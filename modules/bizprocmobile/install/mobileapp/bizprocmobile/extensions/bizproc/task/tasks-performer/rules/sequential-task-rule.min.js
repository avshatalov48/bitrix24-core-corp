jn.define("bizproc/task/tasks-performer/rules/sequential-task-rule",((s,t,e)=>{const{Rule:a}=s("bizproc/task/tasks-performer/rules/rule");const{TaskHashRule:r}=s("bizproc/task/tasks-performer/rules/task-hash-rule");class o extends a{static isApplicable(s,t){return true}async start(){return this.showNextTask()}async showNextTask(){const s=this.tasks.shift();if(!s){return Promise.resolve()}const{doTaskRequest:t,delegateRequest:e,finishRule:a}=await this.showTask(s);if(a===true){return Promise.reject()}if(!t&&!e){return this.showNextTask()}if(r.isApplicable(this.tasks,s)){const{hashTasks:a,otherTasks:o}=this.separateTasksByHash(s.hash);this.tasks=o;const i=new r({doTaskRequest:t,delegateRequest:e,layout:this.layout,tasks:a,onTasksCancel:this.props.onTasksCancel,onTaskNotFoundError:this.props.onTaskNotFoundError,onTasksCompleted:this.onTasksCompleted.bind(this),onTasksDelegated:this.onTasksDelegated.bind(this),generateExitButton:this.generateExitButton});let n=false;await i.start().catch((()=>{n=true}));if(n){return Promise.reject()}}return this.showNextTask()}separateTasksByHash(s){const t=[];const e=[];for(const a of this.tasks){if(a.hash===s){t.push(a)}else{e.push(a)}}return{hashTasks:t,otherTasks:e}}}e.exports={SequentialTaskRule:o}}));
//# sourceMappingURL=sequential-task-rule.map.js