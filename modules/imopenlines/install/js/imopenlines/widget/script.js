// widget bundle

// file: /bitrix/js/main/core/minimal/dist/main.core.minimal.bundle.js
;(function() {

	if (typeof window.BX === 'function')
	{
		return;
	}

/**
 * Babel external helpers
 * (c) 2018 Babel
 * @license MIT
 */
(function (global) {
  var babelHelpers = global.babelHelpers = {};

  function _typeof(obj) {
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      babelHelpers.typeof = _typeof = function (obj) {
        return typeof obj;
      };
    } else {
      babelHelpers.typeof = _typeof = function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof(obj);
  }

  babelHelpers.typeof = _typeof;
  var REACT_ELEMENT_TYPE;

  function _createRawReactElement(type, props, key, children) {
    if (!REACT_ELEMENT_TYPE) {
      REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7;
    }

    var defaultProps = type && type.defaultProps;
    var childrenLength = arguments.length - 3;

    if (!props && childrenLength !== 0) {
      props = {
        children: void 0
      };
    }

    if (props && defaultProps) {
      for (var propName in defaultProps) {
        if (props[propName] === void 0) {
          props[propName] = defaultProps[propName];
        }
      }
    } else if (!props) {
      props = defaultProps || {};
    }

    if (childrenLength === 1) {
      props.children = children;
    } else if (childrenLength > 1) {
      var childArray = new Array(childrenLength);

      for (var i = 0; i < childrenLength; i++) {
        childArray[i] = arguments[i + 3];
      }

      props.children = childArray;
    }

    return {
      $$typeof: REACT_ELEMENT_TYPE,
      type: type,
      key: key === undefined ? null : '' + key,
      ref: null,
      props: props,
      _owner: null
    };
  }

  babelHelpers.jsx = _createRawReactElement;

  function _asyncIterator(iterable) {
    var method;

    if (typeof Symbol === "function") {
      if (Symbol.asyncIterator) {
        method = iterable[Symbol.asyncIterator];
        if (method != null) return method.call(iterable);
      }

      if (Symbol.iterator) {
        method = iterable[Symbol.iterator];
        if (method != null) return method.call(iterable);
      }
    }

    throw new TypeError("Object is not async iterable");
  }

  babelHelpers.asyncIterator = _asyncIterator;

  function _AwaitValue(value) {
    this.wrapped = value;
  }

  babelHelpers.AwaitValue = _AwaitValue;

  function AsyncGenerator(gen) {
    var front, back;

    function send(key, arg) {
      return new Promise(function (resolve, reject) {
        var request = {
          key: key,
          arg: arg,
          resolve: resolve,
          reject: reject,
          next: null
        };

        if (back) {
          back = back.next = request;
        } else {
          front = back = request;
          resume(key, arg);
        }
      });
    }

    function resume(key, arg) {
      try {
        var result = gen[key](arg);
        var value = result.value;
        var wrappedAwait = value instanceof babelHelpers.AwaitValue;
        Promise.resolve(wrappedAwait ? value.wrapped : value).then(function (arg) {
          if (wrappedAwait) {
            resume("next", arg);
            return;
          }

          settle(result.done ? "return" : "normal", arg);
        }, function (err) {
          resume("throw", err);
        });
      } catch (err) {
        settle("throw", err);
      }
    }

    function settle(type, value) {
      switch (type) {
        case "return":
          front.resolve({
            value: value,
            done: true
          });
          break;

        case "throw":
          front.reject(value);
          break;

        default:
          front.resolve({
            value: value,
            done: false
          });
          break;
      }

      front = front.next;

      if (front) {
        resume(front.key, front.arg);
      } else {
        back = null;
      }
    }

    this._invoke = send;

    if (typeof gen.return !== "function") {
      this.return = undefined;
    }
  }

  if (typeof Symbol === "function" && Symbol.asyncIterator) {
    AsyncGenerator.prototype[Symbol.asyncIterator] = function () {
      return this;
    };
  }

  AsyncGenerator.prototype.next = function (arg) {
    return this._invoke("next", arg);
  };

  AsyncGenerator.prototype.throw = function (arg) {
    return this._invoke("throw", arg);
  };

  AsyncGenerator.prototype.return = function (arg) {
    return this._invoke("return", arg);
  };

  babelHelpers.AsyncGenerator = AsyncGenerator;

  function _wrapAsyncGenerator(fn) {
    return function () {
      return new babelHelpers.AsyncGenerator(fn.apply(this, arguments));
    };
  }

  babelHelpers.wrapAsyncGenerator = _wrapAsyncGenerator;

  function _awaitAsyncGenerator(value) {
    return new babelHelpers.AwaitValue(value);
  }

  babelHelpers.awaitAsyncGenerator = _awaitAsyncGenerator;

  function _asyncGeneratorDelegate(inner, awaitWrap) {
    var iter = {},
        waiting = false;

    function pump(key, value) {
      waiting = true;
      value = new Promise(function (resolve) {
        resolve(inner[key](value));
      });
      return {
        done: false,
        value: awaitWrap(value)
      };
    }

    ;

    if (typeof Symbol === "function" && Symbol.iterator) {
      iter[Symbol.iterator] = function () {
        return this;
      };
    }

    iter.next = function (value) {
      if (waiting) {
        waiting = false;
        return value;
      }

      return pump("next", value);
    };

    if (typeof inner.throw === "function") {
      iter.throw = function (value) {
        if (waiting) {
          waiting = false;
          throw value;
        }

        return pump("throw", value);
      };
    }

    if (typeof inner.return === "function") {
      iter.return = function (value) {
        return pump("return", value);
      };
    }

    return iter;
  }

  babelHelpers.asyncGeneratorDelegate = _asyncGeneratorDelegate;

  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }

    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }

  function _asyncToGenerator(fn) {
    return function () {
      var self = this,
          args = arguments;
      return new Promise(function (resolve, reject) {
        var gen = fn.apply(self, args);

        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }

        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }

        _next(undefined);
      });
    };
  }

  babelHelpers.asyncToGenerator = _asyncToGenerator;

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  babelHelpers.classCallCheck = _classCallCheck;

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  babelHelpers.createClass = _createClass;

  function _defineEnumerableProperties(obj, descs) {
    for (var key in descs) {
      var desc = descs[key];
      desc.configurable = desc.enumerable = true;
      if ("value" in desc) desc.writable = true;
      Object.defineProperty(obj, key, desc);
    }

    if (Object.getOwnPropertySymbols) {
      var objectSymbols = Object.getOwnPropertySymbols(descs);

      for (var i = 0; i < objectSymbols.length; i++) {
        var sym = objectSymbols[i];
        var desc = descs[sym];
        desc.configurable = desc.enumerable = true;
        if ("value" in desc) desc.writable = true;
        Object.defineProperty(obj, sym, desc);
      }
    }

    return obj;
  }

  babelHelpers.defineEnumerableProperties = _defineEnumerableProperties;

  function _defaults(obj, defaults) {
    var keys = Object.getOwnPropertyNames(defaults);

    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      var value = Object.getOwnPropertyDescriptor(defaults, key);

      if (value && value.configurable && obj[key] === undefined) {
        Object.defineProperty(obj, key, value);
      }
    }

    return obj;
  }

  babelHelpers.defaults = _defaults;

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  babelHelpers.defineProperty = _defineProperty;

  function _extends() {
    babelHelpers.extends = _extends = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    };

    return _extends.apply(this, arguments);
  }

  babelHelpers.extends = _extends;

  function _objectSpread(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      var ownKeys = Object.keys(source);

      if (typeof Object.getOwnPropertySymbols === 'function') {
        ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }));
      }

      ownKeys.forEach(function (key) {
        babelHelpers.defineProperty(target, key, source[key]);
      });
    }

    return target;
  }

  babelHelpers.objectSpread = _objectSpread;

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) babelHelpers.setPrototypeOf(subClass, superClass);
  }

  babelHelpers.inherits = _inherits;

  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    subClass.__proto__ = superClass;
  }

  babelHelpers.inheritsLoose = _inheritsLoose;

  function _getPrototypeOf(o) {
    babelHelpers.getPrototypeOf = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }

  babelHelpers.getPrototypeOf = _getPrototypeOf;

  function _setPrototypeOf(o, p) {
    babelHelpers.setPrototypeOf = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }

  babelHelpers.setPrototypeOf = _setPrototypeOf;

  function isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  function _construct(Parent, args, Class) {
    if (isNativeReflectConstruct()) {
      babelHelpers.construct = _construct = Reflect.construct;
    } else {
      babelHelpers.construct = _construct = function _construct(Parent, args, Class) {
        var a = [null];
        a.push.apply(a, args);
        var Constructor = Function.bind.apply(Parent, a);
        var instance = new Constructor();
        if (Class) babelHelpers.setPrototypeOf(instance, Class.prototype);
        return instance;
      };
    }

    return _construct.apply(null, arguments);
  }

  babelHelpers.construct = _construct;

  function _isNativeFunction(fn) {
    return Function.toString.call(fn).indexOf("[native code]") !== -1;
  }

  babelHelpers.isNativeFunction = _isNativeFunction;

  function _wrapNativeSuper(Class) {
    var _cache = typeof Map === "function" ? new Map() : undefined;

    babelHelpers.wrapNativeSuper = _wrapNativeSuper = function _wrapNativeSuper(Class) {
      if (Class === null || !babelHelpers.isNativeFunction(Class)) return Class;

      if (typeof Class !== "function") {
        throw new TypeError("Super expression must either be null or a function");
      }

      if (typeof _cache !== "undefined") {
        if (_cache.has(Class)) return _cache.get(Class);

        _cache.set(Class, Wrapper);
      }

      function Wrapper() {
        return babelHelpers.construct(Class, arguments, babelHelpers.getPrototypeOf(this).constructor);
      }

      Wrapper.prototype = Object.create(Class.prototype, {
        constructor: {
          value: Wrapper,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
      return babelHelpers.setPrototypeOf(Wrapper, Class);
    };

    return _wrapNativeSuper(Class);
  }

  babelHelpers.wrapNativeSuper = _wrapNativeSuper;

  function _instanceof(left, right) {
    if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) {
      return right[Symbol.hasInstance](left);
    } else {
      return left instanceof right;
    }
  }

  babelHelpers.instanceof = _instanceof;

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }

  babelHelpers.interopRequireDefault = _interopRequireDefault;

  function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
      return obj;
    } else {
      var newObj = {};

      if (obj != null) {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};

            if (desc.get || desc.set) {
              Object.defineProperty(newObj, key, desc);
            } else {
              newObj[key] = obj[key];
            }
          }
        }
      }

      newObj.default = obj;
      return newObj;
    }
  }

  babelHelpers.interopRequireWildcard = _interopRequireWildcard;

  function _newArrowCheck(innerThis, boundThis) {
    if (innerThis !== boundThis) {
      throw new TypeError("Cannot instantiate an arrow function");
    }
  }

  babelHelpers.newArrowCheck = _newArrowCheck;

  function _objectDestructuringEmpty(obj) {
    if (obj == null) throw new TypeError("Cannot destructure undefined");
  }

  babelHelpers.objectDestructuringEmpty = _objectDestructuringEmpty;

  function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;

    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }

    return target;
  }

  babelHelpers.objectWithoutPropertiesLoose = _objectWithoutPropertiesLoose;

  function _objectWithoutProperties(source, excluded) {
    if (source == null) return {};
    var target = babelHelpers.objectWithoutPropertiesLoose(source, excluded);
    var key, i;

    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

      for (i = 0; i < sourceSymbolKeys.length; i++) {
        key = sourceSymbolKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
        target[key] = source[key];
      }
    }

    return target;
  }

  babelHelpers.objectWithoutProperties = _objectWithoutProperties;

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  babelHelpers.assertThisInitialized = _assertThisInitialized;

  function _possibleConstructorReturn(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
      return call;
    }

    return babelHelpers.assertThisInitialized(self);
  }

  babelHelpers.possibleConstructorReturn = _possibleConstructorReturn;

  function _superPropBase(object, property) {
    while (!Object.prototype.hasOwnProperty.call(object, property)) {
      object = babelHelpers.getPrototypeOf(object);
      if (object === null) break;
    }

    return object;
  }

  babelHelpers.superPropBase = _superPropBase;

  function _get(target, property, receiver) {
    if (typeof Reflect !== "undefined" && Reflect.get) {
      babelHelpers.get = _get = Reflect.get;
    } else {
      babelHelpers.get = _get = function _get(target, property, receiver) {
        var base = babelHelpers.superPropBase(target, property);
        if (!base) return;
        var desc = Object.getOwnPropertyDescriptor(base, property);

        if (desc.get) {
          return desc.get.call(receiver);
        }

        return desc.value;
      };
    }

    return _get(target, property, receiver || target);
  }

  babelHelpers.get = _get;

  function set(target, property, value, receiver) {
    if (typeof Reflect !== "undefined" && Reflect.set) {
      set = Reflect.set;
    } else {
      set = function set(target, property, value, receiver) {
        var base = babelHelpers.superPropBase(target, property);
        var desc;

        if (base) {
          desc = Object.getOwnPropertyDescriptor(base, property);

          if (desc.set) {
            desc.set.call(receiver, value);
            return true;
          } else if (!desc.writable) {
            return false;
          }
        }

        desc = Object.getOwnPropertyDescriptor(receiver, property);

        if (desc) {
          if (!desc.writable) {
            return false;
          }

          desc.value = value;
          Object.defineProperty(receiver, property, desc);
        } else {
          babelHelpers.defineProperty(receiver, property, value);
        }

        return true;
      };
    }

    return set(target, property, value, receiver);
  }

  function _set(target, property, value, receiver, isStrict) {
    var s = set(target, property, value, receiver || target);

    if (!s && isStrict) {
      throw new Error('failed to set property');
    }

    return value;
  }

  babelHelpers.set = _set;

  function _taggedTemplateLiteral(strings, raw) {
    if (!raw) {
      raw = strings.slice(0);
    }

    return Object.freeze(Object.defineProperties(strings, {
      raw: {
        value: Object.freeze(raw)
      }
    }));
  }

  babelHelpers.taggedTemplateLiteral = _taggedTemplateLiteral;

  function _taggedTemplateLiteralLoose(strings, raw) {
    if (!raw) {
      raw = strings.slice(0);
    }

    strings.raw = raw;
    return strings;
  }

  babelHelpers.taggedTemplateLiteralLoose = _taggedTemplateLiteralLoose;

  function _temporalRef(val, name) {
    if (val === babelHelpers.temporalUndefined) {
      throw new ReferenceError(name + " is not defined - temporal dead zone");
    } else {
      return val;
    }
  }

  babelHelpers.temporalRef = _temporalRef;

  function _readOnlyError(name) {
    throw new Error("\"" + name + "\" is read-only");
  }

  babelHelpers.readOnlyError = _readOnlyError;

  function _classNameTDZError(name) {
    throw new Error("Class \"" + name + "\" cannot be referenced in computed property keys.");
  }

  babelHelpers.classNameTDZError = _classNameTDZError;
  babelHelpers.temporalUndefined = {};

  function _slicedToArray(arr, i) {
    return babelHelpers.arrayWithHoles(arr) || babelHelpers.iterableToArrayLimit(arr, i) || babelHelpers.nonIterableRest();
  }

  babelHelpers.slicedToArray = _slicedToArray;

  function _slicedToArrayLoose(arr, i) {
    return babelHelpers.arrayWithHoles(arr) || babelHelpers.iterableToArrayLimitLoose(arr, i) || babelHelpers.nonIterableRest();
  }

  babelHelpers.slicedToArrayLoose = _slicedToArrayLoose;

  function _toArray(arr) {
    return babelHelpers.arrayWithHoles(arr) || babelHelpers.iterableToArray(arr) || babelHelpers.nonIterableRest();
  }

  babelHelpers.toArray = _toArray;

  function _toConsumableArray(arr) {
    return babelHelpers.arrayWithoutHoles(arr) || babelHelpers.iterableToArray(arr) || babelHelpers.nonIterableSpread();
  }

  babelHelpers.toConsumableArray = _toConsumableArray;

  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

      return arr2;
    }
  }

  babelHelpers.arrayWithoutHoles = _arrayWithoutHoles;

  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }

  babelHelpers.arrayWithHoles = _arrayWithHoles;

  function _iterableToArray(iter) {
    if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
  }

  babelHelpers.iterableToArray = _iterableToArray;

  function _iterableToArrayLimit(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  babelHelpers.iterableToArrayLimit = _iterableToArrayLimit;

  function _iterableToArrayLimitLoose(arr, i) {
    var _arr = [];

    for (var _iterator = arr[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) {
      _arr.push(_step.value);

      if (i && _arr.length === i) break;
    }

    return _arr;
  }

  babelHelpers.iterableToArrayLimitLoose = _iterableToArrayLimitLoose;

  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance");
  }

  babelHelpers.nonIterableSpread = _nonIterableSpread;

  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance");
  }

  babelHelpers.nonIterableRest = _nonIterableRest;

  function _skipFirstGeneratorNext(fn) {
    return function () {
      var it = fn.apply(this, arguments);
      it.next();
      return it;
    };
  }

  babelHelpers.skipFirstGeneratorNext = _skipFirstGeneratorNext;

  function _toPropertyKey(key) {
    if (typeof key === "symbol") {
      return key;
    } else {
      return String(key);
    }
  }

  babelHelpers.toPropertyKey = _toPropertyKey;

  function _initializerWarningHelper(descriptor, context) {
    throw new Error('Decorating class property failed. Please ensure that ' + 'proposal-class-properties is enabled and set to use loose mode. ' + 'To use proposal-class-properties in spec mode with decorators, wait for ' + 'the next major version of decorators in stage 2.');
  }

  babelHelpers.initializerWarningHelper = _initializerWarningHelper;

  function _initializerDefineProperty(target, property, descriptor, context) {
    if (!descriptor) return;
    Object.defineProperty(target, property, {
      enumerable: descriptor.enumerable,
      configurable: descriptor.configurable,
      writable: descriptor.writable,
      value: descriptor.initializer ? descriptor.initializer.call(context) : void 0
    });
  }

  babelHelpers.initializerDefineProperty = _initializerDefineProperty;

  function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
    var desc = {};
    Object['ke' + 'ys'](descriptor).forEach(function (key) {
      desc[key] = descriptor[key];
    });
    desc.enumerable = !!desc.enumerable;
    desc.configurable = !!desc.configurable;

    if ('value' in desc || desc.initializer) {
      desc.writable = true;
    }

    desc = decorators.slice().reverse().reduce(function (desc, decorator) {
      return decorator(target, property, desc) || desc;
    }, desc);

    if (context && desc.initializer !== void 0) {
      desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
      desc.initializer = undefined;
    }

    if (desc.initializer === void 0) {
      Object['define' + 'Property'](target, property, desc);
      desc = null;
    }

    return desc;
  }

  babelHelpers.applyDecoratedDescriptor = _applyDecoratedDescriptor;
  var id = 0;

  function _classPrivateFieldKey(name) {
    return "__private_" + id++ + "_" + name;
  }

  babelHelpers.classPrivateFieldLooseKey = _classPrivateFieldKey;

  function _classPrivateFieldBase(receiver, privateKey) {
    if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {
      throw new TypeError("attempted to use private field on non-instance");
    }

    return receiver;
  }

  babelHelpers.classPrivateFieldLooseBase = _classPrivateFieldBase;

  function _classPrivateFieldGet(receiver, privateMap) {
    if (!privateMap.has(receiver)) {
      throw new TypeError("attempted to get private field on non-instance");
    }

    return privateMap.get(receiver).value;
  }

  babelHelpers.classPrivateFieldGet = _classPrivateFieldGet;

  function _classPrivateFieldSet(receiver, privateMap, value) {
    if (!privateMap.has(receiver)) {
      throw new TypeError("attempted to set private field on non-instance");
    }

    var descriptor = privateMap.get(receiver);

    if (!descriptor.writable) {
      throw new TypeError("attempted to set read only private field");
    }

    descriptor.value = value;
    return value;
  }

  babelHelpers.classPrivateFieldSet = _classPrivateFieldSet;
})(typeof global === "undefined" ? window : global);

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

!(function(global) {
	"use strict";

	var Op = Object.prototype;
	var hasOwn = Op.hasOwnProperty;
	var undefined; // More compressible than void 0.
	var $Symbol = typeof Symbol === "function" ? Symbol : {};
	var iteratorSymbol = $Symbol.iterator || "@@iterator";
	var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
	var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

	// Define the runtime globally (as expected by generated code) as either
	// module.exports (if we're in a module) or a new, empty object.
	var runtime = global.regeneratorRuntime = {};

	function wrap(innerFn, outerFn, self, tryLocsList) {
		// If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
		var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
		var generator = Object.create(protoGenerator.prototype);
		var context = new Context(tryLocsList || []);

		// The ._invoke method unifies the implementations of the .next,
		// .throw, and .return methods.
		generator._invoke = makeInvokeMethod(innerFn, self, context);

		return generator;
	}
	runtime.wrap = wrap;

	// Try/catch helper to minimize deoptimizations. Returns a completion
	// record like context.tryEntries[i].completion. This interface could
	// have been (and was previously) designed to take a closure to be
	// invoked without arguments, but in all the cases we care about we
	// already have an existing method we want to call, so there's no need
	// to create a new function object. We can even get away with assuming
	// the method takes exactly one argument, since that happens to be true
	// in every case, so we don't have to touch the arguments object. The
	// only additional allocation required is the completion record, which
	// has a stable shape and so hopefully should be cheap to allocate.
	function tryCatch(fn, obj, arg) {
		try {
			return { type: "normal", arg: fn.call(obj, arg) };
		} catch (err) {
			return { type: "throw", arg: err };
		}
	}

	var GenStateSuspendedStart = "suspendedStart";
	var GenStateSuspendedYield = "suspendedYield";
	var GenStateExecuting = "executing";
	var GenStateCompleted = "completed";

	// Returning this object from the innerFn has the same effect as
	// breaking out of the dispatch switch statement.
	var ContinueSentinel = {};

	// Dummy constructor functions that we use as the .constructor and
	// .constructor.prototype properties for functions that return Generator
	// objects. For full spec compliance, you may wish to configure your
	// minifier not to mangle the names of these two functions.
	function Generator() {}
	function GeneratorFunction() {}
	function GeneratorFunctionPrototype() {}

	// This is a polyfill for %IteratorPrototype% for environments that
	// don't natively support it.
	var IteratorPrototype = {};
	IteratorPrototype[iteratorSymbol] = function () {
		return this;
	};

	var getProto = Object.getPrototypeOf;
	var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
	if (NativeIteratorPrototype &&
		NativeIteratorPrototype !== Op &&
		hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
		// This environment has a native %IteratorPrototype%; use it instead
		// of the polyfill.
		IteratorPrototype = NativeIteratorPrototype;
	}

	var Gp = GeneratorFunctionPrototype.prototype =
		Generator.prototype = Object.create(IteratorPrototype);
	GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
	GeneratorFunctionPrototype.constructor = GeneratorFunction;
	GeneratorFunctionPrototype[toStringTagSymbol] =
		GeneratorFunction.displayName = "GeneratorFunction";

	// Helper for defining the .next, .throw, and .return methods of the
	// Iterator interface in terms of a single ._invoke method.
	function defineIteratorMethods(prototype) {
		["next", "throw", "return"].forEach(function(method) {
			prototype[method] = function(arg) {
				return this._invoke(method, arg);
			};
		});
	}

	runtime.isGeneratorFunction = function(genFun) {
		var ctor = typeof genFun === "function" && genFun.constructor;
		return ctor
			? ctor === GeneratorFunction ||
			// For the native GeneratorFunction constructor, the best we can
			// do is to check its .name property.
			(ctor.displayName || ctor.name) === "GeneratorFunction"
			: false;
	};

	runtime.mark = function(genFun) {
		if (Object.setPrototypeOf) {
			Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
		} else {
			genFun.__proto__ = GeneratorFunctionPrototype;
			if (!(toStringTagSymbol in genFun)) {
				genFun[toStringTagSymbol] = "GeneratorFunction";
			}
		}
		genFun.prototype = Object.create(Gp);
		return genFun;
	};

	// Within the body of any async function, `await x` is transformed to
	// `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
	// `hasOwn.call(value, "__await")` to determine if the yielded value is
	// meant to be awaited.
	runtime.awrap = function(arg) {
		return { __await: arg };
	};

	function AsyncIterator(generator) {
		function invoke(method, arg, resolve, reject) {
			var record = tryCatch(generator[method], generator, arg);
			if (record.type === "throw") {
				reject(record.arg);
			} else {
				var result = record.arg;
				var value = result.value;
				if (value &&
					typeof value === "object" &&
					hasOwn.call(value, "__await")) {
					return Promise.resolve(value.__await).then(function(value) {
						invoke("next", value, resolve, reject);
					}, function(err) {
						invoke("throw", err, resolve, reject);
					});
				}

				return Promise.resolve(value).then(function(unwrapped) {
					// When a yielded Promise is resolved, its final value becomes
					// the .value of the Promise<{value,done}> result for the
					// current iteration. If the Promise is rejected, however, the
					// result for this iteration will be rejected with the same
					// reason. Note that rejections of yielded Promises are not
					// thrown back into the generator function, as is the case
					// when an awaited Promise is rejected. This difference in
					// behavior between yield and await is important, because it
					// allows the consumer to decide what to do with the yielded
					// rejection (swallow it and continue, manually .throw it back
					// into the generator, abandon iteration, whatever). With
					// await, by contrast, there is no opportunity to examine the
					// rejection reason outside the generator function, so the
					// only option is to throw it from the await expression, and
					// let the generator function handle the exception.
					result.value = unwrapped;
					resolve(result);
				}, reject);
			}
		}

		var previousPromise;

		function enqueue(method, arg) {
			function callInvokeWithMethodAndArg() {
				return new Promise(function(resolve, reject) {
					invoke(method, arg, resolve, reject);
				});
			}

			return previousPromise =
				// If enqueue has been called before, then we want to wait until
				// all previous Promises have been resolved before calling invoke,
				// so that results are always delivered in the correct order. If
				// enqueue has not been called before, then it is important to
				// call invoke immediately, without waiting on a callback to fire,
				// so that the async generator function has the opportunity to do
				// any necessary setup in a predictable way. This predictability
				// is why the Promise constructor synchronously invokes its
				// executor callback, and why async functions synchronously
				// execute code before the first await. Since we implement simple
				// async functions in terms of async generators, it is especially
				// important to get this right, even though it requires care.
				previousPromise ? previousPromise.then(
					callInvokeWithMethodAndArg,
					// Avoid propagating failures to Promises returned by later
					// invocations of the iterator.
					callInvokeWithMethodAndArg
				) : callInvokeWithMethodAndArg();
		}

		// Define the unified helper method that is used to implement .next,
		// .throw, and .return (see defineIteratorMethods).
		this._invoke = enqueue;
	}

	defineIteratorMethods(AsyncIterator.prototype);
	AsyncIterator.prototype[asyncIteratorSymbol] = function () {
		return this;
	};
	runtime.AsyncIterator = AsyncIterator;

	// Note that simple async functions are implemented on top of
	// AsyncIterator objects; they just return a Promise for the value of
	// the final result produced by the iterator.
	runtime.async = function(innerFn, outerFn, self, tryLocsList) {
		var iter = new AsyncIterator(
			wrap(innerFn, outerFn, self, tryLocsList)
		);

		return runtime.isGeneratorFunction(outerFn)
			? iter // If outerFn is a generator, return the full iterator.
			: iter.next().then(function(result) {
				return result.done ? result.value : iter.next();
			});
	};

	function makeInvokeMethod(innerFn, self, context) {
		var state = GenStateSuspendedStart;

		return function invoke(method, arg) {
			if (state === GenStateExecuting) {
				throw new Error("Generator is already running");
			}

			if (state === GenStateCompleted) {
				if (method === "throw") {
					throw arg;
				}

				// Be forgiving, per 25.3.3.3.3 of the spec:
				// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
				return doneResult();
			}

			context.method = method;
			context.arg = arg;

			while (true) {
				var delegate = context.delegate;
				if (delegate) {
					var delegateResult = maybeInvokeDelegate(delegate, context);
					if (delegateResult) {
						if (delegateResult === ContinueSentinel) continue;
						return delegateResult;
					}
				}

				if (context.method === "next") {
					// Setting context._sent for legacy support of Babel's
					// function.sent implementation.
					context.sent = context._sent = context.arg;

				} else if (context.method === "throw") {
					if (state === GenStateSuspendedStart) {
						state = GenStateCompleted;
						throw context.arg;
					}

					context.dispatchException(context.arg);

				} else if (context.method === "return") {
					context.abrupt("return", context.arg);
				}

				state = GenStateExecuting;

				var record = tryCatch(innerFn, self, context);
				if (record.type === "normal") {
					// If an exception is thrown from innerFn, we leave state ===
					// GenStateExecuting and loop back for another invocation.
					state = context.done
						? GenStateCompleted
						: GenStateSuspendedYield;

					if (record.arg === ContinueSentinel) {
						continue;
					}

					return {
						value: record.arg,
						done: context.done
					};

				} else if (record.type === "throw") {
					state = GenStateCompleted;
					// Dispatch the exception by looping back around to the
					// context.dispatchException(context.arg) call above.
					context.method = "throw";
					context.arg = record.arg;
				}
			}
		};
	}

	// Call delegate.iterator[context.method](context.arg) and handle the
	// result, either by returning a { value, done } result from the
	// delegate iterator, or by modifying context.method and context.arg,
	// setting context.delegate to null, and returning the ContinueSentinel.
	function maybeInvokeDelegate(delegate, context) {
		var method = delegate.iterator[context.method];
		if (method === undefined) {
			// A .throw or .return when the delegate iterator has no .throw
			// method always terminates the yield* loop.
			context.delegate = null;

			if (context.method === "throw") {
				if (delegate.iterator.return) {
					// If the delegate iterator has a return method, give it a
					// chance to clean up.
					context.method = "return";
					context.arg = undefined;
					maybeInvokeDelegate(delegate, context);

					if (context.method === "throw") {
						// If maybeInvokeDelegate(context) changed context.method from
						// "return" to "throw", let that override the TypeError below.
						return ContinueSentinel;
					}
				}

				context.method = "throw";
				context.arg = new TypeError(
					"The iterator does not provide a 'throw' method");
			}

			return ContinueSentinel;
		}

		var record = tryCatch(method, delegate.iterator, context.arg);

		if (record.type === "throw") {
			context.method = "throw";
			context.arg = record.arg;
			context.delegate = null;
			return ContinueSentinel;
		}

		var info = record.arg;

		if (! info) {
			context.method = "throw";
			context.arg = new TypeError("iterator result is not an object");
			context.delegate = null;
			return ContinueSentinel;
		}

		if (info.done) {
			// Assign the result of the finished delegate to the temporary
			// variable specified by delegate.resultName (see delegateYield).
			context[delegate.resultName] = info.value;

			// Resume execution at the desired location (see delegateYield).
			context.next = delegate.nextLoc;

			// If context.method was "throw" but the delegate handled the
			// exception, let the outer generator proceed normally. If
			// context.method was "next", forget context.arg since it has been
			// "consumed" by the delegate iterator. If context.method was
			// "return", allow the original .return call to continue in the
			// outer generator.
			if (context.method !== "return") {
				context.method = "next";
				context.arg = undefined;
			}

		} else {
			// Re-yield the result returned by the delegate method.
			return info;
		}

		// The delegate iterator is finished, so forget it and continue with
		// the outer generator.
		context.delegate = null;
		return ContinueSentinel;
	}

	// Define Generator.prototype.{next,throw,return} in terms of the
	// unified ._invoke helper method.
	defineIteratorMethods(Gp);

	Gp[toStringTagSymbol] = "Generator";

	// A Generator should always return itself as the iterator object when the
	// @@iterator function is called on it. Some browsers' implementations of the
	// iterator prototype chain incorrectly implement this, causing the Generator
	// object to not be returned from this call. This ensures that doesn't happen.
	// See https://github.com/facebook/regenerator/issues/274 for more details.
	Gp[iteratorSymbol] = function() {
		return this;
	};

	Gp.toString = function() {
		return "[object Generator]";
	};

	function pushTryEntry(locs) {
		var entry = { tryLoc: locs[0] };

		if (1 in locs) {
			entry.catchLoc = locs[1];
		}

		if (2 in locs) {
			entry.finallyLoc = locs[2];
			entry.afterLoc = locs[3];
		}

		this.tryEntries.push(entry);
	}

	function resetTryEntry(entry) {
		var record = entry.completion || {};
		record.type = "normal";
		delete record.arg;
		entry.completion = record;
	}

	function Context(tryLocsList) {
		// The root entry object (effectively a try statement without a catch
		// or a finally block) gives us a place to store values thrown from
		// locations where there is no enclosing try statement.
		this.tryEntries = [{ tryLoc: "root" }];
		tryLocsList.forEach(pushTryEntry, this);
		this.reset(true);
	}

	runtime.keys = function(object) {
		var keys = [];
		for (var key in object) {
			keys.push(key);
		}
		keys.reverse();

		// Rather than returning an object with a next method, we keep
		// things simple and return the next function itself.
		return function next() {
			while (keys.length) {
				var key = keys.pop();
				if (key in object) {
					next.value = key;
					next.done = false;
					return next;
				}
			}

			// To avoid creating an additional object, we just hang the .value
			// and .done properties off the next function object itself. This
			// also ensures that the minifier will not anonymize the function.
			next.done = true;
			return next;
		};
	};

	function values(iterable) {
		if (iterable) {
			var iteratorMethod = iterable[iteratorSymbol];
			if (iteratorMethod) {
				return iteratorMethod.call(iterable);
			}

			if (typeof iterable.next === "function") {
				return iterable;
			}

			if (!isNaN(iterable.length)) {
				var i = -1, next = function next() {
					while (++i < iterable.length) {
						if (hasOwn.call(iterable, i)) {
							next.value = iterable[i];
							next.done = false;
							return next;
						}
					}

					next.value = undefined;
					next.done = true;

					return next;
				};

				return next.next = next;
			}
		}

		// Return an iterator with no values.
		return { next: doneResult };
	}
	runtime.values = values;

	function doneResult() {
		return { value: undefined, done: true };
	}

	Context.prototype = {
		constructor: Context,

		reset: function(skipTempReset) {
			this.prev = 0;
			this.next = 0;
			// Resetting context._sent for legacy support of Babel's
			// function.sent implementation.
			this.sent = this._sent = undefined;
			this.done = false;
			this.delegate = null;

			this.method = "next";
			this.arg = undefined;

			this.tryEntries.forEach(resetTryEntry);

			if (!skipTempReset) {
				for (var name in this) {
					// Not sure about the optimal order of these conditions:
					if (name.charAt(0) === "t" &&
						hasOwn.call(this, name) &&
						!isNaN(+name.slice(1))) {
						this[name] = undefined;
					}
				}
			}
		},

		stop: function() {
			this.done = true;

			var rootEntry = this.tryEntries[0];
			var rootRecord = rootEntry.completion;
			if (rootRecord.type === "throw") {
				throw rootRecord.arg;
			}

			return this.rval;
		},

		dispatchException: function(exception) {
			if (this.done) {
				throw exception;
			}

			var context = this;
			function handle(loc, caught) {
				record.type = "throw";
				record.arg = exception;
				context.next = loc;

				if (caught) {
					// If the dispatched exception was caught by a catch block,
					// then let that catch block handle the exception normally.
					context.method = "next";
					context.arg = undefined;
				}

				return !! caught;
			}

			for (var i = this.tryEntries.length - 1; i >= 0; --i) {
				var entry = this.tryEntries[i];
				var record = entry.completion;

				if (entry.tryLoc === "root") {
					// Exception thrown outside of any try block that could handle
					// it, so set the completion value of the entire function to
					// throw the exception.
					return handle("end");
				}

				if (entry.tryLoc <= this.prev) {
					var hasCatch = hasOwn.call(entry, "catchLoc");
					var hasFinally = hasOwn.call(entry, "finallyLoc");

					if (hasCatch && hasFinally) {
						if (this.prev < entry.catchLoc) {
							return handle(entry.catchLoc, true);
						} else if (this.prev < entry.finallyLoc) {
							return handle(entry.finallyLoc);
						}

					} else if (hasCatch) {
						if (this.prev < entry.catchLoc) {
							return handle(entry.catchLoc, true);
						}

					} else if (hasFinally) {
						if (this.prev < entry.finallyLoc) {
							return handle(entry.finallyLoc);
						}

					} else {
						throw new Error("try statement without catch or finally");
					}
				}
			}
		},

		abrupt: function(type, arg) {
			for (var i = this.tryEntries.length - 1; i >= 0; --i) {
				var entry = this.tryEntries[i];
				if (entry.tryLoc <= this.prev &&
					hasOwn.call(entry, "finallyLoc") &&
					this.prev < entry.finallyLoc) {
					var finallyEntry = entry;
					break;
				}
			}

			if (finallyEntry &&
				(type === "break" ||
					type === "continue") &&
				finallyEntry.tryLoc <= arg &&
				arg <= finallyEntry.finallyLoc) {
				// Ignore the finally entry if control is not jumping to a
				// location outside the try/catch block.
				finallyEntry = null;
			}

			var record = finallyEntry ? finallyEntry.completion : {};
			record.type = type;
			record.arg = arg;

			if (finallyEntry) {
				this.method = "next";
				this.next = finallyEntry.finallyLoc;
				return ContinueSentinel;
			}

			return this.complete(record);
		},

		complete: function(record, afterLoc) {
			if (record.type === "throw") {
				throw record.arg;
			}

			if (record.type === "break" ||
				record.type === "continue") {
				this.next = record.arg;
			} else if (record.type === "return") {
				this.rval = this.arg = record.arg;
				this.method = "return";
				this.next = "end";
			} else if (record.type === "normal" && afterLoc) {
				this.next = afterLoc;
			}

			return ContinueSentinel;
		},

		finish: function(finallyLoc) {
			for (var i = this.tryEntries.length - 1; i >= 0; --i) {
				var entry = this.tryEntries[i];
				if (entry.finallyLoc === finallyLoc) {
					this.complete(entry.completion, entry.afterLoc);
					resetTryEntry(entry);
					return ContinueSentinel;
				}
			}
		},

		"catch": function(tryLoc) {
			for (var i = this.tryEntries.length - 1; i >= 0; --i) {
				var entry = this.tryEntries[i];
				if (entry.tryLoc === tryLoc) {
					var record = entry.completion;
					if (record.type === "throw") {
						var thrown = record.arg;
						resetTryEntry(entry);
					}
					return thrown;
				}
			}

			// The context.catch method must only be called with a location
			// argument that corresponds to a known catch block.
			throw new Error("illegal catch attempt");
		},

		delegateYield: function(iterable, resultName, nextLoc) {
			this.delegate = {
				iterator: values(iterable),
				resultName: resultName,
				nextLoc: nextLoc
			};

			if (this.method === "next") {
				// Deliberately forget the last sent value so that we don't
				// accidentally pass it on to the delegate.
				this.arg = undefined;
			}

			return ContinueSentinel;
		}
	};
})(
	// In sloppy mode, unbound `this` refers to the global object, fallback to
	// Function constructor if we're in global strict mode. That is sadly a form
	// of indirect eval which violates Content Security Policy.
	(function() { return this })() || Function("return this")()
);

(function (exports) {
	'use strict';

	function createCommonjsModule(fn, module) {
	  return module = {
	    exports: {}
	  }, fn(module, module.exports), module.exports;
	}

	var _global = createCommonjsModule(function (module) {
	// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
	var global = module.exports = typeof window != 'undefined' && window.Math == Math ? window : typeof self != 'undefined' && self.Math == Math ? self // eslint-disable-next-line no-new-func
	: Function('return this')();
	if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef
	});

	var hasOwnProperty = {}.hasOwnProperty;

	var _has = function (it, key) {
	  return hasOwnProperty.call(it, key);
	};

	var _fails = function (exec) {
	  try {
	    return !!exec();
	  } catch (e) {
	    return true;
	  }
	};

	// Thank's IE8 for his funny defineProperty
	var _descriptors = !_fails(function () {
	  return Object.defineProperty({}, 'a', {
	    get: function get() {
	      return 7;
	    }
	  }).a != 7;
	});

	var _core = createCommonjsModule(function (module) {
	var core = module.exports = {
	  version: '2.6.3'
	};
	if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef
	});
	var _core_1 = _core.version;

	var _isObject = function (it) {
	  return babelHelpers.typeof(it) === 'object' ? it !== null : typeof it === 'function';
	};

	var _anObject = function (it) {
	  if (!_isObject(it)) throw TypeError(it + ' is not an object!');
	  return it;
	};

	var document$1 = _global.document; // typeof document.createElement is 'object' in old IE


	var is = _isObject(document$1) && _isObject(document$1.createElement);

	var _domCreate = function (it) {
	  return is ? document$1.createElement(it) : {};
	};

	var _ie8DomDefine = !_descriptors && !_fails(function () {
	  return Object.defineProperty(_domCreate('div'), 'a', {
	    get: function get() {
	      return 7;
	    }
	  }).a != 7;
	});

	// 7.1.1 ToPrimitive(input [, PreferredType])
	 // instead of the ES6 spec version, we didn't implement @@toPrimitive case
	// and the second argument - flag - preferred type is a string


	var _toPrimitive = function (it, S) {
	  if (!_isObject(it)) return it;
	  var fn, val;
	  if (S && typeof (fn = it.toString) == 'function' && !_isObject(val = fn.call(it))) return val;
	  if (typeof (fn = it.valueOf) == 'function' && !_isObject(val = fn.call(it))) return val;
	  if (!S && typeof (fn = it.toString) == 'function' && !_isObject(val = fn.call(it))) return val;
	  throw TypeError("Can't convert object to primitive value");
	};

	var dP = Object.defineProperty;
	var f = _descriptors ? Object.defineProperty : function defineProperty(O, P, Attributes) {
	  _anObject(O);
	  P = _toPrimitive(P, true);
	  _anObject(Attributes);
	  if (_ie8DomDefine) try {
	    return dP(O, P, Attributes);
	  } catch (e) {
	    /* empty */
	  }
	  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
	  if ('value' in Attributes) O[P] = Attributes.value;
	  return O;
	};

	var _objectDp = {
		f: f
	};

	var _propertyDesc = function (bitmap, value) {
	  return {
	    enumerable: !(bitmap & 1),
	    configurable: !(bitmap & 2),
	    writable: !(bitmap & 4),
	    value: value
	  };
	};

	var _hide = _descriptors ? function (object, key, value) {
	  return _objectDp.f(object, key, _propertyDesc(1, value));
	} : function (object, key, value) {
	  object[key] = value;
	  return object;
	};

	var id = 0;
	var px = Math.random();

	var _uid = function (key) {
	  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
	};

	var _redefine = createCommonjsModule(function (module) {
	var SRC = _uid('src');

	var TO_STRING = 'toString';
	var $toString = Function[TO_STRING];
	var TPL = ('' + $toString).split(TO_STRING);

	_core.inspectSource = function (it) {
	  return $toString.call(it);
	};

	(module.exports = function (O, key, val, safe) {
	  var isFunction = typeof val == 'function';
	  if (isFunction) _has(val, 'name') || _hide(val, 'name', key);
	  if (O[key] === val) return;
	  if (isFunction) _has(val, SRC) || _hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));

	  if (O === _global) {
	    O[key] = val;
	  } else if (!safe) {
	    delete O[key];
	    _hide(O, key, val);
	  } else if (O[key]) {
	    O[key] = val;
	  } else {
	    _hide(O, key, val);
	  } // add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative

	})(Function.prototype, TO_STRING, function toString() {
	  return typeof this == 'function' && this[SRC] || $toString.call(this);
	});
	});

	var _aFunction = function (it) {
	  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
	  return it;
	};

	// optional / simple context binding


	var _ctx = function (fn, that, length) {
	  _aFunction(fn);
	  if (that === undefined) return fn;

	  switch (length) {
	    case 1:
	      return function (a) {
	        return fn.call(that, a);
	      };

	    case 2:
	      return function (a, b) {
	        return fn.call(that, a, b);
	      };

	    case 3:
	      return function (a, b, c) {
	        return fn.call(that, a, b, c);
	      };
	  }

	  return function ()
	  /* ...args */
	  {
	    return fn.apply(that, arguments);
	  };
	};

	var PROTOTYPE = 'prototype';

	var $export = function $export(type, name, source) {
	  var IS_FORCED = type & $export.F;
	  var IS_GLOBAL = type & $export.G;
	  var IS_STATIC = type & $export.S;
	  var IS_PROTO = type & $export.P;
	  var IS_BIND = type & $export.B;
	  var target = IS_GLOBAL ? _global : IS_STATIC ? _global[name] || (_global[name] = {}) : (_global[name] || {})[PROTOTYPE];
	  var exports = IS_GLOBAL ? _core : _core[name] || (_core[name] = {});
	  var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});
	  var key, own, out, exp;
	  if (IS_GLOBAL) source = name;

	  for (key in source) {
	    // contains in native
	    own = !IS_FORCED && target && target[key] !== undefined; // export native or passed

	    out = (own ? target : source)[key]; // bind timers to global for call from export context

	    exp = IS_BIND && own ? _ctx(out, _global) : IS_PROTO && typeof out == 'function' ? _ctx(Function.call, out) : out; // extend global

	    if (target) _redefine(target, key, out, type & $export.U); // export

	    if (exports[key] != out) _hide(exports, key, exp);
	    if (IS_PROTO && expProto[key] != out) expProto[key] = out;
	  }
	};

	$export.F = 1; // forced

	$export.G = 2; // global

	$export.S = 4; // static

	$export.P = 8; // proto

	$export.B = 16; // bind

	$export.W = 32; // wrap

	$export.U = 64; // safe

	$export.R = 128; // real proto method for `library`

	var _export = $export;

	var _meta = createCommonjsModule(function (module) {
	var META = _uid('meta');





	var setDesc = _objectDp.f;

	var id = 0;

	var isExtensible = Object.isExtensible || function () {
	  return true;
	};

	var FREEZE = !_fails(function () {
	  return isExtensible(Object.preventExtensions({}));
	});

	var setMeta = function setMeta(it) {
	  setDesc(it, META, {
	    value: {
	      i: 'O' + ++id,
	      // object ID
	      w: {} // weak collections IDs

	    }
	  });
	};

	var fastKey = function fastKey(it, create) {
	  // return primitive with prefix
	  if (!_isObject(it)) return babelHelpers.typeof(it) == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;

	  if (!_has(it, META)) {
	    // can't set metadata to uncaught frozen object
	    if (!isExtensible(it)) return 'F'; // not necessary to add metadata

	    if (!create) return 'E'; // add missing metadata

	    setMeta(it); // return object ID
	  }

	  return it[META].i;
	};

	var getWeak = function getWeak(it, create) {
	  if (!_has(it, META)) {
	    // can't set metadata to uncaught frozen object
	    if (!isExtensible(it)) return true; // not necessary to add metadata

	    if (!create) return false; // add missing metadata

	    setMeta(it); // return hash weak collections IDs
	  }

	  return it[META].w;
	}; // add metadata on freeze-family methods calling


	var onFreeze = function onFreeze(it) {
	  if (FREEZE && meta.NEED && isExtensible(it) && !_has(it, META)) setMeta(it);
	  return it;
	};

	var meta = module.exports = {
	  KEY: META,
	  NEED: false,
	  fastKey: fastKey,
	  getWeak: getWeak,
	  onFreeze: onFreeze
	};
	});
	var _meta_1 = _meta.KEY;
	var _meta_2 = _meta.NEED;
	var _meta_3 = _meta.fastKey;
	var _meta_4 = _meta.getWeak;
	var _meta_5 = _meta.onFreeze;

	var _library = false;

	var _shared = createCommonjsModule(function (module) {
	var SHARED = '__core-js_shared__';
	var store = _global[SHARED] || (_global[SHARED] = {});
	(module.exports = function (key, value) {
	  return store[key] || (store[key] = value !== undefined ? value : {});
	})('versions', []).push({
	  version: _core.version,
	  mode: _library ? 'pure' : 'global',
	  copyright: '(c) 2019 Denis Pushkarev (zloirock.ru)'
	});
	});

	var _wks = createCommonjsModule(function (module) {
	var store = _shared('wks');



	var _Symbol = _global.Symbol;

	var USE_SYMBOL = typeof _Symbol == 'function';

	var $exports = module.exports = function (name) {
	  return store[name] || (store[name] = USE_SYMBOL && _Symbol[name] || (USE_SYMBOL ? _Symbol : _uid)('Symbol.' + name));
	};

	$exports.store = store;
	});

	var def = _objectDp.f;



	var TAG = _wks('toStringTag');

	var _setToStringTag = function (it, tag, stat) {
	  if (it && !_has(it = stat ? it : it.prototype, TAG)) def(it, TAG, {
	    configurable: true,
	    value: tag
	  });
	};

	var f$1 = _wks;

	var _wksExt = {
		f: f$1
	};

	var defineProperty = _objectDp.f;

	var _wksDefine = function (name) {
	  var $Symbol = _core.Symbol || (_core.Symbol = _library ? {} : _global.Symbol || {});
	  if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, {
	    value: _wksExt.f(name)
	  });
	};

	var toString = {}.toString;

	var _cof = function (it) {
	  return toString.call(it).slice(8, -1);
	};

	// fallback for non-array-like ES3 and non-enumerable old V8 strings
	 // eslint-disable-next-line no-prototype-builtins


	var _iobject = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
	  return _cof(it) == 'String' ? it.split('') : Object(it);
	};

	// 7.2.1 RequireObjectCoercible(argument)
	var _defined = function (it) {
	  if (it == undefined) throw TypeError("Can't call method on  " + it);
	  return it;
	};

	// to indexed object, toObject with fallback for non-array-like ES3 strings




	var _toIobject = function (it) {
	  return _iobject(_defined(it));
	};

	// 7.1.4 ToInteger
	var ceil = Math.ceil;
	var floor = Math.floor;

	var _toInteger = function (it) {
	  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
	};

	// 7.1.15 ToLength


	var min = Math.min;

	var _toLength = function (it) {
	  return it > 0 ? min(_toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
	};

	var max = Math.max;
	var min$1 = Math.min;

	var _toAbsoluteIndex = function (index, length) {
	  index = _toInteger(index);
	  return index < 0 ? max(index + length, 0) : min$1(index, length);
	};

	// false -> Array#indexOf
	// true  -> Array#includes






	var _arrayIncludes = function (IS_INCLUDES) {
	  return function ($this, el, fromIndex) {
	    var O = _toIobject($this);
	    var length = _toLength(O.length);
	    var index = _toAbsoluteIndex(fromIndex, length);
	    var value; // Array#includes uses SameValueZero equality algorithm
	    // eslint-disable-next-line no-self-compare

	    if (IS_INCLUDES && el != el) while (length > index) {
	      value = O[index++]; // eslint-disable-next-line no-self-compare

	      if (value != value) return true; // Array#indexOf ignores holes, Array#includes - not
	    } else for (; length > index; index++) {
	      if (IS_INCLUDES || index in O) {
	        if (O[index] === el) return IS_INCLUDES || index || 0;
	      }
	    }
	    return !IS_INCLUDES && -1;
	  };
	};

	var shared = _shared('keys');



	var _sharedKey = function (key) {
	  return shared[key] || (shared[key] = _uid(key));
	};

	var arrayIndexOf = _arrayIncludes(false);

	var IE_PROTO = _sharedKey('IE_PROTO');

	var _objectKeysInternal = function (object, names) {
	  var O = _toIobject(object);
	  var i = 0;
	  var result = [];
	  var key;

	  for (key in O) {
	    if (key != IE_PROTO) _has(O, key) && result.push(key);
	  } // Don't enum bug & hidden keys


	  while (names.length > i) {
	    if (_has(O, key = names[i++])) {
	      ~arrayIndexOf(result, key) || result.push(key);
	    }
	  }

	  return result;
	};

	// IE 8- don't enum bug keys
	var _enumBugKeys = 'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'.split(',');

	// 19.1.2.14 / 15.2.3.14 Object.keys(O)




	var _objectKeys = Object.keys || function keys(O) {
	  return _objectKeysInternal(O, _enumBugKeys);
	};

	var f$2 = Object.getOwnPropertySymbols;

	var _objectGops = {
		f: f$2
	};

	var f$3 = {}.propertyIsEnumerable;

	var _objectPie = {
		f: f$3
	};

	// all enumerable object keys, includes symbols






	var _enumKeys = function (it) {
	  var result = _objectKeys(it);
	  var getSymbols = _objectGops.f;

	  if (getSymbols) {
	    var symbols = getSymbols(it);
	    var isEnum = _objectPie.f;
	    var i = 0;
	    var key;

	    while (symbols.length > i) {
	      if (isEnum.call(it, key = symbols[i++])) result.push(key);
	    }
	  }

	  return result;
	};

	// 7.2.2 IsArray(argument)


	var _isArray = Array.isArray || function isArray(arg) {
	  return _cof(arg) == 'Array';
	};

	var _objectDps = _descriptors ? Object.defineProperties : function defineProperties(O, Properties) {
	  _anObject(O);
	  var keys = _objectKeys(Properties);
	  var length = keys.length;
	  var i = 0;
	  var P;

	  while (length > i) {
	    _objectDp.f(O, P = keys[i++], Properties[P]);
	  }

	  return O;
	};

	var document$2 = _global.document;

	var _html = document$2 && document$2.documentElement;

	// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])






	var IE_PROTO$1 = _sharedKey('IE_PROTO');

	var Empty = function Empty() {
	  /* empty */
	};

	var PROTOTYPE$1 = 'prototype'; // Create object with fake `null` prototype: use iframe Object with cleared prototype

	var _createDict = function createDict() {
	  // Thrash, waste and sodomy: IE GC bug
	  var iframe = _domCreate('iframe');

	  var i = _enumBugKeys.length;
	  var lt = '<';
	  var gt = '>';
	  var iframeDocument;
	  iframe.style.display = 'none';

	  _html.appendChild(iframe);

	  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
	  // createDict = iframe.contentWindow.Object;
	  // html.removeChild(iframe);

	  iframeDocument = iframe.contentWindow.document;
	  iframeDocument.open();
	  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
	  iframeDocument.close();
	  _createDict = iframeDocument.F;

	  while (i--) {
	    delete _createDict[PROTOTYPE$1][_enumBugKeys[i]];
	  }

	  return _createDict();
	};

	var _objectCreate = Object.create || function create(O, Properties) {
	  var result;

	  if (O !== null) {
	    Empty[PROTOTYPE$1] = _anObject(O);
	    result = new Empty();
	    Empty[PROTOTYPE$1] = null; // add "__proto__" for Object.getPrototypeOf polyfill

	    result[IE_PROTO$1] = O;
	  } else result = _createDict();

	  return Properties === undefined ? result : _objectDps(result, Properties);
	};

	// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)


	var hiddenKeys = _enumBugKeys.concat('length', 'prototype');

	var f$4 = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
	  return _objectKeysInternal(O, hiddenKeys);
	};

	var _objectGopn = {
		f: f$4
	};

	// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window


	var gOPN = _objectGopn.f;

	var toString$1 = {}.toString;
	var windowNames = (typeof window === "undefined" ? "undefined" : babelHelpers.typeof(window)) == 'object' && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];

	var getWindowNames = function getWindowNames(it) {
	  try {
	    return gOPN(it);
	  } catch (e) {
	    return windowNames.slice();
	  }
	};

	var f$5 = function getOwnPropertyNames(it) {
	  return windowNames && toString$1.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(_toIobject(it));
	};

	var _objectGopnExt = {
		f: f$5
	};

	var gOPD = Object.getOwnPropertyDescriptor;
	var f$6 = _descriptors ? gOPD : function getOwnPropertyDescriptor(O, P) {
	  O = _toIobject(O);
	  P = _toPrimitive(P, true);
	  if (_ie8DomDefine) try {
	    return gOPD(O, P);
	  } catch (e) {
	    /* empty */
	  }
	  if (_has(O, P)) return _propertyDesc(!_objectPie.f.call(O, P), O[P]);
	};

	var _objectGopd = {
		f: f$6
	};

	var META = _meta.KEY;







































	var gOPD$1 = _objectGopd.f;
	var dP$1 = _objectDp.f;
	var gOPN$1 = _objectGopnExt.f;
	var $Symbol = _global.Symbol;
	var $JSON = _global.JSON;

	var _stringify = $JSON && $JSON.stringify;

	var PROTOTYPE$2 = 'prototype';
	var HIDDEN = _wks('_hidden');
	var TO_PRIMITIVE = _wks('toPrimitive');
	var isEnum = {}.propertyIsEnumerable;
	var SymbolRegistry = _shared('symbol-registry');
	var AllSymbols = _shared('symbols');
	var OPSymbols = _shared('op-symbols');
	var ObjectProto = Object[PROTOTYPE$2];
	var USE_NATIVE = typeof $Symbol == 'function';
	var QObject = _global.QObject; // Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173

	var setter = !QObject || !QObject[PROTOTYPE$2] || !QObject[PROTOTYPE$2].findChild; // fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687

	var setSymbolDesc = _descriptors && _fails(function () {
	  return _objectCreate(dP$1({}, 'a', {
	    get: function get() {
	      return dP$1(this, 'a', {
	        value: 7
	      }).a;
	    }
	  })).a != 7;
	}) ? function (it, key, D) {
	  var protoDesc = gOPD$1(ObjectProto, key);
	  if (protoDesc) delete ObjectProto[key];
	  dP$1(it, key, D);
	  if (protoDesc && it !== ObjectProto) dP$1(ObjectProto, key, protoDesc);
	} : dP$1;

	var wrap = function wrap(tag) {
	  var sym = AllSymbols[tag] = _objectCreate($Symbol[PROTOTYPE$2]);

	  sym._k = tag;
	  return sym;
	};

	var isSymbol = USE_NATIVE && babelHelpers.typeof($Symbol.iterator) == 'symbol' ? function (it) {
	  return babelHelpers.typeof(it) == 'symbol';
	} : function (it) {
	  return it instanceof $Symbol;
	};

	var $defineProperty = function defineProperty(it, key, D) {
	  if (it === ObjectProto) $defineProperty(OPSymbols, key, D);
	  _anObject(it);
	  key = _toPrimitive(key, true);
	  _anObject(D);

	  if (_has(AllSymbols, key)) {
	    if (!D.enumerable) {
	      if (!_has(it, HIDDEN)) dP$1(it, HIDDEN, _propertyDesc(1, {}));
	      it[HIDDEN][key] = true;
	    } else {
	      if (_has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
	      D = _objectCreate(D, {
	        enumerable: _propertyDesc(0, false)
	      });
	    }

	    return setSymbolDesc(it, key, D);
	  }

	  return dP$1(it, key, D);
	};

	var $defineProperties = function defineProperties(it, P) {
	  _anObject(it);
	  var keys = _enumKeys(P = _toIobject(P));
	  var i = 0;
	  var l = keys.length;
	  var key;

	  while (l > i) {
	    $defineProperty(it, key = keys[i++], P[key]);
	  }

	  return it;
	};

	var $create = function create(it, P) {
	  return P === undefined ? _objectCreate(it) : $defineProperties(_objectCreate(it), P);
	};

	var $propertyIsEnumerable = function propertyIsEnumerable(key) {
	  var E = isEnum.call(this, key = _toPrimitive(key, true));
	  if (this === ObjectProto && _has(AllSymbols, key) && !_has(OPSymbols, key)) return false;
	  return E || !_has(this, key) || !_has(AllSymbols, key) || _has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
	};

	var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
	  it = _toIobject(it);
	  key = _toPrimitive(key, true);
	  if (it === ObjectProto && _has(AllSymbols, key) && !_has(OPSymbols, key)) return;
	  var D = gOPD$1(it, key);
	  if (D && _has(AllSymbols, key) && !(_has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;
	  return D;
	};

	var $getOwnPropertyNames = function getOwnPropertyNames(it) {
	  var names = gOPN$1(_toIobject(it));
	  var result = [];
	  var i = 0;
	  var key;

	  while (names.length > i) {
	    if (!_has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);
	  }

	  return result;
	};

	var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
	  var IS_OP = it === ObjectProto;
	  var names = gOPN$1(IS_OP ? OPSymbols : _toIobject(it));
	  var result = [];
	  var i = 0;
	  var key;

	  while (names.length > i) {
	    if (_has(AllSymbols, key = names[i++]) && (IS_OP ? _has(ObjectProto, key) : true)) result.push(AllSymbols[key]);
	  }

	  return result;
	}; // 19.4.1.1 Symbol([description])


	if (!USE_NATIVE) {
	  $Symbol = function _Symbol() {
	    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');
	    var tag = _uid(arguments.length > 0 ? arguments[0] : undefined);

	    var $set = function $set(value) {
	      if (this === ObjectProto) $set.call(OPSymbols, value);
	      if (_has(this, HIDDEN) && _has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
	      setSymbolDesc(this, tag, _propertyDesc(1, value));
	    };

	    if (_descriptors && setter) setSymbolDesc(ObjectProto, tag, {
	      configurable: true,
	      set: $set
	    });
	    return wrap(tag);
	  };

	  _redefine($Symbol[PROTOTYPE$2], 'toString', function toString() {
	    return this._k;
	  });
	  _objectGopd.f = $getOwnPropertyDescriptor;
	  _objectDp.f = $defineProperty;
	  _objectGopn.f = _objectGopnExt.f = $getOwnPropertyNames;
	  _objectPie.f = $propertyIsEnumerable;
	  _objectGops.f = $getOwnPropertySymbols;

	  if (_descriptors && !_library) {
	    _redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
	  }

	  _wksExt.f = function (name) {
	    return wrap(_wks(name));
	  };
	}

	_export(_export.G + _export.W + _export.F * !USE_NATIVE, {
	  Symbol: $Symbol
	});

	for (var es6Symbols = // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
	'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'.split(','), j = 0; es6Symbols.length > j;) {
	  _wks(es6Symbols[j++]);
	}

	for (var wellKnownSymbols = _objectKeys(_wks.store), k = 0; wellKnownSymbols.length > k;) {
	  _wksDefine(wellKnownSymbols[k++]);
	}

	_export(_export.S + _export.F * !USE_NATIVE, 'Symbol', {
	  // 19.4.2.1 Symbol.for(key)
	  'for': function _for(key) {
	    return _has(SymbolRegistry, key += '') ? SymbolRegistry[key] : SymbolRegistry[key] = $Symbol(key);
	  },
	  // 19.4.2.5 Symbol.keyFor(sym)
	  keyFor: function keyFor(sym) {
	    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!');

	    for (var key in SymbolRegistry) {
	      if (SymbolRegistry[key] === sym) return key;
	    }
	  },
	  useSetter: function useSetter() {
	    setter = true;
	  },
	  useSimple: function useSimple() {
	    setter = false;
	  }
	});
	_export(_export.S + _export.F * !USE_NATIVE, 'Object', {
	  // 19.1.2.2 Object.create(O [, Properties])
	  create: $create,
	  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
	  defineProperty: $defineProperty,
	  // 19.1.2.3 Object.defineProperties(O, Properties)
	  defineProperties: $defineProperties,
	  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
	  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
	  // 19.1.2.7 Object.getOwnPropertyNames(O)
	  getOwnPropertyNames: $getOwnPropertyNames,
	  // 19.1.2.8 Object.getOwnPropertySymbols(O)
	  getOwnPropertySymbols: $getOwnPropertySymbols
	}); // 24.3.2 JSON.stringify(value [, replacer [, space]])

	$JSON && _export(_export.S + _export.F * (!USE_NATIVE || _fails(function () {
	  var S = $Symbol(); // MS Edge converts symbol values to JSON as {}
	  // WebKit converts symbol values to JSON as null
	  // V8 throws on boxed symbols

	  return _stringify([S]) != '[null]' || _stringify({
	    a: S
	  }) != '{}' || _stringify(Object(S)) != '{}';
	})), 'JSON', {
	  stringify: function stringify(it) {
	    var args = [it];
	    var i = 1;
	    var replacer, $replacer;

	    while (arguments.length > i) {
	      args.push(arguments[i++]);
	    }

	    $replacer = replacer = args[1];
	    if (!_isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined

	    if (!_isArray(replacer)) replacer = function replacer(key, value) {
	      if (typeof $replacer == 'function') value = $replacer.call(this, key, value);
	      if (!isSymbol(value)) return value;
	    };
	    args[1] = replacer;
	    return _stringify.apply($JSON, args);
	  }
	}); // 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)

	$Symbol[PROTOTYPE$2][TO_PRIMITIVE] || _hide($Symbol[PROTOTYPE$2], TO_PRIMITIVE, $Symbol[PROTOTYPE$2].valueOf); // 19.4.3.5 Symbol.prototype[@@toStringTag]

	_setToStringTag($Symbol, 'Symbol'); // 20.2.1.9 Math[@@toStringTag]

	_setToStringTag(Math, 'Math', true); // 24.3.3 JSON[@@toStringTag]

	_setToStringTag(_global.JSON, 'JSON', true);

	// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])


	_export(_export.S, 'Object', {
	  create: _objectCreate
	});

	// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)


	_export(_export.S + _export.F * !_descriptors, 'Object', {
	  defineProperty: _objectDp.f
	});

	// 19.1.2.3 / 15.2.3.7 Object.defineProperties(O, Properties)


	_export(_export.S + _export.F * !_descriptors, 'Object', {
	  defineProperties: _objectDps
	});

	// most Object methods by ES6 should accept primitives






	var _objectSap = function (KEY, exec) {
	  var fn = (_core.Object || {})[KEY] || Object[KEY];
	  var exp = {};
	  exp[KEY] = exec(fn);
	  _export(_export.S + _export.F * _fails(function () {
	    fn(1);
	  }), 'Object', exp);
	};

	// 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)


	var $getOwnPropertyDescriptor$1 = _objectGopd.f;

	_objectSap('getOwnPropertyDescriptor', function () {
	  return function getOwnPropertyDescriptor(it, key) {
	    return $getOwnPropertyDescriptor$1(_toIobject(it), key);
	  };
	});

	// 7.1.13 ToObject(argument)


	var _toObject = function (it) {
	  return Object(_defined(it));
	};

	// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)




	var IE_PROTO$2 = _sharedKey('IE_PROTO');

	var ObjectProto$1 = Object.prototype;

	var _objectGpo = Object.getPrototypeOf || function (O) {
	  O = _toObject(O);
	  if (_has(O, IE_PROTO$2)) return O[IE_PROTO$2];

	  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
	    return O.constructor.prototype;
	  }

	  return O instanceof Object ? ObjectProto$1 : null;
	};

	// 19.1.2.9 Object.getPrototypeOf(O)




	_objectSap('getPrototypeOf', function () {
	  return function getPrototypeOf(it) {
	    return _objectGpo(_toObject(it));
	  };
	});

	// 19.1.2.14 Object.keys(O)




	_objectSap('keys', function () {
	  return function keys(it) {
	    return _objectKeys(_toObject(it));
	  };
	});

	// 19.1.2.7 Object.getOwnPropertyNames(O)
	_objectSap('getOwnPropertyNames', function () {
	  return _objectGopnExt.f;
	});

	// 19.1.2.5 Object.freeze(O)


	var meta = _meta.onFreeze;

	_objectSap('freeze', function ($freeze) {
	  return function freeze(it) {
	    return $freeze && _isObject(it) ? $freeze(meta(it)) : it;
	  };
	});

	// 19.1.2.17 Object.seal(O)


	var meta$1 = _meta.onFreeze;

	_objectSap('seal', function ($seal) {
	  return function seal(it) {
	    return $seal && _isObject(it) ? $seal(meta$1(it)) : it;
	  };
	});

	// 19.1.2.15 Object.preventExtensions(O)


	var meta$2 = _meta.onFreeze;

	_objectSap('preventExtensions', function ($preventExtensions) {
	  return function preventExtensions(it) {
	    return $preventExtensions && _isObject(it) ? $preventExtensions(meta$2(it)) : it;
	  };
	});

	// 19.1.2.12 Object.isFrozen(O)


	_objectSap('isFrozen', function ($isFrozen) {
	  return function isFrozen(it) {
	    return _isObject(it) ? $isFrozen ? $isFrozen(it) : false : true;
	  };
	});

	// 19.1.2.13 Object.isSealed(O)


	_objectSap('isSealed', function ($isSealed) {
	  return function isSealed(it) {
	    return _isObject(it) ? $isSealed ? $isSealed(it) : false : true;
	  };
	});

	// 19.1.2.11 Object.isExtensible(O)


	_objectSap('isExtensible', function ($isExtensible) {
	  return function isExtensible(it) {
	    return _isObject(it) ? $isExtensible ? $isExtensible(it) : true : false;
	  };
	});

	var $assign = Object.assign; // should work with symbols and should have deterministic property order (V8 bug)

	var _objectAssign = !$assign || _fails(function () {
	  var A = {};
	  var B = {}; // eslint-disable-next-line no-undef

	  var S = Symbol();
	  var K = 'abcdefghijklmnopqrst';
	  A[S] = 7;
	  K.split('').forEach(function (k) {
	    B[k] = k;
	  });
	  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
	}) ? function assign(target, source) {
	  // eslint-disable-line no-unused-vars
	  var T = _toObject(target);
	  var aLen = arguments.length;
	  var index = 1;
	  var getSymbols = _objectGops.f;
	  var isEnum = _objectPie.f;

	  while (aLen > index) {
	    var S = _iobject(arguments[index++]);
	    var keys = getSymbols ? _objectKeys(S).concat(getSymbols(S)) : _objectKeys(S);
	    var length = keys.length;
	    var j = 0;
	    var key;

	    while (length > j) {
	      if (isEnum.call(S, key = keys[j++])) T[key] = S[key];
	    }
	  }

	  return T;
	} : $assign;

	// 19.1.3.1 Object.assign(target, source)


	_export(_export.S + _export.F, 'Object', {
	  assign: _objectAssign
	});

	// 7.2.9 SameValue(x, y)
	var _sameValue = Object.is || function is(x, y) {
	  // eslint-disable-next-line no-self-compare
	  return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
	};

	// 19.1.3.10 Object.is(value1, value2)


	_export(_export.S, 'Object', {
	  is: _sameValue
	});

	// Works with __proto__ only. Old v8 can't work with null proto objects.

	/* eslint-disable no-proto */




	var check = function check(O, proto) {
	  _anObject(O);
	  if (!_isObject(proto) && proto !== null) throw TypeError(proto + ": can't set as prototype!");
	};

	var _setProto = {
	  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
	  function (test, buggy, set) {
	    try {
	      set = _ctx(Function.call, _objectGopd.f(Object.prototype, '__proto__').set, 2);
	      set(test, []);
	      buggy = !(test instanceof Array);
	    } catch (e) {
	      buggy = true;
	    }

	    return function setPrototypeOf(O, proto) {
	      check(O, proto);
	      if (buggy) O.__proto__ = proto;else set(O, proto);
	      return O;
	    };
	  }({}, false) : undefined),
	  check: check
	};

	// 19.1.3.19 Object.setPrototypeOf(O, proto)


	_export(_export.S, 'Object', {
	  setPrototypeOf: _setProto.set
	});

	// getting tag from 19.1.3.6 Object.prototype.toString()


	var TAG$1 = _wks('toStringTag'); // ES3 wrong here


	var ARG = _cof(function () {
	  return arguments;
	}()) == 'Arguments'; // fallback for IE11 Script Access Denied error

	var tryGet = function tryGet(it, key) {
	  try {
	    return it[key];
	  } catch (e) {
	    /* empty */
	  }
	};

	var _classof = function (it) {
	  var O, T, B;
	  return it === undefined ? 'Undefined' : it === null ? 'Null' // @@toStringTag case
	  : typeof (T = tryGet(O = Object(it), TAG$1)) == 'string' ? T // builtinTag case
	  : ARG ? _cof(O) // ES3 arguments fallback
	  : (B = _cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
	};

	var test = {};
	test[_wks('toStringTag')] = 'z';

	if (test + '' != '[object z]') {
	  _redefine(Object.prototype, 'toString', function toString() {
	    return '[object ' + _classof(this) + ']';
	  }, true);
	}

	// fast apply, http://jsperf.lnkit.com/fast-apply/5
	var _invoke = function (fn, args, that) {
	  var un = that === undefined;

	  switch (args.length) {
	    case 0:
	      return un ? fn() : fn.call(that);

	    case 1:
	      return un ? fn(args[0]) : fn.call(that, args[0]);

	    case 2:
	      return un ? fn(args[0], args[1]) : fn.call(that, args[0], args[1]);

	    case 3:
	      return un ? fn(args[0], args[1], args[2]) : fn.call(that, args[0], args[1], args[2]);

	    case 4:
	      return un ? fn(args[0], args[1], args[2], args[3]) : fn.call(that, args[0], args[1], args[2], args[3]);
	  }

	  return fn.apply(that, args);
	};

	var arraySlice = [].slice;
	var factories = {};

	var construct = function construct(F, len, args) {
	  if (!(len in factories)) {
	    for (var n = [], i = 0; i < len; i++) {
	      n[i] = 'a[' + i + ']';
	    } // eslint-disable-next-line no-new-func


	    factories[len] = Function('F,a', 'return new F(' + n.join(',') + ')');
	  }

	  return factories[len](F, args);
	};

	var _bind = Function.bind || function bind(that
	/* , ...args */
	) {
	  var fn = _aFunction(this);
	  var partArgs = arraySlice.call(arguments, 1);

	  var bound = function bound()
	  /* args... */
	  {
	    var args = partArgs.concat(arraySlice.call(arguments));
	    return this instanceof bound ? construct(fn, args.length, args) : _invoke(fn, args, that);
	  };

	  if (_isObject(fn.prototype)) bound.prototype = fn.prototype;
	  return bound;
	};

	// 19.2.3.2 / 15.3.4.5 Function.prototype.bind(thisArg, args...)


	_export(_export.P, 'Function', {
	  bind: _bind
	});

	var dP$2 = _objectDp.f;

	var FProto = Function.prototype;
	var nameRE = /^\s*function ([^ (]*)/;
	var NAME = 'name'; // 19.2.4.2 name

	NAME in FProto || _descriptors && dP$2(FProto, NAME, {
	  configurable: true,
	  get: function get() {
	    try {
	      return ('' + this).match(nameRE)[1];
	    } catch (e) {
	      return '';
	    }
	  }
	});

	var HAS_INSTANCE = _wks('hasInstance');

	var FunctionProto = Function.prototype; // 19.2.3.6 Function.prototype[@@hasInstance](V)

	if (!(HAS_INSTANCE in FunctionProto)) _objectDp.f(FunctionProto, HAS_INSTANCE, {
	  value: function value(O) {
	    if (typeof this != 'function' || !_isObject(O)) return false;
	    if (!_isObject(this.prototype)) return O instanceof this; // for environment w/o native `@@hasInstance` logic enough `instanceof`, but add this:

	    while (O = _objectGpo(O)) {
	      if (this.prototype === O) return true;
	    }

	    return false;
	  }
	});

	var _stringWs = "\t\n\x0B\f\r \xA0\u1680\u180E\u2000\u2001\u2002\u2003" + "\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF";

	var space = '[' + _stringWs + ']';
	var non = "\u200B\x85";
	var ltrim = RegExp('^' + space + space + '*');
	var rtrim = RegExp(space + space + '*$');

	var exporter = function exporter(KEY, exec, ALIAS) {
	  var exp = {};
	  var FORCE = _fails(function () {
	    return !!_stringWs[KEY]() || non[KEY]() != non;
	  });
	  var fn = exp[KEY] = FORCE ? exec(trim) : _stringWs[KEY];
	  if (ALIAS) exp[ALIAS] = fn;
	  _export(_export.P + _export.F * FORCE, 'String', exp);
	}; // 1 -> String#trimLeft
	// 2 -> String#trimRight
	// 3 -> String#trim


	var trim = exporter.trim = function (string, TYPE) {
	  string = String(_defined(string));
	  if (TYPE & 1) string = string.replace(ltrim, '');
	  if (TYPE & 2) string = string.replace(rtrim, '');
	  return string;
	};

	var _stringTrim = exporter;

	var $parseInt = _global.parseInt;

	var $trim = _stringTrim.trim;



	var hex = /^[-+]?0[xX]/;
	var _parseInt = $parseInt(_stringWs + '08') !== 8 || $parseInt(_stringWs + '0x16') !== 22 ? function parseInt(str, radix) {
	  var string = $trim(String(str), 3);
	  return $parseInt(string, radix >>> 0 || (hex.test(string) ? 16 : 10));
	} : $parseInt;

	// 18.2.5 parseInt(string, radix)


	_export(_export.G + _export.F * (parseInt != _parseInt), {
	  parseInt: _parseInt
	});

	var $parseFloat = _global.parseFloat;

	var $trim$1 = _stringTrim.trim;

	var _parseFloat = 1 / $parseFloat(_stringWs + '-0') !== -Infinity ? function parseFloat(str) {
	  var string = $trim$1(String(str), 3);
	  var result = $parseFloat(string);
	  return result === 0 && string.charAt(0) == '-' ? -0 : result;
	} : $parseFloat;

	// 18.2.4 parseFloat(string)


	_export(_export.G + _export.F * (parseFloat != _parseFloat), {
	  parseFloat: _parseFloat
	});

	var setPrototypeOf = _setProto.set;

	var _inheritIfRequired = function (that, target, C) {
	  var S = target.constructor;
	  var P;

	  if (S !== C && typeof S == 'function' && (P = S.prototype) !== C.prototype && _isObject(P) && setPrototypeOf) {
	    setPrototypeOf(that, P);
	  }

	  return that;
	};

	var gOPN$2 = _objectGopn.f;

	var gOPD$2 = _objectGopd.f;

	var dP$3 = _objectDp.f;

	var $trim$2 = _stringTrim.trim;

	var NUMBER = 'Number';
	var $Number = _global[NUMBER];
	var Base = $Number;
	var proto = $Number.prototype; // Opera ~12 has broken Object#toString

	var BROKEN_COF = _cof(_objectCreate(proto)) == NUMBER;
	var TRIM = 'trim' in String.prototype; // 7.1.3 ToNumber(argument)

	var toNumber = function toNumber(argument) {
	  var it = _toPrimitive(argument, false);

	  if (typeof it == 'string' && it.length > 2) {
	    it = TRIM ? it.trim() : $trim$2(it, 3);
	    var first = it.charCodeAt(0);
	    var third, radix, maxCode;

	    if (first === 43 || first === 45) {
	      third = it.charCodeAt(2);
	      if (third === 88 || third === 120) return NaN; // Number('+0x1') should be NaN, old V8 fix
	    } else if (first === 48) {
	      switch (it.charCodeAt(1)) {
	        case 66:
	        case 98:
	          radix = 2;
	          maxCode = 49;
	          break;
	        // fast equal /^0b[01]+$/i

	        case 79:
	        case 111:
	          radix = 8;
	          maxCode = 55;
	          break;
	        // fast equal /^0o[0-7]+$/i

	        default:
	          return +it;
	      }

	      for (var digits = it.slice(2), i = 0, l = digits.length, code; i < l; i++) {
	        code = digits.charCodeAt(i); // parseInt parses a string to a first unavailable symbol
	        // but ToNumber should return NaN if a string contains unavailable symbols

	        if (code < 48 || code > maxCode) return NaN;
	      }

	      return parseInt(digits, radix);
	    }
	  }

	  return +it;
	};

	if (!$Number(' 0o1') || !$Number('0b1') || $Number('+0x1')) {
	  $Number = function Number(value) {
	    var it = arguments.length < 1 ? 0 : value;
	    var that = this;
	    return that instanceof $Number // check on 1..constructor(foo) case
	    && (BROKEN_COF ? _fails(function () {
	      proto.valueOf.call(that);
	    }) : _cof(that) != NUMBER) ? _inheritIfRequired(new Base(toNumber(it)), that, $Number) : toNumber(it);
	  };

	  for (var keys = _descriptors ? gOPN$2(Base) : ( // ES3:
	  'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' + // ES6 (in case, if modules with ES6 Number statics required before):
	  'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' + 'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger').split(','), j$1 = 0, key; keys.length > j$1; j$1++) {
	    if (_has(Base, key = keys[j$1]) && !_has($Number, key)) {
	      dP$3($Number, key, gOPD$2(Base, key));
	    }
	  }

	  $Number.prototype = proto;
	  proto.constructor = $Number;

	  _redefine(_global, NUMBER, $Number);
	}

	var _aNumberValue = function (it, msg) {
	  if (typeof it != 'number' && _cof(it) != 'Number') throw TypeError(msg);
	  return +it;
	};

	var _stringRepeat = function repeat(count) {
	  var str = String(_defined(this));
	  var res = '';
	  var n = _toInteger(count);
	  if (n < 0 || n == Infinity) throw RangeError("Count can't be negative");

	  for (; n > 0; (n >>>= 1) && (str += str)) {
	    if (n & 1) res += str;
	  }

	  return res;
	};

	var $toFixed = 1.0.toFixed;
	var floor$1 = Math.floor;
	var data = [0, 0, 0, 0, 0, 0];
	var ERROR = 'Number.toFixed: incorrect invocation!';
	var ZERO = '0';

	var multiply = function multiply(n, c) {
	  var i = -1;
	  var c2 = c;

	  while (++i < 6) {
	    c2 += n * data[i];
	    data[i] = c2 % 1e7;
	    c2 = floor$1(c2 / 1e7);
	  }
	};

	var divide = function divide(n) {
	  var i = 6;
	  var c = 0;

	  while (--i >= 0) {
	    c += data[i];
	    data[i] = floor$1(c / n);
	    c = c % n * 1e7;
	  }
	};

	var numToString = function numToString() {
	  var i = 6;
	  var s = '';

	  while (--i >= 0) {
	    if (s !== '' || i === 0 || data[i] !== 0) {
	      var t = String(data[i]);
	      s = s === '' ? t : s + _stringRepeat.call(ZERO, 7 - t.length) + t;
	    }
	  }

	  return s;
	};

	var pow = function pow(x, n, acc) {
	  return n === 0 ? acc : n % 2 === 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc);
	};

	var log = function log(x) {
	  var n = 0;
	  var x2 = x;

	  while (x2 >= 4096) {
	    n += 12;
	    x2 /= 4096;
	  }

	  while (x2 >= 2) {
	    n += 1;
	    x2 /= 2;
	  }

	  return n;
	};

	_export(_export.P + _export.F * (!!$toFixed && (0.00008.toFixed(3) !== '0.000' || 0.9.toFixed(0) !== '1' || 1.255.toFixed(2) !== '1.25' || 1000000000000000128.0.toFixed(0) !== '1000000000000000128') || !_fails(function () {
	  // V8 ~ Android 4.3-
	  $toFixed.call({});
	})), 'Number', {
	  toFixed: function toFixed(fractionDigits) {
	    var x = _aNumberValue(this, ERROR);
	    var f = _toInteger(fractionDigits);
	    var s = '';
	    var m = ZERO;
	    var e, z, j, k;
	    if (f < 0 || f > 20) throw RangeError(ERROR); // eslint-disable-next-line no-self-compare

	    if (x != x) return 'NaN';
	    if (x <= -1e21 || x >= 1e21) return String(x);

	    if (x < 0) {
	      s = '-';
	      x = -x;
	    }

	    if (x > 1e-21) {
	      e = log(x * pow(2, 69, 1)) - 69;
	      z = e < 0 ? x * pow(2, -e, 1) : x / pow(2, e, 1);
	      z *= 0x10000000000000;
	      e = 52 - e;

	      if (e > 0) {
	        multiply(0, z);
	        j = f;

	        while (j >= 7) {
	          multiply(1e7, 0);
	          j -= 7;
	        }

	        multiply(pow(10, j, 1), 0);
	        j = e - 1;

	        while (j >= 23) {
	          divide(1 << 23);
	          j -= 23;
	        }

	        divide(1 << j);
	        multiply(1, 1);
	        divide(2);
	        m = numToString();
	      } else {
	        multiply(0, z);
	        multiply(1 << -e, 0);
	        m = numToString() + _stringRepeat.call(ZERO, f);
	      }
	    }

	    if (f > 0) {
	      k = m.length;
	      m = s + (k <= f ? '0.' + _stringRepeat.call(ZERO, f - k) + m : m.slice(0, k - f) + '.' + m.slice(k - f));
	    } else {
	      m = s + m;
	    }

	    return m;
	  }
	});

	var $toPrecision = 1.0.toPrecision;
	_export(_export.P + _export.F * (_fails(function () {
	  // IE7-
	  return $toPrecision.call(1, undefined) !== '1';
	}) || !_fails(function () {
	  // V8 ~ Android 4.3-
	  $toPrecision.call({});
	})), 'Number', {
	  toPrecision: function toPrecision(precision) {
	    var that = _aNumberValue(this, 'Number#toPrecision: incorrect invocation!');
	    return precision === undefined ? $toPrecision.call(that) : $toPrecision.call(that, precision);
	  }
	});

	// 20.1.2.1 Number.EPSILON


	_export(_export.S, 'Number', {
	  EPSILON: Math.pow(2, -52)
	});

	// 20.1.2.2 Number.isFinite(number)


	var _isFinite = _global.isFinite;

	_export(_export.S, 'Number', {
	  isFinite: function isFinite(it) {
	    return typeof it == 'number' && _isFinite(it);
	  }
	});

	// 20.1.2.3 Number.isInteger(number)


	var floor$2 = Math.floor;

	var _isInteger = function isInteger(it) {
	  return !_isObject(it) && isFinite(it) && floor$2(it) === it;
	};

	// 20.1.2.3 Number.isInteger(number)


	_export(_export.S, 'Number', {
	  isInteger: _isInteger
	});

	// 20.1.2.4 Number.isNaN(number)


	_export(_export.S, 'Number', {
	  isNaN: function isNaN(number) {
	    // eslint-disable-next-line no-self-compare
	    return number != number;
	  }
	});

	// 20.1.2.5 Number.isSafeInteger(number)




	var abs = Math.abs;
	_export(_export.S, 'Number', {
	  isSafeInteger: function isSafeInteger(number) {
	    return _isInteger(number) && abs(number) <= 0x1fffffffffffff;
	  }
	});

	// 20.1.2.6 Number.MAX_SAFE_INTEGER


	_export(_export.S, 'Number', {
	  MAX_SAFE_INTEGER: 0x1fffffffffffff
	});

	// 20.1.2.10 Number.MIN_SAFE_INTEGER


	_export(_export.S, 'Number', {
	  MIN_SAFE_INTEGER: -0x1fffffffffffff
	});

	// 20.1.2.12 Number.parseFloat(string)


	_export(_export.S + _export.F * (Number.parseFloat != _parseFloat), 'Number', {
	  parseFloat: _parseFloat
	});

	// 20.1.2.13 Number.parseInt(string, radix)


	_export(_export.S + _export.F * (Number.parseInt != _parseInt), 'Number', {
	  parseInt: _parseInt
	});

	// 20.2.2.20 Math.log1p(x)
	var _mathLog1p = Math.log1p || function log1p(x) {
	  return (x = +x) > -1e-8 && x < 1e-8 ? x - x * x / 2 : Math.log(1 + x);
	};

	// 20.2.2.3 Math.acosh(x)




	var sqrt = Math.sqrt;
	var $acosh = Math.acosh;
	_export(_export.S + _export.F * !($acosh // V8 bug: https://code.google.com/p/v8/issues/detail?id=3509
	&& Math.floor($acosh(Number.MAX_VALUE)) == 710 // Tor Browser bug: Math.acosh(Infinity) -> NaN
	&& $acosh(Infinity) == Infinity), 'Math', {
	  acosh: function acosh(x) {
	    return (x = +x) < 1 ? NaN : x > 94906265.62425156 ? Math.log(x) + Math.LN2 : _mathLog1p(x - 1 + sqrt(x - 1) * sqrt(x + 1));
	  }
	});

	// 20.2.2.5 Math.asinh(x)


	var $asinh = Math.asinh;

	function asinh(x) {
	  return !isFinite(x = +x) || x == 0 ? x : x < 0 ? -asinh(-x) : Math.log(x + Math.sqrt(x * x + 1));
	} // Tor Browser bug: Math.asinh(0) -> -0


	_export(_export.S + _export.F * !($asinh && 1 / $asinh(0) > 0), 'Math', {
	  asinh: asinh
	});

	// 20.2.2.7 Math.atanh(x)


	var $atanh = Math.atanh; // Tor Browser bug: Math.atanh(-0) -> 0

	_export(_export.S + _export.F * !($atanh && 1 / $atanh(-0) < 0), 'Math', {
	  atanh: function atanh(x) {
	    return (x = +x) == 0 ? x : Math.log((1 + x) / (1 - x)) / 2;
	  }
	});

	// 20.2.2.28 Math.sign(x)
	var _mathSign = Math.sign || function sign(x) {
	  // eslint-disable-next-line no-self-compare
	  return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;
	};

	// 20.2.2.9 Math.cbrt(x)




	_export(_export.S, 'Math', {
	  cbrt: function cbrt(x) {
	    return _mathSign(x = +x) * Math.pow(Math.abs(x), 1 / 3);
	  }
	});

	// 20.2.2.11 Math.clz32(x)


	_export(_export.S, 'Math', {
	  clz32: function clz32(x) {
	    return (x >>>= 0) ? 31 - Math.floor(Math.log(x + 0.5) * Math.LOG2E) : 32;
	  }
	});

	// 20.2.2.12 Math.cosh(x)


	var exp = Math.exp;
	_export(_export.S, 'Math', {
	  cosh: function cosh(x) {
	    return (exp(x = +x) + exp(-x)) / 2;
	  }
	});

	// 20.2.2.14 Math.expm1(x)
	var $expm1 = Math.expm1;
	var _mathExpm1 = !$expm1 // Old FF bug
	|| $expm1(10) > 22025.465794806719 || $expm1(10) < 22025.4657948067165168 // Tor Browser bug
	|| $expm1(-2e-17) != -2e-17 ? function expm1(x) {
	  return (x = +x) == 0 ? x : x > -1e-6 && x < 1e-6 ? x + x * x / 2 : Math.exp(x) - 1;
	} : $expm1;

	// 20.2.2.14 Math.expm1(x)




	_export(_export.S + _export.F * (_mathExpm1 != Math.expm1), 'Math', {
	  expm1: _mathExpm1
	});

	// 20.2.2.16 Math.fround(x)


	var pow$1 = Math.pow;
	var EPSILON = pow$1(2, -52);
	var EPSILON32 = pow$1(2, -23);
	var MAX32 = pow$1(2, 127) * (2 - EPSILON32);
	var MIN32 = pow$1(2, -126);

	var roundTiesToEven = function roundTiesToEven(n) {
	  return n + 1 / EPSILON - 1 / EPSILON;
	};

	var _mathFround = Math.fround || function fround(x) {
	  var $abs = Math.abs(x);
	  var $sign = _mathSign(x);
	  var a, result;
	  if ($abs < MIN32) return $sign * roundTiesToEven($abs / MIN32 / EPSILON32) * MIN32 * EPSILON32;
	  a = (1 + EPSILON32 / EPSILON) * $abs;
	  result = a - (a - $abs); // eslint-disable-next-line no-self-compare

	  if (result > MAX32 || result != result) return $sign * Infinity;
	  return $sign * result;
	};

	// 20.2.2.16 Math.fround(x)


	_export(_export.S, 'Math', {
	  fround: _mathFround
	});

	// 20.2.2.17 Math.hypot([value1[, value2[, ... ]]])


	var abs$1 = Math.abs;
	_export(_export.S, 'Math', {
	  hypot: function hypot(value1, value2) {
	    // eslint-disable-line no-unused-vars
	    var sum = 0;
	    var i = 0;
	    var aLen = arguments.length;
	    var larg = 0;
	    var arg, div;

	    while (i < aLen) {
	      arg = abs$1(arguments[i++]);

	      if (larg < arg) {
	        div = larg / arg;
	        sum = sum * div * div + 1;
	        larg = arg;
	      } else if (arg > 0) {
	        div = arg / larg;
	        sum += div * div;
	      } else sum += arg;
	    }

	    return larg === Infinity ? Infinity : larg * Math.sqrt(sum);
	  }
	});

	// 20.2.2.18 Math.imul(x, y)


	var $imul = Math.imul; // some WebKit versions fails with big numbers, some has wrong arity

	_export(_export.S + _export.F * _fails(function () {
	  return $imul(0xffffffff, 5) != -5 || $imul.length != 2;
	}), 'Math', {
	  imul: function imul(x, y) {
	    var UINT16 = 0xffff;
	    var xn = +x;
	    var yn = +y;
	    var xl = UINT16 & xn;
	    var yl = UINT16 & yn;
	    return 0 | xl * yl + ((UINT16 & xn >>> 16) * yl + xl * (UINT16 & yn >>> 16) << 16 >>> 0);
	  }
	});

	// 20.2.2.21 Math.log10(x)


	_export(_export.S, 'Math', {
	  log10: function log10(x) {
	    return Math.log(x) * Math.LOG10E;
	  }
	});

	// 20.2.2.20 Math.log1p(x)


	_export(_export.S, 'Math', {
	  log1p: _mathLog1p
	});

	// 20.2.2.22 Math.log2(x)


	_export(_export.S, 'Math', {
	  log2: function log2(x) {
	    return Math.log(x) / Math.LN2;
	  }
	});

	// 20.2.2.28 Math.sign(x)


	_export(_export.S, 'Math', {
	  sign: _mathSign
	});

	// 20.2.2.30 Math.sinh(x)




	var exp$1 = Math.exp; // V8 near Chromium 38 has a problem with very small numbers

	_export(_export.S + _export.F * _fails(function () {
	  return !Math.sinh(-2e-17) != -2e-17;
	}), 'Math', {
	  sinh: function sinh(x) {
	    return Math.abs(x = +x) < 1 ? (_mathExpm1(x) - _mathExpm1(-x)) / 2 : (exp$1(x - 1) - exp$1(-x - 1)) * (Math.E / 2);
	  }
	});

	// 20.2.2.33 Math.tanh(x)




	var exp$2 = Math.exp;
	_export(_export.S, 'Math', {
	  tanh: function tanh(x) {
	    var a = _mathExpm1(x = +x);
	    var b = _mathExpm1(-x);
	    return a == Infinity ? 1 : b == Infinity ? -1 : (a - b) / (exp$2(x) + exp$2(-x));
	  }
	});

	// 20.2.2.34 Math.trunc(x)


	_export(_export.S, 'Math', {
	  trunc: function trunc(it) {
	    return (it > 0 ? Math.floor : Math.ceil)(it);
	  }
	});

	var fromCharCode = String.fromCharCode;
	var $fromCodePoint = String.fromCodePoint; // length should be 1, old FF problem

	_export(_export.S + _export.F * (!!$fromCodePoint && $fromCodePoint.length != 1), 'String', {
	  // 21.1.2.2 String.fromCodePoint(...codePoints)
	  fromCodePoint: function fromCodePoint(x) {
	    // eslint-disable-line no-unused-vars
	    var res = [];
	    var aLen = arguments.length;
	    var i = 0;
	    var code;

	    while (aLen > i) {
	      code = +arguments[i++];
	      if (_toAbsoluteIndex(code, 0x10ffff) !== code) throw RangeError(code + ' is not a valid code point');
	      res.push(code < 0x10000 ? fromCharCode(code) : fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00));
	    }

	    return res.join('');
	  }
	});

	_export(_export.S, 'String', {
	  // 21.1.2.4 String.raw(callSite, ...substitutions)
	  raw: function raw(callSite) {
	    var tpl = _toIobject(callSite.raw);
	    var len = _toLength(tpl.length);
	    var aLen = arguments.length;
	    var res = [];
	    var i = 0;

	    while (len > i) {
	      res.push(String(tpl[i++]));
	      if (i < aLen) res.push(String(arguments[i]));
	    }

	    return res.join('');
	  }
	});

	_stringTrim('trim', function ($trim) {
	  return function trim() {
	    return $trim(this, 3);
	  };
	});

	// true  -> String#at
	// false -> String#codePointAt


	var _stringAt = function (TO_STRING) {
	  return function (that, pos) {
	    var s = String(_defined(that));
	    var i = _toInteger(pos);
	    var l = s.length;
	    var a, b;
	    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
	    a = s.charCodeAt(i);
	    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff ? TO_STRING ? s.charAt(i) : a : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
	  };
	};

	var _iterators = {};

	var IteratorPrototype = {}; // 25.1.2.1.1 %IteratorPrototype%[@@iterator]()

	_hide(IteratorPrototype, _wks('iterator'), function () {
	  return this;
	});

	var _iterCreate = function (Constructor, NAME, next) {
	  Constructor.prototype = _objectCreate(IteratorPrototype, {
	    next: _propertyDesc(1, next)
	  });
	  _setToStringTag(Constructor, NAME + ' Iterator');
	};

	var ITERATOR = _wks('iterator');

	var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`

	var FF_ITERATOR = '@@iterator';
	var KEYS = 'keys';
	var VALUES = 'values';

	var returnThis = function returnThis() {
	  return this;
	};

	var _iterDefine = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
	  _iterCreate(Constructor, NAME, next);

	  var getMethod = function getMethod(kind) {
	    if (!BUGGY && kind in proto) return proto[kind];

	    switch (kind) {
	      case KEYS:
	        return function keys() {
	          return new Constructor(this, kind);
	        };

	      case VALUES:
	        return function values() {
	          return new Constructor(this, kind);
	        };
	    }

	    return function entries() {
	      return new Constructor(this, kind);
	    };
	  };

	  var TAG = NAME + ' Iterator';
	  var DEF_VALUES = DEFAULT == VALUES;
	  var VALUES_BUG = false;
	  var proto = Base.prototype;
	  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
	  var $default = $native || getMethod(DEFAULT);
	  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
	  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
	  var methods, key, IteratorPrototype; // Fix native

	  if ($anyNative) {
	    IteratorPrototype = _objectGpo($anyNative.call(new Base()));

	    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
	      // Set @@toStringTag to native iterators
	      _setToStringTag(IteratorPrototype, TAG, true); // fix for some old engines

	      if (typeof IteratorPrototype[ITERATOR] != 'function') _hide(IteratorPrototype, ITERATOR, returnThis);
	    }
	  } // fix Array#{values, @@iterator}.name in V8 / FF


	  if (DEF_VALUES && $native && $native.name !== VALUES) {
	    VALUES_BUG = true;

	    $default = function values() {
	      return $native.call(this);
	    };
	  } // Define iterator


	  if (BUGGY || VALUES_BUG || !proto[ITERATOR]) {
	    _hide(proto, ITERATOR, $default);
	  } // Plug for library


	  _iterators[NAME] = $default;
	  _iterators[TAG] = returnThis;

	  if (DEFAULT) {
	    methods = {
	      values: DEF_VALUES ? $default : getMethod(VALUES),
	      keys: IS_SET ? $default : getMethod(KEYS),
	      entries: $entries
	    };
	    if (FORCED) for (key in methods) {
	      if (!(key in proto)) _redefine(proto, key, methods[key]);
	    } else _export(_export.P + _export.F * (BUGGY || VALUES_BUG), NAME, methods);
	  }

	  return methods;
	};

	var $at = _stringAt(true); // 21.1.3.27 String.prototype[@@iterator]()


	_iterDefine(String, 'String', function (iterated) {
	  this._t = String(iterated); // target

	  this._i = 0; // next index
	  // 21.1.5.2.1 %StringIteratorPrototype%.next()
	}, function () {
	  var O = this._t;
	  var index = this._i;
	  var point;
	  if (index >= O.length) return {
	    value: undefined,
	    done: true
	  };
	  point = $at(O, index);
	  this._i += point.length;
	  return {
	    value: point,
	    done: false
	  };
	});

	var $at$1 = _stringAt(false);

	_export(_export.P, 'String', {
	  // 21.1.3.3 String.prototype.codePointAt(pos)
	  codePointAt: function codePointAt(pos) {
	    return $at$1(this, pos);
	  }
	});

	// 7.2.8 IsRegExp(argument)




	var MATCH = _wks('match');

	var _isRegexp = function (it) {
	  var isRegExp;
	  return _isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : _cof(it) == 'RegExp');
	};

	// helper for String#{startsWith, endsWith, includes}




	var _stringContext = function (that, searchString, NAME) {
	  if (_isRegexp(searchString)) throw TypeError('String#' + NAME + " doesn't accept regex!");
	  return String(_defined(that));
	};

	var MATCH$1 = _wks('match');

	var _failsIsRegexp = function (KEY) {
	  var re = /./;

	  try {
	    '/./'[KEY](re);
	  } catch (e) {
	    try {
	      re[MATCH$1] = false;
	      return !'/./'[KEY](re);
	    } catch (f) {
	      /* empty */
	    }
	  }

	  return true;
	};

	var ENDS_WITH = 'endsWith';
	var $endsWith = ''[ENDS_WITH];
	_export(_export.P + _export.F * _failsIsRegexp(ENDS_WITH), 'String', {
	  endsWith: function endsWith(searchString
	  /* , endPosition = @length */
	  ) {
	    var that = _stringContext(this, searchString, ENDS_WITH);
	    var endPosition = arguments.length > 1 ? arguments[1] : undefined;
	    var len = _toLength(that.length);
	    var end = endPosition === undefined ? len : Math.min(_toLength(endPosition), len);
	    var search = String(searchString);
	    return $endsWith ? $endsWith.call(that, search, end) : that.slice(end - search.length, end) === search;
	  }
	});

	var INCLUDES = 'includes';
	_export(_export.P + _export.F * _failsIsRegexp(INCLUDES), 'String', {
	  includes: function includes(searchString
	  /* , position = 0 */
	  ) {
	    return !!~_stringContext(this, searchString, INCLUDES).indexOf(searchString, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

	_export(_export.P, 'String', {
	  // 21.1.3.13 String.prototype.repeat(count)
	  repeat: _stringRepeat
	});

	var STARTS_WITH = 'startsWith';
	var $startsWith = ''[STARTS_WITH];
	_export(_export.P + _export.F * _failsIsRegexp(STARTS_WITH), 'String', {
	  startsWith: function startsWith(searchString
	  /* , position = 0 */
	  ) {
	    var that = _stringContext(this, searchString, STARTS_WITH);
	    var index = _toLength(Math.min(arguments.length > 1 ? arguments[1] : undefined, that.length));
	    var search = String(searchString);
	    return $startsWith ? $startsWith.call(that, search, index) : that.slice(index, index + search.length) === search;
	  }
	});

	var quot = /"/g; // B.2.3.2.1 CreateHTML(string, tag, attribute, value)

	var createHTML = function createHTML(string, tag, attribute, value) {
	  var S = String(_defined(string));
	  var p1 = '<' + tag;
	  if (attribute !== '') p1 += ' ' + attribute + '="' + String(value).replace(quot, '&quot;') + '"';
	  return p1 + '>' + S + '</' + tag + '>';
	};

	var _stringHtml = function (NAME, exec) {
	  var O = {};
	  O[NAME] = exec(createHTML);
	  _export(_export.P + _export.F * _fails(function () {
	    var test = ''[NAME]('"');
	    return test !== test.toLowerCase() || test.split('"').length > 3;
	  }), 'String', O);
	};

	_stringHtml('anchor', function (createHTML) {
	  return function anchor(name) {
	    return createHTML(this, 'a', 'name', name);
	  };
	});

	_stringHtml('big', function (createHTML) {
	  return function big() {
	    return createHTML(this, 'big', '', '');
	  };
	});

	_stringHtml('blink', function (createHTML) {
	  return function blink() {
	    return createHTML(this, 'blink', '', '');
	  };
	});

	_stringHtml('bold', function (createHTML) {
	  return function bold() {
	    return createHTML(this, 'b', '', '');
	  };
	});

	_stringHtml('fixed', function (createHTML) {
	  return function fixed() {
	    return createHTML(this, 'tt', '', '');
	  };
	});

	_stringHtml('fontcolor', function (createHTML) {
	  return function fontcolor(color) {
	    return createHTML(this, 'font', 'color', color);
	  };
	});

	_stringHtml('fontsize', function (createHTML) {
	  return function fontsize(size) {
	    return createHTML(this, 'font', 'size', size);
	  };
	});

	_stringHtml('italics', function (createHTML) {
	  return function italics() {
	    return createHTML(this, 'i', '', '');
	  };
	});

	_stringHtml('link', function (createHTML) {
	  return function link(url) {
	    return createHTML(this, 'a', 'href', url);
	  };
	});

	_stringHtml('small', function (createHTML) {
	  return function small() {
	    return createHTML(this, 'small', '', '');
	  };
	});

	_stringHtml('strike', function (createHTML) {
	  return function strike() {
	    return createHTML(this, 'strike', '', '');
	  };
	});

	_stringHtml('sub', function (createHTML) {
	  return function sub() {
	    return createHTML(this, 'sub', '', '');
	  };
	});

	_stringHtml('sup', function (createHTML) {
	  return function sup() {
	    return createHTML(this, 'sup', '', '');
	  };
	});

	// 20.3.3.1 / 15.9.4.4 Date.now()


	_export(_export.S, 'Date', {
	  now: function now() {
	    return new Date().getTime();
	  }
	});

	_export(_export.P + _export.F * _fails(function () {
	  return new Date(NaN).toJSON() !== null || Date.prototype.toJSON.call({
	    toISOString: function toISOString() {
	      return 1;
	    }
	  }) !== 1;
	}), 'Date', {
	  // eslint-disable-next-line no-unused-vars
	  toJSON: function toJSON(key) {
	    var O = _toObject(this);
	    var pv = _toPrimitive(O);
	    return typeof pv == 'number' && !isFinite(pv) ? null : O.toISOString();
	  }
	});

	var getTime = Date.prototype.getTime;
	var $toISOString = Date.prototype.toISOString;

	var lz = function lz(num) {
	  return num > 9 ? num : '0' + num;
	}; // PhantomJS / old WebKit has a broken implementations


	var _dateToIsoString = _fails(function () {
	  return $toISOString.call(new Date(-5e13 - 1)) != '0385-07-25T07:06:39.999Z';
	}) || !_fails(function () {
	  $toISOString.call(new Date(NaN));
	}) ? function toISOString() {
	  if (!isFinite(getTime.call(this))) throw RangeError('Invalid time value');
	  var d = this;
	  var y = d.getUTCFullYear();
	  var m = d.getUTCMilliseconds();
	  var s = y < 0 ? '-' : y > 9999 ? '+' : '';
	  return s + ('00000' + Math.abs(y)).slice(s ? -6 : -4) + '-' + lz(d.getUTCMonth() + 1) + '-' + lz(d.getUTCDate()) + 'T' + lz(d.getUTCHours()) + ':' + lz(d.getUTCMinutes()) + ':' + lz(d.getUTCSeconds()) + '.' + (m > 99 ? m : '0' + lz(m)) + 'Z';
	} : $toISOString;

	// 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()


	 // PhantomJS / old WebKit has a broken implementations


	_export(_export.P + _export.F * (Date.prototype.toISOString !== _dateToIsoString), 'Date', {
	  toISOString: _dateToIsoString
	});

	var DateProto = Date.prototype;
	var INVALID_DATE = 'Invalid Date';
	var TO_STRING = 'toString';
	var $toString = DateProto[TO_STRING];
	var getTime$1 = DateProto.getTime;

	if (new Date(NaN) + '' != INVALID_DATE) {
	  _redefine(DateProto, TO_STRING, function toString() {
	    var value = getTime$1.call(this); // eslint-disable-next-line no-self-compare

	    return value === value ? $toString.call(this) : INVALID_DATE;
	  });
	}

	var NUMBER$1 = 'number';

	var _dateToPrimitive = function (hint) {
	  if (hint !== 'string' && hint !== NUMBER$1 && hint !== 'default') throw TypeError('Incorrect hint');
	  return _toPrimitive(_anObject(this), hint != NUMBER$1);
	};

	var TO_PRIMITIVE$1 = _wks('toPrimitive');

	var proto$1 = Date.prototype;
	if (!(TO_PRIMITIVE$1 in proto$1)) _hide(proto$1, TO_PRIMITIVE$1, _dateToPrimitive);

	// 22.1.2.2 / 15.4.3.2 Array.isArray(arg)


	_export(_export.S, 'Array', {
	  isArray: _isArray
	});

	// call something on iterator step with safe closing on error


	var _iterCall = function (iterator, fn, value, entries) {
	  try {
	    return entries ? fn(_anObject(value)[0], value[1]) : fn(value); // 7.4.6 IteratorClose(iterator, completion)
	  } catch (e) {
	    var ret = iterator['return'];
	    if (ret !== undefined) _anObject(ret.call(iterator));
	    throw e;
	  }
	};

	// check on default Array iterator


	var ITERATOR$1 = _wks('iterator');

	var ArrayProto = Array.prototype;

	var _isArrayIter = function (it) {
	  return it !== undefined && (_iterators.Array === it || ArrayProto[ITERATOR$1] === it);
	};

	var _createProperty = function (object, index, value) {
	  if (index in object) _objectDp.f(object, index, _propertyDesc(0, value));else object[index] = value;
	};

	var ITERATOR$2 = _wks('iterator');



	var core_getIteratorMethod = _core.getIteratorMethod = function (it) {
	  if (it != undefined) return it[ITERATOR$2] || it['@@iterator'] || _iterators[_classof(it)];
	};

	var ITERATOR$3 = _wks('iterator');

	var SAFE_CLOSING = false;

	try {
	  var riter = [7][ITERATOR$3]();

	  riter['return'] = function () {
	    SAFE_CLOSING = true;
	  }; // eslint-disable-next-line no-throw-literal
	} catch (e) {
	  /* empty */
	}

	var _iterDetect = function (exec, skipClosing) {
	  if (!skipClosing && !SAFE_CLOSING) return false;
	  var safe = false;

	  try {
	    var arr = [7];
	    var iter = arr[ITERATOR$3]();

	    iter.next = function () {
	      return {
	        done: safe = true
	      };
	    };

	    arr[ITERATOR$3] = function () {
	      return iter;
	    };

	    exec(arr);
	  } catch (e) {
	    /* empty */
	  }

	  return safe;
	};

	_export(_export.S + _export.F * !_iterDetect(function (iter) {
	}), 'Array', {
	  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
	  from: function from(arrayLike
	  /* , mapfn = undefined, thisArg = undefined */
	  ) {
	    var O = _toObject(arrayLike);
	    var C = typeof this == 'function' ? this : Array;
	    var aLen = arguments.length;
	    var mapfn = aLen > 1 ? arguments[1] : undefined;
	    var mapping = mapfn !== undefined;
	    var index = 0;
	    var iterFn = core_getIteratorMethod(O);
	    var length, result, step, iterator;
	    if (mapping) mapfn = _ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2); // if object isn't iterable or it's array with default iterator - use simple case

	    if (iterFn != undefined && !(C == Array && _isArrayIter(iterFn))) {
	      for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {
	        _createProperty(result, index, mapping ? _iterCall(iterator, mapfn, [step.value, index], true) : step.value);
	      }
	    } else {
	      length = _toLength(O.length);

	      for (result = new C(length); length > index; index++) {
	        _createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
	      }
	    }

	    result.length = index;
	    return result;
	  }
	});

	// WebKit Array.of isn't generic


	_export(_export.S + _export.F * _fails(function () {
	  function F() {
	    /* empty */
	  }

	  return !(Array.of.call(F) instanceof F);
	}), 'Array', {
	  // 22.1.2.3 Array.of( ...items)
	  of: function of()
	  /* ...args */
	  {
	    var index = 0;
	    var aLen = arguments.length;
	    var result = new (typeof this == 'function' ? this : Array)(aLen);

	    while (aLen > index) {
	      _createProperty(result, index, arguments[index++]);
	    }

	    result.length = aLen;
	    return result;
	  }
	});

	var _strictMethod = function (method, arg) {
	  return !!method && _fails(function () {
	    // eslint-disable-next-line no-useless-call
	    arg ? method.call(null, function () {
	      /* empty */
	    }, 1) : method.call(null);
	  });
	};

	var arrayJoin = [].join; // fallback for not array-like strings

	_export(_export.P + _export.F * (_iobject != Object || !_strictMethod(arrayJoin)), 'Array', {
	  join: function join(separator) {
	    return arrayJoin.call(_toIobject(this), separator === undefined ? ',' : separator);
	  }
	});

	var arraySlice$1 = [].slice; // fallback for not array-like ES3 strings and DOM objects

	_export(_export.P + _export.F * _fails(function () {
	  if (_html) arraySlice$1.call(_html);
	}), 'Array', {
	  slice: function slice(begin, end) {
	    var len = _toLength(this.length);
	    var klass = _cof(this);
	    end = end === undefined ? len : end;
	    if (klass == 'Array') return arraySlice$1.call(this, begin, end);
	    var start = _toAbsoluteIndex(begin, len);
	    var upTo = _toAbsoluteIndex(end, len);
	    var size = _toLength(upTo - start);
	    var cloned = new Array(size);
	    var i = 0;

	    for (; i < size; i++) {
	      cloned[i] = klass == 'String' ? this.charAt(start + i) : this[start + i];
	    }

	    return cloned;
	  }
	});

	var $sort = [].sort;
	var test$1 = [1, 2, 3];
	_export(_export.P + _export.F * (_fails(function () {
	  // IE8-
	  test$1.sort(undefined);
	}) || !_fails(function () {
	  // V8 bug
	  test$1.sort(null); // Old WebKit
	}) || !_strictMethod($sort)), 'Array', {
	  // 22.1.3.25 Array.prototype.sort(comparefn)
	  sort: function sort(comparefn) {
	    return comparefn === undefined ? $sort.call(_toObject(this)) : $sort.call(_toObject(this), _aFunction(comparefn));
	  }
	});

	var SPECIES = _wks('species');

	var _arraySpeciesConstructor = function (original) {
	  var C;

	  if (_isArray(original)) {
	    C = original.constructor; // cross-realm fallback

	    if (typeof C == 'function' && (C === Array || _isArray(C.prototype))) C = undefined;

	    if (_isObject(C)) {
	      C = C[SPECIES];
	      if (C === null) C = undefined;
	    }
	  }

	  return C === undefined ? Array : C;
	};

	// 9.4.2.3 ArraySpeciesCreate(originalArray, length)


	var _arraySpeciesCreate = function (original, length) {
	  return new (_arraySpeciesConstructor(original))(length);
	};

	// 0 -> Array#forEach
	// 1 -> Array#map
	// 2 -> Array#filter
	// 3 -> Array#some
	// 4 -> Array#every
	// 5 -> Array#find
	// 6 -> Array#findIndex










	var _arrayMethods = function (TYPE, $create) {
	  var IS_MAP = TYPE == 1;
	  var IS_FILTER = TYPE == 2;
	  var IS_SOME = TYPE == 3;
	  var IS_EVERY = TYPE == 4;
	  var IS_FIND_INDEX = TYPE == 6;
	  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
	  var create = $create || _arraySpeciesCreate;
	  return function ($this, callbackfn, that) {
	    var O = _toObject($this);
	    var self = _iobject(O);
	    var f = _ctx(callbackfn, that, 3);
	    var length = _toLength(self.length);
	    var index = 0;
	    var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
	    var val, res;

	    for (; length > index; index++) {
	      if (NO_HOLES || index in self) {
	        val = self[index];
	        res = f(val, index, O);

	        if (TYPE) {
	          if (IS_MAP) result[index] = res; // map
	          else if (res) switch (TYPE) {
	              case 3:
	                return true;
	              // some

	              case 5:
	                return val;
	              // find

	              case 6:
	                return index;
	              // findIndex

	              case 2:
	                result.push(val);
	              // filter
	            } else if (IS_EVERY) return false; // every
	        }
	      }
	    }

	    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
	  };
	};

	var $forEach = _arrayMethods(0);

	var STRICT = _strictMethod([].forEach, true);

	_export(_export.P + _export.F * !STRICT, 'Array', {
	  // 22.1.3.10 / 15.4.4.18 Array.prototype.forEach(callbackfn [, thisArg])
	  forEach: function forEach(callbackfn
	  /* , thisArg */
	  ) {
	    return $forEach(this, callbackfn, arguments[1]);
	  }
	});

	var $map = _arrayMethods(1);

	_export(_export.P + _export.F * !_strictMethod([].map, true), 'Array', {
	  // 22.1.3.15 / 15.4.4.19 Array.prototype.map(callbackfn [, thisArg])
	  map: function map(callbackfn
	  /* , thisArg */
	  ) {
	    return $map(this, callbackfn, arguments[1]);
	  }
	});

	var $filter = _arrayMethods(2);

	_export(_export.P + _export.F * !_strictMethod([].filter, true), 'Array', {
	  // 22.1.3.7 / 15.4.4.20 Array.prototype.filter(callbackfn [, thisArg])
	  filter: function filter(callbackfn
	  /* , thisArg */
	  ) {
	    return $filter(this, callbackfn, arguments[1]);
	  }
	});

	var $some = _arrayMethods(3);

	_export(_export.P + _export.F * !_strictMethod([].some, true), 'Array', {
	  // 22.1.3.23 / 15.4.4.17 Array.prototype.some(callbackfn [, thisArg])
	  some: function some(callbackfn
	  /* , thisArg */
	  ) {
	    return $some(this, callbackfn, arguments[1]);
	  }
	});

	var $every = _arrayMethods(4);

	_export(_export.P + _export.F * !_strictMethod([].every, true), 'Array', {
	  // 22.1.3.5 / 15.4.4.16 Array.prototype.every(callbackfn [, thisArg])
	  every: function every(callbackfn
	  /* , thisArg */
	  ) {
	    return $every(this, callbackfn, arguments[1]);
	  }
	});

	var _arrayReduce = function (that, callbackfn, aLen, memo, isRight) {
	  _aFunction(callbackfn);
	  var O = _toObject(that);
	  var self = _iobject(O);
	  var length = _toLength(O.length);
	  var index = isRight ? length - 1 : 0;
	  var i = isRight ? -1 : 1;
	  if (aLen < 2) for (;;) {
	    if (index in self) {
	      memo = self[index];
	      index += i;
	      break;
	    }

	    index += i;

	    if (isRight ? index < 0 : length <= index) {
	      throw TypeError('Reduce of empty array with no initial value');
	    }
	  }

	  for (; isRight ? index >= 0 : length > index; index += i) {
	    if (index in self) {
	      memo = callbackfn(memo, self[index], index, O);
	    }
	  }

	  return memo;
	};

	_export(_export.P + _export.F * !_strictMethod([].reduce, true), 'Array', {
	  // 22.1.3.18 / 15.4.4.21 Array.prototype.reduce(callbackfn [, initialValue])
	  reduce: function reduce(callbackfn
	  /* , initialValue */
	  ) {
	    return _arrayReduce(this, callbackfn, arguments.length, arguments[1], false);
	  }
	});

	_export(_export.P + _export.F * !_strictMethod([].reduceRight, true), 'Array', {
	  // 22.1.3.19 / 15.4.4.22 Array.prototype.reduceRight(callbackfn [, initialValue])
	  reduceRight: function reduceRight(callbackfn
	  /* , initialValue */
	  ) {
	    return _arrayReduce(this, callbackfn, arguments.length, arguments[1], true);
	  }
	});

	var $indexOf = _arrayIncludes(false);

	var $native = [].indexOf;
	var NEGATIVE_ZERO = !!$native && 1 / [1].indexOf(1, -0) < 0;
	_export(_export.P + _export.F * (NEGATIVE_ZERO || !_strictMethod($native)), 'Array', {
	  // 22.1.3.11 / 15.4.4.14 Array.prototype.indexOf(searchElement [, fromIndex])
	  indexOf: function indexOf(searchElement
	  /* , fromIndex = 0 */
	  ) {
	    return NEGATIVE_ZERO // convert -0 to +0
	    ? $native.apply(this, arguments) || 0 : $indexOf(this, searchElement, arguments[1]);
	  }
	});

	var $native$1 = [].lastIndexOf;
	var NEGATIVE_ZERO$1 = !!$native$1 && 1 / [1].lastIndexOf(1, -0) < 0;
	_export(_export.P + _export.F * (NEGATIVE_ZERO$1 || !_strictMethod($native$1)), 'Array', {
	  // 22.1.3.14 / 15.4.4.15 Array.prototype.lastIndexOf(searchElement [, fromIndex])
	  lastIndexOf: function lastIndexOf(searchElement
	  /* , fromIndex = @[*-1] */
	  ) {
	    // convert -0 to +0
	    if (NEGATIVE_ZERO$1) return $native$1.apply(this, arguments) || 0;
	    var O = _toIobject(this);
	    var length = _toLength(O.length);
	    var index = length - 1;
	    if (arguments.length > 1) index = Math.min(index, _toInteger(arguments[1]));
	    if (index < 0) index = length + index;

	    for (; index >= 0; index--) {
	      if (index in O) if (O[index] === searchElement) return index || 0;
	    }

	    return -1;
	  }
	});

	var _arrayCopyWithin = [].copyWithin || function copyWithin(target
	/* = 0 */
	, start
	/* = 0, end = @length */
	) {
	  var O = _toObject(this);
	  var len = _toLength(O.length);
	  var to = _toAbsoluteIndex(target, len);
	  var from = _toAbsoluteIndex(start, len);
	  var end = arguments.length > 2 ? arguments[2] : undefined;
	  var count = Math.min((end === undefined ? len : _toAbsoluteIndex(end, len)) - from, len - to);
	  var inc = 1;

	  if (from < to && to < from + count) {
	    inc = -1;
	    from += count - 1;
	    to += count - 1;
	  }

	  while (count-- > 0) {
	    if (from in O) O[to] = O[from];else delete O[to];
	    to += inc;
	    from += inc;
	  }

	  return O;
	};

	// 22.1.3.31 Array.prototype[@@unscopables]
	var UNSCOPABLES = _wks('unscopables');

	var ArrayProto$1 = Array.prototype;
	if (ArrayProto$1[UNSCOPABLES] == undefined) _hide(ArrayProto$1, UNSCOPABLES, {});

	var _addToUnscopables = function (key) {
	  ArrayProto$1[UNSCOPABLES][key] = true;
	};

	// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)


	_export(_export.P, 'Array', {
	  copyWithin: _arrayCopyWithin
	});

	_addToUnscopables('copyWithin');

	var _arrayFill = function fill(value
	/* , start = 0, end = @length */
	) {
	  var O = _toObject(this);
	  var length = _toLength(O.length);
	  var aLen = arguments.length;
	  var index = _toAbsoluteIndex(aLen > 1 ? arguments[1] : undefined, length);
	  var end = aLen > 2 ? arguments[2] : undefined;
	  var endPos = end === undefined ? length : _toAbsoluteIndex(end, length);

	  while (endPos > index) {
	    O[index++] = value;
	  }

	  return O;
	};

	// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)


	_export(_export.P, 'Array', {
	  fill: _arrayFill
	});

	_addToUnscopables('fill');

	var $find = _arrayMethods(5);

	var KEY = 'find';
	var forced = true; // Shouldn't skip holes

	if (KEY in []) Array(1)[KEY](function () {
	  forced = false;
	});
	_export(_export.P + _export.F * forced, 'Array', {
	  find: function find(callbackfn
	  /* , that = undefined */
	  ) {
	    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

	_addToUnscopables(KEY);

	var $find$1 = _arrayMethods(6);

	var KEY$1 = 'findIndex';
	var forced$1 = true; // Shouldn't skip holes

	if (KEY$1 in []) Array(1)[KEY$1](function () {
	  forced$1 = false;
	});
	_export(_export.P + _export.F * forced$1, 'Array', {
	  findIndex: function findIndex(callbackfn
	  /* , that = undefined */
	  ) {
	    return $find$1(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

	_addToUnscopables(KEY$1);

	var SPECIES$1 = _wks('species');

	var _setSpecies = function (KEY) {
	  var C = _global[KEY];
	  if (_descriptors && C && !C[SPECIES$1]) _objectDp.f(C, SPECIES$1, {
	    configurable: true,
	    get: function get() {
	      return this;
	    }
	  });
	};

	_setSpecies('Array');

	var _iterStep = function (done, value) {
	  return {
	    value: value,
	    done: !!done
	  };
	};

	// 22.1.3.4 Array.prototype.entries()
	// 22.1.3.13 Array.prototype.keys()
	// 22.1.3.29 Array.prototype.values()
	// 22.1.3.30 Array.prototype[@@iterator]()


	var es6_array_iterator = _iterDefine(Array, 'Array', function (iterated, kind) {
	  this._t = _toIobject(iterated); // target

	  this._i = 0; // next index

	  this._k = kind; // kind
	  // 22.1.5.2.1 %ArrayIteratorPrototype%.next()
	}, function () {
	  var O = this._t;
	  var kind = this._k;
	  var index = this._i++;

	  if (!O || index >= O.length) {
	    this._t = undefined;
	    return _iterStep(1);
	  }

	  if (kind == 'keys') return _iterStep(0, index);
	  if (kind == 'values') return _iterStep(0, O[index]);
	  return _iterStep(0, [index, O[index]]);
	}, 'values'); // argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)

	_iterators.Arguments = _iterators.Array;
	_addToUnscopables('keys');
	_addToUnscopables('values');
	_addToUnscopables('entries');

	var _flags = function () {
	  var that = _anObject(this);
	  var result = '';
	  if (that.global) result += 'g';
	  if (that.ignoreCase) result += 'i';
	  if (that.multiline) result += 'm';
	  if (that.unicode) result += 'u';
	  if (that.sticky) result += 'y';
	  return result;
	};

	var dP$4 = _objectDp.f;

	var gOPN$3 = _objectGopn.f;





	var $RegExp = _global.RegExp;
	var Base$1 = $RegExp;
	var proto$2 = $RegExp.prototype;
	var re1 = /a/g;
	var re2 = /a/g; // "new" creates a new object, old webkit buggy here

	var CORRECT_NEW = new $RegExp(re1) !== re1;

	if (_descriptors && (!CORRECT_NEW || _fails(function () {
	  re2[_wks('match')] = false; // RegExp constructor can alter flags and IsRegExp works correct with @@match

	  return $RegExp(re1) != re1 || $RegExp(re2) == re2 || $RegExp(re1, 'i') != '/a/i';
	}))) {
	  $RegExp = function RegExp(p, f) {
	    var tiRE = this instanceof $RegExp;
	    var piRE = _isRegexp(p);
	    var fiU = f === undefined;
	    return !tiRE && piRE && p.constructor === $RegExp && fiU ? p : _inheritIfRequired(CORRECT_NEW ? new Base$1(piRE && !fiU ? p.source : p, f) : Base$1((piRE = p instanceof $RegExp) ? p.source : p, piRE && fiU ? _flags.call(p) : f), tiRE ? this : proto$2, $RegExp);
	  };

	  var proxy = function proxy(key) {
	    key in $RegExp || dP$4($RegExp, key, {
	      configurable: true,
	      get: function get() {
	        return Base$1[key];
	      },
	      set: function set(it) {
	        Base$1[key] = it;
	      }
	    });
	  };

	  for (var keys$1 = gOPN$3(Base$1), i = 0; keys$1.length > i;) {
	    proxy(keys$1[i++]);
	  }

	  proto$2.constructor = $RegExp;
	  $RegExp.prototype = proto$2;

	  _redefine(_global, 'RegExp', $RegExp);
	}

	_setSpecies('RegExp');

	var nativeExec = RegExp.prototype.exec; // This always refers to the native implementation, because the
	// String#replace polyfill uses ./fix-regexp-well-known-symbol-logic.js,
	// which loads this file before patching the method.

	var nativeReplace = String.prototype.replace;
	var patchedExec = nativeExec;
	var LAST_INDEX = 'lastIndex';

	var UPDATES_LAST_INDEX_WRONG = function () {
	  var re1 = /a/,
	      re2 = /b*/g;
	  nativeExec.call(re1, 'a');
	  nativeExec.call(re2, 'a');
	  return re1[LAST_INDEX] !== 0 || re2[LAST_INDEX] !== 0;
	}(); // nonparticipating capturing group, copied from es5-shim's String#split patch.


	var NPCG_INCLUDED = /()??/.exec('')[1] !== undefined;
	var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED;

	if (PATCH) {
	  patchedExec = function exec(str) {
	    var re = this;
	    var lastIndex, reCopy, match, i;

	    if (NPCG_INCLUDED) {
	      reCopy = new RegExp('^' + re.source + '$(?!\\s)', _flags.call(re));
	    }

	    if (UPDATES_LAST_INDEX_WRONG) lastIndex = re[LAST_INDEX];
	    match = nativeExec.call(re, str);

	    if (UPDATES_LAST_INDEX_WRONG && match) {
	      re[LAST_INDEX] = re.global ? match.index + match[0].length : lastIndex;
	    }

	    if (NPCG_INCLUDED && match && match.length > 1) {
	      // Fix browsers whose `exec` methods don't consistently return `undefined`
	      // for NPCG, like IE8. NOTE: This doesn' work for /(.?)?/
	      // eslint-disable-next-line no-loop-func
	      nativeReplace.call(match[0], reCopy, function () {
	        for (i = 1; i < arguments.length - 2; i++) {
	          if (arguments[i] === undefined) match[i] = undefined;
	        }
	      });
	    }

	    return match;
	  };
	}

	var _regexpExec = patchedExec;

	_export({
	  target: 'RegExp',
	  proto: true,
	  forced: _regexpExec !== /./.exec
	}, {
	  exec: _regexpExec
	});

	// 21.2.5.3 get RegExp.prototype.flags()
	if (_descriptors && /./g.flags != 'g') _objectDp.f(RegExp.prototype, 'flags', {
	  configurable: true,
	  get: _flags
	});

	var TO_STRING$1 = 'toString';
	var $toString$1 = /./[TO_STRING$1];

	var define = function define(fn) {
	  _redefine(RegExp.prototype, TO_STRING$1, fn, true);
	}; // 21.2.5.14 RegExp.prototype.toString()


	if (_fails(function () {
	  return $toString$1.call({
	    source: 'a',
	    flags: 'b'
	  }) != '/a/b';
	})) {
	  define(function toString() {
	    var R = _anObject(this);
	    return '/'.concat(R.source, '/', 'flags' in R ? R.flags : !_descriptors && R instanceof RegExp ? _flags.call(R) : undefined);
	  }); // FF44- RegExp#toString has a wrong name
	} else if ($toString$1.name != TO_STRING$1) {
	  define(function toString() {
	    return $toString$1.call(this);
	  });
	}

	var at = _stringAt(true); // `AdvanceStringIndex` abstract operation
	// https://tc39.github.io/ecma262/#sec-advancestringindex


	var _advanceStringIndex = function (S, index, unicode) {
	  return index + (unicode ? at(S, index).length : 1);
	};

	var builtinExec = RegExp.prototype.exec; // `RegExpExec` abstract operation
	// https://tc39.github.io/ecma262/#sec-regexpexec

	var _regexpExecAbstract = function (R, S) {
	  var exec = R.exec;

	  if (typeof exec === 'function') {
	    var result = exec.call(R, S);

	    if (babelHelpers.typeof(result) !== 'object') {
	      throw new TypeError('RegExp exec method returned something other than an Object or null');
	    }

	    return result;
	  }

	  if (_classof(R) !== 'RegExp') {
	    throw new TypeError('RegExp#exec called on incompatible receiver');
	  }

	  return builtinExec.call(R, S);
	};

	var SPECIES$2 = _wks('species');
	var REPLACE_SUPPORTS_NAMED_GROUPS = !_fails(function () {
	  // #replace needs built-in support for named groups.
	  // #match works fine because it just return the exec results, even if it has
	  // a "grops" property.
	  var re = /./;

	  re.exec = function () {
	    var result = [];
	    result.groups = {
	      a: '7'
	    };
	    return result;
	  };

	  return ''.replace(re, '$<a>') !== '7';
	});

	var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = function () {
	  // Chrome 51 has a buggy "split" implementation when RegExp#exec !== nativeExec
	  var re = /(?:)/;
	  var originalExec = re.exec;

	  re.exec = function () {
	    return originalExec.apply(this, arguments);
	  };

	  var result = 'ab'.split(re);
	  return result.length === 2 && result[0] === 'a' && result[1] === 'b';
	}();

	var _fixReWks = function (KEY, length, exec) {
	  var SYMBOL = _wks(KEY);
	  var DELEGATES_TO_SYMBOL = !_fails(function () {
	    // String methods call symbol-named RegEp methods
	    var O = {};

	    O[SYMBOL] = function () {
	      return 7;
	    };

	    return ''[KEY](O) != 7;
	  });
	  var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL ? !_fails(function () {
	    // Symbol-named RegExp methods call .exec
	    var execCalled = false;
	    var re = /a/;

	    re.exec = function () {
	      execCalled = true;
	      return null;
	    };

	    if (KEY === 'split') {
	      // RegExp[@@split] doesn't call the regex's exec method, but first creates
	      // a new one. We need to return the patched regex when creating the new one.
	      re.constructor = {};

	      re.constructor[SPECIES$2] = function () {
	        return re;
	      };
	    }

	    re[SYMBOL]('');
	    return !execCalled;
	  }) : undefined;

	  if (!DELEGATES_TO_SYMBOL || !DELEGATES_TO_EXEC || KEY === 'replace' && !REPLACE_SUPPORTS_NAMED_GROUPS || KEY === 'split' && !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC) {
	    var nativeRegExpMethod = /./[SYMBOL];
	    var fns = exec(_defined, SYMBOL, ''[KEY], function maybeCallNative(nativeMethod, regexp, str, arg2, forceStringMethod) {
	      if (regexp.exec === _regexpExec) {
	        if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
	          // The native String method already delegates to @@method (this
	          // polyfilled function), leasing to infinite recursion.
	          // We avoid it by directly calling the native @@method method.
	          return {
	            done: true,
	            value: nativeRegExpMethod.call(regexp, str, arg2)
	          };
	        }

	        return {
	          done: true,
	          value: nativeMethod.call(str, regexp, arg2)
	        };
	      }

	      return {
	        done: false
	      };
	    });
	    var strfn = fns[0];
	    var rxfn = fns[1];
	    _redefine(String.prototype, KEY, strfn);
	    _hide(RegExp.prototype, SYMBOL, length == 2 // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
	    // 21.2.5.11 RegExp.prototype[@@split](string, limit)
	    ? function (string, arg) {
	      return rxfn.call(string, this, arg);
	    } // 21.2.5.6 RegExp.prototype[@@match](string)
	    // 21.2.5.9 RegExp.prototype[@@search](string)
	    : function (string) {
	      return rxfn.call(string, this);
	    });
	  }
	};

	// @@match logic


	_fixReWks('match', 1, function (defined, MATCH, $match, maybeCallNative) {
	  return [// `String.prototype.match` method
	  // https://tc39.github.io/ecma262/#sec-string.prototype.match
	  function match(regexp) {
	    var O = defined(this);
	    var fn = regexp == undefined ? undefined : regexp[MATCH];
	    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));
	  }, // `RegExp.prototype[@@match]` method
	  // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@match
	  function (regexp) {
	    var res = maybeCallNative($match, regexp, this);
	    if (res.done) return res.value;
	    var rx = _anObject(regexp);
	    var S = String(this);
	    if (!rx.global) return _regexpExecAbstract(rx, S);
	    var fullUnicode = rx.unicode;
	    rx.lastIndex = 0;
	    var A = [];
	    var n = 0;
	    var result;

	    while ((result = _regexpExecAbstract(rx, S)) !== null) {
	      var matchStr = String(result[0]);
	      A[n] = matchStr;
	      if (matchStr === '') rx.lastIndex = _advanceStringIndex(S, _toLength(rx.lastIndex), fullUnicode);
	      n++;
	    }

	    return n === 0 ? null : A;
	  }];
	});

	var max$1 = Math.max;
	var min$2 = Math.min;
	var floor$3 = Math.floor;
	var SUBSTITUTION_SYMBOLS = /\$([$&`']|\d\d?|<[^>]*>)/g;
	var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&`']|\d\d?)/g;

	var maybeToString = function maybeToString(it) {
	  return it === undefined ? it : String(it);
	}; // @@replace logic


	_fixReWks('replace', 2, function (defined, REPLACE, $replace, maybeCallNative) {
	  return [// `String.prototype.replace` method
	  // https://tc39.github.io/ecma262/#sec-string.prototype.replace
	  function replace(searchValue, replaceValue) {
	    var O = defined(this);
	    var fn = searchValue == undefined ? undefined : searchValue[REPLACE];
	    return fn !== undefined ? fn.call(searchValue, O, replaceValue) : $replace.call(String(O), searchValue, replaceValue);
	  }, // `RegExp.prototype[@@replace]` method
	  // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@replace
	  function (regexp, replaceValue) {
	    var res = maybeCallNative($replace, regexp, this, replaceValue);
	    if (res.done) return res.value;
	    var rx = _anObject(regexp);
	    var S = String(this);
	    var functionalReplace = typeof replaceValue === 'function';
	    if (!functionalReplace) replaceValue = String(replaceValue);
	    var global = rx.global;

	    if (global) {
	      var fullUnicode = rx.unicode;
	      rx.lastIndex = 0;
	    }

	    var results = [];

	    while (true) {
	      var result = _regexpExecAbstract(rx, S);
	      if (result === null) break;
	      results.push(result);
	      if (!global) break;
	      var matchStr = String(result[0]);
	      if (matchStr === '') rx.lastIndex = _advanceStringIndex(S, _toLength(rx.lastIndex), fullUnicode);
	    }

	    var accumulatedResult = '';
	    var nextSourcePosition = 0;

	    for (var i = 0; i < results.length; i++) {
	      result = results[i];
	      var matched = String(result[0]);
	      var position = max$1(min$2(_toInteger(result.index), S.length), 0);
	      var captures = []; // NOTE: This is equivalent to
	      //   captures = result.slice(1).map(maybeToString)
	      // but for some reason `nativeSlice.call(result, 1, result.length)` (called in
	      // the slice polyfill when slicing native arrays) "doesn't work" in safari 9 and
	      // causes a crash (https://pastebin.com/N21QzeQA) when trying to debug it.

	      for (var j = 1; j < result.length; j++) {
	        captures.push(maybeToString(result[j]));
	      }

	      var namedCaptures = result.groups;

	      if (functionalReplace) {
	        var replacerArgs = [matched].concat(captures, position, S);
	        if (namedCaptures !== undefined) replacerArgs.push(namedCaptures);
	        var replacement = String(replaceValue.apply(undefined, replacerArgs));
	      } else {
	        replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);
	      }

	      if (position >= nextSourcePosition) {
	        accumulatedResult += S.slice(nextSourcePosition, position) + replacement;
	        nextSourcePosition = position + matched.length;
	      }
	    }

	    return accumulatedResult + S.slice(nextSourcePosition);
	  }]; // https://tc39.github.io/ecma262/#sec-getsubstitution

	  function getSubstitution(matched, str, position, captures, namedCaptures, replacement) {
	    var tailPos = position + matched.length;
	    var m = captures.length;
	    var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;

	    if (namedCaptures !== undefined) {
	      namedCaptures = _toObject(namedCaptures);
	      symbols = SUBSTITUTION_SYMBOLS;
	    }

	    return $replace.call(replacement, symbols, function (match, ch) {
	      var capture;

	      switch (ch.charAt(0)) {
	        case '$':
	          return '$';

	        case '&':
	          return matched;

	        case '`':
	          return str.slice(0, position);

	        case "'":
	          return str.slice(tailPos);

	        case '<':
	          capture = namedCaptures[ch.slice(1, -1)];
	          break;

	        default:
	          // \d\d?
	          var n = +ch;
	          if (n === 0) return match;

	          if (n > m) {
	            var f = floor$3(n / 10);
	            if (f === 0) return match;
	            if (f <= m) return captures[f - 1] === undefined ? ch.charAt(1) : captures[f - 1] + ch.charAt(1);
	            return match;
	          }

	          capture = captures[n - 1];
	      }

	      return capture === undefined ? '' : capture;
	    });
	  }
	});

	// @@search logic


	_fixReWks('search', 1, function (defined, SEARCH, $search, maybeCallNative) {
	  return [// `String.prototype.search` method
	  // https://tc39.github.io/ecma262/#sec-string.prototype.search
	  function search(regexp) {
	    var O = defined(this);
	    var fn = regexp == undefined ? undefined : regexp[SEARCH];
	    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[SEARCH](String(O));
	  }, // `RegExp.prototype[@@search]` method
	  // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@search
	  function (regexp) {
	    var res = maybeCallNative($search, regexp, this);
	    if (res.done) return res.value;
	    var rx = _anObject(regexp);
	    var S = String(this);
	    var previousLastIndex = rx.lastIndex;
	    if (!_sameValue(previousLastIndex, 0)) rx.lastIndex = 0;
	    var result = _regexpExecAbstract(rx, S);
	    if (!_sameValue(rx.lastIndex, previousLastIndex)) rx.lastIndex = previousLastIndex;
	    return result === null ? -1 : result.index;
	  }];
	});

	// 7.3.20 SpeciesConstructor(O, defaultConstructor)




	var SPECIES$3 = _wks('species');

	var _speciesConstructor = function (O, D) {
	  var C = _anObject(O).constructor;
	  var S;
	  return C === undefined || (S = _anObject(C)[SPECIES$3]) == undefined ? D : _aFunction(S);
	};

	var $min = Math.min;
	var $push = [].push;
	var $SPLIT = 'split';
	var LENGTH = 'length';
	var LAST_INDEX$1 = 'lastIndex';
	var MAX_UINT32 = 0xffffffff; // babel-minify transpiles RegExp('x', 'y') -> /x/y and it causes SyntaxError

	var SUPPORTS_Y = !_fails(function () {
	}); // @@split logic

	_fixReWks('split', 2, function (defined, SPLIT, $split, maybeCallNative) {
	  var internalSplit;

	  if ('abbc'[$SPLIT](/(b)*/)[1] == 'c' || 'test'[$SPLIT](/(?:)/, -1)[LENGTH] != 4 || 'ab'[$SPLIT](/(?:ab)*/)[LENGTH] != 2 || '.'[$SPLIT](/(.?)(.?)/)[LENGTH] != 4 || '.'[$SPLIT](/()()/)[LENGTH] > 1 || ''[$SPLIT](/.?/)[LENGTH]) {
	    // based on es5-shim implementation, need to rework it
	    internalSplit = function internalSplit(separator, limit) {
	      var string = String(this);
	      if (separator === undefined && limit === 0) return []; // If `separator` is not a regex, use native split

	      if (!_isRegexp(separator)) return $split.call(string, separator, limit);
	      var output = [];
	      var flags = (separator.ignoreCase ? 'i' : '') + (separator.multiline ? 'm' : '') + (separator.unicode ? 'u' : '') + (separator.sticky ? 'y' : '');
	      var lastLastIndex = 0;
	      var splitLimit = limit === undefined ? MAX_UINT32 : limit >>> 0; // Make `global` and avoid `lastIndex` issues by working with a copy

	      var separatorCopy = new RegExp(separator.source, flags + 'g');
	      var match, lastIndex, lastLength;

	      while (match = _regexpExec.call(separatorCopy, string)) {
	        lastIndex = separatorCopy[LAST_INDEX$1];

	        if (lastIndex > lastLastIndex) {
	          output.push(string.slice(lastLastIndex, match.index));
	          if (match[LENGTH] > 1 && match.index < string[LENGTH]) $push.apply(output, match.slice(1));
	          lastLength = match[0][LENGTH];
	          lastLastIndex = lastIndex;
	          if (output[LENGTH] >= splitLimit) break;
	        }

	        if (separatorCopy[LAST_INDEX$1] === match.index) separatorCopy[LAST_INDEX$1]++; // Avoid an infinite loop
	      }

	      if (lastLastIndex === string[LENGTH]) {
	        if (lastLength || !separatorCopy.test('')) output.push('');
	      } else output.push(string.slice(lastLastIndex));

	      return output[LENGTH] > splitLimit ? output.slice(0, splitLimit) : output;
	    }; // Chakra, V8

	  } else if ('0'[$SPLIT](undefined, 0)[LENGTH]) {
	    internalSplit = function internalSplit(separator, limit) {
	      return separator === undefined && limit === 0 ? [] : $split.call(this, separator, limit);
	    };
	  } else {
	    internalSplit = $split;
	  }

	  return [// `String.prototype.split` method
	  // https://tc39.github.io/ecma262/#sec-string.prototype.split
	  function split(separator, limit) {
	    var O = defined(this);
	    var splitter = separator == undefined ? undefined : separator[SPLIT];
	    return splitter !== undefined ? splitter.call(separator, O, limit) : internalSplit.call(String(O), separator, limit);
	  }, // `RegExp.prototype[@@split]` method
	  // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@split
	  //
	  // NOTE: This cannot be properly polyfilled in engines that don't support
	  // the 'y' flag.
	  function (regexp, limit) {
	    var res = maybeCallNative(internalSplit, regexp, this, limit, internalSplit !== $split);
	    if (res.done) return res.value;
	    var rx = _anObject(regexp);
	    var S = String(this);
	    var C = _speciesConstructor(rx, RegExp);
	    var unicodeMatching = rx.unicode;
	    var flags = (rx.ignoreCase ? 'i' : '') + (rx.multiline ? 'm' : '') + (rx.unicode ? 'u' : '') + (SUPPORTS_Y ? 'y' : 'g'); // ^(? + rx + ) is needed, in combination with some S slicing, to
	    // simulate the 'y' flag.

	    var splitter = new C(SUPPORTS_Y ? rx : '^(?:' + rx.source + ')', flags);
	    var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;
	    if (lim === 0) return [];
	    if (S.length === 0) return _regexpExecAbstract(splitter, S) === null ? [S] : [];
	    var p = 0;
	    var q = 0;
	    var A = [];

	    while (q < S.length) {
	      splitter.lastIndex = SUPPORTS_Y ? q : 0;
	      var z = _regexpExecAbstract(splitter, SUPPORTS_Y ? S : S.slice(q));
	      var e;

	      if (z === null || (e = $min(_toLength(splitter.lastIndex + (SUPPORTS_Y ? 0 : q)), S.length)) === p) {
	        q = _advanceStringIndex(S, q, unicodeMatching);
	      } else {
	        A.push(S.slice(p, q));
	        if (A.length === lim) return A;

	        for (var i = 1; i <= z.length - 1; i++) {
	          A.push(z[i]);
	          if (A.length === lim) return A;
	        }

	        q = p = e;
	      }
	    }

	    A.push(S.slice(p));
	    return A;
	  }];
	});

	var _anInstance = function (it, Constructor, name, forbiddenField) {
	  if (!(it instanceof Constructor) || forbiddenField !== undefined && forbiddenField in it) {
	    throw TypeError(name + ': incorrect invocation!');
	  }

	  return it;
	};

	var _forOf = createCommonjsModule(function (module) {
	var BREAK = {};
	var RETURN = {};

	var exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {
	  var iterFn = ITERATOR ? function () {
	    return iterable;
	  } : core_getIteratorMethod(iterable);
	  var f = _ctx(fn, that, entries ? 2 : 1);
	  var index = 0;
	  var length, step, iterator, result;
	  if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!'); // fast case for arrays with default iterator

	  if (_isArrayIter(iterFn)) for (length = _toLength(iterable.length); length > index; index++) {
	    result = entries ? f(_anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
	    if (result === BREAK || result === RETURN) return result;
	  } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
	    result = _iterCall(iterator, f, step.value, entries);
	    if (result === BREAK || result === RETURN) return result;
	  }
	};

	exports.BREAK = BREAK;
	exports.RETURN = RETURN;
	});

	var process = _global.process;
	var setTask = _global.setImmediate;
	var clearTask = _global.clearImmediate;
	var MessageChannel = _global.MessageChannel;
	var Dispatch = _global.Dispatch;
	var counter = 0;
	var queue = {};
	var ONREADYSTATECHANGE = 'onreadystatechange';
	var defer, channel, port;

	var run = function run() {
	  var id = +this; // eslint-disable-next-line no-prototype-builtins

	  if (queue.hasOwnProperty(id)) {
	    var fn = queue[id];
	    delete queue[id];
	    fn();
	  }
	};

	var listener = function listener(event) {
	  run.call(event.data);
	}; // Node.js 0.9+ & IE10+ has setImmediate, otherwise:


	if (!setTask || !clearTask) {
	  setTask = function setImmediate(fn) {
	    var args = [];
	    var i = 1;

	    while (arguments.length > i) {
	      args.push(arguments[i++]);
	    }

	    queue[++counter] = function () {
	      // eslint-disable-next-line no-new-func
	      _invoke(typeof fn == 'function' ? fn : Function(fn), args);
	    };

	    defer(counter);
	    return counter;
	  };

	  clearTask = function clearImmediate(id) {
	    delete queue[id];
	  }; // Node.js 0.8-


	  if (_cof(process) == 'process') {
	    defer = function defer(id) {
	      process.nextTick(_ctx(run, id, 1));
	    }; // Sphere (JS game engine) Dispatch API

	  } else if (Dispatch && Dispatch.now) {
	    defer = function defer(id) {
	      Dispatch.now(_ctx(run, id, 1));
	    }; // Browsers with MessageChannel, includes WebWorkers

	  } else if (MessageChannel) {
	    channel = new MessageChannel();
	    port = channel.port2;
	    channel.port1.onmessage = listener;
	    defer = _ctx(port.postMessage, port, 1); // Browsers with postMessage, skip WebWorkers
	    // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
	  } else if (_global.addEventListener && typeof postMessage == 'function' && !_global.importScripts) {
	    defer = function defer(id) {
	      _global.postMessage(id + '', '*');
	    };

	    _global.addEventListener('message', listener, false); // IE8-
	  } else if (ONREADYSTATECHANGE in _domCreate('script')) {
	    defer = function defer(id) {
	      _html.appendChild(_domCreate('script'))[ONREADYSTATECHANGE] = function () {
	        _html.removeChild(this);
	        run.call(id);
	      };
	    }; // Rest old browsers

	  } else {
	    defer = function defer(id) {
	      setTimeout(_ctx(run, id, 1), 0);
	    };
	  }
	}

	var _task = {
	  set: setTask,
	  clear: clearTask
	};

	var macrotask = _task.set;

	var Observer = _global.MutationObserver || _global.WebKitMutationObserver;
	var process$1 = _global.process;
	var Promise = _global.Promise;
	var isNode = _cof(process$1) == 'process';

	var _microtask = function () {
	  var head, last, notify;

	  var flush = function flush() {
	    var parent, fn;
	    if (isNode && (parent = process$1.domain)) parent.exit();

	    while (head) {
	      fn = head.fn;
	      head = head.next;

	      try {
	        fn();
	      } catch (e) {
	        if (head) notify();else last = undefined;
	        throw e;
	      }
	    }

	    last = undefined;
	    if (parent) parent.enter();
	  }; // Node.js


	  if (isNode) {
	    notify = function notify() {
	      process$1.nextTick(flush);
	    }; // browsers with MutationObserver, except iOS Safari - https://github.com/zloirock/core-js/issues/339

	  } else if (Observer && !(_global.navigator && _global.navigator.standalone)) {
	    var toggle = true;
	    var node = document.createTextNode('');
	    new Observer(flush).observe(node, {
	      characterData: true
	    }); // eslint-disable-line no-new

	    notify = function notify() {
	      node.data = toggle = !toggle;
	    }; // environments with maybe non-completely correct, but existent Promise

	  } else if (Promise && Promise.resolve) {
	    // Promise.resolve without an argument throws an error in LG WebOS 2
	    var promise = Promise.resolve(undefined);

	    notify = function notify() {
	      promise.then(flush);
	    }; // for other environments - macrotask based on:
	    // - setImmediate
	    // - MessageChannel
	    // - window.postMessag
	    // - onreadystatechange
	    // - setTimeout

	  } else {
	    notify = function notify() {
	      // strange IE + webpack dev server bug - use .call(global)
	      macrotask.call(_global, flush);
	    };
	  }

	  return function (fn) {
	    var task = {
	      fn: fn,
	      next: undefined
	    };
	    if (last) last.next = task;

	    if (!head) {
	      head = task;
	      notify();
	    }

	    last = task;
	  };
	};

	function PromiseCapability(C) {
	  var resolve, reject;
	  this.promise = new C(function ($$resolve, $$reject) {
	    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
	    resolve = $$resolve;
	    reject = $$reject;
	  });
	  this.resolve = _aFunction(resolve);
	  this.reject = _aFunction(reject);
	}

	var f$7 = function (C) {
	  return new PromiseCapability(C);
	};

	var _newPromiseCapability = {
		f: f$7
	};

	var _perform = function (exec) {
	  try {
	    return {
	      e: false,
	      v: exec()
	    };
	  } catch (e) {
	    return {
	      e: true,
	      v: e
	    };
	  }
	};

	var navigator = _global.navigator;
	var _userAgent = navigator && navigator.userAgent || '';

	var _promiseResolve = function (C, x) {
	  _anObject(C);
	  if (_isObject(x) && x.constructor === C) return x;
	  var promiseCapability = _newPromiseCapability.f(C);
	  var resolve = promiseCapability.resolve;
	  resolve(x);
	  return promiseCapability.promise;
	};

	var _redefineAll = function (target, src, safe) {
	  for (var key in src) {
	    _redefine(target, key, src[key], safe);
	  }

	  return target;
	};

	var task = _task.set;

	var microtask = _microtask();









	var PROMISE = 'Promise';
	var TypeError$1 = _global.TypeError;
	var process$2 = _global.process;
	var versions = process$2 && process$2.versions;
	var v8 = versions && versions.v8 || '';
	var $Promise = _global[PROMISE];
	var isNode$1 = _classof(process$2) == 'process';

	var empty = function empty() {
	  /* empty */
	};

	var Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper;
	var newPromiseCapability = newGenericPromiseCapability = _newPromiseCapability.f;
	var USE_NATIVE$1 = !!function () {
	  try {
	    // correct subclassing with @@species support
	    var promise = $Promise.resolve(1);

	    var FakePromise = (promise.constructor = {})[_wks('species')] = function (exec) {
	      exec(empty, empty);
	    }; // unhandled rejections tracking support, NodeJS Promise without it fails @@species test


	    return (isNode$1 || typeof PromiseRejectionEvent == 'function') && promise.then(empty) instanceof FakePromise // v8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables
	    // https://bugs.chromium.org/p/chromium/issues/detail?id=830565
	    // we can't detect it synchronously, so just check versions
	    && v8.indexOf('6.6') !== 0 && _userAgent.indexOf('Chrome/66') === -1;
	  } catch (e) {
	    /* empty */
	  }
	}(); // helpers

	var isThenable = function isThenable(it) {
	  var then;
	  return _isObject(it) && typeof (then = it.then) == 'function' ? then : false;
	};

	var notify = function notify(promise, isReject) {
	  if (promise._n) return;
	  promise._n = true;
	  var chain = promise._c;
	  microtask(function () {
	    var value = promise._v;
	    var ok = promise._s == 1;
	    var i = 0;

	    var run = function run(reaction) {
	      var handler = ok ? reaction.ok : reaction.fail;
	      var resolve = reaction.resolve;
	      var reject = reaction.reject;
	      var domain = reaction.domain;
	      var result, then, exited;

	      try {
	        if (handler) {
	          if (!ok) {
	            if (promise._h == 2) onHandleUnhandled(promise);
	            promise._h = 1;
	          }

	          if (handler === true) result = value;else {
	            if (domain) domain.enter();
	            result = handler(value); // may throw

	            if (domain) {
	              domain.exit();
	              exited = true;
	            }
	          }

	          if (result === reaction.promise) {
	            reject(TypeError$1('Promise-chain cycle'));
	          } else if (then = isThenable(result)) {
	            then.call(result, resolve, reject);
	          } else resolve(result);
	        } else reject(value);
	      } catch (e) {
	        if (domain && !exited) domain.exit();
	        reject(e);
	      }
	    };

	    while (chain.length > i) {
	      run(chain[i++]);
	    } // variable length - can't use forEach


	    promise._c = [];
	    promise._n = false;
	    if (isReject && !promise._h) onUnhandled(promise);
	  });
	};

	var onUnhandled = function onUnhandled(promise) {
	  task.call(_global, function () {
	    var value = promise._v;
	    var unhandled = isUnhandled(promise);
	    var result, handler, console;

	    if (unhandled) {
	      result = _perform(function () {
	        if (isNode$1) {
	          process$2.emit('unhandledRejection', value, promise);
	        } else if (handler = _global.onunhandledrejection) {
	          handler({
	            promise: promise,
	            reason: value
	          });
	        } else if ((console = _global.console) && console.error) {
	          console.error('Unhandled promise rejection', value);
	        }
	      }); // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should

	      promise._h = isNode$1 || isUnhandled(promise) ? 2 : 1;
	    }

	    promise._a = undefined;
	    if (unhandled && result.e) throw result.v;
	  });
	};

	var isUnhandled = function isUnhandled(promise) {
	  return promise._h !== 1 && (promise._a || promise._c).length === 0;
	};

	var onHandleUnhandled = function onHandleUnhandled(promise) {
	  task.call(_global, function () {
	    var handler;

	    if (isNode$1) {
	      process$2.emit('rejectionHandled', promise);
	    } else if (handler = _global.onrejectionhandled) {
	      handler({
	        promise: promise,
	        reason: promise._v
	      });
	    }
	  });
	};

	var $reject = function $reject(value) {
	  var promise = this;
	  if (promise._d) return;
	  promise._d = true;
	  promise = promise._w || promise; // unwrap

	  promise._v = value;
	  promise._s = 2;
	  if (!promise._a) promise._a = promise._c.slice();
	  notify(promise, true);
	};

	var $resolve = function $resolve(value) {
	  var promise = this;
	  var then;
	  if (promise._d) return;
	  promise._d = true;
	  promise = promise._w || promise; // unwrap

	  try {
	    if (promise === value) throw TypeError$1("Promise can't be resolved itself");

	    if (then = isThenable(value)) {
	      microtask(function () {
	        var wrapper = {
	          _w: promise,
	          _d: false
	        }; // wrap

	        try {
	          then.call(value, _ctx($resolve, wrapper, 1), _ctx($reject, wrapper, 1));
	        } catch (e) {
	          $reject.call(wrapper, e);
	        }
	      });
	    } else {
	      promise._v = value;
	      promise._s = 1;
	      notify(promise, false);
	    }
	  } catch (e) {
	    $reject.call({
	      _w: promise,
	      _d: false
	    }, e); // wrap
	  }
	}; // constructor polyfill


	if (!USE_NATIVE$1) {
	  // 25.4.3.1 Promise(executor)
	  $Promise = function Promise(executor) {
	    _anInstance(this, $Promise, PROMISE, '_h');
	    _aFunction(executor);
	    Internal.call(this);

	    try {
	      executor(_ctx($resolve, this, 1), _ctx($reject, this, 1));
	    } catch (err) {
	      $reject.call(this, err);
	    }
	  }; // eslint-disable-next-line no-unused-vars


	  Internal = function Promise(executor) {
	    this._c = []; // <- awaiting reactions

	    this._a = undefined; // <- checked in isUnhandled reactions

	    this._s = 0; // <- state

	    this._d = false; // <- done

	    this._v = undefined; // <- value

	    this._h = 0; // <- rejection state, 0 - default, 1 - handled, 2 - unhandled

	    this._n = false; // <- notify
	  };

	  Internal.prototype = _redefineAll($Promise.prototype, {
	    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
	    then: function then(onFulfilled, onRejected) {
	      var reaction = newPromiseCapability(_speciesConstructor(this, $Promise));
	      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
	      reaction.fail = typeof onRejected == 'function' && onRejected;
	      reaction.domain = isNode$1 ? process$2.domain : undefined;

	      this._c.push(reaction);

	      if (this._a) this._a.push(reaction);
	      if (this._s) notify(this, false);
	      return reaction.promise;
	    },
	    // 25.4.5.1 Promise.prototype.catch(onRejected)
	    'catch': function _catch(onRejected) {
	      return this.then(undefined, onRejected);
	    }
	  });

	  OwnPromiseCapability = function OwnPromiseCapability() {
	    var promise = new Internal();
	    this.promise = promise;
	    this.resolve = _ctx($resolve, promise, 1);
	    this.reject = _ctx($reject, promise, 1);
	  };

	  _newPromiseCapability.f = newPromiseCapability = function newPromiseCapability(C) {
	    return C === $Promise || C === Wrapper ? new OwnPromiseCapability(C) : newGenericPromiseCapability(C);
	  };
	}

	_export(_export.G + _export.W + _export.F * !USE_NATIVE$1, {
	  Promise: $Promise
	});

	_setToStringTag($Promise, PROMISE);

	_setSpecies(PROMISE);

	Wrapper = _core[PROMISE]; // statics

	_export(_export.S + _export.F * !USE_NATIVE$1, PROMISE, {
	  // 25.4.4.5 Promise.reject(r)
	  reject: function reject(r) {
	    var capability = newPromiseCapability(this);
	    var $$reject = capability.reject;
	    $$reject(r);
	    return capability.promise;
	  }
	});
	_export(_export.S + _export.F * (_library || !USE_NATIVE$1), PROMISE, {
	  // 25.4.4.6 Promise.resolve(x)
	  resolve: function resolve(x) {
	    return _promiseResolve(_library && this === Wrapper ? $Promise : this, x);
	  }
	});
	_export(_export.S + _export.F * !(USE_NATIVE$1 && _iterDetect(function (iter) {
	  $Promise.all(iter)['catch'](empty);
	})), PROMISE, {
	  // 25.4.4.1 Promise.all(iterable)
	  all: function all(iterable) {
	    var C = this;
	    var capability = newPromiseCapability(C);
	    var resolve = capability.resolve;
	    var reject = capability.reject;
	    var result = _perform(function () {
	      var values = [];
	      var index = 0;
	      var remaining = 1;
	      _forOf(iterable, false, function (promise) {
	        var $index = index++;
	        var alreadyCalled = false;
	        values.push(undefined);
	        remaining++;
	        C.resolve(promise).then(function (value) {
	          if (alreadyCalled) return;
	          alreadyCalled = true;
	          values[$index] = value;
	          --remaining || resolve(values);
	        }, reject);
	      });
	      --remaining || resolve(values);
	    });
	    if (result.e) reject(result.v);
	    return capability.promise;
	  },
	  // 25.4.4.4 Promise.race(iterable)
	  race: function race(iterable) {
	    var C = this;
	    var capability = newPromiseCapability(C);
	    var reject = capability.reject;
	    var result = _perform(function () {
	      _forOf(iterable, false, function (promise) {
	        C.resolve(promise).then(capability.resolve, reject);
	      });
	    });
	    if (result.e) reject(result.v);
	    return capability.promise;
	  }
	});

	var _validateCollection = function (it, TYPE) {
	  if (!_isObject(it) || it._t !== TYPE) throw TypeError('Incompatible receiver, ' + TYPE + ' required!');
	  return it;
	};

	var dP$5 = _objectDp.f;



















	var fastKey = _meta.fastKey;



	var SIZE = _descriptors ? '_s' : 'size';

	var getEntry = function getEntry(that, key) {
	  // fast case
	  var index = fastKey(key);
	  var entry;
	  if (index !== 'F') return that._i[index]; // frozen object case

	  for (entry = that._f; entry; entry = entry.n) {
	    if (entry.k == key) return entry;
	  }
	};

	var _collectionStrong = {
	  getConstructor: function getConstructor(wrapper, NAME, IS_MAP, ADDER) {
	    var C = wrapper(function (that, iterable) {
	      _anInstance(that, C, NAME, '_i');
	      that._t = NAME; // collection type

	      that._i = _objectCreate(null); // index

	      that._f = undefined; // first entry

	      that._l = undefined; // last entry

	      that[SIZE] = 0; // size

	      if (iterable != undefined) _forOf(iterable, IS_MAP, that[ADDER], that);
	    });
	    _redefineAll(C.prototype, {
	      // 23.1.3.1 Map.prototype.clear()
	      // 23.2.3.2 Set.prototype.clear()
	      clear: function clear() {
	        for (var that = _validateCollection(this, NAME), data = that._i, entry = that._f; entry; entry = entry.n) {
	          entry.r = true;
	          if (entry.p) entry.p = entry.p.n = undefined;
	          delete data[entry.i];
	        }

	        that._f = that._l = undefined;
	        that[SIZE] = 0;
	      },
	      // 23.1.3.3 Map.prototype.delete(key)
	      // 23.2.3.4 Set.prototype.delete(value)
	      'delete': function _delete(key) {
	        var that = _validateCollection(this, NAME);
	        var entry = getEntry(that, key);

	        if (entry) {
	          var next = entry.n;
	          var prev = entry.p;
	          delete that._i[entry.i];
	          entry.r = true;
	          if (prev) prev.n = next;
	          if (next) next.p = prev;
	          if (that._f == entry) that._f = next;
	          if (that._l == entry) that._l = prev;
	          that[SIZE]--;
	        }

	        return !!entry;
	      },
	      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
	      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
	      forEach: function forEach(callbackfn
	      /* , that = undefined */
	      ) {
	        _validateCollection(this, NAME);
	        var f = _ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
	        var entry;

	        while (entry = entry ? entry.n : this._f) {
	          f(entry.v, entry.k, this); // revert to the last existing entry

	          while (entry && entry.r) {
	            entry = entry.p;
	          }
	        }
	      },
	      // 23.1.3.7 Map.prototype.has(key)
	      // 23.2.3.7 Set.prototype.has(value)
	      has: function has(key) {
	        return !!getEntry(_validateCollection(this, NAME), key);
	      }
	    });
	    if (_descriptors) dP$5(C.prototype, 'size', {
	      get: function get() {
	        return _validateCollection(this, NAME)[SIZE];
	      }
	    });
	    return C;
	  },
	  def: function def(that, key, value) {
	    var entry = getEntry(that, key);
	    var prev, index; // change existing entry

	    if (entry) {
	      entry.v = value; // create new entry
	    } else {
	      that._l = entry = {
	        i: index = fastKey(key, true),
	        // <- index
	        k: key,
	        // <- key
	        v: value,
	        // <- value
	        p: prev = that._l,
	        // <- previous entry
	        n: undefined,
	        // <- next entry
	        r: false // <- removed

	      };
	      if (!that._f) that._f = entry;
	      if (prev) prev.n = entry;
	      that[SIZE]++; // add to index

	      if (index !== 'F') that._i[index] = entry;
	    }

	    return that;
	  },
	  getEntry: getEntry,
	  setStrong: function setStrong(C, NAME, IS_MAP) {
	    // add .keys, .values, .entries, [@@iterator]
	    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
	    _iterDefine(C, NAME, function (iterated, kind) {
	      this._t = _validateCollection(iterated, NAME); // target

	      this._k = kind; // kind

	      this._l = undefined; // previous
	    }, function () {
	      var that = this;
	      var kind = that._k;
	      var entry = that._l; // revert to the last existing entry

	      while (entry && entry.r) {
	        entry = entry.p;
	      } // get next entry


	      if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) {
	        // or finish the iteration
	        that._t = undefined;
	        return _iterStep(1);
	      } // return step by kind


	      if (kind == 'keys') return _iterStep(0, entry.k);
	      if (kind == 'values') return _iterStep(0, entry.v);
	      return _iterStep(0, [entry.k, entry.v]);
	    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true); // add [@@species], 23.1.2.2, 23.2.2.2

	    _setSpecies(NAME);
	  }
	};

	var _collection = function (NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {
	  var Base = _global[NAME];
	  var C = Base;
	  var ADDER = IS_MAP ? 'set' : 'add';
	  var proto = C && C.prototype;
	  var O = {};

	  var fixMethod = function fixMethod(KEY) {
	    var fn = proto[KEY];
	    _redefine(proto, KEY, KEY == 'delete' ? function (a) {
	      return IS_WEAK && !_isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
	    } : KEY == 'has' ? function has(a) {
	      return IS_WEAK && !_isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
	    } : KEY == 'get' ? function get(a) {
	      return IS_WEAK && !_isObject(a) ? undefined : fn.call(this, a === 0 ? 0 : a);
	    } : KEY == 'add' ? function add(a) {
	      fn.call(this, a === 0 ? 0 : a);
	      return this;
	    } : function set(a, b) {
	      fn.call(this, a === 0 ? 0 : a, b);
	      return this;
	    });
	  };

	  if (typeof C != 'function' || !(IS_WEAK || proto.forEach && !_fails(function () {
	    new C().entries().next();
	  }))) {
	    // create collection constructor
	    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
	    _redefineAll(C.prototype, methods);
	    _meta.NEED = true;
	  } else {
	    var instance = new C(); // early implementations not supports chaining

	    var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance; // V8 ~  Chromium 40- weak-collections throws on primitives, but should return false

	    var THROWS_ON_PRIMITIVES = _fails(function () {
	      instance.has(1);
	    }); // most early implementations doesn't supports iterables, most modern - not close it correctly

	    var ACCEPT_ITERABLES = _iterDetect(function (iter) {
	      new C(iter);
	    }); // eslint-disable-line no-new
	    // for early implementations -0 and +0 not the same

	    var BUGGY_ZERO = !IS_WEAK && _fails(function () {
	      // V8 ~ Chromium 42- fails only with 5+ elements
	      var $instance = new C();
	      var index = 5;

	      while (index--) {
	        $instance[ADDER](index, index);
	      }

	      return !$instance.has(-0);
	    });

	    if (!ACCEPT_ITERABLES) {
	      C = wrapper(function (target, iterable) {
	        _anInstance(target, C, NAME);
	        var that = _inheritIfRequired(new Base(), target, C);
	        if (iterable != undefined) _forOf(iterable, IS_MAP, that[ADDER], that);
	        return that;
	      });
	      C.prototype = proto;
	      proto.constructor = C;
	    }

	    if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
	      fixMethod('delete');
	      fixMethod('has');
	      IS_MAP && fixMethod('get');
	    }

	    if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER); // weak collections should not contains .clear method

	    if (IS_WEAK && proto.clear) delete proto.clear;
	  }

	  _setToStringTag(C, NAME);
	  O[NAME] = C;
	  _export(_export.G + _export.W + _export.F * (C != Base), O);
	  if (!IS_WEAK) common.setStrong(C, NAME, IS_MAP);
	  return C;
	};

	var MAP = 'Map'; // 23.1 Map Objects

	var es6_map = _collection(MAP, function (get) {
	  return function Map() {
	    return get(this, arguments.length > 0 ? arguments[0] : undefined);
	  };
	}, {
	  // 23.1.3.6 Map.prototype.get(key)
	  get: function get(key) {
	    var entry = _collectionStrong.getEntry(_validateCollection(this, MAP), key);
	    return entry && entry.v;
	  },
	  // 23.1.3.9 Map.prototype.set(key, value)
	  set: function set(key, value) {
	    return _collectionStrong.def(_validateCollection(this, MAP), key === 0 ? 0 : key, value);
	  }
	}, _collectionStrong, true);

	var SET = 'Set'; // 23.2 Set Objects

	var es6_set = _collection(SET, function (get) {
	  return function Set() {
	    return get(this, arguments.length > 0 ? arguments[0] : undefined);
	  };
	}, {
	  // 23.2.3.1 Set.prototype.add(value)
	  add: function add(value) {
	    return _collectionStrong.def(_validateCollection(this, SET), value = value === 0 ? 0 : value, value);
	  }
	}, _collectionStrong);

	var getWeak = _meta.getWeak;















	var arrayFind = _arrayMethods(5);
	var arrayFindIndex = _arrayMethods(6);
	var id$1 = 0; // fallback for uncaught frozen keys

	var uncaughtFrozenStore = function uncaughtFrozenStore(that) {
	  return that._l || (that._l = new UncaughtFrozenStore());
	};

	var UncaughtFrozenStore = function UncaughtFrozenStore() {
	  this.a = [];
	};

	var findUncaughtFrozen = function findUncaughtFrozen(store, key) {
	  return arrayFind(store.a, function (it) {
	    return it[0] === key;
	  });
	};

	UncaughtFrozenStore.prototype = {
	  get: function get(key) {
	    var entry = findUncaughtFrozen(this, key);
	    if (entry) return entry[1];
	  },
	  has: function has(key) {
	    return !!findUncaughtFrozen(this, key);
	  },
	  set: function set(key, value) {
	    var entry = findUncaughtFrozen(this, key);
	    if (entry) entry[1] = value;else this.a.push([key, value]);
	  },
	  'delete': function _delete(key) {
	    var index = arrayFindIndex(this.a, function (it) {
	      return it[0] === key;
	    });
	    if (~index) this.a.splice(index, 1);
	    return !!~index;
	  }
	};
	var _collectionWeak = {
	  getConstructor: function getConstructor(wrapper, NAME, IS_MAP, ADDER) {
	    var C = wrapper(function (that, iterable) {
	      _anInstance(that, C, NAME, '_i');
	      that._t = NAME; // collection type

	      that._i = id$1++; // collection id

	      that._l = undefined; // leak store for uncaught frozen objects

	      if (iterable != undefined) _forOf(iterable, IS_MAP, that[ADDER], that);
	    });
	    _redefineAll(C.prototype, {
	      // 23.3.3.2 WeakMap.prototype.delete(key)
	      // 23.4.3.3 WeakSet.prototype.delete(value)
	      'delete': function _delete(key) {
	        if (!_isObject(key)) return false;
	        var data = getWeak(key);
	        if (data === true) return uncaughtFrozenStore(_validateCollection(this, NAME))['delete'](key);
	        return data && _has(data, this._i) && delete data[this._i];
	      },
	      // 23.3.3.4 WeakMap.prototype.has(key)
	      // 23.4.3.4 WeakSet.prototype.has(value)
	      has: function has(key) {
	        if (!_isObject(key)) return false;
	        var data = getWeak(key);
	        if (data === true) return uncaughtFrozenStore(_validateCollection(this, NAME)).has(key);
	        return data && _has(data, this._i);
	      }
	    });
	    return C;
	  },
	  def: function def(that, key, value) {
	    var data = getWeak(_anObject(key), true);
	    if (data === true) uncaughtFrozenStore(that).set(key, value);else data[that._i] = value;
	    return that;
	  },
	  ufstore: uncaughtFrozenStore
	};

	var es6_weakMap = createCommonjsModule(function (module) {

	var each = _arrayMethods(0);















	var WEAK_MAP = 'WeakMap';
	var getWeak = _meta.getWeak;
	var isExtensible = Object.isExtensible;
	var uncaughtFrozenStore = _collectionWeak.ufstore;
	var tmp = {};
	var InternalMap;

	var wrapper = function wrapper(get) {
	  return function WeakMap() {
	    return get(this, arguments.length > 0 ? arguments[0] : undefined);
	  };
	};

	var methods = {
	  // 23.3.3.3 WeakMap.prototype.get(key)
	  get: function get(key) {
	    if (_isObject(key)) {
	      var data = getWeak(key);
	      if (data === true) return uncaughtFrozenStore(_validateCollection(this, WEAK_MAP)).get(key);
	      return data ? data[this._i] : undefined;
	    }
	  },
	  // 23.3.3.5 WeakMap.prototype.set(key, value)
	  set: function set(key, value) {
	    return _collectionWeak.def(_validateCollection(this, WEAK_MAP), key, value);
	  }
	}; // 23.3 WeakMap Objects

	var $WeakMap = module.exports = _collection(WEAK_MAP, wrapper, methods, _collectionWeak, true, true); // IE11 WeakMap frozen keys fix


	if (_fails(function () {
	  return new $WeakMap().set((Object.freeze || Object)(tmp), 7).get(tmp) != 7;
	})) {
	  InternalMap = _collectionWeak.getConstructor(wrapper, WEAK_MAP);
	  _objectAssign(InternalMap.prototype, methods);
	  _meta.NEED = true;
	  each(['delete', 'has', 'get', 'set'], function (key) {
	    var proto = $WeakMap.prototype;
	    var method = proto[key];
	    _redefine(proto, key, function (a, b) {
	      // store frozen objects on internal weakmap shim
	      if (_isObject(a) && !isExtensible(a)) {
	        if (!this._f) this._f = new InternalMap();

	        var result = this._f[key](a, b);

	        return key == 'set' ? this : result; // store all the rest on native weakmap
	      }

	      return method.call(this, a, b);
	    });
	  });
	}
	});

	var WEAK_SET = 'WeakSet'; // 23.4 WeakSet Objects

	_collection(WEAK_SET, function (get) {
	  return function WeakSet() {
	    return get(this, arguments.length > 0 ? arguments[0] : undefined);
	  };
	}, {
	  // 23.4.3.1 WeakSet.prototype.add(value)
	  add: function add(value) {
	    return _collectionWeak.def(_validateCollection(this, WEAK_SET), value, true);
	  }
	}, _collectionWeak, false, true);

	var TYPED = _uid('typed_array');
	var VIEW = _uid('view');
	var ABV = !!(_global.ArrayBuffer && _global.DataView);
	var CONSTR = ABV;
	var i$1 = 0;
	var l = 9;
	var Typed;
	var TypedArrayConstructors = 'Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array'.split(',');

	while (i$1 < l) {
	  if (Typed = _global[TypedArrayConstructors[i$1++]]) {
	    _hide(Typed.prototype, TYPED, true);
	    _hide(Typed.prototype, VIEW, true);
	  } else CONSTR = false;
	}

	var _typed = {
	  ABV: ABV,
	  CONSTR: CONSTR,
	  TYPED: TYPED,
	  VIEW: VIEW
	};

	// https://tc39.github.io/ecma262/#sec-toindex




	var _toIndex = function (it) {
	  if (it === undefined) return 0;
	  var number = _toInteger(it);
	  var length = _toLength(number);
	  if (number !== length) throw RangeError('Wrong length!');
	  return length;
	};

	var _typedBuffer = createCommonjsModule(function (module, exports) {























	var gOPN = _objectGopn.f;

	var dP = _objectDp.f;





	var ARRAY_BUFFER = 'ArrayBuffer';
	var DATA_VIEW = 'DataView';
	var PROTOTYPE = 'prototype';
	var WRONG_LENGTH = 'Wrong length!';
	var WRONG_INDEX = 'Wrong index!';
	var $ArrayBuffer = _global[ARRAY_BUFFER];
	var $DataView = _global[DATA_VIEW];
	var Math = _global.Math;
	var RangeError = _global.RangeError; // eslint-disable-next-line no-shadow-restricted-names

	var Infinity = _global.Infinity;
	var BaseBuffer = $ArrayBuffer;
	var abs = Math.abs;
	var pow = Math.pow;
	var floor = Math.floor;
	var log = Math.log;
	var LN2 = Math.LN2;
	var BUFFER = 'buffer';
	var BYTE_LENGTH = 'byteLength';
	var BYTE_OFFSET = 'byteOffset';
	var $BUFFER = _descriptors ? '_b' : BUFFER;
	var $LENGTH = _descriptors ? '_l' : BYTE_LENGTH;
	var $OFFSET = _descriptors ? '_o' : BYTE_OFFSET; // IEEE754 conversions based on https://github.com/feross/ieee754

	function packIEEE754(value, mLen, nBytes) {
	  var buffer = new Array(nBytes);
	  var eLen = nBytes * 8 - mLen - 1;
	  var eMax = (1 << eLen) - 1;
	  var eBias = eMax >> 1;
	  var rt = mLen === 23 ? pow(2, -24) - pow(2, -77) : 0;
	  var i = 0;
	  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
	  var e, m, c;
	  value = abs(value); // eslint-disable-next-line no-self-compare

	  if (value != value || value === Infinity) {
	    // eslint-disable-next-line no-self-compare
	    m = value != value ? 1 : 0;
	    e = eMax;
	  } else {
	    e = floor(log(value) / LN2);

	    if (value * (c = pow(2, -e)) < 1) {
	      e--;
	      c *= 2;
	    }

	    if (e + eBias >= 1) {
	      value += rt / c;
	    } else {
	      value += rt * pow(2, 1 - eBias);
	    }

	    if (value * c >= 2) {
	      e++;
	      c /= 2;
	    }

	    if (e + eBias >= eMax) {
	      m = 0;
	      e = eMax;
	    } else if (e + eBias >= 1) {
	      m = (value * c - 1) * pow(2, mLen);
	      e = e + eBias;
	    } else {
	      m = value * pow(2, eBias - 1) * pow(2, mLen);
	      e = 0;
	    }
	  }

	  for (; mLen >= 8; buffer[i++] = m & 255, m /= 256, mLen -= 8) {
	  }

	  e = e << mLen | m;
	  eLen += mLen;

	  for (; eLen > 0; buffer[i++] = e & 255, e /= 256, eLen -= 8) {
	  }

	  buffer[--i] |= s * 128;
	  return buffer;
	}

	function unpackIEEE754(buffer, mLen, nBytes) {
	  var eLen = nBytes * 8 - mLen - 1;
	  var eMax = (1 << eLen) - 1;
	  var eBias = eMax >> 1;
	  var nBits = eLen - 7;
	  var i = nBytes - 1;
	  var s = buffer[i--];
	  var e = s & 127;
	  var m;
	  s >>= 7;

	  for (; nBits > 0; e = e * 256 + buffer[i], i--, nBits -= 8) {
	  }

	  m = e & (1 << -nBits) - 1;
	  e >>= -nBits;
	  nBits += mLen;

	  for (; nBits > 0; m = m * 256 + buffer[i], i--, nBits -= 8) {
	  }

	  if (e === 0) {
	    e = 1 - eBias;
	  } else if (e === eMax) {
	    return m ? NaN : s ? -Infinity : Infinity;
	  } else {
	    m = m + pow(2, mLen);
	    e = e - eBias;
	  }

	  return (s ? -1 : 1) * m * pow(2, e - mLen);
	}

	function unpackI32(bytes) {
	  return bytes[3] << 24 | bytes[2] << 16 | bytes[1] << 8 | bytes[0];
	}

	function packI8(it) {
	  return [it & 0xff];
	}

	function packI16(it) {
	  return [it & 0xff, it >> 8 & 0xff];
	}

	function packI32(it) {
	  return [it & 0xff, it >> 8 & 0xff, it >> 16 & 0xff, it >> 24 & 0xff];
	}

	function packF64(it) {
	  return packIEEE754(it, 52, 8);
	}

	function packF32(it) {
	  return packIEEE754(it, 23, 4);
	}

	function addGetter(C, key, internal) {
	  dP(C[PROTOTYPE], key, {
	    get: function get() {
	      return this[internal];
	    }
	  });
	}

	function get(view, bytes, index, isLittleEndian) {
	  var numIndex = +index;
	  var intIndex = _toIndex(numIndex);
	  if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
	  var store = view[$BUFFER]._b;
	  var start = intIndex + view[$OFFSET];
	  var pack = store.slice(start, start + bytes);
	  return isLittleEndian ? pack : pack.reverse();
	}

	function set(view, bytes, index, conversion, value, isLittleEndian) {
	  var numIndex = +index;
	  var intIndex = _toIndex(numIndex);
	  if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
	  var store = view[$BUFFER]._b;
	  var start = intIndex + view[$OFFSET];
	  var pack = conversion(+value);

	  for (var i = 0; i < bytes; i++) {
	    store[start + i] = pack[isLittleEndian ? i : bytes - i - 1];
	  }
	}

	if (!_typed.ABV) {
	  $ArrayBuffer = function ArrayBuffer(length) {
	    _anInstance(this, $ArrayBuffer, ARRAY_BUFFER);
	    var byteLength = _toIndex(length);
	    this._b = _arrayFill.call(new Array(byteLength), 0);
	    this[$LENGTH] = byteLength;
	  };

	  $DataView = function DataView(buffer, byteOffset, byteLength) {
	    _anInstance(this, $DataView, DATA_VIEW);
	    _anInstance(buffer, $ArrayBuffer, DATA_VIEW);
	    var bufferLength = buffer[$LENGTH];
	    var offset = _toInteger(byteOffset);
	    if (offset < 0 || offset > bufferLength) throw RangeError('Wrong offset!');
	    byteLength = byteLength === undefined ? bufferLength - offset : _toLength(byteLength);
	    if (offset + byteLength > bufferLength) throw RangeError(WRONG_LENGTH);
	    this[$BUFFER] = buffer;
	    this[$OFFSET] = offset;
	    this[$LENGTH] = byteLength;
	  };

	  if (_descriptors) {
	    addGetter($ArrayBuffer, BYTE_LENGTH, '_l');
	    addGetter($DataView, BUFFER, '_b');
	    addGetter($DataView, BYTE_LENGTH, '_l');
	    addGetter($DataView, BYTE_OFFSET, '_o');
	  }

	  _redefineAll($DataView[PROTOTYPE], {
	    getInt8: function getInt8(byteOffset) {
	      return get(this, 1, byteOffset)[0] << 24 >> 24;
	    },
	    getUint8: function getUint8(byteOffset) {
	      return get(this, 1, byteOffset)[0];
	    },
	    getInt16: function getInt16(byteOffset
	    /* , littleEndian */
	    ) {
	      var bytes = get(this, 2, byteOffset, arguments[1]);
	      return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
	    },
	    getUint16: function getUint16(byteOffset
	    /* , littleEndian */
	    ) {
	      var bytes = get(this, 2, byteOffset, arguments[1]);
	      return bytes[1] << 8 | bytes[0];
	    },
	    getInt32: function getInt32(byteOffset
	    /* , littleEndian */
	    ) {
	      return unpackI32(get(this, 4, byteOffset, arguments[1]));
	    },
	    getUint32: function getUint32(byteOffset
	    /* , littleEndian */
	    ) {
	      return unpackI32(get(this, 4, byteOffset, arguments[1])) >>> 0;
	    },
	    getFloat32: function getFloat32(byteOffset
	    /* , littleEndian */
	    ) {
	      return unpackIEEE754(get(this, 4, byteOffset, arguments[1]), 23, 4);
	    },
	    getFloat64: function getFloat64(byteOffset
	    /* , littleEndian */
	    ) {
	      return unpackIEEE754(get(this, 8, byteOffset, arguments[1]), 52, 8);
	    },
	    setInt8: function setInt8(byteOffset, value) {
	      set(this, 1, byteOffset, packI8, value);
	    },
	    setUint8: function setUint8(byteOffset, value) {
	      set(this, 1, byteOffset, packI8, value);
	    },
	    setInt16: function setInt16(byteOffset, value
	    /* , littleEndian */
	    ) {
	      set(this, 2, byteOffset, packI16, value, arguments[2]);
	    },
	    setUint16: function setUint16(byteOffset, value
	    /* , littleEndian */
	    ) {
	      set(this, 2, byteOffset, packI16, value, arguments[2]);
	    },
	    setInt32: function setInt32(byteOffset, value
	    /* , littleEndian */
	    ) {
	      set(this, 4, byteOffset, packI32, value, arguments[2]);
	    },
	    setUint32: function setUint32(byteOffset, value
	    /* , littleEndian */
	    ) {
	      set(this, 4, byteOffset, packI32, value, arguments[2]);
	    },
	    setFloat32: function setFloat32(byteOffset, value
	    /* , littleEndian */
	    ) {
	      set(this, 4, byteOffset, packF32, value, arguments[2]);
	    },
	    setFloat64: function setFloat64(byteOffset, value
	    /* , littleEndian */
	    ) {
	      set(this, 8, byteOffset, packF64, value, arguments[2]);
	    }
	  });
	} else {
	  if (!_fails(function () {
	    $ArrayBuffer(1);
	  }) || !_fails(function () {
	    new $ArrayBuffer(-1); // eslint-disable-line no-new
	  }) || _fails(function () {
	    new $ArrayBuffer(); // eslint-disable-line no-new

	    new $ArrayBuffer(1.5); // eslint-disable-line no-new

	    new $ArrayBuffer(NaN); // eslint-disable-line no-new

	    return $ArrayBuffer.name != ARRAY_BUFFER;
	  })) {
	    $ArrayBuffer = function ArrayBuffer(length) {
	      _anInstance(this, $ArrayBuffer);
	      return new BaseBuffer(_toIndex(length));
	    };

	    var ArrayBufferProto = $ArrayBuffer[PROTOTYPE] = BaseBuffer[PROTOTYPE];

	    for (var keys = gOPN(BaseBuffer), j = 0, key; keys.length > j;) {
	      if (!((key = keys[j++]) in $ArrayBuffer)) _hide($ArrayBuffer, key, BaseBuffer[key]);
	    }

	    ArrayBufferProto.constructor = $ArrayBuffer;
	  } // iOS Safari 7.x bug


	  var view = new $DataView(new $ArrayBuffer(2));
	  var $setInt8 = $DataView[PROTOTYPE].setInt8;
	  view.setInt8(0, 2147483648);
	  view.setInt8(1, 2147483649);
	  if (view.getInt8(0) || !view.getInt8(1)) _redefineAll($DataView[PROTOTYPE], {
	    setInt8: function setInt8(byteOffset, value) {
	      $setInt8.call(this, byteOffset, value << 24 >> 24);
	    },
	    setUint8: function setUint8(byteOffset, value) {
	      $setInt8.call(this, byteOffset, value << 24 >> 24);
	    }
	  }, true);
	}

	_setToStringTag($ArrayBuffer, ARRAY_BUFFER);
	_setToStringTag($DataView, DATA_VIEW);
	_hide($DataView[PROTOTYPE], _typed.VIEW, true);
	exports[ARRAY_BUFFER] = $ArrayBuffer;
	exports[DATA_VIEW] = $DataView;
	});

	var ArrayBuffer = _global.ArrayBuffer;



	var $ArrayBuffer = _typedBuffer.ArrayBuffer;
	var $DataView = _typedBuffer.DataView;
	var $isView = _typed.ABV && ArrayBuffer.isView;
	var $slice = $ArrayBuffer.prototype.slice;
	var VIEW$1 = _typed.VIEW;
	var ARRAY_BUFFER = 'ArrayBuffer';
	_export(_export.G + _export.W + _export.F * (ArrayBuffer !== $ArrayBuffer), {
	  ArrayBuffer: $ArrayBuffer
	});
	_export(_export.S + _export.F * !_typed.CONSTR, ARRAY_BUFFER, {
	  // 24.1.3.1 ArrayBuffer.isView(arg)
	  isView: function isView(it) {
	    return $isView && $isView(it) || _isObject(it) && VIEW$1 in it;
	  }
	});
	_export(_export.P + _export.U + _export.F * _fails(function () {
	  return !new $ArrayBuffer(2).slice(1, undefined).byteLength;
	}), ARRAY_BUFFER, {
	  // 24.1.4.3 ArrayBuffer.prototype.slice(start, end)
	  slice: function slice(start, end) {
	    if ($slice !== undefined && end === undefined) return $slice.call(_anObject(this), start); // FF fix

	    var len = _anObject(this).byteLength;
	    var first = _toAbsoluteIndex(start, len);
	    var fin = _toAbsoluteIndex(end === undefined ? len : end, len);
	    var result = new (_speciesConstructor(this, $ArrayBuffer))(_toLength(fin - first));
	    var viewS = new $DataView(this);
	    var viewT = new $DataView(result);
	    var index = 0;

	    while (first < fin) {
	      viewT.setUint8(index++, viewS.getUint8(first++));
	    }

	    return result;
	  }
	});

	_setSpecies(ARRAY_BUFFER);

	_export(_export.G + _export.W + _export.F * !_typed.ABV, {
	  DataView: _typedBuffer.DataView
	});

	var _typedArray = createCommonjsModule(function (module) {

	if (_descriptors) {

	  var global = _global;

	  var fails = _fails;

	  var $export = _export;

	  var $typed = _typed;

	  var $buffer = _typedBuffer;

	  var ctx = _ctx;

	  var anInstance = _anInstance;

	  var propertyDesc = _propertyDesc;

	  var hide = _hide;

	  var redefineAll = _redefineAll;

	  var toInteger = _toInteger;

	  var toLength = _toLength;

	  var toIndex = _toIndex;

	  var toAbsoluteIndex = _toAbsoluteIndex;

	  var toPrimitive = _toPrimitive;

	  var has = _has;

	  var classof = _classof;

	  var isObject = _isObject;

	  var toObject = _toObject;

	  var isArrayIter = _isArrayIter;

	  var create = _objectCreate;

	  var getPrototypeOf = _objectGpo;

	  var gOPN = _objectGopn.f;

	  var getIterFn = core_getIteratorMethod;

	  var uid = _uid;

	  var wks = _wks;

	  var createArrayMethod = _arrayMethods;

	  var createArrayIncludes = _arrayIncludes;

	  var speciesConstructor = _speciesConstructor;

	  var ArrayIterators = es6_array_iterator;

	  var Iterators = _iterators;

	  var $iterDetect = _iterDetect;

	  var setSpecies = _setSpecies;

	  var arrayFill = _arrayFill;

	  var arrayCopyWithin = _arrayCopyWithin;

	  var $DP = _objectDp;

	  var $GOPD = _objectGopd;

	  var dP = $DP.f;
	  var gOPD = $GOPD.f;
	  var RangeError = global.RangeError;
	  var TypeError = global.TypeError;
	  var Uint8Array = global.Uint8Array;
	  var ARRAY_BUFFER = 'ArrayBuffer';
	  var SHARED_BUFFER = 'Shared' + ARRAY_BUFFER;
	  var BYTES_PER_ELEMENT = 'BYTES_PER_ELEMENT';
	  var PROTOTYPE = 'prototype';
	  var ArrayProto = Array[PROTOTYPE];
	  var $ArrayBuffer = $buffer.ArrayBuffer;
	  var $DataView = $buffer.DataView;
	  var arrayForEach = createArrayMethod(0);
	  var arrayFilter = createArrayMethod(2);
	  var arraySome = createArrayMethod(3);
	  var arrayEvery = createArrayMethod(4);
	  var arrayFind = createArrayMethod(5);
	  var arrayFindIndex = createArrayMethod(6);
	  var arrayIncludes = createArrayIncludes(true);
	  var arrayIndexOf = createArrayIncludes(false);
	  var arrayValues = ArrayIterators.values;
	  var arrayKeys = ArrayIterators.keys;
	  var arrayEntries = ArrayIterators.entries;
	  var arrayLastIndexOf = ArrayProto.lastIndexOf;
	  var arrayReduce = ArrayProto.reduce;
	  var arrayReduceRight = ArrayProto.reduceRight;
	  var arrayJoin = ArrayProto.join;
	  var arraySort = ArrayProto.sort;
	  var arraySlice = ArrayProto.slice;
	  var arrayToString = ArrayProto.toString;
	  var arrayToLocaleString = ArrayProto.toLocaleString;
	  var ITERATOR = wks('iterator');
	  var TAG = wks('toStringTag');
	  var TYPED_CONSTRUCTOR = uid('typed_constructor');
	  var DEF_CONSTRUCTOR = uid('def_constructor');
	  var ALL_CONSTRUCTORS = $typed.CONSTR;
	  var TYPED_ARRAY = $typed.TYPED;
	  var VIEW = $typed.VIEW;
	  var WRONG_LENGTH = 'Wrong length!';
	  var $map = createArrayMethod(1, function (O, length) {
	    return allocate(speciesConstructor(O, O[DEF_CONSTRUCTOR]), length);
	  });
	  var LITTLE_ENDIAN = fails(function () {
	    // eslint-disable-next-line no-undef
	    return new Uint8Array(new Uint16Array([1]).buffer)[0] === 1;
	  });
	  var FORCED_SET = !!Uint8Array && !!Uint8Array[PROTOTYPE].set && fails(function () {
	    new Uint8Array(1).set({});
	  });

	  var toOffset = function toOffset(it, BYTES) {
	    var offset = toInteger(it);
	    if (offset < 0 || offset % BYTES) throw RangeError('Wrong offset!');
	    return offset;
	  };

	  var validate = function validate(it) {
	    if (isObject(it) && TYPED_ARRAY in it) return it;
	    throw TypeError(it + ' is not a typed array!');
	  };

	  var allocate = function allocate(C, length) {
	    if (!(isObject(C) && TYPED_CONSTRUCTOR in C)) {
	      throw TypeError('It is not a typed array constructor!');
	    }

	    return new C(length);
	  };

	  var speciesFromList = function speciesFromList(O, list) {
	    return fromList(speciesConstructor(O, O[DEF_CONSTRUCTOR]), list);
	  };

	  var fromList = function fromList(C, list) {
	    var index = 0;
	    var length = list.length;
	    var result = allocate(C, length);

	    while (length > index) {
	      result[index] = list[index++];
	    }

	    return result;
	  };

	  var addGetter = function addGetter(it, key, internal) {
	    dP(it, key, {
	      get: function get() {
	        return this._d[internal];
	      }
	    });
	  };

	  var $from = function from(source
	  /* , mapfn, thisArg */
	  ) {
	    var O = toObject(source);
	    var aLen = arguments.length;
	    var mapfn = aLen > 1 ? arguments[1] : undefined;
	    var mapping = mapfn !== undefined;
	    var iterFn = getIterFn(O);
	    var i, length, values, result, step, iterator;

	    if (iterFn != undefined && !isArrayIter(iterFn)) {
	      for (iterator = iterFn.call(O), values = [], i = 0; !(step = iterator.next()).done; i++) {
	        values.push(step.value);
	      }

	      O = values;
	    }

	    if (mapping && aLen > 2) mapfn = ctx(mapfn, arguments[2], 2);

	    for (i = 0, length = toLength(O.length), result = allocate(this, length); length > i; i++) {
	      result[i] = mapping ? mapfn(O[i], i) : O[i];
	    }

	    return result;
	  };

	  var $of = function of()
	  /* ...items */
	  {
	    var index = 0;
	    var length = arguments.length;
	    var result = allocate(this, length);

	    while (length > index) {
	      result[index] = arguments[index++];
	    }

	    return result;
	  }; // iOS Safari 6.x fails here


	  var TO_LOCALE_BUG = !!Uint8Array && fails(function () {
	    arrayToLocaleString.call(new Uint8Array(1));
	  });

	  var $toLocaleString = function toLocaleString() {
	    return arrayToLocaleString.apply(TO_LOCALE_BUG ? arraySlice.call(validate(this)) : validate(this), arguments);
	  };

	  var proto = {
	    copyWithin: function copyWithin(target, start
	    /* , end */
	    ) {
	      return arrayCopyWithin.call(validate(this), target, start, arguments.length > 2 ? arguments[2] : undefined);
	    },
	    every: function every(callbackfn
	    /* , thisArg */
	    ) {
	      return arrayEvery(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    fill: function fill(value
	    /* , start, end */
	    ) {
	      // eslint-disable-line no-unused-vars
	      return arrayFill.apply(validate(this), arguments);
	    },
	    filter: function filter(callbackfn
	    /* , thisArg */
	    ) {
	      return speciesFromList(this, arrayFilter(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined));
	    },
	    find: function find(predicate
	    /* , thisArg */
	    ) {
	      return arrayFind(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    findIndex: function findIndex(predicate
	    /* , thisArg */
	    ) {
	      return arrayFindIndex(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    forEach: function forEach(callbackfn
	    /* , thisArg */
	    ) {
	      arrayForEach(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    indexOf: function indexOf(searchElement
	    /* , fromIndex */
	    ) {
	      return arrayIndexOf(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    includes: function includes(searchElement
	    /* , fromIndex */
	    ) {
	      return arrayIncludes(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    join: function join(separator) {
	      // eslint-disable-line no-unused-vars
	      return arrayJoin.apply(validate(this), arguments);
	    },
	    lastIndexOf: function lastIndexOf(searchElement
	    /* , fromIndex */
	    ) {
	      // eslint-disable-line no-unused-vars
	      return arrayLastIndexOf.apply(validate(this), arguments);
	    },
	    map: function map(mapfn
	    /* , thisArg */
	    ) {
	      return $map(validate(this), mapfn, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    reduce: function reduce(callbackfn
	    /* , initialValue */
	    ) {
	      // eslint-disable-line no-unused-vars
	      return arrayReduce.apply(validate(this), arguments);
	    },
	    reduceRight: function reduceRight(callbackfn
	    /* , initialValue */
	    ) {
	      // eslint-disable-line no-unused-vars
	      return arrayReduceRight.apply(validate(this), arguments);
	    },
	    reverse: function reverse() {
	      var that = this;
	      var length = validate(that).length;
	      var middle = Math.floor(length / 2);
	      var index = 0;
	      var value;

	      while (index < middle) {
	        value = that[index];
	        that[index++] = that[--length];
	        that[length] = value;
	      }

	      return that;
	    },
	    some: function some(callbackfn
	    /* , thisArg */
	    ) {
	      return arraySome(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    sort: function sort(comparefn) {
	      return arraySort.call(validate(this), comparefn);
	    },
	    subarray: function subarray(begin, end) {
	      var O = validate(this);
	      var length = O.length;
	      var $begin = toAbsoluteIndex(begin, length);
	      return new (speciesConstructor(O, O[DEF_CONSTRUCTOR]))(O.buffer, O.byteOffset + $begin * O.BYTES_PER_ELEMENT, toLength((end === undefined ? length : toAbsoluteIndex(end, length)) - $begin));
	    }
	  };

	  var $slice = function slice(start, end) {
	    return speciesFromList(this, arraySlice.call(validate(this), start, end));
	  };

	  var $set = function set(arrayLike
	  /* , offset */
	  ) {
	    validate(this);
	    var offset = toOffset(arguments[1], 1);
	    var length = this.length;
	    var src = toObject(arrayLike);
	    var len = toLength(src.length);
	    var index = 0;
	    if (len + offset > length) throw RangeError(WRONG_LENGTH);

	    while (index < len) {
	      this[offset + index] = src[index++];
	    }
	  };

	  var $iterators = {
	    entries: function entries() {
	      return arrayEntries.call(validate(this));
	    },
	    keys: function keys() {
	      return arrayKeys.call(validate(this));
	    },
	    values: function values() {
	      return arrayValues.call(validate(this));
	    }
	  };

	  var isTAIndex = function isTAIndex(target, key) {
	    return isObject(target) && target[TYPED_ARRAY] && babelHelpers.typeof(key) != 'symbol' && key in target && String(+key) == String(key);
	  };

	  var $getDesc = function getOwnPropertyDescriptor(target, key) {
	    return isTAIndex(target, key = toPrimitive(key, true)) ? propertyDesc(2, target[key]) : gOPD(target, key);
	  };

	  var $setDesc = function defineProperty(target, key, desc) {
	    if (isTAIndex(target, key = toPrimitive(key, true)) && isObject(desc) && has(desc, 'value') && !has(desc, 'get') && !has(desc, 'set') // TODO: add validation descriptor w/o calling accessors
	    && !desc.configurable && (!has(desc, 'writable') || desc.writable) && (!has(desc, 'enumerable') || desc.enumerable)) {
	      target[key] = desc.value;
	      return target;
	    }

	    return dP(target, key, desc);
	  };

	  if (!ALL_CONSTRUCTORS) {
	    $GOPD.f = $getDesc;
	    $DP.f = $setDesc;
	  }

	  $export($export.S + $export.F * !ALL_CONSTRUCTORS, 'Object', {
	    getOwnPropertyDescriptor: $getDesc,
	    defineProperty: $setDesc
	  });

	  if (fails(function () {
	    arrayToString.call({});
	  })) {
	    arrayToString = arrayToLocaleString = function toString() {
	      return arrayJoin.call(this);
	    };
	  }

	  var $TypedArrayPrototype$ = redefineAll({}, proto);
	  redefineAll($TypedArrayPrototype$, $iterators);
	  hide($TypedArrayPrototype$, ITERATOR, $iterators.values);
	  redefineAll($TypedArrayPrototype$, {
	    slice: $slice,
	    set: $set,
	    constructor: function constructor() {
	      /* noop */
	    },
	    toString: arrayToString,
	    toLocaleString: $toLocaleString
	  });
	  addGetter($TypedArrayPrototype$, 'buffer', 'b');
	  addGetter($TypedArrayPrototype$, 'byteOffset', 'o');
	  addGetter($TypedArrayPrototype$, 'byteLength', 'l');
	  addGetter($TypedArrayPrototype$, 'length', 'e');
	  dP($TypedArrayPrototype$, TAG, {
	    get: function get() {
	      return this[TYPED_ARRAY];
	    }
	  }); // eslint-disable-next-line max-statements

	  module.exports = function (KEY, BYTES, wrapper, CLAMPED) {
	    CLAMPED = !!CLAMPED;
	    var NAME = KEY + (CLAMPED ? 'Clamped' : '') + 'Array';
	    var GETTER = 'get' + KEY;
	    var SETTER = 'set' + KEY;
	    var TypedArray = global[NAME];
	    var Base = TypedArray || {};
	    var TAC = TypedArray && getPrototypeOf(TypedArray);
	    var FORCED = !TypedArray || !$typed.ABV;
	    var O = {};
	    var TypedArrayPrototype = TypedArray && TypedArray[PROTOTYPE];

	    var getter = function getter(that, index) {
	      var data = that._d;
	      return data.v[GETTER](index * BYTES + data.o, LITTLE_ENDIAN);
	    };

	    var setter = function setter(that, index, value) {
	      var data = that._d;
	      if (CLAMPED) value = (value = Math.round(value)) < 0 ? 0 : value > 0xff ? 0xff : value & 0xff;
	      data.v[SETTER](index * BYTES + data.o, value, LITTLE_ENDIAN);
	    };

	    var addElement = function addElement(that, index) {
	      dP(that, index, {
	        get: function get() {
	          return getter(this, index);
	        },
	        set: function set(value) {
	          return setter(this, index, value);
	        },
	        enumerable: true
	      });
	    };

	    if (FORCED) {
	      TypedArray = wrapper(function (that, data, $offset, $length) {
	        anInstance(that, TypedArray, NAME, '_d');
	        var index = 0;
	        var offset = 0;
	        var buffer, byteLength, length, klass;

	        if (!isObject(data)) {
	          length = toIndex(data);
	          byteLength = length * BYTES;
	          buffer = new $ArrayBuffer(byteLength);
	        } else if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
	          buffer = data;
	          offset = toOffset($offset, BYTES);
	          var $len = data.byteLength;

	          if ($length === undefined) {
	            if ($len % BYTES) throw RangeError(WRONG_LENGTH);
	            byteLength = $len - offset;
	            if (byteLength < 0) throw RangeError(WRONG_LENGTH);
	          } else {
	            byteLength = toLength($length) * BYTES;
	            if (byteLength + offset > $len) throw RangeError(WRONG_LENGTH);
	          }

	          length = byteLength / BYTES;
	        } else if (TYPED_ARRAY in data) {
	          return fromList(TypedArray, data);
	        } else {
	          return $from.call(TypedArray, data);
	        }

	        hide(that, '_d', {
	          b: buffer,
	          o: offset,
	          l: byteLength,
	          e: length,
	          v: new $DataView(buffer)
	        });

	        while (index < length) {
	          addElement(that, index++);
	        }
	      });
	      TypedArrayPrototype = TypedArray[PROTOTYPE] = create($TypedArrayPrototype$);
	      hide(TypedArrayPrototype, 'constructor', TypedArray);
	    } else if (!fails(function () {
	      TypedArray(1);
	    }) || !fails(function () {
	      new TypedArray(-1); // eslint-disable-line no-new
	    }) || !$iterDetect(function (iter) {
	      new TypedArray(); // eslint-disable-line no-new

	      new TypedArray(null); // eslint-disable-line no-new

	      new TypedArray(1.5); // eslint-disable-line no-new

	      new TypedArray(iter); // eslint-disable-line no-new
	    }, true)) {
	      TypedArray = wrapper(function (that, data, $offset, $length) {
	        anInstance(that, TypedArray, NAME);
	        var klass; // `ws` module bug, temporarily remove validation length for Uint8Array
	        // https://github.com/websockets/ws/pull/645

	        if (!isObject(data)) return new Base(toIndex(data));

	        if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
	          return $length !== undefined ? new Base(data, toOffset($offset, BYTES), $length) : $offset !== undefined ? new Base(data, toOffset($offset, BYTES)) : new Base(data);
	        }

	        if (TYPED_ARRAY in data) return fromList(TypedArray, data);
	        return $from.call(TypedArray, data);
	      });
	      arrayForEach(TAC !== Function.prototype ? gOPN(Base).concat(gOPN(TAC)) : gOPN(Base), function (key) {
	        if (!(key in TypedArray)) hide(TypedArray, key, Base[key]);
	      });
	      TypedArray[PROTOTYPE] = TypedArrayPrototype;
	      TypedArrayPrototype.constructor = TypedArray;
	    }

	    var $nativeIterator = TypedArrayPrototype[ITERATOR];
	    var CORRECT_ITER_NAME = !!$nativeIterator && ($nativeIterator.name == 'values' || $nativeIterator.name == undefined);
	    var $iterator = $iterators.values;
	    hide(TypedArray, TYPED_CONSTRUCTOR, true);
	    hide(TypedArrayPrototype, TYPED_ARRAY, NAME);
	    hide(TypedArrayPrototype, VIEW, true);
	    hide(TypedArrayPrototype, DEF_CONSTRUCTOR, TypedArray);

	    if (CLAMPED ? new TypedArray(1)[TAG] != NAME : !(TAG in TypedArrayPrototype)) {
	      dP(TypedArrayPrototype, TAG, {
	        get: function get() {
	          return NAME;
	        }
	      });
	    }

	    O[NAME] = TypedArray;
	    $export($export.G + $export.W + $export.F * (TypedArray != Base), O);
	    $export($export.S, NAME, {
	      BYTES_PER_ELEMENT: BYTES
	    });
	    $export($export.S + $export.F * fails(function () {
	      Base.of.call(TypedArray, 1);
	    }), NAME, {
	      from: $from,
	      of: $of
	    });
	    if (!(BYTES_PER_ELEMENT in TypedArrayPrototype)) hide(TypedArrayPrototype, BYTES_PER_ELEMENT, BYTES);
	    $export($export.P, NAME, proto);
	    setSpecies(NAME);
	    $export($export.P + $export.F * FORCED_SET, NAME, {
	      set: $set
	    });
	    $export($export.P + $export.F * !CORRECT_ITER_NAME, NAME, $iterators);
	    if (TypedArrayPrototype.toString != arrayToString) TypedArrayPrototype.toString = arrayToString;
	    $export($export.P + $export.F * fails(function () {
	      new TypedArray(1).slice();
	    }), NAME, {
	      slice: $slice
	    });
	    $export($export.P + $export.F * (fails(function () {
	      return [1, 2].toLocaleString() != new TypedArray([1, 2]).toLocaleString();
	    }) || !fails(function () {
	      TypedArrayPrototype.toLocaleString.call([1, 2]);
	    })), NAME, {
	      toLocaleString: $toLocaleString
	    });
	    Iterators[NAME] = CORRECT_ITER_NAME ? $nativeIterator : $iterator;
	    if (!CORRECT_ITER_NAME) hide(TypedArrayPrototype, ITERATOR, $iterator);
	  };
	} else module.exports = function () {
	  /* empty */
	};
	});

	_typedArray('Int8', 1, function (init) {
	  return function Int8Array(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	});

	_typedArray('Uint8', 1, function (init) {
	  return function Uint8Array(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	});

	_typedArray('Uint8', 1, function (init) {
	  return function Uint8ClampedArray(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	}, true);

	_typedArray('Int16', 2, function (init) {
	  return function Int16Array(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	});

	_typedArray('Uint16', 2, function (init) {
	  return function Uint16Array(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	});

	_typedArray('Int32', 4, function (init) {
	  return function Int32Array(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	});

	_typedArray('Uint32', 4, function (init) {
	  return function Uint32Array(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	});

	_typedArray('Float32', 4, function (init) {
	  return function Float32Array(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	});

	_typedArray('Float64', 8, function (init) {
	  return function Float64Array(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	});

	// 26.1.1 Reflect.apply(target, thisArgument, argumentsList)






	var rApply = (_global.Reflect || {}).apply;
	var fApply = Function.apply; // MS Edge argumentsList argument is optional

	_export(_export.S + _export.F * !_fails(function () {
	  rApply(function () {
	    /* empty */
	  });
	}), 'Reflect', {
	  apply: function apply(target, thisArgument, argumentsList) {
	    var T = _aFunction(target);
	    var L = _anObject(argumentsList);
	    return rApply ? rApply(T, thisArgument, L) : fApply.call(T, thisArgument, L);
	  }
	});

	// 26.1.2 Reflect.construct(target, argumentsList [, newTarget])














	var rConstruct = (_global.Reflect || {}).construct; // MS Edge supports only 2 arguments and argumentsList argument is optional
	// FF Nightly sets third argument as `new.target`, but does not create `this` from it

	var NEW_TARGET_BUG = _fails(function () {
	  function F() {
	    /* empty */
	  }

	  return !(rConstruct(function () {
	    /* empty */
	  }, [], F) instanceof F);
	});
	var ARGS_BUG = !_fails(function () {
	  rConstruct(function () {
	    /* empty */
	  });
	});
	_export(_export.S + _export.F * (NEW_TARGET_BUG || ARGS_BUG), 'Reflect', {
	  construct: function construct(Target, args
	  /* , newTarget */
	  ) {
	    _aFunction(Target);
	    _anObject(args);
	    var newTarget = arguments.length < 3 ? Target : _aFunction(arguments[2]);
	    if (ARGS_BUG && !NEW_TARGET_BUG) return rConstruct(Target, args, newTarget);

	    if (Target == newTarget) {
	      // w/o altered newTarget, optimization for 0-4 arguments
	      switch (args.length) {
	        case 0:
	          return new Target();

	        case 1:
	          return new Target(args[0]);

	        case 2:
	          return new Target(args[0], args[1]);

	        case 3:
	          return new Target(args[0], args[1], args[2]);

	        case 4:
	          return new Target(args[0], args[1], args[2], args[3]);
	      } // w/o altered newTarget, lot of arguments case


	      var $args = [null];
	      $args.push.apply($args, args);
	      return new (_bind.apply(Target, $args))();
	    } // with altered newTarget, not support built-in constructors


	    var proto = newTarget.prototype;
	    var instance = _objectCreate(_isObject(proto) ? proto : Object.prototype);
	    var result = Function.apply.call(Target, instance, args);
	    return _isObject(result) ? result : instance;
	  }
	});

	// 26.1.3 Reflect.defineProperty(target, propertyKey, attributes)






	 // MS Edge has broken Reflect.defineProperty - throwing instead of returning false


	_export(_export.S + _export.F * _fails(function () {
	  // eslint-disable-next-line no-undef
	  Reflect.defineProperty(_objectDp.f({}, 1, {
	    value: 1
	  }), 1, {
	    value: 2
	  });
	}), 'Reflect', {
	  defineProperty: function defineProperty(target, propertyKey, attributes) {
	    _anObject(target);
	    propertyKey = _toPrimitive(propertyKey, true);
	    _anObject(attributes);

	    try {
	      _objectDp.f(target, propertyKey, attributes);
	      return true;
	    } catch (e) {
	      return false;
	    }
	  }
	});

	// 26.1.4 Reflect.deleteProperty(target, propertyKey)


	var gOPD$3 = _objectGopd.f;



	_export(_export.S, 'Reflect', {
	  deleteProperty: function deleteProperty(target, propertyKey) {
	    var desc = gOPD$3(_anObject(target), propertyKey);
	    return desc && !desc.configurable ? false : delete target[propertyKey];
	  }
	});

	var Enumerate = function Enumerate(iterated) {
	  this._t = _anObject(iterated); // target

	  this._i = 0; // next index

	  var keys = this._k = []; // keys

	  var key;

	  for (key in iterated) {
	    keys.push(key);
	  }
	};

	_iterCreate(Enumerate, 'Object', function () {
	  var that = this;
	  var keys = that._k;
	  var key;

	  do {
	    if (that._i >= keys.length) return {
	      value: undefined,
	      done: true
	    };
	  } while (!((key = keys[that._i++]) in that._t));

	  return {
	    value: key,
	    done: false
	  };
	});

	_export(_export.S, 'Reflect', {
	  enumerate: function enumerate(target) {
	    return new Enumerate(target);
	  }
	});

	// 26.1.6 Reflect.get(target, propertyKey [, receiver])












	function get(target, propertyKey
	/* , receiver */
	) {
	  var receiver = arguments.length < 3 ? target : arguments[2];
	  var desc, proto;
	  if (_anObject(target) === receiver) return target[propertyKey];
	  if (desc = _objectGopd.f(target, propertyKey)) return _has(desc, 'value') ? desc.value : desc.get !== undefined ? desc.get.call(receiver) : undefined;
	  if (_isObject(proto = _objectGpo(target))) return get(proto, propertyKey, receiver);
	}

	_export(_export.S, 'Reflect', {
	  get: get
	});

	// 26.1.7 Reflect.getOwnPropertyDescriptor(target, propertyKey)






	_export(_export.S, 'Reflect', {
	  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey) {
	    return _objectGopd.f(_anObject(target), propertyKey);
	  }
	});

	// 26.1.8 Reflect.getPrototypeOf(target)






	_export(_export.S, 'Reflect', {
	  getPrototypeOf: function getPrototypeOf(target) {
	    return _objectGpo(_anObject(target));
	  }
	});

	// 26.1.9 Reflect.has(target, propertyKey)


	_export(_export.S, 'Reflect', {
	  has: function has(target, propertyKey) {
	    return propertyKey in target;
	  }
	});

	// 26.1.10 Reflect.isExtensible(target)




	var $isExtensible = Object.isExtensible;
	_export(_export.S, 'Reflect', {
	  isExtensible: function isExtensible(target) {
	    _anObject(target);
	    return $isExtensible ? $isExtensible(target) : true;
	  }
	});

	// all object keys, includes non-enumerable and symbols






	var Reflect$1 = _global.Reflect;

	var _ownKeys = Reflect$1 && Reflect$1.ownKeys || function ownKeys(it) {
	  var keys = _objectGopn.f(_anObject(it));
	  var getSymbols = _objectGops.f;
	  return getSymbols ? keys.concat(getSymbols(it)) : keys;
	};

	// 26.1.11 Reflect.ownKeys(target)


	_export(_export.S, 'Reflect', {
	  ownKeys: _ownKeys
	});

	// 26.1.12 Reflect.preventExtensions(target)




	var $preventExtensions = Object.preventExtensions;
	_export(_export.S, 'Reflect', {
	  preventExtensions: function preventExtensions(target) {
	    _anObject(target);

	    try {
	      if ($preventExtensions) $preventExtensions(target);
	      return true;
	    } catch (e) {
	      return false;
	    }
	  }
	});

	// 26.1.13 Reflect.set(target, propertyKey, V [, receiver])
















	function set(target, propertyKey, V
	/* , receiver */
	) {
	  var receiver = arguments.length < 4 ? target : arguments[3];
	  var ownDesc = _objectGopd.f(_anObject(target), propertyKey);
	  var existingDescriptor, proto;

	  if (!ownDesc) {
	    if (_isObject(proto = _objectGpo(target))) {
	      return set(proto, propertyKey, V, receiver);
	    }

	    ownDesc = _propertyDesc(0);
	  }

	  if (_has(ownDesc, 'value')) {
	    if (ownDesc.writable === false || !_isObject(receiver)) return false;

	    if (existingDescriptor = _objectGopd.f(receiver, propertyKey)) {
	      if (existingDescriptor.get || existingDescriptor.set || existingDescriptor.writable === false) return false;
	      existingDescriptor.value = V;
	      _objectDp.f(receiver, propertyKey, existingDescriptor);
	    } else _objectDp.f(receiver, propertyKey, _propertyDesc(0, V));

	    return true;
	  }

	  return ownDesc.set === undefined ? false : (ownDesc.set.call(receiver, V), true);
	}

	_export(_export.S, 'Reflect', {
	  set: set
	});

	// 26.1.14 Reflect.setPrototypeOf(target, proto)




	if (_setProto) _export(_export.S, 'Reflect', {
	  setPrototypeOf: function setPrototypeOf(target, proto) {
	    _setProto.check(target, proto);

	    try {
	      _setProto.set(target, proto);
	      return true;
	    } catch (e) {
	      return false;
	    }
	  }
	});

	var $includes = _arrayIncludes(true);

	_export(_export.P, 'Array', {
	  includes: function includes(el
	  /* , fromIndex = 0 */
	  ) {
	    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

	_addToUnscopables('includes');

	var IS_CONCAT_SPREADABLE = _wks('isConcatSpreadable');

	function flattenIntoArray(target, original, source, sourceLen, start, depth, mapper, thisArg) {
	  var targetIndex = start;
	  var sourceIndex = 0;
	  var mapFn = mapper ? _ctx(mapper, thisArg, 3) : false;
	  var element, spreadable;

	  while (sourceIndex < sourceLen) {
	    if (sourceIndex in source) {
	      element = mapFn ? mapFn(source[sourceIndex], sourceIndex, original) : source[sourceIndex];
	      spreadable = false;

	      if (_isObject(element)) {
	        spreadable = element[IS_CONCAT_SPREADABLE];
	        spreadable = spreadable !== undefined ? !!spreadable : _isArray(element);
	      }

	      if (spreadable && depth > 0) {
	        targetIndex = flattenIntoArray(target, original, element, _toLength(element.length), targetIndex, depth - 1) - 1;
	      } else {
	        if (targetIndex >= 0x1fffffffffffff) throw TypeError();
	        target[targetIndex] = element;
	      }

	      targetIndex++;
	    }

	    sourceIndex++;
	  }

	  return targetIndex;
	}

	var _flattenIntoArray = flattenIntoArray;

	_export(_export.P, 'Array', {
	  flatMap: function flatMap(callbackfn
	  /* , thisArg */
	  ) {
	    var O = _toObject(this);
	    var sourceLen, A;
	    _aFunction(callbackfn);
	    sourceLen = _toLength(O.length);
	    A = _arraySpeciesCreate(O, 0);
	    _flattenIntoArray(A, O, O, sourceLen, 0, 1, callbackfn, arguments[1]);
	    return A;
	  }
	});

	_addToUnscopables('flatMap');

	_export(_export.P, 'Array', {
	  flatten: function flatten()
	  /* depthArg = 1 */
	  {
	    var depthArg = arguments[0];
	    var O = _toObject(this);
	    var sourceLen = _toLength(O.length);
	    var A = _arraySpeciesCreate(O, 0);
	    _flattenIntoArray(A, O, O, sourceLen, 0, depthArg === undefined ? 1 : _toInteger(depthArg));
	    return A;
	  }
	});

	_addToUnscopables('flatten');

	var $at$2 = _stringAt(true);

	_export(_export.P, 'String', {
	  at: function at(pos) {
	    return $at$2(this, pos);
	  }
	});

	// https://github.com/tc39/proposal-string-pad-start-end






	var _stringPad = function (that, maxLength, fillString, left) {
	  var S = String(_defined(that));
	  var stringLength = S.length;
	  var fillStr = fillString === undefined ? ' ' : String(fillString);
	  var intMaxLength = _toLength(maxLength);
	  if (intMaxLength <= stringLength || fillStr == '') return S;
	  var fillLen = intMaxLength - stringLength;
	  var stringFiller = _stringRepeat.call(fillStr, Math.ceil(fillLen / fillStr.length));
	  if (stringFiller.length > fillLen) stringFiller = stringFiller.slice(0, fillLen);
	  return left ? stringFiller + S : S + stringFiller;
	};

	// https://github.com/zloirock/core-js/issues/280


	_export(_export.P + _export.F * /Version\/10\.\d+(\.\d+)? Safari\//.test(_userAgent), 'String', {
	  padStart: function padStart(maxLength
	  /* , fillString = ' ' */
	  ) {
	    return _stringPad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, true);
	  }
	});

	// https://github.com/zloirock/core-js/issues/280


	_export(_export.P + _export.F * /Version\/10\.\d+(\.\d+)? Safari\//.test(_userAgent), 'String', {
	  padEnd: function padEnd(maxLength
	  /* , fillString = ' ' */
	  ) {
	    return _stringPad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, false);
	  }
	});

	_stringTrim('trimLeft', function ($trim) {
	  return function trimLeft() {
	    return $trim(this, 1);
	  };
	}, 'trimStart');

	_stringTrim('trimRight', function ($trim) {
	  return function trimRight() {
	    return $trim(this, 2);
	  };
	}, 'trimEnd');

	var RegExpProto = RegExp.prototype;

	var $RegExpStringIterator = function $RegExpStringIterator(regexp, string) {
	  this._r = regexp;
	  this._s = string;
	};

	_iterCreate($RegExpStringIterator, 'RegExp String', function next() {
	  var match = this._r.exec(this._s);

	  return {
	    value: match,
	    done: match === null
	  };
	});

	_export(_export.P, 'String', {
	  matchAll: function matchAll(regexp) {
	    _defined(this);
	    if (!_isRegexp(regexp)) throw TypeError(regexp + ' is not a regexp!');
	    var S = String(this);
	    var flags = 'flags' in RegExpProto ? String(regexp.flags) : _flags.call(regexp);
	    var rx = new RegExp(regexp.source, ~flags.indexOf('g') ? flags : 'g' + flags);
	    rx.lastIndex = _toLength(regexp.lastIndex);
	    return new $RegExpStringIterator(rx, S);
	  }
	});

	_wksDefine('asyncIterator');

	_wksDefine('observable');

	// https://github.com/tc39/proposal-object-getownpropertydescriptors










	_export(_export.S, 'Object', {
	  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
	    var O = _toIobject(object);
	    var getDesc = _objectGopd.f;
	    var keys = _ownKeys(O);
	    var result = {};
	    var i = 0;
	    var key, desc;

	    while (keys.length > i) {
	      desc = getDesc(O, key = keys[i++]);
	      if (desc !== undefined) _createProperty(result, key, desc);
	    }

	    return result;
	  }
	});

	var isEnum$1 = _objectPie.f;

	var _objectToArray = function (isEntries) {
	  return function (it) {
	    var O = _toIobject(it);
	    var keys = _objectKeys(O);
	    var length = keys.length;
	    var i = 0;
	    var result = [];
	    var key;

	    while (length > i) {
	      if (isEnum$1.call(O, key = keys[i++])) {
	        result.push(isEntries ? [key, O[key]] : O[key]);
	      }
	    }

	    return result;
	  };
	};

	// https://github.com/tc39/proposal-object-values-entries


	var $values = _objectToArray(false);

	_export(_export.S, 'Object', {
	  values: function values(it) {
	    return $values(it);
	  }
	});

	// https://github.com/tc39/proposal-object-values-entries


	var $entries = _objectToArray(true);

	_export(_export.S, 'Object', {
	  entries: function entries(it) {
	    return $entries(it);
	  }
	});

	var _objectForcedPam = !_fails(function () {
	  var K = Math.random(); // In FF throws only define methods
	  // eslint-disable-next-line no-undef, no-useless-call

	  __defineSetter__.call(null, K, function () {
	    /* empty */
	  });

	  delete _global[K];
	});

	// B.2.2.2 Object.prototype.__defineGetter__(P, getter)


	_descriptors && _export(_export.P + _objectForcedPam, 'Object', {
	  __defineGetter__: function __defineGetter__(P, getter) {
	    _objectDp.f(_toObject(this), P, {
	      get: _aFunction(getter),
	      enumerable: true,
	      configurable: true
	    });
	  }
	});

	// B.2.2.3 Object.prototype.__defineSetter__(P, setter)


	_descriptors && _export(_export.P + _objectForcedPam, 'Object', {
	  __defineSetter__: function __defineSetter__(P, setter) {
	    _objectDp.f(_toObject(this), P, {
	      set: _aFunction(setter),
	      enumerable: true,
	      configurable: true
	    });
	  }
	});

	var getOwnPropertyDescriptor = _objectGopd.f; // B.2.2.4 Object.prototype.__lookupGetter__(P)


	_descriptors && _export(_export.P + _objectForcedPam, 'Object', {
	  __lookupGetter__: function __lookupGetter__(P) {
	    var O = _toObject(this);
	    var K = _toPrimitive(P, true);
	    var D;

	    do {
	      if (D = getOwnPropertyDescriptor(O, K)) return D.get;
	    } while (O = _objectGpo(O));
	  }
	});

	var getOwnPropertyDescriptor$1 = _objectGopd.f; // B.2.2.5 Object.prototype.__lookupSetter__(P)


	_descriptors && _export(_export.P + _objectForcedPam, 'Object', {
	  __lookupSetter__: function __lookupSetter__(P) {
	    var O = _toObject(this);
	    var K = _toPrimitive(P, true);
	    var D;

	    do {
	      if (D = getOwnPropertyDescriptor$1(O, K)) return D.set;
	    } while (O = _objectGpo(O));
	  }
	});

	var _arrayFromIterable = function (iter, ITERATOR) {
	  var result = [];
	  _forOf(iter, false, result.push, result, ITERATOR);
	  return result;
	};

	// https://github.com/DavidBruant/Map-Set.prototype.toJSON




	var _collectionToJson = function (NAME) {
	  return function toJSON() {
	    if (_classof(this) != NAME) throw TypeError(NAME + "#toJSON isn't generic");
	    return _arrayFromIterable(this);
	  };
	};

	// https://github.com/DavidBruant/Map-Set.prototype.toJSON


	_export(_export.P + _export.R, 'Map', {
	  toJSON: _collectionToJson('Map')
	});

	// https://github.com/DavidBruant/Map-Set.prototype.toJSON


	_export(_export.P + _export.R, 'Set', {
	  toJSON: _collectionToJson('Set')
	});

	var _setCollectionOf = function (COLLECTION) {
	  _export(_export.S, COLLECTION, {
	    of: function of() {
	      var length = arguments.length;
	      var A = new Array(length);

	      while (length--) {
	        A[length] = arguments[length];
	      }

	      return new this(A);
	    }
	  });
	};

	// https://tc39.github.io/proposal-setmap-offrom/#sec-map.of
	_setCollectionOf('Map');

	// https://tc39.github.io/proposal-setmap-offrom/#sec-set.of
	_setCollectionOf('Set');

	// https://tc39.github.io/proposal-setmap-offrom/#sec-weakmap.of
	_setCollectionOf('WeakMap');

	// https://tc39.github.io/proposal-setmap-offrom/#sec-weakset.of
	_setCollectionOf('WeakSet');

	var _setCollectionFrom = function (COLLECTION) {
	  _export(_export.S, COLLECTION, {
	    from: function from(source
	    /* , mapFn, thisArg */
	    ) {
	      var mapFn = arguments[1];
	      var mapping, A, n, cb;
	      _aFunction(this);
	      mapping = mapFn !== undefined;
	      if (mapping) _aFunction(mapFn);
	      if (source == undefined) return new this();
	      A = [];

	      if (mapping) {
	        n = 0;
	        cb = _ctx(mapFn, arguments[2], 2);
	        _forOf(source, false, function (nextItem) {
	          A.push(cb(nextItem, n++));
	        });
	      } else {
	        _forOf(source, false, A.push, A);
	      }

	      return new this(A);
	    }
	  });
	};

	// https://tc39.github.io/proposal-setmap-offrom/#sec-map.from
	_setCollectionFrom('Map');

	// https://tc39.github.io/proposal-setmap-offrom/#sec-set.from
	_setCollectionFrom('Set');

	// https://tc39.github.io/proposal-setmap-offrom/#sec-weakmap.from
	_setCollectionFrom('WeakMap');

	// https://tc39.github.io/proposal-setmap-offrom/#sec-weakset.from
	_setCollectionFrom('WeakSet');

	// https://github.com/tc39/proposal-global


	_export(_export.G, {
	  global: _global
	});

	// https://github.com/tc39/proposal-global


	_export(_export.S, 'System', {
	  global: _global
	});

	// https://github.com/ljharb/proposal-is-error




	_export(_export.S, 'Error', {
	  isError: function isError(it) {
	    return _cof(it) === 'Error';
	  }
	});

	// https://rwaldron.github.io/proposal-math-extensions/


	_export(_export.S, 'Math', {
	  clamp: function clamp(x, lower, upper) {
	    return Math.min(upper, Math.max(lower, x));
	  }
	});

	// https://rwaldron.github.io/proposal-math-extensions/


	_export(_export.S, 'Math', {
	  DEG_PER_RAD: Math.PI / 180
	});

	// https://rwaldron.github.io/proposal-math-extensions/


	var RAD_PER_DEG = 180 / Math.PI;
	_export(_export.S, 'Math', {
	  degrees: function degrees(radians) {
	    return radians * RAD_PER_DEG;
	  }
	});

	// https://rwaldron.github.io/proposal-math-extensions/
	var _mathScale = Math.scale || function scale(x, inLow, inHigh, outLow, outHigh) {
	  if (arguments.length === 0 // eslint-disable-next-line no-self-compare
	  || x != x // eslint-disable-next-line no-self-compare
	  || inLow != inLow // eslint-disable-next-line no-self-compare
	  || inHigh != inHigh // eslint-disable-next-line no-self-compare
	  || outLow != outLow // eslint-disable-next-line no-self-compare
	  || outHigh != outHigh) return NaN;
	  if (x === Infinity || x === -Infinity) return x;
	  return (x - inLow) * (outHigh - outLow) / (inHigh - inLow) + outLow;
	};

	// https://rwaldron.github.io/proposal-math-extensions/






	_export(_export.S, 'Math', {
	  fscale: function fscale(x, inLow, inHigh, outLow, outHigh) {
	    return _mathFround(_mathScale(x, inLow, inHigh, outLow, outHigh));
	  }
	});

	// https://gist.github.com/BrendanEich/4294d5c212a6d2254703


	_export(_export.S, 'Math', {
	  iaddh: function iaddh(x0, x1, y0, y1) {
	    var $x0 = x0 >>> 0;
	    var $x1 = x1 >>> 0;
	    var $y0 = y0 >>> 0;
	    return $x1 + (y1 >>> 0) + (($x0 & $y0 | ($x0 | $y0) & ~($x0 + $y0 >>> 0)) >>> 31) | 0;
	  }
	});

	// https://gist.github.com/BrendanEich/4294d5c212a6d2254703


	_export(_export.S, 'Math', {
	  isubh: function isubh(x0, x1, y0, y1) {
	    var $x0 = x0 >>> 0;
	    var $x1 = x1 >>> 0;
	    var $y0 = y0 >>> 0;
	    return $x1 - (y1 >>> 0) - ((~$x0 & $y0 | ~($x0 ^ $y0) & $x0 - $y0 >>> 0) >>> 31) | 0;
	  }
	});

	// https://gist.github.com/BrendanEich/4294d5c212a6d2254703


	_export(_export.S, 'Math', {
	  imulh: function imulh(u, v) {
	    var UINT16 = 0xffff;
	    var $u = +u;
	    var $v = +v;
	    var u0 = $u & UINT16;
	    var v0 = $v & UINT16;
	    var u1 = $u >> 16;
	    var v1 = $v >> 16;
	    var t = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);
	    return u1 * v1 + (t >> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >> 16);
	  }
	});

	// https://rwaldron.github.io/proposal-math-extensions/


	_export(_export.S, 'Math', {
	  RAD_PER_DEG: 180 / Math.PI
	});

	// https://rwaldron.github.io/proposal-math-extensions/


	var DEG_PER_RAD = Math.PI / 180;
	_export(_export.S, 'Math', {
	  radians: function radians(degrees) {
	    return degrees * DEG_PER_RAD;
	  }
	});

	// https://rwaldron.github.io/proposal-math-extensions/


	_export(_export.S, 'Math', {
	  scale: _mathScale
	});

	// https://gist.github.com/BrendanEich/4294d5c212a6d2254703


	_export(_export.S, 'Math', {
	  umulh: function umulh(u, v) {
	    var UINT16 = 0xffff;
	    var $u = +u;
	    var $v = +v;
	    var u0 = $u & UINT16;
	    var v0 = $v & UINT16;
	    var u1 = $u >>> 16;
	    var v1 = $v >>> 16;
	    var t = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);
	    return u1 * v1 + (t >>> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >>> 16);
	  }
	});

	// http://jfbastien.github.io/papers/Math.signbit.html


	_export(_export.S, 'Math', {
	  signbit: function signbit(x) {
	    // eslint-disable-next-line no-self-compare
	    return (x = +x) != x ? x : x == 0 ? 1 / x == Infinity : x > 0;
	  }
	});

	_export(_export.S, 'Promise', {
	  'try': function _try(callbackfn) {
	    var promiseCapability = _newPromiseCapability.f(this);
	    var result = _perform(callbackfn);
	    (result.e ? promiseCapability.reject : promiseCapability.resolve)(result.v);
	    return promiseCapability.promise;
	  }
	});

	var shared$1 = _shared('metadata');

	var store = shared$1.store || (shared$1.store = new (es6_weakMap)());

	var getOrCreateMetadataMap = function getOrCreateMetadataMap(target, targetKey, create) {
	  var targetMetadata = store.get(target);

	  if (!targetMetadata) {
	    if (!create) return undefined;
	    store.set(target, targetMetadata = new es6_map());
	  }

	  var keyMetadata = targetMetadata.get(targetKey);

	  if (!keyMetadata) {
	    if (!create) return undefined;
	    targetMetadata.set(targetKey, keyMetadata = new es6_map());
	  }

	  return keyMetadata;
	};

	var ordinaryHasOwnMetadata = function ordinaryHasOwnMetadata(MetadataKey, O, P) {
	  var metadataMap = getOrCreateMetadataMap(O, P, false);
	  return metadataMap === undefined ? false : metadataMap.has(MetadataKey);
	};

	var ordinaryGetOwnMetadata = function ordinaryGetOwnMetadata(MetadataKey, O, P) {
	  var metadataMap = getOrCreateMetadataMap(O, P, false);
	  return metadataMap === undefined ? undefined : metadataMap.get(MetadataKey);
	};

	var ordinaryDefineOwnMetadata = function ordinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P) {
	  getOrCreateMetadataMap(O, P, true).set(MetadataKey, MetadataValue);
	};

	var ordinaryOwnMetadataKeys = function ordinaryOwnMetadataKeys(target, targetKey) {
	  var metadataMap = getOrCreateMetadataMap(target, targetKey, false);
	  var keys = [];
	  if (metadataMap) metadataMap.forEach(function (_, key) {
	    keys.push(key);
	  });
	  return keys;
	};

	var toMetaKey = function toMetaKey(it) {
	  return it === undefined || babelHelpers.typeof(it) == 'symbol' ? it : String(it);
	};

	var exp$3 = function exp(O) {
	  _export(_export.S, 'Reflect', O);
	};

	var _metadata = {
	  store: store,
	  map: getOrCreateMetadataMap,
	  has: ordinaryHasOwnMetadata,
	  get: ordinaryGetOwnMetadata,
	  set: ordinaryDefineOwnMetadata,
	  keys: ordinaryOwnMetadataKeys,
	  key: toMetaKey,
	  exp: exp$3
	};

	var toMetaKey$1 = _metadata.key;
	var ordinaryDefineOwnMetadata$1 = _metadata.set;
	_metadata.exp({
	  defineMetadata: function defineMetadata(metadataKey, metadataValue, target, targetKey) {
	    ordinaryDefineOwnMetadata$1(metadataKey, metadataValue, _anObject(target), toMetaKey$1(targetKey));
	  }
	});

	var toMetaKey$2 = _metadata.key;
	var getOrCreateMetadataMap$1 = _metadata.map;
	var store$1 = _metadata.store;
	_metadata.exp({
	  deleteMetadata: function deleteMetadata(metadataKey, target
	  /* , targetKey */
	  ) {
	    var targetKey = arguments.length < 3 ? undefined : toMetaKey$2(arguments[2]);
	    var metadataMap = getOrCreateMetadataMap$1(_anObject(target), targetKey, false);
	    if (metadataMap === undefined || !metadataMap['delete'](metadataKey)) return false;
	    if (metadataMap.size) return true;
	    var targetMetadata = store$1.get(target);
	    targetMetadata['delete'](targetKey);
	    return !!targetMetadata.size || store$1['delete'](target);
	  }
	});

	var ordinaryHasOwnMetadata$1 = _metadata.has;
	var ordinaryGetOwnMetadata$1 = _metadata.get;
	var toMetaKey$3 = _metadata.key;

	var ordinaryGetMetadata = function ordinaryGetMetadata(MetadataKey, O, P) {
	  var hasOwn = ordinaryHasOwnMetadata$1(MetadataKey, O, P);
	  if (hasOwn) return ordinaryGetOwnMetadata$1(MetadataKey, O, P);
	  var parent = _objectGpo(O);
	  return parent !== null ? ordinaryGetMetadata(MetadataKey, parent, P) : undefined;
	};

	_metadata.exp({
	  getMetadata: function getMetadata(metadataKey, target
	  /* , targetKey */
	  ) {
	    return ordinaryGetMetadata(metadataKey, _anObject(target), arguments.length < 3 ? undefined : toMetaKey$3(arguments[2]));
	  }
	});

	var ordinaryOwnMetadataKeys$1 = _metadata.keys;
	var toMetaKey$4 = _metadata.key;

	var ordinaryMetadataKeys = function ordinaryMetadataKeys(O, P) {
	  var oKeys = ordinaryOwnMetadataKeys$1(O, P);
	  var parent = _objectGpo(O);
	  if (parent === null) return oKeys;
	  var pKeys = ordinaryMetadataKeys(parent, P);
	  return pKeys.length ? oKeys.length ? _arrayFromIterable(new es6_set(oKeys.concat(pKeys))) : pKeys : oKeys;
	};

	_metadata.exp({
	  getMetadataKeys: function getMetadataKeys(target
	  /* , targetKey */
	  ) {
	    return ordinaryMetadataKeys(_anObject(target), arguments.length < 2 ? undefined : toMetaKey$4(arguments[1]));
	  }
	});

	var ordinaryGetOwnMetadata$2 = _metadata.get;
	var toMetaKey$5 = _metadata.key;
	_metadata.exp({
	  getOwnMetadata: function getOwnMetadata(metadataKey, target
	  /* , targetKey */
	  ) {
	    return ordinaryGetOwnMetadata$2(metadataKey, _anObject(target), arguments.length < 3 ? undefined : toMetaKey$5(arguments[2]));
	  }
	});

	var ordinaryOwnMetadataKeys$2 = _metadata.keys;
	var toMetaKey$6 = _metadata.key;
	_metadata.exp({
	  getOwnMetadataKeys: function getOwnMetadataKeys(target
	  /* , targetKey */
	  ) {
	    return ordinaryOwnMetadataKeys$2(_anObject(target), arguments.length < 2 ? undefined : toMetaKey$6(arguments[1]));
	  }
	});

	var ordinaryHasOwnMetadata$2 = _metadata.has;
	var toMetaKey$7 = _metadata.key;

	var ordinaryHasMetadata = function ordinaryHasMetadata(MetadataKey, O, P) {
	  var hasOwn = ordinaryHasOwnMetadata$2(MetadataKey, O, P);
	  if (hasOwn) return true;
	  var parent = _objectGpo(O);
	  return parent !== null ? ordinaryHasMetadata(MetadataKey, parent, P) : false;
	};

	_metadata.exp({
	  hasMetadata: function hasMetadata(metadataKey, target
	  /* , targetKey */
	  ) {
	    return ordinaryHasMetadata(metadataKey, _anObject(target), arguments.length < 3 ? undefined : toMetaKey$7(arguments[2]));
	  }
	});

	var ordinaryHasOwnMetadata$3 = _metadata.has;
	var toMetaKey$8 = _metadata.key;
	_metadata.exp({
	  hasOwnMetadata: function hasOwnMetadata(metadataKey, target
	  /* , targetKey */
	  ) {
	    return ordinaryHasOwnMetadata$3(metadataKey, _anObject(target), arguments.length < 3 ? undefined : toMetaKey$8(arguments[2]));
	  }
	});

	var toMetaKey$9 = _metadata.key;
	var ordinaryDefineOwnMetadata$2 = _metadata.set;
	_metadata.exp({
	  metadata: function metadata(metadataKey, metadataValue) {
	    return function decorator(target, targetKey) {
	      ordinaryDefineOwnMetadata$2(metadataKey, metadataValue, (targetKey !== undefined ? _anObject : _aFunction)(target), toMetaKey$9(targetKey));
	    };
	  }
	});

	// https://github.com/rwaldron/tc39-notes/blob/master/es6/2014-09/sept-25.md#510-globalasap-for-enqueuing-a-microtask


	var microtask$1 = _microtask();

	var process$3 = _global.process;

	var isNode$2 = _cof(process$3) == 'process';
	_export(_export.G, {
	  asap: function asap(fn) {
	    var domain = isNode$2 && process$3.domain;
	    microtask$1(domain ? domain.bind(fn) : fn);
	  }
	});

	var microtask$2 = _microtask();

	var OBSERVABLE = _wks('observable');













	var RETURN = _forOf.RETURN;

	var getMethod = function getMethod(fn) {
	  return fn == null ? undefined : _aFunction(fn);
	};

	var cleanupSubscription = function cleanupSubscription(subscription) {
	  var cleanup = subscription._c;

	  if (cleanup) {
	    subscription._c = undefined;
	    cleanup();
	  }
	};

	var subscriptionClosed = function subscriptionClosed(subscription) {
	  return subscription._o === undefined;
	};

	var closeSubscription = function closeSubscription(subscription) {
	  if (!subscriptionClosed(subscription)) {
	    subscription._o = undefined;
	    cleanupSubscription(subscription);
	  }
	};

	var Subscription = function Subscription(observer, subscriber) {
	  _anObject(observer);
	  this._c = undefined;
	  this._o = observer;
	  observer = new SubscriptionObserver(this);

	  try {
	    var cleanup = subscriber(observer);
	    var subscription = cleanup;

	    if (cleanup != null) {
	      if (typeof cleanup.unsubscribe === 'function') cleanup = function cleanup() {
	        subscription.unsubscribe();
	      };else _aFunction(cleanup);
	      this._c = cleanup;
	    }
	  } catch (e) {
	    observer.error(e);
	    return;
	  }

	  if (subscriptionClosed(this)) cleanupSubscription(this);
	};

	Subscription.prototype = _redefineAll({}, {
	  unsubscribe: function unsubscribe() {
	    closeSubscription(this);
	  }
	});

	var SubscriptionObserver = function SubscriptionObserver(subscription) {
	  this._s = subscription;
	};

	SubscriptionObserver.prototype = _redefineAll({}, {
	  next: function next(value) {
	    var subscription = this._s;

	    if (!subscriptionClosed(subscription)) {
	      var observer = subscription._o;

	      try {
	        var m = getMethod(observer.next);
	        if (m) return m.call(observer, value);
	      } catch (e) {
	        try {
	          closeSubscription(subscription);
	        } finally {
	          throw e;
	        }
	      }
	    }
	  },
	  error: function error(value) {
	    var subscription = this._s;
	    if (subscriptionClosed(subscription)) throw value;
	    var observer = subscription._o;
	    subscription._o = undefined;

	    try {
	      var m = getMethod(observer.error);
	      if (!m) throw value;
	      value = m.call(observer, value);
	    } catch (e) {
	      try {
	        cleanupSubscription(subscription);
	      } finally {
	        throw e;
	      }
	    }

	    cleanupSubscription(subscription);
	    return value;
	  },
	  complete: function complete(value) {
	    var subscription = this._s;

	    if (!subscriptionClosed(subscription)) {
	      var observer = subscription._o;
	      subscription._o = undefined;

	      try {
	        var m = getMethod(observer.complete);
	        value = m ? m.call(observer, value) : undefined;
	      } catch (e) {
	        try {
	          cleanupSubscription(subscription);
	        } finally {
	          throw e;
	        }
	      }

	      cleanupSubscription(subscription);
	      return value;
	    }
	  }
	});

	var $Observable = function Observable(subscriber) {
	  _anInstance(this, $Observable, 'Observable', '_f')._f = _aFunction(subscriber);
	};

	_redefineAll($Observable.prototype, {
	  subscribe: function subscribe(observer) {
	    return new Subscription(observer, this._f);
	  },
	  forEach: function forEach(fn) {
	    var that = this;
	    return new (_core.Promise || _global.Promise)(function (resolve, reject) {
	      _aFunction(fn);
	      var subscription = that.subscribe({
	        next: function next(value) {
	          try {
	            return fn(value);
	          } catch (e) {
	            reject(e);
	            subscription.unsubscribe();
	          }
	        },
	        error: reject,
	        complete: resolve
	      });
	    });
	  }
	});
	_redefineAll($Observable, {
	  from: function from(x) {
	    var C = typeof this === 'function' ? this : $Observable;
	    var method = getMethod(_anObject(x)[OBSERVABLE]);

	    if (method) {
	      var observable = _anObject(method.call(x));
	      return observable.constructor === C ? observable : new C(function (observer) {
	        return observable.subscribe(observer);
	      });
	    }

	    return new C(function (observer) {
	      var done = false;
	      microtask$2(function () {
	        if (!done) {
	          try {
	            if (_forOf(x, false, function (it) {
	              observer.next(it);
	              if (done) return RETURN;
	            }) === RETURN) return;
	          } catch (e) {
	            if (done) throw e;
	            observer.error(e);
	            return;
	          }

	          observer.complete();
	        }
	      });
	      return function () {
	        done = true;
	      };
	    });
	  },
	  of: function of() {
	    for (var i = 0, l = arguments.length, items = new Array(l); i < l;) {
	      items[i] = arguments[i++];
	    }

	    return new (typeof this === 'function' ? this : $Observable)(function (observer) {
	      var done = false;
	      microtask$2(function () {
	        if (!done) {
	          for (var j = 0; j < items.length; ++j) {
	            observer.next(items[j]);
	            if (done) return;
	          }

	          observer.complete();
	        }
	      });
	      return function () {
	        done = true;
	      };
	    });
	  }
	});
	_hide($Observable.prototype, OBSERVABLE, function () {
	  return this;
	});
	_export(_export.G, {
	  Observable: $Observable
	});

	_setSpecies('Observable');

	// ie9- setTimeout & setInterval additional parameters fix






	var slice = [].slice;
	var MSIE = /MSIE .\./.test(_userAgent); // <- dirty ie9- check

	var wrap$1 = function wrap(set) {
	  return function (fn, time
	  /* , ...args */
	  ) {
	    var boundArgs = arguments.length > 2;
	    var args = boundArgs ? slice.call(arguments, 2) : false;
	    return set(boundArgs ? function () {
	      // eslint-disable-next-line no-new-func
	      (typeof fn == 'function' ? fn : Function(fn)).apply(this, args);
	    } : fn, time);
	  };
	};

	_export(_export.G + _export.B + _export.F * MSIE, {
	  setTimeout: wrap$1(_global.setTimeout),
	  setInterval: wrap$1(_global.setInterval)
	});

	_export(_export.G + _export.B, {
	  setImmediate: _task.set,
	  clearImmediate: _task.clear
	});

	var ITERATOR$4 = _wks('iterator');
	var TO_STRING_TAG = _wks('toStringTag');
	var ArrayValues = _iterators.Array;
	var DOMIterables = {
	  CSSRuleList: true,
	  // TODO: Not spec compliant, should be false.
	  CSSStyleDeclaration: false,
	  CSSValueList: false,
	  ClientRectList: false,
	  DOMRectList: false,
	  DOMStringList: false,
	  DOMTokenList: true,
	  DataTransferItemList: false,
	  FileList: false,
	  HTMLAllCollection: false,
	  HTMLCollection: false,
	  HTMLFormElement: false,
	  HTMLSelectElement: false,
	  MediaList: true,
	  // TODO: Not spec compliant, should be false.
	  MimeTypeArray: false,
	  NamedNodeMap: false,
	  NodeList: true,
	  PaintRequestList: false,
	  Plugin: false,
	  PluginArray: false,
	  SVGLengthList: false,
	  SVGNumberList: false,
	  SVGPathSegList: false,
	  SVGPointList: false,
	  SVGStringList: false,
	  SVGTransformList: false,
	  SourceBufferList: false,
	  StyleSheetList: true,
	  // TODO: Not spec compliant, should be false.
	  TextTrackCueList: false,
	  TextTrackList: false,
	  TouchList: false
	};

	for (var collections = _objectKeys(DOMIterables), i$2 = 0; i$2 < collections.length; i$2++) {
	  var NAME$1 = collections[i$2];
	  var explicit = DOMIterables[NAME$1];
	  var Collection = _global[NAME$1];
	  var proto$3 = Collection && Collection.prototype;
	  var key$1;

	  if (proto$3) {
	    if (!proto$3[ITERATOR$4]) _hide(proto$3, ITERATOR$4, ArrayValues);
	    if (!proto$3[TO_STRING_TAG]) _hide(proto$3, TO_STRING_TAG, NAME$1);
	    _iterators[NAME$1] = ArrayValues;
	    if (explicit) for (key$1 in es6_array_iterator) {
	      if (!proto$3[key$1]) _redefine(proto$3, key$1, es6_array_iterator[key$1], true);
	    }
	  }
	}

	if (window._main_core_polyfill) {
	  console.warn('main.core.polyfill is loaded more than once on this page');
	}

	window._main_core_polyfill = true;

}((this.window = this.window || {})));



/**
 * Element.prototype.matches polyfill
 */
;(function(element) {
	'use strict';

	if (!element.matches && element.matchesSelector)
	{
		element.matches = element.matchesSelector;
	}

	if (!element.matches)
	{
		element.matches = function(selector) {
			var matches = document.querySelectorAll(selector);
			var self = this;

			return Array.prototype.some.call(matches, function(e) {
				return e === self;
			});
		};
	}

})(Element.prototype);

;(function() {
	'use strict';

	if (!Element.prototype.closest)
	{
		/**
		 * Finds closest parent element by selector
		 * @param {string} selector
		 * @return {HTMLElement|Element|Node}
		 */
		Object.defineProperty(Element.prototype, 'closest', {
			enumerable: false,
			value: function(selector) {
				var node = this;

				while (node)
				{
					if (node.matches(selector))
					{
						return node;
					}

					node = node.parentElement;
				}

				return null;
			},
		});
	}
})();

(function (exports) {
	'use strict';

	if (!window.DOMRect || typeof DOMRect.prototype.toJSON !== 'function' || typeof DOMRect.fromRect !== 'function') {
	  window.DOMRect =
	  /*#__PURE__*/
	  function () {
	    function DOMRect(x, y, width, height) {
	      babelHelpers.classCallCheck(this, DOMRect);
	      this.x = x || 0;
	      this.y = y || 0;
	      this.width = width || 0;
	      this.height = height || 0;
	    }

	    babelHelpers.createClass(DOMRect, [{
	      key: "toJSON",
	      value: function toJSON() {
	        return {
	          top: this.top,
	          left: this.left,
	          right: this.right,
	          bottom: this.bottom,
	          width: this.width,
	          height: this.height,
	          x: this.x,
	          y: this.y
	        };
	      }
	    }, {
	      key: "top",
	      get: function get() {
	        return this.y;
	      }
	    }, {
	      key: "left",
	      get: function get() {
	        return this.x;
	      }
	    }, {
	      key: "right",
	      get: function get() {
	        return this.x + this.width;
	      }
	    }, {
	      key: "bottom",
	      get: function get() {
	        return this.y + this.height;
	      }
	    }], [{
	      key: "fromRect",
	      value: function fromRect(otherRect) {
	        return new DOMRect(otherRect.x, otherRect.y, otherRect.width, otherRect.height);
	      }
	    }]);
	    return DOMRect;
	  }();
	}

}((this.window = this.window || {})));




(function (exports) {
	'use strict';

	/**
	 * Gets object.toString result
	 * @param value
	 * @return {string}
	 */
	function getTag(value) {
	  return Object.prototype.toString.call(value);
	}

	var objectCtorString = Function.prototype.toString.call(Object);
	/**
	 * @memberOf BX
	 */

	var Type = /*#__PURE__*/function () {
	  function Type() {
	    babelHelpers.classCallCheck(this, Type);
	  }

	  babelHelpers.createClass(Type, null, [{
	    key: "isString",

	    /**
	     * Checks that value is string
	     * @param value
	     * @return {boolean}
	     */
	    value: function isString(value) {
	      return typeof value === 'string';
	    }
	    /**
	     * Returns true if a value is not empty string
	     * @param value
	     * @returns {boolean}
	     */

	  }, {
	    key: "isStringFilled",
	    value: function isStringFilled(value) {
	      return this.isString(value) && value !== '';
	    }
	    /**
	     * Checks that value is function
	     * @param value
	     * @return {boolean}
	     */

	  }, {
	    key: "isFunction",
	    value: function isFunction(value) {
	      return typeof value === 'function';
	    }
	    /**
	     * Checks that value is object
	     * @param value
	     * @return {boolean}
	     */

	  }, {
	    key: "isObject",
	    value: function isObject(value) {
	      return !!value && (babelHelpers.typeof(value) === 'object' || typeof value === 'function');
	    }
	    /**
	     * Checks that value is object like
	     * @param value
	     * @return {boolean}
	     */

	  }, {
	    key: "isObjectLike",
	    value: function isObjectLike(value) {
	      return !!value && babelHelpers.typeof(value) === 'object';
	    }
	    /**
	     * Checks that value is plain object
	     * @param value
	     * @return {boolean}
	     */

	  }, {
	    key: "isPlainObject",
	    value: function isPlainObject(value) {
	      if (!Type.isObjectLike(value) || getTag(value) !== '[object Object]') {
	        return false;
	      }

	      var proto = Object.getPrototypeOf(value);

	      if (proto === null) {
	        return true;
	      }

	      var ctor = proto.hasOwnProperty('constructor') && proto.constructor;
	      return typeof ctor === 'function' && Function.prototype.toString.call(ctor) === objectCtorString;
	    }
	    /**
	     * Checks that value is boolean
	     * @param value
	     * @return {boolean}
	     */

	  }, {
	    key: "isBoolean",
	    value: function isBoolean(value) {
	      return value === true || value === false;
	    }
	    /**
	     * Checks that value is number
	     * @param value
	     * @return {boolean}
	     */

	  }, {
	    key: "isNumber",
	    value: function isNumber(value) {
	      return !Number.isNaN(value) && typeof value === 'number';
	    }
	    /**
	     * Checks that value is integer
	     * @param value
	     * @return {boolean}
	     */

	  }, {
	    key: "isInteger",
	    value: function isInteger(value) {
	      return Type.isNumber(value) && value % 1 === 0;
	    }
	    /**
	     * Checks that value is float
	     * @param value
	     * @return {boolean}
	     */

	  }, {
	    key: "isFloat",
	    value: function isFloat(value) {
	      return Type.isNumber(value) && !Type.isInteger(value);
	    }
	    /**
	     * Checks that value is nil
	     * @param value
	     * @return {boolean}
	     */

	  }, {
	    key: "isNil",
	    value: function isNil(value) {
	      return value === null || value === undefined;
	    }
	    /**
	     * Checks that value is array
	     * @param value
	     * @return {boolean}
	     */

	  }, {
	    key: "isArray",
	    value: function isArray(value) {
	      return !Type.isNil(value) && Array.isArray(value);
	    }
	    /**
	     * Returns true if a value is an array and it has at least one element
	     * @param value
	     * @returns {boolean}
	     */

	  }, {
	    key: "isArrayFilled",
	    value: function isArrayFilled(value) {
	      return this.isArray(value) && value.length > 0;
	    }
	    /**
	     * Checks that value is array like
	     * @param value
	     * @return {boolean}
	     */

	  }, {
	    key: "isArrayLike",
	    value: function isArrayLike(value) {
	      return !Type.isNil(value) && !Type.isFunction(value) && value.length > -1 && value.length <= Number.MAX_SAFE_INTEGER;
	    }
	    /**
	     * Checks that value is Date
	     * @param value
	     * @return {boolean}
	     */

	  }, {
	    key: "isDate",
	    value: function isDate(value) {
	      return Type.isObjectLike(value) && getTag(value) === '[object Date]';
	    }
	    /**
	     * Checks that is DOM node
	     * @param value
	     * @return {boolean}
	     */

	  }, {
	    key: "isDomNode",
	    value: function isDomNode(value) {
	      return Type.isObjectLike(value) && !Type.isPlainObject(value) && 'nodeType' in value;
	    }
	    /**
	     * Checks that value is element node
	     * @param value
	     * @return {boolean}
	     */

	  }, {
	    key: "isElementNode",
	    value: function isElementNode(value) {
	      return Type.isDomNode(value) && value.nodeType === Node.ELEMENT_NODE;
	    }
	    /**
	     * Checks that value is text node
	     * @param value
	     * @return {boolean}
	     */

	  }, {
	    key: "isTextNode",
	    value: function isTextNode(value) {
	      return Type.isDomNode(value) && value.nodeType === Node.TEXT_NODE;
	    }
	    /**
	     * Checks that value is Map
	     * @param value
	     * @return {boolean}
	     */

	  }, {
	    key: "isMap",
	    value: function isMap(value) {
	      return Type.isObjectLike(value) && getTag(value) === '[object Map]';
	    }
	    /**
	     * Checks that value is Set
	     * @param value
	     * @return {boolean}
	     */

	  }, {
	    key: "isSet",
	    value: function isSet(value) {
	      return Type.isObjectLike(value) && getTag(value) === '[object Set]';
	    }
	    /**
	     * Checks that value is WeakMap
	     * @param value
	     * @return {boolean}
	     */

	  }, {
	    key: "isWeakMap",
	    value: function isWeakMap(value) {
	      return Type.isObjectLike(value) && getTag(value) === '[object WeakMap]';
	    }
	    /**
	     * Checks that value is WeakSet
	     * @param value
	     * @return {boolean}
	     */

	  }, {
	    key: "isWeakSet",
	    value: function isWeakSet(value) {
	      return Type.isObjectLike(value) && getTag(value) === '[object WeakSet]';
	    }
	    /**
	     * Checks that value is prototype
	     * @param value
	     * @return {boolean}
	     */

	  }, {
	    key: "isPrototype",
	    value: function isPrototype(value) {
	      return (typeof (value && value.constructor) === 'function' && value.constructor.prototype || Object.prototype) === value;
	    }
	    /**
	     * Checks that value is regexp
	     * @param value
	     * @return {boolean}
	     */

	  }, {
	    key: "isRegExp",
	    value: function isRegExp(value) {
	      return Type.isObjectLike(value) && getTag(value) === '[object RegExp]';
	    }
	    /**
	     * Checks that value is null
	     * @param value
	     * @return {boolean}
	     */

	  }, {
	    key: "isNull",
	    value: function isNull(value) {
	      return value === null;
	    }
	    /**
	     * Checks that value is undefined
	     * @param value
	     * @return {boolean}
	     */

	  }, {
	    key: "isUndefined",
	    value: function isUndefined(value) {
	      return typeof value === 'undefined';
	    }
	    /**
	     * Checks that value is ArrayBuffer
	     * @param value
	     * @return {boolean}
	     */

	  }, {
	    key: "isArrayBuffer",
	    value: function isArrayBuffer(value) {
	      return Type.isObjectLike(value) && getTag(value) === '[object ArrayBuffer]';
	    }
	    /**
	     * Checks that value is typed array
	     * @param value
	     * @return {boolean}
	     */

	  }, {
	    key: "isTypedArray",
	    value: function isTypedArray(value) {
	      var regExpTypedTag = /^\[object (?:Float(?:32|64)|(?:Int|Uint)(?:8|16|32)|Uint8Clamped)]$/;
	      return Type.isObjectLike(value) && regExpTypedTag.test(getTag(value));
	    }
	    /**
	     * Checks that value is Blob
	     * @param value
	     * @return {boolean}
	     */

	  }, {
	    key: "isBlob",
	    value: function isBlob(value) {
	      return Type.isObjectLike(value) && Type.isNumber(value.size) && Type.isString(value.type) && Type.isFunction(value.slice);
	    }
	    /**
	     * Checks that value is File
	     * @param value
	     * @return {boolean}
	     */

	  }, {
	    key: "isFile",
	    value: function isFile(value) {
	      return Type.isBlob(value) && Type.isString(value.name) && (Type.isNumber(value.lastModified) || Type.isObjectLike(value.lastModifiedDate));
	    }
	    /**
	     * Checks that value is FormData
	     * @param value
	     * @return {boolean}
	     */

	  }, {
	    key: "isFormData",
	    value: function isFormData(value) {
	      return value instanceof FormData;
	    }
	  }]);
	  return Type;
	}();

	/**
	 * @memberOf BX
	 */

	var Reflection = /*#__PURE__*/function () {
	  function Reflection() {
	    babelHelpers.classCallCheck(this, Reflection);
	  }

	  babelHelpers.createClass(Reflection, null, [{
	    key: "getClass",

	    /**
	     * Gets link to function by function name
	     * @param className
	     * @return {?Function}
	     */
	    value: function getClass(className) {
	      if (Type.isString(className) && !!className) {
	        var classFn = null;
	        var currentNamespace = window;
	        var namespaces = className.split('.');

	        for (var i = 0; i < namespaces.length; i += 1) {
	          var namespace = namespaces[i];

	          if (!currentNamespace[namespace]) {
	            return null;
	          }

	          currentNamespace = currentNamespace[namespace];
	          classFn = currentNamespace;
	        }

	        return classFn;
	      }

	      if (Type.isFunction(className)) {
	        return className;
	      }

	      return null;
	    }
	    /**
	     * Creates a namespace or returns a link to a previously created one
	     * @param {String} namespaceName
	     * @return {Object<string, any> | Function | null}
	     */

	  }, {
	    key: "namespace",
	    value: function namespace(namespaceName) {
	      var parts = namespaceName.split('.');
	      var parent = window.BX;

	      if (parts[0] === 'BX') {
	        parts = parts.slice(1);
	      }

	      for (var i = 0; i < parts.length; i += 1) {
	        if (Type.isUndefined(parent[parts[i]])) {
	          parent[parts[i]] = {};
	        }

	        parent = parent[parts[i]];
	      }

	      return parent;
	    }
	  }]);
	  return Reflection;
	}();

	var reEscape = /[&<>'"]/g;
	var reUnescape = /&(?:amp|#38|lt|#60|gt|#62|apos|#39|quot|#34);/g;
	var escapeEntities = {
	  '&': '&amp;',
	  '<': '&lt;',
	  '>': '&gt;',
	  "'": '&#39;',
	  '"': '&quot;'
	};
	var unescapeEntities = {
	  '&amp;': '&',
	  '&#38;': '&',
	  '&lt;': '<',
	  '&#60;': '<',
	  '&gt;': '>',
	  '&#62;': '>',
	  '&apos;': "'",
	  '&#39;': "'",
	  '&quot;': '"',
	  '&#34;': '"'
	};
	/**
	 * @memberOf BX
	 */

	var Text = /*#__PURE__*/function () {
	  function Text() {
	    babelHelpers.classCallCheck(this, Text);
	  }

	  babelHelpers.createClass(Text, null, [{
	    key: "encode",

	    /**
	     * Encodes all unsafe entities
	     * @param {string} value
	     * @return {string}
	     */
	    value: function encode(value) {
	      if (Type.isString(value)) {
	        return value.replace(reEscape, function (item) {
	          return escapeEntities[item];
	        });
	      }

	      return value;
	    }
	    /**
	     * Decodes all encoded entities
	     * @param {string} value
	     * @return {string}
	     */

	  }, {
	    key: "decode",
	    value: function decode(value) {
	      if (Type.isString(value)) {
	        return value.replace(reUnescape, function (item) {
	          return unescapeEntities[item];
	        });
	      }

	      return value;
	    }
	  }, {
	    key: "getRandom",
	    value: function getRandom() {
	      var length = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 8;
	      // eslint-disable-next-line
	      return babelHelpers.toConsumableArray(Array(length)).map(function () {
	        return (~~(Math.random() * 36)).toString(36);
	      }).join('');
	    }
	  }, {
	    key: "toNumber",
	    value: function toNumber(value) {
	      var parsedValue = Number.parseFloat(value);

	      if (Type.isNumber(parsedValue)) {
	        return parsedValue;
	      }

	      return 0;
	    }
	  }, {
	    key: "toInteger",
	    value: function toInteger(value) {
	      return Text.toNumber(Number.parseInt(value, 10));
	    }
	  }, {
	    key: "toBoolean",
	    value: function toBoolean(value) {
	      var trueValues = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
	      var transformedValue = Type.isString(value) ? value.toLowerCase() : value;
	      return ['true', 'y', '1', 1, true].concat(babelHelpers.toConsumableArray(trueValues)).includes(transformedValue);
	    }
	  }, {
	    key: "toCamelCase",
	    value: function toCamelCase(str) {
	      if (!Type.isStringFilled(str)) {
	        return str;
	      }

	      var regex = /[-_\s]+(.)?/g;

	      if (!regex.test(str)) {
	        return str.match(/^[A-Z]+$/) ? str.toLowerCase() : str[0].toLowerCase() + str.slice(1);
	      }

	      str = str.toLowerCase();
	      str = str.replace(regex, function (match, letter) {
	        return letter ? letter.toUpperCase() : '';
	      });
	      return str[0].toLowerCase() + str.substr(1);
	    }
	  }, {
	    key: "toPascalCase",
	    value: function toPascalCase(str) {
	      if (!Type.isStringFilled(str)) {
	        return str;
	      }

	      return this.capitalize(this.toCamelCase(str));
	    }
	  }, {
	    key: "toKebabCase",
	    value: function toKebabCase(str) {
	      if (!Type.isStringFilled(str)) {
	        return str;
	      }

	      var matches = str.match(/[A-Z]{2,}(?=[A-Z][a-z]+[0-9]*|\b)|[A-Z]?[a-z]+[0-9]*|[A-Z]|[0-9]+/g);

	      if (!matches) {
	        return str;
	      }

	      return matches.map(function (x) {
	        return x.toLowerCase();
	      }).join('-');
	    }
	  }, {
	    key: "capitalize",
	    value: function capitalize(str) {
	      if (!Type.isStringFilled(str)) {
	        return str;
	      }

	      return str[0].toUpperCase() + str.substr(1);
	    }
	  }]);
	  return Text;
	}();

	var aliases = {
	  mousewheel: ['DOMMouseScroll'],
	  bxchange: ['change', 'cut', 'paste', 'drop', 'keyup'],
	  animationend: ['animationend', 'oAnimationEnd', 'webkitAnimationEnd', 'MSAnimationEnd'],
	  transitionend: ['webkitTransitionEnd', 'otransitionend', 'oTransitionEnd', 'msTransitionEnd', 'transitionend'],
	  fullscreenchange: ['fullscreenchange', 'webkitfullscreenchange', 'mozfullscreenchange', 'MSFullscreenChange'],
	  fullscreenerror: ['fullscreenerror', 'webkitfullscreenerror', 'mozfullscreenerror', 'MSFullscreenError']
	};

	var Registry = /*#__PURE__*/function () {
	  function Registry() {
	    babelHelpers.classCallCheck(this, Registry);
	    babelHelpers.defineProperty(this, "registry", new WeakMap());
	  }

	  babelHelpers.createClass(Registry, [{
	    key: "set",
	    value: function set(target, event, listener) {
	      var events = this.get(target);

	      if (!Type.isSet(events[event])) {
	        events[event] = new Set();
	      }

	      events[event].add(listener);
	      this.registry.set(target, events);
	    }
	  }, {
	    key: "get",
	    value: function get(target) {
	      return this.registry.get(target) || {};
	    }
	  }, {
	    key: "has",
	    value: function has(target, event, listener) {
	      if (event && listener) {
	        return this.registry.has(target) && this.registry.get(target)[event].has(listener);
	      }

	      return this.registry.has(target);
	    }
	  }, {
	    key: "delete",
	    value: function _delete(target, event, listener) {
	      if (!Type.isDomNode(target)) {
	        return;
	      }

	      if (Type.isString(event) && Type.isFunction(listener)) {
	        var events = this.registry.get(target);

	        if (Type.isPlainObject(events) && Type.isSet(events[event])) {
	          events[event].delete(listener);
	        }

	        return;
	      }

	      if (Type.isString(event)) {
	        var _events = this.registry.get(target);

	        if (Type.isPlainObject(_events) && Type.isSet(_events[event])) {
	          _events[event] = new Set();
	        }

	        return;
	      }

	      this.registry.delete(target);
	    }
	  }]);
	  return Registry;
	}();
	var registry = new Registry();

	function isOptionSupported(name) {
	  var isSupported = false;

	  try {
	    var options = Object.defineProperty({}, name, {
	      get: function get() {
	        isSupported = true;
	        return undefined;
	      }
	    });
	    window.addEventListener('test', null, options);
	  } // eslint-disable-next-line
	  catch (err) {}

	  return isSupported;
	}

	function fetchSupportedListenerOptions(options) {
	  if (!Type.isPlainObject(options)) {
	    return options;
	  }

	  return Object.keys(options).reduce(function (acc, name) {
	    if (isOptionSupported(name)) {
	      acc[name] = options[name];
	    }

	    return acc;
	  }, {});
	}

	function bind(target, eventName, handler, options) {
	  if (!Type.isObject(target) || !Type.isFunction(target.addEventListener)) {
	    return;
	  }

	  var listenerOptions = fetchSupportedListenerOptions(options);

	  if (eventName in aliases) {
	    aliases[eventName].forEach(function (key) {
	      target.addEventListener(key, handler, listenerOptions);
	      registry.set(target, eventName, handler);
	    });
	    return;
	  }

	  target.addEventListener(eventName, handler, listenerOptions);
	  registry.set(target, eventName, handler);
	}

	function unbind(target, eventName, handler, options) {
	  if (!Type.isObject(target) || !Type.isFunction(target.removeEventListener)) {
	    return;
	  }

	  var listenerOptions = fetchSupportedListenerOptions(options);

	  if (eventName in aliases) {
	    aliases[eventName].forEach(function (key) {
	      target.removeEventListener(key, handler, listenerOptions);
	      registry.delete(target, key, handler);
	    });
	    return;
	  }

	  target.removeEventListener(eventName, handler, listenerOptions);
	  registry.delete(target, eventName, handler);
	}

	function unbindAll(target, eventName) {
	  var events = registry.get(target);
	  Object.keys(events).forEach(function (currentEvent) {
	    events[currentEvent].forEach(function (handler) {
	      if (!Type.isString(eventName) || eventName === currentEvent) {
	        unbind(target, currentEvent, handler);
	      }
	    });
	  });
	}

	function bindOnce(target, eventName, handler, options) {
	  var once = function once() {
	    unbind(target, eventName, once, options);
	    handler.apply(void 0, arguments);
	  };

	  bind(target, eventName, once, options);
	}

	var debugState = true;
	function enableDebug() {
	  debugState = true;
	}
	function disableDebug() {
	  debugState = false;
	}
	function isDebugEnabled() {
	  return debugState;
	}
	function debug() {
	  if (isDebugEnabled() && Type.isObject(window.console)) {
	    if (Type.isFunction(window.console.log)) {
	      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
	        args[_key] = arguments[_key];
	      }

	      window.console.log('BX.debug: ', args.length > 0 ? args : args[0]);

	      if (args[0] instanceof Error && args[0].stack) {
	        window.console.log('BX.debug error stack trace', args[0].stack);
	      }
	    }

	    if (Type.isFunction(window.console.trace)) {
	      // eslint-disable-next-line
	      console.trace();
	    }
	  }
	}

	function fetchExtensionSettings(html) {
	  if (Type.isStringFilled(html)) {
	    var scripts = html.match(/<script type="extension\/settings" \b[^>]*>([\s\S]*?)<\/script>/g);

	    if (Type.isArrayFilled(scripts)) {
	      return scripts.map(function (script) {
	        var _script$match = script.match(/data-extension="(.[a-z0-9_.-]+)"/),
	            _script$match2 = babelHelpers.slicedToArray(_script$match, 2),
	            extension = _script$match2[1];

	        return {
	          extension: extension,
	          script: script
	        };
	      });
	    }
	  }

	  return [];
	}

	var Extension = /*#__PURE__*/function () {
	  function Extension(options) {
	    babelHelpers.classCallCheck(this, Extension);
	    this.config = options.config || {};
	    this.name = options.extension;
	    this.state = 'scheduled'; // eslint-disable-next-line

	    var result = BX.processHTML(options.html || '');
	    this.inlineScripts = result.SCRIPT.reduce(inlineScripts, []);
	    this.externalScripts = result.SCRIPT.reduce(externalScripts, []);
	    this.externalStyles = result.STYLE.reduce(externalStyles, []);
	    this.settingsScripts = fetchExtensionSettings(result.HTML);
	  }

	  babelHelpers.createClass(Extension, [{
	    key: "load",
	    value: function load() {
	      var _this = this;

	      if (this.state === 'error') {
	        this.loadPromise = this.loadPromise || Promise.resolve(this);
	        console.warn('Extension', this.name, 'not found');
	      }

	      if (!this.loadPromise && this.state) {
	        this.state = 'load';
	        this.settingsScripts.forEach(function (entry) {
	          var isLoaded = !!document.querySelector("script[data-extension=\"".concat(entry.extension, "\"]"));

	          if (!isLoaded) {
	            document.body.insertAdjacentHTML('beforeend', entry.script);
	          }
	        });
	        this.inlineScripts.forEach(BX.evalGlobal);
	        this.loadPromise = Promise.all([loadAll(this.externalScripts), loadAll(this.externalStyles)]).then(function () {
	          _this.state = 'loaded';

	          if (Type.isPlainObject(_this.config) && _this.config.namespace) {
	            return Reflection.getClass(_this.config.namespace);
	          }

	          return window;
	        });
	      }

	      return this.loadPromise;
	    }
	  }]);
	  return Extension;
	}();

	var initialized = {};
	var ajaxController = 'main.bitrix.main.controller.loadext.getextensions';

	function makeIterable(value) {
	  return Type.isArray(value) ? value : [value];
	}
	function isInitialized(extension) {
	  return extension in initialized;
	}
	function getInitialized(extension) {
	  return initialized[extension];
	}
	function isAllInitialized(extensions) {
	  return extensions.every(isInitialized);
	}
	function loadExtensions(extensions) {
	  return Promise.all(extensions.map(function (item) {
	    return item.load();
	  }));
	}
	function mergeExports(exports) {
	  return exports.reduce(function (acc, currentExports) {
	    if (Type.isObject(currentExports)) {
	      return babelHelpers.objectSpread({}, currentExports);
	    }

	    return currentExports;
	  }, {});
	}
	function inlineScripts(acc, item) {
	  if (item.isInternal) {
	    acc.push(item.JS);
	  }

	  return acc;
	}
	function externalScripts(acc, item) {
	  if (!item.isInternal) {
	    acc.push(item.JS);
	  }

	  return acc;
	}
	function externalStyles(acc, item) {
	  if (Type.isString(item) && item !== '') {
	    acc.push(item);
	  }

	  return acc;
	}
	function request(options) {
	  return new Promise(function (resolve) {
	    // eslint-disable-next-line
	    BX.ajax.runAction(ajaxController, {
	      data: options
	    }).then(resolve);
	  });
	}
	function prepareExtensions(response) {
	  if (response.status !== 'success') {
	    response.errors.map(console.warn);
	    return [];
	  }

	  return response.data.map(function (item) {
	    var initializedExtension = getInitialized(item.extension);

	    if (initializedExtension) {
	      return initializedExtension;
	    }

	    initialized[item.extension] = new Extension(item);
	    return initialized[item.extension];
	  });
	}
	function loadAll(items) {
	  var itemsList = makeIterable(items);

	  if (!itemsList.length) {
	    return Promise.resolve();
	  }

	  return new Promise(function (resolve) {
	    // eslint-disable-next-line
	    BX.load(itemsList, resolve);
	  });
	}

	/**
	 * Loads extensions asynchronously
	 * @param {string|Array<string>} extension
	 * @return {Promise<Array<Extension>>}
	 */
	function loadExtension(extension) {
	  var extensions = makeIterable(extension);
	  var isAllInitialized$$1 = isAllInitialized(extensions);

	  if (isAllInitialized$$1) {
	    var initializedExtensions = extensions.map(getInitialized);
	    return loadExtensions(initializedExtensions).then(mergeExports);
	  }

	  return request({
	    extension: extensions
	  }).then(prepareExtensions).then(loadExtensions).then(mergeExports);
	}

	var cloneableTags = ['[object Object]', '[object Array]', '[object RegExp]', '[object Arguments]', '[object Date]', '[object Error]', '[object Map]', '[object Set]', '[object ArrayBuffer]', '[object DataView]', '[object Float32Array]', '[object Float64Array]', '[object Int8Array]', '[object Int16Array]', '[object Int32Array]', '[object Uint8Array]', '[object Uint16Array]', '[object Uint32Array]', '[object Uint8ClampedArray]'];

	function isCloneable(value) {
	  var isCloneableValue = Type.isObjectLike(value) && cloneableTags.includes(getTag(value));
	  return isCloneableValue || Type.isDomNode(value);
	}

	function internalClone(value, map) {
	  if (map.has(value)) {
	    return map.get(value);
	  }

	  if (isCloneable(value)) {
	    if (Type.isArray(value)) {
	      var cloned = Array.from(value);
	      map.set(value, cloned);
	      value.forEach(function (item, index) {
	        cloned[index] = internalClone(item, map);
	      });
	      return map.get(value);
	    }

	    if (Type.isDomNode(value)) {
	      return value.cloneNode(true);
	    }

	    if (Type.isMap(value)) {
	      var _result = new Map();

	      map.set(value, _result);
	      value.forEach(function (item, key) {
	        _result.set(internalClone(key, map), internalClone(item, map));
	      });
	      return _result;
	    }

	    if (Type.isSet(value)) {
	      var _result2 = new Set();

	      map.set(value, _result2);
	      value.forEach(function (item) {
	        _result2.add(internalClone(item, map));
	      });
	      return _result2;
	    }

	    if (Type.isDate(value)) {
	      return new Date(value);
	    }

	    if (Type.isRegExp(value)) {
	      var regExpFlags = /\w*$/;
	      var flags = regExpFlags.exec(value);

	      var _result3 = new RegExp(value.source);

	      if (flags && Type.isArray(flags)) {
	        _result3 = new RegExp(value.source, flags[0]);
	      }

	      _result3.lastIndex = value.lastIndex;
	      return _result3;
	    }

	    var proto = Object.getPrototypeOf(value);
	    var result = Object.assign(Object.create(proto), value);
	    map.set(value, result);
	    Object.keys(value).forEach(function (key) {
	      result[key] = internalClone(value[key], map);
	    });
	    return result;
	  }

	  return value;
	}
	/**
	 * Clones any cloneable object
	 * @param value
	 * @return {*}
	 */

	function clone(value) {
	  return internalClone(value, new WeakMap());
	}

	function merge(current, target) {
	  return Object.entries(target).reduce(function (acc, _ref) {
	    var _ref2 = babelHelpers.slicedToArray(_ref, 2),
	        key = _ref2[0],
	        value = _ref2[1];

	    if (!Type.isDomNode(acc[key]) && Type.isObjectLike(acc[key]) && Type.isObjectLike(value)) {
	      acc[key] = merge(acc[key], value);
	      return acc;
	    }

	    acc[key] = value;
	    return acc;
	  }, current);
	}

	function createComparator(fields) {
	  var orders = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
	  return function (a, b) {
	    var field = fields[0];
	    var order = orders[0] || 'asc';

	    if (Type.isUndefined(field)) {
	      return 0;
	    }

	    var valueA = a[field];
	    var valueB = b[field];

	    if (Type.isString(valueA) && Type.isString(valueB)) {
	      valueA = valueA.toLowerCase();
	      valueB = valueB.toLowerCase();
	    }

	    if (valueA < valueB) {
	      return order === 'asc' ? -1 : 1;
	    }

	    if (valueA > valueB) {
	      return order === 'asc' ? 1 : -1;
	    }

	    return createComparator(fields.slice(1), orders.slice(1))(a, b);
	  };
	}

	/**
	 * @memberOf BX
	 */

	var Runtime = /*#__PURE__*/function () {
	  function Runtime() {
	    babelHelpers.classCallCheck(this, Runtime);
	  }

	  babelHelpers.createClass(Runtime, null, [{
	    key: "debounce",
	    value: function debounce(func) {
	      var wait = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
	      var context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
	      var timeoutId;
	      return function debounced() {
	        var _this = this;

	        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
	          args[_key] = arguments[_key];
	        }

	        if (Type.isNumber(timeoutId)) {
	          clearTimeout(timeoutId);
	        }

	        timeoutId = setTimeout(function () {
	          func.apply(context || _this, args);
	        }, wait);
	      };
	    }
	  }, {
	    key: "throttle",
	    value: function throttle(func) {
	      var wait = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
	      var context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
	      var timer = 0;
	      var invoke;
	      return function wrapper() {
	        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
	          args[_key2] = arguments[_key2];
	        }

	        invoke = true;

	        if (!timer) {
	          var q = function q() {
	            if (invoke) {
	              func.apply(context || this, args);
	              invoke = false;
	              timer = setTimeout(q, wait);
	            } else {
	              timer = null;
	            }
	          };

	          q();
	        }
	      };
	    }
	  }, {
	    key: "html",
	    value: function html(node, _html) {
	      var params = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

	      if (Type.isNil(_html) && Type.isDomNode(node)) {
	        return node.innerHTML;
	      } // eslint-disable-next-line


	      var parsedHtml = BX.processHTML(_html);
	      var externalCss = parsedHtml.STYLE.reduce(externalStyles, []);
	      var externalJs = parsedHtml.SCRIPT.reduce(externalScripts, []);
	      var inlineJs = parsedHtml.SCRIPT.reduce(inlineScripts, []);

	      if (Type.isDomNode(node)) {
	        if (params.htmlFirst || !externalJs.length && !externalCss.length) {
	          if (params.useAdjacentHTML) {
	            node.insertAdjacentHTML('beforeend', parsedHtml.HTML);
	          } else {
	            node.innerHTML = parsedHtml.HTML;
	          }
	        }
	      }

	      return Promise.all([loadAll(externalJs), loadAll(externalCss)]).then(function () {
	        if (Type.isDomNode(node) && (externalJs.length > 0 || externalCss.length > 0)) {
	          if (params.useAdjacentHTML) {
	            node.insertAdjacentHTML('beforeend', parsedHtml.HTML);
	          } else {
	            node.innerHTML = parsedHtml.HTML;
	          }
	        } // eslint-disable-next-line


	        inlineJs.forEach(function (script) {
	          return BX.evalGlobal(script);
	        });

	        if (Type.isFunction(params.callback)) {
	          params.callback();
	        }
	      });
	    }
	    /**
	     * Merges objects or arrays
	     * @param targets
	     * @return {any}
	     */

	  }, {
	    key: "merge",
	    value: function merge$$1() {
	      for (var _len3 = arguments.length, targets = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
	        targets[_key3] = arguments[_key3];
	      }

	      if (Type.isArray(targets[0])) {
	        targets.unshift([]);
	      } else if (Type.isObject(targets[0])) {
	        targets.unshift({});
	      }

	      return targets.reduce(function (acc, item) {
	        return merge(acc, item);
	      }, targets[0]);
	    }
	  }, {
	    key: "orderBy",
	    value: function orderBy(collection) {
	      var fields = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
	      var orders = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
	      var comparator = createComparator(fields, orders);
	      return Object.values(collection).sort(comparator);
	    }
	  }, {
	    key: "destroy",
	    value: function destroy(target) {
	      var errorMessage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'Object is destroyed';

	      if (Type.isObject(target)) {
	        var onPropertyAccess = function onPropertyAccess() {
	          throw new Error(errorMessage);
	        };

	        var ownProperties = Object.keys(target);

	        var prototypeProperties = function () {
	          var targetPrototype = Object.getPrototypeOf(target);

	          if (Type.isObject(targetPrototype)) {
	            return Object.getOwnPropertyNames(targetPrototype);
	          }

	          return [];
	        }();

	        var uniquePropertiesList = babelHelpers.toConsumableArray(new Set([].concat(babelHelpers.toConsumableArray(ownProperties), babelHelpers.toConsumableArray(prototypeProperties))));
	        uniquePropertiesList.filter(function (name) {
	          var descriptor = Object.getOwnPropertyDescriptor(target, name);
	          return !/__(.+)__/.test(name) && (!Type.isObject(descriptor) || descriptor.configurable === true);
	        }).forEach(function (name) {
	          Object.defineProperty(target, name, {
	            get: onPropertyAccess,
	            set: onPropertyAccess,
	            configurable: false
	          });
	        });
	        Object.setPrototypeOf(target, null);
	      }
	    }
	  }]);
	  return Runtime;
	}();

	babelHelpers.defineProperty(Runtime, "debug", debug);
	babelHelpers.defineProperty(Runtime, "loadExtension", loadExtension);
	babelHelpers.defineProperty(Runtime, "clone", clone);

	var _isError = Symbol.for('BX.BaseError.isError');
	/**
	 * @memberOf BX
	 */


	var BaseError = /*#__PURE__*/function () {
	  function BaseError(message, code, customData) {
	    babelHelpers.classCallCheck(this, BaseError);
	    this[_isError] = true;
	    this.message = '';
	    this.code = null;
	    this.customData = null;
	    this.setMessage(message);
	    this.setCode(code);
	    this.setCustomData(customData);
	  }
	  /**
	   * Returns a brief description of the error
	   * @returns {string}
	   */


	  babelHelpers.createClass(BaseError, [{
	    key: "getMessage",
	    value: function getMessage() {
	      return this.message;
	    }
	    /**
	     * Sets a message of the error
	     * @param {string} message
	     * @returns {this}
	     */

	  }, {
	    key: "setMessage",
	    value: function setMessage(message) {
	      if (Type.isString(message)) {
	        this.message = message;
	      }

	      return this;
	    }
	    /**
	     * Returns a code of the error
	     * @returns {?string}
	     */

	  }, {
	    key: "getCode",
	    value: function getCode() {
	      return this.code;
	    }
	    /**
	     * Sets a code of the error
	     * @param {string} code
	     * @returns {this}
	     */

	  }, {
	    key: "setCode",
	    value: function setCode(code) {
	      if (Type.isStringFilled(code) || code === null) {
	        this.code = code;
	      }

	      return this;
	    }
	    /**
	     * Returns custom data of the error
	     * @returns {null|*}
	     */

	  }, {
	    key: "getCustomData",
	    value: function getCustomData() {
	      return this.customData;
	    }
	    /**
	     * Sets custom data of the error
	     * @returns {this}
	     */

	  }, {
	    key: "setCustomData",
	    value: function setCustomData(customData) {
	      if (!Type.isUndefined(customData)) {
	        this.customData = customData;
	      }

	      return this;
	    }
	  }, {
	    key: "toString",
	    value: function toString() {
	      var code = this.getCode();
	      var message = this.getMessage();

	      if (!Type.isStringFilled(code) && !Type.isStringFilled(message)) {
	        return '';
	      } else if (!Type.isStringFilled(code)) {
	        return "Error: ".concat(message);
	      } else if (!Type.isStringFilled(message)) {
	        return code;
	      } else {
	        return "".concat(code, ": ").concat(message);
	      }
	    }
	    /**
	     * Returns true if the object is an instance of BaseError
	     * @param error
	     * @returns {boolean}
	     */

	  }], [{
	    key: "isError",
	    value: function isError(error) {
	      return Type.isObject(error) && error[_isError] === true;
	    }
	  }]);
	  return BaseError;
	}();

	/**
	 * Implements base event object interface
	 */

	var BaseEvent = /*#__PURE__*/function () {
	  function BaseEvent() {
	    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
	      data: {}
	    };
	    babelHelpers.classCallCheck(this, BaseEvent);
	    this.type = '';
	    this.data = null;
	    this.target = null;
	    this.compatData = null;
	    this.defaultPrevented = false;
	    this.immediatePropagationStopped = false;
	    this.errors = [];
	    this.setData(options.data);
	    this.setCompatData(options.compatData);
	  }

	  babelHelpers.createClass(BaseEvent, [{
	    key: "getType",

	    /**
	     * Returns the name of the event
	     * @returns {string}
	     */
	    value: function getType() {
	      return this.type;
	    }
	    /**
	     *
	     * @param {string} type
	     */

	  }, {
	    key: "setType",
	    value: function setType(type) {
	      if (Type.isStringFilled(type)) {
	        this.type = type;
	      }

	      return this;
	    }
	    /**
	     * Returns an event data
	     */

	  }, {
	    key: "getData",
	    value: function getData() {
	      return this.data;
	    }
	    /**
	     * Sets an event data
	     * @param data
	     */

	  }, {
	    key: "setData",
	    value: function setData(data) {
	      if (!Type.isUndefined(data)) {
	        this.data = data;
	      }

	      return this;
	    }
	    /**
	     * Returns arguments for BX.addCustomEvent handlers (deprecated).
	     * @returns {array | null}
	     */

	  }, {
	    key: "getCompatData",
	    value: function getCompatData() {
	      return this.compatData;
	    }
	    /**
	     * Sets arguments for BX.addCustomEvent handlers (deprecated)
	     * @param data
	     */

	  }, {
	    key: "setCompatData",
	    value: function setCompatData(data) {
	      if (Type.isArrayLike(data)) {
	        this.compatData = data;
	      }

	      return this;
	    }
	    /**
	     * Sets a event target
	     * @param target
	     */

	  }, {
	    key: "setTarget",
	    value: function setTarget(target) {
	      this.target = target;
	      return this;
	    }
	    /**
	     * Returns a event target
	     */

	  }, {
	    key: "getTarget",
	    value: function getTarget() {
	      return this.target;
	    }
	    /**
	     * Returns an array of event errors
	     * @returns {[]}
	     */

	  }, {
	    key: "getErrors",
	    value: function getErrors() {
	      return this.errors;
	    }
	    /**
	     * Adds an error of the event.
	     * Event listeners can prevent emitter's default action and set the reason of this behavior.
	     * @param error
	     */

	  }, {
	    key: "setError",
	    value: function setError(error) {
	      if (BaseError.isError(error)) {
	        this.errors.push(error);
	      }
	    }
	    /**
	     * Prevents default action
	     */

	  }, {
	    key: "preventDefault",
	    value: function preventDefault() {
	      this.defaultPrevented = true;
	    }
	    /**
	     * Checks that is default action prevented
	     * @return {boolean}
	     */

	  }, {
	    key: "isDefaultPrevented",
	    value: function isDefaultPrevented() {
	      return this.defaultPrevented;
	    }
	    /**
	     * Stops event immediate propagation
	     */

	  }, {
	    key: "stopImmediatePropagation",
	    value: function stopImmediatePropagation() {
	      this.immediatePropagationStopped = true;
	    }
	    /**
	     * Checks that is immediate propagation stopped
	     * @return {boolean}
	     */

	  }, {
	    key: "isImmediatePropagationStopped",
	    value: function isImmediatePropagationStopped() {
	      return this.immediatePropagationStopped;
	    }
	  }], [{
	    key: "create",
	    value: function create(options) {
	      return new this(options);
	    }
	  }]);
	  return BaseEvent;
	}();

	var EventStore = /*#__PURE__*/function () {
	  function EventStore() {
	    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	    babelHelpers.classCallCheck(this, EventStore);
	    this.defaultMaxListeners = Type.isNumber(options.defaultMaxListeners) ? options.defaultMaxListeners : 10;
	    this.eventStore = new WeakMap();
	  }

	  babelHelpers.createClass(EventStore, [{
	    key: "add",
	    value: function add(target) {
	      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	      var record = this.getRecordScheme();

	      if (Type.isNumber(options.maxListeners)) {
	        record.maxListeners = options.maxListeners;
	      }

	      this.eventStore.set(target, record);
	      return record;
	    }
	  }, {
	    key: "get",
	    value: function get(target) {
	      return this.eventStore.get(target);
	    }
	  }, {
	    key: "getOrAdd",
	    value: function getOrAdd(target) {
	      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	      return this.get(target) || this.add(target, options);
	    }
	  }, {
	    key: "delete",
	    value: function _delete(context) {
	      this.eventStore.delete(context);
	    }
	  }, {
	    key: "getRecordScheme",
	    value: function getRecordScheme() {
	      return {
	        eventsMap: new Map(),
	        onceMap: new Map(),
	        maxListeners: this.getDefaultMaxListeners(),
	        eventsMaxListeners: new Map()
	      };
	    }
	  }, {
	    key: "getDefaultMaxListeners",
	    value: function getDefaultMaxListeners() {
	      return this.defaultMaxListeners;
	    }
	  }]);
	  return EventStore;
	}();

	var WarningStore = /*#__PURE__*/function () {
	  function WarningStore() {
	    babelHelpers.classCallCheck(this, WarningStore);
	    this.warnings = new Map();
	    this.printDelayed = Runtime.debounce(this.print.bind(this), 500);
	  }

	  babelHelpers.createClass(WarningStore, [{
	    key: "add",
	    value: function add(target, eventName, listeners) {
	      var contextWarnings = this.warnings.get(target);

	      if (!contextWarnings) {
	        contextWarnings = Object.create(null);
	        this.warnings.set(target, contextWarnings);
	      }

	      if (!contextWarnings[eventName]) {
	        contextWarnings[eventName] = {};
	      }

	      contextWarnings[eventName].size = listeners.size;

	      if (!Type.isArray(contextWarnings[eventName].errors)) {
	        contextWarnings[eventName].errors = [];
	      }

	      contextWarnings[eventName].errors.push(new Error());
	    }
	  }, {
	    key: "print",
	    value: function print() {
	      this.warnings.forEach(function (warnings) {
	        for (var eventName in warnings) {
	          console.groupCollapsed('Possible BX.Event.EventEmitter memory leak detected. ' + warnings[eventName].size + ' "' + eventName + '" listeners added. ' + 'Use emitter.setMaxListeners() to increase limit.');
	          console.dir(warnings[eventName].errors);
	          console.groupEnd();
	        }
	      });
	      this.clear();
	    }
	  }, {
	    key: "clear",
	    value: function clear() {
	      this.warnings.clear();
	    }
	  }, {
	    key: "printDelayed",
	    value: function printDelayed() {}
	  }]);
	  return WarningStore;
	}();

	var eventStore = new EventStore({
	  defaultMaxListeners: 10
	});
	var warningStore = new WarningStore();
	var aliasStore = new Map();
	var globalTarget = {
	  GLOBAL_TARGET: 'GLOBAL_TARGET' // this key only for debugging purposes

	};
	eventStore.add(globalTarget, {
	  maxListeners: 25
	});
	var isEmitterProperty = Symbol.for('BX.Event.EventEmitter.isEmitter');
	var namespaceProperty = Symbol('namespaceProperty');
	var targetProperty = Symbol('targetProperty');

	var EventEmitter = /*#__PURE__*/function () {
	  /** @private */
	  function EventEmitter() {
	    babelHelpers.classCallCheck(this, EventEmitter);
	    this[targetProperty] = null;
	    this[namespaceProperty] = null;
	    this[isEmitterProperty] = true;
	    var target = this;

	    if (Object.getPrototypeOf(this) === EventEmitter.prototype && arguments.length > 0) //new EventEmitter(obj) case
	      {
	        if (!Type.isObject(arguments.length <= 0 ? undefined : arguments[0])) {
	          throw new TypeError("The \"target\" argument must be an object.");
	        }

	        target = arguments.length <= 0 ? undefined : arguments[0];
	        this.setEventNamespace(arguments.length <= 1 ? undefined : arguments[1]);
	      }

	    this[targetProperty] = target;
	  }
	  /**
	   * Makes a target observable
	   * @param {object} target
	   * @param {string} namespace
	   */


	  babelHelpers.createClass(EventEmitter, [{
	    key: "setEventNamespace",
	    value: function setEventNamespace(namespace) {
	      if (Type.isStringFilled(namespace)) {
	        this[namespaceProperty] = namespace;
	      }
	    }
	  }, {
	    key: "getEventNamespace",
	    value: function getEventNamespace() {
	      return this[namespaceProperty];
	    }
	    /**
	     * Subscribes listener on specified global event
	     * @param {object} target
	     * @param {string} eventName
	     * @param {Function<BaseEvent>} listener
	     * @param {object} options
	     */

	  }, {
	    key: "subscribe",

	    /**
	     * Subscribes a listener on a specified event
	     * @param {string} eventName
	     * @param {Function<BaseEvent>} listener
	     * @return {this}
	     */
	    value: function subscribe(eventName, listener) {
	      EventEmitter.subscribe(this, eventName, listener);
	      return this;
	    }
	    /**
	     *
	     * @param {object} options
	     * @param {object} [aliases]
	     * @param {boolean} [compatMode=false]
	     */

	  }, {
	    key: "subscribeFromOptions",
	    value: function subscribeFromOptions(options, aliases, compatMode) {
	      var _this = this;

	      if (!Type.isPlainObject(options)) {
	        return;
	      }

	      aliases = Type.isPlainObject(aliases) ? EventEmitter.normalizeAliases(aliases) : {};
	      Object.keys(options).forEach(function (eventName) {
	        var listener = options[eventName];

	        if (!Type.isFunction(listener)) {
	          throw new TypeError("The \"listener\" argument must be of type Function. Received type ".concat(babelHelpers.typeof(listener), "."));
	        }

	        eventName = EventEmitter.normalizeEventName(eventName);

	        if (aliases[eventName]) {
	          var actualName = aliases[eventName].eventName;
	          EventEmitter.subscribe(_this, actualName, listener, {
	            compatMode: compatMode !== false
	          });
	        } else {
	          EventEmitter.subscribe(_this, eventName, listener, {
	            compatMode: compatMode === true
	          });
	        }
	      });
	    }
	    /**
	     * Subscribes a listener that is called at
	     * most once for a specified event.
	     * @param {object} target
	     * @param {string} eventName
	     * @param {Function<BaseEvent>} listener
	     */

	  }, {
	    key: "subscribeOnce",

	    /**
	     * Subscribes a listener that is called at most once for a specified event.
	     * @param {string} eventName
	     * @param {Function<BaseEvent>} listener
	     * @return {this}
	     */
	    value: function subscribeOnce(eventName, listener) {
	      EventEmitter.subscribeOnce(this, eventName, listener);
	      return this;
	    }
	    /**
	     * Unsubscribes an event listener
	     * @param {object} target
	     * @param {string} eventName
	     * @param {Function<BaseEvent>} listener
	     * @param options
	     */

	  }, {
	    key: "unsubscribe",

	    /**
	     * Unsubscribes an event listener
	     * @param {string} eventName
	     * @param {Function<BaseEvent>} listener
	     * @return {this}
	     */
	    value: function unsubscribe(eventName, listener) {
	      EventEmitter.unsubscribe(this, eventName, listener);
	      return this;
	    }
	    /**
	     * Unsubscribes all event listeners
	     * @param {object} target
	     * @param {string} eventName
	     * @param options
	     */

	  }, {
	    key: "unsubscribeAll",

	    /**
	     * Unsubscribes all event listeners
	     * @param {string} [eventName]
	     */
	    value: function unsubscribeAll(eventName) {
	      EventEmitter.unsubscribeAll(this, eventName);
	    }
	    /**
	     *
	     * @param {object} target
	     * @param {string} eventName
	     * @param {BaseEvent | any} event
	     * @param {object} options
	     * @returns {Array}
	     */

	  }, {
	    key: "emit",

	    /**
	     * Emits specified event with specified event object
	     * @param {string} eventName
	     * @param {BaseEvent | any} event
	     * @return {this}
	     */
	    value: function emit(eventName, event) {
	      if (this.getEventNamespace() === null) {
	        console.warn('The instance of BX.Event.EventEmitter is supposed to have an event namespace. ' + 'Use emitter.setEventNamespace() to make events more unique.');
	      }

	      EventEmitter.emit(this, eventName, event);
	      return this;
	    }
	    /**
	     * Emits global event and returns a promise that is resolved when
	     * all promise returned from event handlers are resolved,
	     * or rejected when at least one of the returned promise is rejected.
	     * Importantly. You can return any value from synchronous handlers, not just promise
	     * @param {object} target
	     * @param {string} eventName
	     * @param {BaseEvent | any} event
	     * @return {Promise<Array>}
	     */

	  }, {
	    key: "emitAsync",

	    /**
	     * Emits event and returns a promise that is resolved when
	     * all promise returned from event handlers are resolved,
	     * or rejected when at least one of the returned promise is rejected.
	     * Importantly. You can return any value from synchronous handlers, not just promise
	     * @param {string} eventName
	     * @param {BaseEvent|any} event
	     * @return {Promise<Array>}
	     */
	    value: function emitAsync(eventName, event) {
	      if (this.getEventNamespace() === null) {
	        console.warn('The instance of BX.Event.EventEmitter is supposed to have an event namespace. ' + 'Use emitter.setEventNamespace() to make events more unique.');
	      }

	      return EventEmitter.emitAsync(this, eventName, event);
	    }
	    /**
	     * @private
	     * @param {object} target
	     * @param {string} eventName
	     * @param {BaseEvent|any} event
	     * @returns {BaseEvent}
	     */

	  }, {
	    key: "setMaxListeners",

	    /**
	     * Sets max events listeners count
	     * this.setMaxListeners(10) - sets the default value for all events
	     * this.setMaxListeners("onClose", 10) sets the value for onClose event
	     * @return {this}
	     * @param args
	     */
	    value: function setMaxListeners() {
	      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
	        args[_key] = arguments[_key];
	      }

	      EventEmitter.setMaxListeners.apply(EventEmitter, [this].concat(args));
	      return this;
	    }
	    /**
	     * Returns max event listeners count
	     * @param {object} target
	     * @param {string} [eventName]
	     * @returns {number}
	     */

	  }, {
	    key: "getMaxListeners",

	    /**
	     * Returns max event listeners count
	     * @param {string} [eventName]
	     * @returns {number}
	     */
	    value: function getMaxListeners(eventName) {
	      return EventEmitter.getMaxListeners(this, eventName);
	    }
	    /**
	     * Adds or subtracts max listeners count
	     * Event.EventEmitter.addMaxListeners() - adds one max listener for all events of global target
	     * Event.EventEmitter.addMaxListeners(3) - adds three max listeners for all events of global target
	     * Event.EventEmitter.addMaxListeners(-1) - subtracts one max listener for all events of global target
	     * Event.EventEmitter.addMaxListeners('onClose') - adds one max listener for onClose event of global target
	     * Event.EventEmitter.addMaxListeners('onClose', 2) - adds two max listeners for onClose event of global target
	     * Event.EventEmitter.addMaxListeners('onClose', -1) - subtracts one max listener for onClose event of global target
	     *
	     * Event.EventEmitter.addMaxListeners(obj) - adds one max listener for all events of 'obj' target
	     * Event.EventEmitter.addMaxListeners(obj, 3) - adds three max listeners for all events of 'obj' target
	     * Event.EventEmitter.addMaxListeners(obj, -1) - subtracts one max listener for all events of 'obj' target
	     * Event.EventEmitter.addMaxListeners(obj, 'onClose') - adds one max listener for onClose event of 'obj' target
	     * Event.EventEmitter.addMaxListeners(obj, 'onClose', 2) - adds two max listeners for onClose event of 'obj' target
	     * Event.EventEmitter.addMaxListeners(obj, 'onClose', -1) - subtracts one max listener for onClose event of 'obj' target
	     * @param args
	     * @returns {number}
	     */

	  }, {
	    key: "incrementMaxListeners",

	    /**
	     * Increases max listeners count
	     * this.incrementMaxListeners() - adds one max listener for all events
	     * this.incrementMaxListeners(3) - adds three max listeners for all events
	     * this.incrementMaxListeners('onClose') - adds one max listener for onClose event
	     * this.incrementMaxListeners('onClose', 2) - adds two max listeners for onClose event
	     */
	    value: function incrementMaxListeners() {
	      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
	        args[_key2] = arguments[_key2];
	      }

	      return EventEmitter.incrementMaxListeners.apply(EventEmitter, [this].concat(args));
	    }
	    /**
	     * Decreases max listeners count
	     *
	     * Event.EventEmitter.decrementMaxListeners() - subtracts one max listener for all events of global target
	     * Event.EventEmitter.decrementMaxListeners(3) - subtracts three max listeners for all events of global target
	     * Event.EventEmitter.decrementMaxListeners('onClose') - subtracts one max listener for onClose event of global target
	     * Event.EventEmitter.decrementMaxListeners('onClose', 2) - subtracts two max listeners for onClose event of global target
	     *
	     * Event.EventEmitter.decrementMaxListeners(obj) - subtracts one max listener for all events of 'obj' target
	     * Event.EventEmitter.decrementMaxListeners(obj, 3) - subtracts three max listeners for all events of 'obj' target
	     * Event.EventEmitter.decrementMaxListeners(obj, 'onClose') - subtracts one max listener for onClose event of 'obj' target
	     * Event.EventEmitter.decrementMaxListeners(obj, 'onClose', 2) - subtracts two max listeners for onClose event of 'obj' target
	     */

	  }, {
	    key: "decrementMaxListeners",

	    /**
	     * Increases max listeners count
	     * this.decrementMaxListeners() - subtracts one max listener for all events
	     * this.decrementMaxListeners(3) - subtracts three max listeners for all events
	     * this.decrementMaxListeners('onClose') - subtracts one max listener for onClose event
	     * this.decrementMaxListeners('onClose', 2) - subtracts two max listeners for onClose event
	     */
	    value: function decrementMaxListeners() {
	      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
	        args[_key3] = arguments[_key3];
	      }

	      return EventEmitter.decrementMaxListeners.apply(EventEmitter, [this].concat(args));
	    }
	    /**
	     * @private
	     * @param {Array} args
	     * @returns Array
	     */

	  }, {
	    key: "getListeners",

	    /**
	     * Gets listeners list for specified event
	     * @param {string} eventName
	     */
	    value: function getListeners(eventName) {
	      return EventEmitter.getListeners(this, eventName);
	    }
	    /**
	     * Returns a full event name with namespace
	     * @param {string} eventName
	     * @returns {string}
	     */

	  }, {
	    key: "getFullEventName",
	    value: function getFullEventName(eventName) {
	      if (!Type.isStringFilled(eventName)) {
	        throw new TypeError("The \"eventName\" argument must be a string.");
	      }

	      return EventEmitter.makeFullEventName(this.getEventNamespace(), eventName);
	    }
	    /**
	     * Registers aliases (old event names for BX.onCustomEvent)
	     * @param aliases
	     */

	  }], [{
	    key: "makeObservable",
	    value: function makeObservable(target, namespace) {
	      if (!Type.isObject(target)) {
	        throw new TypeError('The "target" argument must be an object.');
	      }

	      if (!Type.isStringFilled(namespace)) {
	        throw new TypeError('The "namespace" must be an non-empty string.');
	      }

	      if (EventEmitter.isEventEmitter(target)) {
	        throw new TypeError('The "target" is an event emitter already.');
	      }

	      var targetProto = Object.getPrototypeOf(target);
	      var emitter = new EventEmitter();
	      emitter.setEventNamespace(namespace);
	      Object.setPrototypeOf(emitter, targetProto);
	      Object.setPrototypeOf(target, emitter);
	      Object.getOwnPropertyNames(EventEmitter.prototype).forEach(function (method) {
	        if (['constructor'].includes(method)) {
	          return;
	        }

	        emitter[method] = function () {
	          for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
	            args[_key4] = arguments[_key4];
	          }

	          return EventEmitter.prototype[method].apply(target, args);
	        };
	      });
	    }
	  }, {
	    key: "subscribe",
	    value: function subscribe(target, eventName, listener, options) {
	      if (Type.isString(target)) {
	        options = listener;
	        listener = eventName;
	        eventName = target;
	        target = this.GLOBAL_TARGET;
	      }

	      if (!Type.isObject(target)) {
	        throw new TypeError("The \"target\" argument must be an object.");
	      }

	      eventName = this.normalizeEventName(eventName);

	      if (!Type.isStringFilled(eventName)) {
	        throw new TypeError("The \"eventName\" argument must be a string.");
	      }

	      if (!Type.isFunction(listener)) {
	        throw new TypeError("The \"listener\" argument must be of type Function. Received type ".concat(babelHelpers.typeof(listener), "."));
	      }

	      options = Type.isPlainObject(options) ? options : {};
	      var fullEventName = this.resolveEventName(eventName, target, options.useGlobalNaming === true);

	      var _eventStore$getOrAdd = eventStore.getOrAdd(target),
	          eventsMap = _eventStore$getOrAdd.eventsMap,
	          onceMap = _eventStore$getOrAdd.onceMap;

	      var onceListeners = onceMap.get(fullEventName);
	      var listeners = eventsMap.get(fullEventName);

	      if (listeners && listeners.has(listener) || onceListeners && onceListeners.has(listener)) {
	        console.error("You cannot subscribe the same \"".concat(fullEventName, "\" event listener twice."));
	      } else {
	        if (listeners) {
	          listeners.set(listener, {
	            listener: listener,
	            options: options,
	            sort: this.getNextSequenceValue()
	          });
	        } else {
	          listeners = new Map([[listener, {
	            listener: listener,
	            options: options,
	            sort: this.getNextSequenceValue()
	          }]]);
	          eventsMap.set(fullEventName, listeners);
	        }
	      }

	      var maxListeners = this.getMaxListeners(target, eventName);

	      if (listeners.size > maxListeners) {
	        warningStore.add(target, fullEventName, listeners);
	        warningStore.printDelayed();
	      }
	    }
	  }, {
	    key: "subscribeOnce",
	    value: function subscribeOnce(target, eventName, listener) {
	      var _this2 = this;

	      if (Type.isString(target)) {
	        listener = eventName;
	        eventName = target;
	        target = this.GLOBAL_TARGET;
	      }

	      if (!Type.isObject(target)) {
	        throw new TypeError("The \"target\" argument must be an object.");
	      }

	      eventName = this.normalizeEventName(eventName);

	      if (!Type.isStringFilled(eventName)) {
	        throw new TypeError("The \"eventName\" argument must be a string.");
	      }

	      if (!Type.isFunction(listener)) {
	        throw new TypeError("The \"listener\" argument must be of type Function. Received type ".concat(babelHelpers.typeof(listener), "."));
	      }

	      var fullEventName = this.resolveEventName(eventName, target);

	      var _eventStore$getOrAdd2 = eventStore.getOrAdd(target),
	          eventsMap = _eventStore$getOrAdd2.eventsMap,
	          onceMap = _eventStore$getOrAdd2.onceMap;

	      var listeners = eventsMap.get(fullEventName);
	      var onceListeners = onceMap.get(fullEventName);

	      if (listeners && listeners.has(listener) || onceListeners && onceListeners.has(listener)) {
	        console.error("You cannot subscribe the same \"".concat(fullEventName, "\" event listener twice."));
	      } else {
	        var once = function once() {
	          _this2.unsubscribe(target, eventName, once);

	          onceListeners.delete(listener);
	          listener.apply(void 0, arguments);
	        };

	        if (onceListeners) {
	          onceListeners.set(listener, once);
	        } else {
	          onceListeners = new Map([[listener, once]]);
	          onceMap.set(fullEventName, onceListeners);
	        }

	        this.subscribe(target, eventName, once);
	      }
	    }
	  }, {
	    key: "unsubscribe",
	    value: function unsubscribe(target, eventName, listener, options) {
	      if (Type.isString(target)) {
	        listener = eventName;
	        eventName = target;
	        target = this.GLOBAL_TARGET;
	      }

	      eventName = this.normalizeEventName(eventName);

	      if (!Type.isStringFilled(eventName)) {
	        throw new TypeError("The \"eventName\" argument must be a string.");
	      }

	      if (!Type.isFunction(listener)) {
	        throw new TypeError("The \"listener\" argument must be of type Function. Received type ".concat(typeof event === "undefined" ? "undefined" : babelHelpers.typeof(event), "."));
	      }

	      options = Type.isPlainObject(options) ? options : {};
	      var fullEventName = this.resolveEventName(eventName, target, options.useGlobalNaming === true);
	      var targetInfo = eventStore.get(target);
	      var listeners = targetInfo && targetInfo.eventsMap.get(fullEventName);
	      var onceListeners = targetInfo && targetInfo.onceMap.get(fullEventName);

	      if (listeners) {
	        listeners.delete(listener);
	      }

	      if (onceListeners) {
	        var once = onceListeners.get(listener);

	        if (once) {
	          onceListeners.delete(listener);
	          listeners.delete(once);
	        }
	      }
	    }
	  }, {
	    key: "unsubscribeAll",
	    value: function unsubscribeAll(target, eventName, options) {
	      if (Type.isString(target)) {
	        eventName = target;
	        target = this.GLOBAL_TARGET;
	      }

	      if (Type.isStringFilled(eventName)) {
	        var targetInfo = eventStore.get(target);

	        if (targetInfo) {
	          options = Type.isPlainObject(options) ? options : {};
	          var fullEventName = this.resolveEventName(eventName, target, options.useGlobalNaming === true);
	          targetInfo.eventsMap.delete(fullEventName);
	          targetInfo.onceMap.delete(fullEventName);
	        }
	      } else if (Type.isNil(eventName)) {
	        if (target === this.GLOBAL_TARGET) {
	          console.error('You cannot unsubscribe all global listeners.');
	        } else {
	          eventStore.delete(target);
	        }
	      }
	    }
	  }, {
	    key: "emit",
	    value: function emit(target, eventName, event, options) {
	      if (Type.isString(target)) {
	        options = event;
	        event = eventName;
	        eventName = target;
	        target = this.GLOBAL_TARGET;
	      }

	      if (!Type.isObject(target)) {
	        throw new TypeError("The \"target\" argument must be an object.");
	      }

	      eventName = this.normalizeEventName(eventName);

	      if (!Type.isStringFilled(eventName)) {
	        throw new TypeError("The \"eventName\" argument must be a string.");
	      }

	      options = Type.isPlainObject(options) ? options : {};
	      var fullEventName = this.resolveEventName(eventName, target, options.useGlobalNaming === true);
	      var globalEvents = eventStore.get(this.GLOBAL_TARGET);
	      var globalListeners = globalEvents && globalEvents.eventsMap.get(fullEventName) || new Map();
	      var targetListeners = new Set();

	      if (target !== this.GLOBAL_TARGET) {
	        var targetEvents = eventStore.get(target);
	        targetListeners = targetEvents && targetEvents.eventsMap.get(fullEventName) || new Map();
	      }

	      var listeners = [].concat(babelHelpers.toConsumableArray(globalListeners.values()), babelHelpers.toConsumableArray(targetListeners.values()));
	      listeners.sort(function (a, b) {
	        return a.sort - b.sort;
	      });
	      var preparedEvent = this.prepareEvent(target, fullEventName, event);
	      var result = [];

	      for (var i = 0; i < listeners.length; i++) {
	        if (preparedEvent.isImmediatePropagationStopped()) {
	          break;
	        }

	        var _listeners$i = listeners[i],
	            listener = _listeners$i.listener,
	            listenerOptions = _listeners$i.options; //A previous listener could remove a current listener.

	        if (globalListeners.has(listener) || targetListeners.has(listener)) {
	          var listenerResult = void 0;

	          if (listenerOptions.compatMode) {
	            var params = [];
	            var compatData = preparedEvent.getCompatData();

	            if (compatData !== null) {
	              params = options.cloneData === true ? Runtime.clone(compatData) : compatData;
	            } else {
	              params = [preparedEvent];
	            }

	            var context = Type.isUndefined(options.thisArg) ? target : options.thisArg;
	            listenerResult = listener.apply(context, params);
	          } else {
	            listenerResult = Type.isUndefined(options.thisArg) ? listener(preparedEvent) : listener.call(options.thisArg, preparedEvent);
	          }

	          result.push(listenerResult);
	        }
	      }

	      return result;
	    }
	  }, {
	    key: "emitAsync",
	    value: function emitAsync(target, eventName, event) {
	      if (Type.isString(target)) {
	        event = eventName;
	        eventName = target;
	        target = this.GLOBAL_TARGET;
	      }

	      return Promise.all(this.emit(target, eventName, event));
	    }
	  }, {
	    key: "prepareEvent",
	    value: function prepareEvent(target, eventName, event) {
	      var preparedEvent = event;

	      if (!(event instanceof BaseEvent)) {
	        preparedEvent = new BaseEvent();
	        preparedEvent.setData(event);
	      }

	      preparedEvent.setTarget(this.isEventEmitter(target) ? target[targetProperty] : target);
	      preparedEvent.setType(eventName);
	      return preparedEvent;
	    }
	    /**
	     * @private
	     * @returns {number}
	     */

	  }, {
	    key: "getNextSequenceValue",
	    value: function getNextSequenceValue() {
	      return this.sequenceValue++;
	    }
	    /**
	     * Sets max global events listeners count
	     * Event.EventEmitter.setMaxListeners(10) - sets the default value for all events (global target)
	     * Event.EventEmitter.setMaxListeners("onClose", 10) - sets the value for onClose event (global target)
	     * Event.EventEmitter.setMaxListeners(obj, 10) - sets the default value for all events (obj target)
	     * Event.EventEmitter.setMaxListeners(obj, "onClose", 10); - sets the value for onClose event (obj target)
	     * @return {void}
	     * @param args
	     */

	  }, {
	    key: "setMaxListeners",
	    value: function setMaxListeners() {
	      var target = this.GLOBAL_TARGET;
	      var eventName = null;
	      var count = undefined;

	      for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
	        args[_key5] = arguments[_key5];
	      }

	      if (args.length === 1) {
	        count = args[0];
	      } else if (args.length === 2) {
	        if (Type.isString(args[0])) {
	          eventName = args[0];
	          count = args[1];
	        } else {
	          target = args[0];
	          count = args[1];
	        }
	      } else if (args.length >= 3) {
	        target = args[0];
	        eventName = args[1];
	        count = args[2];
	      }

	      if (!Type.isObject(target)) {
	        throw new TypeError("The \"target\" argument must be an object.");
	      }

	      if (eventName !== null && !Type.isStringFilled(eventName)) {
	        throw new TypeError("The \"eventName\" argument must be a string.");
	      }

	      if (!Type.isNumber(count) || count < 0) {
	        throw new TypeError("The value of \"count\" is out of range. It must be a non-negative number. Received ".concat(count, "."));
	      }

	      var targetInfo = eventStore.getOrAdd(target);

	      if (Type.isStringFilled(eventName)) {
	        var fullEventName = this.resolveEventName(eventName, target);
	        targetInfo.eventsMaxListeners.set(fullEventName, count);
	      } else {
	        targetInfo.maxListeners = count;
	      }
	    }
	  }, {
	    key: "getMaxListeners",
	    value: function getMaxListeners(target, eventName) {
	      if (Type.isString(target)) {
	        eventName = target;
	        target = this.GLOBAL_TARGET;
	      } else if (Type.isNil(target)) {
	        target = this.GLOBAL_TARGET;
	      }

	      if (!Type.isObject(target)) {
	        throw new TypeError("The \"target\" argument must be an object.");
	      }

	      var targetInfo = eventStore.get(target);

	      if (targetInfo) {
	        var maxListeners = targetInfo.maxListeners;

	        if (Type.isStringFilled(eventName)) {
	          var fullEventName = this.resolveEventName(eventName, target);
	          maxListeners = targetInfo.eventsMaxListeners.get(fullEventName) || maxListeners;
	        }

	        return maxListeners;
	      }

	      return this.DEFAULT_MAX_LISTENERS;
	    }
	  }, {
	    key: "addMaxListeners",
	    value: function addMaxListeners() {
	      var _this$destructMaxList = this.destructMaxListenersArgs.apply(this, arguments),
	          _this$destructMaxList2 = babelHelpers.slicedToArray(_this$destructMaxList, 3),
	          target = _this$destructMaxList2[0],
	          eventName = _this$destructMaxList2[1],
	          increment = _this$destructMaxList2[2];

	      var maxListeners = Math.max(this.getMaxListeners(target, eventName) + increment, 0);

	      if (Type.isStringFilled(eventName)) {
	        EventEmitter.setMaxListeners(target, eventName, maxListeners);
	      } else {
	        EventEmitter.setMaxListeners(target, maxListeners);
	      }

	      return maxListeners;
	    }
	    /**
	     * Increases max listeners count
	     *
	     * Event.EventEmitter.incrementMaxListeners() - adds one max listener for all events of global target
	     * Event.EventEmitter.incrementMaxListeners(3) - adds three max listeners for all events of global target
	     * Event.EventEmitter.incrementMaxListeners('onClose') - adds one max listener for onClose event of global target
	     * Event.EventEmitter.incrementMaxListeners('onClose', 2) - adds two max listeners for onClose event of global target
	     *
	     * Event.EventEmitter.incrementMaxListeners(obj) - adds one max listener for all events of 'obj' target
	     * Event.EventEmitter.incrementMaxListeners(obj, 3) - adds three max listeners for all events of 'obj' target
	     * Event.EventEmitter.incrementMaxListeners(obj, 'onClose') - adds one max listener for onClose event of 'obj' target
	     * Event.EventEmitter.incrementMaxListeners(obj, 'onClose', 2) - adds two max listeners for onClose event of 'obj' target
	     */

	  }, {
	    key: "incrementMaxListeners",
	    value: function incrementMaxListeners() {
	      var _this$destructMaxList3 = this.destructMaxListenersArgs.apply(this, arguments),
	          _this$destructMaxList4 = babelHelpers.slicedToArray(_this$destructMaxList3, 3),
	          target = _this$destructMaxList4[0],
	          eventName = _this$destructMaxList4[1],
	          increment = _this$destructMaxList4[2];

	      return this.addMaxListeners(target, eventName, Math.abs(increment));
	    }
	  }, {
	    key: "decrementMaxListeners",
	    value: function decrementMaxListeners() {
	      var _this$destructMaxList5 = this.destructMaxListenersArgs.apply(this, arguments),
	          _this$destructMaxList6 = babelHelpers.slicedToArray(_this$destructMaxList5, 3),
	          target = _this$destructMaxList6[0],
	          eventName = _this$destructMaxList6[1],
	          increment = _this$destructMaxList6[2];

	      return this.addMaxListeners(target, eventName, -Math.abs(increment));
	    }
	  }, {
	    key: "destructMaxListenersArgs",
	    value: function destructMaxListenersArgs() {
	      var eventName = null;
	      var increment = 1;
	      var target = this.GLOBAL_TARGET;

	      for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
	        args[_key6] = arguments[_key6];
	      }

	      if (args.length === 1) {
	        if (Type.isNumber(args[0])) {
	          increment = args[0];
	        } else if (Type.isString(args[0])) {
	          eventName = args[0];
	        } else {
	          target = args[0];
	        }
	      } else if (args.length === 2) {
	        if (Type.isString(args[0])) {
	          eventName = args[0];
	          increment = args[1];
	        } else if (Type.isString(args[1])) {
	          target = args[0];
	          eventName = args[1];
	        } else {
	          target = args[0];
	          increment = args[1];
	        }
	      } else if (args.length >= 3) {
	        target = args[0];
	        eventName = args[1];
	        increment = args[2];
	      }

	      if (!Type.isObject(target)) {
	        throw new TypeError("The \"target\" argument must be an object.");
	      }

	      if (eventName !== null && !Type.isStringFilled(eventName)) {
	        throw new TypeError("The \"eventName\" argument must be a string.");
	      }

	      if (!Type.isNumber(increment)) {
	        throw new TypeError("The value of \"increment\" must be a number.");
	      }

	      return [target, eventName, increment];
	    }
	    /**
	     * Gets listeners list for a specified event
	     * @param {object} target
	     * @param {string} eventName
	     */

	  }, {
	    key: "getListeners",
	    value: function getListeners(target, eventName) {
	      if (Type.isString(target)) {
	        eventName = target;
	        target = this.GLOBAL_TARGET;
	      }

	      if (!Type.isObject(target)) {
	        throw new TypeError("The \"target\" argument must be an object.");
	      }

	      eventName = this.normalizeEventName(eventName);

	      if (!Type.isStringFilled(eventName)) {
	        throw new TypeError("The \"eventName\" argument must be a string.");
	      }

	      var targetInfo = eventStore.get(target);

	      if (!targetInfo) {
	        return new Map();
	      }

	      var fullEventName = this.resolveEventName(eventName, target);
	      return targetInfo.eventsMap.get(fullEventName) || new Map();
	    }
	  }, {
	    key: "registerAliases",
	    value: function registerAliases(aliases) {
	      aliases = this.normalizeAliases(aliases);
	      Object.keys(aliases).forEach(function (alias) {
	        aliasStore.set(alias, {
	          eventName: aliases[alias].eventName,
	          namespace: aliases[alias].namespace
	        });
	      });
	      EventEmitter.mergeEventAliases(aliases);
	    }
	    /**
	     * @private
	     * @param aliases
	     */

	  }, {
	    key: "normalizeAliases",
	    value: function normalizeAliases(aliases) {
	      if (!Type.isPlainObject(aliases)) {
	        throw new TypeError("The \"aliases\" argument must be an object.");
	      }

	      var result = Object.create(null);

	      for (var _alias in aliases) {
	        if (!Type.isStringFilled(_alias)) {
	          throw new TypeError("The alias must be an non-empty string.");
	        }

	        var options = aliases[_alias];

	        if (!options || !Type.isStringFilled(options.eventName) || !Type.isStringFilled(options.namespace)) {
	          throw new TypeError("The alias options must set the \"eventName\" and the \"namespace\".");
	        }

	        _alias = this.normalizeEventName(_alias);
	        result[_alias] = {
	          eventName: options.eventName,
	          namespace: options.namespace
	        };
	      }

	      return result;
	    }
	    /**
	     * @private
	     */

	  }, {
	    key: "mergeEventAliases",
	    value: function mergeEventAliases(aliases) {
	      var _this3 = this;

	      var globalEvents = eventStore.get(this.GLOBAL_TARGET);

	      if (!globalEvents) {
	        return;
	      }

	      Object.keys(aliases).forEach(function (alias) {
	        var options = aliases[alias];
	        alias = _this3.normalizeEventName(alias);

	        var fullEventName = _this3.makeFullEventName(options.namespace, options.eventName);

	        var aliasListeners = globalEvents.eventsMap.get(alias);

	        if (aliasListeners) {
	          var listeners = globalEvents.eventsMap.get(fullEventName) || new Map();
	          globalEvents.eventsMap.set(fullEventName, new Map([].concat(babelHelpers.toConsumableArray(listeners), babelHelpers.toConsumableArray(aliasListeners))));
	          globalEvents.eventsMap.delete(alias);
	        }

	        var aliasOnceListeners = globalEvents.onceMap.get(alias);

	        if (aliasOnceListeners) {
	          var onceListeners = globalEvents.onceMap.get(fullEventName) || new Map();
	          globalEvents.onceMap.set(fullEventName, new Map([].concat(babelHelpers.toConsumableArray(onceListeners), babelHelpers.toConsumableArray(aliasOnceListeners))));
	          globalEvents.onceMap.delete(alias);
	        }

	        var aliasMaxListeners = globalEvents.eventsMaxListeners.get(alias);

	        if (aliasMaxListeners) {
	          var eventMaxListeners = globalEvents.eventsMaxListeners.get(fullEventName) || 0;
	          globalEvents.eventsMaxListeners.set(fullEventName, Math.max(eventMaxListeners, aliasMaxListeners));
	          globalEvents.eventsMaxListeners.delete(alias);
	        }
	      });
	    }
	    /**
	     * Returns true if the target is an instance of Event.EventEmitter
	     * @param {object} target
	     * @returns {boolean}
	     */

	  }, {
	    key: "isEventEmitter",
	    value: function isEventEmitter(target) {
	      return Type.isObject(target) && target[isEmitterProperty] === true;
	    }
	    /**
	     * @private
	     * @param {string} eventName
	     * @returns {string}
	     */

	  }, {
	    key: "normalizeEventName",
	    value: function normalizeEventName(eventName) {
	      if (!Type.isStringFilled(eventName)) {
	        return '';
	      }

	      return eventName.toLowerCase();
	    }
	    /**
	     * @private
	     * @param eventName
	     * @param target
	     * @param useGlobalNaming
	     * @returns {string}
	     */

	  }, {
	    key: "resolveEventName",
	    value: function resolveEventName(eventName, target) {
	      var useGlobalNaming = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
	      eventName = this.normalizeEventName(eventName);

	      if (!Type.isStringFilled(eventName)) {
	        return '';
	      }

	      if (this.isEventEmitter(target) && useGlobalNaming !== true) {
	        if (target.getEventNamespace() !== null && eventName.includes('.')) {
	          console.warn("Possible the wrong event name \"".concat(eventName, "\"."));
	        }

	        eventName = target.getFullEventName(eventName);
	      } else if (aliasStore.has(eventName)) {
	        var _aliasStore$get = aliasStore.get(eventName),
	            namespace = _aliasStore$get.namespace,
	            actualEventName = _aliasStore$get.eventName;

	        eventName = this.makeFullEventName(namespace, actualEventName);
	      }

	      return eventName;
	    }
	    /**
	     * @private
	     * @param {string} namespace
	     * @param {string} eventName
	     * @returns {string}
	     */

	  }, {
	    key: "makeFullEventName",
	    value: function makeFullEventName(namespace, eventName) {
	      var fullName = Type.isStringFilled(namespace) ? "".concat(namespace, ":").concat(eventName) : eventName;
	      return Type.isStringFilled(fullName) ? fullName.toLowerCase() : '';
	    }
	  }]);
	  return EventEmitter;
	}();

	babelHelpers.defineProperty(EventEmitter, "GLOBAL_TARGET", globalTarget);
	babelHelpers.defineProperty(EventEmitter, "DEFAULT_MAX_LISTENERS", eventStore.getDefaultMaxListeners());
	babelHelpers.defineProperty(EventEmitter, "sequenceValue", 1);

	var stack = [];
	/**
	 * For compatibility only
	 * @type {boolean}
	 */
	// eslint-disable-next-line

	exports.isReady = false;
	function ready(handler) {
	  switch (document.readyState) {
	    case 'loading':
	      stack.push(handler);
	      break;

	    case 'interactive':
	    case 'complete':
	      if (Type.isFunction(handler)) {
	        handler();
	      }

	      exports.isReady = true;
	      break;

	    default:
	      break;
	  }
	}
	document.addEventListener('readystatechange', function () {
	  if (!exports.isReady) {
	    stack.forEach(ready);
	    stack = [];
	  }
	});

	/**
	 * @memberOf BX
	 */

	var Event = function Event() {
	  babelHelpers.classCallCheck(this, Event);
	};

	babelHelpers.defineProperty(Event, "bind", bind);
	babelHelpers.defineProperty(Event, "bindOnce", bindOnce);
	babelHelpers.defineProperty(Event, "unbind", unbind);
	babelHelpers.defineProperty(Event, "unbindAll", unbindAll);
	babelHelpers.defineProperty(Event, "ready", ready);
	babelHelpers.defineProperty(Event, "EventEmitter", EventEmitter);
	babelHelpers.defineProperty(Event, "BaseEvent", BaseEvent);

	function encodeAttributeValue(value) {
	  if (Type.isPlainObject(value) || Type.isArray(value)) {
	    return JSON.stringify(value);
	  }

	  return Text.encode(Text.decode(value));
	}

	function decodeAttributeValue(value) {
	  if (Type.isString(value)) {
	    var decodedValue = Text.decode(value);
	    var result;

	    try {
	      result = JSON.parse(decodedValue);
	    } catch (e) {
	      result = decodedValue;
	    }

	    if (result === decodedValue) {
	      if (/^[\d.]+[.]?\d+$/.test(result)) {
	        return Number(result);
	      }
	    }

	    if (result === 'true' || result === 'false') {
	      return Boolean(result);
	    }

	    return result;
	  }

	  return value;
	}

	function getPageScroll() {
	  var _document = document,
	      documentElement = _document.documentElement,
	      body = _document.body;
	  var scrollTop = Math.max(window.pageYOffset || 0, documentElement ? documentElement.scrollTop : 0, body ? body.scrollTop : 0);
	  var scrollLeft = Math.max(window.pageXOffset || 0, documentElement ? documentElement.scrollLeft : 0, body ? body.scrollLeft : 0);
	  return {
	    scrollTop: scrollTop,
	    scrollLeft: scrollLeft
	  };
	}

	/**
	 * @memberOf BX
	 */

	var Dom = /*#__PURE__*/function () {
	  function Dom() {
	    babelHelpers.classCallCheck(this, Dom);
	  }

	  babelHelpers.createClass(Dom, null, [{
	    key: "replace",

	    /**
	     * Replaces old html element to new html element
	     * @param oldElement
	     * @param newElement
	     */
	    value: function replace(oldElement, newElement) {
	      if (Type.isDomNode(oldElement) && Type.isDomNode(newElement)) {
	        if (Type.isDomNode(oldElement.parentNode)) {
	          oldElement.parentNode.replaceChild(newElement, oldElement);
	        }
	      }
	    }
	    /**
	     * Removes element
	     * @param element
	     */

	  }, {
	    key: "remove",
	    value: function remove(element) {
	      if (Type.isDomNode(element) && Type.isDomNode(element.parentNode)) {
	        element.parentNode.removeChild(element);
	      }
	    }
	    /**
	     * Cleans element
	     * @param element
	     */

	  }, {
	    key: "clean",
	    value: function clean(element) {
	      if (Type.isDomNode(element)) {
	        while (element.childNodes.length > 0) {
	          element.removeChild(element.firstChild);
	        }

	        return;
	      }

	      if (Type.isString(element)) {
	        Dom.clean(document.getElementById(element));
	      }
	    }
	    /**
	     * Inserts element before target element
	     * @param current
	     * @param target
	     */

	  }, {
	    key: "insertBefore",
	    value: function insertBefore(current, target) {
	      if (Type.isDomNode(current) && Type.isDomNode(target)) {
	        if (Type.isDomNode(target.parentNode)) {
	          target.parentNode.insertBefore(current, target);
	        }
	      }
	    }
	    /**
	     * Inserts element after target element
	     * @param current
	     * @param target
	     */

	  }, {
	    key: "insertAfter",
	    value: function insertAfter(current, target) {
	      if (Type.isDomNode(current) && Type.isDomNode(target)) {
	        if (Type.isDomNode(target.parentNode)) {
	          var parent = target.parentNode;

	          if (Type.isDomNode(target.nextSibling)) {
	            parent.insertBefore(current, target.nextSibling);
	            return;
	          }

	          parent.appendChild(current);
	        }
	      }
	    }
	    /**
	     * Appends element to target element
	     * @param current
	     * @param target
	     */

	  }, {
	    key: "append",
	    value: function append(current, target) {
	      if (Type.isDomNode(current) && Type.isDomNode(target)) {
	        target.appendChild(current);
	      }
	    }
	    /**
	     * Prepends element to target element
	     * @param current
	     * @param target
	     */

	  }, {
	    key: "prepend",
	    value: function prepend(current, target) {
	      if (Type.isDomNode(current) && Type.isDomNode(target)) {
	        if (Type.isDomNode(target.firstChild)) {
	          target.insertBefore(current, target.firstChild);
	          return;
	        }

	        Dom.append(current, target);
	      }
	    }
	    /**
	     * Checks that element contains class name or class names
	     * @param element
	     * @param className
	     * @return {Boolean}
	     */

	  }, {
	    key: "hasClass",
	    value: function hasClass(element, className) {
	      if (Type.isElementNode(element)) {
	        if (Type.isString(className)) {
	          var preparedClassName = className.trim();

	          if (preparedClassName.length > 0) {
	            if (preparedClassName.includes(' ')) {
	              return preparedClassName.split(' ').every(function (name) {
	                return Dom.hasClass(element, name);
	              });
	            }

	            if ('classList' in element) {
	              return element.classList.contains(preparedClassName);
	            }

	            if (Type.isObject(element.className) && Type.isString(element.className.baseVal)) {
	              return element.getAttribute('class').split(' ').some(function (name) {
	                return name === preparedClassName;
	              });
	            }
	          }
	        }

	        if (Type.isArray(className) && className.length > 0) {
	          return className.every(function (name) {
	            return Dom.hasClass(element, name);
	          });
	        }
	      }

	      return false;
	    }
	    /**
	     * Adds class name
	     * @param element
	     * @param className
	     */

	  }, {
	    key: "addClass",
	    value: function addClass(element, className) {
	      if (Type.isElementNode(element)) {
	        if (Type.isString(className)) {
	          var preparedClassName = className.trim();

	          if (preparedClassName.length > 0) {
	            if (preparedClassName.includes(' ')) {
	              Dom.addClass(element, preparedClassName.split(' '));
	              return;
	            }

	            if ('classList' in element) {
	              element.classList.add(preparedClassName);
	              return;
	            }

	            if (Type.isObject(element.className) && Type.isString(element.className.baseVal)) {
	              if (element.className.baseVal === '') {
	                element.className.baseVal = preparedClassName;
	                return;
	              }

	              var names = element.className.baseVal.split(' ');

	              if (!names.includes(preparedClassName)) {
	                names.push(preparedClassName);
	                element.className.baseVal = names.join(' ').trim();
	                return;
	              }
	            }

	            return;
	          }
	        }

	        if (Type.isArray(className)) {
	          className.forEach(function (name) {
	            return Dom.addClass(element, name);
	          });
	        }
	      }
	    }
	    /**
	     * Removes class name
	     * @param element
	     * @param className
	     */

	  }, {
	    key: "removeClass",
	    value: function removeClass(element, className) {
	      if (Type.isElementNode(element)) {
	        if (Type.isString(className)) {
	          var preparedClassName = className.trim();

	          if (preparedClassName.length > 0) {
	            if (preparedClassName.includes(' ')) {
	              Dom.removeClass(element, preparedClassName.split(' '));
	              return;
	            }

	            if ('classList' in element) {
	              element.classList.remove(preparedClassName);
	              return;
	            }

	            if (Type.isObject(element.className) && Type.isString(element.className.baseVal)) {
	              var names = element.className.baseVal.split(' ').filter(function (name) {
	                return name !== preparedClassName;
	              });
	              element.className.baseVal = names.join(' ');
	              return;
	            }
	          }
	        }

	        if (Type.isArray(className)) {
	          className.forEach(function (name) {
	            return Dom.removeClass(element, name);
	          });
	        }
	      }
	    }
	    /**
	     * Toggles class name
	     * @param element
	     * @param className
	     */

	  }, {
	    key: "toggleClass",
	    value: function toggleClass(element, className) {
	      if (Type.isElementNode(element)) {
	        if (Type.isString(className)) {
	          var preparedClassName = className.trim();

	          if (preparedClassName.length > 0) {
	            if (preparedClassName.includes(' ')) {
	              Dom.toggleClass(element, preparedClassName.split(' '));
	              return;
	            }

	            element.classList.toggle(preparedClassName);
	            return;
	          }
	        }

	        if (Type.isArray(className)) {
	          className.forEach(function (name) {
	            return Dom.toggleClass(element, name);
	          });
	        }
	      }
	    }
	    /**
	     * Styles element
	     */

	  }, {
	    key: "style",
	    value: function style(element, prop, value) {
	      if (Type.isElementNode(element)) {
	        if (Type.isNull(prop)) {
	          element.removeAttribute('style');
	          return element;
	        }

	        if (Type.isPlainObject(prop)) {
	          Object.entries(prop).forEach(function (item) {
	            var _item = babelHelpers.slicedToArray(item, 2),
	                currentKey = _item[0],
	                currentValue = _item[1];

	            Dom.style(element, currentKey, currentValue);
	          });
	          return element;
	        }

	        if (Type.isString(prop)) {
	          if (Type.isUndefined(value) && element.nodeType !== Node.DOCUMENT_NODE) {
	            var computedStyle = getComputedStyle(element);

	            if (prop in computedStyle) {
	              return computedStyle[prop];
	            }

	            return computedStyle.getPropertyValue(prop);
	          }

	          if (Type.isNull(value) || value === '' || value === 'null') {
	            // eslint-disable-next-line
	            element.style[prop] = '';
	            return element;
	          }

	          if (Type.isString(value) || Type.isNumber(value)) {
	            // eslint-disable-next-line
	            element.style[prop] = value;
	            return element;
	          }
	        }
	      }

	      return null;
	    }
	    /**
	     * Adjusts element
	     * @param target
	     * @param data
	     * @return {*}
	     */

	  }, {
	    key: "adjust",
	    value: function adjust(target) {
	      var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

	      if (!target.nodeType) {
	        return null;
	      }

	      var element = target;

	      if (target.nodeType === Node.DOCUMENT_NODE) {
	        element = target.body;
	      }

	      if (Type.isPlainObject(data)) {
	        if (Type.isPlainObject(data.attrs)) {
	          Object.keys(data.attrs).forEach(function (key) {
	            if (key === 'class' || key.toLowerCase() === 'classname') {
	              element.className = data.attrs[key];
	              return;
	            } // eslint-disable-next-line


	            if (data.attrs[key] == '') {
	              element.removeAttribute(key);
	              return;
	            }

	            element.setAttribute(key, data.attrs[key]);
	          });
	        }

	        if (Type.isPlainObject(data.style)) {
	          Dom.style(element, data.style);
	        }

	        if (Type.isPlainObject(data.props)) {
	          Object.keys(data.props).forEach(function (key) {
	            element[key] = data.props[key];
	          });
	        }

	        if (Type.isPlainObject(data.events)) {
	          Object.keys(data.events).forEach(function (key) {
	            Event.bind(element, key, data.events[key]);
	          });
	        }

	        if (Type.isPlainObject(data.dataset)) {
	          Object.keys(data.dataset).forEach(function (key) {
	            element.dataset[key] = data.dataset[key];
	          });
	        }

	        if (Type.isString(data.children)) {
	          data.children = [data.children];
	        }

	        if (Type.isArray(data.children) && data.children.length > 0) {
	          data.children.forEach(function (item) {
	            if (Type.isDomNode(item)) {
	              Dom.append(item, element);
	            }

	            if (Type.isString(item)) {
	              element.innerHTML += item;
	            }
	          });
	          return element;
	        }

	        if ('text' in data && !Type.isNil(data.text)) {
	          element.innerText = data.text;
	          return element;
	        }

	        if ('html' in data && !Type.isNil(data.html)) {
	          element.innerHTML = data.html;
	        }
	      }

	      return element;
	    }
	    /**
	     * Creates element
	     * @param tag
	     * @param data
	     * @param context
	     * @return {HTMLElement|HTMLBodyElement}
	     */

	  }, {
	    key: "create",
	    value: function create(tag) {
	      var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	      var context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : document;
	      var tagName = tag;
	      var options = data;

	      if (Type.isObjectLike(tag)) {
	        options = tag;
	        tagName = tag.tag;
	      }

	      return Dom.adjust(context.createElement(tagName), options);
	    }
	    /**
	     * Shows element
	     * @param element
	     */

	  }, {
	    key: "show",
	    value: function show(element) {
	      if (Type.isDomNode(element)) {
	        // eslint-disable-next-line
	        element.hidden = false;
	      }
	    }
	    /**
	     * Hides element
	     * @param element
	     */

	  }, {
	    key: "hide",
	    value: function hide(element) {
	      if (Type.isDomNode(element)) {
	        // eslint-disable-next-line
	        element.hidden = true;
	      }
	    }
	    /**
	     * Checks that element is shown
	     * @param element
	     * @return {*|boolean}
	     */

	  }, {
	    key: "isShown",
	    value: function isShown(element) {
	      return Type.isDomNode(element) && !element.hidden && element.style.getPropertyValue('display') !== 'none';
	    }
	    /**
	     * Toggles element visibility
	     * @param element
	     */

	  }, {
	    key: "toggle",
	    value: function toggle(element) {
	      if (Type.isDomNode(element)) {
	        if (Dom.isShown(element)) {
	          Dom.hide(element);
	        } else {
	          Dom.show(element);
	        }
	      }
	    }
	    /**
	     * Gets element position relative page
	     * @param {HTMLElement} element
	     * @return {DOMRect}
	     */

	  }, {
	    key: "getPosition",
	    value: function getPosition(element) {
	      if (Type.isDomNode(element)) {
	        var elementRect = element.getBoundingClientRect();

	        var _getPageScroll = getPageScroll(),
	            scrollLeft = _getPageScroll.scrollLeft,
	            scrollTop = _getPageScroll.scrollTop;

	        return new DOMRect(elementRect.left + scrollLeft, elementRect.top + scrollTop, elementRect.width, elementRect.height);
	      }

	      return new DOMRect();
	    }
	    /**
	     * Gets element position relative specified element position
	     * @param {HTMLElement} element
	     * @param {HTMLElement} relationElement
	     * @return {DOMRect}
	     */

	  }, {
	    key: "getRelativePosition",
	    value: function getRelativePosition(element, relationElement) {
	      if (Type.isDomNode(element) && Type.isDomNode(relationElement)) {
	        var elementPosition = Dom.getPosition(element);
	        var relationElementPosition = Dom.getPosition(relationElement);
	        return new DOMRect(elementPosition.left - relationElementPosition.left, elementPosition.top - relationElementPosition.top, elementPosition.width, elementPosition.height);
	      }

	      return new DOMRect();
	    }
	  }, {
	    key: "attr",
	    value: function attr(element, _attr, value) {
	      if (Type.isElementNode(element)) {
	        if (Type.isString(_attr)) {
	          if (!Type.isNil(value)) {
	            return element.setAttribute(_attr, encodeAttributeValue(value));
	          }

	          if (Type.isNull(value)) {
	            return element.removeAttribute(_attr);
	          }

	          return decodeAttributeValue(element.getAttribute(_attr));
	        }

	        if (Type.isPlainObject(_attr)) {
	          return Object.entries(_attr).forEach(function (_ref) {
	            var _ref2 = babelHelpers.slicedToArray(_ref, 2),
	                attrKey = _ref2[0],
	                attrValue = _ref2[1];

	            Dom.attr(element, attrKey, attrValue);
	          });
	        }
	      }

	      return null;
	    }
	  }]);
	  return Dom;
	}();

	var UA = navigator.userAgent.toLowerCase();
	/**
	 * @memberOf BX
	 */

	var Browser = /*#__PURE__*/function () {
	  function Browser() {
	    babelHelpers.classCallCheck(this, Browser);
	  }

	  babelHelpers.createClass(Browser, null, [{
	    key: "isOpera",
	    value: function isOpera() {
	      return UA.includes('opera');
	    }
	  }, {
	    key: "isIE",
	    value: function isIE() {
	      return 'attachEvent' in document && !Browser.isOpera();
	    }
	  }, {
	    key: "isIE6",
	    value: function isIE6() {
	      return UA.includes('msie 6');
	    }
	  }, {
	    key: "isIE7",
	    value: function isIE7() {
	      return UA.includes('msie 7');
	    }
	  }, {
	    key: "isIE8",
	    value: function isIE8() {
	      return UA.includes('msie 8');
	    }
	  }, {
	    key: "isIE9",
	    value: function isIE9() {
	      return 'documentMode' in document && document.documentMode >= 9;
	    }
	  }, {
	    key: "isIE10",
	    value: function isIE10() {
	      return 'documentMode' in document && document.documentMode >= 10;
	    }
	  }, {
	    key: "isSafari",
	    value: function isSafari() {
	      return UA.includes('webkit');
	    }
	  }, {
	    key: "isFirefox",
	    value: function isFirefox() {
	      return UA.includes('firefox');
	    }
	  }, {
	    key: "isChrome",
	    value: function isChrome() {
	      return UA.includes('chrome');
	    }
	  }, {
	    key: "detectIEVersion",
	    value: function detectIEVersion() {
	      if (Browser.isOpera() || Browser.isSafari() || Browser.isFirefox() || Browser.isChrome()) {
	        return -1;
	      }

	      var rv = -1;

	      if (!!window.MSStream && !window.ActiveXObject && 'ActiveXObject' in window) {
	        rv = 11;
	      } else if (Browser.isIE10()) {
	        rv = 10;
	      } else if (Browser.isIE9()) {
	        rv = 9;
	      } else if (Browser.isIE()) {
	        rv = 8;
	      }

	      if (rv === -1 || rv === 8) {
	        if (navigator.appName === 'Microsoft Internet Explorer') {
	          var re = new RegExp('MSIE ([0-9]+[.0-9]*)');
	          var res = navigator.userAgent.match(re);

	          if (Type.isArrayLike(res) && res.length > 0) {
	            rv = parseFloat(res[1]);
	          }
	        }

	        if (navigator.appName === 'Netscape') {
	          // Alternative check for IE 11
	          rv = 11;

	          var _re = new RegExp('Trident/.*rv:([0-9]+[.0-9]*)');

	          if (_re.exec(navigator.userAgent) != null) {
	            var _res = navigator.userAgent.match(_re);

	            if (Type.isArrayLike(_res) && _res.length > 0) {
	              rv = parseFloat(_res[1]);
	            }
	          }
	        }
	      }

	      return rv;
	    }
	  }, {
	    key: "isIE11",
	    value: function isIE11() {
	      return Browser.detectIEVersion() >= 11;
	    }
	  }, {
	    key: "isMac",
	    value: function isMac() {
	      return UA.includes('macintosh');
	    }
	  }, {
	    key: "isWin",
	    value: function isWin() {
	      return UA.includes('windows');
	    }
	  }, {
	    key: "isLinux",
	    value: function isLinux() {
	      return UA.includes('linux') && !Browser.isAndroid();
	    }
	  }, {
	    key: "isAndroid",
	    value: function isAndroid() {
	      return UA.includes('android');
	    }
	  }, {
	    key: "isIPad",
	    value: function isIPad() {
	      return UA.includes('ipad;') || this.isMac() && this.isTouchDevice();
	    }
	  }, {
	    key: "isIPhone",
	    value: function isIPhone() {
	      return UA.includes('iphone;');
	    }
	  }, {
	    key: "isIOS",
	    value: function isIOS() {
	      return Browser.isIPad() || Browser.isIPhone();
	    }
	  }, {
	    key: "isMobile",
	    value: function isMobile() {
	      return Browser.isIPhone() || Browser.isIPad() || Browser.isAndroid() || UA.includes('mobile') || UA.includes('touch');
	    }
	  }, {
	    key: "isRetina",
	    value: function isRetina() {
	      return window.devicePixelRatio && window.devicePixelRatio >= 2;
	    }
	  }, {
	    key: "isTouchDevice",
	    value: function isTouchDevice() {
	      return 'ontouchstart' in window || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0;
	    }
	  }, {
	    key: "isDoctype",
	    value: function isDoctype(target) {
	      var doc = target || document;

	      if (doc.compatMode) {
	        return doc.compatMode === 'CSS1Compat';
	      }

	      return doc.documentElement && doc.documentElement.clientHeight;
	    }
	  }, {
	    key: "isLocalStorageSupported",
	    value: function isLocalStorageSupported() {
	      try {
	        localStorage.setItem('test', 'test');
	        localStorage.removeItem('test');
	        return true;
	      } catch (e) {
	        return false;
	      }
	    }
	  }, {
	    key: "addGlobalClass",
	    value: function addGlobalClass() {
	      var globalClass = 'bx-core';

	      if (Dom.hasClass(document.documentElement, globalClass)) {
	        return;
	      }

	      if (Browser.isIOS()) {
	        globalClass += ' bx-ios';
	      } else if (Browser.isMac()) {
	        globalClass += ' bx-mac';
	      } else if (Browser.isAndroid()) {
	        globalClass += ' bx-android';
	      }

	      globalClass += Browser.isMobile() ? ' bx-touch' : ' bx-no-touch';
	      globalClass += Browser.isRetina() ? ' bx-retina' : ' bx-no-retina';
	      var ieVersion = -1;

	      if (/AppleWebKit/.test(navigator.userAgent)) {
	        globalClass += ' bx-chrome';
	      } else if (Browser.detectIEVersion() > 0) {
	        ieVersion = Browser.detectIEVersion();
	        globalClass += " bx-ie bx-ie".concat(ieVersion);

	        if (ieVersion > 7 && ieVersion < 10 && !Browser.isDoctype()) {
	          globalClass += ' bx-quirks';
	        }
	      } else if (/Opera/.test(navigator.userAgent)) {
	        globalClass += ' bx-opera';
	      } else if (/Gecko/.test(navigator.userAgent)) {
	        globalClass += ' bx-firefox';
	      }

	      Dom.addClass(document.documentElement, globalClass);
	    }
	  }, {
	    key: "detectAndroidVersion",
	    value: function detectAndroidVersion() {
	      var re = new RegExp('Android ([0-9]+[.0-9]*)');

	      if (re.exec(navigator.userAgent) != null) {
	        var res = navigator.userAgent.match(re);

	        if (Type.isArrayLike(res) && res.length > 0) {
	          return parseFloat(res[1]);
	        }
	      }

	      return 0;
	    }
	  }, {
	    key: "isPropertySupported",
	    value: function isPropertySupported(jsProperty, returnCSSName) {
	      if (jsProperty === '') {
	        return false;
	      }

	      function getCssName(propertyName) {
	        return propertyName.replace(/([A-Z])/g, function () {
	          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
	            args[_key] = arguments[_key];
	          }

	          return "-".concat(args[1].toLowerCase());
	        });
	      }

	      function getJsName(cssName) {
	        var reg = /(\\-([a-z]))/g;

	        if (reg.test(cssName)) {
	          return cssName.replace(reg, function () {
	            for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
	              args[_key2] = arguments[_key2];
	            }

	            return args[2].toUpperCase();
	          });
	        }

	        return cssName;
	      }

	      var property = jsProperty.includes('-') ? getJsName(jsProperty) : jsProperty;
	      var bReturnCSSName = !!returnCSSName;
	      var ucProperty = property.charAt(0).toUpperCase() + property.slice(1);
	      var props = ['Webkit', 'Moz', 'O', 'ms'].join("".concat(ucProperty, " "));
	      var properties = "".concat(property, " ").concat(props, " ").concat(ucProperty).split(' ');
	      var obj = document.body || document.documentElement;

	      for (var i = 0; i < properties.length; i += 1) {
	        var prop = properties[i];

	        if (obj && 'style' in obj && prop in obj.style) {
	          var lowerProp = prop.substr(0, prop.length - property.length).toLowerCase();
	          var prefix = prop === property ? '' : "-".concat(lowerProp, "-");
	          return bReturnCSSName ? prefix + getCssName(property) : prop;
	        }
	      }

	      return false;
	    }
	  }, {
	    key: "addGlobalFeatures",
	    value: function addGlobalFeatures(features) {
	      if (!Type.isArray(features)) {
	        return;
	      }

	      var classNames = [];

	      for (var i = 0; i < features.length; i += 1) {
	        var support = !!Browser.isPropertySupported(features[i]);
	        classNames.push("bx-".concat(support ? '' : 'no-').concat(features[i].toLowerCase()));
	      }

	      Dom.addClass(document.documentElement, classNames.join(' '));
	    }
	  }]);
	  return Browser;
	}();

	var Cookie = /*#__PURE__*/function () {
	  function Cookie() {
	    babelHelpers.classCallCheck(this, Cookie);
	  }

	  babelHelpers.createClass(Cookie, null, [{
	    key: "getList",

	    /**
	     * Gets cookies list for current domain
	     * @return {object}
	     */
	    value: function getList() {
	      return document.cookie.split(';').map(function (item) {
	        return item.split('=');
	      }).map(function (item) {
	        return item.map(function (subItem) {
	          return subItem.trim();
	        });
	      }).reduce(function (acc, item) {
	        var _item = babelHelpers.slicedToArray(item, 2),
	            key = _item[0],
	            value = _item[1];

	        acc[decodeURIComponent(key)] = decodeURIComponent(value);
	        return acc;
	      }, {});
	    }
	    /**
	     * Gets cookie value
	     * @param {string} name
	     * @return {*}
	     */

	  }, {
	    key: "get",
	    value: function get(name) {
	      var cookiesList = Cookie.getList();

	      if (name in cookiesList) {
	        return cookiesList[name];
	      }

	      return undefined;
	    }
	    /**
	     * Sets cookie
	     * @param {string} name
	     * @param {*} value
	     * @param {object} [options]
	     */

	  }, {
	    key: "set",
	    value: function set(name, value) {
	      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
	      var attributes = babelHelpers.objectSpread({
	        expires: ''
	      }, options);

	      if (Type.isNumber(attributes.expires)) {
	        var now = +new Date();
	        var days = attributes.expires;
	        var dayInMs = 864e+5;
	        attributes.expires = new Date(now + days * dayInMs);
	      }

	      if (Type.isDate(attributes.expires)) {
	        attributes.expires = attributes.expires.toUTCString();
	      }

	      var safeName = decodeURIComponent(String(name)).replace(/%(23|24|26|2B|5E|60|7C)/g, decodeURIComponent).replace(/[()]/g, escape);
	      var safeValue = encodeURIComponent(String(value)).replace(/%(23|24|26|2B|3A|3C|3E|3D|2F|3F|40|5B|5D|5E|60|7B|7D|7C)/g, decodeURIComponent);
	      var stringifiedAttributes = Object.keys(attributes).reduce(function (acc, key) {
	        var attributeValue = attributes[key];

	        if (!attributeValue) {
	          return acc;
	        }

	        if (attributeValue === true) {
	          return "".concat(acc, "; ").concat(key);
	        }
	        /**
	         * Considers RFC 6265 section 5.2:
	         * ...
	         * 3. If the remaining unparsed-attributes contains a %x3B (';')
	         * character:
	         * Consume the characters of the unparsed-attributes up to,
	         * not including, the first %x3B (';') character.
	         */


	        return "".concat(acc, "; ").concat(key, "=").concat(attributeValue.split(';')[0]);
	      }, '');
	      document.cookie = "".concat(safeName, "=").concat(safeValue).concat(stringifiedAttributes);
	    }
	    /**
	     * Removes cookie
	     * @param {string} name
	     * @param {object} [options]
	     */

	  }, {
	    key: "remove",
	    value: function remove(name) {
	      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	      Cookie.set(name, '', babelHelpers.objectSpread({}, options, {
	        expires: -1
	      }));
	    }
	  }]);
	  return Cookie;
	}();

	function objectToFormData(source) {
	  var formData = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new FormData();
	  var pre = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

	  if (Type.isUndefined(source)) {
	    return formData;
	  }

	  if (Type.isNull(source)) {
	    formData.append(pre, '');
	  } else if (Type.isArray(source)) {
	    if (!source.length) {
	      var _key = "".concat(pre, "[]");

	      formData.append(_key, '');
	    } else {
	      source.forEach(function (value, index) {
	        var key = "".concat(pre, "[").concat(index, "]");
	        objectToFormData(value, formData, key);
	      });
	    }
	  } else if (Type.isDate(source)) {
	    formData.append(pre, source.toISOString());
	  } else if (Type.isObject(source) && !Type.isFile(source) && !Type.isBlob(source)) {
	    Object.keys(source).forEach(function (property) {
	      var value = source[property];
	      var preparedProperty = property;

	      if (Type.isArray(value)) {
	        while (property.length > 2 && property.lastIndexOf('[]') === property.length - 2) {
	          preparedProperty = property.substring(0, property.length - 2);
	        }
	      }

	      var key = pre ? "".concat(pre, "[").concat(preparedProperty, "]") : preparedProperty;
	      objectToFormData(value, formData, key);
	    });
	  } else {
	    formData.append(pre, source);
	  }

	  return formData;
	}

	var Data = /*#__PURE__*/function () {
	  function Data() {
	    babelHelpers.classCallCheck(this, Data);
	  }

	  babelHelpers.createClass(Data, null, [{
	    key: "convertObjectToFormData",

	    /**
	     * Converts object to FormData
	     * @param source
	     * @return {FormData}
	     */
	    value: function convertObjectToFormData(source) {
	      return objectToFormData(source);
	    }
	  }]);
	  return Data;
	}();

	/**
	 * @memberOf BX
	 */

	var Http = function Http() {
	  babelHelpers.classCallCheck(this, Http);
	};

	babelHelpers.defineProperty(Http, "Cookie", Cookie);
	babelHelpers.defineProperty(Http, "Data", Data);

	function message(value) {
	  if (Type.isString(value)) {
	    if (Type.isNil(message[value])) {
	      // eslint-disable-next-line
	      EventEmitter.emit('onBXMessageNotFound', new BaseEvent({
	        compatData: [value]
	      }));

	      if (Type.isNil(message[value])) {
	        Runtime.debug("message undefined: ".concat(value));
	        message[value] = '';
	      }
	    }
	  }

	  if (Type.isPlainObject(value)) {
	    Object.keys(value).forEach(function (key) {
	      message[key] = value[key];
	    });
	  }

	  return message[value];
	}

	if (!Type.isNil(window.BX) && Type.isFunction(window.BX.message)) {
	  Object.keys(window.BX.message).forEach(function (key) {
	    message(babelHelpers.defineProperty({}, key, window.BX.message[key]));
	  });
	}

	/**
	 * Implements interface for works with language messages
	 * @memberOf BX
	 */

	var Loc = /*#__PURE__*/function () {
	  function Loc() {
	    babelHelpers.classCallCheck(this, Loc);
	  }

	  babelHelpers.createClass(Loc, null, [{
	    key: "getMessage",

	    /**
	     * Gets message by id
	     * @param {string} messageId
	     * @param {object} replacements
	     * @return {?string}
	     */
	    value: function getMessage(messageId) {
	      var replacements = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
	      var mess = message(messageId);

	      if (Type.isString(mess) && Type.isPlainObject(replacements)) {
	        Object.keys(replacements).forEach(function (replacement) {
	          var globalRegexp = new RegExp(replacement, 'gi');
	          mess = mess.replace(globalRegexp, function () {
	            return Type.isNil(replacements[replacement]) ? '' : String(replacements[replacement]);
	          });
	        });
	      }

	      return mess;
	    }
	  }, {
	    key: "hasMessage",
	    value: function hasMessage(messageId) {
	      return Type.isString(messageId) && !Type.isNil(message[messageId]);
	    }
	    /**
	     * Sets message or messages
	     * @param {string | Object<string, string>} id
	     * @param {string} [value]
	     */

	  }, {
	    key: "setMessage",
	    value: function setMessage(id, value) {
	      if (Type.isString(id) && Type.isString(value)) {
	        message(babelHelpers.defineProperty({}, id, value));
	      }

	      if (Type.isObject(id)) {
	        message(id);
	      }
	    }
	    /**
	     * Gets plural message by id and number
	     * @param {string} messageId
	     * @param {number} value
	     * @param {object} [replacements]
	     * @return {?string}
	     */

	  }, {
	    key: "getMessagePlural",
	    value: function getMessagePlural(messageId, value) {
	      var replacements = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
	      var result = '';

	      if (Type.isNumber(value)) {
	        if (this.hasMessage("".concat(messageId, "_PLURAL_").concat(this.getPluralForm(value)))) {
	          result = this.getMessage("".concat(messageId, "_PLURAL_").concat(this.getPluralForm(value)), replacements);
	        } else {
	          result = this.getMessage("".concat(messageId, "_PLURAL_1"), replacements);
	        }
	      } else {
	        result = this.getMessage(messageId, replacements);
	      }

	      return result;
	    }
	    /**
	     * Gets language plural form id by number
	     * see http://docs.translatehouse.org/projects/localization-guide/en/latest/l10n/pluralforms.html
	     * @param {number} value
	     * @param {string} [languageId]
	     * @return {?number}
	     */

	  }, {
	    key: "getPluralForm",
	    value: function getPluralForm(value, languageId) {
	      var pluralForm;

	      if (!Type.isStringFilled(languageId)) {
	        languageId = message('LANGUAGE_ID');
	      }

	      if (value < 0) {
	        value = -1 * value;
	      }

	      switch (languageId) {
	        case 'ar':
	          pluralForm = value !== 1 ? 1 : 0;
	          /*
	          				if (value === 0)
	          				{
	          					pluralForm = 0;
	          				}
	          				else if (value === 1)
	          				{
	          					pluralForm = 1;
	          				}
	          				else if (value === 2)
	          				{
	          					pluralForm = 2;
	          				}
	          				else if (
	          					value % 100 >= 3
	          					&& value % 100 <= 10
	          				)
	          				{
	          					pluralForm = 3;
	          				}
	          				else if (value % 100 >= 11)
	          				{
	          					pluralForm = 4;
	          				}
	          				else
	          				{
	          					pluralForm = 5;
	          				}
	           */

	          break;

	        case 'br':
	        case 'fr':
	        case 'tr':
	          pluralForm = value > 1 ? 1 : 0;
	          break;

	        case 'de':
	        case 'en':
	        case 'hi':
	        case 'it':
	        case 'la':
	          pluralForm = value !== 1 ? 1 : 0;
	          break;

	        case 'ru':
	        case 'ua':
	          if (value % 10 === 1 && value % 100 !== 11) {
	            pluralForm = 0;
	          } else if (value % 10 >= 2 && value % 10 <= 4 && (value % 100 < 10 || value % 100 >= 20)) {
	            pluralForm = 1;
	          } else {
	            pluralForm = 2;
	          }

	          break;

	        case 'pl':
	          if (value === 1) {
	            pluralForm = 0;
	          } else if (value % 10 >= 2 && value % 10 <= 4 && (value % 100 < 10 || value % 100 >= 20)) {
	            pluralForm = 1;
	          } else {
	            pluralForm = 2;
	          }

	          break;

	        case 'id':
	        case 'ja':
	        case 'ms':
	        case 'sc':
	        case 'tc':
	        case 'th':
	        case 'vn':
	          pluralForm = 0;
	          break;

	        default:
	          pluralForm = 1;
	          break;
	      }

	      return pluralForm;
	    }
	  }]);
	  return Loc;
	}();

	var handlers = new Map();
	var children = new Map();

	var getUid = function () {
	  var incremental = 0;
	  return function () {
	    incremental += 1;
	    return incremental;
	  };
	}();

	function bindAll(element, handlersMap) {
	  handlersMap.forEach(function (handler, key) {
	    var currentElement = element.querySelector("[".concat(key, "]"));

	    if (currentElement) {
	      currentElement.removeAttribute(key);
	      var event = key.replace(/-(.*)/, '');
	      Event.bind(currentElement, event, handler);
	      handlers.delete(key);
	    }
	  });
	}

	function replaceChild(element, childrenMap) {
	  childrenMap.forEach(function (item, id) {
	    var currentElement = element.getElementById(id);

	    if (currentElement) {
	      Dom.replace(currentElement, item);
	      children.delete(id);
	    }
	  });
	}

	function render(sections) {
	  var eventAttrRe = /[ |\t]on(\w+)="$/;
	  var uselessSymbolsRe = /[\r\n\t]/g;

	  for (var _len = arguments.length, substitutions = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	    substitutions[_key - 1] = arguments[_key];
	  }

	  var html = substitutions.reduce(function (acc, item, index) {
	    var preparedAcc = acc; // Process event handlers

	    var matches = acc.match(eventAttrRe);

	    if (matches && Type.isFunction(item)) {
	      var eventName = matches[1].replace(/=['|"]/, '');
	      var attrName = "".concat(eventName, "-").concat(getUid());
	      var attribute = "".concat(attrName, "=\"");
	      preparedAcc = preparedAcc.replace(eventAttrRe, " ".concat(attribute));
	      handlers.set(attrName, item);
	      preparedAcc += sections[index + 1].replace(uselessSymbolsRe, ' ').replace(/  +/g, ' ');
	      return preparedAcc;
	    } // Process element


	    if (Type.isDomNode(item)) {
	      var childKey = "tmp___".concat(getUid());
	      children.set(childKey, item);
	      preparedAcc += "<span id=\"".concat(childKey, "\"> </span>");
	      preparedAcc += sections[index + 1];
	      return preparedAcc;
	    } // Process array


	    if (Type.isArray(item)) {
	      babelHelpers.toConsumableArray(item).forEach(function (currentElement) {
	        if (Type.isDomNode(currentElement)) {
	          var _childKey = "tmp___".concat(getUid());

	          children.set(_childKey, currentElement);
	          preparedAcc += "<span id=\"".concat(_childKey, "\"> </span>");
	        }
	      });
	      preparedAcc += sections[index + 1];
	      return preparedAcc;
	    }

	    return preparedAcc + item + sections[index + 1];
	  }, sections[0]);
	  var lowercaseHtml = html.trim().toLowerCase();

	  if (lowercaseHtml.startsWith('<!doctype') || lowercaseHtml.startsWith('<html')) {
	    var doc = document.implementation.createHTMLDocument('');
	    doc.documentElement.innerHTML = html;
	    replaceChild(doc, children);
	    bindAll(doc, handlers);
	    handlers.clear();
	    return doc;
	  }

	  var parser = new DOMParser();
	  var parsedDocument = parser.parseFromString(html, 'text/html');
	  replaceChild(parsedDocument, children);
	  bindAll(parsedDocument, handlers);

	  if (parsedDocument.head.children.length && parsedDocument.body.children.length) {
	    return parsedDocument;
	  }

	  if (parsedDocument.body.children.length === 1) {
	    var _parsedDocument$body$ = babelHelpers.slicedToArray(parsedDocument.body.children, 1),
	        el = _parsedDocument$body$[0];

	    Dom.remove(el);
	    return el;
	  }

	  if (parsedDocument.body.children.length > 1) {
	    return babelHelpers.toConsumableArray(parsedDocument.body.children).map(function (item) {
	      Dom.remove(item);
	      return item;
	    });
	  }

	  if (parsedDocument.body.children.length === 0) {
	    if (parsedDocument.head.children.length === 1) {
	      var _parsedDocument$head$ = babelHelpers.slicedToArray(parsedDocument.head.children, 1),
	          _el = _parsedDocument$head$[0];

	      Dom.remove(_el);
	      return _el;
	    }

	    if (parsedDocument.head.children.length > 1) {
	      return babelHelpers.toConsumableArray(parsedDocument.head.children).map(function (item) {
	        Dom.remove(item);
	        return item;
	      });
	    }
	  }

	  return false;
	}

	function parseProps(sections) {
	  for (var _len = arguments.length, substitutions = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	    substitutions[_key - 1] = arguments[_key];
	  }

	  return substitutions.reduce(function (acc, item, index) {
	    var nextSectionIndex = index + 1;

	    if (!Type.isPlainObject(item) && !Type.isArray(item)) {
	      return acc + item + sections[nextSectionIndex];
	    }

	    return "".concat(acc, "__s").concat(index).concat(sections[nextSectionIndex]);
	  }, sections[0]).replace(/[\r\t]/gm, '').split(';\n').map(function (item) {
	    return item.replace(/\n/, '');
	  }).reduce(function (acc, item) {
	    if (item !== '') {
	      var matches = item.match(/^[\w-. ]+:/);
	      var splitted = item.split(/^[\w-. ]+:/);

	      var _key2 = matches[0].replace(':', '').trim();

	      var value = splitted[1].trim();
	      var substitutionPlaceholderExp = /^__s\d+/;

	      if (substitutionPlaceholderExp.test(value)) {
	        acc[_key2] = substitutions[value.replace('__s', '')];
	        return acc;
	      }

	      acc[_key2] = value;
	    }

	    return acc;
	  }, {});
	}
	/**
	 * @memberOf BX
	 */


	var Tag = /*#__PURE__*/function () {
	  function Tag() {
	    babelHelpers.classCallCheck(this, Tag);
	  }

	  babelHelpers.createClass(Tag, null, [{
	    key: "safe",

	    /**
	     * Encodes all substitutions
	     * @param sections
	     * @param substitutions
	     * @return {string}
	     */
	    value: function safe(sections) {
	      for (var _len2 = arguments.length, substitutions = new Array(_len2 > 1 ? _len2 - 1 : 0), _key3 = 1; _key3 < _len2; _key3++) {
	        substitutions[_key3 - 1] = arguments[_key3];
	      }

	      return substitutions.reduce(function (acc, item, index) {
	        return acc + Text.encode(item) + sections[index + 1];
	      }, sections[0]);
	    }
	    /**
	     * Decodes all substitutions
	     * @param sections
	     * @param substitutions
	     * @return {string}
	     */

	  }, {
	    key: "unsafe",
	    value: function unsafe(sections) {
	      for (var _len3 = arguments.length, substitutions = new Array(_len3 > 1 ? _len3 - 1 : 0), _key4 = 1; _key4 < _len3; _key4++) {
	        substitutions[_key4 - 1] = arguments[_key4];
	      }

	      return substitutions.reduce(function (acc, item, index) {
	        return acc + Text.decode(item) + sections[index + 1];
	      }, sections[0]);
	    }
	    /**
	     * Adds styles to specified element
	     * @param {HTMLElement} element
	     * @return {Function}
	     */

	  }, {
	    key: "style",
	    value: function style(element) {
	      if (!Type.isDomNode(element)) {
	        throw new Error('element is not HTMLElement');
	      }

	      return function styleTagHandler() {
	        Dom.style(element, parseProps.apply(void 0, arguments));
	      };
	    }
	    /**
	     * Replace all messages identifiers to real messages
	     * @param sections
	     * @param substitutions
	     * @return {string}
	     */

	  }, {
	    key: "message",
	    value: function message(sections) {
	      for (var _len4 = arguments.length, substitutions = new Array(_len4 > 1 ? _len4 - 1 : 0), _key5 = 1; _key5 < _len4; _key5++) {
	        substitutions[_key5 - 1] = arguments[_key5];
	      }

	      return substitutions.reduce(function (acc, item, index) {
	        return acc + Loc.getMessage(item) + sections[index + 1];
	      }, sections[0]);
	    }
	  }, {
	    key: "attrs",

	    /**
	     * Adds attributes to specified element
	     * @param element
	     * @return {Function}
	     */
	    value: function attrs(element) {
	      if (!Type.isDomNode(element)) {
	        throw new Error('element is not HTMLElement');
	      }

	      return function attrsTagHandler() {
	        Dom.attr(element, parseProps.apply(void 0, arguments));
	      };
	    }
	  }]);
	  return Tag;
	}();

	babelHelpers.defineProperty(Tag, "render", render);
	babelHelpers.defineProperty(Tag, "attr", Tag.attrs);

	function getParser(format) {
	  switch (format) {
	    case 'index':
	      return function (sourceKey, value, accumulator) {
	        var result = /\[(\w*)\]$/.exec(sourceKey);
	        var key = sourceKey.replace(/\[\w*\]$/, '');

	        if (Type.isNil(result)) {
	          accumulator[key] = value;
	          return;
	        }

	        if (Type.isUndefined(accumulator[key])) {
	          accumulator[key] = {};
	        }

	        accumulator[key][result[1]] = value;
	      };

	    case 'bracket':
	      return function (sourceKey, value, accumulator) {
	        var result = /(\[\])$/.exec(sourceKey);
	        var key = sourceKey.replace(/\[\]$/, '');

	        if (Type.isNil(result)) {
	          accumulator[key] = value;
	          return;
	        }

	        if (Type.isUndefined(accumulator[key])) {
	          accumulator[key] = [value];
	          return;
	        }

	        accumulator[key] = [].concat(accumulator[key], value);
	      };

	    default:
	      return function (sourceKey, value, accumulator) {
	        var key = sourceKey.replace(/\[\]$/, '');
	        accumulator[key] = value;
	      };
	  }
	}

	function getKeyFormat(key) {
	  if (/^\w+\[([\w]+)\]$/.test(key)) {
	    return 'index';
	  }

	  if (/^\w+\[\]$/.test(key)) {
	    return 'bracket';
	  }

	  return 'default';
	}

	function parseQuery(input) {
	  if (!Type.isString(input)) {
	    return {};
	  }

	  var url = input.trim().replace(/^[?#&]/, '');

	  if (!url) {
	    return {};
	  }

	  return url.split('&').reduce(function (acc, param) {
	    var _param$replace$split = param.replace(/\+/g, ' ').split('='),
	        _param$replace$split2 = babelHelpers.slicedToArray(_param$replace$split, 2),
	        key = _param$replace$split2[0],
	        value = _param$replace$split2[1];

	    var keyFormat = getKeyFormat(key);
	    var formatter = getParser(keyFormat);
	    formatter(key, value, acc);
	    return acc;
	  }, {});
	}

	var urlExp = /^((\w+):)?(\/\/((\w+)?(:(\w+))?@)?([^\/\?:]+)(:(\d+))?)?(\/?([^\/\?#][^\?#]*)?)?(\?([^#]+))?(#(\w*))?/;
	function parseUrl(url) {
	  var result = url.match(urlExp);

	  if (Type.isArray(result)) {
	    var queryParams = parseQuery(result[14]);
	    return {
	      useShort: /^\/\//.test(url),
	      href: result[0] || '',
	      schema: result[2] || '',
	      host: result[8] || '',
	      port: result[10] || '',
	      path: result[11] || '',
	      query: result[14] || '',
	      queryParams: queryParams,
	      hash: result[16] || '',
	      username: result[5] || '',
	      password: result[7] || '',
	      origin: result[8] || ''
	    };
	  }

	  return {};
	}

	function buildQueryString() {
	  var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	  var queryString = Object.keys(params).reduce(function (acc, key) {
	    if (Type.isArray(params[key])) {
	      params[key].forEach(function (paramValue) {
	        acc.push("".concat(key, "[]=").concat(paramValue));
	      }, '');
	    }

	    if (Type.isPlainObject(params[key])) {
	      Object.keys(params[key]).forEach(function (paramIndex) {
	        acc.push("".concat(key, "[").concat(paramIndex, "]=").concat(params[key][paramIndex]));
	      }, '');
	    }

	    if (!Type.isObject(params[key]) && !Type.isArray(params[key])) {
	      acc.push("".concat(key, "=").concat(params[key]));
	    }

	    return acc;
	  }, []).join('&');

	  if (queryString.length > 0) {
	    return "?".concat(queryString);
	  }

	  return queryString;
	}

	function prepareParamValue(value) {
	  if (Type.isArray(value)) {
	    return value.map(function (item) {
	      return String(item);
	    });
	  }

	  if (Type.isPlainObject(value)) {
	    return babelHelpers.objectSpread({}, value);
	  }

	  return String(value);
	}

	var map = new WeakMap();
	/**
	 * Implements interface for works with URI
	 * @memberOf BX
	 */

	var Uri = /*#__PURE__*/function () {
	  babelHelpers.createClass(Uri, null, [{
	    key: "addParam",
	    value: function addParam(url) {
	      var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	      return new Uri(url).setQueryParams(params).toString();
	    }
	  }, {
	    key: "removeParam",
	    value: function removeParam(url, params) {
	      var _Uri;

	      var removableParams = Type.isArray(params) ? params : [params];
	      return (_Uri = new Uri(url)).removeQueryParam.apply(_Uri, babelHelpers.toConsumableArray(removableParams)).toString();
	    }
	  }]);

	  function Uri() {
	    var url = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
	    babelHelpers.classCallCheck(this, Uri);
	    map.set(this, parseUrl(url));
	  }
	  /**
	   * Gets schema
	   * @return {?string}
	   */


	  babelHelpers.createClass(Uri, [{
	    key: "getSchema",
	    value: function getSchema() {
	      return map.get(this).schema;
	    }
	    /**
	     * Sets schema
	     * @param {string} schema
	     * @return {Uri}
	     */

	  }, {
	    key: "setSchema",
	    value: function setSchema(schema) {
	      map.get(this).schema = String(schema);
	      return this;
	    }
	    /**
	     * Gets host
	     * @return {?string}
	     */

	  }, {
	    key: "getHost",
	    value: function getHost() {
	      return map.get(this).host;
	    }
	    /**
	     * Sets host
	     * @param {string} host
	     * @return {Uri}
	     */

	  }, {
	    key: "setHost",
	    value: function setHost(host) {
	      map.get(this).host = String(host);
	      return this;
	    }
	    /**
	     * Gets port
	     * @return {?string}
	     */

	  }, {
	    key: "getPort",
	    value: function getPort() {
	      return map.get(this).port;
	    }
	    /**
	     * Sets port
	     * @param {String | Number} port
	     * @return {Uri}
	     */

	  }, {
	    key: "setPort",
	    value: function setPort(port) {
	      map.get(this).port = String(port);
	      return this;
	    }
	    /**
	     * Gets path
	     * @return {?string}
	     */

	  }, {
	    key: "getPath",
	    value: function getPath() {
	      return map.get(this).path;
	    }
	    /**
	     * Sets path
	     * @param {string} path
	     * @return {Uri}
	     */

	  }, {
	    key: "setPath",
	    value: function setPath(path) {
	      if (!/^\//.test(path)) {
	        map.get(this).path = "/".concat(String(path));
	        return this;
	      }

	      map.get(this).path = String(path);
	      return this;
	    }
	    /**
	     * Gets query
	     * @return {?string}
	     */

	  }, {
	    key: "getQuery",
	    value: function getQuery() {
	      return buildQueryString(map.get(this).queryParams);
	    }
	    /**
	     * Gets query param value by name
	     * @param {string} key
	     * @return {?string}
	     */

	  }, {
	    key: "getQueryParam",
	    value: function getQueryParam(key) {
	      var params = this.getQueryParams();

	      if (key in params) {
	        return params[key];
	      }

	      return null;
	    }
	    /**
	     * Sets query param
	     * @param {string} key
	     * @param [value]
	     * @return {Uri}
	     */

	  }, {
	    key: "setQueryParam",
	    value: function setQueryParam(key) {
	      var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
	      map.get(this).queryParams[key] = prepareParamValue(value);
	      return this;
	    }
	    /**
	     * Gets query params
	     * @return {Object<string, any>}
	     */

	  }, {
	    key: "getQueryParams",
	    value: function getQueryParams() {
	      return babelHelpers.objectSpread({}, map.get(this).queryParams);
	    }
	    /**
	     * Sets query params
	     * @param {Object<string, any>} params
	     * @return {Uri}
	     */

	  }, {
	    key: "setQueryParams",
	    value: function setQueryParams() {
	      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	      var currentParams = this.getQueryParams();
	      var newParams = babelHelpers.objectSpread({}, currentParams, params);
	      Object.keys(newParams).forEach(function (key) {
	        newParams[key] = prepareParamValue(newParams[key]);
	      });
	      map.get(this).queryParams = newParams;
	      return this;
	    }
	    /**
	     * Removes query params by name
	     * @param keys
	     * @return {Uri}
	     */

	  }, {
	    key: "removeQueryParam",
	    value: function removeQueryParam() {
	      var currentParams = babelHelpers.objectSpread({}, map.get(this).queryParams);

	      for (var _len = arguments.length, keys = new Array(_len), _key = 0; _key < _len; _key++) {
	        keys[_key] = arguments[_key];
	      }

	      keys.forEach(function (key) {
	        if (key in currentParams) {
	          delete currentParams[key];
	        }
	      });
	      map.get(this).queryParams = currentParams;
	      return this;
	    }
	    /**
	     * Gets fragment
	     * @return {?string}
	     */

	  }, {
	    key: "getFragment",
	    value: function getFragment() {
	      return map.get(this).hash;
	    }
	    /**
	     * Sets fragment
	     * @param {string} hash
	     * @return {Uri}
	     */

	  }, {
	    key: "setFragment",
	    value: function setFragment(hash) {
	      map.get(this).hash = String(hash);
	      return this;
	    }
	    /**
	     * Serializes URI
	     * @return {Object}
	     */

	  }, {
	    key: "serialize",
	    value: function serialize() {
	      var serialized = babelHelpers.objectSpread({}, map.get(this));
	      serialized.href = this.toString();
	      return serialized;
	    }
	    /**
	     * Gets URI string
	     * @return {string}
	     */

	  }, {
	    key: "toString",
	    value: function toString() {
	      var data = babelHelpers.objectSpread({}, map.get(this));
	      var protocol = data.schema ? "".concat(data.schema, "://") : '';

	      if (data.useShort) {
	        protocol = '//';
	      }

	      var port = function () {
	        if (Type.isString(data.port) && !['', '80'].includes(data.port)) {
	          return ":".concat(data.port);
	        }

	        return '';
	      }();

	      var host = this.getHost();
	      var path = this.getPath();
	      var query = buildQueryString(data.queryParams);
	      var hash = data.hash ? "#".concat(data.hash) : '';
	      return "".concat(host ? protocol : '').concat(host).concat(host ? port : '').concat(path).concat(query).concat(hash);
	    }
	  }]);
	  return Uri;
	}();

	/**
	 * @memberOf BX
	 */
	var Validation = /*#__PURE__*/function () {
	  function Validation() {
	    babelHelpers.classCallCheck(this, Validation);
	  }

	  babelHelpers.createClass(Validation, null, [{
	    key: "isEmail",

	    /**
	     * Checks that value is valid email
	     * @param value
	     * @return {boolean}
	     */
	    value: function isEmail(value) {
	      var exp = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
	      return exp.test(String(value).toLowerCase());
	    }
	  }]);
	  return Validation;
	}();

	var BaseCache = /*#__PURE__*/function () {
	  function BaseCache() {
	    babelHelpers.classCallCheck(this, BaseCache);
	    babelHelpers.defineProperty(this, "storage", new Map());
	  }

	  babelHelpers.createClass(BaseCache, [{
	    key: "get",

	    /**
	     * Gets cached value or default value
	     */
	    value: function get(key, defaultValue) {
	      if (!this.storage.has(key)) {
	        if (Type.isFunction(defaultValue)) {
	          return defaultValue();
	        }

	        if (!Type.isUndefined(defaultValue)) {
	          return defaultValue;
	        }
	      }

	      return this.storage.get(key);
	    }
	    /**
	     * Sets cache entry
	     */

	  }, {
	    key: "set",
	    value: function set(key, value) {
	      this.storage.set(key, value);
	    }
	    /**
	     * Deletes cache entry
	     */

	  }, {
	    key: "delete",
	    value: function _delete(key) {
	      this.storage.delete(key);
	    }
	    /**
	     * Checks that storage contains entry with specified key
	     */

	  }, {
	    key: "has",
	    value: function has(key) {
	      return this.storage.has(key);
	    }
	    /**
	     * Gets cached value if exists,
	     */

	  }, {
	    key: "remember",
	    value: function remember(key, defaultValue) {
	      if (!this.storage.has(key)) {
	        if (Type.isFunction(defaultValue)) {
	          this.storage.set(key, defaultValue());
	        } else if (!Type.isUndefined(defaultValue)) {
	          this.storage.set(key, defaultValue);
	        }
	      }

	      return this.storage.get(key);
	    }
	    /**
	     * Gets storage size
	     */

	  }, {
	    key: "size",
	    value: function size() {
	      return this.storage.size;
	    }
	    /**
	     * Gets storage keys
	     */

	  }, {
	    key: "keys",
	    value: function keys() {
	      return babelHelpers.toConsumableArray(this.storage.keys());
	    }
	    /**
	     * Gets storage values
	     */

	  }, {
	    key: "values",
	    value: function values() {
	      return babelHelpers.toConsumableArray(this.storage.values());
	    }
	  }]);
	  return BaseCache;
	}();

	var MemoryCache = /*#__PURE__*/function (_BaseCache) {
	  babelHelpers.inherits(MemoryCache, _BaseCache);

	  function MemoryCache() {
	    var _babelHelpers$getProt;

	    var _this;

	    babelHelpers.classCallCheck(this, MemoryCache);

	    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }

	    _this = babelHelpers.possibleConstructorReturn(this, (_babelHelpers$getProt = babelHelpers.getPrototypeOf(MemoryCache)).call.apply(_babelHelpers$getProt, [this].concat(args)));
	    babelHelpers.defineProperty(babelHelpers.assertThisInitialized(_this), "storage", new Map());
	    return _this;
	  }

	  return MemoryCache;
	}(BaseCache);

	var LsStorage = /*#__PURE__*/function () {
	  function LsStorage() {
	    babelHelpers.classCallCheck(this, LsStorage);
	    babelHelpers.defineProperty(this, "stackKey", 'BX.Cache.Storage.LsStorage.stack');
	    babelHelpers.defineProperty(this, "stack", null);
	  }

	  babelHelpers.createClass(LsStorage, [{
	    key: "getStack",

	    /**
	     * @private
	     */
	    value: function getStack() {
	      if (Type.isPlainObject(this.stack)) {
	        return this.stack;
	      }

	      var stack = localStorage.getItem(this.stackKey);

	      if (Type.isString(stack) && stack !== '') {
	        var parsedStack = JSON.parse(stack);

	        if (Type.isPlainObject(parsedStack)) {
	          this.stack = parsedStack;
	          return this.stack;
	        }
	      }

	      this.stack = {};
	      return this.stack;
	    }
	    /**
	     * @private
	     */

	  }, {
	    key: "saveStack",
	    value: function saveStack() {
	      if (Type.isPlainObject(this.stack)) {
	        var preparedStack = JSON.stringify(this.stack);
	        localStorage.setItem(this.stackKey, preparedStack);
	      }
	    }
	  }, {
	    key: "get",
	    value: function get(key) {
	      var stack = this.getStack();
	      return stack[key];
	    }
	  }, {
	    key: "set",
	    value: function set(key, value) {
	      var stack = this.getStack();
	      stack[key] = value;
	      this.saveStack();
	    }
	  }, {
	    key: "delete",
	    value: function _delete(key) {
	      var stack = this.getStack();

	      if (key in stack) {
	        delete stack[key];
	      }
	    }
	  }, {
	    key: "has",
	    value: function has(key) {
	      var stack = this.getStack();
	      return key in stack;
	    }
	  }, {
	    key: "keys",
	    value: function keys() {
	      var stack = this.getStack();
	      return Object.keys(stack);
	    }
	  }, {
	    key: "values",
	    value: function values() {
	      var stack = this.getStack();
	      return Object.values(stack);
	    }
	  }, {
	    key: "size",
	    get: function get() {
	      var stack = this.getStack();
	      return Object.keys(stack).length;
	    }
	  }]);
	  return LsStorage;
	}();

	var LocalStorageCache = /*#__PURE__*/function (_BaseCache) {
	  babelHelpers.inherits(LocalStorageCache, _BaseCache);

	  function LocalStorageCache() {
	    var _babelHelpers$getProt;

	    var _this;

	    babelHelpers.classCallCheck(this, LocalStorageCache);

	    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }

	    _this = babelHelpers.possibleConstructorReturn(this, (_babelHelpers$getProt = babelHelpers.getPrototypeOf(LocalStorageCache)).call.apply(_babelHelpers$getProt, [this].concat(args)));
	    babelHelpers.defineProperty(babelHelpers.assertThisInitialized(_this), "storage", new LsStorage());
	    return _this;
	  }

	  return LocalStorageCache;
	}(BaseCache);

	/**
	 * @memberOf BX
	 */

	var Cache = function Cache() {
	  babelHelpers.classCallCheck(this, Cache);
	};

	babelHelpers.defineProperty(Cache, "MemoryCache", MemoryCache);
	babelHelpers.defineProperty(Cache, "LocalStorageCache", LocalStorageCache);

	var _Symbol$iterator;

	function _classPrivateMethodInitSpec(obj, privateSet) { _checkPrivateRedeclaration(obj, privateSet); privateSet.add(obj); }

	function _checkPrivateRedeclaration(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError("Cannot initialize the same private elements twice on an object"); } }

	function _classPrivateMethodGet(receiver, privateSet, fn) { if (!privateSet.has(receiver)) { throw new TypeError("attempted to get private field on non-instance"); } return fn; }

	var _searchIndexToInsert = /*#__PURE__*/new WeakSet();

	_Symbol$iterator = Symbol.iterator;

	var OrderedArray = /*#__PURE__*/function () {
	  function OrderedArray() {
	    var comparator = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
	    babelHelpers.classCallCheck(this, OrderedArray);

	    _classPrivateMethodInitSpec(this, _searchIndexToInsert);

	    babelHelpers.defineProperty(this, "comparator", null);
	    babelHelpers.defineProperty(this, "items", []);
	    this.comparator = Type.isFunction(comparator) ? comparator : null;
	  }

	  babelHelpers.createClass(OrderedArray, [{
	    key: "add",
	    value: function add(item) {
	      var index = -1;

	      if (this.comparator) {
	        index = _classPrivateMethodGet(this, _searchIndexToInsert, _searchIndexToInsert2).call(this, item);
	        this.items.splice(index, 0, item);
	      } else {
	        this.items.push(item);
	      }

	      return index;
	    }
	  }, {
	    key: "has",
	    value: function has(item) {
	      return this.items.includes(item);
	    }
	  }, {
	    key: "getIndex",
	    value: function getIndex(item) {
	      return this.items.indexOf(item);
	    }
	  }, {
	    key: "getByIndex",
	    value: function getByIndex(index) {
	      if (Type.isNumber(index) && index >= 0) {
	        var item = this.items[index];
	        return Type.isUndefined(item) ? null : item;
	      }

	      return null;
	    }
	  }, {
	    key: "getFirst",
	    value: function getFirst() {
	      var first = this.items[0];
	      return Type.isUndefined(first) ? null : first;
	    }
	  }, {
	    key: "getLast",
	    value: function getLast() {
	      var last = this.items[this.count() - 1];
	      return Type.isUndefined(last) ? null : last;
	    }
	  }, {
	    key: "count",
	    value: function count() {
	      return this.items.length;
	    }
	  }, {
	    key: "delete",
	    value: function _delete(item) {
	      var index = this.getIndex(item);

	      if (index !== -1) {
	        this.items.splice(index, 1);
	        return true;
	      }

	      return false;
	    }
	  }, {
	    key: "clear",
	    value: function clear() {
	      this.items = [];
	    }
	  }, {
	    key: _Symbol$iterator,
	    value: function value() {
	      return this.items[Symbol.iterator]();
	    }
	  }, {
	    key: "forEach",
	    value: function forEach(callbackfn, thisArg) {
	      return this.items.forEach(callbackfn, thisArg);
	    }
	  }, {
	    key: "getAll",
	    value: function getAll() {
	      return this.items;
	    }
	  }, {
	    key: "getComparator",
	    value: function getComparator() {
	      return this.comparator;
	    }
	  }, {
	    key: "sort",
	    value: function sort() {
	      var _this = this;

	      var comparator = this.getComparator();

	      if (comparator === null) {
	        return;
	      }
	      /*
	      Simple implementation
	      this.items.sort((item1, item2) => {
	      	return comparator(item1, item2);
	      });
	      */
	      // For stable sorting https://v8.dev/features/stable-sort


	      var length = this.items.length;
	      var indexes = new Array(length);

	      for (var i = 0; i < length; i++) {
	        indexes[i] = i;
	      } // If the comparator returns zero, use the original indexes


	      indexes.sort(function (index1, index2) {
	        return comparator(_this.items[index1], _this.items[index2]) || index1 - index2;
	      });

	      for (var _i = 0; _i < length; _i++) {
	        indexes[_i] = this.items[indexes[_i]];
	      }

	      for (var _i2 = 0; _i2 < length; _i2++) {
	        this.items[_i2] = indexes[_i2];
	      }
	    }
	  }]);
	  return OrderedArray;
	}();

	function _searchIndexToInsert2(value) {
	  var low = 0;
	  var high = this.items.length;

	  while (low < high) {
	    var mid = Math.floor((low + high) / 2);

	    if (this.comparator(this.items[mid], value) >= 0) {
	      high = mid;
	    } else {
	      low = mid + 1;
	    }
	  }

	  return low;
	}

	var ZIndexComponent = /*#__PURE__*/function (_EventEmitter) {
	  babelHelpers.inherits(ZIndexComponent, _EventEmitter);

	  function ZIndexComponent(element) {
	    var _this;

	    var componentOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	    babelHelpers.classCallCheck(this, ZIndexComponent);
	    _this = babelHelpers.possibleConstructorReturn(this, babelHelpers.getPrototypeOf(ZIndexComponent).call(this));
	    babelHelpers.defineProperty(babelHelpers.assertThisInitialized(_this), "sort", 0);
	    babelHelpers.defineProperty(babelHelpers.assertThisInitialized(_this), "alwaysOnTop", false);
	    babelHelpers.defineProperty(babelHelpers.assertThisInitialized(_this), "zIndex", 0);
	    babelHelpers.defineProperty(babelHelpers.assertThisInitialized(_this), "element", null);
	    babelHelpers.defineProperty(babelHelpers.assertThisInitialized(_this), "overlay", null);
	    babelHelpers.defineProperty(babelHelpers.assertThisInitialized(_this), "overlayGap", -5);
	    babelHelpers.defineProperty(babelHelpers.assertThisInitialized(_this), "stack", null);

	    _this.setEventNamespace('BX.Main.ZIndexManager.Component');

	    if (!Type.isElementNode(element)) {
	      throw new Error('ZIndexManager.Component: The argument \'element\' must be a DOM element.');
	    }

	    _this.element = element;
	    var options = Type.isPlainObject(componentOptions) ? componentOptions : {};

	    _this.setAlwaysOnTop(options.alwaysOnTop);

	    _this.setOverlay(options.overlay);

	    _this.setOverlayGap(options.overlayGap);

	    _this.subscribeFromOptions(options.events);

	    return _this;
	  }

	  babelHelpers.createClass(ZIndexComponent, [{
	    key: "getSort",
	    value: function getSort() {
	      return this.sort;
	    }
	    /**
	     * @internal
	     * @param sort
	     */

	  }, {
	    key: "setSort",
	    value: function setSort(sort) {
	      if (Type.isNumber(sort)) {
	        this.sort = sort;
	      }
	    }
	    /**
	     * @internal
	     * @param stack
	     */

	  }, {
	    key: "setStack",
	    value: function setStack(stack) {
	      this.stack = stack;
	    }
	  }, {
	    key: "getStack",
	    value: function getStack() {
	      return this.stack;
	    }
	  }, {
	    key: "getZIndex",
	    value: function getZIndex() {
	      return this.zIndex;
	    }
	    /**
	     * @internal
	     */

	  }, {
	    key: "setZIndex",
	    value: function setZIndex(zIndex) {
	      var changed = this.getZIndex() !== zIndex;
	      this.getElement().style.setProperty('z-index', zIndex, 'important');
	      this.zIndex = zIndex;

	      if (this.getOverlay() !== null) {
	        this.getOverlay().style.setProperty('z-index', zIndex + this.getOverlayGap(), 'important');
	      }

	      if (changed) {
	        this.emit('onZIndexChange', {
	          component: this
	        });
	      }
	    }
	  }, {
	    key: "getAlwaysOnTop",
	    value: function getAlwaysOnTop() {
	      return this.alwaysOnTop;
	    }
	  }, {
	    key: "setAlwaysOnTop",
	    value: function setAlwaysOnTop(value) {
	      if (Type.isNumber(value) || Type.isBoolean(value)) {
	        this.alwaysOnTop = value;
	      }
	    }
	  }, {
	    key: "getElement",
	    value: function getElement() {
	      return this.element;
	    }
	  }, {
	    key: "setOverlay",
	    value: function setOverlay(overlay, gap) {
	      if (Type.isElementNode(overlay) || overlay === null) {
	        this.overlay = overlay;
	        this.setOverlayGap(gap);

	        if (this.getStack()) {
	          this.getStack().sort();
	        }
	      }
	    }
	  }, {
	    key: "getOverlay",
	    value: function getOverlay() {
	      return this.overlay;
	    }
	  }, {
	    key: "setOverlayGap",
	    value: function setOverlayGap(gap) {
	      if (Type.isNumber(gap)) {
	        this.overlayGap = gap;
	      }
	    }
	  }, {
	    key: "getOverlayGap",
	    value: function getOverlayGap() {
	      return this.overlayGap;
	    }
	  }]);
	  return ZIndexComponent;
	}(EventEmitter);

	var ZIndexStack = /*#__PURE__*/function () {
	  function ZIndexStack(container) {
	    babelHelpers.classCallCheck(this, ZIndexStack);
	    babelHelpers.defineProperty(this, "container", null);
	    babelHelpers.defineProperty(this, "components", null);
	    babelHelpers.defineProperty(this, "elements", new WeakMap());
	    babelHelpers.defineProperty(this, "baseIndex", 1000);
	    babelHelpers.defineProperty(this, "baseStep", 50);
	    babelHelpers.defineProperty(this, "sortCount", 0);

	    if (!Type.isDomNode(container)) {
	      throw new Error('ZIndexManager.Stack: The \'container\' argument must be a DOM element.');
	    }

	    this.container = container;

	    var comparator = function comparator(componentA, componentB) {
	      var result = (componentA.getAlwaysOnTop() || 0) - (componentB.getAlwaysOnTop() || 0);

	      if (!result) {
	        result = componentA.getSort() - componentB.getSort();
	      }

	      return result;
	    };

	    this.components = new OrderedArray(comparator);
	  }

	  babelHelpers.createClass(ZIndexStack, [{
	    key: "getBaseIndex",
	    value: function getBaseIndex() {
	      return this.baseIndex;
	    }
	  }, {
	    key: "setBaseIndex",
	    value: function setBaseIndex(index) {
	      if (Type.isNumber(index) && index >= 0) {
	        this.baseIndex = index;
	        this.sort();
	      }
	    }
	  }, {
	    key: "setBaseStep",
	    value: function setBaseStep(step) {
	      if (Type.isNumber(step) && step > 0) {
	        this.baseStep = step;
	        this.sort();
	      }
	    }
	  }, {
	    key: "getBaseStep",
	    value: function getBaseStep() {
	      return this.baseStep;
	    }
	  }, {
	    key: "register",
	    value: function register(element) {
	      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

	      if (this.getComponent(element)) {
	        console.warn('ZIndexManager: You cannot register the element twice.', element);
	        return this.getComponent(element);
	      }

	      var component = new ZIndexComponent(element, options);
	      component.setStack(this);
	      component.setSort(++this.sortCount);
	      this.elements.set(element, component);
	      this.components.add(component);
	      this.sort();
	      return component;
	    }
	  }, {
	    key: "unregister",
	    value: function unregister(element) {
	      var component = this.elements.get(element);
	      this.components.delete(component);
	      this.elements.delete(element);
	      this.sort();
	    }
	  }, {
	    key: "getComponent",
	    value: function getComponent(element) {
	      return this.elements.get(element) || null;
	    }
	  }, {
	    key: "getComponents",
	    value: function getComponents() {
	      return this.components.getAll();
	    }
	  }, {
	    key: "getMaxZIndex",
	    value: function getMaxZIndex() {
	      var last = this.components.getLast();
	      return last ? last.getZIndex() : this.baseIndex;
	    }
	  }, {
	    key: "sort",
	    value: function sort() {
	      var _this = this;

	      this.components.sort();
	      var zIndex = this.baseIndex;
	      this.components.forEach(function (component) {
	        component.setZIndex(zIndex);
	        zIndex += _this.baseStep;
	      });
	    }
	  }, {
	    key: "bringToFront",
	    value: function bringToFront(element) {
	      var component = this.getComponent(element);

	      if (!component) {
	        console.error('ZIndexManager: element was not found in the stack.', element);
	        return null;
	      }

	      component.setSort(++this.sortCount);
	      this.sort();
	      return component;
	    }
	  }]);
	  return ZIndexStack;
	}();

	function _classStaticPrivateMethodGet(receiver, classConstructor, method) { _classCheckPrivateStaticAccess(receiver, classConstructor); return method; }

	function _classCheckPrivateStaticAccess(receiver, classConstructor) { if (receiver !== classConstructor) { throw new TypeError("Private static access of wrong provenance"); } }

	/**
	 * @memberof BX
	 */
	var ZIndexManager = /*#__PURE__*/function () {
	  function ZIndexManager() {
	    babelHelpers.classCallCheck(this, ZIndexManager);
	  }

	  babelHelpers.createClass(ZIndexManager, null, [{
	    key: "register",
	    value: function register(element) {
	      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

	      var parentNode = _classStaticPrivateMethodGet(this, ZIndexManager, _getParentNode).call(this, element);

	      if (!parentNode) {
	        return null;
	      }

	      var stack = this.getOrAddStack(parentNode);
	      return stack.register(element, options);
	    }
	  }, {
	    key: "unregister",
	    value: function unregister(element) {
	      var parentNode = _classStaticPrivateMethodGet(this, ZIndexManager, _getParentNode).call(this, element);

	      var stack = this.getStack(parentNode);

	      if (stack) {
	        stack.unregister(element);
	      }
	    }
	  }, {
	    key: "addStack",
	    value: function addStack(container) {
	      var stack = new ZIndexStack(container);
	      this.stacks.set(container, stack);
	      return stack;
	    }
	  }, {
	    key: "getStack",
	    value: function getStack(container) {
	      return this.stacks.get(container) || null;
	    }
	  }, {
	    key: "getOrAddStack",
	    value: function getOrAddStack(container) {
	      return this.getStack(container) || this.addStack(container);
	    }
	  }, {
	    key: "getComponent",
	    value: function getComponent(element) {
	      var parentNode = _classStaticPrivateMethodGet(this, ZIndexManager, _getParentNode).call(this, element, true);

	      if (!parentNode) {
	        return null;
	      }

	      var stack = this.getStack(parentNode);
	      return stack ? stack.getComponent(element) : null;
	    }
	  }, {
	    key: "bringToFront",
	    value: function bringToFront(element) {
	      var parentNode = _classStaticPrivateMethodGet(this, ZIndexManager, _getParentNode).call(this, element);

	      var stack = this.getStack(parentNode);

	      if (stack) {
	        return stack.bringToFront(element);
	      }

	      return null;
	    }
	  }]);
	  return ZIndexManager;
	}();

	function _getParentNode(element) {
	  var suppressWarnings = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

	  if (!Type.isElementNode(element)) {
	    if (!suppressWarnings) {
	      console.error('ZIndexManager: The argument \'element\' must be a DOM element.', element);
	    }

	    return null;
	  } else if (!Type.isElementNode(element.parentNode)) {
	    if (!suppressWarnings) {
	      console.error('ZIndexManager: The \'element\' doesn\'t have a parent node.', element);
	    }

	    return null;
	  }

	  return element.parentNode;
	}

	babelHelpers.defineProperty(ZIndexManager, "stacks", new WeakMap());

	function getElement(element) {
	  if (Type.isString(element)) {
	    return document.getElementById(element);
	  }

	  return element;
	}

	function getWindow(element) {
	  if (Type.isElementNode(element)) {
	    return element.ownerDocument.parentWindow || element.ownerDocument.defaultView || window;
	  }

	  if (Type.isDomNode(element)) {
	    return element.parentWindow || element.defaultView || window;
	  }

	  return window;
	}

	/* eslint-disable prefer-rest-params */

	var getClass = Reflection.getClass,
	    namespace = Reflection.namespace;
	var message$1 = message;
	/**
	 * @memberOf BX
	 */

	var replace = Dom.replace,
	    remove = Dom.remove,
	    clean = Dom.clean,
	    insertBefore = Dom.insertBefore,
	    insertAfter = Dom.insertAfter,
	    append = Dom.append,
	    prepend = Dom.prepend,
	    style = Dom.style,
	    adjust = Dom.adjust,
	    create = Dom.create,
	    isShown = Dom.isShown;
	var addClass = function addClass() {
	  Dom.addClass.apply(Dom, babelHelpers.toConsumableArray(Runtime.merge([], Array.from(arguments), [getElement(arguments[0])])));
	};
	var removeClass = function removeClass() {
	  Dom.removeClass.apply(Dom, babelHelpers.toConsumableArray(Runtime.merge(Array.from(arguments), [getElement(arguments[0])])));
	};
	var hasClass = function hasClass() {
	  return Dom.hasClass.apply(Dom, babelHelpers.toConsumableArray(Runtime.merge(Array.from(arguments), [getElement(arguments[0])])));
	};
	var toggleClass = function toggleClass() {
	  Dom.toggleClass.apply(Dom, babelHelpers.toConsumableArray(Runtime.merge(Array.from(arguments), [getElement(arguments[0])])));
	};
	var cleanNode = function cleanNode(element) {
	  var removeElement = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
	  var currentElement = getElement(element);

	  if (Type.isDomNode(currentElement)) {
	    Dom.clean(currentElement);

	    if (removeElement) {
	      Dom.remove(currentElement);
	      return currentElement;
	    }
	  }

	  return currentElement;
	};
	var getCookie = Http.Cookie.get;
	var setCookie = function setCookie(name, value) {
	  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
	  var attributes = babelHelpers.objectSpread({}, options);

	  if (Type.isNumber(attributes.expires)) {
	    attributes.expires /= 3600 * 24;
	  }

	  Http.Cookie.set(name, value, attributes);
	};
	var bind$1 = Event.bind,
	    unbind$1 = Event.unbind,
	    unbindAll$1 = Event.unbindAll,
	    bindOnce$1 = Event.bindOnce,
	    ready$1 = Event.ready;
	var debugEnableFlag = debugState,
	    debugStatus = isDebugEnabled,
	    debug$1 = debug;
	var debugEnable = function debugEnable(value) {
	  if (value) {
	    enableDebug();
	  } else {
	    disableDebug();
	  }
	};
	var clone$1 = Runtime.clone,
	    loadExt = Runtime.loadExtension,
	    debounce = Runtime.debounce,
	    throttle = Runtime.throttle,
	    html = Runtime.html; // BX.type
	var type = babelHelpers.objectSpread({}, Object.getOwnPropertyNames(Type).filter(function (key) {
	  return !['name', 'length', 'prototype', 'caller', 'arguments'].includes(key);
	}).reduce(function (acc, key) {
	  acc[key] = Type[key];
	  return acc;
	}, {}), {
	  isNotEmptyString: function isNotEmptyString(value) {
	    return Type.isString(value) && value !== '';
	  },
	  isNotEmptyObject: function isNotEmptyObject(value) {
	    return Type.isObjectLike(value) && Object.keys(value).length > 0;
	  },
	  isMapKey: Type.isObject,
	  stringToInt: function stringToInt(value) {
	    var parsed = parseInt(value);
	    return !Number.isNaN(parsed) ? parsed : 0;
	  }
	}); // BX.browser

	var browser = {
	  IsOpera: Browser.isOpera,
	  IsIE: Browser.isIE,
	  IsIE6: Browser.isIE6,
	  IsIE7: Browser.isIE7,
	  IsIE8: Browser.isIE8,
	  IsIE9: Browser.isIE9,
	  IsIE10: Browser.isIE10,
	  IsIE11: Browser.isIE11,
	  IsSafari: Browser.isSafari,
	  IsFirefox: Browser.isFirefox,
	  IsChrome: Browser.isChrome,
	  DetectIeVersion: Browser.detectIEVersion,
	  IsMac: Browser.isMac,
	  IsAndroid: Browser.isAndroid,
	  isIPad: Browser.isIPad,
	  isIPhone: Browser.isIPhone,
	  IsIOS: Browser.isIOS,
	  IsMobile: Browser.isMobile,
	  isRetina: Browser.isRetina,
	  IsDoctype: Browser.isDoctype,
	  SupportLocalStorage: Browser.isLocalStorageSupported,
	  addGlobalClass: Browser.addGlobalClass,
	  DetectAndroidVersion: Browser.detectAndroidVersion,
	  isPropertySupported: Browser.isPropertySupported,
	  addGlobalFeatures: Browser.addGlobalFeatures
	}; // eslint-disable-next-line

	var ajax = window.BX ? window.BX.ajax : function () {};
	function GetWindowScrollSize() {
	  var doc = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : document;
	  return {
	    scrollWidth: doc.documentElement.scrollWidth,
	    scrollHeight: doc.documentElement.scrollHeight
	  };
	}
	function GetWindowScrollPos() {
	  var doc = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : document;
	  var win = getWindow(doc);
	  return {
	    scrollLeft: win.pageXOffset,
	    scrollTop: win.pageYOffset
	  };
	}
	function GetWindowInnerSize() {
	  var doc = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : document;
	  var win = getWindow(doc);
	  return {
	    innerWidth: win.innerWidth,
	    innerHeight: win.innerHeight
	  };
	}
	function GetWindowSize() {
	  var doc = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : document;
	  return babelHelpers.objectSpread({}, GetWindowInnerSize(doc), GetWindowScrollPos(doc), GetWindowScrollSize(doc));
	}
	function GetContext(node) {
	  return getWindow(node);
	}
	function pos(element) {
	  var relative = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

	  if (!element) {
	    return new DOMRect().toJSON();
	  }

	  if (element.ownerDocument === document && !relative) {
	    var clientRect = element.getBoundingClientRect();
	    var root = document.documentElement;
	    var _document = document,
	        body = _document.body;
	    return {
	      top: Math.round(clientRect.top + (root.scrollTop || body.scrollTop)),
	      left: Math.round(clientRect.left + (root.scrollLeft || body.scrollLeft)),
	      width: Math.round(clientRect.right - clientRect.left),
	      height: Math.round(clientRect.bottom - clientRect.top),
	      right: Math.round(clientRect.right + (root.scrollLeft || body.scrollLeft)),
	      bottom: Math.round(clientRect.bottom + (root.scrollTop || body.scrollTop))
	    };
	  }

	  var x = 0;
	  var y = 0;
	  var w = element.offsetWidth;
	  var h = element.offsetHeight;
	  var first = true; // eslint-disable-next-line no-param-reassign

	  for (; element != null; element = element.offsetParent) {
	    if (!first && relative && BX.is_relative(element)) {
	      break;
	    }

	    x += element.offsetLeft;
	    y += element.offsetTop;

	    if (first) {
	      first = false; // eslint-disable-next-line no-continue

	      continue;
	    }

	    x += Text.toNumber(Dom.style(element, 'border-left-width'));
	    y += Text.toNumber(Dom.style(element, 'border-top-width'));
	  }

	  return new DOMRect(x, y, w, h).toJSON();
	}
	function addCustomEvent(eventObject, eventName, eventHandler) {
	  if (Type.isString(eventObject)) {
	    eventHandler = eventName;
	    eventName = eventObject;
	    eventObject = EventEmitter.GLOBAL_TARGET;
	  }

	  if (eventObject === window) {
	    eventObject = EventEmitter.GLOBAL_TARGET;
	  }

	  if (!Type.isObject(eventObject)) {
	    console.error('The "eventObject" argument must be an object. Received type ' + babelHelpers.typeof(eventObject) + '.');
	    return;
	  }

	  if (!Type.isStringFilled(eventName)) {
	    console.error('The "eventName" argument must be a string.');
	    return;
	  }

	  if (!Type.isFunction(eventHandler)) {
	    console.error('The "eventHandler" argument must be a function. Received type ' + babelHelpers.typeof(eventHandler) + '.');
	    return;
	  }

	  eventName = eventName.toLowerCase();
	  EventEmitter.subscribe(eventObject, eventName, eventHandler, {
	    compatMode: true,
	    useGlobalNaming: true
	  });
	}
	function onCustomEvent(eventObject, eventName, eventParams, secureParams) {
	  if (Type.isString(eventObject)) {
	    secureParams = eventParams;
	    eventParams = eventName;
	    eventName = eventObject;
	    eventObject = EventEmitter.GLOBAL_TARGET;
	  }

	  if (!Type.isObject(eventObject) || eventObject === window) {
	    eventObject = EventEmitter.GLOBAL_TARGET;
	  }

	  if (!eventParams) {
	    eventParams = [];
	  }

	  eventName = eventName.toLowerCase();
	  var event = new BaseEvent();
	  event.setData(eventParams);
	  event.setCompatData(eventParams);
	  EventEmitter.emit(eventObject, eventName, event, {
	    cloneData: secureParams === true,
	    useGlobalNaming: true
	  });
	}
	function removeCustomEvent(eventObject, eventName, eventHandler) {
	  if (Type.isString(eventObject)) {
	    eventHandler = eventName;
	    eventName = eventObject;
	    eventObject = EventEmitter.GLOBAL_TARGET;
	  }

	  if (!Type.isFunction(eventHandler)) {
	    console.error('The "eventHandler" argument must be a function. Received type ' + babelHelpers.typeof(eventHandler) + '.');
	    return;
	  }

	  if (eventObject === window) {
	    eventObject = EventEmitter.GLOBAL_TARGET;
	  }

	  eventName = eventName.toLowerCase();
	  EventEmitter.unsubscribe(eventObject, eventName, eventHandler, {
	    useGlobalNaming: true
	  });
	}
	function removeAllCustomEvents(eventObject, eventName) {
	  if (Type.isString(eventObject)) {
	    eventName = eventObject;
	    eventObject = EventEmitter.GLOBAL_TARGET;
	  }

	  if (eventObject === window) {
	    eventObject = EventEmitter.GLOBAL_TARGET;
	  }

	  eventName = eventName.toLowerCase();
	  EventEmitter.unsubscribeAll(eventObject, eventName, {
	    useGlobalNaming: true
	  });
	}

	//import './internal/bx';

	exports.Type = Type;
	exports.Reflection = Reflection;
	exports.Text = Text;
	exports.Dom = Dom;
	exports.Browser = Browser;
	exports.Event = Event;
	exports.Http = Http;
	exports.Runtime = Runtime;
	exports.Loc = Loc;
	exports.Tag = Tag;
	exports.Uri = Uri;
	exports.Validation = Validation;
	exports.Cache = Cache;
	exports.BaseError = BaseError;
	exports.ZIndexManager = ZIndexManager;
	exports.getClass = getClass;
	exports.namespace = namespace;
	exports.message = message$1;
	exports.replace = replace;
	exports.remove = remove;
	exports.clean = clean;
	exports.insertBefore = insertBefore;
	exports.insertAfter = insertAfter;
	exports.append = append;
	exports.prepend = prepend;
	exports.style = style;
	exports.adjust = adjust;
	exports.create = create;
	exports.isShown = isShown;
	exports.addClass = addClass;
	exports.removeClass = removeClass;
	exports.hasClass = hasClass;
	exports.toggleClass = toggleClass;
	exports.cleanNode = cleanNode;
	exports.getCookie = getCookie;
	exports.setCookie = setCookie;
	exports.bind = bind$1;
	exports.unbind = unbind$1;
	exports.unbindAll = unbindAll$1;
	exports.bindOnce = bindOnce$1;
	exports.ready = ready$1;
	exports.debugEnableFlag = debugEnableFlag;
	exports.debugStatus = debugStatus;
	exports.debug = debug$1;
	exports.debugEnable = debugEnable;
	exports.clone = clone$1;
	exports.loadExt = loadExt;
	exports.debounce = debounce;
	exports.throttle = throttle;
	exports.html = html;
	exports.type = type;
	exports.browser = browser;
	exports.ajax = ajax;
	exports.GetWindowScrollSize = GetWindowScrollSize;
	exports.GetWindowScrollPos = GetWindowScrollPos;
	exports.GetWindowInnerSize = GetWindowInnerSize;
	exports.GetWindowSize = GetWindowSize;
	exports.GetContext = GetContext;
	exports.pos = pos;
	exports.addCustomEvent = addCustomEvent;
	exports.onCustomEvent = onCustomEvent;
	exports.removeCustomEvent = removeCustomEvent;
	exports.removeAllCustomEvents = removeAllCustomEvents;

}((this.BX = this.BX || {})));



})();
 



// file: /bitrix/js/main/polyfill/customevent/main.polyfill.customevent.js
/**
 * window.CustomEvent polyfill
 */
;(function() {
	'use strict';

	try
	{
		new window.CustomEvent('bx-test-custom-event', {
			bubbles: true,
  			cancelable: true
		});
	}
	catch (exception)
	{
		var CustomEventPolyfill = function(event, params)
		{
			params = params || {};
			params.bubbles = !!params.bubbles;
			params.cancelable = !!params.cancelable;

			var customEvent = document.createEvent('CustomEvent');

			customEvent.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);

			var originalPreventFunction = customEvent.preventDefault;

			customEvent.preventDefault = function()
			{
				Object.defineProperty(this, 'defaultPrevented', {
					get: function() { return true; }
				});

				originalPreventFunction.call(this);
			};

			return customEvent;
		};

		CustomEventPolyfill.prototype = window.Event.prototype;

		window.CustomEvent = CustomEventPolyfill;
	}

})();



// file: /bitrix/js/ui/vue/vue2/prod/dist/vue.bundle.js
;(function() {

	if (typeof this.BX !== 'undefined' && typeof this.BX.WidgetVue !== 'undefined')
	{
		var currentVersion = '2.6.14';

		if (this.BX.WidgetVue.version() !== currentVersion)
		{
			console.warn('BX.WidgetVue already loaded. Loaded: ' + this.BX.WidgetVue.version() + ', Skipped: ' + currentVersion + '. Version differences may cause errors!');
		}

		return;
	}

(function (exports,main_core_events,main_core,rest_client,pull_client) {
	'use strict';

	/**
	 * Bitrix Vue wrapper
	 *
	 * @package bitrix
	 * @subpackage ui
	 * @copyright 2001-2021 Bitrix
	 */
	var BitrixVue = /*#__PURE__*/function () {
	  function BitrixVue(VueVendor) {
	    babelHelpers.classCallCheck(this, BitrixVue);
	    this._appCounter = 0;
	    this._components = {};
	    this._mutations = {};
	    this._clones = {};
	    this._instance = VueVendor;

	    this._instance.use(this);

	    this.event = new VueVendor();
	    this.events = {
	      restClientChange: 'RestClient::change',
	      pullClientChange: 'PullClient::change'
	    };
	  }
	  /**
	   * Create new Vue instance
	   *
	   * @param {Object} params - definition
	   *
	   * @see https://vuejs.org/v2/guide/
	   */


	  babelHelpers.createClass(BitrixVue, [{
	    key: "create",
	    value: function create(params) {
	      BitrixVue.showNotice('Method Vue.create is deprecated, use BitrixVue.createApp instead.\n' + 'If you are using "el" property or .$mount(...) to bind your application, use .mount(...) instead.');
	      return this.createApp(params);
	    }
	    /**
	     * Create new Vue instance
	     *
	     * @param {Object} params - definition
	     *
	     * @see https://vuejs.org/v2/guide/
	     */

	  }, {
	    key: "createApp",
	    value: function createApp(params) {
	      var bitrixVue = this; // 1. Init Bitrix public api

	      var $Bitrix = {}; // 1.1 Localization

	      $Bitrix.Loc = {
	        messages: {},
	        getMessage: function getMessage(messageId) {
	          var replacements = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
	          var message = '';

	          if (!main_core.Type.isUndefined(this.messages[messageId])) {
	            message = this.messages[messageId];
	          } else {
	            message = main_core.Loc.getMessage(messageId);
	            this.messages[messageId] = message;
	          }

	          if (main_core.Type.isString(message) && main_core.Type.isPlainObject(replacements)) {
	            Object.keys(replacements).forEach(function (replacement) {
	              var globalRegexp = new RegExp(replacement, 'gi');
	              message = message.replace(globalRegexp, function () {
	                return main_core.Type.isNil(replacements[replacement]) ? '' : String(replacements[replacement]);
	              });
	            });
	          }

	          return message;
	        },
	        hasMessage: function hasMessage(messageId) {
	          return main_core.Type.isString(messageId) && !main_core.Type.isNil(this.getMessages()[messageId]);
	        },
	        getMessages: function getMessages() {
	          if (typeof BX.message !== 'undefined') {
	            return babelHelpers.objectSpread({}, BX.message, this.messages);
	          }

	          return babelHelpers.objectSpread({}, this.messages);
	        },
	        setMessage: function setMessage(id, value) {
	          if (main_core.Type.isString(id)) {
	            this.messages[id] = value;
	          }

	          if (main_core.Type.isObject(id)) {
	            for (var code in id) {
	              if (id.hasOwnProperty(code)) {
	                this.messages[code] = id[code];
	              }
	            }
	          }
	        }
	      }; // 1.2  Application Data

	      $Bitrix.Application = {
	        instance: null,
	        get: function get() {
	          return this.instance;
	        },
	        set: function set(instance) {
	          this.instance = instance;
	        }
	      }; // 1.3  Application Data

	      $Bitrix.Data = {
	        data: {},
	        get: function get(name, defaultValue) {
	          var _this$data$name;

	          return (_this$data$name = this.data[name]) !== null && _this$data$name !== void 0 ? _this$data$name : defaultValue;
	        },
	        set: function set(name, value) {
	          this.data[name] = value;
	        }
	      }; // 1.4  Application EventEmitter

	      $Bitrix.eventEmitter = new main_core_events.EventEmitter();

	      if (typeof $Bitrix.eventEmitter.setEventNamespace === 'function') {
	        this._appCounter++;
	        $Bitrix.eventEmitter.setEventNamespace('vue:app:' + this._appCounter);
	      } else // hack for old version of Bitrix SM
	        {
	          window.BX.Event.EventEmitter.prototype.setEventNamespace = function () {};

	          $Bitrix.eventEmitter.setEventNamespace = function () {};
	        } // 1.5  Application RestClient


	      $Bitrix.RestClient = {
	        instance: null,
	        get: function get() {
	          var _this$instance;

	          return (_this$instance = this.instance) !== null && _this$instance !== void 0 ? _this$instance : rest_client.rest;
	        },
	        set: function set(instance) {
	          this.instance = instance;
	          $Bitrix.eventEmitter.emit(bitrixVue.events.restClientChange);
	        },
	        isCustom: function isCustom() {
	          return this.instance !== null;
	        }
	      }; // 1.6  Application PullClient

	      $Bitrix.PullClient = {
	        instance: null,
	        get: function get() {
	          var _this$instance2;

	          return (_this$instance2 = this.instance) !== null && _this$instance2 !== void 0 ? _this$instance2 : pull_client.PULL;
	        },
	        set: function set(instance) {
	          this.instance = instance;
	          $Bitrix.eventEmitter.emit(bitrixVue.events.pullClientChange);
	        },
	        isCustom: function isCustom() {
	          return this.instance !== null;
	        }
	      };

	      if (typeof params.mixins === 'undefined') {
	        params.mixins = [];
	      }

	      params.mixins.unshift({
	        beforeCreate: function beforeCreate() {
	          this.$bitrix = $Bitrix;
	        }
	      });
	      var instance = new this._instance(params);

	      instance.mount = function (rootContainer) {
	        return this.$mount(rootContainer);
	      };

	      return instance;
	    }
	    /**
	     * Register Vue component
	     *
	     * @param {String} id
	     * @param {Object} params
	     * @param {Object} [options]
	     *
	     * @see https://vuejs.org/v2/guide/components.html
	     */

	  }, {
	    key: "component",
	    value: function component(id, params) {
	      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

	      if (!params.name) {
	        params.name = id;
	      }

	      this._components[id] = Object.assign({}, params);
	      this._components[id].bitrixOptions = {
	        immutable: options.immutable === true,
	        local: options.local === true
	      };

	      if (typeof this._clones[id] !== 'undefined') {
	        this._registerCloneComponent(id);
	      }

	      var componentParams = this._getFinalComponentParams(id);

	      if (this.isLocal(id)) {
	        return componentParams;
	      }

	      return this._instance.component(id, componentParams);
	    }
	    /**
	     * Register Vue component (local)
	     * @see https://vuejs.org/v2/guide/components.html
	     *
	     * @param {string} name
	     * @param {Object} definition
	     * @param {Object} [options]
	     *
	     * @returns {Object}
	     */

	  }, {
	    key: "localComponent",
	    value: function localComponent(name, definition) {
	      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
	      return this.component(name, definition, babelHelpers.objectSpread({
	        immutable: false
	      }, options, {
	        local: true
	      }));
	    }
	    /**
	     * Get local Vue component
	     * @see https://vuejs.org/v2/guide/components.html
	     *
	     * @param {string} name
	     *
	     * @returns {Object}
	     */

	  }, {
	    key: "getLocalComponent",
	    value: function getLocalComponent(name) {
	      if (!this.isComponent(name)) {
	        BitrixVue.showNotice('Component "' + name + '" is not registered yet.');
	        return null;
	      }

	      if (!this.isLocal(name)) {
	        BitrixVue.showNotice('You cannot get the component "' + name + '" because it is marked as global.');
	        return null;
	      }

	      return this._getFinalComponentParams(name);
	    }
	    /**
	     * Modify Vue component
	     *
	     * @param {String} id
	     * @param {Object} mutations
	     *
	     * @returns {Function|boolean} - function for remove this modification
	     */

	  }, {
	    key: "mutateComponent",
	    value: function mutateComponent(id, mutations) {
	      var _this = this;

	      var mutable = this.isMutable(id);

	      if (mutable === false) {
	        BitrixVue.showNotice('You cannot mutate the component "' + id + '" because it is marked as immutable, perhaps cloning the component is fine for you.');
	        return false;
	      }

	      if (typeof this._mutations[id] === 'undefined') {
	        this._mutations[id] = [];
	      }

	      this._mutations[id].push(mutations);

	      if (typeof this._components[id] !== 'undefined' && !this.isLocal(id)) {
	        this.component(id, this._components[id], this._components[id].bitrixOptions);
	      }

	      return function () {
	        _this._mutations[id] = _this._mutations[id].filter(function (element) {
	          return element !== mutations;
	        });
	      };
	    }
	    /**
	     * Clone Vue component
	     *
	     * @param {string} id
	     * @param {string} sourceId
	     * @param {object} mutations
	     * @returns {boolean}
	     */

	  }, {
	    key: "cloneComponent",
	    value: function cloneComponent(id, sourceId, mutations) {
	      if (this.isLocal(sourceId)) {
	        var definition = this.getLocalComponent(sourceId);
	        definition.name = id;
	        this.component(id, definition, {
	          immutable: false,
	          local: true
	        });
	        this.mutateComponent(id, mutations);
	        return true;
	      }

	      if (typeof this._clones[sourceId] === 'undefined') {
	        this._clones[sourceId] = {};
	      }

	      this._clones[sourceId][id] = {
	        id: id,
	        sourceId: sourceId,
	        mutations: mutations
	      };

	      if (typeof this._components[sourceId] !== 'undefined') {
	        this._registerCloneComponent(sourceId, id);
	      }

	      return true;
	    }
	    /**
	     * Check exists Vue component
	     *
	     * @param {string} id
	     * @returns {boolean}
	     */

	  }, {
	    key: "isComponent",
	    value: function isComponent(id) {
	      return typeof this._components[id] !== 'undefined';
	    }
	    /**
	     * Check able to mutate Vue component
	     *
	     * @param id
	     * @returns {boolean|undefined} - undefined when component not registered yet.
	     */

	  }, {
	    key: "isMutable",
	    value: function isMutable(id) {
	      if (typeof this._components[id] === 'undefined') {
	        return undefined;
	      }

	      return !this._components[id].bitrixOptions.immutable;
	    }
	    /**
	     * Check component is a local
	     *
	     * @param id
	     * @returns {boolean|undefined} - undefined when component not registered yet.
	     */

	  }, {
	    key: "isLocal",
	    value: function isLocal(id) {
	      if (typeof this._components[id] === 'undefined') {
	        return undefined;
	      }

	      return this._components[id].bitrixOptions.local === true;
	    }
	    /**
	     * Create a "subclass" of the base Vue constructor.
	     *
	     * @param options
	     * @returns {*}
	     *
	     * @see https://vuejs.org/v2/api/#Vue-extend
	     */

	  }, {
	    key: "extend",
	    value: function extend(options) {
	      return this._instance.extend(options);
	    }
	    /**
	     *	Defer the callback to be executed after the next DOM update cycle. Use it immediately after you have changed some data to wait for the DOM update.
	     *
	     * @param {Function} callback
	     * @param {Object} context
	     * @returns {Promise|void}
	     *
	     * @see https://vuejs.org/v2/api/#Vue-nextTick
	     */

	  }, {
	    key: "nextTick",
	    value: function nextTick(callback, context) {
	      return this._instance.nextTick(callback, context);
	    }
	    /**
	     * Adds a property to a reactive object, ensuring the new property is also reactive, so triggers view updates.
	     *
	     * @param {Object|Array} target
	     * @param {String|Number} key
	     * @param {*} value
	     * @returns {*}
	     *
	     * @see https://vuejs.org/v2/api/#Vue-set
	     */

	  }, {
	    key: "set",
	    value: function set(target, key, value) {
	      return this._instance.set(target, key, value);
	    }
	    /**
	     * Delete a property on an object. If the object is reactive, ensure the deletion triggers view updates.
	     *
	     * @param {Object|Array} target
	     * @param {String|Number} key
	     * @returns {*}
	     */

	  }, {
	    key: "delete",
	    value: function _delete(target, key) {
	      return this._instance.delete(target, key);
	    }
	    /**
	     * Register or retrieve a global directive.
	     *
	     * @param {String} id
	     * @param {Object|Function} definition
	     * @returns {*}
	     *
	     * @see https://vuejs.org/v2/api/#Vue-directive
	     */

	  }, {
	    key: "directive",
	    value: function directive(id, definition) {
	      return this._instance.directive(id, definition);
	    }
	    /**
	     * Register or retrieve a global filter.
	     *
	     * @param id
	     * @param definition
	     * @returns {*}
	     *
	     * @see https://vuejs.org/v2/api/#Vue-filter
	     */

	  }, {
	    key: "filter",
	    value: function filter(id, definition) {
	      return this._instance.filter(id, definition);
	    }
	    /**
	     * Install a Vue.js plugin.
	     *
	     * @param {Object|Function} plugin
	     * @returns {*}
	     *
	     * @see https://vuejs.org/v2/api/#Vue-use
	     */

	  }, {
	    key: "use",
	    value: function use(plugin) {
	      return this._instance.use(plugin);
	    }
	    /**
	     * Apply a mixin globally, which affects every Vue instance created afterwards.
	     *
	     * @param {Object} mixin
	     * @returns {*|Function|Object}
	     *
	     * @see https://vuejs.org/v2/api/#Vue-mixin
	     */

	  }, {
	    key: "mixin",
	    value: function mixin(_mixin) {
	      return this._instance.mixin(_mixin);
	    }
	    /**
	     * Make an object reactive. Internally, Vue uses this on the object returned by the data function.
	     *
	     * @param object
	     * @returns {*}
	     *
	     * @see https://vuejs.org/v2/api/#Vue-observable
	     */

	  }, {
	    key: "observable",
	    value: function observable(object) {
	      return this._instance.observable(object);
	    }
	    /**
	     * Compiles a template string into a render function.
	     *
	     * @param template
	     * @returns {*}
	     *
	     * @see https://vuejs.org/v2/api/#Vue-compile
	     */

	  }, {
	    key: "compile",
	    value: function compile(template) {
	      return this._instance.compile(template);
	    }
	    /**
	     * Provides the installed version of Vue as a string.
	     *
	     * @returns {String}
	     *
	     * @see https://vuejs.org/v2/api/#Vue-version
	     */

	  }, {
	    key: "version",
	    value: function version() {
	      return this._instance.version;
	    }
	    /**
	     * Test node for compliance with parameters
	     *
	     * @param obj
	     * @param params
	     * @returns {boolean}
	     */

	  }, {
	    key: "testNode",
	    value: function testNode(obj, params) {
	      if (!params || babelHelpers.typeof(params) !== 'object') {
	        return true;
	      }

	      var i, j, len;

	      for (i in params) {
	        if (!params.hasOwnProperty(i)) {
	          continue;
	        }

	        switch (i) {
	          case 'tag':
	          case 'tagName':
	            if (typeof params[i] === "string") {
	              if (obj.tagName.toUpperCase() !== params[i].toUpperCase()) {
	                return false;
	              }
	            } else if (params[i] instanceof RegExp) {
	              if (!params[i].test(obj.tagName)) {
	                return false;
	              }
	            }

	            break;

	          case 'class':
	          case 'className':
	            if (typeof params[i] === "string") {
	              if (!obj.classList.contains(params[i].trim())) {
	                return false;
	              }
	            } else if (params[i] instanceof RegExp) {
	              if (typeof obj.className !== "string" || !params[i].test(obj.className)) {
	                return false;
	              }
	            }

	            break;

	          case 'attr':
	          case 'attrs':
	          case 'attribute':
	            if (typeof params[i] === "string") {
	              if (!obj.getAttribute(params[i])) {
	                return false;
	              }
	            } else if (params[i] && Object.prototype.toString.call(params[i]) === "[object Array]") {
	              for (j = 0, len = params[i].length; j < len; j++) {
	                if (params[i][j] && !obj.getAttribute(params[i][j])) {
	                  return false;
	                }
	              }
	            } else {
	              for (j in params[i]) {
	                if (!params[i].hasOwnProperty(j)) {
	                  continue;
	                }

	                var value = obj.getAttribute(j);

	                if (typeof value !== "string") {
	                  return false;
	                }

	                if (params[i][j] instanceof RegExp) {
	                  if (!params[i][j].test(value)) {
	                    return false;
	                  }
	                } else if (value !== '' + params[i][j]) {
	                  return false;
	                }
	              }
	            }

	            break;

	          case 'property':
	          case 'props':
	            if (typeof params[i] === "string") {
	              if (!obj[params[i]]) {
	                return false;
	              }
	            } else if (params[i] && Object.prototype.toString.call(params[i]) == "[object Array]") {
	              for (j = 0, len = params[i].length; j < len; j++) {
	                if (params[i][j] && !obj[params[i][j]]) {
	                  return false;
	                }
	              }
	            } else {
	              for (j in params[i]) {
	                if (!params[i].hasOwnProperty(j)) {
	                  continue;
	                }

	                if (typeof params[i][j] === "string") {
	                  if (obj[j] != params[i][j]) {
	                    return false;
	                  }
	                } else if (params[i][j] instanceof RegExp) {
	                  if (typeof obj[j] !== "string" || !params[i][j].test(obj[j])) {
	                    return false;
	                  }
	                }
	              }
	            }

	            break;
	        }
	      }

	      return true;
	    }
	    /**
	     * Getting a part of localization object for insertion into computed property.
	     *
	     * @param {String} phrasePrefix
	     * @param {Object|null} phrases
	     * @returns {ReadonlyArray<any>}
	     */

	  }, {
	    key: "getFilteredPhrases",
	    value: function getFilteredPhrases(phrasePrefix) {
	      var phrases = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
	      var result = {};

	      if (!phrases && typeof BX.message !== 'undefined') {
	        phrases = BX.message;
	      } else if (main_core.Type.isObject(phrases) && main_core.Type.isObject(phrases.$Bitrix)) {
	        phrases = phrases.$Bitrix.Loc.getMessages();
	      }

	      if (Array.isArray(phrasePrefix)) {
	        var _loop = function _loop(message) {
	          if (!phrases.hasOwnProperty(message)) {
	            return "continue";
	          }

	          if (!phrasePrefix.find(function (element) {
	            return message.toString().startsWith(element);
	          })) {
	            return "continue";
	          }

	          result[message] = phrases[message];
	        };

	        for (var message in phrases) {
	          var _ret = _loop(message);

	          if (_ret === "continue") continue;
	        }
	      } else {
	        for (var _message in phrases) {
	          if (!phrases.hasOwnProperty(_message)) {
	            continue;
	          }

	          if (!_message.startsWith(phrasePrefix)) {
	            continue;
	          }

	          result[_message] = phrases[_message];
	        }
	      }

	      return Object.freeze(result);
	    }
	    /**
	     * Return component params with mutation
	     *
	     * @param {String} componentId
	     * @param {Object} mutations
	     * @returns {null|Object}
	     *
	     * @private
	     */

	  }, {
	    key: "_getComponentParamsWithMutation",
	    value: function _getComponentParamsWithMutation(componentId, mutations) {
	      var _this2 = this;

	      if (typeof this._components[componentId] === 'undefined') {
	        return null;
	      }

	      var componentParams = Object.assign({}, this._components[componentId]);

	      if (typeof mutations === 'undefined') {
	        return componentParams;
	      }

	      mutations.forEach(function (mutation) {
	        componentParams = _this2._applyMutation(_this2._cloneObjectWithoutDuplicateFunction(componentParams, mutation), mutation);
	      });
	      return componentParams;
	    }
	  }, {
	    key: "_getFinalComponentParams",
	    value: function _getFinalComponentParams(id) {
	      var mutations = this.isMutable(id) ? this._mutations[id] : undefined;
	      return this._getComponentParamsWithMutation(id, mutations);
	    }
	    /**
	     * Register clone of components
	     *
	     * @param {String} sourceId
	     * @param {String|null} [id]
	     *
	     * @private
	     */

	  }, {
	    key: "_registerCloneComponent",
	    value: function _registerCloneComponent(sourceId) {
	      var _this3 = this;

	      var id = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
	      var components = [];

	      if (id) {
	        if (typeof this._clones[sourceId][id] !== 'undefined') {
	          components.push(this._clones[sourceId][id]);
	        }
	      } else {
	        for (var cloneId in this._clones[sourceId]) {
	          if (!this._clones[sourceId].hasOwnProperty(cloneId)) {
	            continue;
	          }

	          components.push(this._clones[sourceId][cloneId]);
	        }
	      }

	      components.forEach(function (element) {
	        var mutations = [];

	        if (typeof _this3._mutations[element.sourceId] !== 'undefined') {
	          mutations = mutations.concat(_this3._mutations[element.sourceId]);
	        }

	        mutations.push(element.mutations);

	        var componentParams = _this3._getComponentParamsWithMutation(element.sourceId, mutations);

	        if (!componentParams) {
	          return false;
	        }

	        _this3.component(element.id, componentParams);
	      });
	    }
	    /**
	     * Clone object without duplicate function for apply mutation
	     *
	     * @param objectParams
	     * @param mutation
	     * @param level
	     * @private
	     */

	  }, {
	    key: "_cloneObjectWithoutDuplicateFunction",
	    value: function _cloneObjectWithoutDuplicateFunction() {
	      var objectParams = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	      var mutation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	      var level = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
	      var object = {};

	      for (var param in objectParams) {
	        if (!objectParams.hasOwnProperty(param)) {
	          continue;
	        }

	        if (typeof objectParams[param] === 'string') {
	          object[param] = objectParams[param];
	        } else if (Object.prototype.toString.call(objectParams[param]) === '[object Array]') {
	          object[param] = [].concat(objectParams[param]);
	        } else if (babelHelpers.typeof(objectParams[param]) === 'object') {
	          if (objectParams[param] === null) {
	            object[param] = null;
	          } else if (babelHelpers.typeof(mutation[param]) === 'object') {
	            object[param] = this._cloneObjectWithoutDuplicateFunction(objectParams[param], mutation[param], level + 1);
	          } else {
	            object[param] = Object.assign({}, objectParams[param]);
	          }
	        } else if (typeof objectParams[param] === 'function') {
	          if (typeof mutation[param] !== 'function') {
	            object[param] = objectParams[param];
	          } else if (level > 1) {
	            object['parent' + param[0].toUpperCase() + param.substr(1)] = objectParams[param];
	          } else {
	            if (typeof object['methods'] === 'undefined') {
	              object['methods'] = {};
	            }

	            object['methods']['parent' + param[0].toUpperCase() + param.substr(1)] = objectParams[param];

	            if (typeof objectParams['methods'] === 'undefined') {
	              objectParams['methods'] = {};
	            }

	            objectParams['methods']['parent' + param[0].toUpperCase() + param.substr(1)] = objectParams[param];
	          }
	        } else if (typeof objectParams[param] !== 'undefined') {
	          object[param] = objectParams[param];
	        }
	      }

	      return object;
	    }
	    /**
	     * Apply mutation
	     *
	     * @param clonedObject
	     * @param mutation
	     * @private
	     */

	  }, {
	    key: "_applyMutation",
	    value: function _applyMutation() {
	      var clonedObject = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	      var mutation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	      var object = Object.assign({}, clonedObject);

	      for (var param in mutation) {
	        if (!mutation.hasOwnProperty(param)) {
	          continue;
	        }

	        if (typeof mutation[param] === 'string') {
	          if (typeof object[param] === 'string') {
	            object[param] = mutation[param].replace("#PARENT_".concat(param.toUpperCase(), "#"), object[param]);
	          } else {
	            object[param] = mutation[param].replace("#PARENT_".concat(param.toUpperCase(), "#"), '');
	          }
	        } else if (Object.prototype.toString.call(mutation[param]) === '[object Array]') {
	          object[param] = [].concat(mutation[param]);
	        } else if (babelHelpers.typeof(mutation[param]) === 'object') {
	          if (babelHelpers.typeof(object[param]) === 'object') {
	            object[param] = this._applyMutation(object[param], mutation[param]);
	          } else {
	            object[param] = mutation[param];
	          }
	        } else {
	          object[param] = mutation[param];
	        }
	      }

	      return object;
	    }
	    /**
	     * @private
	     * @param text
	     */

	  }, {
	    key: "install",

	    /**
	     * @deprecated Special method for plugin registration
	     */
	    value: function install(app, options) {
	      app.mixin({
	        beforeCreate: function beforeCreate() {
	          if (typeof this.$root !== 'undefined') {
	            this.$bitrix = this.$root.$bitrix;
	          }
	        },
	        computed: {
	          $Bitrix: function $Bitrix() {
	            return this.$root.$bitrix;
	          }
	        },
	        mounted: function mounted() {
	          if (!main_core.Type.isNil(this.$root.$bitrixApplication)) {
	            BitrixVue.showNotice("Store reference in global variables (like: this.$bitrixApplication) is deprecated, use this.$Bitrix.Data.set(...) instead.");
	          }

	          if (!main_core.Type.isNil(this.$root.$bitrixController)) {
	            BitrixVue.showNotice("Store reference in global variables (like: this.$bitrixController) is deprecated, use this.$Bitrix.Data.set(...) instead.");
	          }

	          if (!main_core.Type.isNil(this.$root.$bitrixMessages)) {
	            BitrixVue.showNotice("Store localization in global variable this.$bitrixMessages is deprecated, use this.$Bitrix.Log.setMessage(...) instead.");
	          }

	          if (!main_core.Type.isNil(this.$root.$bitrixRestClient)) {
	            BitrixVue.showNotice("Working with a Rest-client through an old variable this.$bitrixRestClient is deprecated, use this.$Bitrix.RestClient.get() instead.");
	          }

	          if (!main_core.Type.isNil(this.$root.$bitrixPullClient)) {
	            BitrixVue.showNotice("Working with a Pull-client through an old variable this.$bitrixPullClient is deprecated, use this.$Bitrix.PullClient.get() instead.");
	          }
	        }
	      });
	    }
	  }], [{
	    key: "showNotice",
	    value: function showNotice(text) {
	      if (BitrixVue.developerMode) {
	        console.warn('BitrixVue: ' + text);
	      }
	    }
	  }]);
	  return BitrixVue;
	}();
	babelHelpers.defineProperty(BitrixVue, "developerMode", false);

	/*!
	 * Vue.js v2.6.14
	 * (c) 2014-2021 Evan You
	 * Released under the MIT License.
	 *
	 * @source: https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.esm.browser.min.js
	 */

	/**
	 * Modify list for integration with Bitrix Framework:
	 * - change default export to local for work in Bitrix CoreJS extensions;
	 */
	var t = Object.freeze({});

	function e(t) {
	  return null == t;
	}

	function n(t) {
	  return null != t;
	}

	function o(t) {
	  return !0 === t;
	}

	function r(t) {
	  return "string" == typeof t || "number" == typeof t || "symbol" == babelHelpers.typeof(t) || "boolean" == typeof t;
	}

	function s(t) {
	  return null !== t && "object" == babelHelpers.typeof(t);
	}

	var i = Object.prototype.toString;

	function a(t) {
	  return "[object Object]" === i.call(t);
	}

	function c(t) {
	  var e = parseFloat(String(t));
	  return e >= 0 && Math.floor(e) === e && isFinite(t);
	}

	function l(t) {
	  return n(t) && "function" == typeof t.then && "function" == typeof t.catch;
	}

	function u(t) {
	  return null == t ? "" : Array.isArray(t) || a(t) && t.toString === i ? JSON.stringify(t, null, 2) : String(t);
	}

	function f(t) {
	  var e = parseFloat(t);
	  return isNaN(e) ? t : e;
	}

	function d(t, e) {
	  var n = Object.create(null),
	      o = t.split(",");

	  for (var _t2 = 0; _t2 < o.length; _t2++) {
	    n[o[_t2]] = !0;
	  }

	  return e ? function (t) {
	    return n[t.toLowerCase()];
	  } : function (t) {
	    return n[t];
	  };
	}

	var p = d("slot,component", !0),
	    h = d("key,ref,slot,slot-scope,is");

	function m(t, e) {
	  if (t.length) {
	    var _n2 = t.indexOf(e);

	    if (_n2 > -1) return t.splice(_n2, 1);
	  }
	}

	var y = Object.prototype.hasOwnProperty;

	function g(t, e) {
	  return y.call(t, e);
	}

	function v(t) {
	  var e = Object.create(null);
	  return function (n) {
	    return e[n] || (e[n] = t(n));
	  };
	}

	var $ = /-(\w)/g,
	    _ = v(function (t) {
	  return t.replace($, function (t, e) {
	    return e ? e.toUpperCase() : "";
	  });
	}),
	    b = v(function (t) {
	  return t.charAt(0).toUpperCase() + t.slice(1);
	}),
	    w = /\B([A-Z])/g,
	    C = v(function (t) {
	  return t.replace(w, "-$1").toLowerCase();
	});

	var x = Function.prototype.bind ? function (t, e) {
	  return t.bind(e);
	} : function (t, e) {
	  function n(n) {
	    var o = arguments.length;
	    return o ? o > 1 ? t.apply(e, arguments) : t.call(e, n) : t.call(e);
	  }

	  return n._length = t.length, n;
	};

	function k(t, e) {
	  e = e || 0;
	  var n = t.length - e;
	  var o = new Array(n);

	  for (; n--;) {
	    o[n] = t[n + e];
	  }

	  return o;
	}

	function A(t, e) {
	  for (var _n3 in e) {
	    t[_n3] = e[_n3];
	  }

	  return t;
	}

	function O(t) {
	  var e = {};

	  for (var _n4 = 0; _n4 < t.length; _n4++) {
	    t[_n4] && A(e, t[_n4]);
	  }

	  return e;
	}

	function S(t, e, n) {}

	var T = function T(t, e, n) {
	  return !1;
	},
	    N = function N(t) {
	  return t;
	};

	function E(t, e) {
	  if (t === e) return !0;
	  var n = s(t),
	      o = s(e);
	  if (!n || !o) return !n && !o && String(t) === String(e);

	  try {
	    var _n5 = Array.isArray(t),
	        _o2 = Array.isArray(e);

	    if (_n5 && _o2) return t.length === e.length && t.every(function (t, n) {
	      return E(t, e[n]);
	    });
	    if (t instanceof Date && e instanceof Date) return t.getTime() === e.getTime();
	    if (_n5 || _o2) return !1;
	    {
	      var _n6 = Object.keys(t),
	          _o3 = Object.keys(e);

	      return _n6.length === _o3.length && _n6.every(function (n) {
	        return E(t[n], e[n]);
	      });
	    }
	  } catch (t) {
	    return !1;
	  }
	}

	function j(t, e) {
	  for (var _n7 = 0; _n7 < t.length; _n7++) {
	    if (E(t[_n7], e)) return _n7;
	  }

	  return -1;
	}

	function D(t) {
	  var e = !1;
	  return function () {
	    e || (e = !0, t.apply(this, arguments));
	  };
	}

	var L = "data-server-rendered",
	    I = ["component", "directive", "filter"],
	    M = ["beforeCreate", "created", "beforeMount", "mounted", "beforeUpdate", "updated", "beforeDestroy", "destroyed", "activated", "deactivated", "errorCaptured", "serverPrefetch"];
	var F = {
	  optionMergeStrategies: Object.create(null),
	  silent: !1,
	  productionTip: !1,
	  devtools: !1,
	  performance: !1,
	  errorHandler: null,
	  warnHandler: null,
	  ignoredElements: [],
	  keyCodes: Object.create(null),
	  isReservedTag: T,
	  isReservedAttr: T,
	  isUnknownElement: T,
	  getTagNamespace: S,
	  parsePlatformTagName: N,
	  mustUseProp: T,
	  async: !0,
	  _lifecycleHooks: M
	};
	var P = /a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;

	function R(t) {
	  var e = (t + "").charCodeAt(0);
	  return 36 === e || 95 === e;
	}

	function H(t, e, n, o) {
	  Object.defineProperty(t, e, {
	    value: n,
	    enumerable: !!o,
	    writable: !0,
	    configurable: !0
	  });
	}

	var B = new RegExp("[^".concat(P.source, ".$_\\d]"));
	var U = ("__proto__" in {}),
	    V = "undefined" != typeof window,
	    z = "undefined" != typeof WXEnvironment && !!WXEnvironment.platform,
	    K = z && WXEnvironment.platform.toLowerCase(),
	    J = V && window.navigator.userAgent.toLowerCase(),
	    q = J && /msie|trident/.test(J),
	    W = J && J.indexOf("msie 9.0") > 0,
	    Z = J && J.indexOf("edge/") > 0,
	    G = (J && J.indexOf("android"), J && /iphone|ipad|ipod|ios/.test(J) || "ios" === K),
	    X = (J && /chrome\/\d+/.test(J), J && /phantomjs/.test(J), J && J.match(/firefox\/(\d+)/)),
	    Y = {}.watch;
	var Q,
	    tt = !1;
	if (V) try {
	  var _t3 = {};
	  Object.defineProperty(_t3, "passive", {
	    get: function get() {
	      tt = !0;
	    }
	  }), window.addEventListener("test-passive", null, _t3);
	} catch (t) {}

	var et = function et() {
	  return void 0 === Q && (Q = !V && !z && "undefined" != typeof global && global.process && "server" === global.process.env.VUE_ENV), Q;
	},
	    nt = V && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;

	function ot(t) {
	  return "function" == typeof t && /native code/.test(t.toString());
	}

	var rt = "undefined" != typeof Symbol && ot(Symbol) && "undefined" != typeof Reflect && ot(Reflect.ownKeys);
	var st;
	st = "undefined" != typeof Set && ot(Set) ? Set : /*#__PURE__*/function () {
	  function _class() {
	    babelHelpers.classCallCheck(this, _class);
	    this.set = Object.create(null);
	  }

	  babelHelpers.createClass(_class, [{
	    key: "has",
	    value: function has(t) {
	      return !0 === this.set[t];
	    }
	  }, {
	    key: "add",
	    value: function add(t) {
	      this.set[t] = !0;
	    }
	  }, {
	    key: "clear",
	    value: function clear() {
	      this.set = Object.create(null);
	    }
	  }]);
	  return _class;
	}();
	var it = S,
	    at = 0;

	var ct = /*#__PURE__*/function () {
	  function ct() {
	    babelHelpers.classCallCheck(this, ct);
	    this.id = at++, this.subs = [];
	  }

	  babelHelpers.createClass(ct, [{
	    key: "addSub",
	    value: function addSub(t) {
	      this.subs.push(t);
	    }
	  }, {
	    key: "removeSub",
	    value: function removeSub(t) {
	      m(this.subs, t);
	    }
	  }, {
	    key: "depend",
	    value: function depend() {
	      ct.target && ct.target.addDep(this);
	    }
	  }, {
	    key: "notify",
	    value: function notify() {
	      var t = this.subs.slice();

	      for (var _e2 = 0, _n8 = t.length; _e2 < _n8; _e2++) {
	        t[_e2].update();
	      }
	    }
	  }]);
	  return ct;
	}();

	ct.target = null;
	var lt = [];

	function ut(t) {
	  lt.push(t), ct.target = t;
	}

	function ft() {
	  lt.pop(), ct.target = lt[lt.length - 1];
	}

	var dt = /*#__PURE__*/function () {
	  function dt(t, e, n, o, r, s, i, a) {
	    babelHelpers.classCallCheck(this, dt);
	    this.tag = t, this.data = e, this.children = n, this.text = o, this.elm = r, this.ns = void 0, this.context = s, this.fnContext = void 0, this.fnOptions = void 0, this.fnScopeId = void 0, this.key = e && e.key, this.componentOptions = i, this.componentInstance = void 0, this.parent = void 0, this.raw = !1, this.isStatic = !1, this.isRootInsert = !0, this.isComment = !1, this.isCloned = !1, this.isOnce = !1, this.asyncFactory = a, this.asyncMeta = void 0, this.isAsyncPlaceholder = !1;
	  }

	  babelHelpers.createClass(dt, [{
	    key: "child",
	    get: function get() {
	      return this.componentInstance;
	    }
	  }]);
	  return dt;
	}();

	var pt = function pt() {
	  var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
	  var e = new dt();
	  return e.text = t, e.isComment = !0, e;
	};

	function ht(t) {
	  return new dt(void 0, void 0, void 0, String(t));
	}

	function mt(t) {
	  var e = new dt(t.tag, t.data, t.children && t.children.slice(), t.text, t.elm, t.context, t.componentOptions, t.asyncFactory);
	  return e.ns = t.ns, e.isStatic = t.isStatic, e.key = t.key, e.isComment = t.isComment, e.fnContext = t.fnContext, e.fnOptions = t.fnOptions, e.fnScopeId = t.fnScopeId, e.asyncMeta = t.asyncMeta, e.isCloned = !0, e;
	}

	var yt = Array.prototype,
	    gt = Object.create(yt);
	["push", "pop", "shift", "unshift", "splice", "sort", "reverse"].forEach(function (t) {
	  var e = yt[t];
	  H(gt, t, function () {
	    for (var _len = arguments.length, n = new Array(_len), _key = 0; _key < _len; _key++) {
	      n[_key] = arguments[_key];
	    }

	    var o = e.apply(this, n),
	        r = this.__ob__;
	    var s;

	    switch (t) {
	      case "push":
	      case "unshift":
	        s = n;
	        break;

	      case "splice":
	        s = n.slice(2);
	    }

	    return s && r.observeArray(s), r.dep.notify(), o;
	  });
	});
	var vt = Object.getOwnPropertyNames(gt);
	var $t = !0;

	function _t(t) {
	  $t = t;
	}

	var bt = /*#__PURE__*/function () {
	  function bt(t) {
	    babelHelpers.classCallCheck(this, bt);
	    var e;
	    this.value = t, this.dep = new ct(), this.vmCount = 0, H(t, "__ob__", this), Array.isArray(t) ? (U ? (e = gt, t.__proto__ = e) : function (t, e, n) {
	      for (var _o4 = 0, _r2 = n.length; _o4 < _r2; _o4++) {
	        var _r3 = n[_o4];
	        H(t, _r3, e[_r3]);
	      }
	    }(t, gt, vt), this.observeArray(t)) : this.walk(t);
	  }

	  babelHelpers.createClass(bt, [{
	    key: "walk",
	    value: function walk(t) {
	      var e = Object.keys(t);

	      for (var _n9 = 0; _n9 < e.length; _n9++) {
	        Ct(t, e[_n9]);
	      }
	    }
	  }, {
	    key: "observeArray",
	    value: function observeArray(t) {
	      for (var _e3 = 0, _n10 = t.length; _e3 < _n10; _e3++) {
	        wt(t[_e3]);
	      }
	    }
	  }]);
	  return bt;
	}();

	function wt(t, e) {
	  if (!s(t) || t instanceof dt) return;
	  var n;
	  return g(t, "__ob__") && t.__ob__ instanceof bt ? n = t.__ob__ : $t && !et() && (Array.isArray(t) || a(t)) && Object.isExtensible(t) && !t._isVue && (n = new bt(t)), e && n && n.vmCount++, n;
	}

	function Ct(t, e, n, o, r) {
	  var s = new ct(),
	      i = Object.getOwnPropertyDescriptor(t, e);
	  if (i && !1 === i.configurable) return;
	  var a = i && i.get,
	      c = i && i.set;
	  a && !c || 2 !== arguments.length || (n = t[e]);
	  var l = !r && wt(n);
	  Object.defineProperty(t, e, {
	    enumerable: !0,
	    configurable: !0,
	    get: function get() {
	      var e = a ? a.call(t) : n;
	      return ct.target && (s.depend(), l && (l.dep.depend(), Array.isArray(e) && function t(e) {
	        for (var _n11, _o5 = 0, _r4 = e.length; _o5 < _r4; _o5++) {
	          (_n11 = e[_o5]) && _n11.__ob__ && _n11.__ob__.dep.depend(), Array.isArray(_n11) && t(_n11);
	        }
	      }(e))), e;
	    },
	    set: function set(e) {
	      var o = a ? a.call(t) : n;
	      e === o || e != e && o != o || a && !c || (c ? c.call(t, e) : n = e, l = !r && wt(e), s.notify());
	    }
	  });
	}

	function xt(t, e, n) {
	  if (Array.isArray(t) && c(e)) return t.length = Math.max(t.length, e), t.splice(e, 1, n), n;
	  if (e in t && !(e in Object.prototype)) return t[e] = n, n;
	  var o = t.__ob__;
	  return t._isVue || o && o.vmCount ? n : o ? (Ct(o.value, e, n), o.dep.notify(), n) : (t[e] = n, n);
	}

	function kt(t, e) {
	  if (Array.isArray(t) && c(e)) return void t.splice(e, 1);
	  var n = t.__ob__;
	  t._isVue || n && n.vmCount || g(t, e) && (delete t[e], n && n.dep.notify());
	}

	var At = F.optionMergeStrategies;

	function Ot(t, e) {
	  if (!e) return t;
	  var n, o, r;
	  var s = rt ? Reflect.ownKeys(e) : Object.keys(e);

	  for (var _i2 = 0; _i2 < s.length; _i2++) {
	    "__ob__" !== (n = s[_i2]) && (o = t[n], r = e[n], g(t, n) ? o !== r && a(o) && a(r) && Ot(o, r) : xt(t, n, r));
	  }

	  return t;
	}

	function St(t, e, n) {
	  return n ? function () {
	    var o = "function" == typeof e ? e.call(n, n) : e,
	        r = "function" == typeof t ? t.call(n, n) : t;
	    return o ? Ot(o, r) : r;
	  } : e ? t ? function () {
	    return Ot("function" == typeof e ? e.call(this, this) : e, "function" == typeof t ? t.call(this, this) : t);
	  } : e : t;
	}

	function Tt(t, e) {
	  var n = e ? t ? t.concat(e) : Array.isArray(e) ? e : [e] : t;
	  return n ? function (t) {
	    var e = [];

	    for (var _n12 = 0; _n12 < t.length; _n12++) {
	      -1 === e.indexOf(t[_n12]) && e.push(t[_n12]);
	    }

	    return e;
	  }(n) : n;
	}

	function Nt(t, e, n, o) {
	  var r = Object.create(t || null);
	  return e ? A(r, e) : r;
	}

	At.data = function (t, e, n) {
	  return n ? St(t, e, n) : e && "function" != typeof e ? t : St(t, e);
	}, M.forEach(function (t) {
	  At[t] = Tt;
	}), I.forEach(function (t) {
	  At[t + "s"] = Nt;
	}), At.watch = function (t, e, n, o) {
	  if (t === Y && (t = void 0), e === Y && (e = void 0), !e) return Object.create(t || null);
	  if (!t) return e;
	  var r = {};
	  A(r, t);

	  for (var _t4 in e) {
	    var _n13 = r[_t4];
	    var _o6 = e[_t4];
	    _n13 && !Array.isArray(_n13) && (_n13 = [_n13]), r[_t4] = _n13 ? _n13.concat(_o6) : Array.isArray(_o6) ? _o6 : [_o6];
	  }

	  return r;
	}, At.props = At.methods = At.inject = At.computed = function (t, e, n, o) {
	  if (!t) return e;
	  var r = Object.create(null);
	  return A(r, t), e && A(r, e), r;
	}, At.provide = St;

	var Et = function Et(t, e) {
	  return void 0 === e ? t : e;
	};

	function jt(t, e, n) {
	  if ("function" == typeof e && (e = e.options), function (t, e) {
	    var n = t.props;
	    if (!n) return;
	    var o = {};
	    var r, s, i;
	    if (Array.isArray(n)) for (r = n.length; r--;) {
	      "string" == typeof (s = n[r]) && (o[i = _(s)] = {
	        type: null
	      });
	    } else if (a(n)) for (var _t5 in n) {
	      s = n[_t5], o[i = _(_t5)] = a(s) ? s : {
	        type: s
	      };
	    }
	    t.props = o;
	  }(e), function (t, e) {
	    var n = t.inject;
	    if (!n) return;
	    var o = t.inject = {};
	    if (Array.isArray(n)) for (var _t6 = 0; _t6 < n.length; _t6++) {
	      o[n[_t6]] = {
	        from: n[_t6]
	      };
	    } else if (a(n)) for (var _t7 in n) {
	      var _e4 = n[_t7];
	      o[_t7] = a(_e4) ? A({
	        from: _t7
	      }, _e4) : {
	        from: _e4
	      };
	    }
	  }(e), function (t) {
	    var e = t.directives;
	    if (e) for (var _t8 in e) {
	      var _n14 = e[_t8];
	      "function" == typeof _n14 && (e[_t8] = {
	        bind: _n14,
	        update: _n14
	      });
	    }
	  }(e), !e._base && (e.extends && (t = jt(t, e.extends, n)), e.mixins)) for (var _o7 = 0, _r5 = e.mixins.length; _o7 < _r5; _o7++) {
	    t = jt(t, e.mixins[_o7], n);
	  }
	  var o = {};
	  var r;

	  for (r in t) {
	    s(r);
	  }

	  for (r in e) {
	    g(t, r) || s(r);
	  }

	  function s(r) {
	    var s = At[r] || Et;
	    o[r] = s(t[r], e[r], n, r);
	  }

	  return o;
	}

	function Dt(t, e, n, o) {
	  if ("string" != typeof n) return;
	  var r = t[e];
	  if (g(r, n)) return r[n];

	  var s = _(n);

	  if (g(r, s)) return r[s];
	  var i = b(s);
	  return g(r, i) ? r[i] : r[n] || r[s] || r[i];
	}

	function Lt(t, e, n, o) {
	  var r = e[t],
	      s = !g(n, t);
	  var i = n[t];
	  var a = Pt(Boolean, r.type);
	  if (a > -1) if (s && !g(r, "default")) i = !1;else if ("" === i || i === C(t)) {
	    var _t9 = Pt(String, r.type);

	    (_t9 < 0 || a < _t9) && (i = !0);
	  }

	  if (void 0 === i) {
	    i = function (t, e, n) {
	      if (!g(e, "default")) return;
	      var o = e.default;
	      if (t && t.$options.propsData && void 0 === t.$options.propsData[n] && void 0 !== t._props[n]) return t._props[n];
	      return "function" == typeof o && "Function" !== Mt(e.type) ? o.call(t) : o;
	    }(o, r, t);

	    var _e5 = $t;
	    _t(!0), wt(i), _t(_e5);
	  }

	  return i;
	}

	var It = /^\s*function (\w+)/;

	function Mt(t) {
	  var e = t && t.toString().match(It);
	  return e ? e[1] : "";
	}

	function Ft(t, e) {
	  return Mt(t) === Mt(e);
	}

	function Pt(t, e) {
	  if (!Array.isArray(e)) return Ft(e, t) ? 0 : -1;

	  for (var _n15 = 0, _o8 = e.length; _n15 < _o8; _n15++) {
	    if (Ft(e[_n15], t)) return _n15;
	  }

	  return -1;
	}

	function Rt(t, e, n) {
	  ut();

	  try {
	    if (e) {
	      var _o9 = e;

	      for (; _o9 = _o9.$parent;) {
	        var _r6 = _o9.$options.errorCaptured;
	        if (_r6) for (var _s2 = 0; _s2 < _r6.length; _s2++) {
	          try {
	            if (!1 === _r6[_s2].call(_o9, t, e, n)) return;
	          } catch (t) {
	            Bt(t, _o9, "errorCaptured hook");
	          }
	        }
	      }
	    }

	    Bt(t, e, n);
	  } finally {
	    ft();
	  }
	}

	function Ht(t, e, n, o, r) {
	  var s;

	  try {
	    (s = n ? t.apply(e, n) : t.call(e)) && !s._isVue && l(s) && !s._handled && (s.catch(function (t) {
	      return Rt(t, o, r + " (Promise/async)");
	    }), s._handled = !0);
	  } catch (t) {
	    Rt(t, o, r);
	  }

	  return s;
	}

	function Bt(t, e, n) {
	  if (F.errorHandler) try {
	    return F.errorHandler.call(null, t, e, n);
	  } catch (e) {
	    e !== t && Ut(e, null, "config.errorHandler");
	  }
	  Ut(t, e, n);
	}

	function Ut(t, e, n) {
	  if (!V && !z || "undefined" == typeof console) throw t;
	  console.error(t);
	}

	var Vt = !1;
	var zt = [];
	var Kt,
	    Jt = !1;

	function qt() {
	  Jt = !1;
	  var t = zt.slice(0);
	  zt.length = 0;

	  for (var _e6 = 0; _e6 < t.length; _e6++) {
	    t[_e6]();
	  }
	}

	if ("undefined" != typeof Promise && ot(Promise)) {
	  var _t10 = Promise.resolve();

	  Kt = function Kt() {
	    _t10.then(qt), G && setTimeout(S);
	  }, Vt = !0;
	} else if (q || "undefined" == typeof MutationObserver || !ot(MutationObserver) && "[object MutationObserverConstructor]" !== MutationObserver.toString()) Kt = "undefined" != typeof setImmediate && ot(setImmediate) ? function () {
	  setImmediate(qt);
	} : function () {
	  setTimeout(qt, 0);
	};else {
	  var _t11 = 1;

	  var _e7 = new MutationObserver(qt),
	      _n16 = document.createTextNode(String(_t11));

	  _e7.observe(_n16, {
	    characterData: !0
	  }), Kt = function Kt() {
	    _t11 = (_t11 + 1) % 2, _n16.data = String(_t11);
	  }, Vt = !0;
	}

	function Wt(t, e) {
	  var n;
	  if (zt.push(function () {
	    if (t) try {
	      t.call(e);
	    } catch (t) {
	      Rt(t, e, "nextTick");
	    } else n && n(e);
	  }), Jt || (Jt = !0, Kt()), !t && "undefined" != typeof Promise) return new Promise(function (t) {
	    n = t;
	  });
	}

	var Zt = new st();

	function Gt(t) {
	  !function t(e, n) {
	    var o, r;
	    var i = Array.isArray(e);
	    if (!i && !s(e) || Object.isFrozen(e) || e instanceof dt) return;

	    if (e.__ob__) {
	      var _t12 = e.__ob__.dep.id;
	      if (n.has(_t12)) return;
	      n.add(_t12);
	    }

	    if (i) for (o = e.length; o--;) {
	      t(e[o], n);
	    } else for (r = Object.keys(e), o = r.length; o--;) {
	      t(e[r[o]], n);
	    }
	  }(t, Zt), Zt.clear();
	}

	var Xt = v(function (t) {
	  var e = "&" === t.charAt(0),
	      n = "~" === (t = e ? t.slice(1) : t).charAt(0),
	      o = "!" === (t = n ? t.slice(1) : t).charAt(0);
	  return {
	    name: t = o ? t.slice(1) : t,
	    once: n,
	    capture: o,
	    passive: e
	  };
	});

	function Yt(t, e) {
	  function n() {
	    var t = n.fns;
	    if (!Array.isArray(t)) return Ht(t, null, arguments, e, "v-on handler");
	    {
	      var _n17 = t.slice();

	      for (var _t13 = 0; _t13 < _n17.length; _t13++) {
	        Ht(_n17[_t13], null, arguments, e, "v-on handler");
	      }
	    }
	  }

	  return n.fns = t, n;
	}

	function Qt(t, n, r, s, i, a) {
	  var c, l, u, f, d;

	  for (c in t) {
	    l = u = t[c], f = n[c], d = Xt(c), e(u) || (e(f) ? (e(u.fns) && (u = t[c] = Yt(u, a)), o(d.once) && (u = t[c] = i(d.name, u, d.capture)), r(d.name, u, d.capture, d.passive, d.params)) : u !== f && (f.fns = u, t[c] = f));
	  }

	  for (c in n) {
	    e(t[c]) && s((d = Xt(c)).name, n[c], d.capture);
	  }
	}

	function te(t, r, s) {
	  var i;
	  t instanceof dt && (t = t.data.hook || (t.data.hook = {}));
	  var a = t[r];

	  function c() {
	    s.apply(this, arguments), m(i.fns, c);
	  }

	  e(a) ? i = Yt([c]) : n(a.fns) && o(a.merged) ? (i = a).fns.push(c) : i = Yt([a, c]), i.merged = !0, t[r] = i;
	}

	function ee(t, e, o, r, s) {
	  if (n(e)) {
	    if (g(e, o)) return t[o] = e[o], s || delete e[o], !0;
	    if (g(e, r)) return t[o] = e[r], s || delete e[r], !0;
	  }

	  return !1;
	}

	function ne(t) {
	  return r(t) ? [ht(t)] : Array.isArray(t) ? function t(s, i) {
	    var a = [];
	    var c, l, u, f;

	    for (c = 0; c < s.length; c++) {
	      e(l = s[c]) || "boolean" == typeof l || (u = a.length - 1, f = a[u], Array.isArray(l) ? l.length > 0 && (oe((l = t(l, "".concat(i || "", "_").concat(c)))[0]) && oe(f) && (a[u] = ht(f.text + l[0].text), l.shift()), a.push.apply(a, l)) : r(l) ? oe(f) ? a[u] = ht(f.text + l) : "" !== l && a.push(ht(l)) : oe(l) && oe(f) ? a[u] = ht(f.text + l.text) : (o(s._isVList) && n(l.tag) && e(l.key) && n(i) && (l.key = "__vlist".concat(i, "_").concat(c, "__")), a.push(l)));
	    }

	    return a;
	  }(t) : void 0;
	}

	function oe(t) {
	  return n(t) && n(t.text) && !1 === t.isComment;
	}

	function re(t, e) {
	  if (t) {
	    var _n18 = Object.create(null),
	        _o10 = rt ? Reflect.ownKeys(t) : Object.keys(t);

	    for (var _r7 = 0; _r7 < _o10.length; _r7++) {
	      var _s3 = _o10[_r7];
	      if ("__ob__" === _s3) continue;
	      var _i3 = t[_s3].from;
	      var _a = e;

	      for (; _a;) {
	        if (_a._provided && g(_a._provided, _i3)) {
	          _n18[_s3] = _a._provided[_i3];
	          break;
	        }

	        _a = _a.$parent;
	      }

	      if (!_a && "default" in t[_s3]) {
	        var _o11 = t[_s3].default;
	        _n18[_s3] = "function" == typeof _o11 ? _o11.call(e) : _o11;
	      }
	    }

	    return _n18;
	  }
	}

	function se(t, e) {
	  if (!t || !t.length) return {};
	  var n = {};

	  for (var _o12 = 0, _r8 = t.length; _o12 < _r8; _o12++) {
	    var _r9 = t[_o12],
	        _s4 = _r9.data;
	    if (_s4 && _s4.attrs && _s4.attrs.slot && delete _s4.attrs.slot, _r9.context !== e && _r9.fnContext !== e || !_s4 || null == _s4.slot) (n.default || (n.default = [])).push(_r9);else {
	      var _t14 = _s4.slot,
	          _e8 = n[_t14] || (n[_t14] = []);

	      "template" === _r9.tag ? _e8.push.apply(_e8, _r9.children || []) : _e8.push(_r9);
	    }
	  }

	  for (var _t15 in n) {
	    n[_t15].every(ie) && delete n[_t15];
	  }

	  return n;
	}

	function ie(t) {
	  return t.isComment && !t.asyncFactory || " " === t.text;
	}

	function ae(t) {
	  return t.isComment && t.asyncFactory;
	}

	function ce(e, n, o) {
	  var r;
	  var s = Object.keys(n).length > 0,
	      i = e ? !!e.$stable : !s,
	      a = e && e.$key;

	  if (e) {
	    if (e._normalized) return e._normalized;
	    if (i && o && o !== t && a === o.$key && !s && !o.$hasNormal) return o;
	    r = {};

	    for (var _t16 in e) {
	      e[_t16] && "$" !== _t16[0] && (r[_t16] = le(n, _t16, e[_t16]));
	    }
	  } else r = {};

	  for (var _t17 in n) {
	    _t17 in r || (r[_t17] = ue(n, _t17));
	  }

	  return e && Object.isExtensible(e) && (e._normalized = r), H(r, "$stable", i), H(r, "$key", a), H(r, "$hasNormal", s), r;
	}

	function le(t, e, n) {
	  var o = function o() {
	    var t = arguments.length ? n.apply(null, arguments) : n({}),
	        e = (t = t && "object" == babelHelpers.typeof(t) && !Array.isArray(t) ? [t] : ne(t)) && t[0];
	    return t && (!e || 1 === t.length && e.isComment && !ae(e)) ? void 0 : t;
	  };

	  return n.proxy && Object.defineProperty(t, e, {
	    get: o,
	    enumerable: !0,
	    configurable: !0
	  }), o;
	}

	function ue(t, e) {
	  return function () {
	    return t[e];
	  };
	}

	function fe(t, e) {
	  var o, r, i, a, c;
	  if (Array.isArray(t) || "string" == typeof t) for (o = new Array(t.length), r = 0, i = t.length; r < i; r++) {
	    o[r] = e(t[r], r);
	  } else if ("number" == typeof t) for (o = new Array(t), r = 0; r < t; r++) {
	    o[r] = e(r + 1, r);
	  } else if (s(t)) if (rt && t[Symbol.iterator]) {
	    o = [];

	    var _n19 = t[Symbol.iterator]();

	    var _r10 = _n19.next();

	    for (; !_r10.done;) {
	      o.push(e(_r10.value, o.length)), _r10 = _n19.next();
	    }
	  } else for (a = Object.keys(t), o = new Array(a.length), r = 0, i = a.length; r < i; r++) {
	    c = a[r], o[r] = e(t[c], c, r);
	  }
	  return n(o) || (o = []), o._isVList = !0, o;
	}

	function de(t, e, n, o) {
	  var r = this.$scopedSlots[t];
	  var s;
	  r ? (n = n || {}, o && (n = A(A({}, o), n)), s = r(n) || ("function" == typeof e ? e() : e)) : s = this.$slots[t] || ("function" == typeof e ? e() : e);
	  var i = n && n.slot;
	  return i ? this.$createElement("template", {
	    slot: i
	  }, s) : s;
	}

	function pe(t) {
	  return Dt(this.$options, "filters", t) || N;
	}

	function he(t, e) {
	  return Array.isArray(t) ? -1 === t.indexOf(e) : t !== e;
	}

	function me(t, e, n, o, r) {
	  var s = F.keyCodes[e] || n;
	  return r && o && !F.keyCodes[e] ? he(r, o) : s ? he(s, t) : o ? C(o) !== e : void 0 === t;
	}

	function ye(t, e, n, o, r) {
	  if (n) if (s(n)) {
	    var _s5;

	    Array.isArray(n) && (n = O(n));

	    var _loop = function _loop(_i4) {
	      if ("class" === _i4 || "style" === _i4 || h(_i4)) _s5 = t;else {
	        var _n20 = t.attrs && t.attrs.type;

	        _s5 = o || F.mustUseProp(e, _n20, _i4) ? t.domProps || (t.domProps = {}) : t.attrs || (t.attrs = {});
	      }

	      var a = _(_i4),
	          c = C(_i4);

	      if (!(a in _s5 || c in _s5) && (_s5[_i4] = n[_i4], r)) {
	        (t.on || (t.on = {}))["update:".concat(_i4)] = function (t) {
	          n[_i4] = t;
	        };
	      }
	    };

	    for (var _i4 in n) {
	      _loop(_i4);
	    }
	  }
	  return t;
	}

	function ge(t, e) {
	  var n = this._staticTrees || (this._staticTrees = []);
	  var o = n[t];
	  return o && !e ? o : ($e(o = n[t] = this.$options.staticRenderFns[t].call(this._renderProxy, null, this), "__static__".concat(t), !1), o);
	}

	function ve(t, e, n) {
	  return $e(t, "__once__".concat(e).concat(n ? "_".concat(n) : ""), !0), t;
	}

	function $e(t, e, n) {
	  if (Array.isArray(t)) for (var _o13 = 0; _o13 < t.length; _o13++) {
	    t[_o13] && "string" != typeof t[_o13] && _e(t[_o13], "".concat(e, "_").concat(_o13), n);
	  } else _e(t, e, n);
	}

	function _e(t, e, n) {
	  t.isStatic = !0, t.key = e, t.isOnce = n;
	}

	function be(t, e) {
	  if (e) if (a(e)) {
	    var _n21 = t.on = t.on ? A({}, t.on) : {};

	    for (var _t18 in e) {
	      var _o14 = _n21[_t18],
	          _r11 = e[_t18];
	      _n21[_t18] = _o14 ? [].concat(_o14, _r11) : _r11;
	    }
	  }
	  return t;
	}

	function we(t, e, n, o) {
	  e = e || {
	    $stable: !n
	  };

	  for (var _o15 = 0; _o15 < t.length; _o15++) {
	    var _r12 = t[_o15];
	    Array.isArray(_r12) ? we(_r12, e, n) : _r12 && (_r12.proxy && (_r12.fn.proxy = !0), e[_r12.key] = _r12.fn);
	  }

	  return o && (e.$key = o), e;
	}

	function Ce(t, e) {
	  for (var _n22 = 0; _n22 < e.length; _n22 += 2) {
	    var _o16 = e[_n22];
	    "string" == typeof _o16 && _o16 && (t[e[_n22]] = e[_n22 + 1]);
	  }

	  return t;
	}

	function xe(t, e) {
	  return "string" == typeof t ? e + t : t;
	}

	function ke(t) {
	  t._o = ve, t._n = f, t._s = u, t._l = fe, t._t = de, t._q = E, t._i = j, t._m = ge, t._f = pe, t._k = me, t._b = ye, t._v = ht, t._e = pt, t._u = we, t._g = be, t._d = Ce, t._p = xe;
	}

	function Ae(e, n, r, s, i) {
	  var _this = this;

	  var a = i.options;
	  var c;
	  g(s, "_uid") ? (c = Object.create(s))._original = s : (c = s, s = s._original);
	  var l = o(a._compiled),
	      u = !l;
	  this.data = e, this.props = n, this.children = r, this.parent = s, this.listeners = e.on || t, this.injections = re(a.inject, s), this.slots = function () {
	    return _this.$slots || ce(e.scopedSlots, _this.$slots = se(r, s)), _this.$slots;
	  }, Object.defineProperty(this, "scopedSlots", {
	    enumerable: !0,
	    get: function get() {
	      return ce(e.scopedSlots, this.slots());
	    }
	  }), l && (this.$options = a, this.$slots = this.slots(), this.$scopedSlots = ce(e.scopedSlots, this.$slots)), a._scopeId ? this._c = function (t, e, n, o) {
	    var r = Ie(c, t, e, n, o, u);
	    return r && !Array.isArray(r) && (r.fnScopeId = a._scopeId, r.fnContext = s), r;
	  } : this._c = function (t, e, n, o) {
	    return Ie(c, t, e, n, o, u);
	  };
	}

	function Oe(t, e, n, o, r) {
	  var s = mt(t);
	  return s.fnContext = n, s.fnOptions = o, e.slot && ((s.data || (s.data = {})).slot = e.slot), s;
	}

	function Se(t, e) {
	  for (var _n23 in e) {
	    t[_(_n23)] = e[_n23];
	  }
	}

	ke(Ae.prototype);
	var Te = {
	  init: function init(t, e) {
	    if (t.componentInstance && !t.componentInstance._isDestroyed && t.data.keepAlive) {
	      var _e9 = t;
	      Te.prepatch(_e9, _e9);
	    } else {
	      (t.componentInstance = function (t, e) {
	        var o = {
	          _isComponent: !0,
	          _parentVnode: t,
	          parent: e
	        },
	            r = t.data.inlineTemplate;
	        n(r) && (o.render = r.render, o.staticRenderFns = r.staticRenderFns);
	        return new t.componentOptions.Ctor(o);
	      }(t, ze)).$mount(e ? t.elm : void 0, e);
	    }
	  },
	  prepatch: function prepatch(e, n) {
	    var o = n.componentOptions;
	    !function (e, n, o, r, s) {
	      var i = r.data.scopedSlots,
	          a = e.$scopedSlots,
	          c = !!(i && !i.$stable || a !== t && !a.$stable || i && e.$scopedSlots.$key !== i.$key || !i && e.$scopedSlots.$key),
	          l = !!(s || e.$options._renderChildren || c);
	      e.$options._parentVnode = r, e.$vnode = r, e._vnode && (e._vnode.parent = r);

	      if (e.$options._renderChildren = s, e.$attrs = r.data.attrs || t, e.$listeners = o || t, n && e.$options.props) {
	        _t(!1);

	        var _t19 = e._props,
	            _o17 = e.$options._propKeys || [];

	        for (var _r13 = 0; _r13 < _o17.length; _r13++) {
	          var _s6 = _o17[_r13],
	              _i5 = e.$options.props;
	          _t19[_s6] = Lt(_s6, _i5, n, e);
	        }

	        _t(!0), e.$options.propsData = n;
	      }

	      o = o || t;
	      var u = e.$options._parentListeners;
	      e.$options._parentListeners = o, Ve(e, o, u), l && (e.$slots = se(s, r.context), e.$forceUpdate());
	    }(n.componentInstance = e.componentInstance, o.propsData, o.listeners, n, o.children);
	  },
	  insert: function insert(t) {
	    var e = t.context,
	        n = t.componentInstance;
	    var o;
	    n._isMounted || (n._isMounted = !0, We(n, "mounted")), t.data.keepAlive && (e._isMounted ? ((o = n)._inactive = !1, Ge.push(o)) : qe(n, !0));
	  },
	  destroy: function destroy(t) {
	    var e = t.componentInstance;
	    e._isDestroyed || (t.data.keepAlive ? function t(e, n) {
	      if (n && (e._directInactive = !0, Je(e))) return;

	      if (!e._inactive) {
	        e._inactive = !0;

	        for (var _n24 = 0; _n24 < e.$children.length; _n24++) {
	          t(e.$children[_n24]);
	        }

	        We(e, "deactivated");
	      }
	    }(e, !0) : e.$destroy());
	  }
	},
	    Ne = Object.keys(Te);

	function Ee(r, i, a, c, u) {
	  if (e(r)) return;
	  var f = a.$options._base;
	  if (s(r) && (r = f.extend(r)), "function" != typeof r) return;
	  var d;
	  if (e(r.cid) && void 0 === (r = function (t, r) {
	    if (o(t.error) && n(t.errorComp)) return t.errorComp;
	    if (n(t.resolved)) return t.resolved;
	    var i = Fe;
	    i && n(t.owners) && -1 === t.owners.indexOf(i) && t.owners.push(i);
	    if (o(t.loading) && n(t.loadingComp)) return t.loadingComp;

	    if (i && !n(t.owners)) {
	      var _o18 = t.owners = [i];

	      var _a2 = !0,
	          _c = null,
	          _u = null;

	      i.$on("hook:destroyed", function () {
	        return m(_o18, i);
	      });

	      var _f = function _f(t) {
	        for (var _t20 = 0, _e10 = _o18.length; _t20 < _e10; _t20++) {
	          _o18[_t20].$forceUpdate();
	        }

	        t && (_o18.length = 0, null !== _c && (clearTimeout(_c), _c = null), null !== _u && (clearTimeout(_u), _u = null));
	      },
	          _d = D(function (e) {
	        t.resolved = Pe(e, r), _a2 ? _o18.length = 0 : _f(!0);
	      }),
	          _p = D(function (e) {
	        n(t.errorComp) && (t.error = !0, _f(!0));
	      }),
	          _h = t(_d, _p);

	      return s(_h) && (l(_h) ? e(t.resolved) && _h.then(_d, _p) : l(_h.component) && (_h.component.then(_d, _p), n(_h.error) && (t.errorComp = Pe(_h.error, r)), n(_h.loading) && (t.loadingComp = Pe(_h.loading, r), 0 === _h.delay ? t.loading = !0 : _c = setTimeout(function () {
	        _c = null, e(t.resolved) && e(t.error) && (t.loading = !0, _f(!1));
	      }, _h.delay || 200)), n(_h.timeout) && (_u = setTimeout(function () {
	        _u = null, e(t.resolved) && _p(null);
	      }, _h.timeout)))), _a2 = !1, t.loading ? t.loadingComp : t.resolved;
	    }
	  }(d = r, f))) return function (t, e, n, o, r) {
	    var s = pt();
	    return s.asyncFactory = t, s.asyncMeta = {
	      data: e,
	      context: n,
	      children: o,
	      tag: r
	    }, s;
	  }(d, i, a, c, u);
	  i = i || {}, yn(r), n(i.model) && function (t, e) {
	    var o = t.model && t.model.prop || "value",
	        r = t.model && t.model.event || "input";
	    (e.attrs || (e.attrs = {}))[o] = e.model.value;
	    var s = e.on || (e.on = {}),
	        i = s[r],
	        a = e.model.callback;
	    n(i) ? (Array.isArray(i) ? -1 === i.indexOf(a) : i !== a) && (s[r] = [a].concat(i)) : s[r] = a;
	  }(r.options, i);

	  var p = function (t, o, r) {
	    var s = o.options.props;
	    if (e(s)) return;
	    var i = {},
	        a = t.attrs,
	        c = t.props;
	    if (n(a) || n(c)) for (var _t21 in s) {
	      var _e11 = C(_t21);

	      ee(i, c, _t21, _e11, !0) || ee(i, a, _t21, _e11, !1);
	    }
	    return i;
	  }(i, r);

	  if (o(r.options.functional)) return function (e, o, r, s, i) {
	    var a = e.options,
	        c = {},
	        l = a.props;
	    if (n(l)) for (var _e12 in l) {
	      c[_e12] = Lt(_e12, l, o || t);
	    } else n(r.attrs) && Se(c, r.attrs), n(r.props) && Se(c, r.props);
	    var u = new Ae(r, c, i, s, e),
	        f = a.render.call(null, u._c, u);
	    if (f instanceof dt) return Oe(f, r, u.parent, a);

	    if (Array.isArray(f)) {
	      var _t22 = ne(f) || [],
	          _e13 = new Array(_t22.length);

	      for (var _n25 = 0; _n25 < _t22.length; _n25++) {
	        _e13[_n25] = Oe(_t22[_n25], r, u.parent, a);
	      }

	      return _e13;
	    }
	  }(r, p, i, a, c);
	  var h = i.on;

	  if (i.on = i.nativeOn, o(r.options.abstract)) {
	    var _t23 = i.slot;
	    i = {}, _t23 && (i.slot = _t23);
	  }

	  !function (t) {
	    var e = t.hook || (t.hook = {});

	    for (var _t24 = 0; _t24 < Ne.length; _t24++) {
	      var _n26 = Ne[_t24],
	          _o19 = e[_n26],
	          _r14 = Te[_n26];
	      _o19 === _r14 || _o19 && _o19._merged || (e[_n26] = _o19 ? je(_r14, _o19) : _r14);
	    }
	  }(i);
	  var y = r.options.name || u;
	  return new dt("vue-component-".concat(r.cid).concat(y ? "-".concat(y) : ""), i, void 0, void 0, void 0, a, {
	    Ctor: r,
	    propsData: p,
	    listeners: h,
	    tag: u,
	    children: c
	  }, d);
	}

	function je(t, e) {
	  var n = function n(_n27, o) {
	    t(_n27, o), e(_n27, o);
	  };

	  return n._merged = !0, n;
	}

	var De = 1,
	    Le = 2;

	function Ie(t, i, a, c, l, u) {
	  return (Array.isArray(a) || r(a)) && (l = c, c = a, a = void 0), o(u) && (l = Le), function (t, r, i, a, c) {
	    if (n(i) && n(i.__ob__)) return pt();
	    n(i) && n(i.is) && (r = i.is);
	    if (!r) return pt();
	    Array.isArray(a) && "function" == typeof a[0] && ((i = i || {}).scopedSlots = {
	      default: a[0]
	    }, a.length = 0);
	    c === Le ? a = ne(a) : c === De && (a = function (t) {
	      for (var _e14 = 0; _e14 < t.length; _e14++) {
	        if (Array.isArray(t[_e14])) return Array.prototype.concat.apply([], t);
	      }

	      return t;
	    }(a));
	    var l, u;

	    if ("string" == typeof r) {
	      var _e15;

	      u = t.$vnode && t.$vnode.ns || F.getTagNamespace(r), l = F.isReservedTag(r) ? new dt(F.parsePlatformTagName(r), i, a, void 0, void 0, t) : i && i.pre || !n(_e15 = Dt(t.$options, "components", r)) ? new dt(r, i, a, void 0, void 0, t) : Ee(_e15, i, t, a, r);
	    } else l = Ee(r, i, t, a);

	    return Array.isArray(l) ? l : n(l) ? (n(u) && function t(r, s, i) {
	      r.ns = s;
	      "foreignObject" === r.tag && (s = void 0, i = !0);
	      if (n(r.children)) for (var _a3 = 0, _c2 = r.children.length; _a3 < _c2; _a3++) {
	        var _c3 = r.children[_a3];
	        n(_c3.tag) && (e(_c3.ns) || o(i) && "svg" !== _c3.tag) && t(_c3, s, i);
	      }
	    }(l, u), n(i) && function (t) {
	      s(t.style) && Gt(t.style);
	      s(t.class) && Gt(t.class);
	    }(i), l) : pt();
	  }(t, i, a, c, l);
	}

	var Me,
	    Fe = null;

	function Pe(t, e) {
	  return (t.__esModule || rt && "Module" === t[Symbol.toStringTag]) && (t = t.default), s(t) ? e.extend(t) : t;
	}

	function Re(t) {
	  if (Array.isArray(t)) for (var _e16 = 0; _e16 < t.length; _e16++) {
	    var _o20 = t[_e16];
	    if (n(_o20) && (n(_o20.componentOptions) || ae(_o20))) return _o20;
	  }
	}

	function He(t, e) {
	  Me.$on(t, e);
	}

	function Be(t, e) {
	  Me.$off(t, e);
	}

	function Ue(t, e) {
	  var n = Me;
	  return function o() {
	    null !== e.apply(null, arguments) && n.$off(t, o);
	  };
	}

	function Ve(t, e, n) {
	  Me = t, Qt(e, n || {}, He, Be, Ue, t), Me = void 0;
	}

	var ze = null;

	function Ke(t) {
	  var e = ze;
	  return ze = t, function () {
	    ze = e;
	  };
	}

	function Je(t) {
	  for (; t && (t = t.$parent);) {
	    if (t._inactive) return !0;
	  }

	  return !1;
	}

	function qe(t, e) {
	  if (e) {
	    if (t._directInactive = !1, Je(t)) return;
	  } else if (t._directInactive) return;

	  if (t._inactive || null === t._inactive) {
	    t._inactive = !1;

	    for (var _e17 = 0; _e17 < t.$children.length; _e17++) {
	      qe(t.$children[_e17]);
	    }

	    We(t, "activated");
	  }
	}

	function We(t, e) {
	  ut();
	  var n = t.$options[e],
	      o = "".concat(e, " hook");
	  if (n) for (var _e18 = 0, _r15 = n.length; _e18 < _r15; _e18++) {
	    Ht(n[_e18], t, null, t, o);
	  }
	  t._hasHookEvent && t.$emit("hook:" + e), ft();
	}

	var Ze = [],
	    Ge = [];
	var Xe = {},
	    Ye = !1,
	    Qe = !1,
	    tn = 0;
	var en = 0,
	    nn = Date.now;

	if (V && !q) {
	  var _t25 = window.performance;
	  _t25 && "function" == typeof _t25.now && nn() > document.createEvent("Event").timeStamp && (nn = function nn() {
	    return _t25.now();
	  });
	}

	function on() {
	  var t, e;

	  for (en = nn(), Qe = !0, Ze.sort(function (t, e) {
	    return t.id - e.id;
	  }), tn = 0; tn < Ze.length; tn++) {
	    (t = Ze[tn]).before && t.before(), e = t.id, Xe[e] = null, t.run();
	  }

	  var n = Ge.slice(),
	      o = Ze.slice();
	  tn = Ze.length = Ge.length = 0, Xe = {}, Ye = Qe = !1, function (t) {
	    for (var _e19 = 0; _e19 < t.length; _e19++) {
	      t[_e19]._inactive = !0, qe(t[_e19], !0);
	    }
	  }(n), function (t) {
	    var e = t.length;

	    for (; e--;) {
	      var _n28 = t[e],
	          _o21 = _n28.vm;
	      _o21._watcher === _n28 && _o21._isMounted && !_o21._isDestroyed && We(_o21, "updated");
	    }
	  }(o), nt && F.devtools && nt.emit("flush");
	}

	var rn = 0;

	var sn = /*#__PURE__*/function () {
	  function sn(t, e, n, o, r) {
	    babelHelpers.classCallCheck(this, sn);
	    this.vm = t, r && (t._watcher = this), t._watchers.push(this), o ? (this.deep = !!o.deep, this.user = !!o.user, this.lazy = !!o.lazy, this.sync = !!o.sync, this.before = o.before) : this.deep = this.user = this.lazy = this.sync = !1, this.cb = n, this.id = ++rn, this.active = !0, this.dirty = this.lazy, this.deps = [], this.newDeps = [], this.depIds = new st(), this.newDepIds = new st(), this.expression = "", "function" == typeof e ? this.getter = e : (this.getter = function (t) {
	      if (B.test(t)) return;
	      var e = t.split(".");
	      return function (t) {
	        for (var _n29 = 0; _n29 < e.length; _n29++) {
	          if (!t) return;
	          t = t[e[_n29]];
	        }

	        return t;
	      };
	    }(e), this.getter || (this.getter = S)), this.value = this.lazy ? void 0 : this.get();
	  }

	  babelHelpers.createClass(sn, [{
	    key: "get",
	    value: function get() {
	      var t;
	      ut(this);
	      var e = this.vm;

	      try {
	        t = this.getter.call(e, e);
	      } catch (t) {
	        if (!this.user) throw t;
	        Rt(t, e, "getter for watcher \"".concat(this.expression, "\""));
	      } finally {
	        this.deep && Gt(t), ft(), this.cleanupDeps();
	      }

	      return t;
	    }
	  }, {
	    key: "addDep",
	    value: function addDep(t) {
	      var e = t.id;
	      this.newDepIds.has(e) || (this.newDepIds.add(e), this.newDeps.push(t), this.depIds.has(e) || t.addSub(this));
	    }
	  }, {
	    key: "cleanupDeps",
	    value: function cleanupDeps() {
	      var t = this.deps.length;

	      for (; t--;) {
	        var _e20 = this.deps[t];
	        this.newDepIds.has(_e20.id) || _e20.removeSub(this);
	      }

	      var e = this.depIds;
	      this.depIds = this.newDepIds, this.newDepIds = e, this.newDepIds.clear(), e = this.deps, this.deps = this.newDeps, this.newDeps = e, this.newDeps.length = 0;
	    }
	  }, {
	    key: "update",
	    value: function update() {
	      this.lazy ? this.dirty = !0 : this.sync ? this.run() : function (t) {
	        var e = t.id;

	        if (null == Xe[e]) {
	          if (Xe[e] = !0, Qe) {
	            var _e21 = Ze.length - 1;

	            for (; _e21 > tn && Ze[_e21].id > t.id;) {
	              _e21--;
	            }

	            Ze.splice(_e21 + 1, 0, t);
	          } else Ze.push(t);

	          Ye || (Ye = !0, Wt(on));
	        }
	      }(this);
	    }
	  }, {
	    key: "run",
	    value: function run() {
	      if (this.active) {
	        var _t26 = this.get();

	        if (_t26 !== this.value || s(_t26) || this.deep) {
	          var _e22 = this.value;

	          if (this.value = _t26, this.user) {
	            var _n30 = "callback for watcher \"".concat(this.expression, "\"");

	            Ht(this.cb, this.vm, [_t26, _e22], this.vm, _n30);
	          } else this.cb.call(this.vm, _t26, _e22);
	        }
	      }
	    }
	  }, {
	    key: "evaluate",
	    value: function evaluate() {
	      this.value = this.get(), this.dirty = !1;
	    }
	  }, {
	    key: "depend",
	    value: function depend() {
	      var t = this.deps.length;

	      for (; t--;) {
	        this.deps[t].depend();
	      }
	    }
	  }, {
	    key: "teardown",
	    value: function teardown() {
	      if (this.active) {
	        this.vm._isBeingDestroyed || m(this.vm._watchers, this);
	        var _t27 = this.deps.length;

	        for (; _t27--;) {
	          this.deps[_t27].removeSub(this);
	        }

	        this.active = !1;
	      }
	    }
	  }]);
	  return sn;
	}();

	var an = {
	  enumerable: !0,
	  configurable: !0,
	  get: S,
	  set: S
	};

	function cn(t, e, n) {
	  an.get = function () {
	    return this[e][n];
	  }, an.set = function (t) {
	    this[e][n] = t;
	  }, Object.defineProperty(t, n, an);
	}

	function ln(t) {
	  t._watchers = [];
	  var e = t.$options;
	  e.props && function (t, e) {
	    var n = t.$options.propsData || {},
	        o = t._props = {},
	        r = t.$options._propKeys = [];
	    t.$parent && _t(!1);

	    for (var _s7 in e) {
	      r.push(_s7);

	      var _i6 = Lt(_s7, e, n, t);

	      Ct(o, _s7, _i6), _s7 in t || cn(t, "_props", _s7);
	    }

	    _t(!0);
	  }(t, e.props), e.methods && function (t, e) {
	    t.$options.props;

	    for (var _n31 in e) {
	      t[_n31] = "function" != typeof e[_n31] ? S : x(e[_n31], t);
	    }
	  }(t, e.methods), e.data ? function (t) {
	    var e = t.$options.data;
	    a(e = t._data = "function" == typeof e ? function (t, e) {
	      ut();

	      try {
	        return t.call(e, e);
	      } catch (t) {
	        return Rt(t, e, "data()"), {};
	      } finally {
	        ft();
	      }
	    }(e, t) : e || {}) || (e = {});
	    var n = Object.keys(e),
	        o = t.$options.props;
	    t.$options.methods;
	    var r = n.length;

	    for (; r--;) {
	      var _e23 = n[r];
	      o && g(o, _e23) || R(_e23) || cn(t, "_data", _e23);
	    }

	    wt(e, !0);
	  }(t) : wt(t._data = {}, !0), e.computed && function (t, e) {
	    var n = t._computedWatchers = Object.create(null),
	        o = et();

	    for (var _r16 in e) {
	      var _s8 = e[_r16],
	          _i7 = "function" == typeof _s8 ? _s8 : _s8.get;

	      o || (n[_r16] = new sn(t, _i7 || S, S, un)), _r16 in t || fn(t, _r16, _s8);
	    }
	  }(t, e.computed), e.watch && e.watch !== Y && function (t, e) {
	    for (var _n32 in e) {
	      var _o22 = e[_n32];
	      if (Array.isArray(_o22)) for (var _e24 = 0; _e24 < _o22.length; _e24++) {
	        hn(t, _n32, _o22[_e24]);
	      } else hn(t, _n32, _o22);
	    }
	  }(t, e.watch);
	}

	var un = {
	  lazy: !0
	};

	function fn(t, e, n) {
	  var o = !et();
	  "function" == typeof n ? (an.get = o ? dn(e) : pn(n), an.set = S) : (an.get = n.get ? o && !1 !== n.cache ? dn(e) : pn(n.get) : S, an.set = n.set || S), Object.defineProperty(t, e, an);
	}

	function dn(t) {
	  return function () {
	    var e = this._computedWatchers && this._computedWatchers[t];
	    if (e) return e.dirty && e.evaluate(), ct.target && e.depend(), e.value;
	  };
	}

	function pn(t) {
	  return function () {
	    return t.call(this, this);
	  };
	}

	function hn(t, e, n, o) {
	  return a(n) && (o = n, n = n.handler), "string" == typeof n && (n = t[n]), t.$watch(e, n, o);
	}

	var mn = 0;

	function yn(t) {
	  var e = t.options;

	  if (t.super) {
	    var _n33 = yn(t.super);

	    if (_n33 !== t.superOptions) {
	      t.superOptions = _n33;

	      var _o23 = function (t) {
	        var e;
	        var n = t.options,
	            o = t.sealedOptions;

	        for (var _t28 in n) {
	          n[_t28] !== o[_t28] && (e || (e = {}), e[_t28] = n[_t28]);
	        }

	        return e;
	      }(t);

	      _o23 && A(t.extendOptions, _o23), (e = t.options = jt(_n33, t.extendOptions)).name && (e.components[e.name] = t);
	    }
	  }

	  return e;
	}

	function gn(t) {
	  this._init(t);
	}

	function vn(t) {
	  t.cid = 0;
	  var e = 1;

	  t.extend = function (t) {
	    t = t || {};
	    var n = this,
	        o = n.cid,
	        r = t._Ctor || (t._Ctor = {});
	    if (r[o]) return r[o];

	    var s = t.name || n.options.name,
	        i = function i(t) {
	      this._init(t);
	    };

	    return (i.prototype = Object.create(n.prototype)).constructor = i, i.cid = e++, i.options = jt(n.options, t), i.super = n, i.options.props && function (t) {
	      var e = t.options.props;

	      for (var _n34 in e) {
	        cn(t.prototype, "_props", _n34);
	      }
	    }(i), i.options.computed && function (t) {
	      var e = t.options.computed;

	      for (var _n35 in e) {
	        fn(t.prototype, _n35, e[_n35]);
	      }
	    }(i), i.extend = n.extend, i.mixin = n.mixin, i.use = n.use, I.forEach(function (t) {
	      i[t] = n[t];
	    }), s && (i.options.components[s] = i), i.superOptions = n.options, i.extendOptions = t, i.sealedOptions = A({}, i.options), r[o] = i, i;
	  };
	}

	function $n(t) {
	  return t && (t.Ctor.options.name || t.tag);
	}

	function _n(t, e) {
	  return Array.isArray(t) ? t.indexOf(e) > -1 : "string" == typeof t ? t.split(",").indexOf(e) > -1 : (n = t, "[object RegExp]" === i.call(n) && t.test(e));
	  var n;
	}

	function bn(t, e) {
	  var n = t.cache,
	      o = t.keys,
	      r = t._vnode;

	  for (var _t29 in n) {
	    var _s9 = n[_t29];

	    if (_s9) {
	      var _i8 = _s9.name;
	      _i8 && !e(_i8) && wn(n, _t29, o, r);
	    }
	  }
	}

	function wn(t, e, n, o) {
	  var r = t[e];
	  !r || o && r.tag === o.tag || r.componentInstance.$destroy(), t[e] = null, m(n, e);
	}

	!function (e) {
	  e.prototype._init = function (e) {
	    var n = this;
	    n._uid = mn++, n._isVue = !0, e && e._isComponent ? function (t, e) {
	      var n = t.$options = Object.create(t.constructor.options),
	          o = e._parentVnode;
	      n.parent = e.parent, n._parentVnode = o;
	      var r = o.componentOptions;
	      n.propsData = r.propsData, n._parentListeners = r.listeners, n._renderChildren = r.children, n._componentTag = r.tag, e.render && (n.render = e.render, n.staticRenderFns = e.staticRenderFns);
	    }(n, e) : n.$options = jt(yn(n.constructor), e || {}, n), n._renderProxy = n, n._self = n, function (t) {
	      var e = t.$options;
	      var n = e.parent;

	      if (n && !e.abstract) {
	        for (; n.$options.abstract && n.$parent;) {
	          n = n.$parent;
	        }

	        n.$children.push(t);
	      }

	      t.$parent = n, t.$root = n ? n.$root : t, t.$children = [], t.$refs = {}, t._watcher = null, t._inactive = null, t._directInactive = !1, t._isMounted = !1, t._isDestroyed = !1, t._isBeingDestroyed = !1;
	    }(n), function (t) {
	      t._events = Object.create(null), t._hasHookEvent = !1;
	      var e = t.$options._parentListeners;
	      e && Ve(t, e);
	    }(n), function (e) {
	      e._vnode = null, e._staticTrees = null;
	      var n = e.$options,
	          o = e.$vnode = n._parentVnode,
	          r = o && o.context;
	      e.$slots = se(n._renderChildren, r), e.$scopedSlots = t, e._c = function (t, n, o, r) {
	        return Ie(e, t, n, o, r, !1);
	      }, e.$createElement = function (t, n, o, r) {
	        return Ie(e, t, n, o, r, !0);
	      };
	      var s = o && o.data;
	      Ct(e, "$attrs", s && s.attrs || t, null, !0), Ct(e, "$listeners", n._parentListeners || t, null, !0);
	    }(n), We(n, "beforeCreate"), function (t) {
	      var e = re(t.$options.inject, t);
	      e && (_t(!1), Object.keys(e).forEach(function (n) {
	        Ct(t, n, e[n]);
	      }), _t(!0));
	    }(n), ln(n), function (t) {
	      var e = t.$options.provide;
	      e && (t._provided = "function" == typeof e ? e.call(t) : e);
	    }(n), We(n, "created"), n.$options.el && n.$mount(n.$options.el);
	  };
	}(gn), function (t) {
	  var e = {
	    get: function get() {
	      return this._data;
	    }
	  },
	      n = {
	    get: function get() {
	      return this._props;
	    }
	  };
	  Object.defineProperty(t.prototype, "$data", e), Object.defineProperty(t.prototype, "$props", n), t.prototype.$set = xt, t.prototype.$delete = kt, t.prototype.$watch = function (t, e, n) {
	    var o = this;
	    if (a(e)) return hn(o, t, e, n);
	    (n = n || {}).user = !0;
	    var r = new sn(o, t, e, n);

	    if (n.immediate) {
	      var _t30 = "callback for immediate watcher \"".concat(r.expression, "\"");

	      ut(), Ht(e, o, [r.value], o, _t30), ft();
	    }

	    return function () {
	      r.teardown();
	    };
	  };
	}(gn), function (t) {
	  var e = /^hook:/;
	  t.prototype.$on = function (t, n) {
	    var o = this;
	    if (Array.isArray(t)) for (var _e25 = 0, _r17 = t.length; _e25 < _r17; _e25++) {
	      o.$on(t[_e25], n);
	    } else (o._events[t] || (o._events[t] = [])).push(n), e.test(t) && (o._hasHookEvent = !0);
	    return o;
	  }, t.prototype.$once = function (t, e) {
	    var n = this;

	    function o() {
	      n.$off(t, o), e.apply(n, arguments);
	    }

	    return o.fn = e, n.$on(t, o), n;
	  }, t.prototype.$off = function (t, e) {
	    var n = this;
	    if (!arguments.length) return n._events = Object.create(null), n;

	    if (Array.isArray(t)) {
	      for (var _o24 = 0, _r18 = t.length; _o24 < _r18; _o24++) {
	        n.$off(t[_o24], e);
	      }

	      return n;
	    }

	    var o = n._events[t];
	    if (!o) return n;
	    if (!e) return n._events[t] = null, n;
	    var r,
	        s = o.length;

	    for (; s--;) {
	      if ((r = o[s]) === e || r.fn === e) {
	        o.splice(s, 1);
	        break;
	      }
	    }

	    return n;
	  }, t.prototype.$emit = function (t) {
	    var e = this;
	    var n = e._events[t];

	    if (n) {
	      n = n.length > 1 ? k(n) : n;

	      var _o25 = k(arguments, 1),
	          _r19 = "event handler for \"".concat(t, "\"");

	      for (var _t31 = 0, _s10 = n.length; _t31 < _s10; _t31++) {
	        Ht(n[_t31], e, _o25, e, _r19);
	      }
	    }

	    return e;
	  };
	}(gn), function (t) {
	  t.prototype._update = function (t, e) {
	    var n = this,
	        o = n.$el,
	        r = n._vnode,
	        s = Ke(n);
	    n._vnode = t, n.$el = r ? n.__patch__(r, t) : n.__patch__(n.$el, t, e, !1), s(), o && (o.__vue__ = null), n.$el && (n.$el.__vue__ = n), n.$vnode && n.$parent && n.$vnode === n.$parent._vnode && (n.$parent.$el = n.$el);
	  }, t.prototype.$forceUpdate = function () {
	    var t = this;
	    t._watcher && t._watcher.update();
	  }, t.prototype.$destroy = function () {
	    var t = this;
	    if (t._isBeingDestroyed) return;
	    We(t, "beforeDestroy"), t._isBeingDestroyed = !0;
	    var e = t.$parent;
	    !e || e._isBeingDestroyed || t.$options.abstract || m(e.$children, t), t._watcher && t._watcher.teardown();
	    var n = t._watchers.length;

	    for (; n--;) {
	      t._watchers[n].teardown();
	    }

	    t._data.__ob__ && t._data.__ob__.vmCount--, t._isDestroyed = !0, t.__patch__(t._vnode, null), We(t, "destroyed"), t.$off(), t.$el && (t.$el.__vue__ = null), t.$vnode && (t.$vnode.parent = null);
	  };
	}(gn), function (t) {
	  ke(t.prototype), t.prototype.$nextTick = function (t) {
	    return Wt(t, this);
	  }, t.prototype._render = function () {
	    var t = this,
	        _t$$options = t.$options,
	        e = _t$$options.render,
	        n = _t$$options._parentVnode;
	    var o;
	    n && (t.$scopedSlots = ce(n.data.scopedSlots, t.$slots, t.$scopedSlots)), t.$vnode = n;

	    try {
	      Fe = t, o = e.call(t._renderProxy, t.$createElement);
	    } catch (e) {
	      Rt(e, t, "render"), o = t._vnode;
	    } finally {
	      Fe = null;
	    }

	    return Array.isArray(o) && 1 === o.length && (o = o[0]), o instanceof dt || (o = pt()), o.parent = n, o;
	  };
	}(gn);
	var Cn = [String, RegExp, Array];
	var xn = {
	  KeepAlive: {
	    name: "keep-alive",
	    abstract: !0,
	    props: {
	      include: Cn,
	      exclude: Cn,
	      max: [String, Number]
	    },
	    methods: {
	      cacheVNode: function cacheVNode() {
	        var t = this.cache,
	            e = this.keys,
	            n = this.vnodeToCache,
	            o = this.keyToCache;

	        if (n) {
	          var _r20 = n.tag,
	              _s11 = n.componentInstance,
	              _i9 = n.componentOptions;
	          t[o] = {
	            name: $n(_i9),
	            tag: _r20,
	            componentInstance: _s11
	          }, e.push(o), this.max && e.length > parseInt(this.max) && wn(t, e[0], e, this._vnode), this.vnodeToCache = null;
	        }
	      }
	    },
	    created: function created() {
	      this.cache = Object.create(null), this.keys = [];
	    },
	    destroyed: function destroyed() {
	      for (var _t32 in this.cache) {
	        wn(this.cache, _t32, this.keys);
	      }
	    },
	    mounted: function mounted() {
	      var _this2 = this;

	      this.cacheVNode(), this.$watch("include", function (t) {
	        bn(_this2, function (e) {
	          return _n(t, e);
	        });
	      }), this.$watch("exclude", function (t) {
	        bn(_this2, function (e) {
	          return !_n(t, e);
	        });
	      });
	    },
	    updated: function updated() {
	      this.cacheVNode();
	    },
	    render: function render() {
	      var t = this.$slots.default,
	          e = Re(t),
	          n = e && e.componentOptions;

	      if (n) {
	        var _t33 = $n(n),
	            _o26 = this.include,
	            _r21 = this.exclude;

	        if (_o26 && (!_t33 || !_n(_o26, _t33)) || _r21 && _t33 && _n(_r21, _t33)) return e;

	        var _s12 = this.cache,
	            _i10 = this.keys,
	            _a4 = null == e.key ? n.Ctor.cid + (n.tag ? "::".concat(n.tag) : "") : e.key;

	        _s12[_a4] ? (e.componentInstance = _s12[_a4].componentInstance, m(_i10, _a4), _i10.push(_a4)) : (this.vnodeToCache = e, this.keyToCache = _a4), e.data.keepAlive = !0;
	      }

	      return e || t && t[0];
	    }
	  }
	};
	!function (t) {
	  var e = {
	    get: function get() {
	      return F;
	    }
	  };
	  Object.defineProperty(t, "config", e), t.util = {
	    warn: it,
	    extend: A,
	    mergeOptions: jt,
	    defineReactive: Ct
	  }, t.set = xt, t.delete = kt, t.nextTick = Wt, t.observable = function (t) {
	    return wt(t), t;
	  }, t.options = Object.create(null), I.forEach(function (e) {
	    t.options[e + "s"] = Object.create(null);
	  }), t.options._base = t, A(t.options.components, xn), function (t) {
	    t.use = function (t) {
	      var e = this._installedPlugins || (this._installedPlugins = []);
	      if (e.indexOf(t) > -1) return this;
	      var n = k(arguments, 1);
	      return n.unshift(this), "function" == typeof t.install ? t.install.apply(t, n) : "function" == typeof t && t.apply(null, n), e.push(t), this;
	    };
	  }(t), function (t) {
	    t.mixin = function (t) {
	      return this.options = jt(this.options, t), this;
	    };
	  }(t), vn(t), function (t) {
	    I.forEach(function (e) {
	      t[e] = function (t, n) {
	        return n ? ("component" === e && a(n) && (n.name = n.name || t, n = this.options._base.extend(n)), "directive" === e && "function" == typeof n && (n = {
	          bind: n,
	          update: n
	        }), this.options[e + "s"][t] = n, n) : this.options[e + "s"][t];
	      };
	    });
	  }(t);
	}(gn), Object.defineProperty(gn.prototype, "$isServer", {
	  get: et
	}), Object.defineProperty(gn.prototype, "$ssrContext", {
	  get: function get() {
	    return this.$vnode && this.$vnode.ssrContext;
	  }
	}), Object.defineProperty(gn, "FunctionalRenderContext", {
	  value: Ae
	}), gn.version = "2.6.14";

	var kn = d("style,class"),
	    An = d("input,textarea,option,select,progress"),
	    On = function On(t, e, n) {
	  return "value" === n && An(t) && "button" !== e || "selected" === n && "option" === t || "checked" === n && "input" === t || "muted" === n && "video" === t;
	},
	    Sn = d("contenteditable,draggable,spellcheck"),
	    Tn = d("events,caret,typing,plaintext-only"),
	    Nn = function Nn(t, e) {
	  return In(e) || "false" === e ? "false" : "contenteditable" === t && Tn(e) ? e : "true";
	},
	    En = d("allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,truespeed,typemustmatch,visible"),
	    jn = "http://www.w3.org/1999/xlink",
	    Dn = function Dn(t) {
	  return ":" === t.charAt(5) && "xlink" === t.slice(0, 5);
	},
	    Ln = function Ln(t) {
	  return Dn(t) ? t.slice(6, t.length) : "";
	},
	    In = function In(t) {
	  return null == t || !1 === t;
	};

	function Mn(t) {
	  var e = t.data,
	      o = t,
	      r = t;

	  for (; n(r.componentInstance);) {
	    (r = r.componentInstance._vnode) && r.data && (e = Fn(r.data, e));
	  }

	  for (; n(o = o.parent);) {
	    o && o.data && (e = Fn(e, o.data));
	  }

	  return function (t, e) {
	    if (n(t) || n(e)) return Pn(t, Rn(e));
	    return "";
	  }(e.staticClass, e.class);
	}

	function Fn(t, e) {
	  return {
	    staticClass: Pn(t.staticClass, e.staticClass),
	    class: n(t.class) ? [t.class, e.class] : e.class
	  };
	}

	function Pn(t, e) {
	  return t ? e ? t + " " + e : t : e || "";
	}

	function Rn(t) {
	  return Array.isArray(t) ? function (t) {
	    var e,
	        o = "";

	    for (var _r22 = 0, _s13 = t.length; _r22 < _s13; _r22++) {
	      n(e = Rn(t[_r22])) && "" !== e && (o && (o += " "), o += e);
	    }

	    return o;
	  }(t) : s(t) ? function (t) {
	    var e = "";

	    for (var _n36 in t) {
	      t[_n36] && (e && (e += " "), e += _n36);
	    }

	    return e;
	  }(t) : "string" == typeof t ? t : "";
	}

	var Hn = {
	  svg: "http://www.w3.org/2000/svg",
	  math: "http://www.w3.org/1998/Math/MathML"
	},
	    Bn = d("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template,blockquote,iframe,tfoot"),
	    Un = d("svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view", !0),
	    Vn = function Vn(t) {
	  return Bn(t) || Un(t);
	};

	function zn(t) {
	  return Un(t) ? "svg" : "math" === t ? "math" : void 0;
	}

	var Kn = Object.create(null);
	var Jn = d("text,number,password,search,email,tel,url");

	function qn(t) {
	  if ("string" == typeof t) {
	    var _e26 = document.querySelector(t);

	    return _e26 || document.createElement("div");
	  }

	  return t;
	}

	var Wn = Object.freeze({
	  createElement: function createElement(t, e) {
	    var n = document.createElement(t);
	    return "select" !== t ? n : (e.data && e.data.attrs && void 0 !== e.data.attrs.multiple && n.setAttribute("multiple", "multiple"), n);
	  },
	  createElementNS: function createElementNS(t, e) {
	    return document.createElementNS(Hn[t], e);
	  },
	  createTextNode: function createTextNode(t) {
	    return document.createTextNode(t);
	  },
	  createComment: function createComment(t) {
	    return document.createComment(t);
	  },
	  insertBefore: function insertBefore(t, e, n) {
	    t.insertBefore(e, n);
	  },
	  removeChild: function removeChild(t, e) {
	    t.removeChild(e);
	  },
	  appendChild: function appendChild(t, e) {
	    t.appendChild(e);
	  },
	  parentNode: function parentNode(t) {
	    return t.parentNode;
	  },
	  nextSibling: function nextSibling(t) {
	    return t.nextSibling;
	  },
	  tagName: function tagName(t) {
	    return t.tagName;
	  },
	  setTextContent: function setTextContent(t, e) {
	    t.textContent = e;
	  },
	  setStyleScope: function setStyleScope(t, e) {
	    t.setAttribute(e, "");
	  }
	}),
	    Zn = {
	  create: function create(t, e) {
	    Gn(e);
	  },
	  update: function update(t, e) {
	    t.data.ref !== e.data.ref && (Gn(t, !0), Gn(e));
	  },
	  destroy: function destroy(t) {
	    Gn(t, !0);
	  }
	};

	function Gn(t, e) {
	  var o = t.data.ref;
	  if (!n(o)) return;
	  var r = t.context,
	      s = t.componentInstance || t.elm,
	      i = r.$refs;
	  e ? Array.isArray(i[o]) ? m(i[o], s) : i[o] === s && (i[o] = void 0) : t.data.refInFor ? Array.isArray(i[o]) ? i[o].indexOf(s) < 0 && i[o].push(s) : i[o] = [s] : i[o] = s;
	}

	var Xn = new dt("", {}, []),
	    Yn = ["create", "activate", "update", "remove", "destroy"];

	function Qn(t, r) {
	  return t.key === r.key && t.asyncFactory === r.asyncFactory && (t.tag === r.tag && t.isComment === r.isComment && n(t.data) === n(r.data) && function (t, e) {
	    if ("input" !== t.tag) return !0;
	    var o;
	    var r = n(o = t.data) && n(o = o.attrs) && o.type,
	        s = n(o = e.data) && n(o = o.attrs) && o.type;
	    return r === s || Jn(r) && Jn(s);
	  }(t, r) || o(t.isAsyncPlaceholder) && e(r.asyncFactory.error));
	}

	function to(t, e, o) {
	  var r, s;
	  var i = {};

	  for (r = e; r <= o; ++r) {
	    n(s = t[r].key) && (i[s] = r);
	  }

	  return i;
	}

	var eo = {
	  create: no,
	  update: no,
	  destroy: function destroy(t) {
	    no(t, Xn);
	  }
	};

	function no(t, e) {
	  (t.data.directives || e.data.directives) && function (t, e) {
	    var n = t === Xn,
	        o = e === Xn,
	        r = ro(t.data.directives, t.context),
	        s = ro(e.data.directives, e.context),
	        i = [],
	        a = [];
	    var c, l, u;

	    for (c in s) {
	      l = r[c], u = s[c], l ? (u.oldValue = l.value, u.oldArg = l.arg, io(u, "update", e, t), u.def && u.def.componentUpdated && a.push(u)) : (io(u, "bind", e, t), u.def && u.def.inserted && i.push(u));
	    }

	    if (i.length) {
	      var _o27 = function _o27() {
	        for (var _n37 = 0; _n37 < i.length; _n37++) {
	          io(i[_n37], "inserted", e, t);
	        }
	      };

	      n ? te(e, "insert", _o27) : _o27();
	    }

	    a.length && te(e, "postpatch", function () {
	      for (var _n38 = 0; _n38 < a.length; _n38++) {
	        io(a[_n38], "componentUpdated", e, t);
	      }
	    });
	    if (!n) for (c in r) {
	      s[c] || io(r[c], "unbind", t, t, o);
	    }
	  }(t, e);
	}

	var oo = Object.create(null);

	function ro(t, e) {
	  var n = Object.create(null);
	  if (!t) return n;
	  var o, r;

	  for (o = 0; o < t.length; o++) {
	    (r = t[o]).modifiers || (r.modifiers = oo), n[so(r)] = r, r.def = Dt(e.$options, "directives", r.name);
	  }

	  return n;
	}

	function so(t) {
	  return t.rawName || "".concat(t.name, ".").concat(Object.keys(t.modifiers || {}).join("."));
	}

	function io(t, e, n, o, r) {
	  var s = t.def && t.def[e];
	  if (s) try {
	    s(n.elm, t, n, o, r);
	  } catch (o) {
	    Rt(o, n.context, "directive ".concat(t.name, " ").concat(e, " hook"));
	  }
	}

	var ao = [Zn, eo];

	function co(t, o) {
	  var r = o.componentOptions;
	  if (n(r) && !1 === r.Ctor.options.inheritAttrs) return;
	  if (e(t.data.attrs) && e(o.data.attrs)) return;
	  var s, i, a;
	  var c = o.elm,
	      l = t.data.attrs || {};
	  var u = o.data.attrs || {};

	  for (s in n(u.__ob__) && (u = o.data.attrs = A({}, u)), u) {
	    i = u[s], (a = l[s]) !== i && lo(c, s, i, o.data.pre);
	  }

	  for (s in (q || Z) && u.value !== l.value && lo(c, "value", u.value), l) {
	    e(u[s]) && (Dn(s) ? c.removeAttributeNS(jn, Ln(s)) : Sn(s) || c.removeAttribute(s));
	  }
	}

	function lo(t, e, n, o) {
	  o || t.tagName.indexOf("-") > -1 ? uo(t, e, n) : En(e) ? In(n) ? t.removeAttribute(e) : (n = "allowfullscreen" === e && "EMBED" === t.tagName ? "true" : e, t.setAttribute(e, n)) : Sn(e) ? t.setAttribute(e, Nn(e, n)) : Dn(e) ? In(n) ? t.removeAttributeNS(jn, Ln(e)) : t.setAttributeNS(jn, e, n) : uo(t, e, n);
	}

	function uo(t, e, n) {
	  if (In(n)) t.removeAttribute(e);else {
	    if (q && !W && "TEXTAREA" === t.tagName && "placeholder" === e && "" !== n && !t.__ieph) {
	      var _e27 = function _e27(n) {
	        n.stopImmediatePropagation(), t.removeEventListener("input", _e27);
	      };

	      t.addEventListener("input", _e27), t.__ieph = !0;
	    }

	    t.setAttribute(e, n);
	  }
	}

	var fo = {
	  create: co,
	  update: co
	};

	function po(t, o) {
	  var r = o.elm,
	      s = o.data,
	      i = t.data;
	  if (e(s.staticClass) && e(s.class) && (e(i) || e(i.staticClass) && e(i.class))) return;
	  var a = Mn(o);
	  var c = r._transitionClasses;
	  n(c) && (a = Pn(a, Rn(c))), a !== r._prevClass && (r.setAttribute("class", a), r._prevClass = a);
	}

	var ho = {
	  create: po,
	  update: po
	};
	var mo = /[\w).+\-_$\]]/;

	function yo(t) {
	  var e,
	      n,
	      o,
	      r,
	      s,
	      i = !1,
	      a = !1,
	      c = !1,
	      l = !1,
	      u = 0,
	      f = 0,
	      d = 0,
	      p = 0;

	  for (o = 0; o < t.length; o++) {
	    if (n = e, e = t.charCodeAt(o), i) 39 === e && 92 !== n && (i = !1);else if (a) 34 === e && 92 !== n && (a = !1);else if (c) 96 === e && 92 !== n && (c = !1);else if (l) 47 === e && 92 !== n && (l = !1);else if (124 !== e || 124 === t.charCodeAt(o + 1) || 124 === t.charCodeAt(o - 1) || u || f || d) {
	      switch (e) {
	        case 34:
	          a = !0;
	          break;

	        case 39:
	          i = !0;
	          break;

	        case 96:
	          c = !0;
	          break;

	        case 40:
	          d++;
	          break;

	        case 41:
	          d--;
	          break;

	        case 91:
	          f++;
	          break;

	        case 93:
	          f--;
	          break;

	        case 123:
	          u++;
	          break;

	        case 125:
	          u--;
	      }

	      if (47 === e) {
	        var _e28 = void 0,
	            _n39 = o - 1;

	        for (; _n39 >= 0 && " " === (_e28 = t.charAt(_n39)); _n39--) {
	        }

	        _e28 && mo.test(_e28) || (l = !0);
	      }
	    } else void 0 === r ? (p = o + 1, r = t.slice(0, o).trim()) : h();
	  }

	  function h() {
	    (s || (s = [])).push(t.slice(p, o).trim()), p = o + 1;
	  }

	  if (void 0 === r ? r = t.slice(0, o).trim() : 0 !== p && h(), s) for (o = 0; o < s.length; o++) {
	    r = go(r, s[o]);
	  }
	  return r;
	}

	function go(t, e) {
	  var n = e.indexOf("(");
	  if (n < 0) return "_f(\"".concat(e, "\")(").concat(t, ")");
	  {
	    var _o28 = e.slice(0, n),
	        _r23 = e.slice(n + 1);

	    return "_f(\"".concat(_o28, "\")(").concat(t).concat(")" !== _r23 ? "," + _r23 : _r23);
	  }
	}

	function vo(t, e) {
	  console.error("[Vue compiler]: ".concat(t));
	}

	function $o(t, e) {
	  return t ? t.map(function (t) {
	    return t[e];
	  }).filter(function (t) {
	    return t;
	  }) : [];
	}

	function _o(t, e, n, o, r) {
	  (t.props || (t.props = [])).push(To({
	    name: e,
	    value: n,
	    dynamic: r
	  }, o)), t.plain = !1;
	}

	function bo(t, e, n, o, r) {
	  (r ? t.dynamicAttrs || (t.dynamicAttrs = []) : t.attrs || (t.attrs = [])).push(To({
	    name: e,
	    value: n,
	    dynamic: r
	  }, o)), t.plain = !1;
	}

	function wo(t, e, n, o) {
	  t.attrsMap[e] = n, t.attrsList.push(To({
	    name: e,
	    value: n
	  }, o));
	}

	function Co(t, e, n, o, r, s, i, a) {
	  (t.directives || (t.directives = [])).push(To({
	    name: e,
	    rawName: n,
	    value: o,
	    arg: r,
	    isDynamicArg: s,
	    modifiers: i
	  }, a)), t.plain = !1;
	}

	function xo(t, e, n) {
	  return n ? "_p(".concat(e, ",\"").concat(t, "\")") : t + e;
	}

	function ko(e, n, o, r, s, i, a, c) {
	  var l;
	  (r = r || t).right ? c ? n = "(".concat(n, ")==='click'?'contextmenu':(").concat(n, ")") : "click" === n && (n = "contextmenu", delete r.right) : r.middle && (c ? n = "(".concat(n, ")==='click'?'mouseup':(").concat(n, ")") : "click" === n && (n = "mouseup")), r.capture && (delete r.capture, n = xo("!", n, c)), r.once && (delete r.once, n = xo("~", n, c)), r.passive && (delete r.passive, n = xo("&", n, c)), r.native ? (delete r.native, l = e.nativeEvents || (e.nativeEvents = {})) : l = e.events || (e.events = {});
	  var u = To({
	    value: o.trim(),
	    dynamic: c
	  }, a);
	  r !== t && (u.modifiers = r);
	  var f = l[n];
	  Array.isArray(f) ? s ? f.unshift(u) : f.push(u) : l[n] = f ? s ? [u, f] : [f, u] : u, e.plain = !1;
	}

	function Ao(t, e, n) {
	  var o = Oo(t, ":" + e) || Oo(t, "v-bind:" + e);
	  if (null != o) return yo(o);

	  if (!1 !== n) {
	    var _n40 = Oo(t, e);

	    if (null != _n40) return JSON.stringify(_n40);
	  }
	}

	function Oo(t, e, n) {
	  var o;

	  if (null != (o = t.attrsMap[e])) {
	    var _n41 = t.attrsList;

	    for (var _t34 = 0, _o29 = _n41.length; _t34 < _o29; _t34++) {
	      if (_n41[_t34].name === e) {
	        _n41.splice(_t34, 1);

	        break;
	      }
	    }
	  }

	  return n && delete t.attrsMap[e], o;
	}

	function So(t, e) {
	  var n = t.attrsList;

	  for (var _t35 = 0, _o30 = n.length; _t35 < _o30; _t35++) {
	    var _o31 = n[_t35];
	    if (e.test(_o31.name)) return n.splice(_t35, 1), _o31;
	  }
	}

	function To(t, e) {
	  return e && (null != e.start && (t.start = e.start), null != e.end && (t.end = e.end)), t;
	}

	function No(t, e, n) {
	  var _ref = n || {},
	      o = _ref.number,
	      r = _ref.trim;

	  var s = "$$v";
	  r && (s = "(typeof $$v === 'string'? $$v.trim(): $$v)"), o && (s = "_n(".concat(s, ")"));
	  var i = Eo(e, s);
	  t.model = {
	    value: "(".concat(e, ")"),
	    expression: JSON.stringify(e),
	    callback: "function ($$v) {".concat(i, "}")
	  };
	}

	function Eo(t, e) {
	  var n = function (t) {
	    if (t = t.trim(), jo = t.length, t.indexOf("[") < 0 || t.lastIndexOf("]") < jo - 1) return (Io = t.lastIndexOf(".")) > -1 ? {
	      exp: t.slice(0, Io),
	      key: '"' + t.slice(Io + 1) + '"'
	    } : {
	      exp: t,
	      key: null
	    };
	    Do = t, Io = Mo = Fo = 0;

	    for (; !Ro();) {
	      Ho(Lo = Po()) ? Uo(Lo) : 91 === Lo && Bo(Lo);
	    }

	    return {
	      exp: t.slice(0, Mo),
	      key: t.slice(Mo + 1, Fo)
	    };
	  }(t);

	  return null === n.key ? "".concat(t, "=").concat(e) : "$set(".concat(n.exp, ", ").concat(n.key, ", ").concat(e, ")");
	}

	var jo, Do, Lo, Io, Mo, Fo;

	function Po() {
	  return Do.charCodeAt(++Io);
	}

	function Ro() {
	  return Io >= jo;
	}

	function Ho(t) {
	  return 34 === t || 39 === t;
	}

	function Bo(t) {
	  var e = 1;

	  for (Mo = Io; !Ro();) {
	    if (Ho(t = Po())) Uo(t);else if (91 === t && e++, 93 === t && e--, 0 === e) {
	      Fo = Io;
	      break;
	    }
	  }
	}

	function Uo(t) {
	  var e = t;

	  for (; !Ro() && (t = Po()) !== e;) {
	  }
	}

	var Vo = "__r",
	    zo = "__c";
	var Ko;

	function Jo(t, e, n) {
	  var o = Ko;
	  return function r() {
	    null !== e.apply(null, arguments) && Zo(t, r, n, o);
	  };
	}

	var qo = Vt && !(X && Number(X[1]) <= 53);

	function Wo(t, e, n, o) {
	  if (qo) {
	    var _t36 = en,
	        _n42 = e;

	    e = _n42._wrapper = function (e) {
	      if (e.target === e.currentTarget || e.timeStamp >= _t36 || e.timeStamp <= 0 || e.target.ownerDocument !== document) return _n42.apply(this, arguments);
	    };
	  }

	  Ko.addEventListener(t, e, tt ? {
	    capture: n,
	    passive: o
	  } : n);
	}

	function Zo(t, e, n, o) {
	  (o || Ko).removeEventListener(t, e._wrapper || e, n);
	}

	function Go(t, o) {
	  if (e(t.data.on) && e(o.data.on)) return;
	  var r = o.data.on || {},
	      s = t.data.on || {};
	  Ko = o.elm, function (t) {
	    if (n(t[Vo])) {
	      var _e29 = q ? "change" : "input";

	      t[_e29] = [].concat(t[Vo], t[_e29] || []), delete t[Vo];
	    }

	    n(t[zo]) && (t.change = [].concat(t[zo], t.change || []), delete t[zo]);
	  }(r), Qt(r, s, Wo, Zo, Jo, o.context), Ko = void 0;
	}

	var Xo = {
	  create: Go,
	  update: Go
	};
	var Yo;

	function Qo(t, o) {
	  if (e(t.data.domProps) && e(o.data.domProps)) return;
	  var r, s;
	  var i = o.elm,
	      a = t.data.domProps || {};
	  var c = o.data.domProps || {};

	  for (r in n(c.__ob__) && (c = o.data.domProps = A({}, c)), a) {
	    r in c || (i[r] = "");
	  }

	  for (r in c) {
	    if (s = c[r], "textContent" === r || "innerHTML" === r) {
	      if (o.children && (o.children.length = 0), s === a[r]) continue;
	      1 === i.childNodes.length && i.removeChild(i.childNodes[0]);
	    }

	    if ("value" === r && "PROGRESS" !== i.tagName) {
	      i._value = s;

	      var _t37 = e(s) ? "" : String(s);

	      tr(i, _t37) && (i.value = _t37);
	    } else if ("innerHTML" === r && Un(i.tagName) && e(i.innerHTML)) {
	      (Yo = Yo || document.createElement("div")).innerHTML = "<svg>".concat(s, "</svg>");
	      var _t38 = Yo.firstChild;

	      for (; i.firstChild;) {
	        i.removeChild(i.firstChild);
	      }

	      for (; _t38.firstChild;) {
	        i.appendChild(_t38.firstChild);
	      }
	    } else if (s !== a[r]) try {
	      i[r] = s;
	    } catch (t) {}
	  }
	}

	function tr(t, e) {
	  return !t.composing && ("OPTION" === t.tagName || function (t, e) {
	    var n = !0;

	    try {
	      n = document.activeElement !== t;
	    } catch (t) {}

	    return n && t.value !== e;
	  }(t, e) || function (t, e) {
	    var o = t.value,
	        r = t._vModifiers;

	    if (n(r)) {
	      if (r.number) return f(o) !== f(e);
	      if (r.trim) return o.trim() !== e.trim();
	    }

	    return o !== e;
	  }(t, e));
	}

	var er = {
	  create: Qo,
	  update: Qo
	};
	var nr = v(function (t) {
	  var e = {},
	      n = /:(.+)/;
	  return t.split(/;(?![^(]*\))/g).forEach(function (t) {
	    if (t) {
	      var _o32 = t.split(n);

	      _o32.length > 1 && (e[_o32[0].trim()] = _o32[1].trim());
	    }
	  }), e;
	});

	function or(t) {
	  var e = rr(t.style);
	  return t.staticStyle ? A(t.staticStyle, e) : e;
	}

	function rr(t) {
	  return Array.isArray(t) ? O(t) : "string" == typeof t ? nr(t) : t;
	}

	var sr = /^--/,
	    ir = /\s*!important$/,
	    ar = function ar(t, e, n) {
	  if (sr.test(e)) t.style.setProperty(e, n);else if (ir.test(n)) t.style.setProperty(C(e), n.replace(ir, ""), "important");else {
	    var _o33 = ur(e);

	    if (Array.isArray(n)) for (var _e30 = 0, _r24 = n.length; _e30 < _r24; _e30++) {
	      t.style[_o33] = n[_e30];
	    } else t.style[_o33] = n;
	  }
	},
	    cr = ["Webkit", "Moz", "ms"];

	var lr;
	var ur = v(function (t) {
	  if (lr = lr || document.createElement("div").style, "filter" !== (t = _(t)) && t in lr) return t;
	  var e = t.charAt(0).toUpperCase() + t.slice(1);

	  for (var _t39 = 0; _t39 < cr.length; _t39++) {
	    var _n43 = cr[_t39] + e;

	    if (_n43 in lr) return _n43;
	  }
	});

	function fr(t, o) {
	  var r = o.data,
	      s = t.data;
	  if (e(r.staticStyle) && e(r.style) && e(s.staticStyle) && e(s.style)) return;
	  var i, a;
	  var c = o.elm,
	      l = s.staticStyle,
	      u = s.normalizedStyle || s.style || {},
	      f = l || u,
	      d = rr(o.data.style) || {};
	  o.data.normalizedStyle = n(d.__ob__) ? A({}, d) : d;

	  var p = function (t, e) {
	    var n = {};
	    var o;

	    if (e) {
	      var _e31 = t;

	      for (; _e31.componentInstance;) {
	        (_e31 = _e31.componentInstance._vnode) && _e31.data && (o = or(_e31.data)) && A(n, o);
	      }
	    }

	    (o = or(t.data)) && A(n, o);
	    var r = t;

	    for (; r = r.parent;) {
	      r.data && (o = or(r.data)) && A(n, o);
	    }

	    return n;
	  }(o, !0);

	  for (a in f) {
	    e(p[a]) && ar(c, a, "");
	  }

	  for (a in p) {
	    (i = p[a]) !== f[a] && ar(c, a, null == i ? "" : i);
	  }
	}

	var dr = {
	  create: fr,
	  update: fr
	};
	var pr = /\s+/;

	function hr(t, e) {
	  if (e && (e = e.trim())) if (t.classList) e.indexOf(" ") > -1 ? e.split(pr).forEach(function (e) {
	    return t.classList.add(e);
	  }) : t.classList.add(e);else {
	    var _n44 = " ".concat(t.getAttribute("class") || "", " ");

	    _n44.indexOf(" " + e + " ") < 0 && t.setAttribute("class", (_n44 + e).trim());
	  }
	}

	function mr(t, e) {
	  if (e && (e = e.trim())) if (t.classList) e.indexOf(" ") > -1 ? e.split(pr).forEach(function (e) {
	    return t.classList.remove(e);
	  }) : t.classList.remove(e), t.classList.length || t.removeAttribute("class");else {
	    var _n45 = " ".concat(t.getAttribute("class") || "", " ");

	    var _o34 = " " + e + " ";

	    for (; _n45.indexOf(_o34) >= 0;) {
	      _n45 = _n45.replace(_o34, " ");
	    }

	    (_n45 = _n45.trim()) ? t.setAttribute("class", _n45) : t.removeAttribute("class");
	  }
	}

	function yr(t) {
	  if (t) {
	    if ("object" == babelHelpers.typeof(t)) {
	      var _e32 = {};
	      return !1 !== t.css && A(_e32, gr(t.name || "v")), A(_e32, t), _e32;
	    }

	    return "string" == typeof t ? gr(t) : void 0;
	  }
	}

	var gr = v(function (t) {
	  return {
	    enterClass: "".concat(t, "-enter"),
	    enterToClass: "".concat(t, "-enter-to"),
	    enterActiveClass: "".concat(t, "-enter-active"),
	    leaveClass: "".concat(t, "-leave"),
	    leaveToClass: "".concat(t, "-leave-to"),
	    leaveActiveClass: "".concat(t, "-leave-active")
	  };
	}),
	    vr = V && !W,
	    $r = "transition",
	    _r = "animation";
	var br = "transition",
	    wr = "transitionend",
	    Cr = "animation",
	    xr = "animationend";
	vr && (void 0 === window.ontransitionend && void 0 !== window.onwebkittransitionend && (br = "WebkitTransition", wr = "webkitTransitionEnd"), void 0 === window.onanimationend && void 0 !== window.onwebkitanimationend && (Cr = "WebkitAnimation", xr = "webkitAnimationEnd"));
	var kr = V ? window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : setTimeout : function (t) {
	  return t();
	};

	function Ar(t) {
	  kr(function () {
	    kr(t);
	  });
	}

	function Or(t, e) {
	  var n = t._transitionClasses || (t._transitionClasses = []);
	  n.indexOf(e) < 0 && (n.push(e), hr(t, e));
	}

	function Sr(t, e) {
	  t._transitionClasses && m(t._transitionClasses, e), mr(t, e);
	}

	function Tr(t, e, n) {
	  var _Er = Er(t, e),
	      o = _Er.type,
	      r = _Er.timeout,
	      s = _Er.propCount;

	  if (!o) return n();
	  var i = o === $r ? wr : xr;
	  var a = 0;

	  var c = function c() {
	    t.removeEventListener(i, l), n();
	  },
	      l = function l(e) {
	    e.target === t && ++a >= s && c();
	  };

	  setTimeout(function () {
	    a < s && c();
	  }, r + 1), t.addEventListener(i, l);
	}

	var Nr = /\b(transform|all)(,|$)/;

	function Er(t, e) {
	  var n = window.getComputedStyle(t),
	      o = (n[br + "Delay"] || "").split(", "),
	      r = (n[br + "Duration"] || "").split(", "),
	      s = jr(o, r),
	      i = (n[Cr + "Delay"] || "").split(", "),
	      a = (n[Cr + "Duration"] || "").split(", "),
	      c = jr(i, a);
	  var l,
	      u = 0,
	      f = 0;
	  return e === $r ? s > 0 && (l = $r, u = s, f = r.length) : e === _r ? c > 0 && (l = _r, u = c, f = a.length) : f = (l = (u = Math.max(s, c)) > 0 ? s > c ? $r : _r : null) ? l === $r ? r.length : a.length : 0, {
	    type: l,
	    timeout: u,
	    propCount: f,
	    hasTransform: l === $r && Nr.test(n[br + "Property"])
	  };
	}

	function jr(t, e) {
	  for (; t.length < e.length;) {
	    t = t.concat(t);
	  }

	  return Math.max.apply(null, e.map(function (e, n) {
	    return Dr(e) + Dr(t[n]);
	  }));
	}

	function Dr(t) {
	  return 1e3 * Number(t.slice(0, -1).replace(",", "."));
	}

	function Lr(t, o) {
	  var r = t.elm;
	  n(r._leaveCb) && (r._leaveCb.cancelled = !0, r._leaveCb());
	  var i = yr(t.data.transition);
	  if (e(i)) return;
	  if (n(r._enterCb) || 1 !== r.nodeType) return;
	  var a = i.css,
	      c = i.type,
	      l = i.enterClass,
	      u = i.enterToClass,
	      d = i.enterActiveClass,
	      p = i.appearClass,
	      h = i.appearToClass,
	      m = i.appearActiveClass,
	      y = i.beforeEnter,
	      g = i.enter,
	      v = i.afterEnter,
	      $ = i.enterCancelled,
	      _ = i.beforeAppear,
	      b = i.appear,
	      w = i.afterAppear,
	      C = i.appearCancelled,
	      x = i.duration;
	  var k = ze,
	      A = ze.$vnode;

	  for (; A && A.parent;) {
	    k = A.context, A = A.parent;
	  }

	  var O = !k._isMounted || !t.isRootInsert;
	  if (O && !b && "" !== b) return;
	  var S = O && p ? p : l,
	      T = O && m ? m : d,
	      N = O && h ? h : u,
	      E = O && _ || y,
	      j = O && "function" == typeof b ? b : g,
	      L = O && w || v,
	      I = O && C || $,
	      M = f(s(x) ? x.enter : x),
	      F = !1 !== a && !W,
	      P = Fr(j),
	      R = r._enterCb = D(function () {
	    F && (Sr(r, N), Sr(r, T)), R.cancelled ? (F && Sr(r, S), I && I(r)) : L && L(r), r._enterCb = null;
	  });
	  t.data.show || te(t, "insert", function () {
	    var e = r.parentNode,
	        n = e && e._pending && e._pending[t.key];
	    n && n.tag === t.tag && n.elm._leaveCb && n.elm._leaveCb(), j && j(r, R);
	  }), E && E(r), F && (Or(r, S), Or(r, T), Ar(function () {
	    Sr(r, S), R.cancelled || (Or(r, N), P || (Mr(M) ? setTimeout(R, M) : Tr(r, c, R)));
	  })), t.data.show && (o && o(), j && j(r, R)), F || P || R();
	}

	function Ir(t, o) {
	  var r = t.elm;
	  n(r._enterCb) && (r._enterCb.cancelled = !0, r._enterCb());
	  var i = yr(t.data.transition);
	  if (e(i) || 1 !== r.nodeType) return o();
	  if (n(r._leaveCb)) return;

	  var a = i.css,
	      c = i.type,
	      l = i.leaveClass,
	      u = i.leaveToClass,
	      d = i.leaveActiveClass,
	      p = i.beforeLeave,
	      h = i.leave,
	      m = i.afterLeave,
	      y = i.leaveCancelled,
	      g = i.delayLeave,
	      v = i.duration,
	      $ = !1 !== a && !W,
	      _ = Fr(h),
	      b = f(s(v) ? v.leave : v),
	      w = r._leaveCb = D(function () {
	    r.parentNode && r.parentNode._pending && (r.parentNode._pending[t.key] = null), $ && (Sr(r, u), Sr(r, d)), w.cancelled ? ($ && Sr(r, l), y && y(r)) : (o(), m && m(r)), r._leaveCb = null;
	  });

	  function C() {
	    w.cancelled || (!t.data.show && r.parentNode && ((r.parentNode._pending || (r.parentNode._pending = {}))[t.key] = t), p && p(r), $ && (Or(r, l), Or(r, d), Ar(function () {
	      Sr(r, l), w.cancelled || (Or(r, u), _ || (Mr(b) ? setTimeout(w, b) : Tr(r, c, w)));
	    })), h && h(r, w), $ || _ || w());
	  }

	  g ? g(C) : C();
	}

	function Mr(t) {
	  return "number" == typeof t && !isNaN(t);
	}

	function Fr(t) {
	  if (e(t)) return !1;
	  var o = t.fns;
	  return n(o) ? Fr(Array.isArray(o) ? o[0] : o) : (t._length || t.length) > 1;
	}

	function Pr(t, e) {
	  !0 !== e.data.show && Lr(e);
	}

	var Rr = function (t) {
	  var s, i;
	  var a = {},
	      c = t.modules,
	      l = t.nodeOps;

	  for (s = 0; s < Yn.length; ++s) {
	    for (a[Yn[s]] = [], i = 0; i < c.length; ++i) {
	      n(c[i][Yn[s]]) && a[Yn[s]].push(c[i][Yn[s]]);
	    }
	  }

	  function u(t) {
	    var e = l.parentNode(t);
	    n(e) && l.removeChild(e, t);
	  }

	  function f(t, e, r, s, i, c, u) {
	    if (n(t.elm) && n(c) && (t = c[u] = mt(t)), t.isRootInsert = !i, function (t, e, r, s) {
	      var i = t.data;

	      if (n(i)) {
	        var _c4 = n(t.componentInstance) && i.keepAlive;

	        if (n(i = i.hook) && n(i = i.init) && i(t, !1), n(t.componentInstance)) return p(t, e), h(r, t.elm, s), o(_c4) && function (t, e, o, r) {
	          var s,
	              i = t;

	          for (; i.componentInstance;) {
	            if (i = i.componentInstance._vnode, n(s = i.data) && n(s = s.transition)) {
	              for (s = 0; s < a.activate.length; ++s) {
	                a.activate[s](Xn, i);
	              }

	              e.push(i);
	              break;
	            }
	          }

	          h(o, t.elm, r);
	        }(t, e, r, s), !0;
	      }
	    }(t, e, r, s)) return;
	    var f = t.data,
	        d = t.children,
	        y = t.tag;
	    n(y) ? (t.elm = t.ns ? l.createElementNS(t.ns, y) : l.createElement(y, t), v(t), m(t, d, e), n(f) && g(t, e), h(r, t.elm, s)) : o(t.isComment) ? (t.elm = l.createComment(t.text), h(r, t.elm, s)) : (t.elm = l.createTextNode(t.text), h(r, t.elm, s));
	  }

	  function p(t, e) {
	    n(t.data.pendingInsert) && (e.push.apply(e, t.data.pendingInsert), t.data.pendingInsert = null), t.elm = t.componentInstance.$el, y(t) ? (g(t, e), v(t)) : (Gn(t), e.push(t));
	  }

	  function h(t, e, o) {
	    n(t) && (n(o) ? l.parentNode(o) === t && l.insertBefore(t, e, o) : l.appendChild(t, e));
	  }

	  function m(t, e, n) {
	    if (Array.isArray(e)) for (var _o35 = 0; _o35 < e.length; ++_o35) {
	      f(e[_o35], n, t.elm, null, !0, e, _o35);
	    } else r(t.text) && l.appendChild(t.elm, l.createTextNode(String(t.text)));
	  }

	  function y(t) {
	    for (; t.componentInstance;) {
	      t = t.componentInstance._vnode;
	    }

	    return n(t.tag);
	  }

	  function g(t, e) {
	    for (var _e33 = 0; _e33 < a.create.length; ++_e33) {
	      a.create[_e33](Xn, t);
	    }

	    n(s = t.data.hook) && (n(s.create) && s.create(Xn, t), n(s.insert) && e.push(t));
	  }

	  function v(t) {
	    var e;
	    if (n(e = t.fnScopeId)) l.setStyleScope(t.elm, e);else {
	      var _o36 = t;

	      for (; _o36;) {
	        n(e = _o36.context) && n(e = e.$options._scopeId) && l.setStyleScope(t.elm, e), _o36 = _o36.parent;
	      }
	    }
	    n(e = ze) && e !== t.context && e !== t.fnContext && n(e = e.$options._scopeId) && l.setStyleScope(t.elm, e);
	  }

	  function $(t, e, n, o, r, s) {
	    for (; o <= r; ++o) {
	      f(n[o], s, t, e, !1, n, o);
	    }
	  }

	  function _(t) {
	    var e, o;
	    var r = t.data;
	    if (n(r)) for (n(e = r.hook) && n(e = e.destroy) && e(t), e = 0; e < a.destroy.length; ++e) {
	      a.destroy[e](t);
	    }
	    if (n(e = t.children)) for (o = 0; o < t.children.length; ++o) {
	      _(t.children[o]);
	    }
	  }

	  function b(t, e, o) {
	    for (; e <= o; ++e) {
	      var _o37 = t[e];
	      n(_o37) && (n(_o37.tag) ? (w(_o37), _(_o37)) : u(_o37.elm));
	    }
	  }

	  function w(t, e) {
	    if (n(e) || n(t.data)) {
	      var _o38;

	      var _r25 = a.remove.length + 1;

	      for (n(e) ? e.listeners += _r25 : e = function (t, e) {
	        function n() {
	          0 == --n.listeners && u(t);
	        }

	        return n.listeners = e, n;
	      }(t.elm, _r25), n(_o38 = t.componentInstance) && n(_o38 = _o38._vnode) && n(_o38.data) && w(_o38, e), _o38 = 0; _o38 < a.remove.length; ++_o38) {
	        a.remove[_o38](t, e);
	      }

	      n(_o38 = t.data.hook) && n(_o38 = _o38.remove) ? _o38(t, e) : e();
	    } else u(t.elm);
	  }

	  function C(t, e, o, r) {
	    for (var _s14 = o; _s14 < r; _s14++) {
	      var _o39 = e[_s14];
	      if (n(_o39) && Qn(t, _o39)) return _s14;
	    }
	  }

	  function x(t, r, s, i, c, u) {
	    if (t === r) return;
	    n(r.elm) && n(i) && (r = i[c] = mt(r));
	    var d = r.elm = t.elm;
	    if (o(t.isAsyncPlaceholder)) return void (n(r.asyncFactory.resolved) ? O(t.elm, r, s) : r.isAsyncPlaceholder = !0);
	    if (o(r.isStatic) && o(t.isStatic) && r.key === t.key && (o(r.isCloned) || o(r.isOnce))) return void (r.componentInstance = t.componentInstance);
	    var p;
	    var h = r.data;
	    n(h) && n(p = h.hook) && n(p = p.prepatch) && p(t, r);
	    var m = t.children,
	        g = r.children;

	    if (n(h) && y(r)) {
	      for (p = 0; p < a.update.length; ++p) {
	        a.update[p](t, r);
	      }

	      n(p = h.hook) && n(p = p.update) && p(t, r);
	    }

	    e(r.text) ? n(m) && n(g) ? m !== g && function (t, o, r, s, i) {
	      var a,
	          c,
	          u,
	          d,
	          p = 0,
	          h = 0,
	          m = o.length - 1,
	          y = o[0],
	          g = o[m],
	          v = r.length - 1,
	          _ = r[0],
	          w = r[v];
	      var k = !i;

	      for (; p <= m && h <= v;) {
	        e(y) ? y = o[++p] : e(g) ? g = o[--m] : Qn(y, _) ? (x(y, _, s, r, h), y = o[++p], _ = r[++h]) : Qn(g, w) ? (x(g, w, s, r, v), g = o[--m], w = r[--v]) : Qn(y, w) ? (x(y, w, s, r, v), k && l.insertBefore(t, y.elm, l.nextSibling(g.elm)), y = o[++p], w = r[--v]) : Qn(g, _) ? (x(g, _, s, r, h), k && l.insertBefore(t, g.elm, y.elm), g = o[--m], _ = r[++h]) : (e(a) && (a = to(o, p, m)), e(c = n(_.key) ? a[_.key] : C(_, o, p, m)) ? f(_, s, t, y.elm, !1, r, h) : Qn(u = o[c], _) ? (x(u, _, s, r, h), o[c] = void 0, k && l.insertBefore(t, u.elm, y.elm)) : f(_, s, t, y.elm, !1, r, h), _ = r[++h]);
	      }

	      p > m ? $(t, d = e(r[v + 1]) ? null : r[v + 1].elm, r, h, v, s) : h > v && b(o, p, m);
	    }(d, m, g, s, u) : n(g) ? (n(t.text) && l.setTextContent(d, ""), $(d, null, g, 0, g.length - 1, s)) : n(m) ? b(m, 0, m.length - 1) : n(t.text) && l.setTextContent(d, "") : t.text !== r.text && l.setTextContent(d, r.text), n(h) && n(p = h.hook) && n(p = p.postpatch) && p(t, r);
	  }

	  function k(t, e, r) {
	    if (o(r) && n(t.parent)) t.parent.data.pendingInsert = e;else for (var _t40 = 0; _t40 < e.length; ++_t40) {
	      e[_t40].data.hook.insert(e[_t40]);
	    }
	  }

	  var A = d("attrs,class,staticClass,staticStyle,key");

	  function O(t, e, r, s) {
	    var i;
	    var a = e.tag,
	        c = e.data,
	        l = e.children;
	    if (s = s || c && c.pre, e.elm = t, o(e.isComment) && n(e.asyncFactory)) return e.isAsyncPlaceholder = !0, !0;
	    if (n(c) && (n(i = c.hook) && n(i = i.init) && i(e, !0), n(i = e.componentInstance))) return p(e, r), !0;

	    if (n(a)) {
	      if (n(l)) if (t.hasChildNodes()) {
	        if (n(i = c) && n(i = i.domProps) && n(i = i.innerHTML)) {
	          if (i !== t.innerHTML) return !1;
	        } else {
	          var _e34 = !0,
	              _n46 = t.firstChild;

	          for (var _t41 = 0; _t41 < l.length; _t41++) {
	            if (!_n46 || !O(_n46, l[_t41], r, s)) {
	              _e34 = !1;
	              break;
	            }

	            _n46 = _n46.nextSibling;
	          }

	          if (!_e34 || _n46) return !1;
	        }
	      } else m(e, l, r);

	      if (n(c)) {
	        var _t42 = !1;

	        for (var _n47 in c) {
	          if (!A(_n47)) {
	            _t42 = !0, g(e, r);
	            break;
	          }
	        }

	        !_t42 && c.class && Gt(c.class);
	      }
	    } else t.data !== e.text && (t.data = e.text);

	    return !0;
	  }

	  return function (t, r, s, i) {
	    if (e(r)) return void (n(t) && _(t));
	    var c = !1;
	    var u = [];
	    if (e(t)) c = !0, f(r, u);else {
	      var _e35 = n(t.nodeType);

	      if (!_e35 && Qn(t, r)) x(t, r, u, null, null, i);else {
	        if (_e35) {
	          if (1 === t.nodeType && t.hasAttribute(L) && (t.removeAttribute(L), s = !0), o(s) && O(t, r, u)) return k(r, u, !0), t;
	          d = t, t = new dt(l.tagName(d).toLowerCase(), {}, [], void 0, d);
	        }

	        var _i11 = t.elm,
	            _c5 = l.parentNode(_i11);

	        if (f(r, u, _i11._leaveCb ? null : _c5, l.nextSibling(_i11)), n(r.parent)) {
	          var _t43 = r.parent;

	          var _e36 = y(r);

	          for (; _t43;) {
	            for (var _e37 = 0; _e37 < a.destroy.length; ++_e37) {
	              a.destroy[_e37](_t43);
	            }

	            if (_t43.elm = r.elm, _e36) {
	              for (var _e39 = 0; _e39 < a.create.length; ++_e39) {
	                a.create[_e39](Xn, _t43);
	              }

	              var _e38 = _t43.data.hook.insert;
	              if (_e38.merged) for (var _t44 = 1; _t44 < _e38.fns.length; _t44++) {
	                _e38.fns[_t44]();
	              }
	            } else Gn(_t43);

	            _t43 = _t43.parent;
	          }
	        }

	        n(_c5) ? b([t], 0, 0) : n(t.tag) && _(t);
	      }
	    }
	    var d;
	    return k(r, u, c), r.elm;
	  };
	}({
	  nodeOps: Wn,
	  modules: [fo, ho, Xo, er, dr, V ? {
	    create: Pr,
	    activate: Pr,
	    remove: function remove(t, e) {
	      !0 !== t.data.show ? Ir(t, e) : e();
	    }
	  } : {}].concat(ao)
	});

	W && document.addEventListener("selectionchange", function () {
	  var t = document.activeElement;
	  t && t.vmodel && qr(t, "input");
	});
	var Hr = {
	  inserted: function inserted(t, e, n, o) {
	    "select" === n.tag ? (o.elm && !o.elm._vOptions ? te(n, "postpatch", function () {
	      Hr.componentUpdated(t, e, n);
	    }) : Br(t, e, n.context), t._vOptions = [].map.call(t.options, zr)) : ("textarea" === n.tag || Jn(t.type)) && (t._vModifiers = e.modifiers, e.modifiers.lazy || (t.addEventListener("compositionstart", Kr), t.addEventListener("compositionend", Jr), t.addEventListener("change", Jr), W && (t.vmodel = !0)));
	  },
	  componentUpdated: function componentUpdated(t, e, n) {
	    if ("select" === n.tag) {
	      Br(t, e, n.context);

	      var _o40 = t._vOptions,
	          _r26 = t._vOptions = [].map.call(t.options, zr);

	      if (_r26.some(function (t, e) {
	        return !E(t, _o40[e]);
	      })) {
	        (t.multiple ? e.value.some(function (t) {
	          return Vr(t, _r26);
	        }) : e.value !== e.oldValue && Vr(e.value, _r26)) && qr(t, "change");
	      }
	    }
	  }
	};

	function Br(t, e, n) {
	  Ur(t, e, n), (q || Z) && setTimeout(function () {
	    Ur(t, e, n);
	  }, 0);
	}

	function Ur(t, e, n) {
	  var o = e.value,
	      r = t.multiple;
	  if (r && !Array.isArray(o)) return;
	  var s, i;

	  for (var _e40 = 0, _n48 = t.options.length; _e40 < _n48; _e40++) {
	    if (i = t.options[_e40], r) s = j(o, zr(i)) > -1, i.selected !== s && (i.selected = s);else if (E(zr(i), o)) return void (t.selectedIndex !== _e40 && (t.selectedIndex = _e40));
	  }

	  r || (t.selectedIndex = -1);
	}

	function Vr(t, e) {
	  return e.every(function (e) {
	    return !E(e, t);
	  });
	}

	function zr(t) {
	  return "_value" in t ? t._value : t.value;
	}

	function Kr(t) {
	  t.target.composing = !0;
	}

	function Jr(t) {
	  t.target.composing && (t.target.composing = !1, qr(t.target, "input"));
	}

	function qr(t, e) {
	  var n = document.createEvent("HTMLEvents");
	  n.initEvent(e, !0, !0), t.dispatchEvent(n);
	}

	function Wr(t) {
	  return !t.componentInstance || t.data && t.data.transition ? t : Wr(t.componentInstance._vnode);
	}

	var Zr = {
	  model: Hr,
	  show: {
	    bind: function bind(t, _ref2, n) {
	      var e = _ref2.value;
	      var o = (n = Wr(n)).data && n.data.transition,
	          r = t.__vOriginalDisplay = "none" === t.style.display ? "" : t.style.display;
	      e && o ? (n.data.show = !0, Lr(n, function () {
	        t.style.display = r;
	      })) : t.style.display = e ? r : "none";
	    },
	    update: function update(t, _ref3, o) {
	      var e = _ref3.value,
	          n = _ref3.oldValue;
	      if (!e == !n) return;
	      (o = Wr(o)).data && o.data.transition ? (o.data.show = !0, e ? Lr(o, function () {
	        t.style.display = t.__vOriginalDisplay;
	      }) : Ir(o, function () {
	        t.style.display = "none";
	      })) : t.style.display = e ? t.__vOriginalDisplay : "none";
	    },
	    unbind: function unbind(t, e, n, o, r) {
	      r || (t.style.display = t.__vOriginalDisplay);
	    }
	  }
	};
	var Gr = {
	  name: String,
	  appear: Boolean,
	  css: Boolean,
	  mode: String,
	  type: String,
	  enterClass: String,
	  leaveClass: String,
	  enterToClass: String,
	  leaveToClass: String,
	  enterActiveClass: String,
	  leaveActiveClass: String,
	  appearClass: String,
	  appearActiveClass: String,
	  appearToClass: String,
	  duration: [Number, String, Object]
	};

	function Xr(t) {
	  var e = t && t.componentOptions;
	  return e && e.Ctor.options.abstract ? Xr(Re(e.children)) : t;
	}

	function Yr(t) {
	  var e = {},
	      n = t.$options;

	  for (var _o41 in n.propsData) {
	    e[_o41] = t[_o41];
	  }

	  var o = n._parentListeners;

	  for (var _t45 in o) {
	    e[_(_t45)] = o[_t45];
	  }

	  return e;
	}

	function Qr(t, e) {
	  if (/\d-keep-alive$/.test(e.tag)) return t("keep-alive", {
	    props: e.componentOptions.propsData
	  });
	}

	var ts = function ts(t) {
	  return t.tag || ae(t);
	},
	    es = function es(t) {
	  return "show" === t.name;
	};

	var ns = {
	  name: "transition",
	  props: Gr,
	  abstract: !0,
	  render: function render(t) {
	    var _this3 = this;

	    var e = this.$slots.default;
	    if (!e) return;
	    if (!(e = e.filter(ts)).length) return;
	    var n = this.mode,
	        o = e[0];
	    if (function (t) {
	      for (; t = t.parent;) {
	        if (t.data.transition) return !0;
	      }
	    }(this.$vnode)) return o;
	    var s = Xr(o);
	    if (!s) return o;
	    if (this._leaving) return Qr(t, o);
	    var i = "__transition-".concat(this._uid, "-");
	    s.key = null == s.key ? s.isComment ? i + "comment" : i + s.tag : r(s.key) ? 0 === String(s.key).indexOf(i) ? s.key : i + s.key : s.key;
	    var a = (s.data || (s.data = {})).transition = Yr(this),
	        c = this._vnode,
	        l = Xr(c);

	    if (s.data.directives && s.data.directives.some(es) && (s.data.show = !0), l && l.data && !function (t, e) {
	      return e.key === t.key && e.tag === t.tag;
	    }(s, l) && !ae(l) && (!l.componentInstance || !l.componentInstance._vnode.isComment)) {
	      var _e41 = l.data.transition = A({}, a);

	      if ("out-in" === n) return this._leaving = !0, te(_e41, "afterLeave", function () {
	        _this3._leaving = !1, _this3.$forceUpdate();
	      }), Qr(t, o);

	      if ("in-out" === n) {
	        if (ae(s)) return c;

	        var _t46;

	        var _n49 = function _n49() {
	          _t46();
	        };

	        te(a, "afterEnter", _n49), te(a, "enterCancelled", _n49), te(_e41, "delayLeave", function (e) {
	          _t46 = e;
	        });
	      }
	    }

	    return o;
	  }
	};
	var os = A({
	  tag: String,
	  moveClass: String
	}, Gr);

	function rs(t) {
	  t.elm._moveCb && t.elm._moveCb(), t.elm._enterCb && t.elm._enterCb();
	}

	function ss(t) {
	  t.data.newPos = t.elm.getBoundingClientRect();
	}

	function is(t) {
	  var e = t.data.pos,
	      n = t.data.newPos,
	      o = e.left - n.left,
	      r = e.top - n.top;

	  if (o || r) {
	    t.data.moved = !0;
	    var _e42 = t.elm.style;
	    _e42.transform = _e42.WebkitTransform = "translate(".concat(o, "px,").concat(r, "px)"), _e42.transitionDuration = "0s";
	  }
	}

	delete os.mode;
	var as = {
	  Transition: ns,
	  TransitionGroup: {
	    props: os,
	    beforeMount: function beforeMount() {
	      var _this4 = this;

	      var t = this._update;

	      this._update = function (e, n) {
	        var o = Ke(_this4);
	        _this4.__patch__(_this4._vnode, _this4.kept, !1, !0), _this4._vnode = _this4.kept, o(), t.call(_this4, e, n);
	      };
	    },
	    render: function render(t) {
	      var e = this.tag || this.$vnode.data.tag || "span",
	          n = Object.create(null),
	          o = this.prevChildren = this.children,
	          r = this.$slots.default || [],
	          s = this.children = [],
	          i = Yr(this);

	      for (var _t47 = 0; _t47 < r.length; _t47++) {
	        var _e43 = r[_t47];
	        _e43.tag && null != _e43.key && 0 !== String(_e43.key).indexOf("__vlist") && (s.push(_e43), n[_e43.key] = _e43, (_e43.data || (_e43.data = {})).transition = i);
	      }

	      if (o) {
	        var _r27 = [],
	            _s15 = [];

	        for (var _t48 = 0; _t48 < o.length; _t48++) {
	          var _e44 = o[_t48];
	          _e44.data.transition = i, _e44.data.pos = _e44.elm.getBoundingClientRect(), n[_e44.key] ? _r27.push(_e44) : _s15.push(_e44);
	        }

	        this.kept = t(e, null, _r27), this.removed = _s15;
	      }

	      return t(e, null, s);
	    },
	    updated: function updated() {
	      var t = this.prevChildren,
	          e = this.moveClass || (this.name || "v") + "-move";
	      t.length && this.hasMove(t[0].elm, e) && (t.forEach(rs), t.forEach(ss), t.forEach(is), this._reflow = document.body.offsetHeight, t.forEach(function (t) {
	        if (t.data.moved) {
	          var _n50 = t.elm,
	              _o42 = _n50.style;
	          Or(_n50, e), _o42.transform = _o42.WebkitTransform = _o42.transitionDuration = "", _n50.addEventListener(wr, _n50._moveCb = function t(o) {
	            o && o.target !== _n50 || o && !/transform$/.test(o.propertyName) || (_n50.removeEventListener(wr, t), _n50._moveCb = null, Sr(_n50, e));
	          });
	        }
	      }));
	    },
	    methods: {
	      hasMove: function hasMove(t, e) {
	        if (!vr) return !1;
	        if (this._hasMove) return this._hasMove;
	        var n = t.cloneNode();
	        t._transitionClasses && t._transitionClasses.forEach(function (t) {
	          mr(n, t);
	        }), hr(n, e), n.style.display = "none", this.$el.appendChild(n);
	        var o = Er(n);
	        return this.$el.removeChild(n), this._hasMove = o.hasTransform;
	      }
	    }
	  }
	};
	gn.config.mustUseProp = On, gn.config.isReservedTag = Vn, gn.config.isReservedAttr = kn, gn.config.getTagNamespace = zn, gn.config.isUnknownElement = function (t) {
	  if (!V) return !0;
	  if (Vn(t)) return !1;
	  if (t = t.toLowerCase(), null != Kn[t]) return Kn[t];
	  var e = document.createElement(t);
	  return t.indexOf("-") > -1 ? Kn[t] = e.constructor === window.HTMLUnknownElement || e.constructor === window.HTMLElement : Kn[t] = /HTMLUnknownElement/.test(e.toString());
	}, A(gn.options.directives, Zr), A(gn.options.components, as), gn.prototype.__patch__ = V ? Rr : S, gn.prototype.$mount = function (t, e) {
	  return function (t, e, n) {
	    var o;
	    return t.$el = e, t.$options.render || (t.$options.render = pt), We(t, "beforeMount"), o = function o() {
	      t._update(t._render(), n);
	    }, new sn(t, o, S, {
	      before: function before() {
	        t._isMounted && !t._isDestroyed && We(t, "beforeUpdate");
	      }
	    }, !0), n = !1, null == t.$vnode && (t._isMounted = !0, We(t, "mounted")), t;
	  }(this, t = t && V ? qn(t) : void 0, e);
	}, V && setTimeout(function () {
	  F.devtools && nt && nt.emit("init", gn);
	}, 0);
	var cs = /\{\{((?:.|\r?\n)+?)\}\}/g,
	    ls = /[-.*+?^${}()|[\]\/\\]/g,
	    us = v(function (t) {
	  var e = t[0].replace(ls, "\\$&"),
	      n = t[1].replace(ls, "\\$&");
	  return new RegExp(e + "((?:.|\\n)+?)" + n, "g");
	});
	var fs = {
	  staticKeys: ["staticClass"],
	  transformNode: function transformNode(t, e) {
	    e.warn;
	    var n = Oo(t, "class");
	    n && (t.staticClass = JSON.stringify(n));
	    var o = Ao(t, "class", !1);
	    o && (t.classBinding = o);
	  },
	  genData: function genData(t) {
	    var e = "";
	    return t.staticClass && (e += "staticClass:".concat(t.staticClass, ",")), t.classBinding && (e += "class:".concat(t.classBinding, ",")), e;
	  }
	};
	var ds = {
	  staticKeys: ["staticStyle"],
	  transformNode: function transformNode(t, e) {
	    e.warn;
	    var n = Oo(t, "style");
	    n && (t.staticStyle = JSON.stringify(nr(n)));
	    var o = Ao(t, "style", !1);
	    o && (t.styleBinding = o);
	  },
	  genData: function genData(t) {
	    var e = "";
	    return t.staticStyle && (e += "staticStyle:".concat(t.staticStyle, ",")), t.styleBinding && (e += "style:(".concat(t.styleBinding, "),")), e;
	  }
	};
	var ps;
	var hs = {
	  decode: function decode(t) {
	    return (ps = ps || document.createElement("div")).innerHTML = t, ps.textContent;
	  }
	};

	var ms = d("area,base,br,col,embed,frame,hr,img,input,isindex,keygen,link,meta,param,source,track,wbr"),
	    ys = d("colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source"),
	    gs = d("address,article,aside,base,blockquote,body,caption,col,colgroup,dd,details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,title,tr,track"),
	    vs = /^\s*([^\s"'<>\/=]+)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/,
	    $s = /^\s*((?:v-[\w-]+:|@|:|#)\[[^=]+?\][^\s"'<>\/=]*)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/,
	    _s = "[a-zA-Z_][\\-\\.0-9_a-zA-Z".concat(P.source, "]*"),
	    bs = "((?:".concat(_s, "\\:)?").concat(_s, ")"),
	    ws = new RegExp("^<".concat(bs)),
	    Cs = /^\s*(\/?)>/,
	    xs = new RegExp("^<\\/".concat(bs, "[^>]*>")),
	    ks = /^<!DOCTYPE [^>]+>/i,
	    As = /^<!\--/,
	    Os = /^<!\[/,
	    Ss = d("script,style,textarea", !0),
	    Ts = {},
	    Ns = {
	  "&lt;": "<",
	  "&gt;": ">",
	  "&quot;": '"',
	  "&amp;": "&",
	  "&#10;": "\n",
	  "&#9;": "\t",
	  "&#39;": "'"
	},
	    Es = /&(?:lt|gt|quot|amp|#39);/g,
	    js = /&(?:lt|gt|quot|amp|#39|#10|#9);/g,
	    Ds = d("pre,textarea", !0),
	    Ls = function Ls(t, e) {
	  return t && Ds(t) && "\n" === e[0];
	};

	function Is(t, e) {
	  var n = e ? js : Es;
	  return t.replace(n, function (t) {
	    return Ns[t];
	  });
	}

	var Ms = /^@|^v-on:/,
	    Fs = /^v-|^@|^:|^#/,
	    Ps = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/,
	    Rs = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/,
	    Hs = /^\(|\)$/g,
	    Bs = /^\[.*\]$/,
	    Us = /:(.*)$/,
	    Vs = /^:|^\.|^v-bind:/,
	    zs = /\.[^.\]]+(?=[^\]]*$)/g,
	    Ks = /^v-slot(:|$)|^#/,
	    Js = /[\r\n]/,
	    qs = /[ \f\t\r\n]+/g,
	    Ws = v(hs.decode),
	    Zs = "_empty_";
	var Gs, Xs, Ys, Qs, ti, ei, ni, oi;

	function ri(t, e, n) {
	  return {
	    type: 1,
	    tag: t,
	    attrsList: e,
	    attrsMap: fi(e),
	    rawAttrsMap: {},
	    parent: n,
	    children: []
	  };
	}

	function si(t, e) {
	  Gs = e.warn || vo, ei = e.isPreTag || T, ni = e.mustUseProp || T, oi = e.getTagNamespace || T;
	  e.isReservedTag;
	  Ys = $o(e.modules, "transformNode"), Qs = $o(e.modules, "preTransformNode"), ti = $o(e.modules, "postTransformNode"), Xs = e.delimiters;
	  var n = [],
	      o = !1 !== e.preserveWhitespace,
	      r = e.whitespace;
	  var s,
	      i,
	      a = !1,
	      c = !1;

	  function l(t) {
	    if (u(t), a || t.processed || (t = ii(t, e)), n.length || t === s || s.if && (t.elseif || t.else) && ci(s, {
	      exp: t.elseif,
	      block: t
	    }), i && !t.forbidden) if (t.elseif || t.else) !function (t, e) {
	      var n = function (t) {
	        var e = t.length;

	        for (; e--;) {
	          if (1 === t[e].type) return t[e];
	          t.pop();
	        }
	      }(e.children);

	      n && n.if && ci(n, {
	        exp: t.elseif,
	        block: t
	      });
	    }(t, i);else {
	      if (t.slotScope) {
	        var _e45 = t.slotTarget || '"default"';

	        (i.scopedSlots || (i.scopedSlots = {}))[_e45] = t;
	      }

	      i.children.push(t), t.parent = i;
	    }
	    t.children = t.children.filter(function (t) {
	      return !t.slotScope;
	    }), u(t), t.pre && (a = !1), ei(t.tag) && (c = !1);

	    for (var _n51 = 0; _n51 < ti.length; _n51++) {
	      ti[_n51](t, e);
	    }
	  }

	  function u(t) {
	    if (!c) {
	      var _e46;

	      for (; (_e46 = t.children[t.children.length - 1]) && 3 === _e46.type && " " === _e46.text;) {
	        t.children.pop();
	      }
	    }
	  }

	  return function (t, e) {
	    var n = [],
	        o = e.expectHTML,
	        r = e.isUnaryTag || T,
	        s = e.canBeLeftOpenTag || T;
	    var i,
	        a,
	        c = 0;

	    for (; t;) {
	      if (i = t, a && Ss(a)) {
	        (function () {
	          var n = 0;
	          var o = a.toLowerCase(),
	              r = Ts[o] || (Ts[o] = new RegExp("([\\s\\S]*?)(</" + o + "[^>]*>)", "i")),
	              s = t.replace(r, function (t, r, s) {
	            return n = s.length, Ss(o) || "noscript" === o || (r = r.replace(/<!\--([\s\S]*?)-->/g, "$1").replace(/<!\[CDATA\[([\s\S]*?)]]>/g, "$1")), Ls(o, r) && (r = r.slice(1)), e.chars && e.chars(r), "";
	          });
	          c += t.length - s.length, t = s, d(o, c - n, c);
	        })();
	      } else {
	        var _n52 = void 0,
	            _o43 = void 0,
	            _r28 = void 0,
	            _s16 = t.indexOf("<");

	        if (0 === _s16) {
	          if (As.test(t)) {
	            var _n54 = t.indexOf("--\x3e");

	            if (_n54 >= 0) {
	              e.shouldKeepComment && e.comment(t.substring(4, _n54), c, c + _n54 + 3), l(_n54 + 3);
	              continue;
	            }
	          }

	          if (Os.test(t)) {
	            var _e47 = t.indexOf("]>");

	            if (_e47 >= 0) {
	              l(_e47 + 2);
	              continue;
	            }
	          }

	          var _n53 = t.match(ks);

	          if (_n53) {
	            l(_n53[0].length);
	            continue;
	          }

	          var _o44 = t.match(xs);

	          if (_o44) {
	            var _t49 = c;
	            l(_o44[0].length), d(_o44[1], _t49, c);
	            continue;
	          }

	          var _r29 = u();

	          if (_r29) {
	            f(_r29), Ls(_r29.tagName, t) && l(1);
	            continue;
	          }
	        }

	        if (_s16 >= 0) {
	          for (_o43 = t.slice(_s16); !(xs.test(_o43) || ws.test(_o43) || As.test(_o43) || Os.test(_o43) || (_r28 = _o43.indexOf("<", 1)) < 0);) {
	            _s16 += _r28, _o43 = t.slice(_s16);
	          }

	          _n52 = t.substring(0, _s16);
	        }

	        _s16 < 0 && (_n52 = t), _n52 && l(_n52.length), e.chars && _n52 && e.chars(_n52, c - _n52.length, c);
	      }

	      if (t === i) {
	        e.chars && e.chars(t);
	        break;
	      }
	    }

	    function l(e) {
	      c += e, t = t.substring(e);
	    }

	    function u() {
	      var e = t.match(ws);

	      if (e) {
	        var _n55 = {
	          tagName: e[1],
	          attrs: [],
	          start: c
	        };

	        var _o45, _r30;

	        for (l(e[0].length); !(_o45 = t.match(Cs)) && (_r30 = t.match($s) || t.match(vs));) {
	          _r30.start = c, l(_r30[0].length), _r30.end = c, _n55.attrs.push(_r30);
	        }

	        if (_o45) return _n55.unarySlash = _o45[1], l(_o45[0].length), _n55.end = c, _n55;
	      }
	    }

	    function f(t) {
	      var i = t.tagName,
	          c = t.unarySlash;
	      o && ("p" === a && gs(i) && d(a), s(i) && a === i && d(i));
	      var l = r(i) || !!c,
	          u = t.attrs.length,
	          f = new Array(u);

	      for (var _n56 = 0; _n56 < u; _n56++) {
	        var _o46 = t.attrs[_n56],
	            _r31 = _o46[3] || _o46[4] || _o46[5] || "",
	            _s17 = "a" === i && "href" === _o46[1] ? e.shouldDecodeNewlinesForHref : e.shouldDecodeNewlines;

	        f[_n56] = {
	          name: _o46[1],
	          value: Is(_r31, _s17)
	        };
	      }

	      l || (n.push({
	        tag: i,
	        lowerCasedTag: i.toLowerCase(),
	        attrs: f,
	        start: t.start,
	        end: t.end
	      }), a = i), e.start && e.start(i, f, l, t.start, t.end);
	    }

	    function d(t, o, r) {
	      var s, i;
	      if (null == o && (o = c), null == r && (r = c), t) for (i = t.toLowerCase(), s = n.length - 1; s >= 0 && n[s].lowerCasedTag !== i; s--) {
	      } else s = 0;

	      if (s >= 0) {
	        for (var _t50 = n.length - 1; _t50 >= s; _t50--) {
	          e.end && e.end(n[_t50].tag, o, r);
	        }

	        n.length = s, a = s && n[s - 1].tag;
	      } else "br" === i ? e.start && e.start(t, [], !0, o, r) : "p" === i && (e.start && e.start(t, [], !1, o, r), e.end && e.end(t, o, r));
	    }

	    d();
	  }(t, {
	    warn: Gs,
	    expectHTML: e.expectHTML,
	    isUnaryTag: e.isUnaryTag,
	    canBeLeftOpenTag: e.canBeLeftOpenTag,
	    shouldDecodeNewlines: e.shouldDecodeNewlines,
	    shouldDecodeNewlinesForHref: e.shouldDecodeNewlinesForHref,
	    shouldKeepComment: e.comments,
	    outputSourceRange: e.outputSourceRange,
	    start: function start(t, o, r, u, f) {
	      var d = i && i.ns || oi(t);
	      q && "svg" === d && (o = function (t) {
	        var e = [];

	        for (var _n57 = 0; _n57 < t.length; _n57++) {
	          var _o47 = t[_n57];
	          di.test(_o47.name) || (_o47.name = _o47.name.replace(pi, ""), e.push(_o47));
	        }

	        return e;
	      }(o));
	      var p = ri(t, o, i);
	      var h;
	      d && (p.ns = d), "style" !== (h = p).tag && ("script" !== h.tag || h.attrsMap.type && "text/javascript" !== h.attrsMap.type) || et() || (p.forbidden = !0);

	      for (var _t51 = 0; _t51 < Qs.length; _t51++) {
	        p = Qs[_t51](p, e) || p;
	      }

	      a || (!function (t) {
	        null != Oo(t, "v-pre") && (t.pre = !0);
	      }(p), p.pre && (a = !0)), ei(p.tag) && (c = !0), a ? function (t) {
	        var e = t.attrsList,
	            n = e.length;

	        if (n) {
	          var _o48 = t.attrs = new Array(n);

	          for (var _t52 = 0; _t52 < n; _t52++) {
	            _o48[_t52] = {
	              name: e[_t52].name,
	              value: JSON.stringify(e[_t52].value)
	            }, null != e[_t52].start && (_o48[_t52].start = e[_t52].start, _o48[_t52].end = e[_t52].end);
	          }
	        } else t.pre || (t.plain = !0);
	      }(p) : p.processed || (ai(p), function (t) {
	        var e = Oo(t, "v-if");
	        if (e) t.if = e, ci(t, {
	          exp: e,
	          block: t
	        });else {
	          null != Oo(t, "v-else") && (t.else = !0);

	          var _e48 = Oo(t, "v-else-if");

	          _e48 && (t.elseif = _e48);
	        }
	      }(p), function (t) {
	        null != Oo(t, "v-once") && (t.once = !0);
	      }(p)), s || (s = p), r ? l(p) : (i = p, n.push(p));
	    },
	    end: function end(t, e, o) {
	      var r = n[n.length - 1];
	      n.length -= 1, i = n[n.length - 1], l(r);
	    },
	    chars: function chars(t, e, n) {
	      if (!i) return;
	      if (q && "textarea" === i.tag && i.attrsMap.placeholder === t) return;
	      var s = i.children;
	      var l;

	      if (t = c || t.trim() ? "script" === (l = i).tag || "style" === l.tag ? t : Ws(t) : s.length ? r ? "condense" === r && Js.test(t) ? "" : " " : o ? " " : "" : "") {
	        var _e49, _n58;

	        c || "condense" !== r || (t = t.replace(qs, " ")), !a && " " !== t && (_e49 = function (t, e) {
	          var n = e ? us(e) : cs;
	          if (!n.test(t)) return;
	          var o = [],
	              r = [];
	          var s,
	              i,
	              a,
	              c = n.lastIndex = 0;

	          for (; s = n.exec(t);) {
	            (i = s.index) > c && (r.push(a = t.slice(c, i)), o.push(JSON.stringify(a)));

	            var _e50 = yo(s[1].trim());

	            o.push("_s(".concat(_e50, ")")), r.push({
	              "@binding": _e50
	            }), c = i + s[0].length;
	          }

	          return c < t.length && (r.push(a = t.slice(c)), o.push(JSON.stringify(a))), {
	            expression: o.join("+"),
	            tokens: r
	          };
	        }(t, Xs)) ? _n58 = {
	          type: 2,
	          expression: _e49.expression,
	          tokens: _e49.tokens,
	          text: t
	        } : " " === t && s.length && " " === s[s.length - 1].text || (_n58 = {
	          type: 3,
	          text: t
	        }), _n58 && s.push(_n58);
	      }
	    },
	    comment: function comment(t, e, n) {
	      if (i) {
	        var _e51 = {
	          type: 3,
	          text: t,
	          isComment: !0
	        };
	        i.children.push(_e51);
	      }
	    }
	  }), s;
	}

	function ii(t, e) {
	  var n;
	  !function (t) {
	    var e = Ao(t, "key");
	    e && (t.key = e);
	  }(t), t.plain = !t.key && !t.scopedSlots && !t.attrsList.length, function (t) {
	    var e = Ao(t, "ref");
	    e && (t.ref = e, t.refInFor = function (t) {
	      var e = t;

	      for (; e;) {
	        if (void 0 !== e.for) return !0;
	        e = e.parent;
	      }

	      return !1;
	    }(t));
	  }(t), function (t) {
	    var e;
	    "template" === t.tag ? (e = Oo(t, "scope"), t.slotScope = e || Oo(t, "slot-scope")) : (e = Oo(t, "slot-scope")) && (t.slotScope = e);
	    var n = Ao(t, "slot");
	    n && (t.slotTarget = '""' === n ? '"default"' : n, t.slotTargetDynamic = !(!t.attrsMap[":slot"] && !t.attrsMap["v-bind:slot"]), "template" === t.tag || t.slotScope || bo(t, "slot", n, function (t, e) {
	      return t.rawAttrsMap[":" + e] || t.rawAttrsMap["v-bind:" + e] || t.rawAttrsMap[e];
	    }(t, "slot")));

	    if ("template" === t.tag) {
	      var _e52 = So(t, Ks);

	      if (_e52) {
	        var _li = li(_e52),
	            _n59 = _li.name,
	            _o49 = _li.dynamic;

	        t.slotTarget = _n59, t.slotTargetDynamic = _o49, t.slotScope = _e52.value || Zs;
	      }
	    } else {
	      var _e53 = So(t, Ks);

	      if (_e53) {
	        var _n60 = t.scopedSlots || (t.scopedSlots = {}),
	            _li2 = li(_e53),
	            _o50 = _li2.name,
	            _r32 = _li2.dynamic,
	            _s18 = _n60[_o50] = ri("template", [], t);

	        _s18.slotTarget = _o50, _s18.slotTargetDynamic = _r32, _s18.children = t.children.filter(function (t) {
	          if (!t.slotScope) return t.parent = _s18, !0;
	        }), _s18.slotScope = _e53.value || Zs, t.children = [], t.plain = !1;
	      }
	    }
	  }(t), "slot" === (n = t).tag && (n.slotName = Ao(n, "name")), function (t) {
	    var e;
	    (e = Ao(t, "is")) && (t.component = e);
	    null != Oo(t, "inline-template") && (t.inlineTemplate = !0);
	  }(t);

	  for (var _n61 = 0; _n61 < Ys.length; _n61++) {
	    t = Ys[_n61](t, e) || t;
	  }

	  return function (t) {
	    var e = t.attrsList;
	    var n, o, r, s, i, a, c, l;

	    for (n = 0, o = e.length; n < o; n++) {
	      if (r = s = e[n].name, i = e[n].value, Fs.test(r)) {
	        if (t.hasBindings = !0, (a = ui(r.replace(Fs, ""))) && (r = r.replace(zs, "")), Vs.test(r)) r = r.replace(Vs, ""), i = yo(i), (l = Bs.test(r)) && (r = r.slice(1, -1)), a && (a.prop && !l && "innerHtml" === (r = _(r)) && (r = "innerHTML"), a.camel && !l && (r = _(r)), a.sync && (c = Eo(i, "$event"), l ? ko(t, "\"update:\"+(".concat(r, ")"), c, null, !1, 0, e[n], !0) : (ko(t, "update:".concat(_(r)), c, null, !1, 0, e[n]), C(r) !== _(r) && ko(t, "update:".concat(C(r)), c, null, !1, 0, e[n])))), a && a.prop || !t.component && ni(t.tag, t.attrsMap.type, r) ? _o(t, r, i, e[n], l) : bo(t, r, i, e[n], l);else if (Ms.test(r)) r = r.replace(Ms, ""), (l = Bs.test(r)) && (r = r.slice(1, -1)), ko(t, r, i, a, !1, 0, e[n], l);else {
	          var _o51 = (r = r.replace(Fs, "")).match(Us);

	          var _c6 = _o51 && _o51[1];

	          l = !1, _c6 && (r = r.slice(0, -(_c6.length + 1)), Bs.test(_c6) && (_c6 = _c6.slice(1, -1), l = !0)), Co(t, r, s, i, _c6, l, a, e[n]);
	        }
	      } else bo(t, r, JSON.stringify(i), e[n]), !t.component && "muted" === r && ni(t.tag, t.attrsMap.type, r) && _o(t, r, "true", e[n]);
	    }
	  }(t), t;
	}

	function ai(t) {
	  var e;

	  if (e = Oo(t, "v-for")) {
	    var _n62 = function (t) {
	      var e = t.match(Ps);
	      if (!e) return;
	      var n = {};
	      n.for = e[2].trim();
	      var o = e[1].trim().replace(Hs, ""),
	          r = o.match(Rs);
	      r ? (n.alias = o.replace(Rs, "").trim(), n.iterator1 = r[1].trim(), r[2] && (n.iterator2 = r[2].trim())) : n.alias = o;
	      return n;
	    }(e);

	    _n62 && A(t, _n62);
	  }
	}

	function ci(t, e) {
	  t.ifConditions || (t.ifConditions = []), t.ifConditions.push(e);
	}

	function li(t) {
	  var e = t.name.replace(Ks, "");
	  return e || "#" !== t.name[0] && (e = "default"), Bs.test(e) ? {
	    name: e.slice(1, -1),
	    dynamic: !0
	  } : {
	    name: "\"".concat(e, "\""),
	    dynamic: !1
	  };
	}

	function ui(t) {
	  var e = t.match(zs);

	  if (e) {
	    var _t53 = {};
	    return e.forEach(function (e) {
	      _t53[e.slice(1)] = !0;
	    }), _t53;
	  }
	}

	function fi(t) {
	  var e = {};

	  for (var _n63 = 0, _o52 = t.length; _n63 < _o52; _n63++) {
	    e[t[_n63].name] = t[_n63].value;
	  }

	  return e;
	}

	var di = /^xmlns:NS\d+/,
	    pi = /^NS\d+:/;

	function hi(t) {
	  return ri(t.tag, t.attrsList.slice(), t.parent);
	}

	var mi = [fs, ds, {
	  preTransformNode: function preTransformNode(t, e) {
	    if ("input" === t.tag) {
	      var _n64 = t.attrsMap;
	      if (!_n64["v-model"]) return;

	      var _o53;

	      if ((_n64[":type"] || _n64["v-bind:type"]) && (_o53 = Ao(t, "type")), _n64.type || _o53 || !_n64["v-bind"] || (_o53 = "(".concat(_n64["v-bind"], ").type")), _o53) {
	        var _n65 = Oo(t, "v-if", !0),
	            _r33 = _n65 ? "&&(".concat(_n65, ")") : "",
	            _s19 = null != Oo(t, "v-else", !0),
	            _i12 = Oo(t, "v-else-if", !0),
	            _a5 = hi(t);

	        ai(_a5), wo(_a5, "type", "checkbox"), ii(_a5, e), _a5.processed = !0, _a5.if = "(".concat(_o53, ")==='checkbox'") + _r33, ci(_a5, {
	          exp: _a5.if,
	          block: _a5
	        });

	        var _c7 = hi(t);

	        Oo(_c7, "v-for", !0), wo(_c7, "type", "radio"), ii(_c7, e), ci(_a5, {
	          exp: "(".concat(_o53, ")==='radio'") + _r33,
	          block: _c7
	        });

	        var _l = hi(t);

	        return Oo(_l, "v-for", !0), wo(_l, ":type", _o53), ii(_l, e), ci(_a5, {
	          exp: _n65,
	          block: _l
	        }), _s19 ? _a5.else = !0 : _i12 && (_a5.elseif = _i12), _a5;
	      }
	    }
	  }
	}];
	var yi = {
	  expectHTML: !0,
	  modules: mi,
	  directives: {
	    model: function model(t, e, n) {
	      var o = e.value,
	          r = e.modifiers,
	          s = t.tag,
	          i = t.attrsMap.type;
	      if (t.component) return No(t, o, r), !1;
	      if ("select" === s) !function (t, e, n) {
	        var o = "var $$selectedVal = ".concat('Array.prototype.filter.call($event.target.options,function(o){return o.selected}).map(function(o){var val = "_value" in o ? o._value : o.value;' + "return ".concat(n && n.number ? "_n(val)" : "val", "})"), ";");
	        o = "".concat(o, " ").concat(Eo(e, "$event.target.multiple ? $$selectedVal : $$selectedVal[0]")), ko(t, "change", o, null, !0);
	      }(t, o, r);else if ("input" === s && "checkbox" === i) !function (t, e, n) {
	        var o = n && n.number,
	            r = Ao(t, "value") || "null",
	            s = Ao(t, "true-value") || "true",
	            i = Ao(t, "false-value") || "false";
	        _o(t, "checked", "Array.isArray(".concat(e, ")") + "?_i(".concat(e, ",").concat(r, ")>-1") + ("true" === s ? ":(".concat(e, ")") : ":_q(".concat(e, ",").concat(s, ")"))), ko(t, "change", "var $$a=".concat(e, ",") + "$$el=$event.target," + "$$c=$$el.checked?(".concat(s, "):(").concat(i, ");") + "if(Array.isArray($$a)){" + "var $$v=".concat(o ? "_n(" + r + ")" : r, ",") + "$$i=_i($$a,$$v);" + "if($$el.checked){$$i<0&&(".concat(Eo(e, "$$a.concat([$$v])"), ")}") + "else{$$i>-1&&(".concat(Eo(e, "$$a.slice(0,$$i).concat($$a.slice($$i+1))"), ")}") + "}else{".concat(Eo(e, "$$c"), "}"), null, !0);
	      }(t, o, r);else if ("input" === s && "radio" === i) !function (t, e, n) {
	        var o = n && n.number;
	        var r = Ao(t, "value") || "null";
	        _o(t, "checked", "_q(".concat(e, ",").concat(r = o ? "_n(".concat(r, ")") : r, ")")), ko(t, "change", Eo(e, r), null, !0);
	      }(t, o, r);else if ("input" === s || "textarea" === s) !function (t, e, n) {
	        var o = t.attrsMap.type,
	            _ref4 = n || {},
	            r = _ref4.lazy,
	            s = _ref4.number,
	            i = _ref4.trim,
	            a = !r && "range" !== o,
	            c = r ? "change" : "range" === o ? Vo : "input";

	        var l = "$event.target.value";
	        i && (l = "$event.target.value.trim()"), s && (l = "_n(".concat(l, ")"));
	        var u = Eo(e, l);
	        a && (u = "if($event.target.composing)return;".concat(u)), _o(t, "value", "(".concat(e, ")")), ko(t, c, u, null, !0), (i || s) && ko(t, "blur", "$forceUpdate()");
	      }(t, o, r);else if (!F.isReservedTag(s)) return No(t, o, r), !1;
	      return !0;
	    },
	    text: function text(t, e) {
	      e.value && _o(t, "textContent", "_s(".concat(e.value, ")"), e);
	    },
	    html: function html(t, e) {
	      e.value && _o(t, "innerHTML", "_s(".concat(e.value, ")"), e);
	    }
	  },
	  isPreTag: function isPreTag(t) {
	    return "pre" === t;
	  },
	  isUnaryTag: ms,
	  mustUseProp: On,
	  canBeLeftOpenTag: ys,
	  isReservedTag: Vn,
	  getTagNamespace: zn,
	  staticKeys: function (t) {
	    return t.reduce(function (t, e) {
	      return t.concat(e.staticKeys || []);
	    }, []).join(",");
	  }(mi)
	};
	var gi, vi;
	var $i = v(function (t) {
	  return d("type,tag,attrsList,attrsMap,plain,parent,children,attrs,start,end,rawAttrsMap" + (t ? "," + t : ""));
	});

	function _i(t, e) {
	  t && (gi = $i(e.staticKeys || ""), vi = e.isReservedTag || T, function t(e) {
	    e.static = function (t) {
	      if (2 === t.type) return !1;
	      if (3 === t.type) return !0;
	      return !(!t.pre && (t.hasBindings || t.if || t.for || p(t.tag) || !vi(t.tag) || function (t) {
	        for (; t.parent;) {
	          if ("template" !== (t = t.parent).tag) return !1;
	          if (t.for) return !0;
	        }

	        return !1;
	      }(t) || !Object.keys(t).every(gi)));
	    }(e);

	    if (1 === e.type) {
	      if (!vi(e.tag) && "slot" !== e.tag && null == e.attrsMap["inline-template"]) return;

	      for (var _n66 = 0, _o54 = e.children.length; _n66 < _o54; _n66++) {
	        var _o55 = e.children[_n66];
	        t(_o55), _o55.static || (e.static = !1);
	      }

	      if (e.ifConditions) for (var _n67 = 1, _o56 = e.ifConditions.length; _n67 < _o56; _n67++) {
	        var _o57 = e.ifConditions[_n67].block;
	        t(_o57), _o57.static || (e.static = !1);
	      }
	    }
	  }(t), function t(e, n) {
	    if (1 === e.type) {
	      if ((e.static || e.once) && (e.staticInFor = n), e.static && e.children.length && (1 !== e.children.length || 3 !== e.children[0].type)) return void (e.staticRoot = !0);
	      if (e.staticRoot = !1, e.children) for (var _o58 = 0, _r34 = e.children.length; _o58 < _r34; _o58++) {
	        t(e.children[_o58], n || !!e.for);
	      }
	      if (e.ifConditions) for (var _o59 = 1, _r35 = e.ifConditions.length; _o59 < _r35; _o59++) {
	        t(e.ifConditions[_o59].block, n);
	      }
	    }
	  }(t, !1));
	}

	var bi = /^([\w$_]+|\([^)]*?\))\s*=>|^function(?:\s+[\w$]+)?\s*\(/,
	    wi = /\([^)]*?\);*$/,
	    Ci = /^[A-Za-z_$][\w$]*(?:\.[A-Za-z_$][\w$]*|\['[^']*?']|\["[^"]*?"]|\[\d+]|\[[A-Za-z_$][\w$]*])*$/,
	    xi = {
	  esc: 27,
	  tab: 9,
	  enter: 13,
	  space: 32,
	  up: 38,
	  left: 37,
	  right: 39,
	  down: 40,
	  delete: [8, 46]
	},
	    ki = {
	  esc: ["Esc", "Escape"],
	  tab: "Tab",
	  enter: "Enter",
	  space: [" ", "Spacebar"],
	  up: ["Up", "ArrowUp"],
	  left: ["Left", "ArrowLeft"],
	  right: ["Right", "ArrowRight"],
	  down: ["Down", "ArrowDown"],
	  delete: ["Backspace", "Delete", "Del"]
	},
	    Ai = function Ai(t) {
	  return "if(".concat(t, ")return null;");
	},
	    Oi = {
	  stop: "$event.stopPropagation();",
	  prevent: "$event.preventDefault();",
	  self: Ai("$event.target !== $event.currentTarget"),
	  ctrl: Ai("!$event.ctrlKey"),
	  shift: Ai("!$event.shiftKey"),
	  alt: Ai("!$event.altKey"),
	  meta: Ai("!$event.metaKey"),
	  left: Ai("'button' in $event && $event.button !== 0"),
	  middle: Ai("'button' in $event && $event.button !== 1"),
	  right: Ai("'button' in $event && $event.button !== 2")
	};

	function Si(t, e) {
	  var n = e ? "nativeOn:" : "on:";
	  var o = "",
	      r = "";

	  for (var _e54 in t) {
	    var _n68 = Ti(t[_e54]);

	    t[_e54] && t[_e54].dynamic ? r += "".concat(_e54, ",").concat(_n68, ",") : o += "\"".concat(_e54, "\":").concat(_n68, ",");
	  }

	  return o = "{".concat(o.slice(0, -1), "}"), r ? n + "_d(".concat(o, ",[").concat(r.slice(0, -1), "])") : n + o;
	}

	function Ti(t) {
	  if (!t) return "function(){}";
	  if (Array.isArray(t)) return "[".concat(t.map(function (t) {
	    return Ti(t);
	  }).join(","), "]");
	  var e = Ci.test(t.value),
	      n = bi.test(t.value),
	      o = Ci.test(t.value.replace(wi, ""));

	  if (t.modifiers) {
	    var _r36 = "",
	        _s20 = "";
	    var _i13 = [];

	    for (var _e55 in t.modifiers) {
	      if (Oi[_e55]) _s20 += Oi[_e55], xi[_e55] && _i13.push(_e55);else if ("exact" === _e55) {
	        (function () {
	          var e = t.modifiers;
	          _s20 += Ai(["ctrl", "shift", "alt", "meta"].filter(function (t) {
	            return !e[t];
	          }).map(function (t) {
	            return "$event.".concat(t, "Key");
	          }).join("||"));
	        })();
	      } else _i13.push(_e55);
	    }

	    return _i13.length && (_r36 += function (t) {
	      return "if(!$event.type.indexOf('key')&&" + "".concat(t.map(Ni).join("&&"), ")return null;");
	    }(_i13)), _s20 && (_r36 += _s20), "function($event){".concat(_r36).concat(e ? "return ".concat(t.value, ".apply(null, arguments)") : n ? "return (".concat(t.value, ").apply(null, arguments)") : o ? "return ".concat(t.value) : t.value, "}");
	  }

	  return e || n ? t.value : "function($event){".concat(o ? "return ".concat(t.value) : t.value, "}");
	}

	function Ni(t) {
	  var e = parseInt(t, 10);
	  if (e) return "$event.keyCode!==".concat(e);
	  var n = xi[t],
	      o = ki[t];
	  return "_k($event.keyCode," + "".concat(JSON.stringify(t), ",") + "".concat(JSON.stringify(n), ",") + "$event.key," + "".concat(JSON.stringify(o)) + ")";
	}

	var Ei = {
	  on: function on(t, e) {
	    t.wrapListeners = function (t) {
	      return "_g(".concat(t, ",").concat(e.value, ")");
	    };
	  },
	  bind: function bind(t, e) {
	    t.wrapData = function (n) {
	      return "_b(".concat(n, ",'").concat(t.tag, "',").concat(e.value, ",").concat(e.modifiers && e.modifiers.prop ? "true" : "false").concat(e.modifiers && e.modifiers.sync ? ",true" : "", ")");
	    };
	  },
	  cloak: S
	};

	var ji = function ji(t) {
	  babelHelpers.classCallCheck(this, ji);
	  this.options = t, this.warn = t.warn || vo, this.transforms = $o(t.modules, "transformCode"), this.dataGenFns = $o(t.modules, "genData"), this.directives = A(A({}, Ei), t.directives);
	  var e = t.isReservedTag || T;
	  this.maybeComponent = function (t) {
	    return !!t.component || !e(t.tag);
	  }, this.onceId = 0, this.staticRenderFns = [], this.pre = !1;
	};

	function Di(t, e) {
	  var n = new ji(e);
	  return {
	    render: "with(this){return ".concat(t ? "script" === t.tag ? "null" : Li(t, n) : '_c("div")', "}"),
	    staticRenderFns: n.staticRenderFns
	  };
	}

	function Li(t, e) {
	  if (t.parent && (t.pre = t.pre || t.parent.pre), t.staticRoot && !t.staticProcessed) return Ii(t, e);
	  if (t.once && !t.onceProcessed) return Mi(t, e);
	  if (t.for && !t.forProcessed) return Pi(t, e);
	  if (t.if && !t.ifProcessed) return Fi(t, e);

	  if ("template" !== t.tag || t.slotTarget || e.pre) {
	    if ("slot" === t.tag) return function (t, e) {
	      var n = t.slotName || '"default"',
	          o = Ui(t, e);
	      var r = "_t(".concat(n).concat(o ? ",function(){return ".concat(o, "}") : "");
	      var s = t.attrs || t.dynamicAttrs ? Ki((t.attrs || []).concat(t.dynamicAttrs || []).map(function (t) {
	        return {
	          name: _(t.name),
	          value: t.value,
	          dynamic: t.dynamic
	        };
	      })) : null,
	          i = t.attrsMap["v-bind"];
	      !s && !i || o || (r += ",null");
	      s && (r += ",".concat(s));
	      i && (r += "".concat(s ? "" : ",null", ",").concat(i));
	      return r + ")";
	    }(t, e);
	    {
	      var _n69;

	      if (t.component) _n69 = function (t, e, n) {
	        var o = e.inlineTemplate ? null : Ui(e, n, !0);
	        return "_c(".concat(t, ",").concat(Ri(e, n)).concat(o ? ",".concat(o) : "", ")");
	      }(t.component, t, e);else {
	        var _o60;

	        (!t.plain || t.pre && e.maybeComponent(t)) && (_o60 = Ri(t, e));

	        var _r37 = t.inlineTemplate ? null : Ui(t, e, !0);

	        _n69 = "_c('".concat(t.tag, "'").concat(_o60 ? ",".concat(_o60) : "").concat(_r37 ? ",".concat(_r37) : "", ")");
	      }

	      for (var _o61 = 0; _o61 < e.transforms.length; _o61++) {
	        _n69 = e.transforms[_o61](t, _n69);
	      }

	      return _n69;
	    }
	  }

	  return Ui(t, e) || "void 0";
	}

	function Ii(t, e) {
	  t.staticProcessed = !0;
	  var n = e.pre;
	  return t.pre && (e.pre = t.pre), e.staticRenderFns.push("with(this){return ".concat(Li(t, e), "}")), e.pre = n, "_m(".concat(e.staticRenderFns.length - 1).concat(t.staticInFor ? ",true" : "", ")");
	}

	function Mi(t, e) {
	  if (t.onceProcessed = !0, t.if && !t.ifProcessed) return Fi(t, e);

	  if (t.staticInFor) {
	    var _n70 = "",
	        _o62 = t.parent;

	    for (; _o62;) {
	      if (_o62.for) {
	        _n70 = _o62.key;
	        break;
	      }

	      _o62 = _o62.parent;
	    }

	    return _n70 ? "_o(".concat(Li(t, e), ",").concat(e.onceId++, ",").concat(_n70, ")") : Li(t, e);
	  }

	  return Ii(t, e);
	}

	function Fi(t, e, n, o) {
	  return t.ifProcessed = !0, function t(e, n, o, r) {
	    if (!e.length) return r || "_e()";
	    var s = e.shift();
	    return s.exp ? "(".concat(s.exp, ")?").concat(i(s.block), ":").concat(t(e, n, o, r)) : "".concat(i(s.block));

	    function i(t) {
	      return o ? o(t, n) : t.once ? Mi(t, n) : Li(t, n);
	    }
	  }(t.ifConditions.slice(), e, n, o);
	}

	function Pi(t, e, n, o) {
	  var r = t.for,
	      s = t.alias,
	      i = t.iterator1 ? ",".concat(t.iterator1) : "",
	      a = t.iterator2 ? ",".concat(t.iterator2) : "";
	  return t.forProcessed = !0, "".concat(o || "_l", "((").concat(r, "),") + "function(".concat(s).concat(i).concat(a, "){") + "return ".concat((n || Li)(t, e)) + "})";
	}

	function Ri(t, e) {
	  var n = "{";

	  var o = function (t, e) {
	    var n = t.directives;
	    if (!n) return;
	    var o,
	        r,
	        s,
	        i,
	        a = "directives:[",
	        c = !1;

	    for (o = 0, r = n.length; o < r; o++) {
	      s = n[o], i = !0;
	      var _r38 = e.directives[s.name];
	      _r38 && (i = !!_r38(t, s, e.warn)), i && (c = !0, a += "{name:\"".concat(s.name, "\",rawName:\"").concat(s.rawName, "\"").concat(s.value ? ",value:(".concat(s.value, "),expression:").concat(JSON.stringify(s.value)) : "").concat(s.arg ? ",arg:".concat(s.isDynamicArg ? s.arg : "\"".concat(s.arg, "\"")) : "").concat(s.modifiers ? ",modifiers:".concat(JSON.stringify(s.modifiers)) : "", "},"));
	    }

	    if (c) return a.slice(0, -1) + "]";
	  }(t, e);

	  o && (n += o + ","), t.key && (n += "key:".concat(t.key, ",")), t.ref && (n += "ref:".concat(t.ref, ",")), t.refInFor && (n += "refInFor:true,"), t.pre && (n += "pre:true,"), t.component && (n += "tag:\"".concat(t.tag, "\","));

	  for (var _o63 = 0; _o63 < e.dataGenFns.length; _o63++) {
	    n += e.dataGenFns[_o63](t);
	  }

	  if (t.attrs && (n += "attrs:".concat(Ki(t.attrs), ",")), t.props && (n += "domProps:".concat(Ki(t.props), ",")), t.events && (n += "".concat(Si(t.events, !1), ",")), t.nativeEvents && (n += "".concat(Si(t.nativeEvents, !0), ",")), t.slotTarget && !t.slotScope && (n += "slot:".concat(t.slotTarget, ",")), t.scopedSlots && (n += "".concat(function (t, e, n) {
	    var o = t.for || Object.keys(e).some(function (t) {
	      var n = e[t];
	      return n.slotTargetDynamic || n.if || n.for || Hi(n);
	    }),
	        r = !!t.if;

	    if (!o) {
	      var _e56 = t.parent;

	      for (; _e56;) {
	        if (_e56.slotScope && _e56.slotScope !== Zs || _e56.for) {
	          o = !0;
	          break;
	        }

	        _e56.if && (r = !0), _e56 = _e56.parent;
	      }
	    }

	    var s = Object.keys(e).map(function (t) {
	      return Bi(e[t], n);
	    }).join(",");
	    return "scopedSlots:_u([".concat(s, "]").concat(o ? ",null,true" : "").concat(!o && r ? ",null,false,".concat(function (t) {
	      var e = 5381,
	          n = t.length;

	      for (; n;) {
	        e = 33 * e ^ t.charCodeAt(--n);
	      }

	      return e >>> 0;
	    }(s)) : "", ")");
	  }(t, t.scopedSlots, e), ",")), t.model && (n += "model:{value:".concat(t.model.value, ",callback:").concat(t.model.callback, ",expression:").concat(t.model.expression, "},")), t.inlineTemplate) {
	    var _o64 = function (t, e) {
	      var n = t.children[0];

	      if (n && 1 === n.type) {
	        var _t54 = Di(n, e.options);

	        return "inlineTemplate:{render:function(){".concat(_t54.render, "},staticRenderFns:[").concat(_t54.staticRenderFns.map(function (t) {
	          return "function(){".concat(t, "}");
	        }).join(","), "]}");
	      }
	    }(t, e);

	    _o64 && (n += "".concat(_o64, ","));
	  }

	  return n = n.replace(/,$/, "") + "}", t.dynamicAttrs && (n = "_b(".concat(n, ",\"").concat(t.tag, "\",").concat(Ki(t.dynamicAttrs), ")")), t.wrapData && (n = t.wrapData(n)), t.wrapListeners && (n = t.wrapListeners(n)), n;
	}

	function Hi(t) {
	  return 1 === t.type && ("slot" === t.tag || t.children.some(Hi));
	}

	function Bi(t, e) {
	  var n = t.attrsMap["slot-scope"];
	  if (t.if && !t.ifProcessed && !n) return Fi(t, e, Bi, "null");
	  if (t.for && !t.forProcessed) return Pi(t, e, Bi);
	  var o = t.slotScope === Zs ? "" : String(t.slotScope),
	      r = "function(".concat(o, "){") + "return ".concat("template" === t.tag ? t.if && n ? "(".concat(t.if, ")?").concat(Ui(t, e) || "undefined", ":undefined") : Ui(t, e) || "undefined" : Li(t, e), "}"),
	      s = o ? "" : ",proxy:true";
	  return "{key:".concat(t.slotTarget || '"default"', ",fn:").concat(r).concat(s, "}");
	}

	function Ui(t, e, n, o, r) {
	  var s = t.children;

	  if (s.length) {
	    var _t55 = s[0];

	    if (1 === s.length && _t55.for && "template" !== _t55.tag && "slot" !== _t55.tag) {
	      var _r39 = n ? e.maybeComponent(_t55) ? ",1" : ",0" : "";

	      return "".concat((o || Li)(_t55, e)).concat(_r39);
	    }

	    var _i14 = n ? function (t, e) {
	      var n = 0;

	      for (var _o65 = 0; _o65 < t.length; _o65++) {
	        var _r40 = t[_o65];

	        if (1 === _r40.type) {
	          if (Vi(_r40) || _r40.ifConditions && _r40.ifConditions.some(function (t) {
	            return Vi(t.block);
	          })) {
	            n = 2;
	            break;
	          }

	          (e(_r40) || _r40.ifConditions && _r40.ifConditions.some(function (t) {
	            return e(t.block);
	          })) && (n = 1);
	        }
	      }

	      return n;
	    }(s, e.maybeComponent) : 0,
	        _a6 = r || zi;

	    return "[".concat(s.map(function (t) {
	      return _a6(t, e);
	    }).join(","), "]").concat(_i14 ? ",".concat(_i14) : "");
	  }
	}

	function Vi(t) {
	  return void 0 !== t.for || "template" === t.tag || "slot" === t.tag;
	}

	function zi(t, e) {
	  return 1 === t.type ? Li(t, e) : 3 === t.type && t.isComment ? (o = t, "_e(".concat(JSON.stringify(o.text), ")")) : "_v(".concat(2 === (n = t).type ? n.expression : Ji(JSON.stringify(n.text)), ")");
	  var n, o;
	}

	function Ki(t) {
	  var e = "",
	      n = "";

	  for (var _o66 = 0; _o66 < t.length; _o66++) {
	    var _r41 = t[_o66],
	        _s21 = Ji(_r41.value);

	    _r41.dynamic ? n += "".concat(_r41.name, ",").concat(_s21, ",") : e += "\"".concat(_r41.name, "\":").concat(_s21, ",");
	  }

	  return e = "{".concat(e.slice(0, -1), "}"), n ? "_d(".concat(e, ",[").concat(n.slice(0, -1), "])") : e;
	}

	function Ji(t) {
	  return t.replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
	}

	function qi(t, e) {
	  try {
	    return new Function(t);
	  } catch (n) {
	    return e.push({
	      err: n,
	      code: t
	    }), S;
	  }
	}

	function Wi(t) {
	  var e = Object.create(null);
	  return function (n, o, r) {
	    (o = A({}, o)).warn;
	    delete o.warn;
	    var s = o.delimiters ? String(o.delimiters) + n : n;
	    if (e[s]) return e[s];
	    var i = t(n, o),
	        a = {},
	        c = [];
	    return a.render = qi(i.render, c), a.staticRenderFns = i.staticRenderFns.map(function (t) {
	      return qi(t, c);
	    }), e[s] = a;
	  };
	}

	var Zi = (Gi = function Gi(t, e) {
	  var n = si(t.trim(), e);
	  !1 !== e.optimize && _i(n, e);
	  var o = Di(n, e);
	  return {
	    ast: n,
	    render: o.render,
	    staticRenderFns: o.staticRenderFns
	  };
	}, function (t) {
	  function e(e, n) {
	    var o = Object.create(t),
	        r = [],
	        s = [];

	    if (n) {
	      n.modules && (o.modules = (t.modules || []).concat(n.modules)), n.directives && (o.directives = A(Object.create(t.directives || null), n.directives));

	      for (var _t56 in n) {
	        "modules" !== _t56 && "directives" !== _t56 && (o[_t56] = n[_t56]);
	      }
	    }

	    o.warn = function (t, e, n) {
	      (n ? s : r).push(t);
	    };

	    var i = Gi(e.trim(), o);
	    return i.errors = r, i.tips = s, i;
	  }

	  return {
	    compile: e,
	    compileToFunctions: Wi(e)
	  };
	});
	var Gi;

	var _Zi = Zi(yi),
	    Xi = _Zi.compile,
	    Yi = _Zi.compileToFunctions;

	var Qi;

	function ta(t) {
	  return (Qi = Qi || document.createElement("div")).innerHTML = t ? '<a href="\n"/>' : '<div a="\n"/>', Qi.innerHTML.indexOf("&#10;") > 0;
	}

	var ea = !!V && ta(!1),
	    na = !!V && ta(!0),
	    oa = v(function (t) {
	  var e = qn(t);
	  return e && e.innerHTML;
	}),
	    ra = gn.prototype.$mount;
	gn.prototype.$mount = function (t, e) {
	  if ((t = t && qn(t)) === document.body || t === document.documentElement) return this;
	  var n = this.$options;

	  if (!n.render) {
	    var _e57 = n.template;
	    if (_e57) {
	      if ("string" == typeof _e57) "#" === _e57.charAt(0) && (_e57 = oa(_e57));else {
	        if (!_e57.nodeType) return this;
	        _e57 = _e57.innerHTML;
	      }
	    } else t && (_e57 = function (t) {
	      if (t.outerHTML) return t.outerHTML;
	      {
	        var _e58 = document.createElement("div");

	        return _e58.appendChild(t.cloneNode(!0)), _e58.innerHTML;
	      }
	    }(t));

	    if (_e57) {
	      var _Yi = Yi(_e57, {
	        outputSourceRange: !1,
	        shouldDecodeNewlines: ea,
	        shouldDecodeNewlinesForHref: na,
	        delimiters: n.delimiters,
	        comments: n.comments
	      }, this),
	          _t57 = _Yi.render,
	          _o67 = _Yi.staticRenderFns;

	      n.render = _t57, n.staticRenderFns = _o67;
	    }
	  }

	  return ra.call(this, t, e);
	}, gn.compile = Yi;
	var BitrixVueInstance = new BitrixVue(gn);

	exports.WidgetBitrixVue = BitrixVueInstance;
	exports.WidgetVue = BitrixVueInstance;
	exports.WidgetVueVendor = gn;
	exports.WidgetVueVendorV2 = gn;

}((this.BX = this.BX || {}),BX.Event,BX,BX,BX));



})();




// file: /bitrix/js/pull/protobuf/protobuf.js
/*!
 * protobuf.js v6.8.6 (c) 2016, daniel wirtz
 * compiled mon, 26 feb 2018 11:35:34 utc
 * licensed under the bsd-3-clause license
 * see: https://github.com/dcodeio/protobuf.js for details
 *
 * Modify list for integration with Bitrix Framework:
 * - removed integration with RequireJS and AMD package builders;
 */
(function(global,undefined){"use strict";(function prelude(modules, cache, entries) {

    // This is the prelude used to bundle protobuf.js for the browser. Wraps up the CommonJS
    // sources through a conflict-free require shim and is again wrapped within an iife that
    // provides a unified `global` and a minification-friendly `undefined` var plus a global
    // "use strict" directive so that minification can remove the directives of each module.

    function $require(name) {
        var $module = cache[name];
        if (!$module)
            modules[name][0].call($module = cache[name] = { exports: {} }, $require, $module, $module.exports);
        return $module.exports;
    }

    // Expose globally
    var protobuf = global.protobuf = $require(entries[0]);

    // Be nice to AMD
    /*if (typeof define === "function" && define.amd)
        define(["long"], function(Long) {
            if (Long && Long.isLong) {
                protobuf.util.Long = Long;
                protobuf.configure();
            }
            return protobuf;
        });*/

    // Be nice to CommonJS
    /*if (typeof module === "object" && module && module.exports)
        module.exports = protobuf;*/

})/* end of prelude */({1:[function(require,module,exports){
"use strict";
module.exports = asPromise;

/**
 * Callback as used by {@link util.asPromise}.
 * @typedef asPromiseCallback
 * @type {function}
 * @param {Error|null} error Error, if any
 * @param {...*} params Additional arguments
 * @returns {undefined}
 */

/**
 * Returns a promise from a node-style callback function.
 * @memberof util
 * @param {asPromiseCallback} fn Function to call
 * @param {*} ctx Function context
 * @param {...*} params Function arguments
 * @returns {Promise<*>} Promisified function
 */
function asPromise(fn, ctx/*, varargs */) {
    var params  = new Array(arguments.length - 1),
        offset  = 0,
        index   = 2,
        pending = true;
    while (index < arguments.length)
        params[offset++] = arguments[index++];
    return new Promise(function executor(resolve, reject) {
        params[offset] = function callback(err/*, varargs */) {
            if (pending) {
                pending = false;
                if (err)
                    reject(err);
                else {
                    var params = new Array(arguments.length - 1),
                        offset = 0;
                    while (offset < params.length)
                        params[offset++] = arguments[offset];
                    resolve.apply(null, params);
                }
            }
        };
        try {
            fn.apply(ctx || null, params);
        } catch (err) {
            if (pending) {
                pending = false;
                reject(err);
            }
        }
    });
}

},{}],2:[function(require,module,exports){
"use strict";

/**
 * A minimal base64 implementation for number arrays.
 * @memberof util
 * @namespace
 */
var base64 = exports;

/**
 * Calculates the byte length of a base64 encoded string.
 * @param {string} string Base64 encoded string
 * @returns {number} Byte length
 */
base64.length = function length(string) {
    var p = string.length;
    if (!p)
        return 0;
    var n = 0;
    while (--p % 4 > 1 && string.charAt(p) === "=")
        ++n;
    return Math.ceil(string.length * 3) / 4 - n;
};

// Base64 encoding table
var b64 = new Array(64);

// Base64 decoding table
var s64 = new Array(123);

// 65..90, 97..122, 48..57, 43, 47
for (var i = 0; i < 64;)
    s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;

/**
 * Encodes a buffer to a base64 encoded string.
 * @param {Uint8Array} buffer Source buffer
 * @param {number} start Source start
 * @param {number} end Source end
 * @returns {string} Base64 encoded string
 */
base64.encode = function encode(buffer, start, end) {
    var parts = null,
        chunk = [];
    var i = 0, // output index
        j = 0, // goto index
        t;     // temporary
    while (start < end) {
        var b = buffer[start++];
        switch (j) {
            case 0:
                chunk[i++] = b64[b >> 2];
                t = (b & 3) << 4;
                j = 1;
                break;
            case 1:
                chunk[i++] = b64[t | b >> 4];
                t = (b & 15) << 2;
                j = 2;
                break;
            case 2:
                chunk[i++] = b64[t | b >> 6];
                chunk[i++] = b64[b & 63];
                j = 0;
                break;
        }
        if (i > 8191) {
            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
            i = 0;
        }
    }
    if (j) {
        chunk[i++] = b64[t];
        chunk[i++] = 61;
        if (j === 1)
            chunk[i++] = 61;
    }
    if (parts) {
        if (i)
            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
    }
    return String.fromCharCode.apply(String, chunk.slice(0, i));
};

var invalidEncoding = "invalid encoding";

/**
 * Decodes a base64 encoded string to a buffer.
 * @param {string} string Source string
 * @param {Uint8Array} buffer Destination buffer
 * @param {number} offset Destination offset
 * @returns {number} Number of bytes written
 * @throws {Error} If encoding is invalid
 */
base64.decode = function decode(string, buffer, offset) {
    var start = offset;
    var j = 0, // goto index
        t;     // temporary
    for (var i = 0; i < string.length;) {
        var c = string.charCodeAt(i++);
        if (c === 61 && j > 1)
            break;
        if ((c = s64[c]) === undefined)
            throw Error(invalidEncoding);
        switch (j) {
            case 0:
                t = c;
                j = 1;
                break;
            case 1:
                buffer[offset++] = t << 2 | (c & 48) >> 4;
                t = c;
                j = 2;
                break;
            case 2:
                buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;
                t = c;
                j = 3;
                break;
            case 3:
                buffer[offset++] = (t & 3) << 6 | c;
                j = 0;
                break;
        }
    }
    if (j === 1)
        throw Error(invalidEncoding);
    return offset - start;
};

/**
 * Tests if the specified string appears to be base64 encoded.
 * @param {string} string String to test
 * @returns {boolean} `true` if probably base64 encoded, otherwise false
 */
base64.test = function test(string) {
    return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);
};

},{}],3:[function(require,module,exports){
"use strict";
module.exports = codegen;

/**
 * Begins generating a function.
 * @memberof util
 * @param {string[]} functionParams Function parameter names
 * @param {string} [functionName] Function name if not anonymous
 * @returns {Codegen} Appender that appends code to the function's body
 */
function codegen(functionParams, functionName) {

    /* istanbul ignore if */
    if (typeof functionParams === "string") {
        functionName = functionParams;
        functionParams = undefined;
    }

    var body = [];

    /**
     * Appends code to the function's body or finishes generation.
     * @typedef Codegen
     * @type {function}
     * @param {string|Object.<string,*>} [formatStringOrScope] Format string or, to finish the function, an object of additional scope variables, if any
     * @param {...*} [formatParams] Format parameters
     * @returns {Codegen|Function} Itself or the generated function if finished
     * @throws {Error} If format parameter counts do not match
     */

    function Codegen(formatStringOrScope) {
        // note that explicit array handling below makes this ~50% faster

        // finish the function
        if (typeof formatStringOrScope !== "string") {
            var source = toString();
            if (codegen.verbose)
                console.log("codegen: " + source); // eslint-disable-line no-console
            source = "return " + source;
            if (formatStringOrScope) {
                var scopeKeys   = Object.keys(formatStringOrScope),
                    scopeParams = new Array(scopeKeys.length + 1),
                    scopeValues = new Array(scopeKeys.length),
                    scopeOffset = 0;
                while (scopeOffset < scopeKeys.length) {
                    scopeParams[scopeOffset] = scopeKeys[scopeOffset];
                    scopeValues[scopeOffset] = formatStringOrScope[scopeKeys[scopeOffset++]];
                }
                scopeParams[scopeOffset] = source;
                return Function.apply(null, scopeParams).apply(null, scopeValues); // eslint-disable-line no-new-func
            }
            return Function(source)(); // eslint-disable-line no-new-func
        }

        // otherwise append to body
        var formatParams = new Array(arguments.length - 1),
            formatOffset = 0;
        while (formatOffset < formatParams.length)
            formatParams[formatOffset] = arguments[++formatOffset];
        formatOffset = 0;
        formatStringOrScope = formatStringOrScope.replace(/%([%dfijs])/g, function replace($0, $1) {
            var value = formatParams[formatOffset++];
            switch ($1) {
                case "d": case "f": return String(Number(value));
                case "i": return String(Math.floor(value));
                case "j": return JSON.stringify(value);
                case "s": return String(value);
            }
            return "%";
        });
        if (formatOffset !== formatParams.length)
            throw Error("parameter count mismatch");
        body.push(formatStringOrScope);
        return Codegen;
    }

    function toString(functionNameOverride) {
        return "function " + (functionNameOverride || functionName || "") + "(" + (functionParams && functionParams.join(",") || "") + "){\n  " + body.join("\n  ") + "\n}";
    }

    Codegen.toString = toString;
    return Codegen;
}

/**
 * Begins generating a function.
 * @memberof util
 * @function codegen
 * @param {string} [functionName] Function name if not anonymous
 * @returns {Codegen} Appender that appends code to the function's body
 * @variation 2
 */

/**
 * When set to `true`, codegen will log generated code to console. Useful for debugging.
 * @name util.codegen.verbose
 * @type {boolean}
 */
codegen.verbose = false;

},{}],4:[function(require,module,exports){
"use strict";
module.exports = EventEmitter;

/**
 * Constructs a new event emitter instance.
 * @classdesc A minimal event emitter.
 * @memberof util
 * @constructor
 */
function EventEmitter() {

    /**
     * Registered listeners.
     * @type {Object.<string,*>}
     * @private
     */
    this._listeners = {};
}

/**
 * Registers an event listener.
 * @param {string} evt Event name
 * @param {function} fn Listener
 * @param {*} [ctx] Listener context
 * @returns {util.EventEmitter} `this`
 */
EventEmitter.prototype.on = function on(evt, fn, ctx) {
    (this._listeners[evt] || (this._listeners[evt] = [])).push({
        fn  : fn,
        ctx : ctx || this
    });
    return this;
};

/**
 * Removes an event listener or any matching listeners if arguments are omitted.
 * @param {string} [evt] Event name. Removes all listeners if omitted.
 * @param {function} [fn] Listener to remove. Removes all listeners of `evt` if omitted.
 * @returns {util.EventEmitter} `this`
 */
EventEmitter.prototype.off = function off(evt, fn) {
    if (evt === undefined)
        this._listeners = {};
    else {
        if (fn === undefined)
            this._listeners[evt] = [];
        else {
            var listeners = this._listeners[evt];
            for (var i = 0; i < listeners.length;)
                if (listeners[i].fn === fn)
                    listeners.splice(i, 1);
                else
                    ++i;
        }
    }
    return this;
};

/**
 * Emits an event by calling its listeners with the specified arguments.
 * @param {string} evt Event name
 * @param {...*} args Arguments
 * @returns {util.EventEmitter} `this`
 */
EventEmitter.prototype.emit = function emit(evt) {
    var listeners = this._listeners[evt];
    if (listeners) {
        var args = [],
            i = 1;
        for (; i < arguments.length;)
            args.push(arguments[i++]);
        for (i = 0; i < listeners.length;)
            listeners[i].fn.apply(listeners[i++].ctx, args);
    }
    return this;
};

},{}],5:[function(require,module,exports){
"use strict";
module.exports = fetch;

var asPromise = require(1),
    inquire   = require(7);

var fs = inquire("fs");

/**
 * Node-style callback as used by {@link util.fetch}.
 * @typedef FetchCallback
 * @type {function}
 * @param {?Error} error Error, if any, otherwise `null`
 * @param {string} [contents] File contents, if there hasn't been an error
 * @returns {undefined}
 */

/**
 * Options as used by {@link util.fetch}.
 * @typedef FetchOptions
 * @type {Object}
 * @property {boolean} [binary=false] Whether expecting a binary response
 * @property {boolean} [xhr=false] If `true`, forces the use of XMLHttpRequest
 */

/**
 * Fetches the contents of a file.
 * @memberof util
 * @param {string} filename File path or url
 * @param {FetchOptions} options Fetch options
 * @param {FetchCallback} callback Callback function
 * @returns {undefined}
 */
function fetch(filename, options, callback) {
    if (typeof options === "function") {
        callback = options;
        options = {};
    } else if (!options)
        options = {};

    if (!callback)
        return asPromise(fetch, this, filename, options); // eslint-disable-line no-invalid-this

    // if a node-like filesystem is present, try it first but fall back to XHR if nothing is found.
    if (!options.xhr && fs && fs.readFile)
        return fs.readFile(filename, function fetchReadFileCallback(err, contents) {
            return err && typeof XMLHttpRequest !== "undefined"
                ? fetch.xhr(filename, options, callback)
                : err
                ? callback(err)
                : callback(null, options.binary ? contents : contents.toString("utf8"));
        });

    // use the XHR version otherwise.
    return fetch.xhr(filename, options, callback);
}

/**
 * Fetches the contents of a file.
 * @name util.fetch
 * @function
 * @param {string} path File path or url
 * @param {FetchCallback} callback Callback function
 * @returns {undefined}
 * @variation 2
 */

/**
 * Fetches the contents of a file.
 * @name util.fetch
 * @function
 * @param {string} path File path or url
 * @param {FetchOptions} [options] Fetch options
 * @returns {Promise<string|Uint8Array>} Promise
 * @variation 3
 */

/**/
fetch.xhr = function fetch_xhr(filename, options, callback) {
    var xhr = new XMLHttpRequest();
    xhr.onreadystatechange /* works everywhere */ = function fetchOnReadyStateChange() {

        if (xhr.readyState !== 4)
            return undefined;

        // local cors security errors return status 0 / empty string, too. afaik this cannot be
        // reliably distinguished from an actually empty file for security reasons. feel free
        // to send a pull request if you are aware of a solution.
        if (xhr.status !== 0 && xhr.status !== 200)
            return callback(Error("status " + xhr.status));

        // if binary data is expected, make sure that some sort of array is returned, even if
        // ArrayBuffers are not supported. the binary string fallback, however, is unsafe.
        if (options.binary) {
            var buffer = xhr.response;
            if (!buffer) {
                buffer = [];
                for (var i = 0; i < xhr.responseText.length; ++i)
                    buffer.push(xhr.responseText.charCodeAt(i) & 255);
            }
            return callback(null, typeof Uint8Array !== "undefined" ? new Uint8Array(buffer) : buffer);
        }
        return callback(null, xhr.responseText);
    };

    if (options.binary) {
        // ref: https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/Sending_and_Receiving_Binary_Data#Receiving_binary_data_in_older_browsers
        if ("overrideMimeType" in xhr)
            xhr.overrideMimeType("text/plain; charset=x-user-defined");
        xhr.responseType = "arraybuffer";
    }

    xhr.open("GET", filename);
    xhr.send();
};

},{"1":1,"7":7}],6:[function(require,module,exports){
"use strict";

module.exports = factory(factory);

/**
 * Reads / writes floats / doubles from / to buffers.
 * @name util.float
 * @namespace
 */

/**
 * Writes a 32 bit float to a buffer using little endian byte order.
 * @name util.float.writeFloatLE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Writes a 32 bit float to a buffer using big endian byte order.
 * @name util.float.writeFloatBE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Reads a 32 bit float from a buffer using little endian byte order.
 * @name util.float.readFloatLE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

/**
 * Reads a 32 bit float from a buffer using big endian byte order.
 * @name util.float.readFloatBE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

/**
 * Writes a 64 bit double to a buffer using little endian byte order.
 * @name util.float.writeDoubleLE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Writes a 64 bit double to a buffer using big endian byte order.
 * @name util.float.writeDoubleBE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Reads a 64 bit double from a buffer using little endian byte order.
 * @name util.float.readDoubleLE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

/**
 * Reads a 64 bit double from a buffer using big endian byte order.
 * @name util.float.readDoubleBE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

// Factory function for the purpose of node-based testing in modified global environments
function factory(exports) {

    // float: typed array
    if (typeof Float32Array !== "undefined") (function() {

        var f32 = new Float32Array([ -0 ]),
            f8b = new Uint8Array(f32.buffer),
            le  = f8b[3] === 128;

        function writeFloat_f32_cpy(val, buf, pos) {
            f32[0] = val;
            buf[pos    ] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
        }

        function writeFloat_f32_rev(val, buf, pos) {
            f32[0] = val;
            buf[pos    ] = f8b[3];
            buf[pos + 1] = f8b[2];
            buf[pos + 2] = f8b[1];
            buf[pos + 3] = f8b[0];
        }

        /* istanbul ignore next */
        exports.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;
        /* istanbul ignore next */
        exports.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;

        function readFloat_f32_cpy(buf, pos) {
            f8b[0] = buf[pos    ];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            return f32[0];
        }

        function readFloat_f32_rev(buf, pos) {
            f8b[3] = buf[pos    ];
            f8b[2] = buf[pos + 1];
            f8b[1] = buf[pos + 2];
            f8b[0] = buf[pos + 3];
            return f32[0];
        }

        /* istanbul ignore next */
        exports.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;
        /* istanbul ignore next */
        exports.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;

    // float: ieee754
    })(); else (function() {

        function writeFloat_ieee754(writeUint, val, buf, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign)
                val = -val;
            if (val === 0)
                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos);
            else if (isNaN(val))
                writeUint(2143289344, buf, pos);
            else if (val > 3.4028234663852886e+38) // +-Infinity
                writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);
            else if (val < 1.1754943508222875e-38) // denormal
                writeUint((sign << 31 | Math.round(val / 1.401298464324817e-45)) >>> 0, buf, pos);
            else {
                var exponent = Math.floor(Math.log(val) / Math.LN2),
                    mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
                writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);
            }
        }

        exports.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
        exports.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);

        function readFloat_ieee754(readUint, buf, pos) {
            var uint = readUint(buf, pos),
                sign = (uint >> 31) * 2 + 1,
                exponent = uint >>> 23 & 255,
                mantissa = uint & 8388607;
            return exponent === 255
                ? mantissa
                ? NaN
                : sign * Infinity
                : exponent === 0 // denormal
                ? sign * 1.401298464324817e-45 * mantissa
                : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);
        }

        exports.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
        exports.readFloatBE = readFloat_ieee754.bind(null, readUintBE);

    })();

    // double: typed array
    if (typeof Float64Array !== "undefined") (function() {

        var f64 = new Float64Array([-0]),
            f8b = new Uint8Array(f64.buffer),
            le  = f8b[7] === 128;

        function writeDouble_f64_cpy(val, buf, pos) {
            f64[0] = val;
            buf[pos    ] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
            buf[pos + 4] = f8b[4];
            buf[pos + 5] = f8b[5];
            buf[pos + 6] = f8b[6];
            buf[pos + 7] = f8b[7];
        }

        function writeDouble_f64_rev(val, buf, pos) {
            f64[0] = val;
            buf[pos    ] = f8b[7];
            buf[pos + 1] = f8b[6];
            buf[pos + 2] = f8b[5];
            buf[pos + 3] = f8b[4];
            buf[pos + 4] = f8b[3];
            buf[pos + 5] = f8b[2];
            buf[pos + 6] = f8b[1];
            buf[pos + 7] = f8b[0];
        }

        /* istanbul ignore next */
        exports.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;
        /* istanbul ignore next */
        exports.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;

        function readDouble_f64_cpy(buf, pos) {
            f8b[0] = buf[pos    ];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            f8b[4] = buf[pos + 4];
            f8b[5] = buf[pos + 5];
            f8b[6] = buf[pos + 6];
            f8b[7] = buf[pos + 7];
            return f64[0];
        }

        function readDouble_f64_rev(buf, pos) {
            f8b[7] = buf[pos    ];
            f8b[6] = buf[pos + 1];
            f8b[5] = buf[pos + 2];
            f8b[4] = buf[pos + 3];
            f8b[3] = buf[pos + 4];
            f8b[2] = buf[pos + 5];
            f8b[1] = buf[pos + 6];
            f8b[0] = buf[pos + 7];
            return f64[0];
        }

        /* istanbul ignore next */
        exports.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;
        /* istanbul ignore next */
        exports.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;

    // double: ieee754
    })(); else (function() {

        function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign)
                val = -val;
            if (val === 0) {
                writeUint(0, buf, pos + off0);
                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos + off1);
            } else if (isNaN(val)) {
                writeUint(0, buf, pos + off0);
                writeUint(2146959360, buf, pos + off1);
            } else if (val > 1.7976931348623157e+308) { // +-Infinity
                writeUint(0, buf, pos + off0);
                writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);
            } else {
                var mantissa;
                if (val < 2.2250738585072014e-308) { // denormal
                    mantissa = val / 5e-324;
                    writeUint(mantissa >>> 0, buf, pos + off0);
                    writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);
                } else {
                    var exponent = Math.floor(Math.log(val) / Math.LN2);
                    if (exponent === 1024)
                        exponent = 1023;
                    mantissa = val * Math.pow(2, -exponent);
                    writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);
                    writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);
                }
            }
        }

        exports.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
        exports.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);

        function readDouble_ieee754(readUint, off0, off1, buf, pos) {
            var lo = readUint(buf, pos + off0),
                hi = readUint(buf, pos + off1);
            var sign = (hi >> 31) * 2 + 1,
                exponent = hi >>> 20 & 2047,
                mantissa = 4294967296 * (hi & 1048575) + lo;
            return exponent === 2047
                ? mantissa
                ? NaN
                : sign * Infinity
                : exponent === 0 // denormal
                ? sign * 5e-324 * mantissa
                : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
        }

        exports.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
        exports.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);

    })();

    return exports;
}

// uint helpers

function writeUintLE(val, buf, pos) {
    buf[pos    ] =  val        & 255;
    buf[pos + 1] =  val >>> 8  & 255;
    buf[pos + 2] =  val >>> 16 & 255;
    buf[pos + 3] =  val >>> 24;
}

function writeUintBE(val, buf, pos) {
    buf[pos    ] =  val >>> 24;
    buf[pos + 1] =  val >>> 16 & 255;
    buf[pos + 2] =  val >>> 8  & 255;
    buf[pos + 3] =  val        & 255;
}

function readUintLE(buf, pos) {
    return (buf[pos    ]
          | buf[pos + 1] << 8
          | buf[pos + 2] << 16
          | buf[pos + 3] << 24) >>> 0;
}

function readUintBE(buf, pos) {
    return (buf[pos    ] << 24
          | buf[pos + 1] << 16
          | buf[pos + 2] << 8
          | buf[pos + 3]) >>> 0;
}

},{}],7:[function(require,module,exports){
"use strict";
module.exports = inquire;

/**
 * Requires a module only if available.
 * @memberof util
 * @param {string} moduleName Module to require
 * @returns {?Object} Required module if available and not empty, otherwise `null`
 */
function inquire(moduleName) {
    try {
        var mod = eval("quire".replace(/^/,"re"))(moduleName); // eslint-disable-line no-eval
        if (mod && (mod.length || Object.keys(mod).length))
            return mod;
    } catch (e) {} // eslint-disable-line no-empty
    return null;
}

},{}],8:[function(require,module,exports){
"use strict";

/**
 * A minimal path module to resolve Unix, Windows and URL paths alike.
 * @memberof util
 * @namespace
 */
var path = exports;

var isAbsolute =
/**
 * Tests if the specified path is absolute.
 * @param {string} path Path to test
 * @returns {boolean} `true` if path is absolute
 */
path.isAbsolute = function isAbsolute(path) {
    return /^(?:\/|\w+:)/.test(path);
};

var normalize =
/**
 * Normalizes the specified path.
 * @param {string} path Path to normalize
 * @returns {string} Normalized path
 */
path.normalize = function normalize(path) {
    path = path.replace(/\\/g, "/")
               .replace(/\/{2,}/g, "/");
    var parts    = path.split("/"),
        absolute = isAbsolute(path),
        prefix   = "";
    if (absolute)
        prefix = parts.shift() + "/";
    for (var i = 0; i < parts.length;) {
        if (parts[i] === "..") {
            if (i > 0 && parts[i - 1] !== "..")
                parts.splice(--i, 2);
            else if (absolute)
                parts.splice(i, 1);
            else
                ++i;
        } else if (parts[i] === ".")
            parts.splice(i, 1);
        else
            ++i;
    }
    return prefix + parts.join("/");
};

/**
 * Resolves the specified include path against the specified origin path.
 * @param {string} originPath Path to the origin file
 * @param {string} includePath Include path relative to origin path
 * @param {boolean} [alreadyNormalized=false] `true` if both paths are already known to be normalized
 * @returns {string} Path to the include file
 */
path.resolve = function resolve(originPath, includePath, alreadyNormalized) {
    if (!alreadyNormalized)
        includePath = normalize(includePath);
    if (isAbsolute(includePath))
        return includePath;
    if (!alreadyNormalized)
        originPath = normalize(originPath);
    return (originPath = originPath.replace(/(?:\/|^)[^/]+$/, "")).length ? normalize(originPath + "/" + includePath) : includePath;
};

},{}],9:[function(require,module,exports){
"use strict";
module.exports = pool;

/**
 * An allocator as used by {@link util.pool}.
 * @typedef PoolAllocator
 * @type {function}
 * @param {number} size Buffer size
 * @returns {Uint8Array} Buffer
 */

/**
 * A slicer as used by {@link util.pool}.
 * @typedef PoolSlicer
 * @type {function}
 * @param {number} start Start offset
 * @param {number} end End offset
 * @returns {Uint8Array} Buffer slice
 * @this {Uint8Array}
 */

/**
 * A general purpose buffer pool.
 * @memberof util
 * @function
 * @param {PoolAllocator} alloc Allocator
 * @param {PoolSlicer} slice Slicer
 * @param {number} [size=8192] Slab size
 * @returns {PoolAllocator} Pooled allocator
 */
function pool(alloc, slice, size) {
    var SIZE   = size || 8192;
    var MAX    = SIZE >>> 1;
    var slab   = null;
    var offset = SIZE;
    return function pool_alloc(size) {
        if (size < 1 || size > MAX)
            return alloc(size);
        if (offset + size > SIZE) {
            slab = alloc(SIZE);
            offset = 0;
        }
        var buf = slice.call(slab, offset, offset += size);
        if (offset & 7) // align to 32 bit
            offset = (offset | 7) + 1;
        return buf;
    };
}

},{}],10:[function(require,module,exports){
"use strict";

/**
 * A minimal UTF8 implementation for number arrays.
 * @memberof util
 * @namespace
 */
var utf8 = exports;

/**
 * Calculates the UTF8 byte length of a string.
 * @param {string} string String
 * @returns {number} Byte length
 */
utf8.length = function utf8_length(string) {
    var len = 0,
        c = 0;
    for (var i = 0; i < string.length; ++i) {
        c = string.charCodeAt(i);
        if (c < 128)
            len += 1;
        else if (c < 2048)
            len += 2;
        else if ((c & 0xFC00) === 0xD800 && (string.charCodeAt(i + 1) & 0xFC00) === 0xDC00) {
            ++i;
            len += 4;
        } else
            len += 3;
    }
    return len;
};

/**
 * Reads UTF8 bytes as a string.
 * @param {Uint8Array} buffer Source buffer
 * @param {number} start Source start
 * @param {number} end Source end
 * @returns {string} String read
 */
utf8.read = function utf8_read(buffer, start, end) {
    var len = end - start;
    if (len < 1)
        return "";
    var parts = null,
        chunk = [],
        i = 0, // char offset
        t;     // temporary
    while (start < end) {
        t = buffer[start++];
        if (t < 128)
            chunk[i++] = t;
        else if (t > 191 && t < 224)
            chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;
        else if (t > 239 && t < 365) {
            t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 0x10000;
            chunk[i++] = 0xD800 + (t >> 10);
            chunk[i++] = 0xDC00 + (t & 1023);
        } else
            chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;
        if (i > 8191) {
            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
            i = 0;
        }
    }
    if (parts) {
        if (i)
            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
    }
    return String.fromCharCode.apply(String, chunk.slice(0, i));
};

/**
 * Writes a string as UTF8 bytes.
 * @param {string} string Source string
 * @param {Uint8Array} buffer Destination buffer
 * @param {number} offset Destination offset
 * @returns {number} Bytes written
 */
utf8.write = function utf8_write(string, buffer, offset) {
    var start = offset,
        c1, // character 1
        c2; // character 2
    for (var i = 0; i < string.length; ++i) {
        c1 = string.charCodeAt(i);
        if (c1 < 128) {
            buffer[offset++] = c1;
        } else if (c1 < 2048) {
            buffer[offset++] = c1 >> 6       | 192;
            buffer[offset++] = c1       & 63 | 128;
        } else if ((c1 & 0xFC00) === 0xD800 && ((c2 = string.charCodeAt(i + 1)) & 0xFC00) === 0xDC00) {
            c1 = 0x10000 + ((c1 & 0x03FF) << 10) + (c2 & 0x03FF);
            ++i;
            buffer[offset++] = c1 >> 18      | 240;
            buffer[offset++] = c1 >> 12 & 63 | 128;
            buffer[offset++] = c1 >> 6  & 63 | 128;
            buffer[offset++] = c1       & 63 | 128;
        } else {
            buffer[offset++] = c1 >> 12      | 224;
            buffer[offset++] = c1 >> 6  & 63 | 128;
            buffer[offset++] = c1       & 63 | 128;
        }
    }
    return offset - start;
};

},{}],11:[function(require,module,exports){
"use strict";
module.exports = common;

var commonRe = /\/|\./;

/**
 * Provides common type definitions.
 * Can also be used to provide additional google types or your own custom types.
 * @param {string} name Short name as in `google/protobuf/[name].proto` or full file name
 * @param {Object.<string,*>} json JSON definition within `google.protobuf` if a short name, otherwise the file's root definition
 * @returns {undefined}
 * @property {INamespace} google/protobuf/any.proto Any
 * @property {INamespace} google/protobuf/duration.proto Duration
 * @property {INamespace} google/protobuf/empty.proto Empty
 * @property {INamespace} google/protobuf/field_mask.proto FieldMask
 * @property {INamespace} google/protobuf/struct.proto Struct, Value, NullValue and ListValue
 * @property {INamespace} google/protobuf/timestamp.proto Timestamp
 * @property {INamespace} google/protobuf/wrappers.proto Wrappers
 * @example
 * // manually provides descriptor.proto (assumes google/protobuf/ namespace and .proto extension)
 * protobuf.common("descriptor", descriptorJson);
 *
 * // manually provides a custom definition (uses my.foo namespace)
 * protobuf.common("my/foo/bar.proto", myFooBarJson);
 */
function common(name, json) {
    if (!commonRe.test(name)) {
        name = "google/protobuf/" + name + ".proto";
        json = { nested: { google: { nested: { protobuf: { nested: json } } } } };
    }
    common[name] = json;
}

// Not provided because of limited use (feel free to discuss or to provide yourself):
//
// google/protobuf/descriptor.proto
// google/protobuf/source_context.proto
// google/protobuf/type.proto
//
// Stripped and pre-parsed versions of these non-bundled files are instead available as part of
// the repository or package within the google/protobuf directory.

common("any", {

    /**
     * Properties of a google.protobuf.Any message.
     * @interface IAny
     * @type {Object}
     * @property {string} [typeUrl]
     * @property {Uint8Array} [bytes]
     * @memberof common
     */
    Any: {
        fields: {
            type_url: {
                type: "string",
                id: 1
            },
            value: {
                type: "bytes",
                id: 2
            }
        }
    }
});

var timeType;

common("duration", {

    /**
     * Properties of a google.protobuf.Duration message.
     * @interface IDuration
     * @type {Object}
     * @property {number|Long} [seconds]
     * @property {number} [nanos]
     * @memberof common
     */
    Duration: timeType = {
        fields: {
            seconds: {
                type: "int64",
                id: 1
            },
            nanos: {
                type: "int32",
                id: 2
            }
        }
    }
});

common("timestamp", {

    /**
     * Properties of a google.protobuf.Timestamp message.
     * @interface ITimestamp
     * @type {Object}
     * @property {number|Long} [seconds]
     * @property {number} [nanos]
     * @memberof common
     */
    Timestamp: timeType
});

common("empty", {

    /**
     * Properties of a google.protobuf.Empty message.
     * @interface IEmpty
     * @memberof common
     */
    Empty: {
        fields: {}
    }
});

common("struct", {

    /**
     * Properties of a google.protobuf.Struct message.
     * @interface IStruct
     * @type {Object}
     * @property {Object.<string,IValue>} [fields]
     * @memberof common
     */
    Struct: {
        fields: {
            fields: {
                keyType: "string",
                type: "Value",
                id: 1
            }
        }
    },

    /**
     * Properties of a google.protobuf.Value message.
     * @interface IValue
     * @type {Object}
     * @property {string} [kind]
     * @property {0} [nullValue]
     * @property {number} [numberValue]
     * @property {string} [stringValue]
     * @property {boolean} [boolValue]
     * @property {IStruct} [structValue]
     * @property {IListValue} [listValue]
     * @memberof common
     */
    Value: {
        oneofs: {
            kind: {
                oneof: [
                    "nullValue",
                    "numberValue",
                    "stringValue",
                    "boolValue",
                    "structValue",
                    "listValue"
                ]
            }
        },
        fields: {
            nullValue: {
                type: "NullValue",
                id: 1
            },
            numberValue: {
                type: "double",
                id: 2
            },
            stringValue: {
                type: "string",
                id: 3
            },
            boolValue: {
                type: "bool",
                id: 4
            },
            structValue: {
                type: "Struct",
                id: 5
            },
            listValue: {
                type: "ListValue",
                id: 6
            }
        }
    },

    NullValue: {
        values: {
            NULL_VALUE: 0
        }
    },

    /**
     * Properties of a google.protobuf.ListValue message.
     * @interface IListValue
     * @type {Object}
     * @property {Array.<IValue>} [values]
     * @memberof common
     */
    ListValue: {
        fields: {
            values: {
                rule: "repeated",
                type: "Value",
                id: 1
            }
        }
    }
});

common("wrappers", {

    /**
     * Properties of a google.protobuf.DoubleValue message.
     * @interface IDoubleValue
     * @type {Object}
     * @property {number} [value]
     * @memberof common
     */
    DoubleValue: {
        fields: {
            value: {
                type: "double",
                id: 1
            }
        }
    },

    /**
     * Properties of a google.protobuf.FloatValue message.
     * @interface IFloatValue
     * @type {Object}
     * @property {number} [value]
     * @memberof common
     */
    FloatValue: {
        fields: {
            value: {
                type: "float",
                id: 1
            }
        }
    },

    /**
     * Properties of a google.protobuf.Int64Value message.
     * @interface IInt64Value
     * @type {Object}
     * @property {number|Long} [value]
     * @memberof common
     */
    Int64Value: {
        fields: {
            value: {
                type: "int64",
                id: 1
            }
        }
    },

    /**
     * Properties of a google.protobuf.UInt64Value message.
     * @interface IUInt64Value
     * @type {Object}
     * @property {number|Long} [value]
     * @memberof common
     */
    UInt64Value: {
        fields: {
            value: {
                type: "uint64",
                id: 1
            }
        }
    },

    /**
     * Properties of a google.protobuf.Int32Value message.
     * @interface IInt32Value
     * @type {Object}
     * @property {number} [value]
     * @memberof common
     */
    Int32Value: {
        fields: {
            value: {
                type: "int32",
                id: 1
            }
        }
    },

    /**
     * Properties of a google.protobuf.UInt32Value message.
     * @interface IUInt32Value
     * @type {Object}
     * @property {number} [value]
     * @memberof common
     */
    UInt32Value: {
        fields: {
            value: {
                type: "uint32",
                id: 1
            }
        }
    },

    /**
     * Properties of a google.protobuf.BoolValue message.
     * @interface IBoolValue
     * @type {Object}
     * @property {boolean} [value]
     * @memberof common
     */
    BoolValue: {
        fields: {
            value: {
                type: "bool",
                id: 1
            }
        }
    },

    /**
     * Properties of a google.protobuf.StringValue message.
     * @interface IStringValue
     * @type {Object}
     * @property {string} [value]
     * @memberof common
     */
    StringValue: {
        fields: {
            value: {
                type: "string",
                id: 1
            }
        }
    },

    /**
     * Properties of a google.protobuf.BytesValue message.
     * @interface IBytesValue
     * @type {Object}
     * @property {Uint8Array} [value]
     * @memberof common
     */
    BytesValue: {
        fields: {
            value: {
                type: "bytes",
                id: 1
            }
        }
    }
});

common("field_mask", {

    /**
     * Properties of a google.protobuf.FieldMask message.
     * @interface IDoubleValue
     * @type {Object}
     * @property {number} [value]
     * @memberof common
     */
    FieldMask: {
        fields: {
            paths: {
                rule: "repeated",
                type: "string",
                id: 1
            }
        }
    }
});

/**
 * Gets the root definition of the specified common proto file.
 *
 * Bundled definitions are:
 * - google/protobuf/any.proto
 * - google/protobuf/duration.proto
 * - google/protobuf/empty.proto
 * - google/protobuf/field_mask.proto
 * - google/protobuf/struct.proto
 * - google/protobuf/timestamp.proto
 * - google/protobuf/wrappers.proto
 *
 * @param {string} file Proto file name
 * @returns {INamespace|null} Root definition or `null` if not defined
 */
common.get = function get(file) {
    return common[file] || null;
};

},{}],12:[function(require,module,exports){
"use strict";
/**
 * Runtime message from/to plain object converters.
 * @namespace
 */
var converter = exports;

var Enum = require(15),
    util = require(37);

/**
 * Generates a partial value fromObject conveter.
 * @param {Codegen} gen Codegen instance
 * @param {Field} field Reflected field
 * @param {number} fieldIndex Field index
 * @param {string} prop Property reference
 * @returns {Codegen} Codegen instance
 * @ignore
 */
function genValuePartial_fromObject(gen, field, fieldIndex, prop) {
    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */
    if (field.resolvedType) {
        if (field.resolvedType instanceof Enum) { gen
            ("switch(d%s){", prop);
            for (var values = field.resolvedType.values, keys = Object.keys(values), i = 0; i < keys.length; ++i) {
                if (field.repeated && values[keys[i]] === field.typeDefault) gen
                ("default:");
                gen
                ("case%j:", keys[i])
                ("case %i:", values[keys[i]])
                    ("m%s=%j", prop, values[keys[i]])
                    ("break");
            } gen
            ("}");
        } else gen
            ("if(typeof d%s!==\"object\")", prop)
                ("throw TypeError(%j)", field.fullName + ": object expected")
            ("m%s=types[%i].fromObject(d%s)", prop, fieldIndex, prop);
    } else {
        var isUnsigned = false;
        switch (field.type) {
            case "double":
            case "float": gen
                ("m%s=Number(d%s)", prop, prop); // also catches "NaN", "Infinity"
                break;
            case "uint32":
            case "fixed32": gen
                ("m%s=d%s>>>0", prop, prop);
                break;
            case "int32":
            case "sint32":
            case "sfixed32": gen
                ("m%s=d%s|0", prop, prop);
                break;
            case "uint64":
                isUnsigned = true;
                // eslint-disable-line no-fallthrough
            case "int64":
            case "sint64":
            case "fixed64":
            case "sfixed64": gen
                ("if(util.Long)")
                    ("(m%s=util.Long.fromValue(d%s)).unsigned=%j", prop, prop, isUnsigned)
                ("else if(typeof d%s===\"string\")", prop)
                    ("m%s=parseInt(d%s,10)", prop, prop)
                ("else if(typeof d%s===\"number\")", prop)
                    ("m%s=d%s", prop, prop)
                ("else if(typeof d%s===\"object\")", prop)
                    ("m%s=new util.LongBits(d%s.low>>>0,d%s.high>>>0).toNumber(%s)", prop, prop, prop, isUnsigned ? "true" : "");
                break;
            case "bytes": gen
                ("if(typeof d%s===\"string\")", prop)
                    ("util.base64.decode(d%s,m%s=util.newBuffer(util.base64.length(d%s)),0)", prop, prop, prop)
                ("else if(d%s.length)", prop)
                    ("m%s=d%s", prop, prop);
                break;
            case "string": gen
                ("m%s=String(d%s)", prop, prop);
                break;
            case "bool": gen
                ("m%s=Boolean(d%s)", prop, prop);
                break;
            /* default: gen
                ("m%s=d%s", prop, prop);
                break; */
        }
    }
    return gen;
    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */
}

/**
 * Generates a plain object to runtime message converter specific to the specified message type.
 * @param {Type} mtype Message type
 * @returns {Codegen} Codegen instance
 */
converter.fromObject = function fromObject(mtype) {
    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */
    var fields = mtype.fieldsArray;
    var gen = util.codegen(["d"], mtype.name + "$fromObject")
    ("if(d instanceof this.ctor)")
        ("return d");
    if (!fields.length) return gen
    ("return new this.ctor");
    gen
    ("var m=new this.ctor");
    for (var i = 0; i < fields.length; ++i) {
        var field  = fields[i].resolve(),
            prop   = util.safeProp(field.name);

        // Map fields
        if (field.map) { gen
    ("if(d%s){", prop)
        ("if(typeof d%s!==\"object\")", prop)
            ("throw TypeError(%j)", field.fullName + ": object expected")
        ("m%s={}", prop)
        ("for(var ks=Object.keys(d%s),i=0;i<ks.length;++i){", prop);
            genValuePartial_fromObject(gen, field, /* not sorted */ i, prop + "[ks[i]]")
        ("}")
    ("}");

        // Repeated fields
        } else if (field.repeated) { gen
    ("if(d%s){", prop)
        ("if(!Array.isArray(d%s))", prop)
            ("throw TypeError(%j)", field.fullName + ": array expected")
        ("m%s=[]", prop)
        ("for(var i=0;i<d%s.length;++i){", prop);
            genValuePartial_fromObject(gen, field, /* not sorted */ i, prop + "[i]")
        ("}")
    ("}");

        // Non-repeated fields
        } else {
            if (!(field.resolvedType instanceof Enum)) gen // no need to test for null/undefined if an enum (uses switch)
    ("if(d%s!=null){", prop); // !== undefined && !== null
        genValuePartial_fromObject(gen, field, /* not sorted */ i, prop);
            if (!(field.resolvedType instanceof Enum)) gen
    ("}");
        }
    } return gen
    ("return m");
    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */
};

/**
 * Generates a partial value toObject converter.
 * @param {Codegen} gen Codegen instance
 * @param {Field} field Reflected field
 * @param {number} fieldIndex Field index
 * @param {string} prop Property reference
 * @returns {Codegen} Codegen instance
 * @ignore
 */
function genValuePartial_toObject(gen, field, fieldIndex, prop) {
    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */
    if (field.resolvedType) {
        if (field.resolvedType instanceof Enum) gen
            ("d%s=o.enums===String?types[%i].values[m%s]:m%s", prop, fieldIndex, prop, prop);
        else gen
            ("d%s=types[%i].toObject(m%s,o)", prop, fieldIndex, prop);
    } else {
        var isUnsigned = false;
        switch (field.type) {
            case "double":
            case "float": gen
            ("d%s=o.json&&!isFinite(m%s)?String(m%s):m%s", prop, prop, prop, prop);
                break;
            case "uint64":
                isUnsigned = true;
                // eslint-disable-line no-fallthrough
            case "int64":
            case "sint64":
            case "fixed64":
            case "sfixed64": gen
            ("if(typeof m%s===\"number\")", prop)
                ("d%s=o.longs===String?String(m%s):m%s", prop, prop, prop)
            ("else") // Long-like
                ("d%s=o.longs===String?util.Long.prototype.toString.call(m%s):o.longs===Number?new util.LongBits(m%s.low>>>0,m%s.high>>>0).toNumber(%s):m%s", prop, prop, prop, prop, isUnsigned ? "true": "", prop);
                break;
            case "bytes": gen
            ("d%s=o.bytes===String?util.base64.encode(m%s,0,m%s.length):o.bytes===Array?Array.prototype.slice.call(m%s):m%s", prop, prop, prop, prop, prop);
                break;
            default: gen
            ("d%s=m%s", prop, prop);
                break;
        }
    }
    return gen;
    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */
}

/**
 * Generates a runtime message to plain object converter specific to the specified message type.
 * @param {Type} mtype Message type
 * @returns {Codegen} Codegen instance
 */
converter.toObject = function toObject(mtype) {
    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */
    var fields = mtype.fieldsArray.slice().sort(util.compareFieldsById);
    if (!fields.length)
        return util.codegen()("return {}");
    var gen = util.codegen(["m", "o"], mtype.name + "$toObject")
    ("if(!o)")
        ("o={}")
    ("var d={}");

    var repeatedFields = [],
        mapFields = [],
        normalFields = [],
        i = 0;
    for (; i < fields.length; ++i)
        if (!fields[i].partOf)
            ( fields[i].resolve().repeated ? repeatedFields
            : fields[i].map ? mapFields
            : normalFields).push(fields[i]);

    if (repeatedFields.length) { gen
    ("if(o.arrays||o.defaults){");
        for (i = 0; i < repeatedFields.length; ++i) gen
        ("d%s=[]", util.safeProp(repeatedFields[i].name));
        gen
    ("}");
    }

    if (mapFields.length) { gen
    ("if(o.objects||o.defaults){");
        for (i = 0; i < mapFields.length; ++i) gen
        ("d%s={}", util.safeProp(mapFields[i].name));
        gen
    ("}");
    }

    if (normalFields.length) { gen
    ("if(o.defaults){");
        for (i = 0; i < normalFields.length; ++i) {
            var field = normalFields[i],
                prop  = util.safeProp(field.name);
            if (field.resolvedType instanceof Enum) gen
        ("d%s=o.enums===String?%j:%j", prop, field.resolvedType.valuesById[field.typeDefault], field.typeDefault);
            else if (field.long) gen
        ("if(util.Long){")
            ("var n=new util.Long(%i,%i,%j)", field.typeDefault.low, field.typeDefault.high, field.typeDefault.unsigned)
            ("d%s=o.longs===String?n.toString():o.longs===Number?n.toNumber():n", prop)
        ("}else")
            ("d%s=o.longs===String?%j:%i", prop, field.typeDefault.toString(), field.typeDefault.toNumber());
            else if (field.bytes) gen
        ("d%s=o.bytes===String?%j:%s", prop, String.fromCharCode.apply(String, field.typeDefault), "[" + Array.prototype.slice.call(field.typeDefault).join(",") + "]");
            else gen
        ("d%s=%j", prop, field.typeDefault); // also messages (=null)
        } gen
    ("}");
    }
    var hasKs2 = false;
    for (i = 0; i < fields.length; ++i) {
        var field = fields[i],
            index = mtype._fieldsArray.indexOf(field),
            prop  = util.safeProp(field.name);
        if (field.map) {
            if (!hasKs2) { hasKs2 = true; gen
    ("var ks2");
            } gen
    ("if(m%s&&(ks2=Object.keys(m%s)).length){", prop, prop)
        ("d%s={}", prop)
        ("for(var j=0;j<ks2.length;++j){");
            genValuePartial_toObject(gen, field, /* sorted */ index, prop + "[ks2[j]]")
        ("}");
        } else if (field.repeated) { gen
    ("if(m%s&&m%s.length){", prop, prop)
        ("d%s=[]", prop)
        ("for(var j=0;j<m%s.length;++j){", prop);
            genValuePartial_toObject(gen, field, /* sorted */ index, prop + "[j]")
        ("}");
        } else { gen
    ("if(m%s!=null&&m.hasOwnProperty(%j)){", prop, field.name); // !== undefined && !== null
        genValuePartial_toObject(gen, field, /* sorted */ index, prop);
        if (field.partOf) gen
        ("if(o.oneofs)")
            ("d%s=%j", util.safeProp(field.partOf.name), field.name);
        }
        gen
    ("}");
    }
    return gen
    ("return d");
    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */
};

},{"15":15,"37":37}],13:[function(require,module,exports){
"use strict";
module.exports = decoder;

var Enum    = require(15),
    types   = require(36),
    util    = require(37);

function missing(field) {
    return "missing required '" + field.name + "'";
}

/**
 * Generates a decoder specific to the specified message type.
 * @param {Type} mtype Message type
 * @returns {Codegen} Codegen instance
 */
function decoder(mtype) {
    /* eslint-disable no-unexpected-multiline */
    var gen = util.codegen(["r", "l"], mtype.name + "$decode")
    ("if(!(r instanceof Reader))")
        ("r=Reader.create(r)")
    ("var c=l===undefined?r.len:r.pos+l,m=new this.ctor" + (mtype.fieldsArray.filter(function(field) { return field.map; }).length ? ",k" : ""))
    ("while(r.pos<c){")
        ("var t=r.uint32()");
    if (mtype.group) gen
        ("if((t&7)===4)")
            ("break");
    gen
        ("switch(t>>>3){");

    var i = 0;
    for (; i < /* initializes */ mtype.fieldsArray.length; ++i) {
        var field = mtype._fieldsArray[i].resolve(),
            type  = field.resolvedType instanceof Enum ? "int32" : field.type,
            ref   = "m" + util.safeProp(field.name); gen
            ("case %i:", field.id);

        // Map fields
        if (field.map) { gen
                ("r.skip().pos++") // assumes id 1 + key wireType
                ("if(%s===util.emptyObject)", ref)
                    ("%s={}", ref)
                ("k=r.%s()", field.keyType)
                ("r.pos++"); // assumes id 2 + value wireType
            if (types.long[field.keyType] !== undefined) {
                if (types.basic[type] === undefined) gen
                ("%s[typeof k===\"object\"?util.longToHash(k):k]=types[%i].decode(r,r.uint32())", ref, i); // can't be groups
                else gen
                ("%s[typeof k===\"object\"?util.longToHash(k):k]=r.%s()", ref, type);
            } else {
                if (types.basic[type] === undefined) gen
                ("%s[k]=types[%i].decode(r,r.uint32())", ref, i); // can't be groups
                else gen
                ("%s[k]=r.%s()", ref, type);
            }

        // Repeated fields
        } else if (field.repeated) { gen

                ("if(!(%s&&%s.length))", ref, ref)
                    ("%s=[]", ref);

            // Packable (always check for forward and backward compatiblity)
            if (types.packed[type] !== undefined) gen
                ("if((t&7)===2){")
                    ("var c2=r.uint32()+r.pos")
                    ("while(r.pos<c2)")
                        ("%s.push(r.%s())", ref, type)
                ("}else");

            // Non-packed
            if (types.basic[type] === undefined) gen(field.resolvedType.group
                    ? "%s.push(types[%i].decode(r))"
                    : "%s.push(types[%i].decode(r,r.uint32()))", ref, i);
            else gen
                    ("%s.push(r.%s())", ref, type);

        // Non-repeated
        } else if (types.basic[type] === undefined) gen(field.resolvedType.group
                ? "%s=types[%i].decode(r)"
                : "%s=types[%i].decode(r,r.uint32())", ref, i);
        else gen
                ("%s=r.%s()", ref, type);
        gen
                ("break");
    // Unknown fields
    } gen
            ("default:")
                ("r.skipType(t&7)")
                ("break")

        ("}")
    ("}");

    // Field presence
    for (i = 0; i < mtype._fieldsArray.length; ++i) {
        var rfield = mtype._fieldsArray[i];
        if (rfield.required) gen
    ("if(!m.hasOwnProperty(%j))", rfield.name)
        ("throw util.ProtocolError(%j,{instance:m})", missing(rfield));
    }

    return gen
    ("return m");
    /* eslint-enable no-unexpected-multiline */
}

},{"15":15,"36":36,"37":37}],14:[function(require,module,exports){
"use strict";
module.exports = encoder;

var Enum     = require(15),
    types    = require(36),
    util     = require(37);

/**
 * Generates a partial message type encoder.
 * @param {Codegen} gen Codegen instance
 * @param {Field} field Reflected field
 * @param {number} fieldIndex Field index
 * @param {string} ref Variable reference
 * @returns {Codegen} Codegen instance
 * @ignore
 */
function genTypePartial(gen, field, fieldIndex, ref) {
    return field.resolvedType.group
        ? gen("types[%i].encode(%s,w.uint32(%i)).uint32(%i)", fieldIndex, ref, (field.id << 3 | 3) >>> 0, (field.id << 3 | 4) >>> 0)
        : gen("types[%i].encode(%s,w.uint32(%i).fork()).ldelim()", fieldIndex, ref, (field.id << 3 | 2) >>> 0);
}

/**
 * Generates an encoder specific to the specified message type.
 * @param {Type} mtype Message type
 * @returns {Codegen} Codegen instance
 */
function encoder(mtype) {
    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */
    var gen = util.codegen(["m", "w"], mtype.name + "$encode")
    ("if(!w)")
        ("w=Writer.create()");

    var i, ref;

    // "when a message is serialized its known fields should be written sequentially by field number"
    var fields = /* initializes */ mtype.fieldsArray.slice().sort(util.compareFieldsById);

    for (var i = 0; i < fields.length; ++i) {
        var field    = fields[i].resolve(),
            index    = mtype._fieldsArray.indexOf(field),
            type     = field.resolvedType instanceof Enum ? "int32" : field.type,
            wireType = types.basic[type];
            ref      = "m" + util.safeProp(field.name);

        // Map fields
        if (field.map) {
            gen
    ("if(%s!=null&&m.hasOwnProperty(%j)){", ref, field.name) // !== undefined && !== null
        ("for(var ks=Object.keys(%s),i=0;i<ks.length;++i){", ref)
            ("w.uint32(%i).fork().uint32(%i).%s(ks[i])", (field.id << 3 | 2) >>> 0, 8 | types.mapKey[field.keyType], field.keyType);
            if (wireType === undefined) gen
            ("types[%i].encode(%s[ks[i]],w.uint32(18).fork()).ldelim().ldelim()", index, ref); // can't be groups
            else gen
            (".uint32(%i).%s(%s[ks[i]]).ldelim()", 16 | wireType, type, ref);
            gen
        ("}")
    ("}");

            // Repeated fields
        } else if (field.repeated) { gen
    ("if(%s!=null&&%s.length){", ref, ref); // !== undefined && !== null

            // Packed repeated
            if (field.packed && types.packed[type] !== undefined) { gen

        ("w.uint32(%i).fork()", (field.id << 3 | 2) >>> 0)
        ("for(var i=0;i<%s.length;++i)", ref)
            ("w.%s(%s[i])", type, ref)
        ("w.ldelim()");

            // Non-packed
            } else { gen

        ("for(var i=0;i<%s.length;++i)", ref);
                if (wireType === undefined)
            genTypePartial(gen, field, index, ref + "[i]");
                else gen
            ("w.uint32(%i).%s(%s[i])", (field.id << 3 | wireType) >>> 0, type, ref);

            } gen
    ("}");

        // Non-repeated
        } else {
            if (field.optional) gen
    ("if(%s!=null&&m.hasOwnProperty(%j))", ref, field.name); // !== undefined && !== null

            if (wireType === undefined)
        genTypePartial(gen, field, index, ref);
            else gen
        ("w.uint32(%i).%s(%s)", (field.id << 3 | wireType) >>> 0, type, ref);

        }
    }

    return gen
    ("return w");
    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */
}
},{"15":15,"36":36,"37":37}],15:[function(require,module,exports){
"use strict";
module.exports = Enum;

// extends ReflectionObject
var ReflectionObject = require(24);
((Enum.prototype = Object.create(ReflectionObject.prototype)).constructor = Enum).className = "Enum";

var Namespace = require(23),
    util = require(37);

/**
 * Constructs a new enum instance.
 * @classdesc Reflected enum.
 * @extends ReflectionObject
 * @constructor
 * @param {string} name Unique name within its namespace
 * @param {Object.<string,number>} [values] Enum values as an object, by name
 * @param {Object.<string,*>} [options] Declared options
 * @param {string} [comment] The comment for this enum
 * @param {Object.<string,string>} [comments] The value comments for this enum
 */
function Enum(name, values, options, comment, comments) {
    ReflectionObject.call(this, name, options);

    if (values && typeof values !== "object")
        throw TypeError("values must be an object");

    /**
     * Enum values by id.
     * @type {Object.<number,string>}
     */
    this.valuesById = {};

    /**
     * Enum values by name.
     * @type {Object.<string,number>}
     */
    this.values = Object.create(this.valuesById); // toJSON, marker

    /**
     * Enum comment text.
     * @type {string|null}
     */
    this.comment = comment;

    /**
     * Value comment texts, if any.
     * @type {Object.<string,string>}
     */
    this.comments = comments || {};

    /**
     * Reserved ranges, if any.
     * @type {Array.<number[]|string>}
     */
    this.reserved = undefined; // toJSON

    // Note that values inherit valuesById on their prototype which makes them a TypeScript-
    // compatible enum. This is used by pbts to write actual enum definitions that work for
    // static and reflection code alike instead of emitting generic object definitions.

    if (values)
        for (var keys = Object.keys(values), i = 0; i < keys.length; ++i)
            if (typeof values[keys[i]] === "number") // use forward entries only
                this.valuesById[ this.values[keys[i]] = values[keys[i]] ] = keys[i];
}

/**
 * Enum descriptor.
 * @interface IEnum
 * @property {Object.<string,number>} values Enum values
 * @property {Object.<string,*>} [options] Enum options
 */

/**
 * Constructs an enum from an enum descriptor.
 * @param {string} name Enum name
 * @param {IEnum} json Enum descriptor
 * @returns {Enum} Created enum
 * @throws {TypeError} If arguments are invalid
 */
Enum.fromJSON = function fromJSON(name, json) {
    var enm = new Enum(name, json.values, json.options, json.comment, json.comments);
    enm.reserved = json.reserved;
    return enm;
};

/**
 * Converts this enum to an enum descriptor.
 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
 * @returns {IEnum} Enum descriptor
 */
Enum.prototype.toJSON = function toJSON(toJSONOptions) {
    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
    return util.toObject([
        "options"  , this.options,
        "values"   , this.values,
        "reserved" , this.reserved && this.reserved.length ? this.reserved : undefined,
        "comment"  , keepComments ? this.comment : undefined,
        "comments" , keepComments ? this.comments : undefined
    ]);
};

/**
 * Adds a value to this enum.
 * @param {string} name Value name
 * @param {number} id Value id
 * @param {string} [comment] Comment, if any
 * @returns {Enum} `this`
 * @throws {TypeError} If arguments are invalid
 * @throws {Error} If there is already a value with this name or id
 */
Enum.prototype.add = function add(name, id, comment) {
    // utilized by the parser but not by .fromJSON

    if (!util.isString(name))
        throw TypeError("name must be a string");

    if (!util.isInteger(id))
        throw TypeError("id must be an integer");

    if (this.values[name] !== undefined)
        throw Error("duplicate name '" + name + "' in " + this);

    if (this.isReservedId(id))
        throw Error("id " + id + " is reserved in " + this);

    if (this.isReservedName(name))
        throw Error("name '" + name + "' is reserved in " + this);

    if (this.valuesById[id] !== undefined) {
        if (!(this.options && this.options.allow_alias))
            throw Error("duplicate id " + id + " in " + this);
        this.values[name] = id;
    } else
        this.valuesById[this.values[name] = id] = name;

    this.comments[name] = comment || null;
    return this;
};

/**
 * Removes a value from this enum
 * @param {string} name Value name
 * @returns {Enum} `this`
 * @throws {TypeError} If arguments are invalid
 * @throws {Error} If `name` is not a name of this enum
 */
Enum.prototype.remove = function remove(name) {

    if (!util.isString(name))
        throw TypeError("name must be a string");

    var val = this.values[name];
    if (val == null)
        throw Error("name '" + name + "' does not exist in " + this);

    delete this.valuesById[val];
    delete this.values[name];
    delete this.comments[name];

    return this;
};

/**
 * Tests if the specified id is reserved.
 * @param {number} id Id to test
 * @returns {boolean} `true` if reserved, otherwise `false`
 */
Enum.prototype.isReservedId = function isReservedId(id) {
    return Namespace.isReservedId(this.reserved, id);
};

/**
 * Tests if the specified name is reserved.
 * @param {string} name Name to test
 * @returns {boolean} `true` if reserved, otherwise `false`
 */
Enum.prototype.isReservedName = function isReservedName(name) {
    return Namespace.isReservedName(this.reserved, name);
};

},{"23":23,"24":24,"37":37}],16:[function(require,module,exports){
"use strict";
module.exports = Field;

// extends ReflectionObject
var ReflectionObject = require(24);
((Field.prototype = Object.create(ReflectionObject.prototype)).constructor = Field).className = "Field";

var Enum  = require(15),
    types = require(36),
    util  = require(37);

var Type; // cyclic

var ruleRe = /^required|optional|repeated$/;

/**
 * Constructs a new message field instance. Note that {@link MapField|map fields} have their own class.
 * @name Field
 * @classdesc Reflected message field.
 * @extends FieldBase
 * @constructor
 * @param {string} name Unique name within its namespace
 * @param {number} id Unique id within its namespace
 * @param {string} type Value type
 * @param {string|Object.<string,*>} [rule="optional"] Field rule
 * @param {string|Object.<string,*>} [extend] Extended type if different from parent
 * @param {Object.<string,*>} [options] Declared options
 */

/**
 * Constructs a field from a field descriptor.
 * @param {string} name Field name
 * @param {IField} json Field descriptor
 * @returns {Field} Created field
 * @throws {TypeError} If arguments are invalid
 */
Field.fromJSON = function fromJSON(name, json) {
    return new Field(name, json.id, json.type, json.rule, json.extend, json.options, json.comment);
};

/**
 * Not an actual constructor. Use {@link Field} instead.
 * @classdesc Base class of all reflected message fields. This is not an actual class but here for the sake of having consistent type definitions.
 * @exports FieldBase
 * @extends ReflectionObject
 * @constructor
 * @param {string} name Unique name within its namespace
 * @param {number} id Unique id within its namespace
 * @param {string} type Value type
 * @param {string|Object.<string,*>} [rule="optional"] Field rule
 * @param {string|Object.<string,*>} [extend] Extended type if different from parent
 * @param {Object.<string,*>} [options] Declared options
 * @param {string} [comment] Comment associated with this field
 */
function Field(name, id, type, rule, extend, options, comment) {

    if (util.isObject(rule)) {
        comment = extend;
        options = rule;
        rule = extend = undefined;
    } else if (util.isObject(extend)) {
        comment = options;
        options = extend;
        extend = undefined;
    }

    ReflectionObject.call(this, name, options);

    if (!util.isInteger(id) || id < 0)
        throw TypeError("id must be a non-negative integer");

    if (!util.isString(type))
        throw TypeError("type must be a string");

    if (rule !== undefined && !ruleRe.test(rule = rule.toString().toLowerCase()))
        throw TypeError("rule must be a string rule");

    if (extend !== undefined && !util.isString(extend))
        throw TypeError("extend must be a string");

    /**
     * Field rule, if any.
     * @type {string|undefined}
     */
    this.rule = rule && rule !== "optional" ? rule : undefined; // toJSON

    /**
     * Field type.
     * @type {string}
     */
    this.type = type; // toJSON

    /**
     * Unique field id.
     * @type {number}
     */
    this.id = id; // toJSON, marker

    /**
     * Extended type if different from parent.
     * @type {string|undefined}
     */
    this.extend = extend || undefined; // toJSON

    /**
     * Whether this field is required.
     * @type {boolean}
     */
    this.required = rule === "required";

    /**
     * Whether this field is optional.
     * @type {boolean}
     */
    this.optional = !this.required;

    /**
     * Whether this field is repeated.
     * @type {boolean}
     */
    this.repeated = rule === "repeated";

    /**
     * Whether this field is a map or not.
     * @type {boolean}
     */
    this.map = false;

    /**
     * Message this field belongs to.
     * @type {Type|null}
     */
    this.message = null;

    /**
     * OneOf this field belongs to, if any,
     * @type {OneOf|null}
     */
    this.partOf = null;

    /**
     * The field type's default value.
     * @type {*}
     */
    this.typeDefault = null;

    /**
     * The field's default value on prototypes.
     * @type {*}
     */
    this.defaultValue = null;

    /**
     * Whether this field's value should be treated as a long.
     * @type {boolean}
     */
    this.long = util.Long ? types.long[type] !== undefined : /* istanbul ignore next */ false;

    /**
     * Whether this field's value is a buffer.
     * @type {boolean}
     */
    this.bytes = type === "bytes";

    /**
     * Resolved type if not a basic type.
     * @type {Type|Enum|null}
     */
    this.resolvedType = null;

    /**
     * Sister-field within the extended type if a declaring extension field.
     * @type {Field|null}
     */
    this.extensionField = null;

    /**
     * Sister-field within the declaring namespace if an extended field.
     * @type {Field|null}
     */
    this.declaringField = null;

    /**
     * Internally remembers whether this field is packed.
     * @type {boolean|null}
     * @private
     */
    this._packed = null;

    /**
     * Comment for this field.
     * @type {string|null}
     */
    this.comment = comment;
}

/**
 * Determines whether this field is packed. Only relevant when repeated and working with proto2.
 * @name Field#packed
 * @type {boolean}
 * @readonly
 */
Object.defineProperty(Field.prototype, "packed", {
    get: function() {
        // defaults to packed=true if not explicity set to false
        if (this._packed === null)
            this._packed = this.getOption("packed") !== false;
        return this._packed;
    }
});

/**
 * @override
 */
Field.prototype.setOption = function setOption(name, value, ifNotSet) {
    if (name === "packed") // clear cached before setting
        this._packed = null;
    return ReflectionObject.prototype.setOption.call(this, name, value, ifNotSet);
};

/**
 * Field descriptor.
 * @interface IField
 * @property {string} [rule="optional"] Field rule
 * @property {string} type Field type
 * @property {number} id Field id
 * @property {Object.<string,*>} [options] Field options
 */

/**
 * Extension field descriptor.
 * @interface IExtensionField
 * @extends IField
 * @property {string} extend Extended type
 */

/**
 * Converts this field to a field descriptor.
 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
 * @returns {IField} Field descriptor
 */
Field.prototype.toJSON = function toJSON(toJSONOptions) {
    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
    return util.toObject([
        "rule"    , this.rule !== "optional" && this.rule || undefined,
        "type"    , this.type,
        "id"      , this.id,
        "extend"  , this.extend,
        "options" , this.options,
        "comment" , keepComments ? this.comment : undefined
    ]);
};

/**
 * Resolves this field's type references.
 * @returns {Field} `this`
 * @throws {Error} If any reference cannot be resolved
 */
Field.prototype.resolve = function resolve() {

    if (this.resolved)
        return this;

    if ((this.typeDefault = types.defaults[this.type]) === undefined) { // if not a basic type, resolve it
        this.resolvedType = (this.declaringField ? this.declaringField.parent : this.parent).lookupTypeOrEnum(this.type);
        if (this.resolvedType instanceof Type)
            this.typeDefault = null;
        else // instanceof Enum
            this.typeDefault = this.resolvedType.values[Object.keys(this.resolvedType.values)[0]]; // first defined
    }

    // use explicitly set default value if present
    if (this.options && this.options["default"] != null) {
        this.typeDefault = this.options["default"];
        if (this.resolvedType instanceof Enum && typeof this.typeDefault === "string")
            this.typeDefault = this.resolvedType.values[this.typeDefault];
    }

    // remove unnecessary options
    if (this.options) {
        if (this.options.packed === true || this.options.packed !== undefined && this.resolvedType && !(this.resolvedType instanceof Enum))
            delete this.options.packed;
        if (!Object.keys(this.options).length)
            this.options = undefined;
    }

    // convert to internal data type if necesssary
    if (this.long) {
        this.typeDefault = util.Long.fromNumber(this.typeDefault, this.type.charAt(0) === "u");

        /* istanbul ignore else */
        if (Object.freeze)
            Object.freeze(this.typeDefault); // long instances are meant to be immutable anyway (i.e. use small int cache that even requires it)

    } else if (this.bytes && typeof this.typeDefault === "string") {
        var buf;
        if (util.base64.test(this.typeDefault))
            util.base64.decode(this.typeDefault, buf = util.newBuffer(util.base64.length(this.typeDefault)), 0);
        else
            util.utf8.write(this.typeDefault, buf = util.newBuffer(util.utf8.length(this.typeDefault)), 0);
        this.typeDefault = buf;
    }

    // take special care of maps and repeated fields
    if (this.map)
        this.defaultValue = util.emptyObject;
    else if (this.repeated)
        this.defaultValue = util.emptyArray;
    else
        this.defaultValue = this.typeDefault;

    // ensure proper value on prototype
    if (this.parent instanceof Type)
        this.parent.ctor.prototype[this.name] = this.defaultValue;

    return ReflectionObject.prototype.resolve.call(this);
};

/**
 * Decorator function as returned by {@link Field.d} and {@link MapField.d} (TypeScript).
 * @typedef FieldDecorator
 * @type {function}
 * @param {Object} prototype Target prototype
 * @param {string} fieldName Field name
 * @returns {undefined}
 */

/**
 * Field decorator (TypeScript).
 * @name Field.d
 * @function
 * @param {number} fieldId Field id
 * @param {"double"|"float"|"int32"|"uint32"|"sint32"|"fixed32"|"sfixed32"|"int64"|"uint64"|"sint64"|"fixed64"|"sfixed64"|"string"|"bool"|"bytes"|Object} fieldType Field type
 * @param {"optional"|"required"|"repeated"} [fieldRule="optional"] Field rule
 * @param {T} [defaultValue] Default value
 * @returns {FieldDecorator} Decorator function
 * @template T extends number | number[] | Long | Long[] | string | string[] | boolean | boolean[] | Uint8Array | Uint8Array[] | Buffer | Buffer[]
 */
Field.d = function decorateField(fieldId, fieldType, fieldRule, defaultValue) {

    // submessage: decorate the submessage and use its name as the type
    if (typeof fieldType === "function")
        fieldType = util.decorateType(fieldType).name;

    // enum reference: create a reflected copy of the enum and keep reuseing it
    else if (fieldType && typeof fieldType === "object")
        fieldType = util.decorateEnum(fieldType).name;

    return function fieldDecorator(prototype, fieldName) {
        util.decorateType(prototype.constructor)
            .add(new Field(fieldName, fieldId, fieldType, fieldRule, { "default": defaultValue }));
    };
};

/**
 * Field decorator (TypeScript).
 * @name Field.d
 * @function
 * @param {number} fieldId Field id
 * @param {Constructor<T>|string} fieldType Field type
 * @param {"optional"|"required"|"repeated"} [fieldRule="optional"] Field rule
 * @returns {FieldDecorator} Decorator function
 * @template T extends Message<T>
 * @variation 2
 */
// like Field.d but without a default value

Field._configure = function configure(Type_) {
    Type = Type_;
};

},{"15":15,"24":24,"36":36,"37":37}],17:[function(require,module,exports){
"use strict";
var protobuf = module.exports = require(18);

protobuf.build = "light";

/**
 * A node-style callback as used by {@link load} and {@link Root#load}.
 * @typedef LoadCallback
 * @type {function}
 * @param {Error|null} error Error, if any, otherwise `null`
 * @param {Root} [root] Root, if there hasn't been an error
 * @returns {undefined}
 */

/**
 * Loads one or multiple .proto or preprocessed .json files into a common root namespace and calls the callback.
 * @param {string|string[]} filename One or multiple files to load
 * @param {Root} root Root namespace, defaults to create a new one if omitted.
 * @param {LoadCallback} callback Callback function
 * @returns {undefined}
 * @see {@link Root#load}
 */
function load(filename, root, callback) {
    if (typeof root === "function") {
        callback = root;
        root = new protobuf.Root();
    } else if (!root)
        root = new protobuf.Root();
    return root.load(filename, callback);
}

/**
 * Loads one or multiple .proto or preprocessed .json files into a common root namespace and calls the callback.
 * @name load
 * @function
 * @param {string|string[]} filename One or multiple files to load
 * @param {LoadCallback} callback Callback function
 * @returns {undefined}
 * @see {@link Root#load}
 * @variation 2
 */
// function load(filename:string, callback:LoadCallback):undefined

/**
 * Loads one or multiple .proto or preprocessed .json files into a common root namespace and returns a promise.
 * @name load
 * @function
 * @param {string|string[]} filename One or multiple files to load
 * @param {Root} [root] Root namespace, defaults to create a new one if omitted.
 * @returns {Promise<Root>} Promise
 * @see {@link Root#load}
 * @variation 3
 */
// function load(filename:string, [root:Root]):Promise<Root>

protobuf.load = load;

/**
 * Synchronously loads one or multiple .proto or preprocessed .json files into a common root namespace (node only).
 * @param {string|string[]} filename One or multiple files to load
 * @param {Root} [root] Root namespace, defaults to create a new one if omitted.
 * @returns {Root} Root namespace
 * @throws {Error} If synchronous fetching is not supported (i.e. in browsers) or if a file's syntax is invalid
 * @see {@link Root#loadSync}
 */
function loadSync(filename, root) {
    if (!root)
        root = new protobuf.Root();
    return root.loadSync(filename);
}

protobuf.loadSync = loadSync;

// Serialization
protobuf.encoder          = require(14);
protobuf.decoder          = require(13);
protobuf.verifier         = require(40);
protobuf.converter        = require(12);

// Reflection
protobuf.ReflectionObject = require(24);
protobuf.Namespace        = require(23);
protobuf.Root             = require(29);
protobuf.Enum             = require(15);
protobuf.Type             = require(35);
protobuf.Field            = require(16);
protobuf.OneOf            = require(25);
protobuf.MapField         = require(20);
protobuf.Service          = require(33);
protobuf.Method           = require(22);

// Runtime
protobuf.Message          = require(21);
protobuf.wrappers         = require(41);

// Utility
protobuf.types            = require(36);
protobuf.util             = require(37);

// Configure reflection
protobuf.ReflectionObject._configure(protobuf.Root);
protobuf.Namespace._configure(protobuf.Type, protobuf.Service);
protobuf.Root._configure(protobuf.Type);
protobuf.Field._configure(protobuf.Type);

},{"12":12,"13":13,"14":14,"15":15,"16":16,"18":18,"20":20,"21":21,"22":22,"23":23,"24":24,"25":25,"29":29,"33":33,"35":35,"36":36,"37":37,"40":40,"41":41}],18:[function(require,module,exports){
"use strict";
var protobuf = exports;

/**
 * Build type, one of `"full"`, `"light"` or `"minimal"`.
 * @name build
 * @type {string}
 * @const
 */
protobuf.build = "minimal";

// Serialization
protobuf.Writer       = require(42);
protobuf.BufferWriter = require(43);
protobuf.Reader       = require(27);
protobuf.BufferReader = require(28);

// Utility
protobuf.util         = require(39);
protobuf.rpc          = require(31);
protobuf.roots        = require(30);
protobuf.configure    = configure;

/* istanbul ignore next */
/**
 * Reconfigures the library according to the environment.
 * @returns {undefined}
 */
function configure() {
    protobuf.Reader._configure(protobuf.BufferReader);
    protobuf.util._configure();
}

// Configure serialization
protobuf.Writer._configure(protobuf.BufferWriter);
configure();

},{"27":27,"28":28,"30":30,"31":31,"39":39,"42":42,"43":43}],19:[function(require,module,exports){
"use strict";
var protobuf = module.exports = require(17);

protobuf.build = "full";

// Parser
protobuf.tokenize         = require(34);
protobuf.parse            = require(26);
protobuf.common           = require(11);

// Configure parser
protobuf.Root._configure(protobuf.Type, protobuf.parse, protobuf.common);

},{"11":11,"17":17,"26":26,"34":34}],20:[function(require,module,exports){
"use strict";
module.exports = MapField;

// extends Field
var Field = require(16);
((MapField.prototype = Object.create(Field.prototype)).constructor = MapField).className = "MapField";

var types   = require(36),
    util    = require(37);

/**
 * Constructs a new map field instance.
 * @classdesc Reflected map field.
 * @extends FieldBase
 * @constructor
 * @param {string} name Unique name within its namespace
 * @param {number} id Unique id within its namespace
 * @param {string} keyType Key type
 * @param {string} type Value type
 * @param {Object.<string,*>} [options] Declared options
 * @param {string} [comment] Comment associated with this field
 */
function MapField(name, id, keyType, type, options, comment) {
    Field.call(this, name, id, type, undefined, undefined, options, comment);

    /* istanbul ignore if */
    if (!util.isString(keyType))
        throw TypeError("keyType must be a string");

    /**
     * Key type.
     * @type {string}
     */
    this.keyType = keyType; // toJSON, marker

    /**
     * Resolved key type if not a basic type.
     * @type {ReflectionObject|null}
     */
    this.resolvedKeyType = null;

    // Overrides Field#map
    this.map = true;
}

/**
 * Map field descriptor.
 * @interface IMapField
 * @extends {IField}
 * @property {string} keyType Key type
 */

/**
 * Extension map field descriptor.
 * @interface IExtensionMapField
 * @extends IMapField
 * @property {string} extend Extended type
 */

/**
 * Constructs a map field from a map field descriptor.
 * @param {string} name Field name
 * @param {IMapField} json Map field descriptor
 * @returns {MapField} Created map field
 * @throws {TypeError} If arguments are invalid
 */
MapField.fromJSON = function fromJSON(name, json) {
    return new MapField(name, json.id, json.keyType, json.type, json.options, json.comment);
};

/**
 * Converts this map field to a map field descriptor.
 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
 * @returns {IMapField} Map field descriptor
 */
MapField.prototype.toJSON = function toJSON(toJSONOptions) {
    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
    return util.toObject([
        "keyType" , this.keyType,
        "type"    , this.type,
        "id"      , this.id,
        "extend"  , this.extend,
        "options" , this.options,
        "comment" , keepComments ? this.comment : undefined
    ]);
};

/**
 * @override
 */
MapField.prototype.resolve = function resolve() {
    if (this.resolved)
        return this;

    // Besides a value type, map fields have a key type that may be "any scalar type except for floating point types and bytes"
    if (types.mapKey[this.keyType] === undefined)
        throw Error("invalid key type: " + this.keyType);

    return Field.prototype.resolve.call(this);
};

/**
 * Map field decorator (TypeScript).
 * @name MapField.d
 * @function
 * @param {number} fieldId Field id
 * @param {"int32"|"uint32"|"sint32"|"fixed32"|"sfixed32"|"int64"|"uint64"|"sint64"|"fixed64"|"sfixed64"|"bool"|"string"} fieldKeyType Field key type
 * @param {"double"|"float"|"int32"|"uint32"|"sint32"|"fixed32"|"sfixed32"|"int64"|"uint64"|"sint64"|"fixed64"|"sfixed64"|"bool"|"string"|"bytes"|Object|Constructor<{}>} fieldValueType Field value type
 * @returns {FieldDecorator} Decorator function
 * @template T extends { [key: string]: number | Long | string | boolean | Uint8Array | Buffer | number[] | Message<{}> }
 */
MapField.d = function decorateMapField(fieldId, fieldKeyType, fieldValueType) {

    // submessage value: decorate the submessage and use its name as the type
    if (typeof fieldValueType === "function")
        fieldValueType = util.decorateType(fieldValueType).name;

    // enum reference value: create a reflected copy of the enum and keep reuseing it
    else if (fieldValueType && typeof fieldValueType === "object")
        fieldValueType = util.decorateEnum(fieldValueType).name;

    return function mapFieldDecorator(prototype, fieldName) {
        util.decorateType(prototype.constructor)
            .add(new MapField(fieldName, fieldId, fieldKeyType, fieldValueType));
    };
};

},{"16":16,"36":36,"37":37}],21:[function(require,module,exports){
"use strict";
module.exports = Message;

var util = require(39);

/**
 * Constructs a new message instance.
 * @classdesc Abstract runtime message.
 * @constructor
 * @param {Properties<T>} [properties] Properties to set
 * @template T extends object
 */
function Message(properties) {
    // not used internally
    if (properties)
        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            this[keys[i]] = properties[keys[i]];
}

/**
 * Reference to the reflected type.
 * @name Message.$type
 * @type {Type}
 * @readonly
 */

/**
 * Reference to the reflected type.
 * @name Message#$type
 * @type {Type}
 * @readonly
 */

/*eslint-disable valid-jsdoc*/

/**
 * Creates a new message of this type using the specified properties.
 * @param {Object.<string,*>} [properties] Properties to set
 * @returns {Message<T>} Message instance
 * @template T extends Message<T>
 * @this Constructor<T>
 */
Message.create = function create(properties) {
    return this.$type.create(properties);
};

/**
 * Encodes a message of this type.
 * @param {T|Object.<string,*>} message Message to encode
 * @param {Writer} [writer] Writer to use
 * @returns {Writer} Writer
 * @template T extends Message<T>
 * @this Constructor<T>
 */
Message.encode = function encode(message, writer) {
    return this.$type.encode(message, writer);
};

/**
 * Encodes a message of this type preceeded by its length as a varint.
 * @param {T|Object.<string,*>} message Message to encode
 * @param {Writer} [writer] Writer to use
 * @returns {Writer} Writer
 * @template T extends Message<T>
 * @this Constructor<T>
 */
Message.encodeDelimited = function encodeDelimited(message, writer) {
    return this.$type.encodeDelimited(message, writer);
};

/**
 * Decodes a message of this type.
 * @name Message.decode
 * @function
 * @param {Reader|Uint8Array} reader Reader or buffer to decode
 * @returns {T} Decoded message
 * @template T extends Message<T>
 * @this Constructor<T>
 */
Message.decode = function decode(reader) {
    return this.$type.decode(reader);
};

/**
 * Decodes a message of this type preceeded by its length as a varint.
 * @name Message.decodeDelimited
 * @function
 * @param {Reader|Uint8Array} reader Reader or buffer to decode
 * @returns {T} Decoded message
 * @template T extends Message<T>
 * @this Constructor<T>
 */
Message.decodeDelimited = function decodeDelimited(reader) {
    return this.$type.decodeDelimited(reader);
};

/**
 * Verifies a message of this type.
 * @name Message.verify
 * @function
 * @param {Object.<string,*>} message Plain object to verify
 * @returns {string|null} `null` if valid, otherwise the reason why it is not
 */
Message.verify = function verify(message) {
    return this.$type.verify(message);
};

/**
 * Creates a new message of this type from a plain object. Also converts values to their respective internal types.
 * @param {Object.<string,*>} object Plain object
 * @returns {T} Message instance
 * @template T extends Message<T>
 * @this Constructor<T>
 */
Message.fromObject = function fromObject(object) {
    return this.$type.fromObject(object);
};

/**
 * Creates a plain object from a message of this type. Also converts values to other types if specified.
 * @param {T} message Message instance
 * @param {IConversionOptions} [options] Conversion options
 * @returns {Object.<string,*>} Plain object
 * @template T extends Message<T>
 * @this Constructor<T>
 */
Message.toObject = function toObject(message, options) {
    return this.$type.toObject(message, options);
};

/**
 * Converts this message to JSON.
 * @returns {Object.<string,*>} JSON object
 */
Message.prototype.toJSON = function toJSON() {
    return this.$type.toObject(this, util.toJSONOptions);
};

/*eslint-enable valid-jsdoc*/
},{"39":39}],22:[function(require,module,exports){
"use strict";
module.exports = Method;

// extends ReflectionObject
var ReflectionObject = require(24);
((Method.prototype = Object.create(ReflectionObject.prototype)).constructor = Method).className = "Method";

var util = require(37);

/**
 * Constructs a new service method instance.
 * @classdesc Reflected service method.
 * @extends ReflectionObject
 * @constructor
 * @param {string} name Method name
 * @param {string|undefined} type Method type, usually `"rpc"`
 * @param {string} requestType Request message type
 * @param {string} responseType Response message type
 * @param {boolean|Object.<string,*>} [requestStream] Whether the request is streamed
 * @param {boolean|Object.<string,*>} [responseStream] Whether the response is streamed
 * @param {Object.<string,*>} [options] Declared options
 * @param {string} [comment] The comment for this method
 */
function Method(name, type, requestType, responseType, requestStream, responseStream, options, comment) {

    /* istanbul ignore next */
    if (util.isObject(requestStream)) {
        options = requestStream;
        requestStream = responseStream = undefined;
    } else if (util.isObject(responseStream)) {
        options = responseStream;
        responseStream = undefined;
    }

    /* istanbul ignore if */
    if (!(type === undefined || util.isString(type)))
        throw TypeError("type must be a string");

    /* istanbul ignore if */
    if (!util.isString(requestType))
        throw TypeError("requestType must be a string");

    /* istanbul ignore if */
    if (!util.isString(responseType))
        throw TypeError("responseType must be a string");

    ReflectionObject.call(this, name, options);

    /**
     * Method type.
     * @type {string}
     */
    this.type = type || "rpc"; // toJSON

    /**
     * Request type.
     * @type {string}
     */
    this.requestType = requestType; // toJSON, marker

    /**
     * Whether requests are streamed or not.
     * @type {boolean|undefined}
     */
    this.requestStream = requestStream ? true : undefined; // toJSON

    /**
     * Response type.
     * @type {string}
     */
    this.responseType = responseType; // toJSON

    /**
     * Whether responses are streamed or not.
     * @type {boolean|undefined}
     */
    this.responseStream = responseStream ? true : undefined; // toJSON

    /**
     * Resolved request type.
     * @type {Type|null}
     */
    this.resolvedRequestType = null;

    /**
     * Resolved response type.
     * @type {Type|null}
     */
    this.resolvedResponseType = null;

    /**
     * Comment for this method
     * @type {string|null}
     */
    this.comment = comment;
}

/**
 * Method descriptor.
 * @interface IMethod
 * @property {string} [type="rpc"] Method type
 * @property {string} requestType Request type
 * @property {string} responseType Response type
 * @property {boolean} [requestStream=false] Whether requests are streamed
 * @property {boolean} [responseStream=false] Whether responses are streamed
 * @property {Object.<string,*>} [options] Method options
 */

/**
 * Constructs a method from a method descriptor.
 * @param {string} name Method name
 * @param {IMethod} json Method descriptor
 * @returns {Method} Created method
 * @throws {TypeError} If arguments are invalid
 */
Method.fromJSON = function fromJSON(name, json) {
    return new Method(name, json.type, json.requestType, json.responseType, json.requestStream, json.responseStream, json.options, json.comment);
};

/**
 * Converts this method to a method descriptor.
 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
 * @returns {IMethod} Method descriptor
 */
Method.prototype.toJSON = function toJSON(toJSONOptions) {
    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
    return util.toObject([
        "type"           , this.type !== "rpc" && /* istanbul ignore next */ this.type || undefined,
        "requestType"    , this.requestType,
        "requestStream"  , this.requestStream,
        "responseType"   , this.responseType,
        "responseStream" , this.responseStream,
        "options"        , this.options,
        "comment"        , keepComments ? this.comment : undefined
    ]);
};

/**
 * @override
 */
Method.prototype.resolve = function resolve() {

    /* istanbul ignore if */
    if (this.resolved)
        return this;

    this.resolvedRequestType = this.parent.lookupType(this.requestType);
    this.resolvedResponseType = this.parent.lookupType(this.responseType);

    return ReflectionObject.prototype.resolve.call(this);
};

},{"24":24,"37":37}],23:[function(require,module,exports){
"use strict";
module.exports = Namespace;

// extends ReflectionObject
var ReflectionObject = require(24);
((Namespace.prototype = Object.create(ReflectionObject.prototype)).constructor = Namespace).className = "Namespace";

var Enum     = require(15),
    Field    = require(16),
    util     = require(37);

var Type,    // cyclic
    Service; // "

/**
 * Constructs a new namespace instance.
 * @name Namespace
 * @classdesc Reflected namespace.
 * @extends NamespaceBase
 * @constructor
 * @param {string} name Namespace name
 * @param {Object.<string,*>} [options] Declared options
 */

/**
 * Constructs a namespace from JSON.
 * @memberof Namespace
 * @function
 * @param {string} name Namespace name
 * @param {Object.<string,*>} json JSON object
 * @returns {Namespace} Created namespace
 * @throws {TypeError} If arguments are invalid
 */
Namespace.fromJSON = function fromJSON(name, json) {
    return new Namespace(name, json.options).addJSON(json.nested);
};

/**
 * Converts an array of reflection objects to JSON.
 * @memberof Namespace
 * @param {ReflectionObject[]} array Object array
 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
 * @returns {Object.<string,*>|undefined} JSON object or `undefined` when array is empty
 */
function arrayToJSON(array, toJSONOptions) {
    if (!(array && array.length))
        return undefined;
    var obj = {};
    for (var i = 0; i < array.length; ++i)
        obj[array[i].name] = array[i].toJSON(toJSONOptions);
    return obj;
}

Namespace.arrayToJSON = arrayToJSON;

/**
 * Tests if the specified id is reserved.
 * @param {Array.<number[]|string>|undefined} reserved Array of reserved ranges and names
 * @param {number} id Id to test
 * @returns {boolean} `true` if reserved, otherwise `false`
 */
Namespace.isReservedId = function isReservedId(reserved, id) {
    if (reserved)
        for (var i = 0; i < reserved.length; ++i)
            if (typeof reserved[i] !== "string" && reserved[i][0] <= id && reserved[i][1] >= id)
                return true;
    return false;
};

/**
 * Tests if the specified name is reserved.
 * @param {Array.<number[]|string>|undefined} reserved Array of reserved ranges and names
 * @param {string} name Name to test
 * @returns {boolean} `true` if reserved, otherwise `false`
 */
Namespace.isReservedName = function isReservedName(reserved, name) {
    if (reserved)
        for (var i = 0; i < reserved.length; ++i)
            if (reserved[i] === name)
                return true;
    return false;
};

/**
 * Not an actual constructor. Use {@link Namespace} instead.
 * @classdesc Base class of all reflection objects containing nested objects. This is not an actual class but here for the sake of having consistent type definitions.
 * @exports NamespaceBase
 * @extends ReflectionObject
 * @abstract
 * @constructor
 * @param {string} name Namespace name
 * @param {Object.<string,*>} [options] Declared options
 * @see {@link Namespace}
 */
function Namespace(name, options) {
    ReflectionObject.call(this, name, options);

    /**
     * Nested objects by name.
     * @type {Object.<string,ReflectionObject>|undefined}
     */
    this.nested = undefined; // toJSON

    /**
     * Cached nested objects as an array.
     * @type {ReflectionObject[]|null}
     * @private
     */
    this._nestedArray = null;
}

function clearCache(namespace) {
    namespace._nestedArray = null;
    return namespace;
}

/**
 * Nested objects of this namespace as an array for iteration.
 * @name NamespaceBase#nestedArray
 * @type {ReflectionObject[]}
 * @readonly
 */
Object.defineProperty(Namespace.prototype, "nestedArray", {
    get: function() {
        return this._nestedArray || (this._nestedArray = util.toArray(this.nested));
    }
});

/**
 * Namespace descriptor.
 * @interface INamespace
 * @property {Object.<string,*>} [options] Namespace options
 * @property {Object.<string,AnyNestedObject>} [nested] Nested object descriptors
 */

/**
 * Any extension field descriptor.
 * @typedef AnyExtensionField
 * @type {IExtensionField|IExtensionMapField}
 */

/**
 * Any nested object descriptor.
 * @typedef AnyNestedObject
 * @type {IEnum|IType|IService|AnyExtensionField|INamespace}
 */
// ^ BEWARE: VSCode hangs forever when using more than 5 types (that's why AnyExtensionField exists in the first place)

/**
 * Converts this namespace to a namespace descriptor.
 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
 * @returns {INamespace} Namespace descriptor
 */
Namespace.prototype.toJSON = function toJSON(toJSONOptions) {
    return util.toObject([
        "options" , this.options,
        "nested"  , arrayToJSON(this.nestedArray, toJSONOptions)
    ]);
};

/**
 * Adds nested objects to this namespace from nested object descriptors.
 * @param {Object.<string,AnyNestedObject>} nestedJson Any nested object descriptors
 * @returns {Namespace} `this`
 */
Namespace.prototype.addJSON = function addJSON(nestedJson) {
    var ns = this;
    /* istanbul ignore else */
    if (nestedJson) {
        for (var names = Object.keys(nestedJson), i = 0, nested; i < names.length; ++i) {
            nested = nestedJson[names[i]];
            ns.add( // most to least likely
                ( nested.fields !== undefined
                ? Type.fromJSON
                : nested.values !== undefined
                ? Enum.fromJSON
                : nested.methods !== undefined
                ? Service.fromJSON
                : nested.id !== undefined
                ? Field.fromJSON
                : Namespace.fromJSON )(names[i], nested)
            );
        }
    }
    return this;
};

/**
 * Gets the nested object of the specified name.
 * @param {string} name Nested object name
 * @returns {ReflectionObject|null} The reflection object or `null` if it doesn't exist
 */
Namespace.prototype.get = function get(name) {
    return this.nested && this.nested[name]
        || null;
};

/**
 * Gets the values of the nested {@link Enum|enum} of the specified name.
 * This methods differs from {@link Namespace#get|get} in that it returns an enum's values directly and throws instead of returning `null`.
 * @param {string} name Nested enum name
 * @returns {Object.<string,number>} Enum values
 * @throws {Error} If there is no such enum
 */
Namespace.prototype.getEnum = function getEnum(name) {
    if (this.nested && this.nested[name] instanceof Enum)
        return this.nested[name].values;
    throw Error("no such enum: " + name);
};

/**
 * Adds a nested object to this namespace.
 * @param {ReflectionObject} object Nested object to add
 * @returns {Namespace} `this`
 * @throws {TypeError} If arguments are invalid
 * @throws {Error} If there is already a nested object with this name
 */
Namespace.prototype.add = function add(object) {

    if (!(object instanceof Field && object.extend !== undefined || object instanceof Type || object instanceof Enum || object instanceof Service || object instanceof Namespace))
        throw TypeError("object must be a valid nested object");

    if (!this.nested)
        this.nested = {};
    else {
        var prev = this.get(object.name);
        if (prev) {
            if (prev instanceof Namespace && object instanceof Namespace && !(prev instanceof Type || prev instanceof Service)) {
                // replace plain namespace but keep existing nested elements and options
                var nested = prev.nestedArray;
                for (var i = 0; i < nested.length; ++i)
                    object.add(nested[i]);
                this.remove(prev);
                if (!this.nested)
                    this.nested = {};
                object.setOptions(prev.options, true);

            } else
                throw Error("duplicate name '" + object.name + "' in " + this);
        }
    }
    this.nested[object.name] = object;
    object.onAdd(this);
    return clearCache(this);
};

/**
 * Removes a nested object from this namespace.
 * @param {ReflectionObject} object Nested object to remove
 * @returns {Namespace} `this`
 * @throws {TypeError} If arguments are invalid
 * @throws {Error} If `object` is not a member of this namespace
 */
Namespace.prototype.remove = function remove(object) {

    if (!(object instanceof ReflectionObject))
        throw TypeError("object must be a ReflectionObject");
    if (object.parent !== this)
        throw Error(object + " is not a member of " + this);

    delete this.nested[object.name];
    if (!Object.keys(this.nested).length)
        this.nested = undefined;

    object.onRemove(this);
    return clearCache(this);
};

/**
 * Defines additial namespaces within this one if not yet existing.
 * @param {string|string[]} path Path to create
 * @param {*} [json] Nested types to create from JSON
 * @returns {Namespace} Pointer to the last namespace created or `this` if path is empty
 */
Namespace.prototype.define = function define(path, json) {

    if (util.isString(path))
        path = path.split(".");
    else if (!Array.isArray(path))
        throw TypeError("illegal path");
    if (path && path.length && path[0] === "")
        throw Error("path must be relative");

    var ptr = this;
    while (path.length > 0) {
        var part = path.shift();
        if (ptr.nested && ptr.nested[part]) {
            ptr = ptr.nested[part];
            if (!(ptr instanceof Namespace))
                throw Error("path conflicts with non-namespace objects");
        } else
            ptr.add(ptr = new Namespace(part));
    }
    if (json)
        ptr.addJSON(json);
    return ptr;
};

/**
 * Resolves this namespace's and all its nested objects' type references. Useful to validate a reflection tree, but comes at a cost.
 * @returns {Namespace} `this`
 */
Namespace.prototype.resolveAll = function resolveAll() {
    var nested = this.nestedArray, i = 0;
    while (i < nested.length)
        if (nested[i] instanceof Namespace)
            nested[i++].resolveAll();
        else
            nested[i++].resolve();
    return this.resolve();
};

/**
 * Recursively looks up the reflection object matching the specified path in the scope of this namespace.
 * @param {string|string[]} path Path to look up
 * @param {*|Array.<*>} filterTypes Filter types, any combination of the constructors of `protobuf.Type`, `protobuf.Enum`, `protobuf.Service` etc.
 * @param {boolean} [parentAlreadyChecked=false] If known, whether the parent has already been checked
 * @returns {ReflectionObject|null} Looked up object or `null` if none could be found
 */
Namespace.prototype.lookup = function lookup(path, filterTypes, parentAlreadyChecked) {

    /* istanbul ignore next */
    if (typeof filterTypes === "boolean") {
        parentAlreadyChecked = filterTypes;
        filterTypes = undefined;
    } else if (filterTypes && !Array.isArray(filterTypes))
        filterTypes = [ filterTypes ];

    if (util.isString(path) && path.length) {
        if (path === ".")
            return this.root;
        path = path.split(".");
    } else if (!path.length)
        return this;

    // Start at root if path is absolute
    if (path[0] === "")
        return this.root.lookup(path.slice(1), filterTypes);

    // Test if the first part matches any nested object, and if so, traverse if path contains more
    var found = this.get(path[0]);
    if (found) {
        if (path.length === 1) {
            if (!filterTypes || filterTypes.indexOf(found.constructor) > -1)
                return found;
        } else if (found instanceof Namespace && (found = found.lookup(path.slice(1), filterTypes, true)))
            return found;

    // Otherwise try each nested namespace
    } else
        for (var i = 0; i < this.nestedArray.length; ++i)
            if (this._nestedArray[i] instanceof Namespace && (found = this._nestedArray[i].lookup(path, filterTypes, true)))
                return found;

    // If there hasn't been a match, try again at the parent
    if (this.parent === null || parentAlreadyChecked)
        return null;
    return this.parent.lookup(path, filterTypes);
};

/**
 * Looks up the reflection object at the specified path, relative to this namespace.
 * @name NamespaceBase#lookup
 * @function
 * @param {string|string[]} path Path to look up
 * @param {boolean} [parentAlreadyChecked=false] Whether the parent has already been checked
 * @returns {ReflectionObject|null} Looked up object or `null` if none could be found
 * @variation 2
 */
// lookup(path: string, [parentAlreadyChecked: boolean])

/**
 * Looks up the {@link Type|type} at the specified path, relative to this namespace.
 * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.
 * @param {string|string[]} path Path to look up
 * @returns {Type} Looked up type
 * @throws {Error} If `path` does not point to a type
 */
Namespace.prototype.lookupType = function lookupType(path) {
    var found = this.lookup(path, [ Type ]);
    if (!found)
        throw Error("no such type: " + path);
    return found;
};

/**
 * Looks up the values of the {@link Enum|enum} at the specified path, relative to this namespace.
 * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.
 * @param {string|string[]} path Path to look up
 * @returns {Enum} Looked up enum
 * @throws {Error} If `path` does not point to an enum
 */
Namespace.prototype.lookupEnum = function lookupEnum(path) {
    var found = this.lookup(path, [ Enum ]);
    if (!found)
        throw Error("no such Enum '" + path + "' in " + this);
    return found;
};

/**
 * Looks up the {@link Type|type} or {@link Enum|enum} at the specified path, relative to this namespace.
 * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.
 * @param {string|string[]} path Path to look up
 * @returns {Type} Looked up type or enum
 * @throws {Error} If `path` does not point to a type or enum
 */
Namespace.prototype.lookupTypeOrEnum = function lookupTypeOrEnum(path) {
    var found = this.lookup(path, [ Type, Enum ]);
    if (!found)
        throw Error("no such Type or Enum '" + path + "' in " + this);
    return found;
};

/**
 * Looks up the {@link Service|service} at the specified path, relative to this namespace.
 * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.
 * @param {string|string[]} path Path to look up
 * @returns {Service} Looked up service
 * @throws {Error} If `path` does not point to a service
 */
Namespace.prototype.lookupService = function lookupService(path) {
    var found = this.lookup(path, [ Service ]);
    if (!found)
        throw Error("no such Service '" + path + "' in " + this);
    return found;
};

Namespace._configure = function(Type_, Service_) {
    Type    = Type_;
    Service = Service_;
};

},{"15":15,"16":16,"24":24,"37":37}],24:[function(require,module,exports){
"use strict";
module.exports = ReflectionObject;

ReflectionObject.className = "ReflectionObject";

var util = require(37);

var Root; // cyclic

/**
 * Constructs a new reflection object instance.
 * @classdesc Base class of all reflection objects.
 * @constructor
 * @param {string} name Object name
 * @param {Object.<string,*>} [options] Declared options
 * @abstract
 */
function ReflectionObject(name, options) {

    if (!util.isString(name))
        throw TypeError("name must be a string");

    if (options && !util.isObject(options))
        throw TypeError("options must be an object");

    /**
     * Options.
     * @type {Object.<string,*>|undefined}
     */
    this.options = options; // toJSON

    /**
     * Unique name within its namespace.
     * @type {string}
     */
    this.name = name;

    /**
     * Parent namespace.
     * @type {Namespace|null}
     */
    this.parent = null;

    /**
     * Whether already resolved or not.
     * @type {boolean}
     */
    this.resolved = false;

    /**
     * Comment text, if any.
     * @type {string|null}
     */
    this.comment = null;

    /**
     * Defining file name.
     * @type {string|null}
     */
    this.filename = null;
}

Object.defineProperties(ReflectionObject.prototype, {

    /**
     * Reference to the root namespace.
     * @name ReflectionObject#root
     * @type {Root}
     * @readonly
     */
    root: {
        get: function() {
            var ptr = this;
            while (ptr.parent !== null)
                ptr = ptr.parent;
            return ptr;
        }
    },

    /**
     * Full name including leading dot.
     * @name ReflectionObject#fullName
     * @type {string}
     * @readonly
     */
    fullName: {
        get: function() {
            var path = [ this.name ],
                ptr = this.parent;
            while (ptr) {
                path.unshift(ptr.name);
                ptr = ptr.parent;
            }
            return path.join(".");
        }
    }
});

/**
 * Converts this reflection object to its descriptor representation.
 * @returns {Object.<string,*>} Descriptor
 * @abstract
 */
ReflectionObject.prototype.toJSON = /* istanbul ignore next */ function toJSON() {
    throw Error(); // not implemented, shouldn't happen
};

/**
 * Called when this object is added to a parent.
 * @param {ReflectionObject} parent Parent added to
 * @returns {undefined}
 */
ReflectionObject.prototype.onAdd = function onAdd(parent) {
    if (this.parent && this.parent !== parent)
        this.parent.remove(this);
    this.parent = parent;
    this.resolved = false;
    var root = parent.root;
    if (root instanceof Root)
        root._handleAdd(this);
};

/**
 * Called when this object is removed from a parent.
 * @param {ReflectionObject} parent Parent removed from
 * @returns {undefined}
 */
ReflectionObject.prototype.onRemove = function onRemove(parent) {
    var root = parent.root;
    if (root instanceof Root)
        root._handleRemove(this);
    this.parent = null;
    this.resolved = false;
};

/**
 * Resolves this objects type references.
 * @returns {ReflectionObject} `this`
 */
ReflectionObject.prototype.resolve = function resolve() {
    if (this.resolved)
        return this;
    if (this.root instanceof Root)
        this.resolved = true; // only if part of a root
    return this;
};

/**
 * Gets an option value.
 * @param {string} name Option name
 * @returns {*} Option value or `undefined` if not set
 */
ReflectionObject.prototype.getOption = function getOption(name) {
    if (this.options)
        return this.options[name];
    return undefined;
};

/**
 * Sets an option.
 * @param {string} name Option name
 * @param {*} value Option value
 * @param {boolean} [ifNotSet] Sets the option only if it isn't currently set
 * @returns {ReflectionObject} `this`
 */
ReflectionObject.prototype.setOption = function setOption(name, value, ifNotSet) {
    if (!ifNotSet || !this.options || this.options[name] === undefined)
        (this.options || (this.options = {}))[name] = value;
    return this;
};

/**
 * Sets multiple options.
 * @param {Object.<string,*>} options Options to set
 * @param {boolean} [ifNotSet] Sets an option only if it isn't currently set
 * @returns {ReflectionObject} `this`
 */
ReflectionObject.prototype.setOptions = function setOptions(options, ifNotSet) {
    if (options)
        for (var keys = Object.keys(options), i = 0; i < keys.length; ++i)
            this.setOption(keys[i], options[keys[i]], ifNotSet);
    return this;
};

/**
 * Converts this instance to its string representation.
 * @returns {string} Class name[, space, full name]
 */
ReflectionObject.prototype.toString = function toString() {
    var className = this.constructor.className,
        fullName  = this.fullName;
    if (fullName.length)
        return className + " " + fullName;
    return className;
};

ReflectionObject._configure = function(Root_) {
    Root = Root_;
};

},{"37":37}],25:[function(require,module,exports){
"use strict";
module.exports = OneOf;

// extends ReflectionObject
var ReflectionObject = require(24);
((OneOf.prototype = Object.create(ReflectionObject.prototype)).constructor = OneOf).className = "OneOf";

var Field = require(16),
    util  = require(37);

/**
 * Constructs a new oneof instance.
 * @classdesc Reflected oneof.
 * @extends ReflectionObject
 * @constructor
 * @param {string} name Oneof name
 * @param {string[]|Object.<string,*>} [fieldNames] Field names
 * @param {Object.<string,*>} [options] Declared options
 * @param {string} [comment] Comment associated with this field
 */
function OneOf(name, fieldNames, options, comment) {
    if (!Array.isArray(fieldNames)) {
        options = fieldNames;
        fieldNames = undefined;
    }
    ReflectionObject.call(this, name, options);

    /* istanbul ignore if */
    if (!(fieldNames === undefined || Array.isArray(fieldNames)))
        throw TypeError("fieldNames must be an Array");

    /**
     * Field names that belong to this oneof.
     * @type {string[]}
     */
    this.oneof = fieldNames || []; // toJSON, marker

    /**
     * Fields that belong to this oneof as an array for iteration.
     * @type {Field[]}
     * @readonly
     */
    this.fieldsArray = []; // declared readonly for conformance, possibly not yet added to parent

    /**
     * Comment for this field.
     * @type {string|null}
     */
    this.comment = comment;
}

/**
 * Oneof descriptor.
 * @interface IOneOf
 * @property {Array.<string>} oneof Oneof field names
 * @property {Object.<string,*>} [options] Oneof options
 */

/**
 * Constructs a oneof from a oneof descriptor.
 * @param {string} name Oneof name
 * @param {IOneOf} json Oneof descriptor
 * @returns {OneOf} Created oneof
 * @throws {TypeError} If arguments are invalid
 */
OneOf.fromJSON = function fromJSON(name, json) {
    return new OneOf(name, json.oneof, json.options, json.comment);
};

/**
 * Converts this oneof to a oneof descriptor.
 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
 * @returns {IOneOf} Oneof descriptor
 */
OneOf.prototype.toJSON = function toJSON(toJSONOptions) {
    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
    return util.toObject([
        "options" , this.options,
        "oneof"   , this.oneof,
        "comment" , keepComments ? this.comment : undefined
    ]);
};

/**
 * Adds the fields of the specified oneof to the parent if not already done so.
 * @param {OneOf} oneof The oneof
 * @returns {undefined}
 * @inner
 * @ignore
 */
function addFieldsToParent(oneof) {
    if (oneof.parent)
        for (var i = 0; i < oneof.fieldsArray.length; ++i)
            if (!oneof.fieldsArray[i].parent)
                oneof.parent.add(oneof.fieldsArray[i]);
}

/**
 * Adds a field to this oneof and removes it from its current parent, if any.
 * @param {Field} field Field to add
 * @returns {OneOf} `this`
 */
OneOf.prototype.add = function add(field) {

    /* istanbul ignore if */
    if (!(field instanceof Field))
        throw TypeError("field must be a Field");

    if (field.parent && field.parent !== this.parent)
        field.parent.remove(field);
    this.oneof.push(field.name);
    this.fieldsArray.push(field);
    field.partOf = this; // field.parent remains null
    addFieldsToParent(this);
    return this;
};

/**
 * Removes a field from this oneof and puts it back to the oneof's parent.
 * @param {Field} field Field to remove
 * @returns {OneOf} `this`
 */
OneOf.prototype.remove = function remove(field) {

    /* istanbul ignore if */
    if (!(field instanceof Field))
        throw TypeError("field must be a Field");

    var index = this.fieldsArray.indexOf(field);

    /* istanbul ignore if */
    if (index < 0)
        throw Error(field + " is not a member of " + this);

    this.fieldsArray.splice(index, 1);
    index = this.oneof.indexOf(field.name);

    /* istanbul ignore else */
    if (index > -1) // theoretical
        this.oneof.splice(index, 1);

    field.partOf = null;
    return this;
};

/**
 * @override
 */
OneOf.prototype.onAdd = function onAdd(parent) {
    ReflectionObject.prototype.onAdd.call(this, parent);
    var self = this;
    // Collect present fields
    for (var i = 0; i < this.oneof.length; ++i) {
        var field = parent.get(this.oneof[i]);
        if (field && !field.partOf) {
            field.partOf = self;
            self.fieldsArray.push(field);
        }
    }
    // Add not yet present fields
    addFieldsToParent(this);
};

/**
 * @override
 */
OneOf.prototype.onRemove = function onRemove(parent) {
    for (var i = 0, field; i < this.fieldsArray.length; ++i)
        if ((field = this.fieldsArray[i]).parent)
            field.parent.remove(field);
    ReflectionObject.prototype.onRemove.call(this, parent);
};

/**
 * Decorator function as returned by {@link OneOf.d} (TypeScript).
 * @typedef OneOfDecorator
 * @type {function}
 * @param {Object} prototype Target prototype
 * @param {string} oneofName OneOf name
 * @returns {undefined}
 */

/**
 * OneOf decorator (TypeScript).
 * @function
 * @param {...string} fieldNames Field names
 * @returns {OneOfDecorator} Decorator function
 * @template T extends string
 */
OneOf.d = function decorateOneOf() {
    var fieldNames = new Array(arguments.length),
        index = 0;
    while (index < arguments.length)
        fieldNames[index] = arguments[index++];
    return function oneOfDecorator(prototype, oneofName) {
        util.decorateType(prototype.constructor)
            .add(new OneOf(oneofName, fieldNames));
        Object.defineProperty(prototype, oneofName, {
            get: util.oneOfGetter(fieldNames),
            set: util.oneOfSetter(fieldNames)
        });
    };
};

},{"16":16,"24":24,"37":37}],26:[function(require,module,exports){
"use strict";
module.exports = parse;

parse.filename = null;
parse.defaults = { keepCase: false };

var tokenize  = require(34),
    Root      = require(29),
    Type      = require(35),
    Field     = require(16),
    MapField  = require(20),
    OneOf     = require(25),
    Enum      = require(15),
    Service   = require(33),
    Method    = require(22),
    types     = require(36),
    util      = require(37);

var base10Re    = /^[1-9][0-9]*$/,
    base10NegRe = /^-?[1-9][0-9]*$/,
    base16Re    = /^0[x][0-9a-fA-F]+$/,
    base16NegRe = /^-?0[x][0-9a-fA-F]+$/,
    base8Re     = /^0[0-7]+$/,
    base8NegRe  = /^-?0[0-7]+$/,
    numberRe    = /^(?![eE])[0-9]*(?:\.[0-9]*)?(?:[eE][+-]?[0-9]+)?$/,
    nameRe      = /^[a-zA-Z_][a-zA-Z_0-9]*$/,
    typeRefRe   = /^(?:\.?[a-zA-Z_][a-zA-Z_0-9]*)(?:\.[a-zA-Z_][a-zA-Z_0-9]*)*$/,
    fqTypeRefRe = /^(?:\.[a-zA-Z_][a-zA-Z_0-9]*)+$/;

/**
 * Result object returned from {@link parse}.
 * @interface IParserResult
 * @property {string|undefined} package Package name, if declared
 * @property {string[]|undefined} imports Imports, if any
 * @property {string[]|undefined} weakImports Weak imports, if any
 * @property {string|undefined} syntax Syntax, if specified (either `"proto2"` or `"proto3"`)
 * @property {Root} root Populated root instance
 */

/**
 * Options modifying the behavior of {@link parse}.
 * @interface IParseOptions
 * @property {boolean} [keepCase=false] Keeps field casing instead of converting to camel case
 * @property {boolean} [alternateCommentMode=false] Recognize double-slash comments in addition to doc-block comments.
 */

/**
 * Options modifying the behavior of JSON serialization.
 * @interface IToJSONOptions
 * @property {boolean} [keepComments=false] Serializes comments.
 */

/**
 * Parses the given .proto source and returns an object with the parsed contents.
 * @param {string} source Source contents
 * @param {Root} root Root to populate
 * @param {IParseOptions} [options] Parse options. Defaults to {@link parse.defaults} when omitted.
 * @returns {IParserResult} Parser result
 * @property {string} filename=null Currently processing file name for error reporting, if known
 * @property {IParseOptions} defaults Default {@link IParseOptions}
 */
function parse(source, root, options) {
    /* eslint-disable callback-return */
    if (!(root instanceof Root)) {
        options = root;
        root = new Root();
    }
    if (!options)
        options = parse.defaults;

    var tn = tokenize(source, options.alternateCommentMode || false),
        next = tn.next,
        push = tn.push,
        peek = tn.peek,
        skip = tn.skip,
        cmnt = tn.cmnt;

    var head = true,
        pkg,
        imports,
        weakImports,
        syntax,
        isProto3 = false;

    var ptr = root;

    var applyCase = options.keepCase ? function(name) { return name; } : util.camelCase;

    /* istanbul ignore next */
    function illegal(token, name, insideTryCatch) {
        var filename = parse.filename;
        if (!insideTryCatch)
            parse.filename = null;
        return Error("illegal " + (name || "token") + " '" + token + "' (" + (filename ? filename + ", " : "") + "line " + tn.line + ")");
    }

    function readString() {
        var values = [],
            token;
        do {
            /* istanbul ignore if */
            if ((token = next()) !== "\"" && token !== "'")
                throw illegal(token);

            values.push(next());
            skip(token);
            token = peek();
        } while (token === "\"" || token === "'");
        return values.join("");
    }

    function readValue(acceptTypeRef) {
        var token = next();
        switch (token) {
            case "'":
            case "\"":
                push(token);
                return readString();
            case "true": case "TRUE":
                return true;
            case "false": case "FALSE":
                return false;
        }
        try {
            return parseNumber(token, /* insideTryCatch */ true);
        } catch (e) {

            /* istanbul ignore else */
            if (acceptTypeRef && typeRefRe.test(token))
                return token;

            /* istanbul ignore next */
            throw illegal(token, "value");
        }
    }

    function readRanges(target, acceptStrings) {
        var token, start;
        do {
            if (acceptStrings && ((token = peek()) === "\"" || token === "'"))
                target.push(readString());
            else
                target.push([ start = parseId(next()), skip("to", true) ? parseId(next()) : start ]);
        } while (skip(",", true));
        skip(";");
    }

    function parseNumber(token, insideTryCatch) {
        var sign = 1;
        if (token.charAt(0) === "-") {
            sign = -1;
            token = token.substring(1);
        }
        switch (token) {
            case "inf": case "INF": case "Inf":
                return sign * Infinity;
            case "nan": case "NAN": case "Nan": case "NaN":
                return NaN;
            case "0":
                return 0;
        }
        if (base10Re.test(token))
            return sign * parseInt(token, 10);
        if (base16Re.test(token))
            return sign * parseInt(token, 16);
        if (base8Re.test(token))
            return sign * parseInt(token, 8);

        /* istanbul ignore else */
        if (numberRe.test(token))
            return sign * parseFloat(token);

        /* istanbul ignore next */
        throw illegal(token, "number", insideTryCatch);
    }

    function parseId(token, acceptNegative) {
        switch (token) {
            case "max": case "MAX": case "Max":
                return 536870911;
            case "0":
                return 0;
        }

        /* istanbul ignore if */
        if (!acceptNegative && token.charAt(0) === "-")
            throw illegal(token, "id");

        if (base10NegRe.test(token))
            return parseInt(token, 10);
        if (base16NegRe.test(token))
            return parseInt(token, 16);

        /* istanbul ignore else */
        if (base8NegRe.test(token))
            return parseInt(token, 8);

        /* istanbul ignore next */
        throw illegal(token, "id");
    }

    function parsePackage() {

        /* istanbul ignore if */
        if (pkg !== undefined)
            throw illegal("package");

        pkg = next();

        /* istanbul ignore if */
        if (!typeRefRe.test(pkg))
            throw illegal(pkg, "name");

        ptr = ptr.define(pkg);
        skip(";");
    }

    function parseImport() {
        var token = peek();
        var whichImports;
        switch (token) {
            case "weak":
                whichImports = weakImports || (weakImports = []);
                next();
                break;
            case "public":
                next();
                // eslint-disable-line no-fallthrough
            default:
                whichImports = imports || (imports = []);
                break;
        }
        token = readString();
        skip(";");
        whichImports.push(token);
    }

    function parseSyntax() {
        skip("=");
        syntax = readString();
        isProto3 = syntax === "proto3";

        /* istanbul ignore if */
        if (!isProto3 && syntax !== "proto2")
            throw illegal(syntax, "syntax");

        skip(";");
    }

    function parseCommon(parent, token) {
        switch (token) {

            case "option":
                parseOption(parent, token);
                skip(";");
                return true;

            case "message":
                parseType(parent, token);
                return true;

            case "enum":
                parseEnum(parent, token);
                return true;

            case "service":
                parseService(parent, token);
                return true;

            case "extend":
                parseExtension(parent, token);
                return true;
        }
        return false;
    }

    function ifBlock(obj, fnIf, fnElse) {
        var trailingLine = tn.line;
        if (obj) {
            obj.comment = cmnt(); // try block-type comment
            obj.filename = parse.filename;
        }
        if (skip("{", true)) {
            var token;
            while ((token = next()) !== "}")
                fnIf(token);
            skip(";", true);
        } else {
            if (fnElse)
                fnElse();
            skip(";");
            if (obj && typeof obj.comment !== "string")
                obj.comment = cmnt(trailingLine); // try line-type comment if no block
        }
    }

    function parseType(parent, token) {

        /* istanbul ignore if */
        if (!nameRe.test(token = next()))
            throw illegal(token, "type name");

        var type = new Type(token);
        ifBlock(type, function parseType_block(token) {
            if (parseCommon(type, token))
                return;

            switch (token) {

                case "map":
                    parseMapField(type, token);
                    break;

                case "required":
                case "optional":
                case "repeated":
                    parseField(type, token);
                    break;

                case "oneof":
                    parseOneOf(type, token);
                    break;

                case "extensions":
                    readRanges(type.extensions || (type.extensions = []));
                    break;

                case "reserved":
                    readRanges(type.reserved || (type.reserved = []), true);
                    break;

                default:
                    /* istanbul ignore if */
                    if (!isProto3 || !typeRefRe.test(token))
                        throw illegal(token);

                    push(token);
                    parseField(type, "optional");
                    break;
            }
        });
        parent.add(type);
    }

    function parseField(parent, rule, extend) {
        var type = next();
        if (type === "group") {
            parseGroup(parent, rule);
            return;
        }

        /* istanbul ignore if */
        if (!typeRefRe.test(type))
            throw illegal(type, "type");

        var name = next();

        /* istanbul ignore if */
        if (!nameRe.test(name))
            throw illegal(name, "name");

        name = applyCase(name);
        skip("=");

        var field = new Field(name, parseId(next()), type, rule, extend);
        ifBlock(field, function parseField_block(token) {

            /* istanbul ignore else */
            if (token === "option") {
                parseOption(field, token);
                skip(";");
            } else
                throw illegal(token);

        }, function parseField_line() {
            parseInlineOptions(field);
        });
        parent.add(field);

        // JSON defaults to packed=true if not set so we have to set packed=false explicity when
        // parsing proto2 descriptors without the option, where applicable. This must be done for
        // all known packable types and anything that could be an enum (= is not a basic type).
        if (!isProto3 && field.repeated && (types.packed[type] !== undefined || types.basic[type] === undefined))
            field.setOption("packed", false, /* ifNotSet */ true);
    }

    function parseGroup(parent, rule) {
        var name = next();

        /* istanbul ignore if */
        if (!nameRe.test(name))
            throw illegal(name, "name");

        var fieldName = util.lcFirst(name);
        if (name === fieldName)
            name = util.ucFirst(name);
        skip("=");
        var id = parseId(next());
        var type = new Type(name);
        type.group = true;
        var field = new Field(fieldName, id, name, rule);
        field.filename = parse.filename;
        ifBlock(type, function parseGroup_block(token) {
            switch (token) {

                case "option":
                    parseOption(type, token);
                    skip(";");
                    break;

                case "required":
                case "optional":
                case "repeated":
                    parseField(type, token);
                    break;

                /* istanbul ignore next */
                default:
                    throw illegal(token); // there are no groups with proto3 semantics
            }
        });
        parent.add(type)
              .add(field);
    }

    function parseMapField(parent) {
        skip("<");
        var keyType = next();

        /* istanbul ignore if */
        if (types.mapKey[keyType] === undefined)
            throw illegal(keyType, "type");

        skip(",");
        var valueType = next();

        /* istanbul ignore if */
        if (!typeRefRe.test(valueType))
            throw illegal(valueType, "type");

        skip(">");
        var name = next();

        /* istanbul ignore if */
        if (!nameRe.test(name))
            throw illegal(name, "name");

        skip("=");
        var field = new MapField(applyCase(name), parseId(next()), keyType, valueType);
        ifBlock(field, function parseMapField_block(token) {

            /* istanbul ignore else */
            if (token === "option") {
                parseOption(field, token);
                skip(";");
            } else
                throw illegal(token);

        }, function parseMapField_line() {
            parseInlineOptions(field);
        });
        parent.add(field);
    }

    function parseOneOf(parent, token) {

        /* istanbul ignore if */
        if (!nameRe.test(token = next()))
            throw illegal(token, "name");

        var oneof = new OneOf(applyCase(token));
        ifBlock(oneof, function parseOneOf_block(token) {
            if (token === "option") {
                parseOption(oneof, token);
                skip(";");
            } else {
                push(token);
                parseField(oneof, "optional");
            }
        });
        parent.add(oneof);
    }

    function parseEnum(parent, token) {

        /* istanbul ignore if */
        if (!nameRe.test(token = next()))
            throw illegal(token, "name");

        var enm = new Enum(token);
        ifBlock(enm, function parseEnum_block(token) {
          switch(token) {
            case "option":
              parseOption(enm, token);
              skip(";");
              break;

            case "reserved":
              readRanges(enm.reserved || (enm.reserved = []), true);
              break;

            default:
              parseEnumValue(enm, token);
          }
        });
        parent.add(enm);
    }

    function parseEnumValue(parent, token) {

        /* istanbul ignore if */
        if (!nameRe.test(token))
            throw illegal(token, "name");

        skip("=");
        var value = parseId(next(), true),
            dummy = {};
        ifBlock(dummy, function parseEnumValue_block(token) {

            /* istanbul ignore else */
            if (token === "option") {
                parseOption(dummy, token); // skip
                skip(";");
            } else
                throw illegal(token);

        }, function parseEnumValue_line() {
            parseInlineOptions(dummy); // skip
        });
        parent.add(token, value, dummy.comment);
    }

    function parseOption(parent, token) {
        var isCustom = skip("(", true);

        /* istanbul ignore if */
        if (!typeRefRe.test(token = next()))
            throw illegal(token, "name");

        var name = token;
        if (isCustom) {
            skip(")");
            name = "(" + name + ")";
            token = peek();
            if (fqTypeRefRe.test(token)) {
                name += token;
                next();
            }
        }
        skip("=");
        parseOptionValue(parent, name);
    }

    function parseOptionValue(parent, name) {
        if (skip("{", true)) { // { a: "foo" b { c: "bar" } }
            do {
                /* istanbul ignore if */
                if (!nameRe.test(token = next()))
                    throw illegal(token, "name");

                if (peek() === "{")
                    parseOptionValue(parent, name + "." + token);
                else {
                    skip(":");
                    if (peek() === "{")
                        parseOptionValue(parent, name + "." + token);
                    else
                        setOption(parent, name + "." + token, readValue(true));
                }
            } while (!skip("}", true));
        } else
            setOption(parent, name, readValue(true));
        // Does not enforce a delimiter to be universal
    }

    function setOption(parent, name, value) {
        if (parent.setOption)
            parent.setOption(name, value);
    }

    function parseInlineOptions(parent) {
        if (skip("[", true)) {
            do {
                parseOption(parent, "option");
            } while (skip(",", true));
            skip("]");
        }
        return parent;
    }

    function parseService(parent, token) {

        /* istanbul ignore if */
        if (!nameRe.test(token = next()))
            throw illegal(token, "service name");

        var service = new Service(token);
        ifBlock(service, function parseService_block(token) {
            if (parseCommon(service, token))
                return;

            /* istanbul ignore else */
            if (token === "rpc")
                parseMethod(service, token);
            else
                throw illegal(token);
        });
        parent.add(service);
    }

    function parseMethod(parent, token) {
        var type = token;

        /* istanbul ignore if */
        if (!nameRe.test(token = next()))
            throw illegal(token, "name");

        var name = token,
            requestType, requestStream,
            responseType, responseStream;

        skip("(");
        if (skip("stream", true))
            requestStream = true;

        /* istanbul ignore if */
        if (!typeRefRe.test(token = next()))
            throw illegal(token);

        requestType = token;
        skip(")"); skip("returns"); skip("(");
        if (skip("stream", true))
            responseStream = true;

        /* istanbul ignore if */
        if (!typeRefRe.test(token = next()))
            throw illegal(token);

        responseType = token;
        skip(")");

        var method = new Method(name, type, requestType, responseType, requestStream, responseStream);
        ifBlock(method, function parseMethod_block(token) {

            /* istanbul ignore else */
            if (token === "option") {
                parseOption(method, token);
                skip(";");
            } else
                throw illegal(token);

        });
        parent.add(method);
    }

    function parseExtension(parent, token) {

        /* istanbul ignore if */
        if (!typeRefRe.test(token = next()))
            throw illegal(token, "reference");

        var reference = token;
        ifBlock(null, function parseExtension_block(token) {
            switch (token) {

                case "required":
                case "repeated":
                case "optional":
                    parseField(parent, token, reference);
                    break;

                default:
                    /* istanbul ignore if */
                    if (!isProto3 || !typeRefRe.test(token))
                        throw illegal(token);
                    push(token);
                    parseField(parent, "optional", reference);
                    break;
            }
        });
    }

    var token;
    while ((token = next()) !== null) {
        switch (token) {

            case "package":

                /* istanbul ignore if */
                if (!head)
                    throw illegal(token);

                parsePackage();
                break;

            case "import":

                /* istanbul ignore if */
                if (!head)
                    throw illegal(token);

                parseImport();
                break;

            case "syntax":

                /* istanbul ignore if */
                if (!head)
                    throw illegal(token);

                parseSyntax();
                break;

            case "option":

                /* istanbul ignore if */
                if (!head)
                    throw illegal(token);

                parseOption(ptr, token);
                skip(";");
                break;

            default:

                /* istanbul ignore else */
                if (parseCommon(ptr, token)) {
                    head = false;
                    continue;
                }

                /* istanbul ignore next */
                throw illegal(token);
        }
    }

    parse.filename = null;
    return {
        "package"     : pkg,
        "imports"     : imports,
         weakImports  : weakImports,
         syntax       : syntax,
         root         : root
    };
}

/**
 * Parses the given .proto source and returns an object with the parsed contents.
 * @name parse
 * @function
 * @param {string} source Source contents
 * @param {IParseOptions} [options] Parse options. Defaults to {@link parse.defaults} when omitted.
 * @returns {IParserResult} Parser result
 * @property {string} filename=null Currently processing file name for error reporting, if known
 * @property {IParseOptions} defaults Default {@link IParseOptions}
 * @variation 2
 */

},{"15":15,"16":16,"20":20,"22":22,"25":25,"29":29,"33":33,"34":34,"35":35,"36":36,"37":37}],27:[function(require,module,exports){
"use strict";
module.exports = Reader;

var util      = require(39);

var BufferReader; // cyclic

var LongBits  = util.LongBits,
    utf8      = util.utf8;

/* istanbul ignore next */
function indexOutOfRange(reader, writeLength) {
    return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);
}

/**
 * Constructs a new reader instance using the specified buffer.
 * @classdesc Wire format reader using `Uint8Array` if available, otherwise `Array`.
 * @constructor
 * @param {Uint8Array} buffer Buffer to read from
 */
function Reader(buffer) {

    /**
     * Read buffer.
     * @type {Uint8Array}
     */
    this.buf = buffer;

    /**
     * Read buffer position.
     * @type {number}
     */
    this.pos = 0;

    /**
     * Read buffer length.
     * @type {number}
     */
    this.len = buffer.length;
}

var create_array = typeof Uint8Array !== "undefined"
    ? function create_typed_array(buffer) {
        if (buffer instanceof Uint8Array || Array.isArray(buffer))
            return new Reader(buffer);
        throw Error("illegal buffer");
    }
    /* istanbul ignore next */
    : function create_array(buffer) {
        if (Array.isArray(buffer))
            return new Reader(buffer);
        throw Error("illegal buffer");
    };

/**
 * Creates a new reader using the specified buffer.
 * @function
 * @param {Uint8Array|Buffer} buffer Buffer to read from
 * @returns {Reader|BufferReader} A {@link BufferReader} if `buffer` is a Buffer, otherwise a {@link Reader}
 * @throws {Error} If `buffer` is not a valid buffer
 */
Reader.create = util.Buffer
    ? function create_buffer_setup(buffer) {
        return (Reader.create = function create_buffer(buffer) {
            return util.Buffer.isBuffer(buffer)
                ? new BufferReader(buffer)
                /* istanbul ignore next */
                : create_array(buffer);
        })(buffer);
    }
    /* istanbul ignore next */
    : create_array;

Reader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */ util.Array.prototype.slice;

/**
 * Reads a varint as an unsigned 32 bit value.
 * @function
 * @returns {number} Value read
 */
Reader.prototype.uint32 = (function read_uint32_setup() {
    var value = 4294967295; // optimizer type-hint, tends to deopt otherwise (?!)
    return function read_uint32() {
        value = (         this.buf[this.pos] & 127       ) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) <<  7) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] &  15) << 28) >>> 0; if (this.buf[this.pos++] < 128) return value;

        /* istanbul ignore if */
        if ((this.pos += 5) > this.len) {
            this.pos = this.len;
            throw indexOutOfRange(this, 10);
        }
        return value;
    };
})();

/**
 * Reads a varint as a signed 32 bit value.
 * @returns {number} Value read
 */
Reader.prototype.int32 = function read_int32() {
    return this.uint32() | 0;
};

/**
 * Reads a zig-zag encoded varint as a signed 32 bit value.
 * @returns {number} Value read
 */
Reader.prototype.sint32 = function read_sint32() {
    var value = this.uint32();
    return value >>> 1 ^ -(value & 1) | 0;
};

/* eslint-disable no-invalid-this */

function readLongVarint() {
    // tends to deopt with local vars for octet etc.
    var bits = new LongBits(0, 0);
    var i = 0;
    if (this.len - this.pos > 4) { // fast route (lo)
        for (; i < 4; ++i) {
            // 1st..4th
            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
        // 5th
        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >>  4) >>> 0;
        if (this.buf[this.pos++] < 128)
            return bits;
        i = 0;
    } else {
        for (; i < 3; ++i) {
            /* istanbul ignore if */
            if (this.pos >= this.len)
                throw indexOutOfRange(this);
            // 1st..3th
            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
        // 4th
        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;
        return bits;
    }
    if (this.len - this.pos > 4) { // fast route (hi)
        for (; i < 5; ++i) {
            // 6th..10th
            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
    } else {
        for (; i < 5; ++i) {
            /* istanbul ignore if */
            if (this.pos >= this.len)
                throw indexOutOfRange(this);
            // 6th..10th
            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
    }
    /* istanbul ignore next */
    throw Error("invalid varint encoding");
}

/* eslint-enable no-invalid-this */

/**
 * Reads a varint as a signed 64 bit value.
 * @name Reader#int64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a varint as an unsigned 64 bit value.
 * @name Reader#uint64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a zig-zag encoded varint as a signed 64 bit value.
 * @name Reader#sint64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a varint as a boolean.
 * @returns {boolean} Value read
 */
Reader.prototype.bool = function read_bool() {
    return this.uint32() !== 0;
};

function readFixed32_end(buf, end) { // note that this uses `end`, not `pos`
    return (buf[end - 4]
          | buf[end - 3] << 8
          | buf[end - 2] << 16
          | buf[end - 1] << 24) >>> 0;
}

/**
 * Reads fixed 32 bits as an unsigned 32 bit integer.
 * @returns {number} Value read
 */
Reader.prototype.fixed32 = function read_fixed32() {

    /* istanbul ignore if */
    if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);

    return readFixed32_end(this.buf, this.pos += 4);
};

/**
 * Reads fixed 32 bits as a signed 32 bit integer.
 * @returns {number} Value read
 */
Reader.prototype.sfixed32 = function read_sfixed32() {

    /* istanbul ignore if */
    if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);

    return readFixed32_end(this.buf, this.pos += 4) | 0;
};

/* eslint-disable no-invalid-this */

function readFixed64(/* this: Reader */) {

    /* istanbul ignore if */
    if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 8);

    return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
}

/* eslint-enable no-invalid-this */

/**
 * Reads fixed 64 bits.
 * @name Reader#fixed64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads zig-zag encoded fixed 64 bits.
 * @name Reader#sfixed64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a float (32 bit) as a number.
 * @function
 * @returns {number} Value read
 */
Reader.prototype.float = function read_float() {

    /* istanbul ignore if */
    if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);

    var value = util.float.readFloatLE(this.buf, this.pos);
    this.pos += 4;
    return value;
};

/**
 * Reads a double (64 bit float) as a number.
 * @function
 * @returns {number} Value read
 */
Reader.prototype.double = function read_double() {

    /* istanbul ignore if */
    if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 4);

    var value = util.float.readDoubleLE(this.buf, this.pos);
    this.pos += 8;
    return value;
};

/**
 * Reads a sequence of bytes preceeded by its length as a varint.
 * @returns {Uint8Array} Value read
 */
Reader.prototype.bytes = function read_bytes() {
    var length = this.uint32(),
        start  = this.pos,
        end    = this.pos + length;

    /* istanbul ignore if */
    if (end > this.len)
        throw indexOutOfRange(this, length);

    this.pos += length;
    if (Array.isArray(this.buf)) // plain array
        return this.buf.slice(start, end);
    return start === end // fix for IE 10/Win8 and others' subarray returning array of size 1
        ? new this.buf.constructor(0)
        : this._slice.call(this.buf, start, end);
};

/**
 * Reads a string preceeded by its byte length as a varint.
 * @returns {string} Value read
 */
Reader.prototype.string = function read_string() {
    var bytes = this.bytes();
    return utf8.read(bytes, 0, bytes.length);
};

/**
 * Skips the specified number of bytes if specified, otherwise skips a varint.
 * @param {number} [length] Length if known, otherwise a varint is assumed
 * @returns {Reader} `this`
 */
Reader.prototype.skip = function skip(length) {
    if (typeof length === "number") {
        /* istanbul ignore if */
        if (this.pos + length > this.len)
            throw indexOutOfRange(this, length);
        this.pos += length;
    } else {
        do {
            /* istanbul ignore if */
            if (this.pos >= this.len)
                throw indexOutOfRange(this);
        } while (this.buf[this.pos++] & 128);
    }
    return this;
};

/**
 * Skips the next element of the specified wire type.
 * @param {number} wireType Wire type received
 * @returns {Reader} `this`
 */
Reader.prototype.skipType = function(wireType) {
    switch (wireType) {
        case 0:
            this.skip();
            break;
        case 1:
            this.skip(8);
            break;
        case 2:
            this.skip(this.uint32());
            break;
        case 3:
            do { // eslint-disable-line no-constant-condition
                if ((wireType = this.uint32() & 7) === 4)
                    break;
                this.skipType(wireType);
            } while (true);
            break;
        case 5:
            this.skip(4);
            break;

        /* istanbul ignore next */
        default:
            throw Error("invalid wire type " + wireType + " at offset " + this.pos);
    }
    return this;
};

Reader._configure = function(BufferReader_) {
    BufferReader = BufferReader_;

    var fn = util.Long ? "toLong" : /* istanbul ignore next */ "toNumber";
    util.merge(Reader.prototype, {

        int64: function read_int64() {
            return readLongVarint.call(this)[fn](false);
        },

        uint64: function read_uint64() {
            return readLongVarint.call(this)[fn](true);
        },

        sint64: function read_sint64() {
            return readLongVarint.call(this).zzDecode()[fn](false);
        },

        fixed64: function read_fixed64() {
            return readFixed64.call(this)[fn](true);
        },

        sfixed64: function read_sfixed64() {
            return readFixed64.call(this)[fn](false);
        }

    });
};

},{"39":39}],28:[function(require,module,exports){
"use strict";
module.exports = BufferReader;

// extends Reader
var Reader = require(27);
(BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;

var util = require(39);

/**
 * Constructs a new buffer reader instance.
 * @classdesc Wire format reader using node buffers.
 * @extends Reader
 * @constructor
 * @param {Buffer} buffer Buffer to read from
 */
function BufferReader(buffer) {
    Reader.call(this, buffer);

    /**
     * Read buffer.
     * @name BufferReader#buf
     * @type {Buffer}
     */
}

/* istanbul ignore else */
if (util.Buffer)
    BufferReader.prototype._slice = util.Buffer.prototype.slice;

/**
 * @override
 */
BufferReader.prototype.string = function read_string_buffer() {
    var len = this.uint32(); // modifies pos
    return this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len));
};

/**
 * Reads a sequence of bytes preceeded by its length as a varint.
 * @name BufferReader#bytes
 * @function
 * @returns {Buffer} Value read
 */

},{"27":27,"39":39}],29:[function(require,module,exports){
"use strict";
module.exports = Root;

// extends Namespace
var Namespace = require(23);
((Root.prototype = Object.create(Namespace.prototype)).constructor = Root).className = "Root";

var Field   = require(16),
    Enum    = require(15),
    OneOf   = require(25),
    util    = require(37);

var Type,   // cyclic
    parse,  // might be excluded
    common; // "

/**
 * Constructs a new root namespace instance.
 * @classdesc Root namespace wrapping all types, enums, services, sub-namespaces etc. that belong together.
 * @extends NamespaceBase
 * @constructor
 * @param {Object.<string,*>} [options] Top level options
 */
function Root(options) {
    Namespace.call(this, "", options);

    /**
     * Deferred extension fields.
     * @type {Field[]}
     */
    this.deferred = [];

    /**
     * Resolved file names of loaded files.
     * @type {string[]}
     */
    this.files = [];
}

/**
 * Loads a namespace descriptor into a root namespace.
 * @param {INamespace} json Nameespace descriptor
 * @param {Root} [root] Root namespace, defaults to create a new one if omitted
 * @returns {Root} Root namespace
 */
Root.fromJSON = function fromJSON(json, root) {
    if (!root)
        root = new Root();
    if (json.options)
        root.setOptions(json.options);
    return root.addJSON(json.nested);
};

/**
 * Resolves the path of an imported file, relative to the importing origin.
 * This method exists so you can override it with your own logic in case your imports are scattered over multiple directories.
 * @function
 * @param {string} origin The file name of the importing file
 * @param {string} target The file name being imported
 * @returns {string|null} Resolved path to `target` or `null` to skip the file
 */
Root.prototype.resolvePath = util.path.resolve;

// A symbol-like function to safely signal synchronous loading
/* istanbul ignore next */
function SYNC() {} // eslint-disable-line no-empty-function

/**
 * Loads one or multiple .proto or preprocessed .json files into this root namespace and calls the callback.
 * @param {string|string[]} filename Names of one or multiple files to load
 * @param {IParseOptions} options Parse options
 * @param {LoadCallback} callback Callback function
 * @returns {undefined}
 */
Root.prototype.load = function load(filename, options, callback) {
    if (typeof options === "function") {
        callback = options;
        options = undefined;
    }
    var self = this;
    if (!callback)
        return util.asPromise(load, self, filename, options);

    var sync = callback === SYNC; // undocumented

    // Finishes loading by calling the callback (exactly once)
    function finish(err, root) {
        /* istanbul ignore if */
        if (!callback)
            return;
        var cb = callback;
        callback = null;
        if (sync)
            throw err;
        cb(err, root);
    }

    // Processes a single file
    function process(filename, source) {
        try {
            if (util.isString(source) && source.charAt(0) === "{")
                source = JSON.parse(source);
            if (!util.isString(source))
                self.setOptions(source.options).addJSON(source.nested);
            else {
                parse.filename = filename;
                var parsed = parse(source, self, options),
                    resolved,
                    i = 0;
                if (parsed.imports)
                    for (; i < parsed.imports.length; ++i)
                        if (resolved = self.resolvePath(filename, parsed.imports[i]))
                            fetch(resolved);
                if (parsed.weakImports)
                    for (i = 0; i < parsed.weakImports.length; ++i)
                        if (resolved = self.resolvePath(filename, parsed.weakImports[i]))
                            fetch(resolved, true);
            }
        } catch (err) {
            finish(err);
        }
        if (!sync && !queued)
            finish(null, self); // only once anyway
    }

    // Fetches a single file
    function fetch(filename, weak) {

        // Strip path if this file references a bundled definition
        var idx = filename.lastIndexOf("google/protobuf/");
        if (idx > -1) {
            var altname = filename.substring(idx);
            if (altname in common)
                filename = altname;
        }

        // Skip if already loaded / attempted
        if (self.files.indexOf(filename) > -1)
            return;
        self.files.push(filename);

        // Shortcut bundled definitions
        if (filename in common) {
            if (sync)
                process(filename, common[filename]);
            else {
                ++queued;
                setTimeout(function() {
                    --queued;
                    process(filename, common[filename]);
                });
            }
            return;
        }

        // Otherwise fetch from disk or network
        if (sync) {
            var source;
            try {
                source = util.fs.readFileSync(filename).toString("utf8");
            } catch (err) {
                if (!weak)
                    finish(err);
                return;
            }
            process(filename, source);
        } else {
            ++queued;
            util.fetch(filename, function(err, source) {
                --queued;
                /* istanbul ignore if */
                if (!callback)
                    return; // terminated meanwhile
                if (err) {
                    /* istanbul ignore else */
                    if (!weak)
                        finish(err);
                    else if (!queued) // can't be covered reliably
                        finish(null, self);
                    return;
                }
                process(filename, source);
            });
        }
    }
    var queued = 0;

    // Assembling the root namespace doesn't require working type
    // references anymore, so we can load everything in parallel
    if (util.isString(filename))
        filename = [ filename ];
    for (var i = 0, resolved; i < filename.length; ++i)
        if (resolved = self.resolvePath("", filename[i]))
            fetch(resolved);

    if (sync)
        return self;
    if (!queued)
        finish(null, self);
    return undefined;
};
// function load(filename:string, options:IParseOptions, callback:LoadCallback):undefined

/**
 * Loads one or multiple .proto or preprocessed .json files into this root namespace and calls the callback.
 * @function Root#load
 * @param {string|string[]} filename Names of one or multiple files to load
 * @param {LoadCallback} callback Callback function
 * @returns {undefined}
 * @variation 2
 */
// function load(filename:string, callback:LoadCallback):undefined

/**
 * Loads one or multiple .proto or preprocessed .json files into this root namespace and returns a promise.
 * @function Root#load
 * @param {string|string[]} filename Names of one or multiple files to load
 * @param {IParseOptions} [options] Parse options. Defaults to {@link parse.defaults} when omitted.
 * @returns {Promise<Root>} Promise
 * @variation 3
 */
// function load(filename:string, [options:IParseOptions]):Promise<Root>

/**
 * Synchronously loads one or multiple .proto or preprocessed .json files into this root namespace (node only).
 * @function Root#loadSync
 * @param {string|string[]} filename Names of one or multiple files to load
 * @param {IParseOptions} [options] Parse options. Defaults to {@link parse.defaults} when omitted.
 * @returns {Root} Root namespace
 * @throws {Error} If synchronous fetching is not supported (i.e. in browsers) or if a file's syntax is invalid
 */
Root.prototype.loadSync = function loadSync(filename, options) {
    if (!util.isNode)
        throw Error("not supported");
    return this.load(filename, options, SYNC);
};

/**
 * @override
 */
Root.prototype.resolveAll = function resolveAll() {
    if (this.deferred.length)
        throw Error("unresolvable extensions: " + this.deferred.map(function(field) {
            return "'extend " + field.extend + "' in " + field.parent.fullName;
        }).join(", "));
    return Namespace.prototype.resolveAll.call(this);
};

// only uppercased (and thus conflict-free) children are exposed, see below
var exposeRe = /^[A-Z]/;

/**
 * Handles a deferred declaring extension field by creating a sister field to represent it within its extended type.
 * @param {Root} root Root instance
 * @param {Field} field Declaring extension field witin the declaring type
 * @returns {boolean} `true` if successfully added to the extended type, `false` otherwise
 * @inner
 * @ignore
 */
function tryHandleExtension(root, field) {
    var extendedType = field.parent.lookup(field.extend);
    if (extendedType) {
        var sisterField = new Field(field.fullName, field.id, field.type, field.rule, undefined, field.options);
        sisterField.declaringField = field;
        field.extensionField = sisterField;
        extendedType.add(sisterField);
        return true;
    }
    return false;
}

/**
 * Called when any object is added to this root or its sub-namespaces.
 * @param {ReflectionObject} object Object added
 * @returns {undefined}
 * @private
 */
Root.prototype._handleAdd = function _handleAdd(object) {
    if (object instanceof Field) {

        if (/* an extension field (implies not part of a oneof) */ object.extend !== undefined && /* not already handled */ !object.extensionField)
            if (!tryHandleExtension(this, object))
                this.deferred.push(object);

    } else if (object instanceof Enum) {

        if (exposeRe.test(object.name))
            object.parent[object.name] = object.values; // expose enum values as property of its parent

    } else if (!(object instanceof OneOf)) /* everything else is a namespace */ {

        if (object instanceof Type) // Try to handle any deferred extensions
            for (var i = 0; i < this.deferred.length;)
                if (tryHandleExtension(this, this.deferred[i]))
                    this.deferred.splice(i, 1);
                else
                    ++i;
        for (var j = 0; j < /* initializes */ object.nestedArray.length; ++j) // recurse into the namespace
            this._handleAdd(object._nestedArray[j]);
        if (exposeRe.test(object.name))
            object.parent[object.name] = object; // expose namespace as property of its parent
    }

    // The above also adds uppercased (and thus conflict-free) nested types, services and enums as
    // properties of namespaces just like static code does. This allows using a .d.ts generated for
    // a static module with reflection-based solutions where the condition is met.
};

/**
 * Called when any object is removed from this root or its sub-namespaces.
 * @param {ReflectionObject} object Object removed
 * @returns {undefined}
 * @private
 */
Root.prototype._handleRemove = function _handleRemove(object) {
    if (object instanceof Field) {

        if (/* an extension field */ object.extend !== undefined) {
            if (/* already handled */ object.extensionField) { // remove its sister field
                object.extensionField.parent.remove(object.extensionField);
                object.extensionField = null;
            } else { // cancel the extension
                var index = this.deferred.indexOf(object);
                /* istanbul ignore else */
                if (index > -1)
                    this.deferred.splice(index, 1);
            }
        }

    } else if (object instanceof Enum) {

        if (exposeRe.test(object.name))
            delete object.parent[object.name]; // unexpose enum values

    } else if (object instanceof Namespace) {

        for (var i = 0; i < /* initializes */ object.nestedArray.length; ++i) // recurse into the namespace
            this._handleRemove(object._nestedArray[i]);

        if (exposeRe.test(object.name))
            delete object.parent[object.name]; // unexpose namespaces

    }
};

Root._configure = function(Type_, parse_, common_) {
    Type = Type_;
    parse = parse_;
    common = common_;
};

},{"15":15,"16":16,"23":23,"25":25,"37":37}],30:[function(require,module,exports){
"use strict";
module.exports = {};

/**
 * Named roots.
 * This is where pbjs stores generated structures (the option `-r, --root` specifies a name).
 * Can also be used manually to make roots available accross modules.
 * @name roots
 * @type {Object.<string,Root>}
 * @example
 * // pbjs -r myroot -o compiled.js ...
 *
 * // in another module:
 * require("./compiled.js");
 *
 * // in any subsequent module:
 * var root = protobuf.roots["myroot"];
 */

},{}],31:[function(require,module,exports){
"use strict";

/**
 * Streaming RPC helpers.
 * @namespace
 */
var rpc = exports;

/**
 * RPC implementation passed to {@link Service#create} performing a service request on network level, i.e. by utilizing http requests or websockets.
 * @typedef RPCImpl
 * @type {function}
 * @param {Method|rpc.ServiceMethod<Message<{}>,Message<{}>>} method Reflected or static method being called
 * @param {Uint8Array} requestData Request data
 * @param {RPCImplCallback} callback Callback function
 * @returns {undefined}
 * @example
 * function rpcImpl(method, requestData, callback) {
 *     if (protobuf.util.lcFirst(method.name) !== "myMethod") // compatible with static code
 *         throw Error("no such method");
 *     asynchronouslyObtainAResponse(requestData, function(err, responseData) {
 *         callback(err, responseData);
 *     });
 * }
 */

/**
 * Node-style callback as used by {@link RPCImpl}.
 * @typedef RPCImplCallback
 * @type {function}
 * @param {Error|null} error Error, if any, otherwise `null`
 * @param {Uint8Array|null} [response] Response data or `null` to signal end of stream, if there hasn't been an error
 * @returns {undefined}
 */

rpc.Service = require(32);

},{"32":32}],32:[function(require,module,exports){
"use strict";
module.exports = Service;

var util = require(39);

// Extends EventEmitter
(Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;

/**
 * A service method callback as used by {@link rpc.ServiceMethod|ServiceMethod}.
 *
 * Differs from {@link RPCImplCallback} in that it is an actual callback of a service method which may not return `response = null`.
 * @typedef rpc.ServiceMethodCallback
 * @template TRes extends Message<TRes>
 * @type {function}
 * @param {Error|null} error Error, if any
 * @param {TRes} [response] Response message
 * @returns {undefined}
 */

/**
 * A service method part of a {@link rpc.Service} as created by {@link Service.create}.
 * @typedef rpc.ServiceMethod
 * @template TReq extends Message<TReq>
 * @template TRes extends Message<TRes>
 * @type {function}
 * @param {TReq|Properties<TReq>} request Request message or plain object
 * @param {rpc.ServiceMethodCallback<TRes>} [callback] Node-style callback called with the error, if any, and the response message
 * @returns {Promise<Message<TRes>>} Promise if `callback` has been omitted, otherwise `undefined`
 */

/**
 * Constructs a new RPC service instance.
 * @classdesc An RPC service as returned by {@link Service#create}.
 * @exports rpc.Service
 * @extends util.EventEmitter
 * @constructor
 * @param {RPCImpl} rpcImpl RPC implementation
 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
 */
function Service(rpcImpl, requestDelimited, responseDelimited) {

    if (typeof rpcImpl !== "function")
        throw TypeError("rpcImpl must be a function");

    util.EventEmitter.call(this);

    /**
     * RPC implementation. Becomes `null` once the service is ended.
     * @type {RPCImpl|null}
     */
    this.rpcImpl = rpcImpl;

    /**
     * Whether requests are length-delimited.
     * @type {boolean}
     */
    this.requestDelimited = Boolean(requestDelimited);

    /**
     * Whether responses are length-delimited.
     * @type {boolean}
     */
    this.responseDelimited = Boolean(responseDelimited);
}

/**
 * Calls a service method through {@link rpc.Service#rpcImpl|rpcImpl}.
 * @param {Method|rpc.ServiceMethod<TReq,TRes>} method Reflected or static method
 * @param {Constructor<TReq>} requestCtor Request constructor
 * @param {Constructor<TRes>} responseCtor Response constructor
 * @param {TReq|Properties<TReq>} request Request message or plain object
 * @param {rpc.ServiceMethodCallback<TRes>} callback Service callback
 * @returns {undefined}
 * @template TReq extends Message<TReq>
 * @template TRes extends Message<TRes>
 */
Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {

    if (!request)
        throw TypeError("request must be specified");

    var self = this;
    if (!callback)
        return util.asPromise(rpcCall, self, method, requestCtor, responseCtor, request);

    if (!self.rpcImpl) {
        setTimeout(function() { callback(Error("already ended")); }, 0);
        return undefined;
    }

    try {
        return self.rpcImpl(
            method,
            requestCtor[self.requestDelimited ? "encodeDelimited" : "encode"](request).finish(),
            function rpcCallback(err, response) {

                if (err) {
                    self.emit("error", err, method);
                    return callback(err);
                }

                if (response === null) {
                    self.end(/* endedByRPC */ true);
                    return undefined;
                }

                if (!(response instanceof responseCtor)) {
                    try {
                        response = responseCtor[self.responseDelimited ? "decodeDelimited" : "decode"](response);
                    } catch (err) {
                        self.emit("error", err, method);
                        return callback(err);
                    }
                }

                self.emit("data", response, method);
                return callback(null, response);
            }
        );
    } catch (err) {
        self.emit("error", err, method);
        setTimeout(function() { callback(err); }, 0);
        return undefined;
    }
};

/**
 * Ends this service and emits the `end` event.
 * @param {boolean} [endedByRPC=false] Whether the service has been ended by the RPC implementation.
 * @returns {rpc.Service} `this`
 */
Service.prototype.end = function end(endedByRPC) {
    if (this.rpcImpl) {
        if (!endedByRPC) // signal end to rpcImpl
            this.rpcImpl(null, null, null);
        this.rpcImpl = null;
        this.emit("end").off();
    }
    return this;
};

},{"39":39}],33:[function(require,module,exports){
"use strict";
module.exports = Service;

// extends Namespace
var Namespace = require(23);
((Service.prototype = Object.create(Namespace.prototype)).constructor = Service).className = "Service";

var Method = require(22),
    util   = require(37),
    rpc    = require(31);

/**
 * Constructs a new service instance.
 * @classdesc Reflected service.
 * @extends NamespaceBase
 * @constructor
 * @param {string} name Service name
 * @param {Object.<string,*>} [options] Service options
 * @throws {TypeError} If arguments are invalid
 */
function Service(name, options) {
    Namespace.call(this, name, options);

    /**
     * Service methods.
     * @type {Object.<string,Method>}
     */
    this.methods = {}; // toJSON, marker

    /**
     * Cached methods as an array.
     * @type {Method[]|null}
     * @private
     */
    this._methodsArray = null;
}

/**
 * Service descriptor.
 * @interface IService
 * @extends INamespace
 * @property {Object.<string,IMethod>} methods Method descriptors
 */

/**
 * Constructs a service from a service descriptor.
 * @param {string} name Service name
 * @param {IService} json Service descriptor
 * @returns {Service} Created service
 * @throws {TypeError} If arguments are invalid
 */
Service.fromJSON = function fromJSON(name, json) {
    var service = new Service(name, json.options);
    /* istanbul ignore else */
    if (json.methods)
        for (var names = Object.keys(json.methods), i = 0; i < names.length; ++i)
            service.add(Method.fromJSON(names[i], json.methods[names[i]]));
    if (json.nested)
        service.addJSON(json.nested);
    service.comment = json.comment;
    return service;
};

/**
 * Converts this service to a service descriptor.
 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
 * @returns {IService} Service descriptor
 */
Service.prototype.toJSON = function toJSON(toJSONOptions) {
    var inherited = Namespace.prototype.toJSON.call(this, toJSONOptions);
    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
    return util.toObject([
        "options" , inherited && inherited.options || undefined,
        "methods" , Namespace.arrayToJSON(this.methodsArray, toJSONOptions) || /* istanbul ignore next */ {},
        "nested"  , inherited && inherited.nested || undefined,
        "comment" , keepComments ? this.comment : undefined
    ]);
};

/**
 * Methods of this service as an array for iteration.
 * @name Service#methodsArray
 * @type {Method[]}
 * @readonly
 */
Object.defineProperty(Service.prototype, "methodsArray", {
    get: function() {
        return this._methodsArray || (this._methodsArray = util.toArray(this.methods));
    }
});

function clearCache(service) {
    service._methodsArray = null;
    return service;
}

/**
 * @override
 */
Service.prototype.get = function get(name) {
    return this.methods[name]
        || Namespace.prototype.get.call(this, name);
};

/**
 * @override
 */
Service.prototype.resolveAll = function resolveAll() {
    var methods = this.methodsArray;
    for (var i = 0; i < methods.length; ++i)
        methods[i].resolve();
    return Namespace.prototype.resolve.call(this);
};

/**
 * @override
 */
Service.prototype.add = function add(object) {

    /* istanbul ignore if */
    if (this.get(object.name))
        throw Error("duplicate name '" + object.name + "' in " + this);

    if (object instanceof Method) {
        this.methods[object.name] = object;
        object.parent = this;
        return clearCache(this);
    }
    return Namespace.prototype.add.call(this, object);
};

/**
 * @override
 */
Service.prototype.remove = function remove(object) {
    if (object instanceof Method) {

        /* istanbul ignore if */
        if (this.methods[object.name] !== object)
            throw Error(object + " is not a member of " + this);

        delete this.methods[object.name];
        object.parent = null;
        return clearCache(this);
    }
    return Namespace.prototype.remove.call(this, object);
};

/**
 * Creates a runtime service using the specified rpc implementation.
 * @param {RPCImpl} rpcImpl RPC implementation
 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
 * @returns {rpc.Service} RPC service. Useful where requests and/or responses are streamed.
 */
Service.prototype.create = function create(rpcImpl, requestDelimited, responseDelimited) {
    var rpcService = new rpc.Service(rpcImpl, requestDelimited, responseDelimited);
    for (var i = 0, method; i < /* initializes */ this.methodsArray.length; ++i) {
        var methodName = util.lcFirst((method = this._methodsArray[i]).resolve().name).replace(/[^$\w_]/g, "");
        rpcService[methodName] = util.codegen(["r","c"], util.isReserved(methodName) ? methodName + "_" : methodName)("return this.rpcCall(m,q,s,r,c)")({
            m: method,
            q: method.resolvedRequestType.ctor,
            s: method.resolvedResponseType.ctor
        });
    }
    return rpcService;
};

},{"22":22,"23":23,"31":31,"37":37}],34:[function(require,module,exports){
"use strict";
module.exports = tokenize;

var delimRe        = /[\s{}=;:[\],'"()<>]/g,
    stringDoubleRe = /(?:"([^"\\]*(?:\\.[^"\\]*)*)")/g,
    stringSingleRe = /(?:'([^'\\]*(?:\\.[^'\\]*)*)')/g;

var setCommentRe = /^ *[*/]+ */,
    setCommentAltRe = /^\s*\*?\/*/,
    setCommentSplitRe = /\n/g,
    whitespaceRe = /\s/,
    unescapeRe = /\\(.?)/g;

var unescapeMap = {
    "0": "\0",
    "r": "\r",
    "n": "\n",
    "t": "\t"
};

/**
 * Unescapes a string.
 * @param {string} str String to unescape
 * @returns {string} Unescaped string
 * @property {Object.<string,string>} map Special characters map
 * @memberof tokenize
 */
function unescape(str) {
    return str.replace(unescapeRe, function($0, $1) {
        switch ($1) {
            case "\\":
            case "":
                return $1;
            default:
                return unescapeMap[$1] || "";
        }
    });
}

tokenize.unescape = unescape;

/**
 * Gets the next token and advances.
 * @typedef TokenizerHandleNext
 * @type {function}
 * @returns {string|null} Next token or `null` on eof
 */

/**
 * Peeks for the next token.
 * @typedef TokenizerHandlePeek
 * @type {function}
 * @returns {string|null} Next token or `null` on eof
 */

/**
 * Pushes a token back to the stack.
 * @typedef TokenizerHandlePush
 * @type {function}
 * @param {string} token Token
 * @returns {undefined}
 */

/**
 * Skips the next token.
 * @typedef TokenizerHandleSkip
 * @type {function}
 * @param {string} expected Expected token
 * @param {boolean} [optional=false] If optional
 * @returns {boolean} Whether the token matched
 * @throws {Error} If the token didn't match and is not optional
 */

/**
 * Gets the comment on the previous line or, alternatively, the line comment on the specified line.
 * @typedef TokenizerHandleCmnt
 * @type {function}
 * @param {number} [line] Line number
 * @returns {string|null} Comment text or `null` if none
 */

/**
 * Handle object returned from {@link tokenize}.
 * @interface ITokenizerHandle
 * @property {TokenizerHandleNext} next Gets the next token and advances (`null` on eof)
 * @property {TokenizerHandlePeek} peek Peeks for the next token (`null` on eof)
 * @property {TokenizerHandlePush} push Pushes a token back to the stack
 * @property {TokenizerHandleSkip} skip Skips a token, returns its presence and advances or, if non-optional and not present, throws
 * @property {TokenizerHandleCmnt} cmnt Gets the comment on the previous line or the line comment on the specified line, if any
 * @property {number} line Current line number
 */

/**
 * Tokenizes the given .proto source and returns an object with useful utility functions.
 * @param {string} source Source contents
 * @param {boolean} alternateCommentMode Whether we should activate alternate comment parsing mode.
 * @returns {ITokenizerHandle} Tokenizer handle
 */
function tokenize(source, alternateCommentMode) {
    /* eslint-disable callback-return */
    source = source.toString();

    var offset = 0,
        length = source.length,
        line = 1,
        commentType = null,
        commentText = null,
        commentLine = 0,
        commentLineEmpty = false;

    var stack = [];

    var stringDelim = null;

    /* istanbul ignore next */
    /**
     * Creates an error for illegal syntax.
     * @param {string} subject Subject
     * @returns {Error} Error created
     * @inner
     */
    function illegal(subject) {
        return Error("illegal " + subject + " (line " + line + ")");
    }

    /**
     * Reads a string till its end.
     * @returns {string} String read
     * @inner
     */
    function readString() {
        var re = stringDelim === "'" ? stringSingleRe : stringDoubleRe;
        re.lastIndex = offset - 1;
        var match = re.exec(source);
        if (!match)
            throw illegal("string");
        offset = re.lastIndex;
        push(stringDelim);
        stringDelim = null;
        return unescape(match[1]);
    }

    /**
     * Gets the character at `pos` within the source.
     * @param {number} pos Position
     * @returns {string} Character
     * @inner
     */
    function charAt(pos) {
        return source.charAt(pos);
    }

    /**
     * Sets the current comment text.
     * @param {number} start Start offset
     * @param {number} end End offset
     * @returns {undefined}
     * @inner
     */
    function setComment(start, end) {
        commentType = source.charAt(start++);
        commentLine = line;
        commentLineEmpty = false;
        var lookback;
        if (alternateCommentMode) {
            lookback = 2;  // alternate comment parsing: "//" or "/*"
        } else {
            lookback = 3;  // "///" or "/**"
        }
        var commentOffset = start - lookback,
            c;
        do {
            if (--commentOffset < 0 ||
                    (c = source.charAt(commentOffset)) === "\n") {
                commentLineEmpty = true;
                break;
            }
        } while (c === " " || c === "\t");
        var lines = source
            .substring(start, end)
            .split(setCommentSplitRe);
        for (var i = 0; i < lines.length; ++i)
            lines[i] = lines[i]
                .replace(alternateCommentMode ? setCommentAltRe : setCommentRe, "")
                .trim();
        commentText = lines
            .join("\n")
            .trim();
    }

    function isDoubleSlashCommentLine(startOffset) {
        var endOffset = findEndOfLine(startOffset);

        // see if remaining line matches comment pattern
        var lineText = source.substring(startOffset, endOffset);
        // look for 1 or 2 slashes since startOffset would already point past
        // the first slash that started the comment.
        var isComment = /^\s*\/{1,2}/.test(lineText);
        return isComment;
    }

    function findEndOfLine(cursor) {
        // find end of cursor's line
        var endOffset = cursor;
        while (endOffset < length && charAt(endOffset) !== "\n") {
            endOffset++;
        }
        return endOffset;
    }

    /**
     * Obtains the next token.
     * @returns {string|null} Next token or `null` on eof
     * @inner
     */
    function next() {
        if (stack.length > 0)
            return stack.shift();
        if (stringDelim)
            return readString();
        var repeat,
            prev,
            curr,
            start,
            isDoc;
        do {
            if (offset === length)
                return null;
            repeat = false;
            while (whitespaceRe.test(curr = charAt(offset))) {
                if (curr === "\n")
                    ++line;
                if (++offset === length)
                    return null;
            }

            if (charAt(offset) === "/") {
                if (++offset === length) {
                    throw illegal("comment");
                }
                if (charAt(offset) === "/") { // Line
                    if (!alternateCommentMode) {
                        // check for triple-slash comment
                        isDoc = charAt(start = offset + 1) === "/";

                        while (charAt(++offset) !== "\n") {
                            if (offset === length) {
                                return null;
                            }
                        }
                        ++offset;
                        if (isDoc) {
                            setComment(start, offset - 1);
                        }
                        ++line;
                        repeat = true;
                    } else {
                        // check for double-slash comments, consolidating consecutive lines
                        start = offset;
                        isDoc = false;
                        if (isDoubleSlashCommentLine(offset)) {
                            isDoc = true;
                            do {
                                offset = findEndOfLine(offset);
                                if (offset === length) {
                                    break;
                                }
                                offset++;
                            } while (isDoubleSlashCommentLine(offset));
                        } else {
                            offset = Math.min(length, findEndOfLine(offset) + 1);
                        }
                        if (isDoc) {
                            setComment(start, offset);
                        }
                        line++;
                        repeat = true;
                    }
                } else if ((curr = charAt(offset)) === "*") { /* Block */
                    // check for /** (regular comment mode) or /* (alternate comment mode)
                    start = offset + 1;
                    isDoc = alternateCommentMode || charAt(start) === "*";
                    do {
                        if (curr === "\n") {
                            ++line;
                        }
                        if (++offset === length) {
                            throw illegal("comment");
                        }
                        prev = curr;
                        curr = charAt(offset);
                    } while (prev !== "*" || curr !== "/");
                    ++offset;
                    if (isDoc) {
                        setComment(start, offset - 2);
                    }
                    repeat = true;
                } else {
                    return "/";
                }
            }
        } while (repeat);

        // offset !== length if we got here

        var end = offset;
        delimRe.lastIndex = 0;
        var delim = delimRe.test(charAt(end++));
        if (!delim)
            while (end < length && !delimRe.test(charAt(end)))
                ++end;
        var token = source.substring(offset, offset = end);
        if (token === "\"" || token === "'")
            stringDelim = token;
        return token;
    }

    /**
     * Pushes a token back to the stack.
     * @param {string} token Token
     * @returns {undefined}
     * @inner
     */
    function push(token) {
        stack.push(token);
    }

    /**
     * Peeks for the next token.
     * @returns {string|null} Token or `null` on eof
     * @inner
     */
    function peek() {
        if (!stack.length) {
            var token = next();
            if (token === null)
                return null;
            push(token);
        }
        return stack[0];
    }

    /**
     * Skips a token.
     * @param {string} expected Expected token
     * @param {boolean} [optional=false] Whether the token is optional
     * @returns {boolean} `true` when skipped, `false` if not
     * @throws {Error} When a required token is not present
     * @inner
     */
    function skip(expected, optional) {
        var actual = peek(),
            equals = actual === expected;
        if (equals) {
            next();
            return true;
        }
        if (!optional)
            throw illegal("token '" + actual + "', '" + expected + "' expected");
        return false;
    }

    /**
     * Gets a comment.
     * @param {number} [trailingLine] Line number if looking for a trailing comment
     * @returns {string|null} Comment text
     * @inner
     */
    function cmnt(trailingLine) {
        var ret = null;
        if (trailingLine === undefined) {
            if (commentLine === line - 1 && (alternateCommentMode || commentType === "*" || commentLineEmpty)) {
                ret = commentText;
            }
        } else {
            /* istanbul ignore else */
            if (commentLine < trailingLine) {
                peek();
            }
            if (commentLine === trailingLine && !commentLineEmpty && (alternateCommentMode || commentType === "/")) {
                ret = commentText;
            }
        }
        return ret;
    }

    return Object.defineProperty({
        next: next,
        peek: peek,
        push: push,
        skip: skip,
        cmnt: cmnt
    }, "line", {
        get: function() { return line; }
    });
    /* eslint-enable callback-return */
}

},{}],35:[function(require,module,exports){
"use strict";
module.exports = Type;

// extends Namespace
var Namespace = require(23);
((Type.prototype = Object.create(Namespace.prototype)).constructor = Type).className = "Type";

var Enum      = require(15),
    OneOf     = require(25),
    Field     = require(16),
    MapField  = require(20),
    Service   = require(33),
    Message   = require(21),
    Reader    = require(27),
    Writer    = require(42),
    util      = require(37),
    encoder   = require(14),
    decoder   = require(13),
    verifier  = require(40),
    converter = require(12),
    wrappers  = require(41);

/**
 * Constructs a new reflected message type instance.
 * @classdesc Reflected message type.
 * @extends NamespaceBase
 * @constructor
 * @param {string} name Message name
 * @param {Object.<string,*>} [options] Declared options
 */
function Type(name, options) {
    Namespace.call(this, name, options);

    /**
     * Message fields.
     * @type {Object.<string,Field>}
     */
    this.fields = {};  // toJSON, marker

    /**
     * Oneofs declared within this namespace, if any.
     * @type {Object.<string,OneOf>}
     */
    this.oneofs = undefined; // toJSON

    /**
     * Extension ranges, if any.
     * @type {number[][]}
     */
    this.extensions = undefined; // toJSON

    /**
     * Reserved ranges, if any.
     * @type {Array.<number[]|string>}
     */
    this.reserved = undefined; // toJSON

    /*?
     * Whether this type is a legacy group.
     * @type {boolean|undefined}
     */
    this.group = undefined; // toJSON

    /**
     * Cached fields by id.
     * @type {Object.<number,Field>|null}
     * @private
     */
    this._fieldsById = null;

    /**
     * Cached fields as an array.
     * @type {Field[]|null}
     * @private
     */
    this._fieldsArray = null;

    /**
     * Cached oneofs as an array.
     * @type {OneOf[]|null}
     * @private
     */
    this._oneofsArray = null;

    /**
     * Cached constructor.
     * @type {Constructor<{}>}
     * @private
     */
    this._ctor = null;
}

Object.defineProperties(Type.prototype, {

    /**
     * Message fields by id.
     * @name Type#fieldsById
     * @type {Object.<number,Field>}
     * @readonly
     */
    fieldsById: {
        get: function() {

            /* istanbul ignore if */
            if (this._fieldsById)
                return this._fieldsById;

            this._fieldsById = {};
            for (var names = Object.keys(this.fields), i = 0; i < names.length; ++i) {
                var field = this.fields[names[i]],
                    id = field.id;

                /* istanbul ignore if */
                if (this._fieldsById[id])
                    throw Error("duplicate id " + id + " in " + this);

                this._fieldsById[id] = field;
            }
            return this._fieldsById;
        }
    },

    /**
     * Fields of this message as an array for iteration.
     * @name Type#fieldsArray
     * @type {Field[]}
     * @readonly
     */
    fieldsArray: {
        get: function() {
            return this._fieldsArray || (this._fieldsArray = util.toArray(this.fields));
        }
    },

    /**
     * Oneofs of this message as an array for iteration.
     * @name Type#oneofsArray
     * @type {OneOf[]}
     * @readonly
     */
    oneofsArray: {
        get: function() {
            return this._oneofsArray || (this._oneofsArray = util.toArray(this.oneofs));
        }
    },

    /**
     * The registered constructor, if any registered, otherwise a generic constructor.
     * Assigning a function replaces the internal constructor. If the function does not extend {@link Message} yet, its prototype will be setup accordingly and static methods will be populated. If it already extends {@link Message}, it will just replace the internal constructor.
     * @name Type#ctor
     * @type {Constructor<{}>}
     */
    ctor: {
        get: function() {
            return this._ctor || (this.ctor = Type.generateConstructor(this)());
        },
        set: function(ctor) {

            // Ensure proper prototype
            var prototype = ctor.prototype;
            if (!(prototype instanceof Message)) {
                (ctor.prototype = new Message()).constructor = ctor;
                util.merge(ctor.prototype, prototype);
            }

            // Classes and messages reference their reflected type
            ctor.$type = ctor.prototype.$type = this;

            // Mix in static methods
            util.merge(ctor, Message, true);

            this._ctor = ctor;

            // Messages have non-enumerable default values on their prototype
            var i = 0;
            for (; i < /* initializes */ this.fieldsArray.length; ++i)
                this._fieldsArray[i].resolve(); // ensures a proper value

            // Messages have non-enumerable getters and setters for each virtual oneof field
            var ctorProperties = {};
            for (i = 0; i < /* initializes */ this.oneofsArray.length; ++i)
                ctorProperties[this._oneofsArray[i].resolve().name] = {
                    get: util.oneOfGetter(this._oneofsArray[i].oneof),
                    set: util.oneOfSetter(this._oneofsArray[i].oneof)
                };
            if (i)
                Object.defineProperties(ctor.prototype, ctorProperties);
        }
    }
});

/**
 * Generates a constructor function for the specified type.
 * @param {Type} mtype Message type
 * @returns {Codegen} Codegen instance
 */
Type.generateConstructor = function generateConstructor(mtype) {
    /* eslint-disable no-unexpected-multiline */
    var gen = util.codegen(["p"], mtype.name);
    // explicitly initialize mutable object/array fields so that these aren't just inherited from the prototype
    for (var i = 0, field; i < mtype.fieldsArray.length; ++i)
        if ((field = mtype._fieldsArray[i]).map) gen
            ("this%s={}", util.safeProp(field.name));
        else if (field.repeated) gen
            ("this%s=[]", util.safeProp(field.name));
    return gen
    ("if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)") // omit undefined or null
        ("this[ks[i]]=p[ks[i]]");
    /* eslint-enable no-unexpected-multiline */
};

function clearCache(type) {
    type._fieldsById = type._fieldsArray = type._oneofsArray = null;
    delete type.encode;
    delete type.decode;
    delete type.verify;
    return type;
}

/**
 * Message type descriptor.
 * @interface IType
 * @extends INamespace
 * @property {Object.<string,IOneOf>} [oneofs] Oneof descriptors
 * @property {Object.<string,IField>} fields Field descriptors
 * @property {number[][]} [extensions] Extension ranges
 * @property {number[][]} [reserved] Reserved ranges
 * @property {boolean} [group=false] Whether a legacy group or not
 */

/**
 * Creates a message type from a message type descriptor.
 * @param {string} name Message name
 * @param {IType} json Message type descriptor
 * @returns {Type} Created message type
 */
Type.fromJSON = function fromJSON(name, json) {
    var type = new Type(name, json.options);
    type.extensions = json.extensions;
    type.reserved = json.reserved;
    var names = Object.keys(json.fields),
        i = 0;
    for (; i < names.length; ++i)
        type.add(
            ( typeof json.fields[names[i]].keyType !== "undefined"
            ? MapField.fromJSON
            : Field.fromJSON )(names[i], json.fields[names[i]])
        );
    if (json.oneofs)
        for (names = Object.keys(json.oneofs), i = 0; i < names.length; ++i)
            type.add(OneOf.fromJSON(names[i], json.oneofs[names[i]]));
    if (json.nested)
        for (names = Object.keys(json.nested), i = 0; i < names.length; ++i) {
            var nested = json.nested[names[i]];
            type.add( // most to least likely
                ( nested.id !== undefined
                ? Field.fromJSON
                : nested.fields !== undefined
                ? Type.fromJSON
                : nested.values !== undefined
                ? Enum.fromJSON
                : nested.methods !== undefined
                ? Service.fromJSON
                : Namespace.fromJSON )(names[i], nested)
            );
        }
    if (json.extensions && json.extensions.length)
        type.extensions = json.extensions;
    if (json.reserved && json.reserved.length)
        type.reserved = json.reserved;
    if (json.group)
        type.group = true;
    if (json.comment)
        type.comment = json.comment;
    return type;
};

/**
 * Converts this message type to a message type descriptor.
 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
 * @returns {IType} Message type descriptor
 */
Type.prototype.toJSON = function toJSON(toJSONOptions) {
    var inherited = Namespace.prototype.toJSON.call(this, toJSONOptions);
    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
    return util.toObject([
        "options"    , inherited && inherited.options || undefined,
        "oneofs"     , Namespace.arrayToJSON(this.oneofsArray, toJSONOptions),
        "fields"     , Namespace.arrayToJSON(this.fieldsArray.filter(function(obj) { return !obj.declaringField; }), toJSONOptions) || {},
        "extensions" , this.extensions && this.extensions.length ? this.extensions : undefined,
        "reserved"   , this.reserved && this.reserved.length ? this.reserved : undefined,
        "group"      , this.group || undefined,
        "nested"     , inherited && inherited.nested || undefined,
        "comment"    , keepComments ? this.comment : undefined
    ]);
};

/**
 * @override
 */
Type.prototype.resolveAll = function resolveAll() {
    var fields = this.fieldsArray, i = 0;
    while (i < fields.length)
        fields[i++].resolve();
    var oneofs = this.oneofsArray; i = 0;
    while (i < oneofs.length)
        oneofs[i++].resolve();
    return Namespace.prototype.resolveAll.call(this);
};

/**
 * @override
 */
Type.prototype.get = function get(name) {
    return this.fields[name]
        || this.oneofs && this.oneofs[name]
        || this.nested && this.nested[name]
        || null;
};

/**
 * Adds a nested object to this type.
 * @param {ReflectionObject} object Nested object to add
 * @returns {Type} `this`
 * @throws {TypeError} If arguments are invalid
 * @throws {Error} If there is already a nested object with this name or, if a field, when there is already a field with this id
 */
Type.prototype.add = function add(object) {

    if (this.get(object.name))
        throw Error("duplicate name '" + object.name + "' in " + this);

    if (object instanceof Field && object.extend === undefined) {
        // NOTE: Extension fields aren't actual fields on the declaring type, but nested objects.
        // The root object takes care of adding distinct sister-fields to the respective extended
        // type instead.

        // avoids calling the getter if not absolutely necessary because it's called quite frequently
        if (this._fieldsById ? /* istanbul ignore next */ this._fieldsById[object.id] : this.fieldsById[object.id])
            throw Error("duplicate id " + object.id + " in " + this);
        if (this.isReservedId(object.id))
            throw Error("id " + object.id + " is reserved in " + this);
        if (this.isReservedName(object.name))
            throw Error("name '" + object.name + "' is reserved in " + this);

        if (object.parent)
            object.parent.remove(object);
        this.fields[object.name] = object;
        object.message = this;
        object.onAdd(this);
        return clearCache(this);
    }
    if (object instanceof OneOf) {
        if (!this.oneofs)
            this.oneofs = {};
        this.oneofs[object.name] = object;
        object.onAdd(this);
        return clearCache(this);
    }
    return Namespace.prototype.add.call(this, object);
};

/**
 * Removes a nested object from this type.
 * @param {ReflectionObject} object Nested object to remove
 * @returns {Type} `this`
 * @throws {TypeError} If arguments are invalid
 * @throws {Error} If `object` is not a member of this type
 */
Type.prototype.remove = function remove(object) {
    if (object instanceof Field && object.extend === undefined) {
        // See Type#add for the reason why extension fields are excluded here.

        /* istanbul ignore if */
        if (!this.fields || this.fields[object.name] !== object)
            throw Error(object + " is not a member of " + this);

        delete this.fields[object.name];
        object.parent = null;
        object.onRemove(this);
        return clearCache(this);
    }
    if (object instanceof OneOf) {

        /* istanbul ignore if */
        if (!this.oneofs || this.oneofs[object.name] !== object)
            throw Error(object + " is not a member of " + this);

        delete this.oneofs[object.name];
        object.parent = null;
        object.onRemove(this);
        return clearCache(this);
    }
    return Namespace.prototype.remove.call(this, object);
};

/**
 * Tests if the specified id is reserved.
 * @param {number} id Id to test
 * @returns {boolean} `true` if reserved, otherwise `false`
 */
Type.prototype.isReservedId = function isReservedId(id) {
    return Namespace.isReservedId(this.reserved, id);
};

/**
 * Tests if the specified name is reserved.
 * @param {string} name Name to test
 * @returns {boolean} `true` if reserved, otherwise `false`
 */
Type.prototype.isReservedName = function isReservedName(name) {
    return Namespace.isReservedName(this.reserved, name);
};

/**
 * Creates a new message of this type using the specified properties.
 * @param {Object.<string,*>} [properties] Properties to set
 * @returns {Message<{}>} Message instance
 */
Type.prototype.create = function create(properties) {
    return new this.ctor(properties);
};

/**
 * Sets up {@link Type#encode|encode}, {@link Type#decode|decode} and {@link Type#verify|verify}.
 * @returns {Type} `this`
 */
Type.prototype.setup = function setup() {
    // Sets up everything at once so that the prototype chain does not have to be re-evaluated
    // multiple times (V8, soft-deopt prototype-check).

    var fullName = this.fullName,
        types    = [];
    for (var i = 0; i < /* initializes */ this.fieldsArray.length; ++i)
        types.push(this._fieldsArray[i].resolve().resolvedType);

    // Replace setup methods with type-specific generated functions
    this.encode = encoder(this)({
        Writer : Writer,
        types  : types,
        util   : util
    });
    this.decode = decoder(this)({
        Reader : Reader,
        types  : types,
        util   : util
    });
    this.verify = verifier(this)({
        types : types,
        util  : util
    });
    this.fromObject = converter.fromObject(this)({
        types : types,
        util  : util
    });
    this.toObject = converter.toObject(this)({
        types : types,
        util  : util
    });

    // Inject custom wrappers for common types
    var wrapper = wrappers[fullName];
    if (wrapper) {
        var originalThis = Object.create(this);
        // if (wrapper.fromObject) {
            originalThis.fromObject = this.fromObject;
            this.fromObject = wrapper.fromObject.bind(originalThis);
        // }
        // if (wrapper.toObject) {
            originalThis.toObject = this.toObject;
            this.toObject = wrapper.toObject.bind(originalThis);
        // }
    }

    return this;
};

/**
 * Encodes a message of this type. Does not implicitly {@link Type#verify|verify} messages.
 * @param {Message<{}>|Object.<string,*>} message Message instance or plain object
 * @param {Writer} [writer] Writer to encode to
 * @returns {Writer} writer
 */
Type.prototype.encode = function encode_setup(message, writer) {
    return this.setup().encode(message, writer); // overrides this method
};

/**
 * Encodes a message of this type preceeded by its byte length as a varint. Does not implicitly {@link Type#verify|verify} messages.
 * @param {Message<{}>|Object.<string,*>} message Message instance or plain object
 * @param {Writer} [writer] Writer to encode to
 * @returns {Writer} writer
 */
Type.prototype.encodeDelimited = function encodeDelimited(message, writer) {
    return this.encode(message, writer && writer.len ? writer.fork() : writer).ldelim();
};

/**
 * Decodes a message of this type.
 * @param {Reader|Uint8Array} reader Reader or buffer to decode from
 * @param {number} [length] Length of the message, if known beforehand
 * @returns {Message<{}>} Decoded message
 * @throws {Error} If the payload is not a reader or valid buffer
 * @throws {util.ProtocolError<{}>} If required fields are missing
 */
Type.prototype.decode = function decode_setup(reader, length) {
    return this.setup().decode(reader, length); // overrides this method
};

/**
 * Decodes a message of this type preceeded by its byte length as a varint.
 * @param {Reader|Uint8Array} reader Reader or buffer to decode from
 * @returns {Message<{}>} Decoded message
 * @throws {Error} If the payload is not a reader or valid buffer
 * @throws {util.ProtocolError} If required fields are missing
 */
Type.prototype.decodeDelimited = function decodeDelimited(reader) {
    if (!(reader instanceof Reader))
        reader = Reader.create(reader);
    return this.decode(reader, reader.uint32());
};

/**
 * Verifies that field values are valid and that required fields are present.
 * @param {Object.<string,*>} message Plain object to verify
 * @returns {null|string} `null` if valid, otherwise the reason why it is not
 */
Type.prototype.verify = function verify_setup(message) {
    return this.setup().verify(message); // overrides this method
};

/**
 * Creates a new message of this type from a plain object. Also converts values to their respective internal types.
 * @param {Object.<string,*>} object Plain object to convert
 * @returns {Message<{}>} Message instance
 */
Type.prototype.fromObject = function fromObject(object) {
    return this.setup().fromObject(object);
};

/**
 * Conversion options as used by {@link Type#toObject} and {@link Message.toObject}.
 * @interface IConversionOptions
 * @property {Function} [longs] Long conversion type.
 * Valid values are `String` and `Number` (the global types).
 * Defaults to copy the present value, which is a possibly unsafe number without and a {@link Long} with a long library.
 * @property {Function} [enums] Enum value conversion type.
 * Only valid value is `String` (the global type).
 * Defaults to copy the present value, which is the numeric id.
 * @property {Function} [bytes] Bytes value conversion type.
 * Valid values are `Array` and (a base64 encoded) `String` (the global types).
 * Defaults to copy the present value, which usually is a Buffer under node and an Uint8Array in the browser.
 * @property {boolean} [defaults=false] Also sets default values on the resulting object
 * @property {boolean} [arrays=false] Sets empty arrays for missing repeated fields even if `defaults=false`
 * @property {boolean} [objects=false] Sets empty objects for missing map fields even if `defaults=false`
 * @property {boolean} [oneofs=false] Includes virtual oneof properties set to the present field's name, if any
 * @property {boolean} [json=false] Performs additional JSON compatibility conversions, i.e. NaN and Infinity to strings
 */

/**
 * Creates a plain object from a message of this type. Also converts values to other types if specified.
 * @param {Message<{}>} message Message instance
 * @param {IConversionOptions} [options] Conversion options
 * @returns {Object.<string,*>} Plain object
 */
Type.prototype.toObject = function toObject(message, options) {
    return this.setup().toObject(message, options);
};

/**
 * Decorator function as returned by {@link Type.d} (TypeScript).
 * @typedef TypeDecorator
 * @type {function}
 * @param {Constructor<T>} target Target constructor
 * @returns {undefined}
 * @template T extends Message<T>
 */

/**
 * Type decorator (TypeScript).
 * @param {string} [typeName] Type name, defaults to the constructor's name
 * @returns {TypeDecorator<T>} Decorator function
 * @template T extends Message<T>
 */
Type.d = function decorateType(typeName) {
    return function typeDecorator(target) {
        util.decorateType(target, typeName);
    };
};

},{"12":12,"13":13,"14":14,"15":15,"16":16,"20":20,"21":21,"23":23,"25":25,"27":27,"33":33,"37":37,"40":40,"41":41,"42":42}],36:[function(require,module,exports){
"use strict";

/**
 * Common type constants.
 * @namespace
 */
var types = exports;

var util = require(37);

var s = [
    "double",   // 0
    "float",    // 1
    "int32",    // 2
    "uint32",   // 3
    "sint32",   // 4
    "fixed32",  // 5
    "sfixed32", // 6
    "int64",    // 7
    "uint64",   // 8
    "sint64",   // 9
    "fixed64",  // 10
    "sfixed64", // 11
    "bool",     // 12
    "string",   // 13
    "bytes"     // 14
];

function bake(values, offset) {
    var i = 0, o = {};
    offset |= 0;
    while (i < values.length) o[s[i + offset]] = values[i++];
    return o;
}

/**
 * Basic type wire types.
 * @type {Object.<string,number>}
 * @const
 * @property {number} double=1 Fixed64 wire type
 * @property {number} float=5 Fixed32 wire type
 * @property {number} int32=0 Varint wire type
 * @property {number} uint32=0 Varint wire type
 * @property {number} sint32=0 Varint wire type
 * @property {number} fixed32=5 Fixed32 wire type
 * @property {number} sfixed32=5 Fixed32 wire type
 * @property {number} int64=0 Varint wire type
 * @property {number} uint64=0 Varint wire type
 * @property {number} sint64=0 Varint wire type
 * @property {number} fixed64=1 Fixed64 wire type
 * @property {number} sfixed64=1 Fixed64 wire type
 * @property {number} bool=0 Varint wire type
 * @property {number} string=2 Ldelim wire type
 * @property {number} bytes=2 Ldelim wire type
 */
types.basic = bake([
    /* double   */ 1,
    /* float    */ 5,
    /* int32    */ 0,
    /* uint32   */ 0,
    /* sint32   */ 0,
    /* fixed32  */ 5,
    /* sfixed32 */ 5,
    /* int64    */ 0,
    /* uint64   */ 0,
    /* sint64   */ 0,
    /* fixed64  */ 1,
    /* sfixed64 */ 1,
    /* bool     */ 0,
    /* string   */ 2,
    /* bytes    */ 2
]);

/**
 * Basic type defaults.
 * @type {Object.<string,*>}
 * @const
 * @property {number} double=0 Double default
 * @property {number} float=0 Float default
 * @property {number} int32=0 Int32 default
 * @property {number} uint32=0 Uint32 default
 * @property {number} sint32=0 Sint32 default
 * @property {number} fixed32=0 Fixed32 default
 * @property {number} sfixed32=0 Sfixed32 default
 * @property {number} int64=0 Int64 default
 * @property {number} uint64=0 Uint64 default
 * @property {number} sint64=0 Sint32 default
 * @property {number} fixed64=0 Fixed64 default
 * @property {number} sfixed64=0 Sfixed64 default
 * @property {boolean} bool=false Bool default
 * @property {string} string="" String default
 * @property {Array.<number>} bytes=Array(0) Bytes default
 * @property {null} message=null Message default
 */
types.defaults = bake([
    /* double   */ 0,
    /* float    */ 0,
    /* int32    */ 0,
    /* uint32   */ 0,
    /* sint32   */ 0,
    /* fixed32  */ 0,
    /* sfixed32 */ 0,
    /* int64    */ 0,
    /* uint64   */ 0,
    /* sint64   */ 0,
    /* fixed64  */ 0,
    /* sfixed64 */ 0,
    /* bool     */ false,
    /* string   */ "",
    /* bytes    */ util.emptyArray,
    /* message  */ null
]);

/**
 * Basic long type wire types.
 * @type {Object.<string,number>}
 * @const
 * @property {number} int64=0 Varint wire type
 * @property {number} uint64=0 Varint wire type
 * @property {number} sint64=0 Varint wire type
 * @property {number} fixed64=1 Fixed64 wire type
 * @property {number} sfixed64=1 Fixed64 wire type
 */
types.long = bake([
    /* int64    */ 0,
    /* uint64   */ 0,
    /* sint64   */ 0,
    /* fixed64  */ 1,
    /* sfixed64 */ 1
], 7);

/**
 * Allowed types for map keys with their associated wire type.
 * @type {Object.<string,number>}
 * @const
 * @property {number} int32=0 Varint wire type
 * @property {number} uint32=0 Varint wire type
 * @property {number} sint32=0 Varint wire type
 * @property {number} fixed32=5 Fixed32 wire type
 * @property {number} sfixed32=5 Fixed32 wire type
 * @property {number} int64=0 Varint wire type
 * @property {number} uint64=0 Varint wire type
 * @property {number} sint64=0 Varint wire type
 * @property {number} fixed64=1 Fixed64 wire type
 * @property {number} sfixed64=1 Fixed64 wire type
 * @property {number} bool=0 Varint wire type
 * @property {number} string=2 Ldelim wire type
 */
types.mapKey = bake([
    /* int32    */ 0,
    /* uint32   */ 0,
    /* sint32   */ 0,
    /* fixed32  */ 5,
    /* sfixed32 */ 5,
    /* int64    */ 0,
    /* uint64   */ 0,
    /* sint64   */ 0,
    /* fixed64  */ 1,
    /* sfixed64 */ 1,
    /* bool     */ 0,
    /* string   */ 2
], 2);

/**
 * Allowed types for packed repeated fields with their associated wire type.
 * @type {Object.<string,number>}
 * @const
 * @property {number} double=1 Fixed64 wire type
 * @property {number} float=5 Fixed32 wire type
 * @property {number} int32=0 Varint wire type
 * @property {number} uint32=0 Varint wire type
 * @property {number} sint32=0 Varint wire type
 * @property {number} fixed32=5 Fixed32 wire type
 * @property {number} sfixed32=5 Fixed32 wire type
 * @property {number} int64=0 Varint wire type
 * @property {number} uint64=0 Varint wire type
 * @property {number} sint64=0 Varint wire type
 * @property {number} fixed64=1 Fixed64 wire type
 * @property {number} sfixed64=1 Fixed64 wire type
 * @property {number} bool=0 Varint wire type
 */
types.packed = bake([
    /* double   */ 1,
    /* float    */ 5,
    /* int32    */ 0,
    /* uint32   */ 0,
    /* sint32   */ 0,
    /* fixed32  */ 5,
    /* sfixed32 */ 5,
    /* int64    */ 0,
    /* uint64   */ 0,
    /* sint64   */ 0,
    /* fixed64  */ 1,
    /* sfixed64 */ 1,
    /* bool     */ 0
]);

},{"37":37}],37:[function(require,module,exports){
"use strict";

/**
 * Various utility functions.
 * @namespace
 */
var util = module.exports = require(39);

var roots = require(30);

var Type, // cyclic
    Enum;

util.codegen = require(3);
util.fetch   = require(5);
util.path    = require(8);

/**
 * Node's fs module if available.
 * @type {Object.<string,*>}
 */
util.fs = util.inquire("fs");

/**
 * Converts an object's values to an array.
 * @param {Object.<string,*>} object Object to convert
 * @returns {Array.<*>} Converted array
 */
util.toArray = function toArray(object) {
    if (object) {
        var keys  = Object.keys(object),
            array = new Array(keys.length),
            index = 0;
        while (index < keys.length)
            array[index] = object[keys[index++]];
        return array;
    }
    return [];
};

/**
 * Converts an array of keys immediately followed by their respective value to an object, omitting undefined values.
 * @param {Array.<*>} array Array to convert
 * @returns {Object.<string,*>} Converted object
 */
util.toObject = function toObject(array) {
    var object = {},
        index  = 0;
    while (index < array.length) {
        var key = array[index++],
            val = array[index++];
        if (val !== undefined)
            object[key] = val;
    }
    return object;
};

var safePropBackslashRe = /\\/g,
    safePropQuoteRe     = /"/g;

/**
 * Tests whether the specified name is a reserved word in JS.
 * @param {string} name Name to test
 * @returns {boolean} `true` if reserved, otherwise `false`
 */
util.isReserved = function isReserved(name) {
    return /^(?:do|if|in|for|let|new|try|var|case|else|enum|eval|false|null|this|true|void|with|break|catch|class|const|super|throw|while|yield|delete|export|import|public|return|static|switch|typeof|default|extends|finally|package|private|continue|debugger|function|arguments|interface|protected|implements|instanceof)$/.test(name);
};

/**
 * Returns a safe property accessor for the specified property name.
 * @param {string} prop Property name
 * @returns {string} Safe accessor
 */
util.safeProp = function safeProp(prop) {
    if (!/^[$\w_]+$/.test(prop) || util.isReserved(prop))
        return "[\"" + prop.replace(safePropBackslashRe, "\\\\").replace(safePropQuoteRe, "\\\"") + "\"]";
    return "." + prop;
};

/**
 * Converts the first character of a string to upper case.
 * @param {string} str String to convert
 * @returns {string} Converted string
 */
util.ucFirst = function ucFirst(str) {
    return str.charAt(0).toUpperCase() + str.substring(1);
};

var camelCaseRe = /_([a-z])/g;

/**
 * Converts a string to camel case.
 * @param {string} str String to convert
 * @returns {string} Converted string
 */
util.camelCase = function camelCase(str) {
    return str.substring(0, 1)
         + str.substring(1)
               .replace(camelCaseRe, function($0, $1) { return $1.toUpperCase(); });
};

/**
 * Compares reflected fields by id.
 * @param {Field} a First field
 * @param {Field} b Second field
 * @returns {number} Comparison value
 */
util.compareFieldsById = function compareFieldsById(a, b) {
    return a.id - b.id;
};

/**
 * Decorator helper for types (TypeScript).
 * @param {Constructor<T>} ctor Constructor function
 * @param {string} [typeName] Type name, defaults to the constructor's name
 * @returns {Type} Reflected type
 * @template T extends Message<T>
 * @property {Root} root Decorators root
 */
util.decorateType = function decorateType(ctor, typeName) {

    /* istanbul ignore if */
    if (ctor.$type) {
        if (typeName && ctor.$type.name !== typeName) {
            util.decorateRoot.remove(ctor.$type);
            ctor.$type.name = typeName;
            util.decorateRoot.add(ctor.$type);
        }
        return ctor.$type;
    }

    /* istanbul ignore next */
    if (!Type)
        Type = require(35);

    var type = new Type(typeName || ctor.name);
    util.decorateRoot.add(type);
    type.ctor = ctor; // sets up .encode, .decode etc.
    Object.defineProperty(ctor, "$type", { value: type, enumerable: false });
    Object.defineProperty(ctor.prototype, "$type", { value: type, enumerable: false });
    return type;
};

var decorateEnumIndex = 0;

/**
 * Decorator helper for enums (TypeScript).
 * @param {Object} object Enum object
 * @returns {Enum} Reflected enum
 */
util.decorateEnum = function decorateEnum(object) {

    /* istanbul ignore if */
    if (object.$type)
        return object.$type;

    /* istanbul ignore next */
    if (!Enum)
        Enum = require(15);

    var enm = new Enum("Enum" + decorateEnumIndex++, object);
    util.decorateRoot.add(enm);
    Object.defineProperty(object, "$type", { value: enm, enumerable: false });
    return enm;
};

/**
 * Decorator root (TypeScript).
 * @name util.decorateRoot
 * @type {Root}
 * @readonly
 */
Object.defineProperty(util, "decorateRoot", {
    get: function() {
        return roots["decorated"] || (roots["decorated"] = new (require(29))());
    }
});

},{"15":15,"29":29,"3":3,"30":30,"35":35,"39":39,"5":5,"8":8}],38:[function(require,module,exports){
"use strict";
module.exports = LongBits;

var util = require(39);

/**
 * Constructs new long bits.
 * @classdesc Helper class for working with the low and high bits of a 64 bit value.
 * @memberof util
 * @constructor
 * @param {number} lo Low 32 bits, unsigned
 * @param {number} hi High 32 bits, unsigned
 */
function LongBits(lo, hi) {

    // note that the casts below are theoretically unnecessary as of today, but older statically
    // generated converter code might still call the ctor with signed 32bits. kept for compat.

    /**
     * Low bits.
     * @type {number}
     */
    this.lo = lo >>> 0;

    /**
     * High bits.
     * @type {number}
     */
    this.hi = hi >>> 0;
}

/**
 * Zero bits.
 * @memberof util.LongBits
 * @type {util.LongBits}
 */
var zero = LongBits.zero = new LongBits(0, 0);

zero.toNumber = function() { return 0; };
zero.zzEncode = zero.zzDecode = function() { return this; };
zero.length = function() { return 1; };

/**
 * Zero hash.
 * @memberof util.LongBits
 * @type {string}
 */
var zeroHash = LongBits.zeroHash = "\0\0\0\0\0\0\0\0";

/**
 * Constructs new long bits from the specified number.
 * @param {number} value Value
 * @returns {util.LongBits} Instance
 */
LongBits.fromNumber = function fromNumber(value) {
    if (value === 0)
        return zero;
    var sign = value < 0;
    if (sign)
        value = -value;
    var lo = value >>> 0,
        hi = (value - lo) / 4294967296 >>> 0;
    if (sign) {
        hi = ~hi >>> 0;
        lo = ~lo >>> 0;
        if (++lo > 4294967295) {
            lo = 0;
            if (++hi > 4294967295)
                hi = 0;
        }
    }
    return new LongBits(lo, hi);
};

/**
 * Constructs new long bits from a number, long or string.
 * @param {Long|number|string} value Value
 * @returns {util.LongBits} Instance
 */
LongBits.from = function from(value) {
    if (typeof value === "number")
        return LongBits.fromNumber(value);
    if (util.isString(value)) {
        /* istanbul ignore else */
        if (util.Long)
            value = util.Long.fromString(value);
        else
            return LongBits.fromNumber(parseInt(value, 10));
    }
    return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;
};

/**
 * Converts this long bits to a possibly unsafe JavaScript number.
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {number} Possibly unsafe number
 */
LongBits.prototype.toNumber = function toNumber(unsigned) {
    if (!unsigned && this.hi >>> 31) {
        var lo = ~this.lo + 1 >>> 0,
            hi = ~this.hi     >>> 0;
        if (!lo)
            hi = hi + 1 >>> 0;
        return -(lo + hi * 4294967296);
    }
    return this.lo + this.hi * 4294967296;
};

/**
 * Converts this long bits to a long.
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {Long} Long
 */
LongBits.prototype.toLong = function toLong(unsigned) {
    return util.Long
        ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned))
        /* istanbul ignore next */
        : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };
};

var charCodeAt = String.prototype.charCodeAt;

/**
 * Constructs new long bits from the specified 8 characters long hash.
 * @param {string} hash Hash
 * @returns {util.LongBits} Bits
 */
LongBits.fromHash = function fromHash(hash) {
    if (hash === zeroHash)
        return zero;
    return new LongBits(
        ( charCodeAt.call(hash, 0)
        | charCodeAt.call(hash, 1) << 8
        | charCodeAt.call(hash, 2) << 16
        | charCodeAt.call(hash, 3) << 24) >>> 0
    ,
        ( charCodeAt.call(hash, 4)
        | charCodeAt.call(hash, 5) << 8
        | charCodeAt.call(hash, 6) << 16
        | charCodeAt.call(hash, 7) << 24) >>> 0
    );
};

/**
 * Converts this long bits to a 8 characters long hash.
 * @returns {string} Hash
 */
LongBits.prototype.toHash = function toHash() {
    return String.fromCharCode(
        this.lo        & 255,
        this.lo >>> 8  & 255,
        this.lo >>> 16 & 255,
        this.lo >>> 24      ,
        this.hi        & 255,
        this.hi >>> 8  & 255,
        this.hi >>> 16 & 255,
        this.hi >>> 24
    );
};

/**
 * Zig-zag encodes this long bits.
 * @returns {util.LongBits} `this`
 */
LongBits.prototype.zzEncode = function zzEncode() {
    var mask =   this.hi >> 31;
    this.hi  = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
    this.lo  = ( this.lo << 1                   ^ mask) >>> 0;
    return this;
};

/**
 * Zig-zag decodes this long bits.
 * @returns {util.LongBits} `this`
 */
LongBits.prototype.zzDecode = function zzDecode() {
    var mask = -(this.lo & 1);
    this.lo  = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
    this.hi  = ( this.hi >>> 1                  ^ mask) >>> 0;
    return this;
};

/**
 * Calculates the length of this longbits when encoded as a varint.
 * @returns {number} Length
 */
LongBits.prototype.length = function length() {
    var part0 =  this.lo,
        part1 = (this.lo >>> 28 | this.hi << 4) >>> 0,
        part2 =  this.hi >>> 24;
    return part2 === 0
         ? part1 === 0
           ? part0 < 16384
             ? part0 < 128 ? 1 : 2
             : part0 < 2097152 ? 3 : 4
           : part1 < 16384
             ? part1 < 128 ? 5 : 6
             : part1 < 2097152 ? 7 : 8
         : part2 < 128 ? 9 : 10;
};

},{"39":39}],39:[function(require,module,exports){
"use strict";
var util = exports;

// used to return a Promise where callback is omitted
util.asPromise = require(1);

// converts to / from base64 encoded strings
util.base64 = require(2);

// base class of rpc.Service
util.EventEmitter = require(4);

// float handling accross browsers
util.float = require(6);

// requires modules optionally and hides the call from bundlers
util.inquire = require(7);

// converts to / from utf8 encoded strings
util.utf8 = require(10);

// provides a node-like buffer pool in the browser
util.pool = require(9);

// utility to work with the low and high bits of a 64 bit value
util.LongBits = require(38);

/**
 * An immuable empty array.
 * @memberof util
 * @type {Array.<*>}
 * @const
 */
util.emptyArray = Object.freeze ? Object.freeze([]) : /* istanbul ignore next */ []; // used on prototypes

/**
 * An immutable empty object.
 * @type {Object}
 * @const
 */
util.emptyObject = Object.freeze ? Object.freeze({}) : /* istanbul ignore next */ {}; // used on prototypes

/**
 * Whether running within node or not.
 * @memberof util
 * @type {boolean}
 * @const
 */
util.isNode = Boolean(global.process && global.process.versions && global.process.versions.node);

/**
 * Tests if the specified value is an integer.
 * @function
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is an integer
 */
util.isInteger = Number.isInteger || /* istanbul ignore next */ function isInteger(value) {
    return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
};

/**
 * Tests if the specified value is a string.
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is a string
 */
util.isString = function isString(value) {
    return typeof value === "string" || value instanceof String;
};

/**
 * Tests if the specified value is a non-null object.
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is a non-null object
 */
util.isObject = function isObject(value) {
    return value && typeof value === "object";
};

/**
 * Checks if a property on a message is considered to be present.
 * This is an alias of {@link util.isSet}.
 * @function
 * @param {Object} obj Plain object or message instance
 * @param {string} prop Property name
 * @returns {boolean} `true` if considered to be present, otherwise `false`
 */
util.isset =

/**
 * Checks if a property on a message is considered to be present.
 * @param {Object} obj Plain object or message instance
 * @param {string} prop Property name
 * @returns {boolean} `true` if considered to be present, otherwise `false`
 */
util.isSet = function isSet(obj, prop) {
    var value = obj[prop];
    if (value != null && obj.hasOwnProperty(prop)) // eslint-disable-line eqeqeq, no-prototype-builtins
        return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
    return false;
};

/**
 * Any compatible Buffer instance.
 * This is a minimal stand-alone definition of a Buffer instance. The actual type is that exported by node's typings.
 * @interface Buffer
 * @extends Uint8Array
 */

/**
 * Node's Buffer class if available.
 * @type {Constructor<Buffer>}
 */
util.Buffer = (function() {
    try {
        var Buffer = util.inquire("buffer").Buffer;
        // refuse to use non-node buffers if not explicitly assigned (perf reasons):
        return Buffer.prototype.utf8Write ? Buffer : /* istanbul ignore next */ null;
    } catch (e) {
        /* istanbul ignore next */
        return null;
    }
})();

// Internal alias of or polyfull for Buffer.from.
util._Buffer_from = null;

// Internal alias of or polyfill for Buffer.allocUnsafe.
util._Buffer_allocUnsafe = null;

/**
 * Creates a new buffer of whatever type supported by the environment.
 * @param {number|number[]} [sizeOrArray=0] Buffer size or number array
 * @returns {Uint8Array|Buffer} Buffer
 */
util.newBuffer = function newBuffer(sizeOrArray) {
    /* istanbul ignore next */
    return typeof sizeOrArray === "number"
        ? util.Buffer
            ? util._Buffer_allocUnsafe(sizeOrArray)
            : new util.Array(sizeOrArray)
        : util.Buffer
            ? util._Buffer_from(sizeOrArray)
            : typeof Uint8Array === "undefined"
                ? sizeOrArray
                : new Uint8Array(sizeOrArray);
};

/**
 * Array implementation used in the browser. `Uint8Array` if supported, otherwise `Array`.
 * @type {Constructor<Uint8Array>}
 */
util.Array = typeof Uint8Array !== "undefined" ? Uint8Array /* istanbul ignore next */ : Array;

/**
 * Any compatible Long instance.
 * This is a minimal stand-alone definition of a Long instance. The actual type is that exported by long.js.
 * @interface Long
 * @property {number} low Low bits
 * @property {number} high High bits
 * @property {boolean} unsigned Whether unsigned or not
 */

/**
 * Long.js's Long class if available.
 * @type {Constructor<Long>}
 */
util.Long = /* istanbul ignore next */ global.dcodeIO && /* istanbul ignore next */ global.dcodeIO.Long || util.inquire("long");

/**
 * Regular expression used to verify 2 bit (`bool`) map keys.
 * @type {RegExp}
 * @const
 */
util.key2Re = /^true|false|0|1$/;

/**
 * Regular expression used to verify 32 bit (`int32` etc.) map keys.
 * @type {RegExp}
 * @const
 */
util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;

/**
 * Regular expression used to verify 64 bit (`int64` etc.) map keys.
 * @type {RegExp}
 * @const
 */
util.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;

/**
 * Converts a number or long to an 8 characters long hash string.
 * @param {Long|number} value Value to convert
 * @returns {string} Hash
 */
util.longToHash = function longToHash(value) {
    return value
        ? util.LongBits.from(value).toHash()
        : util.LongBits.zeroHash;
};

/**
 * Converts an 8 characters long hash string to a long or number.
 * @param {string} hash Hash
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {Long|number} Original value
 */
util.longFromHash = function longFromHash(hash, unsigned) {
    var bits = util.LongBits.fromHash(hash);
    if (util.Long)
        return util.Long.fromBits(bits.lo, bits.hi, unsigned);
    return bits.toNumber(Boolean(unsigned));
};

/**
 * Merges the properties of the source object into the destination object.
 * @memberof util
 * @param {Object.<string,*>} dst Destination object
 * @param {Object.<string,*>} src Source object
 * @param {boolean} [ifNotSet=false] Merges only if the key is not already set
 * @returns {Object.<string,*>} Destination object
 */
function merge(dst, src, ifNotSet) { // used by converters
    for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)
        if (dst[keys[i]] === undefined || !ifNotSet)
            dst[keys[i]] = src[keys[i]];
    return dst;
}

util.merge = merge;

/**
 * Converts the first character of a string to lower case.
 * @param {string} str String to convert
 * @returns {string} Converted string
 */
util.lcFirst = function lcFirst(str) {
    return str.charAt(0).toLowerCase() + str.substring(1);
};

/**
 * Creates a custom error constructor.
 * @memberof util
 * @param {string} name Error name
 * @returns {Constructor<Error>} Custom error constructor
 */
function newError(name) {

    function CustomError(message, properties) {

        if (!(this instanceof CustomError))
            return new CustomError(message, properties);

        // Error.call(this, message);
        // ^ just returns a new error instance because the ctor can be called as a function

        Object.defineProperty(this, "message", { get: function() { return message; } });

        /* istanbul ignore next */
        if (Error.captureStackTrace) // node
            Error.captureStackTrace(this, CustomError);
        else
            Object.defineProperty(this, "stack", { value: (new Error()).stack || "" });

        if (properties)
            merge(this, properties);
    }

    (CustomError.prototype = Object.create(Error.prototype)).constructor = CustomError;

    Object.defineProperty(CustomError.prototype, "name", { get: function() { return name; } });

    CustomError.prototype.toString = function toString() {
        return this.name + ": " + this.message;
    };

    return CustomError;
}

util.newError = newError;

/**
 * Constructs a new protocol error.
 * @classdesc Error subclass indicating a protocol specifc error.
 * @memberof util
 * @extends Error
 * @template T extends Message<T>
 * @constructor
 * @param {string} message Error message
 * @param {Object.<string,*>} [properties] Additional properties
 * @example
 * try {
 *     MyMessage.decode(someBuffer); // throws if required fields are missing
 * } catch (e) {
 *     if (e instanceof ProtocolError && e.instance)
 *         console.log("decoded so far: " + JSON.stringify(e.instance));
 * }
 */
util.ProtocolError = newError("ProtocolError");

/**
 * So far decoded message instance.
 * @name util.ProtocolError#instance
 * @type {Message<T>}
 */

/**
 * A OneOf getter as returned by {@link util.oneOfGetter}.
 * @typedef OneOfGetter
 * @type {function}
 * @returns {string|undefined} Set field name, if any
 */

/**
 * Builds a getter for a oneof's present field name.
 * @param {string[]} fieldNames Field names
 * @returns {OneOfGetter} Unbound getter
 */
util.oneOfGetter = function getOneOf(fieldNames) {
    var fieldMap = {};
    for (var i = 0; i < fieldNames.length; ++i)
        fieldMap[fieldNames[i]] = 1;

    /**
     * @returns {string|undefined} Set field name, if any
     * @this Object
     * @ignore
     */
    return function() { // eslint-disable-line consistent-return
        for (var keys = Object.keys(this), i = keys.length - 1; i > -1; --i)
            if (fieldMap[keys[i]] === 1 && this[keys[i]] !== undefined && this[keys[i]] !== null)
                return keys[i];
    };
};

/**
 * A OneOf setter as returned by {@link util.oneOfSetter}.
 * @typedef OneOfSetter
 * @type {function}
 * @param {string|undefined} value Field name
 * @returns {undefined}
 */

/**
 * Builds a setter for a oneof's present field name.
 * @param {string[]} fieldNames Field names
 * @returns {OneOfSetter} Unbound setter
 */
util.oneOfSetter = function setOneOf(fieldNames) {

    /**
     * @param {string} name Field name
     * @returns {undefined}
     * @this Object
     * @ignore
     */
    return function(name) {
        for (var i = 0; i < fieldNames.length; ++i)
            if (fieldNames[i] !== name)
                delete this[fieldNames[i]];
    };
};

/**
 * Default conversion options used for {@link Message#toJSON} implementations.
 *
 * These options are close to proto3's JSON mapping with the exception that internal types like Any are handled just like messages. More precisely:
 *
 * - Longs become strings
 * - Enums become string keys
 * - Bytes become base64 encoded strings
 * - (Sub-)Messages become plain objects
 * - Maps become plain objects with all string keys
 * - Repeated fields become arrays
 * - NaN and Infinity for float and double fields become strings
 *
 * @type {IConversionOptions}
 * @see https://developers.google.com/protocol-buffers/docs/proto3?hl=en#json
 */
util.toJSONOptions = {
    longs: String,
    enums: String,
    bytes: String,
    json: true
};

util._configure = function() {
    var Buffer = util.Buffer;
    /* istanbul ignore if */
    if (!Buffer) {
        util._Buffer_from = util._Buffer_allocUnsafe = null;
        return;
    }
    // because node 4.x buffers are incompatible & immutable
    // see: https://github.com/dcodeIO/protobuf.js/pull/665
    util._Buffer_from = Buffer.from !== Uint8Array.from && Buffer.from ||
        /* istanbul ignore next */
        function Buffer_from(value, encoding) {
            return new Buffer(value, encoding);
        };
    util._Buffer_allocUnsafe = Buffer.allocUnsafe ||
        /* istanbul ignore next */
        function Buffer_allocUnsafe(size) {
            return new Buffer(size);
        };
};

},{"1":1,"10":10,"2":2,"38":38,"4":4,"6":6,"7":7,"9":9}],40:[function(require,module,exports){
"use strict";
module.exports = verifier;

var Enum      = require(15),
    util      = require(37);

function invalid(field, expected) {
    return field.name + ": " + expected + (field.repeated && expected !== "array" ? "[]" : field.map && expected !== "object" ? "{k:"+field.keyType+"}" : "") + " expected";
}

/**
 * Generates a partial value verifier.
 * @param {Codegen} gen Codegen instance
 * @param {Field} field Reflected field
 * @param {number} fieldIndex Field index
 * @param {string} ref Variable reference
 * @returns {Codegen} Codegen instance
 * @ignore
 */
function genVerifyValue(gen, field, fieldIndex, ref) {
    /* eslint-disable no-unexpected-multiline */
    if (field.resolvedType) {
        if (field.resolvedType instanceof Enum) { gen
            ("switch(%s){", ref)
                ("default:")
                    ("return%j", invalid(field, "enum value"));
            for (var keys = Object.keys(field.resolvedType.values), j = 0; j < keys.length; ++j) gen
                ("case %i:", field.resolvedType.values[keys[j]]);
            gen
                    ("break")
            ("}");
        } else {
            gen
            ("{")
                ("var e=types[%i].verify(%s);", fieldIndex, ref)
                ("if(e)")
                    ("return%j+e", field.name + ".")
            ("}");
        }
    } else {
        switch (field.type) {
            case "int32":
            case "uint32":
            case "sint32":
            case "fixed32":
            case "sfixed32": gen
                ("if(!util.isInteger(%s))", ref)
                    ("return%j", invalid(field, "integer"));
                break;
            case "int64":
            case "uint64":
            case "sint64":
            case "fixed64":
            case "sfixed64": gen
                ("if(!util.isInteger(%s)&&!(%s&&util.isInteger(%s.low)&&util.isInteger(%s.high)))", ref, ref, ref, ref)
                    ("return%j", invalid(field, "integer|Long"));
                break;
            case "float":
            case "double": gen
                ("if(typeof %s!==\"number\")", ref)
                    ("return%j", invalid(field, "number"));
                break;
            case "bool": gen
                ("if(typeof %s!==\"boolean\")", ref)
                    ("return%j", invalid(field, "boolean"));
                break;
            case "string": gen
                ("if(!util.isString(%s))", ref)
                    ("return%j", invalid(field, "string"));
                break;
            case "bytes": gen
                ("if(!(%s&&typeof %s.length===\"number\"||util.isString(%s)))", ref, ref, ref)
                    ("return%j", invalid(field, "buffer"));
                break;
        }
    }
    return gen;
    /* eslint-enable no-unexpected-multiline */
}

/**
 * Generates a partial key verifier.
 * @param {Codegen} gen Codegen instance
 * @param {Field} field Reflected field
 * @param {string} ref Variable reference
 * @returns {Codegen} Codegen instance
 * @ignore
 */
function genVerifyKey(gen, field, ref) {
    /* eslint-disable no-unexpected-multiline */
    switch (field.keyType) {
        case "int32":
        case "uint32":
        case "sint32":
        case "fixed32":
        case "sfixed32": gen
            ("if(!util.key32Re.test(%s))", ref)
                ("return%j", invalid(field, "integer key"));
            break;
        case "int64":
        case "uint64":
        case "sint64":
        case "fixed64":
        case "sfixed64": gen
            ("if(!util.key64Re.test(%s))", ref) // see comment above: x is ok, d is not
                ("return%j", invalid(field, "integer|Long key"));
            break;
        case "bool": gen
            ("if(!util.key2Re.test(%s))", ref)
                ("return%j", invalid(field, "boolean key"));
            break;
    }
    return gen;
    /* eslint-enable no-unexpected-multiline */
}

/**
 * Generates a verifier specific to the specified message type.
 * @param {Type} mtype Message type
 * @returns {Codegen} Codegen instance
 */
function verifier(mtype) {
    /* eslint-disable no-unexpected-multiline */

    var gen = util.codegen(["m"], mtype.name + "$verify")
    ("if(typeof m!==\"object\"||m===null)")
        ("return%j", "object expected");
    var oneofs = mtype.oneofsArray,
        seenFirstField = {};
    if (oneofs.length) gen
    ("var p={}");

    for (var i = 0; i < /* initializes */ mtype.fieldsArray.length; ++i) {
        var field = mtype._fieldsArray[i].resolve(),
            ref   = "m" + util.safeProp(field.name);

        if (field.optional) gen
        ("if(%s!=null&&m.hasOwnProperty(%j)){", ref, field.name); // !== undefined && !== null

        // map fields
        if (field.map) { gen
            ("if(!util.isObject(%s))", ref)
                ("return%j", invalid(field, "object"))
            ("var k=Object.keys(%s)", ref)
            ("for(var i=0;i<k.length;++i){");
                genVerifyKey(gen, field, "k[i]");
                genVerifyValue(gen, field, i, ref + "[k[i]]")
            ("}");

        // repeated fields
        } else if (field.repeated) { gen
            ("if(!Array.isArray(%s))", ref)
                ("return%j", invalid(field, "array"))
            ("for(var i=0;i<%s.length;++i){", ref);
                genVerifyValue(gen, field, i, ref + "[i]")
            ("}");

        // required or present fields
        } else {
            if (field.partOf) {
                var oneofProp = util.safeProp(field.partOf.name);
                if (seenFirstField[field.partOf.name] === 1) gen
            ("if(p%s===1)", oneofProp)
                ("return%j", field.partOf.name + ": multiple values");
                seenFirstField[field.partOf.name] = 1;
                gen
            ("p%s=1", oneofProp);
            }
            genVerifyValue(gen, field, i, ref);
        }
        if (field.optional) gen
        ("}");
    }
    return gen
    ("return null");
    /* eslint-enable no-unexpected-multiline */
}
},{"15":15,"37":37}],41:[function(require,module,exports){
"use strict";

/**
 * Wrappers for common types.
 * @type {Object.<string,IWrapper>}
 * @const
 */
var wrappers = exports;

var Message = require(21);

/**
 * From object converter part of an {@link IWrapper}.
 * @typedef WrapperFromObjectConverter
 * @type {function}
 * @param {Object.<string,*>} object Plain object
 * @returns {Message<{}>} Message instance
 * @this Type
 */

/**
 * To object converter part of an {@link IWrapper}.
 * @typedef WrapperToObjectConverter
 * @type {function}
 * @param {Message<{}>} message Message instance
 * @param {IConversionOptions} [options] Conversion options
 * @returns {Object.<string,*>} Plain object
 * @this Type
 */

/**
 * Common type wrapper part of {@link wrappers}.
 * @interface IWrapper
 * @property {WrapperFromObjectConverter} [fromObject] From object converter
 * @property {WrapperToObjectConverter} [toObject] To object converter
 */

// Custom wrapper for Any
wrappers[".google.protobuf.Any"] = {

    fromObject: function(object) {

        // unwrap value type if mapped
        if (object && object["@type"]) {
            var type = this.lookup(object["@type"]);
            /* istanbul ignore else */
            if (type) {
                // type_url does not accept leading "."
                var type_url = object["@type"].charAt(0) === "." ?
                    object["@type"].substr(1) : object["@type"];
                // type_url prefix is optional, but path seperator is required
                return this.create({
                    type_url: "/" + type_url,
                    value: type.encode(type.fromObject(object)).finish()
                });
            }
        }

        return this.fromObject(object);
    },

    toObject: function(message, options) {

        // decode value if requested and unmapped
        if (options && options.json && message.type_url && message.value) {
            // Only use fully qualified type name after the last '/'
            var name = message.type_url.substring(message.type_url.lastIndexOf("/") + 1);
            var type = this.lookup(name);
            /* istanbul ignore else */
            if (type)
                message = type.decode(message.value);
        }

        // wrap value if unmapped
        if (!(message instanceof this.ctor) && message instanceof Message) {
            var object = message.$type.toObject(message, options);
            object["@type"] = message.$type.fullName;
            return object;
        }

        return this.toObject(message, options);
    }
};

},{"21":21}],42:[function(require,module,exports){
"use strict";
module.exports = Writer;

var util      = require(39);

var BufferWriter; // cyclic

var LongBits  = util.LongBits,
    base64    = util.base64,
    utf8      = util.utf8;

/**
 * Constructs a new writer operation instance.
 * @classdesc Scheduled writer operation.
 * @constructor
 * @param {function(*, Uint8Array, number)} fn Function to call
 * @param {number} len Value byte length
 * @param {*} val Value to write
 * @ignore
 */
function Op(fn, len, val) {

    /**
     * Function to call.
     * @type {function(Uint8Array, number, *)}
     */
    this.fn = fn;

    /**
     * Value byte length.
     * @type {number}
     */
    this.len = len;

    /**
     * Next operation.
     * @type {Writer.Op|undefined}
     */
    this.next = undefined;

    /**
     * Value to write.
     * @type {*}
     */
    this.val = val; // type varies
}

/* istanbul ignore next */
function noop() {} // eslint-disable-line no-empty-function

/**
 * Constructs a new writer state instance.
 * @classdesc Copied writer state.
 * @memberof Writer
 * @constructor
 * @param {Writer} writer Writer to copy state from
 * @ignore
 */
function State(writer) {

    /**
     * Current head.
     * @type {Writer.Op}
     */
    this.head = writer.head;

    /**
     * Current tail.
     * @type {Writer.Op}
     */
    this.tail = writer.tail;

    /**
     * Current buffer length.
     * @type {number}
     */
    this.len = writer.len;

    /**
     * Next state.
     * @type {State|null}
     */
    this.next = writer.states;
}

/**
 * Constructs a new writer instance.
 * @classdesc Wire format writer using `Uint8Array` if available, otherwise `Array`.
 * @constructor
 */
function Writer() {

    /**
     * Current length.
     * @type {number}
     */
    this.len = 0;

    /**
     * Operations head.
     * @type {Object}
     */
    this.head = new Op(noop, 0, 0);

    /**
     * Operations tail
     * @type {Object}
     */
    this.tail = this.head;

    /**
     * Linked forked states.
     * @type {Object|null}
     */
    this.states = null;

    // When a value is written, the writer calculates its byte length and puts it into a linked
    // list of operations to perform when finish() is called. This both allows us to allocate
    // buffers of the exact required size and reduces the amount of work we have to do compared
    // to first calculating over objects and then encoding over objects. In our case, the encoding
    // part is just a linked list walk calling operations with already prepared values.
}

/**
 * Creates a new writer.
 * @function
 * @returns {BufferWriter|Writer} A {@link BufferWriter} when Buffers are supported, otherwise a {@link Writer}
 */
Writer.create = util.Buffer
    ? function create_buffer_setup() {
        return (Writer.create = function create_buffer() {
            return new BufferWriter();
        })();
    }
    /* istanbul ignore next */
    : function create_array() {
        return new Writer();
    };

/**
 * Allocates a buffer of the specified size.
 * @param {number} size Buffer size
 * @returns {Uint8Array} Buffer
 */
Writer.alloc = function alloc(size) {
    return new util.Array(size);
};

// Use Uint8Array buffer pool in the browser, just like node does with buffers
/* istanbul ignore else */
if (util.Array !== Array)
    Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);

/**
 * Pushes a new operation to the queue.
 * @param {function(Uint8Array, number, *)} fn Function to call
 * @param {number} len Value byte length
 * @param {number} val Value to write
 * @returns {Writer} `this`
 * @private
 */
Writer.prototype._push = function push(fn, len, val) {
    this.tail = this.tail.next = new Op(fn, len, val);
    this.len += len;
    return this;
};

function writeByte(val, buf, pos) {
    buf[pos] = val & 255;
}

function writeVarint32(val, buf, pos) {
    while (val > 127) {
        buf[pos++] = val & 127 | 128;
        val >>>= 7;
    }
    buf[pos] = val;
}

/**
 * Constructs a new varint writer operation instance.
 * @classdesc Scheduled varint writer operation.
 * @extends Op
 * @constructor
 * @param {number} len Value byte length
 * @param {number} val Value to write
 * @ignore
 */
function VarintOp(len, val) {
    this.len = len;
    this.next = undefined;
    this.val = val;
}

VarintOp.prototype = Object.create(Op.prototype);
VarintOp.prototype.fn = writeVarint32;

/**
 * Writes an unsigned 32 bit value as a varint.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.uint32 = function write_uint32(value) {
    // here, the call to this.push has been inlined and a varint specific Op subclass is used.
    // uint32 is by far the most frequently used operation and benefits significantly from this.
    this.len += (this.tail = this.tail.next = new VarintOp(
        (value = value >>> 0)
                < 128       ? 1
        : value < 16384     ? 2
        : value < 2097152   ? 3
        : value < 268435456 ? 4
        :                     5,
    value)).len;
    return this;
};

/**
 * Writes a signed 32 bit value as a varint.
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.int32 = function write_int32(value) {
    return value < 0
        ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) // 10 bytes per spec
        : this.uint32(value);
};

/**
 * Writes a 32 bit value as a varint, zig-zag encoded.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.sint32 = function write_sint32(value) {
    return this.uint32((value << 1 ^ value >> 31) >>> 0);
};

function writeVarint64(val, buf, pos) {
    while (val.hi) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
        val.hi >>>= 7;
    }
    while (val.lo > 127) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = val.lo >>> 7;
    }
    buf[pos++] = val.lo;
}

/**
 * Writes an unsigned 64 bit value as a varint.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.uint64 = function write_uint64(value) {
    var bits = LongBits.from(value);
    return this._push(writeVarint64, bits.length(), bits);
};

/**
 * Writes a signed 64 bit value as a varint.
 * @function
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.int64 = Writer.prototype.uint64;

/**
 * Writes a signed 64 bit value as a varint, zig-zag encoded.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.sint64 = function write_sint64(value) {
    var bits = LongBits.from(value).zzEncode();
    return this._push(writeVarint64, bits.length(), bits);
};

/**
 * Writes a boolish value as a varint.
 * @param {boolean} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.bool = function write_bool(value) {
    return this._push(writeByte, 1, value ? 1 : 0);
};

function writeFixed32(val, buf, pos) {
    buf[pos    ] =  val         & 255;
    buf[pos + 1] =  val >>> 8   & 255;
    buf[pos + 2] =  val >>> 16  & 255;
    buf[pos + 3] =  val >>> 24;
}

/**
 * Writes an unsigned 32 bit value as fixed 32 bits.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.fixed32 = function write_fixed32(value) {
    return this._push(writeFixed32, 4, value >>> 0);
};

/**
 * Writes a signed 32 bit value as fixed 32 bits.
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.sfixed32 = Writer.prototype.fixed32;

/**
 * Writes an unsigned 64 bit value as fixed 64 bits.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.fixed64 = function write_fixed64(value) {
    var bits = LongBits.from(value);
    return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
};

/**
 * Writes a signed 64 bit value as fixed 64 bits.
 * @function
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.sfixed64 = Writer.prototype.fixed64;

/**
 * Writes a float (32 bit).
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.float = function write_float(value) {
    return this._push(util.float.writeFloatLE, 4, value);
};

/**
 * Writes a double (64 bit float).
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.double = function write_double(value) {
    return this._push(util.float.writeDoubleLE, 8, value);
};

var writeBytes = util.Array.prototype.set
    ? function writeBytes_set(val, buf, pos) {
        buf.set(val, pos); // also works for plain array values
    }
    /* istanbul ignore next */
    : function writeBytes_for(val, buf, pos) {
        for (var i = 0; i < val.length; ++i)
            buf[pos + i] = val[i];
    };

/**
 * Writes a sequence of bytes.
 * @param {Uint8Array|string} value Buffer or base64 encoded string to write
 * @returns {Writer} `this`
 */
Writer.prototype.bytes = function write_bytes(value) {
    var len = value.length >>> 0;
    if (!len)
        return this._push(writeByte, 1, 0);
    if (util.isString(value)) {
        var buf = Writer.alloc(len = base64.length(value));
        base64.decode(value, buf, 0);
        value = buf;
    }
    return this.uint32(len)._push(writeBytes, len, value);
};

/**
 * Writes a string.
 * @param {string} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.string = function write_string(value) {
    var len = utf8.length(value);
    return len
        ? this.uint32(len)._push(utf8.write, len, value)
        : this._push(writeByte, 1, 0);
};

/**
 * Forks this writer's state by pushing it to a stack.
 * Calling {@link Writer#reset|reset} or {@link Writer#ldelim|ldelim} resets the writer to the previous state.
 * @returns {Writer} `this`
 */
Writer.prototype.fork = function fork() {
    this.states = new State(this);
    this.head = this.tail = new Op(noop, 0, 0);
    this.len = 0;
    return this;
};

/**
 * Resets this instance to the last state.
 * @returns {Writer} `this`
 */
Writer.prototype.reset = function reset() {
    if (this.states) {
        this.head   = this.states.head;
        this.tail   = this.states.tail;
        this.len    = this.states.len;
        this.states = this.states.next;
    } else {
        this.head = this.tail = new Op(noop, 0, 0);
        this.len  = 0;
    }
    return this;
};

/**
 * Resets to the last state and appends the fork state's current write length as a varint followed by its operations.
 * @returns {Writer} `this`
 */
Writer.prototype.ldelim = function ldelim() {
    var head = this.head,
        tail = this.tail,
        len  = this.len;
    this.reset().uint32(len);
    if (len) {
        this.tail.next = head.next; // skip noop
        this.tail = tail;
        this.len += len;
    }
    return this;
};

/**
 * Finishes the write operation.
 * @returns {Uint8Array} Finished buffer
 */
Writer.prototype.finish = function finish() {
    var head = this.head.next, // skip noop
        buf  = this.constructor.alloc(this.len),
        pos  = 0;
    while (head) {
        head.fn(head.val, buf, pos);
        pos += head.len;
        head = head.next;
    }
    // this.head = this.tail = null;
    return buf;
};

Writer._configure = function(BufferWriter_) {
    BufferWriter = BufferWriter_;
};

},{"39":39}],43:[function(require,module,exports){
"use strict";
module.exports = BufferWriter;

// extends Writer
var Writer = require(42);
(BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;

var util = require(39);

var Buffer = util.Buffer;

/**
 * Constructs a new buffer writer instance.
 * @classdesc Wire format writer using node buffers.
 * @extends Writer
 * @constructor
 */
function BufferWriter() {
    Writer.call(this);
}

/**
 * Allocates a buffer of the specified size.
 * @param {number} size Buffer size
 * @returns {Buffer} Buffer
 */
BufferWriter.alloc = function alloc_buffer(size) {
    return (BufferWriter.alloc = util._Buffer_allocUnsafe)(size);
};

var writeBytesBuffer = Buffer && Buffer.prototype instanceof Uint8Array && Buffer.prototype.set.name === "set"
    ? function writeBytesBuffer_set(val, buf, pos) {
        buf.set(val, pos); // faster than copy (requires node >= 4 where Buffers extend Uint8Array and set is properly inherited)
                           // also works for plain array values
    }
    /* istanbul ignore next */
    : function writeBytesBuffer_copy(val, buf, pos) {
        if (val.copy) // Buffer values
            val.copy(buf, pos, 0, val.length);
        else for (var i = 0; i < val.length;) // plain array values
            buf[pos++] = val[i++];
    };

/**
 * @override
 */
BufferWriter.prototype.bytes = function write_bytes_buffer(value) {
    if (util.isString(value))
        value = util._Buffer_from(value, "base64");
    var len = value.length >>> 0;
    this.uint32(len);
    if (len)
        this._push(writeBytesBuffer, len, value);
    return this;
};

function writeStringBuffer(val, buf, pos) {
    if (val.length < 40) // plain js is faster for short strings (probably due to redundant assertions)
        util.utf8.write(val, buf, pos);
    else
        buf.utf8Write(val, pos);
}

/**
 * @override
 */
BufferWriter.prototype.string = function write_string_buffer(value) {
    var len = Buffer.byteLength(value);
    this.uint32(len);
    if (len)
        this._push(writeStringBuffer, len, value);
    return this;
};


/**
 * Finishes the write operation.
 * @name BufferWriter#finish
 * @function
 * @returns {Buffer} Finished buffer
 */

},{"39":39,"42":42}]},{},[19])

})(
	typeof window==="object" && window
	|| typeof self==="object" && self
	|| this
);





// file: /bitrix/js/pull/protobuf/model.js
/*eslint-disable block-scoped-var, no-redeclare, no-control-regex, no-prototype-builtins*/
(function($protobuf) {
    "use strict";

    // Common aliases
    var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;

    // Exported root namespace
    var $root = $protobuf.roots["push-server"] || ($protobuf.roots["push-server"] = {});

    $root.RequestBatch = (function() {

        /**
         * Properties of a RequestBatch.
         * @exports IRequestBatch
         * @interface IRequestBatch
         * @property {Array.<Request>|null} [requests] RequestBatch requests
         */

        /**
         * Constructs a new RequestBatch.
         * @exports RequestBatch
         * @classdesc Represents a RequestBatch.
         * @implements IRequestBatch
         * @constructor
         * @param {IRequestBatch=} [properties] Properties to set
         */
        function RequestBatch(properties) {
            this.requests = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RequestBatch requests.
         * @member {Array.<Request>} requests
         * @memberof RequestBatch
         * @instance
         */
        RequestBatch.prototype.requests = $util.emptyArray;

        /**
         * Creates a new RequestBatch instance using the specified properties.
         * @function create
         * @memberof RequestBatch
         * @static
         * @param {IRequestBatch=} [properties] Properties to set
         * @returns {RequestBatch} RequestBatch instance
         */
        RequestBatch.create = function create(properties) {
            return new RequestBatch(properties);
        };

        /**
         * Encodes the specified RequestBatch message. Does not implicitly {@link RequestBatch.verify|verify} messages.
         * @function encode
         * @memberof RequestBatch
         * @static
         * @param {RequestBatch} message RequestBatch message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RequestBatch.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.requests != null && message.requests.length)
                for (var i = 0; i < message.requests.length; ++i)
                    $root.Request.encode(message.requests[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Decodes a RequestBatch message from the specified reader or buffer.
         * @function decode
         * @memberof RequestBatch
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RequestBatch} RequestBatch
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RequestBatch.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RequestBatch();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.requests && message.requests.length))
                        message.requests = [];
                    message.requests.push($root.Request.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return RequestBatch;
    })();

    $root.Request = (function() {

        /**
         * Properties of a Request.
         * @exports IRequest
         * @interface IRequest
         * @property {IncomingMessagesRequest|null} [incomingMessages] Request incomingMessages
         * @property {ChannelStatsRequest|null} [channelStats] Request channelStats
         * @property {ServerStatsRequest|null} [serverStats] Request serverStats
         */

        /**
         * Constructs a new Request.
         * @exports Request
         * @classdesc Represents a Request.
         * @implements IRequest
         * @constructor
         * @param {IRequest=} [properties] Properties to set
         */
        function Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Request incomingMessages.
         * @member {IncomingMessagesRequest|null|undefined} incomingMessages
         * @memberof Request
         * @instance
         */
        Request.prototype.incomingMessages = null;

        /**
         * Request channelStats.
         * @member {ChannelStatsRequest|null|undefined} channelStats
         * @memberof Request
         * @instance
         */
        Request.prototype.channelStats = null;

        /**
         * Request serverStats.
         * @member {ServerStatsRequest|null|undefined} serverStats
         * @memberof Request
         * @instance
         */
        Request.prototype.serverStats = null;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * Request command.
         * @member {"incomingMessages"|"channelStats"|"serverStats"|undefined} command
         * @memberof Request
         * @instance
         */
        Object.defineProperty(Request.prototype, "command", {
            get: $util.oneOfGetter($oneOfFields = ["incomingMessages", "channelStats", "serverStats"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new Request instance using the specified properties.
         * @function create
         * @memberof Request
         * @static
         * @param {IRequest=} [properties] Properties to set
         * @returns {Request} Request instance
         */
        Request.create = function create(properties) {
            return new Request(properties);
        };

        /**
         * Encodes the specified Request message. Does not implicitly {@link Request.verify|verify} messages.
         * @function encode
         * @memberof Request
         * @static
         * @param {Request} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.incomingMessages != null && message.hasOwnProperty("incomingMessages"))
                $root.IncomingMessagesRequest.encode(message.incomingMessages, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.channelStats != null && message.hasOwnProperty("channelStats"))
                $root.ChannelStatsRequest.encode(message.channelStats, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.serverStats != null && message.hasOwnProperty("serverStats"))
                $root.ServerStatsRequest.encode(message.serverStats, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Decodes a Request message from the specified reader or buffer.
         * @function decode
         * @memberof Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.incomingMessages = $root.IncomingMessagesRequest.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.channelStats = $root.ChannelStatsRequest.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.serverStats = $root.ServerStatsRequest.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return Request;
    })();

    $root.IncomingMessagesRequest = (function() {

        /**
         * Properties of an IncomingMessagesRequest.
         * @exports IIncomingMessagesRequest
         * @interface IIncomingMessagesRequest
         * @property {Array.<IncomingMessage>|null} [messages] IncomingMessagesRequest messages
         */

        /**
         * Constructs a new IncomingMessagesRequest.
         * @exports IncomingMessagesRequest
         * @classdesc Represents an IncomingMessagesRequest.
         * @implements IIncomingMessagesRequest
         * @constructor
         * @param {IIncomingMessagesRequest=} [properties] Properties to set
         */
        function IncomingMessagesRequest(properties) {
            this.messages = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IncomingMessagesRequest messages.
         * @member {Array.<IncomingMessage>} messages
         * @memberof IncomingMessagesRequest
         * @instance
         */
        IncomingMessagesRequest.prototype.messages = $util.emptyArray;

        /**
         * Creates a new IncomingMessagesRequest instance using the specified properties.
         * @function create
         * @memberof IncomingMessagesRequest
         * @static
         * @param {IIncomingMessagesRequest=} [properties] Properties to set
         * @returns {IncomingMessagesRequest} IncomingMessagesRequest instance
         */
        IncomingMessagesRequest.create = function create(properties) {
            return new IncomingMessagesRequest(properties);
        };

        /**
         * Encodes the specified IncomingMessagesRequest message. Does not implicitly {@link IncomingMessagesRequest.verify|verify} messages.
         * @function encode
         * @memberof IncomingMessagesRequest
         * @static
         * @param {IncomingMessagesRequest} message IncomingMessagesRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IncomingMessagesRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.messages != null && message.messages.length)
                for (var i = 0; i < message.messages.length; ++i)
                    $root.IncomingMessage.encode(message.messages[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Decodes an IncomingMessagesRequest message from the specified reader or buffer.
         * @function decode
         * @memberof IncomingMessagesRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {IncomingMessagesRequest} IncomingMessagesRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IncomingMessagesRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.IncomingMessagesRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.messages && message.messages.length))
                        message.messages = [];
                    message.messages.push($root.IncomingMessage.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return IncomingMessagesRequest;
    })();

    $root.IncomingMessage = (function() {

        /**
         * Properties of an IncomingMessage.
         * @exports IIncomingMessage
         * @interface IIncomingMessage
         * @property {Array.<Receiver>|null} [receivers] IncomingMessage receivers
         * @property {Sender|null} [sender] IncomingMessage sender
         * @property {string|null} [body] IncomingMessage body
         * @property {number|null} [expiry] IncomingMessage expiry
         * @property {string|null} [type] IncomingMessage type
         */

        /**
         * Constructs a new IncomingMessage.
         * @exports IncomingMessage
         * @classdesc Represents an IncomingMessage.
         * @implements IIncomingMessage
         * @constructor
         * @param {IIncomingMessage=} [properties] Properties to set
         */
        function IncomingMessage(properties) {
            this.receivers = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IncomingMessage receivers.
         * @member {Array.<Receiver>} receivers
         * @memberof IncomingMessage
         * @instance
         */
        IncomingMessage.prototype.receivers = $util.emptyArray;

        /**
         * IncomingMessage sender.
         * @member {Sender|null|undefined} sender
         * @memberof IncomingMessage
         * @instance
         */
        IncomingMessage.prototype.sender = null;

        /**
         * IncomingMessage body.
         * @member {string} body
         * @memberof IncomingMessage
         * @instance
         */
        IncomingMessage.prototype.body = "";

        /**
         * IncomingMessage expiry.
         * @member {number} expiry
         * @memberof IncomingMessage
         * @instance
         */
        IncomingMessage.prototype.expiry = 0;

        /**
         * IncomingMessage type.
         * @member {string} type
         * @memberof IncomingMessage
         * @instance
         */
        IncomingMessage.prototype.type = "";

        /**
         * Creates a new IncomingMessage instance using the specified properties.
         * @function create
         * @memberof IncomingMessage
         * @static
         * @param {IIncomingMessage=} [properties] Properties to set
         * @returns {IncomingMessage} IncomingMessage instance
         */
        IncomingMessage.create = function create(properties) {
            return new IncomingMessage(properties);
        };

        /**
         * Encodes the specified IncomingMessage message. Does not implicitly {@link IncomingMessage.verify|verify} messages.
         * @function encode
         * @memberof IncomingMessage
         * @static
         * @param {IncomingMessage} message IncomingMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IncomingMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.receivers != null && message.receivers.length)
                for (var i = 0; i < message.receivers.length; ++i)
                    $root.Receiver.encode(message.receivers[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.sender != null && message.hasOwnProperty("sender"))
                $root.Sender.encode(message.sender, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.body != null && message.hasOwnProperty("body"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.body);
            if (message.expiry != null && message.hasOwnProperty("expiry"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.expiry);
            if (message.type != null && message.hasOwnProperty("type"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.type);
            return writer;
        };

        /**
         * Decodes an IncomingMessage message from the specified reader or buffer.
         * @function decode
         * @memberof IncomingMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {IncomingMessage} IncomingMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IncomingMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.IncomingMessage();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.receivers && message.receivers.length))
                        message.receivers = [];
                    message.receivers.push($root.Receiver.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.sender = $root.Sender.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.body = reader.string();
                    break;
                case 4:
                    message.expiry = reader.uint32();
                    break;
                case 5:
                    message.type = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return IncomingMessage;
    })();

    $root.ChannelStatsRequest = (function() {

        /**
         * Properties of a ChannelStatsRequest.
         * @exports IChannelStatsRequest
         * @interface IChannelStatsRequest
         * @property {Array.<ChannelId>|null} [channels] ChannelStatsRequest channels
         */

        /**
         * Constructs a new ChannelStatsRequest.
         * @exports ChannelStatsRequest
         * @classdesc Represents a ChannelStatsRequest.
         * @implements IChannelStatsRequest
         * @constructor
         * @param {IChannelStatsRequest=} [properties] Properties to set
         */
        function ChannelStatsRequest(properties) {
            this.channels = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChannelStatsRequest channels.
         * @member {Array.<ChannelId>} channels
         * @memberof ChannelStatsRequest
         * @instance
         */
        ChannelStatsRequest.prototype.channels = $util.emptyArray;

        /**
         * Creates a new ChannelStatsRequest instance using the specified properties.
         * @function create
         * @memberof ChannelStatsRequest
         * @static
         * @param {IChannelStatsRequest=} [properties] Properties to set
         * @returns {ChannelStatsRequest} ChannelStatsRequest instance
         */
        ChannelStatsRequest.create = function create(properties) {
            return new ChannelStatsRequest(properties);
        };

        /**
         * Encodes the specified ChannelStatsRequest message. Does not implicitly {@link ChannelStatsRequest.verify|verify} messages.
         * @function encode
         * @memberof ChannelStatsRequest
         * @static
         * @param {ChannelStatsRequest} message ChannelStatsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelStatsRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.channels != null && message.channels.length)
                for (var i = 0; i < message.channels.length; ++i)
                    $root.ChannelId.encode(message.channels[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Decodes a ChannelStatsRequest message from the specified reader or buffer.
         * @function decode
         * @memberof ChannelStatsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ChannelStatsRequest} ChannelStatsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelStatsRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ChannelStatsRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.channels && message.channels.length))
                        message.channels = [];
                    message.channels.push($root.ChannelId.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return ChannelStatsRequest;
    })();

    $root.ChannelId = (function() {

        /**
         * Properties of a ChannelId.
         * @exports IChannelId
         * @interface IChannelId
         * @property {Uint8Array|null} [id] ChannelId id
         * @property {boolean|null} [isPrivate] ChannelId isPrivate
         * @property {Uint8Array|null} [signature] ChannelId signature
         */

        /**
         * Constructs a new ChannelId.
         * @exports ChannelId
         * @classdesc Represents a ChannelId.
         * @implements IChannelId
         * @constructor
         * @param {IChannelId=} [properties] Properties to set
         */
        function ChannelId(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChannelId id.
         * @member {Uint8Array} id
         * @memberof ChannelId
         * @instance
         */
        ChannelId.prototype.id = $util.newBuffer([]);

        /**
         * ChannelId isPrivate.
         * @member {boolean} isPrivate
         * @memberof ChannelId
         * @instance
         */
        ChannelId.prototype.isPrivate = false;

        /**
         * ChannelId signature.
         * @member {Uint8Array} signature
         * @memberof ChannelId
         * @instance
         */
        ChannelId.prototype.signature = $util.newBuffer([]);

        /**
         * Creates a new ChannelId instance using the specified properties.
         * @function create
         * @memberof ChannelId
         * @static
         * @param {IChannelId=} [properties] Properties to set
         * @returns {ChannelId} ChannelId instance
         */
        ChannelId.create = function create(properties) {
            return new ChannelId(properties);
        };

        /**
         * Encodes the specified ChannelId message. Does not implicitly {@link ChannelId.verify|verify} messages.
         * @function encode
         * @memberof ChannelId
         * @static
         * @param {ChannelId} message ChannelId message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelId.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && message.hasOwnProperty("id"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.id);
            if (message.isPrivate != null && message.hasOwnProperty("isPrivate"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.isPrivate);
            if (message.signature != null && message.hasOwnProperty("signature"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.signature);
            return writer;
        };

        /**
         * Decodes a ChannelId message from the specified reader or buffer.
         * @function decode
         * @memberof ChannelId
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ChannelId} ChannelId
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelId.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ChannelId();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.bytes();
                    break;
                case 2:
                    message.isPrivate = reader.bool();
                    break;
                case 3:
                    message.signature = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return ChannelId;
    })();

    $root.ServerStatsRequest = (function() {

        /**
         * Properties of a ServerStatsRequest.
         * @exports IServerStatsRequest
         * @interface IServerStatsRequest
         */

        /**
         * Constructs a new ServerStatsRequest.
         * @exports ServerStatsRequest
         * @classdesc Represents a ServerStatsRequest.
         * @implements IServerStatsRequest
         * @constructor
         * @param {IServerStatsRequest=} [properties] Properties to set
         */
        function ServerStatsRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new ServerStatsRequest instance using the specified properties.
         * @function create
         * @memberof ServerStatsRequest
         * @static
         * @param {IServerStatsRequest=} [properties] Properties to set
         * @returns {ServerStatsRequest} ServerStatsRequest instance
         */
        ServerStatsRequest.create = function create(properties) {
            return new ServerStatsRequest(properties);
        };

        /**
         * Encodes the specified ServerStatsRequest message. Does not implicitly {@link ServerStatsRequest.verify|verify} messages.
         * @function encode
         * @memberof ServerStatsRequest
         * @static
         * @param {ServerStatsRequest} message ServerStatsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServerStatsRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes a ServerStatsRequest message from the specified reader or buffer.
         * @function decode
         * @memberof ServerStatsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ServerStatsRequest} ServerStatsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServerStatsRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ServerStatsRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return ServerStatsRequest;
    })();

    $root.Sender = (function() {

        /**
         * Properties of a Sender.
         * @exports ISender
         * @interface ISender
         * @property {SenderType|null} [type] Sender type
         * @property {Uint8Array|null} [id] Sender id
         */

        /**
         * Constructs a new Sender.
         * @exports Sender
         * @classdesc Represents a Sender.
         * @implements ISender
         * @constructor
         * @param {ISender=} [properties] Properties to set
         */
        function Sender(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Sender type.
         * @member {SenderType} type
         * @memberof Sender
         * @instance
         */
        Sender.prototype.type = 0;

        /**
         * Sender id.
         * @member {Uint8Array} id
         * @memberof Sender
         * @instance
         */
        Sender.prototype.id = $util.newBuffer([]);

        /**
         * Creates a new Sender instance using the specified properties.
         * @function create
         * @memberof Sender
         * @static
         * @param {ISender=} [properties] Properties to set
         * @returns {Sender} Sender instance
         */
        Sender.create = function create(properties) {
            return new Sender(properties);
        };

        /**
         * Encodes the specified Sender message. Does not implicitly {@link Sender.verify|verify} messages.
         * @function encode
         * @memberof Sender
         * @static
         * @param {Sender} message Sender message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Sender.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && message.hasOwnProperty("type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            if (message.id != null && message.hasOwnProperty("id"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.id);
            return writer;
        };

        /**
         * Decodes a Sender message from the specified reader or buffer.
         * @function decode
         * @memberof Sender
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Sender} Sender
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Sender.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Sender();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                case 2:
                    message.id = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return Sender;
    })();

    /**
     * SenderType enum.
     * @exports SenderType
     * @enum {string}
     * @property {number} UNKNOWN=0 UNKNOWN value
     * @property {number} CLIENT=1 CLIENT value
     * @property {number} BACKEND=2 BACKEND value
     */
    $root.SenderType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "UNKNOWN"] = 0;
        values[valuesById[1] = "CLIENT"] = 1;
        values[valuesById[2] = "BACKEND"] = 2;
        return values;
    })();

    $root.Receiver = (function() {

        /**
         * Properties of a Receiver.
         * @exports IReceiver
         * @interface IReceiver
         * @property {Uint8Array|null} [id] Receiver id
         * @property {boolean|null} [isPrivate] Receiver isPrivate
         * @property {Uint8Array|null} [signature] Receiver signature
         */

        /**
         * Constructs a new Receiver.
         * @exports Receiver
         * @classdesc Represents a Receiver.
         * @implements IReceiver
         * @constructor
         * @param {IReceiver=} [properties] Properties to set
         */
        function Receiver(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Receiver id.
         * @member {Uint8Array} id
         * @memberof Receiver
         * @instance
         */
        Receiver.prototype.id = $util.newBuffer([]);

        /**
         * Receiver isPrivate.
         * @member {boolean} isPrivate
         * @memberof Receiver
         * @instance
         */
        Receiver.prototype.isPrivate = false;

        /**
         * Receiver signature.
         * @member {Uint8Array} signature
         * @memberof Receiver
         * @instance
         */
        Receiver.prototype.signature = $util.newBuffer([]);

        /**
         * Creates a new Receiver instance using the specified properties.
         * @function create
         * @memberof Receiver
         * @static
         * @param {IReceiver=} [properties] Properties to set
         * @returns {Receiver} Receiver instance
         */
        Receiver.create = function create(properties) {
            return new Receiver(properties);
        };

        /**
         * Encodes the specified Receiver message. Does not implicitly {@link Receiver.verify|verify} messages.
         * @function encode
         * @memberof Receiver
         * @static
         * @param {Receiver} message Receiver message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Receiver.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && message.hasOwnProperty("id"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.id);
            if (message.isPrivate != null && message.hasOwnProperty("isPrivate"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.isPrivate);
            if (message.signature != null && message.hasOwnProperty("signature"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.signature);
            return writer;
        };

        /**
         * Decodes a Receiver message from the specified reader or buffer.
         * @function decode
         * @memberof Receiver
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Receiver} Receiver
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Receiver.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Receiver();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.bytes();
                    break;
                case 2:
                    message.isPrivate = reader.bool();
                    break;
                case 3:
                    message.signature = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return Receiver;
    })();

    $root.ResponseBatch = (function() {

        /**
         * Properties of a ResponseBatch.
         * @exports IResponseBatch
         * @interface IResponseBatch
         * @property {Array.<Response>|null} [responses] ResponseBatch responses
         */

        /**
         * Constructs a new ResponseBatch.
         * @exports ResponseBatch
         * @classdesc Represents a ResponseBatch.
         * @implements IResponseBatch
         * @constructor
         * @param {IResponseBatch=} [properties] Properties to set
         */
        function ResponseBatch(properties) {
            this.responses = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ResponseBatch responses.
         * @member {Array.<Response>} responses
         * @memberof ResponseBatch
         * @instance
         */
        ResponseBatch.prototype.responses = $util.emptyArray;

        /**
         * Creates a new ResponseBatch instance using the specified properties.
         * @function create
         * @memberof ResponseBatch
         * @static
         * @param {IResponseBatch=} [properties] Properties to set
         * @returns {ResponseBatch} ResponseBatch instance
         */
        ResponseBatch.create = function create(properties) {
            return new ResponseBatch(properties);
        };

        /**
         * Encodes the specified ResponseBatch message. Does not implicitly {@link ResponseBatch.verify|verify} messages.
         * @function encode
         * @memberof ResponseBatch
         * @static
         * @param {ResponseBatch} message ResponseBatch message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResponseBatch.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.responses != null && message.responses.length)
                for (var i = 0; i < message.responses.length; ++i)
                    $root.Response.encode(message.responses[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Decodes a ResponseBatch message from the specified reader or buffer.
         * @function decode
         * @memberof ResponseBatch
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ResponseBatch} ResponseBatch
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResponseBatch.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ResponseBatch();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.responses && message.responses.length))
                        message.responses = [];
                    message.responses.push($root.Response.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return ResponseBatch;
    })();

    $root.Response = (function() {

        /**
         * Properties of a Response.
         * @exports IResponse
         * @interface IResponse
         * @property {OutgoingMessagesResponse|null} [outgoingMessages] Response outgoingMessages
         * @property {ChannelStatsResponse|null} [channelStats] Response channelStats
         * @property {JsonResponse|null} [serverStats] Response serverStats
         */

        /**
         * Constructs a new Response.
         * @exports Response
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response outgoingMessages.
         * @member {OutgoingMessagesResponse|null|undefined} outgoingMessages
         * @memberof Response
         * @instance
         */
        Response.prototype.outgoingMessages = null;

        /**
         * Response channelStats.
         * @member {ChannelStatsResponse|null|undefined} channelStats
         * @memberof Response
         * @instance
         */
        Response.prototype.channelStats = null;

        /**
         * Response serverStats.
         * @member {JsonResponse|null|undefined} serverStats
         * @memberof Response
         * @instance
         */
        Response.prototype.serverStats = null;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * Response command.
         * @member {"outgoingMessages"|"channelStats"|"serverStats"|undefined} command
         * @memberof Response
         * @instance
         */
        Object.defineProperty(Response.prototype, "command", {
            get: $util.oneOfGetter($oneOfFields = ["outgoingMessages", "channelStats", "serverStats"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof Response
         * @static
         * @param {IResponse=} [properties] Properties to set
         * @returns {Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link Response.verify|verify} messages.
         * @function encode
         * @memberof Response
         * @static
         * @param {Response} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.outgoingMessages != null && message.hasOwnProperty("outgoingMessages"))
                $root.OutgoingMessagesResponse.encode(message.outgoingMessages, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.channelStats != null && message.hasOwnProperty("channelStats"))
                $root.ChannelStatsResponse.encode(message.channelStats, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.serverStats != null && message.hasOwnProperty("serverStats"))
                $root.JsonResponse.encode(message.serverStats, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.outgoingMessages = $root.OutgoingMessagesResponse.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.channelStats = $root.ChannelStatsResponse.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.serverStats = $root.JsonResponse.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return Response;
    })();

    $root.OutgoingMessagesResponse = (function() {

        /**
         * Properties of an OutgoingMessagesResponse.
         * @exports IOutgoingMessagesResponse
         * @interface IOutgoingMessagesResponse
         * @property {Array.<OutgoingMessage>|null} [messages] OutgoingMessagesResponse messages
         */

        /**
         * Constructs a new OutgoingMessagesResponse.
         * @exports OutgoingMessagesResponse
         * @classdesc Represents an OutgoingMessagesResponse.
         * @implements IOutgoingMessagesResponse
         * @constructor
         * @param {IOutgoingMessagesResponse=} [properties] Properties to set
         */
        function OutgoingMessagesResponse(properties) {
            this.messages = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * OutgoingMessagesResponse messages.
         * @member {Array.<OutgoingMessage>} messages
         * @memberof OutgoingMessagesResponse
         * @instance
         */
        OutgoingMessagesResponse.prototype.messages = $util.emptyArray;

        /**
         * Creates a new OutgoingMessagesResponse instance using the specified properties.
         * @function create
         * @memberof OutgoingMessagesResponse
         * @static
         * @param {IOutgoingMessagesResponse=} [properties] Properties to set
         * @returns {OutgoingMessagesResponse} OutgoingMessagesResponse instance
         */
        OutgoingMessagesResponse.create = function create(properties) {
            return new OutgoingMessagesResponse(properties);
        };

        /**
         * Encodes the specified OutgoingMessagesResponse message. Does not implicitly {@link OutgoingMessagesResponse.verify|verify} messages.
         * @function encode
         * @memberof OutgoingMessagesResponse
         * @static
         * @param {OutgoingMessagesResponse} message OutgoingMessagesResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OutgoingMessagesResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.messages != null && message.messages.length)
                for (var i = 0; i < message.messages.length; ++i)
                    $root.OutgoingMessage.encode(message.messages[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Decodes an OutgoingMessagesResponse message from the specified reader or buffer.
         * @function decode
         * @memberof OutgoingMessagesResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {OutgoingMessagesResponse} OutgoingMessagesResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OutgoingMessagesResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.OutgoingMessagesResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.messages && message.messages.length))
                        message.messages = [];
                    message.messages.push($root.OutgoingMessage.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return OutgoingMessagesResponse;
    })();

    $root.OutgoingMessage = (function() {

        /**
         * Properties of an OutgoingMessage.
         * @exports IOutgoingMessage
         * @interface IOutgoingMessage
         * @property {Uint8Array|null} [id] OutgoingMessage id
         * @property {string|null} [body] OutgoingMessage body
         * @property {number|null} [expiry] OutgoingMessage expiry
         * @property {number|null} [created] OutgoingMessage created
         * @property {Sender|null} [sender] OutgoingMessage sender
         */

        /**
         * Constructs a new OutgoingMessage.
         * @exports OutgoingMessage
         * @classdesc Represents an OutgoingMessage.
         * @implements IOutgoingMessage
         * @constructor
         * @param {IOutgoingMessage=} [properties] Properties to set
         */
        function OutgoingMessage(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * OutgoingMessage id.
         * @member {Uint8Array} id
         * @memberof OutgoingMessage
         * @instance
         */
        OutgoingMessage.prototype.id = $util.newBuffer([]);

        /**
         * OutgoingMessage body.
         * @member {string} body
         * @memberof OutgoingMessage
         * @instance
         */
        OutgoingMessage.prototype.body = "";

        /**
         * OutgoingMessage expiry.
         * @member {number} expiry
         * @memberof OutgoingMessage
         * @instance
         */
        OutgoingMessage.prototype.expiry = 0;

        /**
         * OutgoingMessage created.
         * @member {number} created
         * @memberof OutgoingMessage
         * @instance
         */
        OutgoingMessage.prototype.created = 0;

        /**
         * OutgoingMessage sender.
         * @member {Sender|null|undefined} sender
         * @memberof OutgoingMessage
         * @instance
         */
        OutgoingMessage.prototype.sender = null;

        /**
         * Creates a new OutgoingMessage instance using the specified properties.
         * @function create
         * @memberof OutgoingMessage
         * @static
         * @param {IOutgoingMessage=} [properties] Properties to set
         * @returns {OutgoingMessage} OutgoingMessage instance
         */
        OutgoingMessage.create = function create(properties) {
            return new OutgoingMessage(properties);
        };

        /**
         * Encodes the specified OutgoingMessage message. Does not implicitly {@link OutgoingMessage.verify|verify} messages.
         * @function encode
         * @memberof OutgoingMessage
         * @static
         * @param {OutgoingMessage} message OutgoingMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OutgoingMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && message.hasOwnProperty("id"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.id);
            if (message.body != null && message.hasOwnProperty("body"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.body);
            if (message.expiry != null && message.hasOwnProperty("expiry"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.expiry);
            if (message.created != null && message.hasOwnProperty("created"))
                writer.uint32(/* id 4, wireType 5 =*/37).fixed32(message.created);
            if (message.sender != null && message.hasOwnProperty("sender"))
                $root.Sender.encode(message.sender, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            return writer;
        };

        /**
         * Decodes an OutgoingMessage message from the specified reader or buffer.
         * @function decode
         * @memberof OutgoingMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {OutgoingMessage} OutgoingMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OutgoingMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.OutgoingMessage();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.bytes();
                    break;
                case 2:
                    message.body = reader.string();
                    break;
                case 3:
                    message.expiry = reader.uint32();
                    break;
                case 4:
                    message.created = reader.fixed32();
                    break;
                case 5:
                    message.sender = $root.Sender.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return OutgoingMessage;
    })();

    $root.ChannelStatsResponse = (function() {

        /**
         * Properties of a ChannelStatsResponse.
         * @exports IChannelStatsResponse
         * @interface IChannelStatsResponse
         * @property {Array.<ChannelStats>|null} [channels] ChannelStatsResponse channels
         */

        /**
         * Constructs a new ChannelStatsResponse.
         * @exports ChannelStatsResponse
         * @classdesc Represents a ChannelStatsResponse.
         * @implements IChannelStatsResponse
         * @constructor
         * @param {IChannelStatsResponse=} [properties] Properties to set
         */
        function ChannelStatsResponse(properties) {
            this.channels = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChannelStatsResponse channels.
         * @member {Array.<ChannelStats>} channels
         * @memberof ChannelStatsResponse
         * @instance
         */
        ChannelStatsResponse.prototype.channels = $util.emptyArray;

        /**
         * Creates a new ChannelStatsResponse instance using the specified properties.
         * @function create
         * @memberof ChannelStatsResponse
         * @static
         * @param {IChannelStatsResponse=} [properties] Properties to set
         * @returns {ChannelStatsResponse} ChannelStatsResponse instance
         */
        ChannelStatsResponse.create = function create(properties) {
            return new ChannelStatsResponse(properties);
        };

        /**
         * Encodes the specified ChannelStatsResponse message. Does not implicitly {@link ChannelStatsResponse.verify|verify} messages.
         * @function encode
         * @memberof ChannelStatsResponse
         * @static
         * @param {ChannelStatsResponse} message ChannelStatsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelStatsResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.channels != null && message.channels.length)
                for (var i = 0; i < message.channels.length; ++i)
                    $root.ChannelStats.encode(message.channels[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Decodes a ChannelStatsResponse message from the specified reader or buffer.
         * @function decode
         * @memberof ChannelStatsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ChannelStatsResponse} ChannelStatsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelStatsResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ChannelStatsResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.channels && message.channels.length))
                        message.channels = [];
                    message.channels.push($root.ChannelStats.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return ChannelStatsResponse;
    })();

    $root.ChannelStats = (function() {

        /**
         * Properties of a ChannelStats.
         * @exports IChannelStats
         * @interface IChannelStats
         * @property {Uint8Array|null} [id] ChannelStats id
         * @property {boolean|null} [isPrivate] ChannelStats isPrivate
         * @property {boolean|null} [isOnline] ChannelStats isOnline
         */

        /**
         * Constructs a new ChannelStats.
         * @exports ChannelStats
         * @classdesc Represents a ChannelStats.
         * @implements IChannelStats
         * @constructor
         * @param {IChannelStats=} [properties] Properties to set
         */
        function ChannelStats(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChannelStats id.
         * @member {Uint8Array} id
         * @memberof ChannelStats
         * @instance
         */
        ChannelStats.prototype.id = $util.newBuffer([]);

        /**
         * ChannelStats isPrivate.
         * @member {boolean} isPrivate
         * @memberof ChannelStats
         * @instance
         */
        ChannelStats.prototype.isPrivate = false;

        /**
         * ChannelStats isOnline.
         * @member {boolean} isOnline
         * @memberof ChannelStats
         * @instance
         */
        ChannelStats.prototype.isOnline = false;

        /**
         * Creates a new ChannelStats instance using the specified properties.
         * @function create
         * @memberof ChannelStats
         * @static
         * @param {IChannelStats=} [properties] Properties to set
         * @returns {ChannelStats} ChannelStats instance
         */
        ChannelStats.create = function create(properties) {
            return new ChannelStats(properties);
        };

        /**
         * Encodes the specified ChannelStats message. Does not implicitly {@link ChannelStats.verify|verify} messages.
         * @function encode
         * @memberof ChannelStats
         * @static
         * @param {ChannelStats} message ChannelStats message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelStats.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && message.hasOwnProperty("id"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.id);
            if (message.isPrivate != null && message.hasOwnProperty("isPrivate"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.isPrivate);
            if (message.isOnline != null && message.hasOwnProperty("isOnline"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.isOnline);
            return writer;
        };

        /**
         * Decodes a ChannelStats message from the specified reader or buffer.
         * @function decode
         * @memberof ChannelStats
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ChannelStats} ChannelStats
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelStats.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ChannelStats();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.bytes();
                    break;
                case 2:
                    message.isPrivate = reader.bool();
                    break;
                case 3:
                    message.isOnline = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return ChannelStats;
    })();

    $root.JsonResponse = (function() {

        /**
         * Properties of a JsonResponse.
         * @exports IJsonResponse
         * @interface IJsonResponse
         * @property {string|null} [json] JsonResponse json
         */

        /**
         * Constructs a new JsonResponse.
         * @exports JsonResponse
         * @classdesc Represents a JsonResponse.
         * @implements IJsonResponse
         * @constructor
         * @param {IJsonResponse=} [properties] Properties to set
         */
        function JsonResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * JsonResponse json.
         * @member {string} json
         * @memberof JsonResponse
         * @instance
         */
        JsonResponse.prototype.json = "";

        /**
         * Creates a new JsonResponse instance using the specified properties.
         * @function create
         * @memberof JsonResponse
         * @static
         * @param {IJsonResponse=} [properties] Properties to set
         * @returns {JsonResponse} JsonResponse instance
         */
        JsonResponse.create = function create(properties) {
            return new JsonResponse(properties);
        };

        /**
         * Encodes the specified JsonResponse message. Does not implicitly {@link JsonResponse.verify|verify} messages.
         * @function encode
         * @memberof JsonResponse
         * @static
         * @param {JsonResponse} message JsonResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        JsonResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.json != null && message.hasOwnProperty("json"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.json);
            return writer;
        };

        /**
         * Decodes a JsonResponse message from the specified reader or buffer.
         * @function decode
         * @memberof JsonResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {JsonResponse} JsonResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        JsonResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.JsonResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.json = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return JsonResponse;
    })();

    return $root;
})(
	typeof window==="object" && typeof window.protobuf==='object' && window.protobuf
	|| typeof self==="object" && typeof self.protobuf==='object' && self.protobuf
	|| typeof protobuf==='object' && protobuf
);




// file: /bitrix/js/main/core/core_promise.js
;(function(window)
{
	/****************** ATTENTION *******************************
	 * Please do not use Bitrix CoreJS in this class.
	 * This class can be called on page without Bitrix Framework
	*************************************************************/

	if (!window.BX)
	{
		window.BX = {};
	}

	var BX = window.BX;

	BX.Promise = function(fn, ctx) // fn is future-reserved
	{
		this.state = null;
		this.value = null;
		this.reason = null;
		this.next = null;
		this.ctx = ctx || this;

		this.onFulfilled = [];
		this.onRejected = [];
	};
	BX.Promise.prototype.fulfill = function(value)
	{
		this.checkState();

		this.value = value;
		this.state = true;
		this.execute();
	};
	BX.Promise.prototype.reject = function(reason)
	{
		this.checkState();

		this.reason = reason;
		this.state = false;
		this.execute();
	};
	BX.Promise.prototype.then = function(onFulfilled, onRejected)
	{
		if(typeof (onFulfilled) == "function" || onFulfilled instanceof Function)
		{
			this.onFulfilled.push(onFulfilled);
		}
		if(typeof (onRejected) == "function" || onRejected instanceof Function)
		{
			this.onRejected.push(onRejected);
		}

		if(this.next === null)
		{
			this.next = new BX.Promise(null, this.ctx);
		}

		if(this.state !== null) // if promise was already resolved, execute immediately
		{
			this.execute();
		}

		return this.next;
	};

	BX.Promise.prototype.catch = function(onRejected)
	{
		if(typeof (onRejected) == "function" || onRejected instanceof Function)
		{
			this.onRejected.push(onRejected);
		}

		if(this.next === null)
		{
			this.next = new BX.Promise(null, this.ctx);
		}

		if(this.state !== null) // if promise was already resolved, execute immediately
		{
			this.execute();
		}

		return this.next;
	};

	BX.Promise.prototype.setAutoResolve = function(way, ms)
	{
		this.timer = setTimeout(function(){
			if(this.state === null)
			{
				this[way ? 'fulfill' : 'reject']();
			}
		}.bind(this), ms || 15);
	};
	BX.Promise.prototype.cancelAutoResolve = function()
	{
		clearTimeout(this.timer);
	};
	/**
	 * Resolve function. This function allows promise chaining, like ..then().then()...
	 * Typical usage:
	 *
	 * var p = new Promise();
	 *
	 * p.then(function(value){
	 *  return someValue; // next promise in the chain will be fulfilled with someValue
	 * }).then(function(value){
	 *
	 *  var p1 = new Promise();
	 *  *** some async code here, that eventually resolves p1 ***
	 *
	 *  return p1; // chain will resume when p1 resolved (fulfilled or rejected)
	 * }).then(function(value){
	 *
	 *  // you can also do
	 *  var e = new Error();
	 *  throw e;
	 *  // it will cause next promise to be rejected with e
	 *
	 *  return someOtherValue;
	 * }).then(function(value){
	 *  ...
	 * }, function(reason){
	 *  // promise was rejected with reason
	 * })...;
	 *
	 * p.fulfill('let`s start this chain');
	 *
	 * @param x
	 */
	BX.Promise.prototype.resolve = function(x)
	{
		var this_ = this;

		if(this === x)
		{
			this.reject(new TypeError('Promise cannot fulfill or reject itself')); // avoid recursion
		}
		// allow "pausing" promise chaining until promise x is fulfilled or rejected
		else if(x && x.toString() === "[object BX.Promise]")
		{
			x.then(function(value){
				this_.fulfill(value);
			}, function(reason){
				this_.reject(reason);
			});
		}
		else // auto-fulfill this promise
		{
			this.fulfill(x);
		}
	};

	BX.Promise.prototype.toString = function()
	{
		return "[object BX.Promise]";
	};

	BX.Promise.prototype.execute = function()
	{
		if(this.state === null)
		{
			//then() must not be called before BX.Promise resolve() happens
			return;
		}

		var value = undefined;
		var reason = undefined;
		var x = undefined;
		var k;
		if(this.state === true) // promise was fulfill()-ed
		{
			if(this.onFulfilled.length)
			{
				try
				{
					for(k = 0; k < this.onFulfilled.length; k++)
					{
						x = this.onFulfilled[k].apply(this.ctx, [this.value]);
						if(typeof x != 'undefined')
						{
							value = x;
						}
					}
				}
				catch(e)
				{
					if('console' in window)
					{
						console.dir(e);
					}

					if (typeof BX.debug !== 'undefined')
					{
						BX.debug(e);
					}

					reason = e; // reject next
				}
			}
			else
			{
				value = this.value; // resolve next
			}
		}
		else if(this.state === false) // promise was reject()-ed
		{
			if(this.onRejected.length)
			{
				try
				{
					for(k = 0; k < this.onRejected.length; k++)
					{
						x = this.onRejected[k].apply(this.ctx, [this.reason]);
						if(typeof x != 'undefined')
						{
							value = x;
						}
					}
				}
				catch(e)
				{
					if('console' in window)
					{
						console.dir(e);
					}

					if (typeof BX.debug !== 'undefined')
					{
						BX.debug(e);
					}

					reason = e; // reject next
				}
			}
			else
			{
				reason = this.reason; // reject next
			}
		}

		if(this.next !== null)
		{
			if(typeof reason != 'undefined')
			{
				this.next.reject(reason);
			}
			else if(typeof value != 'undefined')
			{
				this.next.resolve(value);
			}
		}
	};
	BX.Promise.prototype.checkState = function()
	{
		if(this.state !== null)
		{
			throw new Error('You can not do fulfill() or reject() multiple times');
		}
	};
})(window);





// file: /bitrix/js/rest/client/rest.client.js
'use strict';

;(function(){

	/************************ ATTENTION ***************************
	 * Please do not use Bitrix CoreJS in this class.            *
	 * This class can be called on page without Bitrix Framework *
	**************************************************************/

	if (!window.BX)
	{
		window.BX = {};
	}
	else if (window.BX.RestClient)
	{
		return;
	}

	var BX = window.BX;

	BX.RestClient = function (options)
	{
		options = options || {};

		this.endpoint = options.endpoint || '/rest';
		this.queryParams = options.queryParams || '';
		this.cors = options.cors === true;
	};

	BX.RestClient.prototype.callMethod = function(method, params, callback, sendCallback, logTag)
	{
		return ajax({
			method: method,
			data: params,
			callback: callback,
			sendCallback: sendCallback,
			logTag: logTag,
			endpoint: this.endpoint,
			queryParams: this.queryParams,
			cors: this.cors
		});
	};

	/*
	calls = [[method,params],[method,params]];
	calls = [{method:method,params:params},[method,params]];
	calls = {call_id:[method,params],...};
	*/
	BX.RestClient.prototype.callBatch = function(calls, callback, bHaltOnError, sendCallback, logTag)
	{
		var cmd = Utils.isArray(calls) ? [] : {};
		var cnt = 0;
		var cb = function(cmd) {
			ajax.batch(cmd, callback, bHaltOnError, sendCallback, this.endpoint, this.queryParams, this.cors, logTag);
		}.bind(this);

		for(var i in calls)
		{
			var method = null, params = null;

			if(!!calls[i] && calls.hasOwnProperty(i))
			{
				if(Utils.isArray(calls[i]))
				{
					method = calls[i][0];
					params = calls[i][1];
				}
				else if(!!calls[i].method)
				{
					method = calls[i].method;
					params = calls[i].params;
				}

				if(!!method)
				{
					cnt++;
					cmd[i] = [method, params];
				}
			}
		}

		if(cnt > 0)
		{
			var e = function(i)
			{
				return function(str)
				{
					cmd[i] = cmd[i][0] + '?' + str;
					if(--cnt <= 0)
						cb(cmd);
				}
			};

			for(var c in cmd)
			{
				if(cmd.hasOwnProperty(c))
				{
					ajax.prepareData(cmd[c][1], '', e(c));
				}
			}
		}
	};

	BX.RestClient.prototype.setEndpoint = function(url)
	{
		this.endpoint = url;
	};

	BX.RestClient.prototype.enableCorsRequest = function(value)
	{
		this.cors = value === true;
	};

	BX.RestClient.prototype.setQueryParams = function(params)
	{
		this.queryParams = params;
	};

	/* self init for bitrix env */
	if (typeof BX.namespace !== 'undefined')
	{
		var BXRest = new BX.RestClient();

		if (typeof BX.rest == 'undefined')
		{
			BX.rest = {};
		}

		BX.rest.callMethod = function (method, params, callback, sendCallback, logTag)
		{
			return BXRest.callMethod(method, params, callback, sendCallback, logTag);
		};

		/*
		calls = [[method,params],[method,params]];
		calls = [{method:method,params:params},[method,params]];
		calls = {call_id:[method,params],...};
		*/
		BX.rest.callBatch = function (calls, callback, bHaltOnError, sendCallback, logTag)
		{
			return BXRest.callBatch(calls, callback, bHaltOnError, sendCallback, logTag);
		};
	}

	var Utils = {
		isArray: function(item) {
			return item && Object.prototype.toString.call(item) == "[object Array]";
		},
		isFunction: function(item) {
			return item === null ? false : (typeof (item) == "function" || item instanceof Function);
		},
		isString: function(item) {
			return item === '' ? true : (item ? (typeof (item) == "string" || item instanceof String) : false);
		},
		isDomNode: function(item) {
			return item && typeof (item) == "object" && "nodeType" in item;
		},
		isDate: function(item) {
			return item && Object.prototype.toString.call(item) == "[object Date]";
		},
		buildQueryString: function(params)
		{
			var result = '';
			for (var key in params)
			{
				if (!params.hasOwnProperty(key))
				{
					continue;
				}
				var value = params[key];
				if(this.isArray(value))
				{
					value.forEach(function(valueElement, index)
					{
						result += encodeURIComponent(key + "[" + index + "]") + "=" + encodeURIComponent(valueElement) + "&";
					});
				}
				else
				{
					result += encodeURIComponent(key) + "=" + encodeURIComponent(value) + "&";
				}
			}

			if(result.length > 0)
			{
				result = result.substr(0, result.length - 1);
			}
			return result;
		},
		clone: function(obj, bCopyObj)
		{
			var _obj, i, l;
			if (bCopyObj !== false)
				bCopyObj = true;

			if (obj === null)
				return null;

			if (this.isDomNode(obj))
			{
				_obj = obj.cloneNode(bCopyObj);
			}
			else if (typeof obj == 'object')
			{
				if (this.isArray(obj))
				{
					_obj = [];
					for (i=0,l=obj.length;i<l;i++)
					{
						if (typeof obj[i] == "object" && bCopyObj)
							_obj[i] = this.clone(obj[i], bCopyObj);
						else
							_obj[i] = obj[i];
					}
				}
				else
				{
					_obj =  {};
					if (obj.constructor)
					{
						if (this.isDate(obj))
							_obj = new Date(obj);
						else
							_obj = new obj.constructor();
					}

					for (i in obj)
					{
						if (typeof obj[i] == "object" && bCopyObj)
							_obj[i] = this.clone(obj[i], bCopyObj);
						else
							_obj[i] = obj[i];
					}
				}

			}
			else
			{
				_obj = obj;
			}

			return _obj;
		}
	};

	var ajax = function(config)
	{
		var hasCallback = !!config.callback && Utils.isFunction(config.callback);
		var promise = typeof BX.Promise === 'undefined' || hasCallback? null: new BX.Promise();
		var sendCallback = config.sendCallback || function() {};
		var withoutRestoringCsrf = config.withoutRestoringCsrf || false;
		var loginAttempt = config.loginAttempt || 0;

		var xhr = ajax.xhr();

		var url = config.endpoint + '/' + ajax.escape(config.method) + '.json'+(config.logTag? '?logTag='+config.logTag: '');

		xhr.open('POST', url);
		xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');

		if (config.cors)
		{
			xhr.withCredentials = true;
		}

		var bRequestCompleted = false;

		// IE fix
		xhr.onprogress = function(){};
		xhr.ontimeout = function(){};
		xhr.timeout = 0;

		xhr.onload = function()
		{
			if(bRequestCompleted)
				return;

			xhr.onload = function() {};

			var bSuccess = ajax.isSuccess(xhr);

			var status = xhr.status;
			if(bSuccess)
			{
				var data = xhr.responseText;

				if(data.length > 0)
				{
					try
					{
						data = JSON.parse(data);
					}
					catch(e)
					{
						bSuccess = false;
					}
				}

				if (status == 401)
				{
					if (data.extended_error === 'user_not_authorized' && loginAttempt === 0)
					{
						if (data.sessid)
						{
							console.warn('BX.rest: csrf-token has expired, replace to a new token');
							BX.message({'bitrix_sessid': data.sessid});
						}

						if('BXDesktopSystem' in window)
						{
							console.warn('BX.rest: you are not authorized, trying to log in');
							config.loginAttempt = 1;
							BXDesktopSystem.Login({
								// todo: support auth failure callback in future (when it is ready)
								success: function()
								{
									console.warn('BX.rest: successfully logged in, repeating request');
									if (!hasCallback)
									{
										config.callback = function(result)
										{
											if (result.error())
											{
												promise.reject(result);
											}
											else
											{
												promise.fulfill(result);
											}
										}
									}
									ajax(config);
								}
							});
							return true;
						}
					}
					else if (data.sessid && !withoutRestoringCsrf)
					{
						BX.message({'bitrix_sessid': data.sessid});
						console.warn('BX.rest: your csrf-token has expired, send query with a new token');

						config.withoutRestoringCsrf = true;

						if (!hasCallback)
						{
							config.callback = function(result)
							{
								if (result.error())
								{
									promise.reject(result);
								}
								else
								{
									promise.fulfill(result);
								}
							}
						}
						ajax(config);

						return true;
					}
				}
				else if (status == 0)
				{
					data = {result: {}, error: "ERROR_NETWORK", error_description: "A network error occurred while the request was being executed."};
				}
				else
				{
					if (status == 200)
					{
						if (data.length <= 0)
						{
							data = {result: {}, error: "BLANK_ANSWER", error_description: "Empty answer with correct http code, network error possible."};
						}
					}
					else if (data.length <= 0)
					{
						data = {result: {}, error: "BLANK_ANSWER_WITH_ERROR_CODE", error_description: 'Empty answer with error http code: '+status};
					}
				}
			}

			xhr = null;
			if(bSuccess)
			{
				var res = new ajaxResult(data, config, status);
				if(hasCallback)
				{
					config.callback.apply(window, [res]);
				}
				else
				{
					if (res.error())
					{
						promise.reject(res);
					}
					else
					{
						promise.fulfill(res);
					}
				}
			}
			else
			{
				var res = new ajaxResult({
					error: "ERROR_UNEXPECTED_ANSWER",
					error_description: "Server returned an unexpected response.",
					ex: {}
				}, config, 0);
				if(hasCallback)
				{
					config.callback.apply(window, [res]);
				}
				else
				{
					promise.reject(res);
				}
			}
		};

		xhr.onerror = function(e)
		{
			var res = new ajaxResult({
				error: "ERROR_NETWORK",
				error_description: "A network error occurred while the request was being executed.",
				ex: e
			}, config, 0);
			if(hasCallback)
			{
				config.callback.apply(window, [res]);
			}
			else
			{
				promise.reject(res);
			}
		};

		var query_data = '';
		if (config.queryParams)
		{
			query_data = Utils.buildQueryString(config.queryParams);
		}
		else if (typeof BX.bitrix_sessid !== 'undefined')
		{
			query_data = 'sessid=' + BX.bitrix_sessid();
		}

		if(typeof config.start !== 'undefined')
		{
			query_data += '&start=' + parseInt(config.start);
		}

		if(!!config.data)
		{
			ajax.prepareData(config.data, '', function(res)
			{
				query_data += '&' + res;
				xhr.send(query_data);
				sendCallback(xhr);
			});
		}
		else
		{
			xhr.send(query_data);
			sendCallback(xhr);
		}

		return hasCallback || !promise? xhr: promise;
	};

	ajax.batch = function(calls, callback, bHaltOnError, sendCallback, endpoint, queryParams, cors, logTag)
	{
		return ajax({
			method: 'batch',
			data: {halt: !!bHaltOnError ? 1 : 0, cmd: calls},
			callback: function(res, config, status)
			{
				if(!callback)
				{
					return false;
				}

				var error = res.error();
				var data = res.data();
				var result = Utils.isArray(calls) ? [] : {};

				for(var i in calls)
				{
					if(!!calls[i] && calls.hasOwnProperty(i))
					{
						if(Utils.isString(calls[i]))
						{
							var q = calls[i].split('?');
						}
						else
						{
							q = [
								Utils.isArray(calls[i]) ? calls[i][0] : calls[i].method,
								Utils.isArray(calls[i]) ? calls[i][1] : calls[i].data
							];
						}

						if (
							data
							&& typeof data.result !== 'undefined'
							&& (
								typeof data.result[i] !== 'undefined'
								|| typeof data.result_error[i] !== 'undefined'
							)
						)
						{
							result[i] = new ajaxResult({
								result: typeof data.result[i] !== 'undefined' ? data.result[i] : {},
								error: data.result_error[i] || undefined,
								total: data.result_total[i],
								time: data.result_time[i],
								next: data.result_next[i]
							}, {
								method: q[0],
								data: q[1],
								callback: callback,
								endpoint: endpoint,
								queryParams: queryParams,
								cors: cors
							}, res.status);
						}
						else if (error)
						{
							result[i] = new ajaxResult({
								result: {},
								error: error.ex,
								total: 0
							}, {
								method: q[0],
								data: q[1],
								callback: callback,
								endpoint: endpoint,
								queryParams: queryParams,
								cors: cors
							}, res.status);
						}
					}
				}

				callback.apply(window, [result]);
			},
			sendCallback: sendCallback,
			endpoint: endpoint,
			queryParams: queryParams,
			cors: cors,
			logTag: logTag
		});
	};

	ajax.xhr = function()
	{
		return new XMLHttpRequest();
	};

	ajax.escape = function(str)
	{
		return encodeURIComponent(str);
	};

	ajax.prepareData = function(arData, prefix, callback)
	{
		var data = '', objects = [];
		if(Utils.isString(arData) || arData === null)
		{
			callback.call(document, arData || '');
		}
		else
		{
			for(var i in arData)
			{
				if(!arData.hasOwnProperty(i))
				{
					continue;
				}

				var name = ajax.escape(i);

				if(prefix)
					name = prefix + '[' + name + ']';

				if(typeof arData[i] === 'object')
				{
					if(Utils.isArray(arData[i]) && arData[i].length <= 0)
					{
						continue;
					}

					objects.push([name, arData[i]]);
				}
				else
				{
					if(data.length > 0)
					{
						data += '&';
					}

					if(typeof arData[i] === 'boolean')
					{
						data += name + '=' + (arData[i]? 1: 0);
					}
					else
					{
						data += name + '=' + ajax.escape(arData[i])
					}
				}
			}

			var cnt = objects.length;
			if(cnt > 0)
			{
				var cb = function(str)
				{
					data += (!!str ? '&' : '') + str;
					if(--cnt <= 0)
					{
						callback.call(document, data)
					}
				};

				var cnt1 = cnt;
				for(var i = 0; i < cnt1; i++)
				{
					if(Utils.isDomNode(objects[i][1]))
					{
						if(objects[i][1].tagName.toUpperCase() === 'INPUT' && objects[i][1].type === 'file')
						{
							if(fileReader.canUse())
							{
								fileReader(objects[i][1], (function(name)
								{
									return function(result)
									{
										if(Utils.isArray(result) && result.length > 0)
										{
											cb(name + '[0]=' + ajax.escape(result[0]) + '&' + name + '[1]=' + ajax.escape(result[1]));
										}
										else
										{
											cb(name + '=');
										}
									}
								})(objects[i][0]));
							}
						}
						else if(typeof objects[i][1].value !== 'undefined')
						{
							cb(objects[i][0] + '=' + ajax.escape(objects[i][1].value));
						}
						else
						{
							cb('');
						}
					}
					else if(Utils.isDate(objects[i][1]))
					{
						cb(objects[i][0] + '=' + ajax.escape(objects[i][1].toJSON()));
					}
					else if(Utils.isArray(objects[i][1]) && objects[i][1].length <= 0)
					{
						cb(objects[i][0] + '=');
					}
					else
					{
						ajax.prepareData(objects[i][1], objects[i][0], cb);
					}
				}
			}
			else
			{
				callback.call(document, data)
			}
		}
	};

	ajax.isSuccess = function(xhr)
	{
		return typeof xhr.status === 'undefined' || (xhr.status >= 200 && xhr.status < 300) || xhr.status === 304 || xhr.status >= 400 && xhr.status < 500 || xhr.status === 1223 || xhr.status === 0;
	};

	var ajaxResult = function(answer, query, status)
	{
		this.answer = answer;
		this.query = Utils.clone(query);
		this.status = status;

		if(typeof this.answer.next !== 'undefined')
		{
			this.answer.next = parseInt(this.answer.next);
		}

		if(typeof this.answer.error !== 'undefined')
		{
			this.answer.ex = new ajaxError(this.status, typeof this.answer.error === 'string' ? this.answer : this.answer.error)
		}
	};

	ajaxResult.prototype.data = function()
	{
		return this.answer.result;
	};

	ajaxResult.prototype.time = function()
	{
		return this.answer.time;
	};

	ajaxResult.prototype.error = function()
	{
		return this.answer.ex;
	};

	ajaxResult.prototype.error_description = function()
	{
		return this.answer.error_description;
	};

	ajaxResult.prototype.more = function()
	{
		return !isNaN(this.answer.next);
	};

	ajaxResult.prototype.total = function()
	{
		return parseInt(this.answer.total);
	};

	ajaxResult.prototype.next = function(cb)
	{
		if(this.more())
		{
			this.query.start = this.answer.next;

			if(!!cb && Utils.isFunction(cb))
			{
				this.query.callback = cb;
			}

			return ajax(this.query);
		}

		return false;
	};

	var ajaxError = function(status, ex)
	{
		this.status = status;
		this.ex = ex;
	};

	ajaxError.prototype.getError = function()
	{
		return this.ex;
	};

	ajaxError.prototype.getStatus = function()
	{
		return this.status;
	};

	ajaxError.prototype.toString = function()
	{
		return this.ex.error + (
			!!this.ex.error_description
				? ': ' + this.ex.error_description
				: ''
		) + ' (' + this.status + ')';
	};

	var arrayBufferToData = function(arrayBuffer)
	{
		var uint8 = new Uint8Array(arrayBuffer);
		var data = '';

		// TypedArray.prototype.forEach is not supported in some browsers as IE.
		if (typeof uint8.forEach === 'function')
		{
			uint8.forEach(function (value)
			{
				data += String.fromCharCode(value);
			});
		}
		else
		{
			var length = uint8.length;
			for (var i = 0; i < length; i += 1)
			{
				data += String.fromCharCode(uint8[i]);
			}
		}
		return btoa(data);
	};

	var fileReader = function(fileInput, cb)
	{
		if(fileReader.canUse())
		{
			var files = fileInput.files,
				len = 0,
				result = fileInput.multiple ? [] : null;

			for(var i = 0, f; f = files[i]; i++)
			{
				var reader = new window.FileReader();

				reader.BXFILENAME = files[i].name;

				reader.onload = function(e)
				{
					e = e || window.event;

					var res = [this.BXFILENAME, arrayBufferToData(e.target.result)];

					if(result === null)
						result = res;
					else
						result.push(res);

					if(--len <= 0)
					{
						cb(result);
					}
				};

				reader.readAsArrayBuffer(f);
			}
			len = i;
			if(len <= 0)
			{
				cb(result);
			}
		}
	};

	fileReader.canUse = function()
	{
		return !!window.FileReader;
	};

})();



// file: /bitrix/js/pull/client/pull.client.js
;(function()
{
	/**
	 * Bitrix Push & Pull
	 * Pull client
	 *
	 * @package bitrix
	 * @subpackage pull
	 * @copyright 2001-2019 Bitrix
	 */

	/****************** ATTENTION *******************************
	 * Please do not use Bitrix CoreJS in this class.
	 * This class can be called on a page without Bitrix Framework
	*************************************************************/

	if (!window.BX)
	{
		window.BX = {};
	}
	else if (window.BX.PullClient)
	{
		return;
	}
	else if (!window.BX.RestClient)
	{
		return;
	}

	var BX = window.BX;
	var protobuf = window.protobuf;

	var REVISION = 19; // api revision - check module/pull/include.php
	var LONG_POLLING_TIMEOUT = 60;
	var RESTORE_WEBSOCKET_TIMEOUT = 30 * 60;
	var CONFIG_TTL = 24 * 60 * 60;
	var CONFIG_CHECK_INTERVAL = 60000;
	var MAX_IDS_TO_STORE = 10;

	var LS_SESSION = "bx-pull-session";
	var LS_SESSION_CACHE_TIME = 20;

	var ConnectionType = {
		WebSocket: 'webSocket',
		LongPolling: 'longPolling'
	};

	var PullStatus = {
		Online: 'online',
		Offline: 'offline',
		Connecting: 'connect'
	};

	var SenderType = {
		Unknown: 0,
		Client: 1,
		Backend: 2
	};

	var SubscriptionType = {
		Server: 'server',
		Client: 'client',
		Online: 'online',
		Status: 'status',
		Revision: 'revision'
	};

	var CloseReasons = {
		NORMAL_CLOSURE : 1000,
		SERVER_DIE : 1001,
		CONFIG_REPLACED : 3000,
		CHANNEL_EXPIRED : 3001,
		SERVER_RESTARTED : 3002,
		CONFIG_EXPIRED : 3003,
		MANUAL : 3004,
	};

	var SystemCommands = {
		CHANNEL_EXPIRE: 'CHANNEL_EXPIRE',
		CONFIG_EXPIRE: 'CONFIG_EXPIRE',
		SERVER_RESTART:'SERVER_RESTART'
	};

	var ServerMode = {
		Shared: 'shared',
		Personal: 'personal'
	};

	// Protobuf message models
	var Response = protobuf.roots['push-server']['Response'];
	var ResponseBatch = protobuf.roots['push-server']['ResponseBatch'];
	var Request = protobuf.roots['push-server']['Request'];
	var RequestBatch = protobuf.roots['push-server']['RequestBatch'];
	var IncomingMessagesRequest = protobuf.roots['push-server']['IncomingMessagesRequest'];
	var IncomingMessage = protobuf.roots['push-server']['IncomingMessage'];
	var Receiver = protobuf.roots['push-server']['Receiver'];

	var Pull = function (params)
	{
		params = params || {};

		if (params.restApplication)
		{
			if (typeof params.configGetMethod === 'undefined')
			{
				params.configGetMethod = 'pull.application.config.get';
			}
			if (typeof params.skipCheckRevision === 'undefined')
			{
				params.skipCheckRevision = true;
			}
			if (typeof params.restApplication === 'string')
			{
				params.siteId = params.restApplication;
			}

			params.serverEnabled = true;
		}

		var self = this;

		this.context = 'master';

		this.guestMode = params.guestMode? params.guestMode: (typeof BX.message !== 'undefined' && BX.message.pull_guest_mode? BX.message.pull_guest_mode === 'Y': false);
		this.guestUserId = params.guestUserId? params.guestUserId: (typeof BX.message !== 'undefined' && BX.message.pull_guest_user_id? parseInt(BX.message.pull_guest_user_id, 10): 0);
		if(this.guestMode && this.guestUserId)
		{
			this.userId = this.guestUserId;
		}
		else
		{
			this.userId = params.userId? params.userId: (typeof BX.message !== 'undefined' && BX.message.USER_ID? BX.message.USER_ID: 0);
		}

		this.siteId = params.siteId? params.siteId: (typeof BX.message !== 'undefined' && BX.message.SITE_ID? BX.message.SITE_ID: 'none');
		this.restClient = typeof params.restClient !== "undefined"? params.restClient: new BX.RestClient(this.getRestClientOptions());

		this.enabled = typeof params.serverEnabled !== 'undefined'? (params.serverEnabled === 'Y' || params.serverEnabled === true): (typeof BX.message !== 'undefined' && BX.message.pull_server_enabled === 'Y');
		this.unloading = false;
		this.starting = false;
		this.debug = false;
		this.connectionAttempt = 0;
		this.connectionType = '';
		this.reconnectTimeout = null;
		this.restoreWebSocketTimeout = null;

		this.configGetMethod = typeof params.configGetMethod !== 'string'? 'pull.config.get': params.configGetMethod;
		this.getPublicListMethod = typeof params.getPublicListMethod !== 'string'? 'pull.channel.public.list': params.getPublicListMethod;

		this.skipStorageInit = params.skipStorageInit === true;

		this.skipCheckRevision = params.skipCheckRevision === true;

		this._subscribers = {};

		this.watchTagsQueue = {};
		this.watchUpdateInterval = 1740000;
		this.watchForceUpdateInterval = 5000;

		if (typeof params.configTimestamp !== 'undefined')
		{
			this.configTimestamp = params.configTimestamp;
		}
		else if (typeof BX.message !== 'undefined' && BX.message.pull_config_timestamp)
		{
			this.configTimestamp = BX.message.pull_config_timestamp;
		}
		else
		{
			this.configTimestamp = 0;
		}

		this.session = {
			mid : null,
			tag : null,
			time : null,
			history: {},
			lastMessageIds: [],
			messageCount: 0
		};

		this._connectors = {
			webSocket: null,
			longPolling: null
		};

		Object.defineProperty(this, "connector", {
			get: function()
			{
				return self._connectors[self.connectionType];
			}
		});

		this.isSecure = document.location.href.indexOf('https') === 0;
		this.config = null;

		this.storage = null;

		if(this.userId && !this.skipStorageInit)
		{
			this.storage = new StorageManager({
				userId: this.userId,
				siteId: this.siteId
			});
		}

		this.sharedConfig = new SharedConfig({
			onWebSocketBlockChanged: this.onWebSocketBlockChanged.bind(this),
			storage: this.storage
		});
		this.channelManager = new ChannelManager({
			restClient: this.restClient,
			getPublicListMethod: this.getPublicListMethod
		});

		this.notificationPopup = null;

		// timers
		this.checkInterval = null;
		this.offlineTimeout = null;

		// manual stop workaround
		this.isManualDisconnect = false;

		this.loggingEnabled = this.sharedConfig.isLoggingEnabled();
	};

	/**
	 * Creates a subscription to incoming messages.
	 *
	 * @param {Object} params
	 * @param {string} [params.type] Subscription type (for possible values see SubscriptionType).
	 * @param {string} [params.moduleId] Name of the module.
	 * @param {Function} params.callback Function, that will be called for incoming messages.
	 * @returns {Function} - Unsubscribe callback function
	 */
	Pull.prototype.subscribe = function(params)
	{
		/**
		 * After modify this method, copy to follow scripts:
		 * mobile/install/mobileapp/mobile/extensions/bitrix/pull/client/events/extension.js
		 * mobile/install/js/mobile/pull/client/src/client.js
		 */

		if (!params)
		{
			console.error(Utils.getDateForLog() + ': Pull.subscribe: params for subscribe function is invalid. ');
			return function(){}
		}

		if (!Utils.isPlainObject(params))
		{
			return this.attachCommandHandler(params);
		}

		params = params || {};
		params.type = params.type || SubscriptionType.Server;
		params.command = params.command || null;

		if (params.type == SubscriptionType.Server || params.type == SubscriptionType.Client)
		{
			if (typeof (this._subscribers[params.type]) === 'undefined')
			{
				this._subscribers[params.type] = {};
			}
			if (typeof (this._subscribers[params.type][params.moduleId]) === 'undefined')
			{
				this._subscribers[params.type][params.moduleId] = {
					'callbacks': [],
					'commands': {},
				};
			}

			if (params.command)
			{
				if (typeof (this._subscribers[params.type][params.moduleId]['commands'][params.command]) === 'undefined')
				{
					this._subscribers[params.type][params.moduleId]['commands'][params.command] = [];
				}

				this._subscribers[params.type][params.moduleId]['commands'][params.command].push(params.callback);

				return function () {
					this._subscribers[params.type][params.moduleId]['commands'][params.command] = this._subscribers[params.type][params.moduleId]['commands'][params.command].filter(function(element) {
						return element !== params.callback;
					});
				}.bind(this);
			}
			else
			{
				this._subscribers[params.type][params.moduleId]['callbacks'].push(params.callback);

				return function () {
					this._subscribers[params.type][params.moduleId]['callbacks'] = this._subscribers[params.type][params.moduleId]['callbacks'].filter(function(element) {
						return element !== params.callback;
					});
				}.bind(this);
			}
		}
		else
		{
			if (typeof (this._subscribers[params.type]) === 'undefined')
			{
				this._subscribers[params.type] = [];
			}

			this._subscribers[params.type].push(params.callback);

			return function () {
				this._subscribers[params.type] = this._subscribers[params.type].filter(function(element) {
					return element !== params.callback;
				});
			}.bind(this);
		}
	};

	Pull.prototype.attachCommandHandler = function(handler)
	{
		/**
		 * After modify this method, copy to follow scripts:
		 * mobile/install/mobileapp/mobile/extensions/bitrix/pull/client/extension.js
		 */
		if (typeof handler.getModuleId !== 'function' || typeof handler.getModuleId() !== 'string')
		{
			console.error(Utils.getDateForLog() + ': Pull.attachCommandHandler: result of handler.getModuleId() is not a string.');
			return function(){}
		}

		var type = SubscriptionType.Server;
		if (typeof handler.getSubscriptionType === 'function')
		{
			type = handler.getSubscriptionType();
		}

		this.subscribe({
			type: type,
			moduleId: handler.getModuleId(),
			callback: function(data)
			{
				var method = null;

				if (typeof handler.getMap === 'function')
				{
					var mapping = handler.getMap();
					if (mapping && typeof mapping === 'object')
					{
						if (typeof mapping[data.command] === 'function')
						{
							method = mapping[data.command].bind(handler)
						}
						else if (typeof mapping[data.command] === 'string' && typeof handler[mapping[data.command]] === 'function')
						{
							method = handler[mapping[data.command]].bind(handler);
						}
					}
				}

				if (!method)
				{
					var methodName = 'handle'+data.command.charAt(0).toUpperCase() + data.command.slice(1);
					if (typeof handler[methodName] === 'function')
					{
						method = handler[methodName].bind(handler);
					}
				}

				if (method)
				{
					if (this.debug && this.context !== 'master')
					{
						console.warn(Utils.getDateForLog() + ': Pull.attachCommandHandler: receive command', data);
					}
					method(data.params, data.extra, data.command);
				}
			}.bind(this)
		});
	};

	/**
	 *
	 * @param params {Object}
	 * @returns {boolean}
	 */
	Pull.prototype.emit = function(params)
	{
		/**
		 * After modify this method, copy to follow scripts:
		 * mobile/install/mobileapp/mobile/extensions/bitrix/pull/client/events/extension.js
		 * mobile/install/js/mobile/pull/client/src/client.js
		 */
		params = params || {};

		if (params.type == SubscriptionType.Server || params.type == SubscriptionType.Client)
		{
			if (typeof (this._subscribers[params.type]) === 'undefined')
			{
				this._subscribers[params.type] = {};
			}
			if (typeof (this._subscribers[params.type][params.moduleId]) === 'undefined')
			{
				this._subscribers[params.type][params.moduleId] = {
					'callbacks': [],
					'commands': {},
				};
			}

			if (this._subscribers[params.type][params.moduleId]['callbacks'].length > 0)
			{
				this._subscribers[params.type][params.moduleId]['callbacks'].forEach(function(callback){
					callback(params.data, {type: params.type, moduleId: params.moduleId});
				});
			}

			if (
				this._subscribers[params.type][params.moduleId]['commands'][params.data.command]
				&& this._subscribers[params.type][params.moduleId]['commands'][params.data.command].length > 0)
			{
				this._subscribers[params.type][params.moduleId]['commands'][params.data.command].forEach(function(callback){
					callback(params.data.params, params.data.extra, params.data.command, {type: params.type, moduleId: params.moduleId});
				});
			}

			return true;
		}
		else
		{
			if (typeof (this._subscribers[params.type]) === 'undefined')
			{
				this._subscribers[params.type] = [];
			}

			if (this._subscribers[params.type].length <= 0)
			{
				return true;
			}

			this._subscribers[params.type].forEach(function(callback){
				callback(params.data, {type: params.type});
			});

			return true;
		}
	};

	Pull.prototype.init = function()
	{
		this._connectors.webSocket = new WebSocketConnector({
			parent: this,
			onOpen: this.onWebSocketOpen.bind(this),
			onMessage: this.parseResponse.bind(this),
			onDisconnect: this.onWebSocketDisconnect.bind(this),
			onError: this.onWebSocketError.bind(this)
		});

		this._connectors.longPolling = new LongPollingConnector({
			parent: this,
			onOpen: this.onLongPollingOpen.bind(this),
			onMessage: this.parseResponse.bind(this),
			onDisconnect: this.onLongPollingDisconnect.bind(this),
			onError: this.onLongPollingError.bind(this)
		});

		this.connectionType = this.isWebSocketAllowed() ? ConnectionType.WebSocket : ConnectionType.LongPolling;

		window.addEventListener("beforeunload", this.onBeforeUnload.bind(this));
		window.addEventListener("offline", this.onOffline.bind(this));
		window.addEventListener("online", this.onOnline.bind(this));

		if(BX && BX.addCustomEvent)
		{
			BX.addCustomEvent("BXLinkOpened", this.connect.bind(this));
		}

		if (BX && BX.desktop)
		{
			BX.addCustomEvent("onDesktopReload", function() {
				this.session.mid = null;
				this.session.tag = null;
				this.session.time = null;
			}.bind(this));

			BX.desktop.addCustomEvent("BXLoginSuccess", function() {
				this.restart(1000, "Desktop login");
			}.bind(this));
		}
	};

	Pull.prototype.start = function(config)
	{
		var allowConfigCaching = true;

		if(this.starting || this.isConnected())
		{
			return;
		}

		if(!this.userId && typeof(BX.message) !== 'undefined' && BX.message.USER_ID)
		{
			this.userId = BX.message.USER_ID;
			if(!this.storage)
			{
				this.storage = new StorageManager({
					userId: this.userId,
					siteId: this.siteId
				});
			}
		}
		if(this.siteId === 'none' && typeof(BX.message) !== 'undefined' && BX.message.SITE_ID)
		{
			this.siteId = BX.message.SITE_ID;
		}

		var result = new BX.Promise();

		var skipReconnectToLastSession = false;
		if (Utils.isPlainObject(config))
		{
			if (typeof config.skipReconnectToLastSession !== 'undefined')
			{
				skipReconnectToLastSession = !!config.skipReconnectToLastSession;
				delete config.skipReconnectToLastSession;
			}
			this.config = config;
			allowConfigCaching = false;
		}

		if (!this.enabled)
		{
			result.reject({
				ex: { error: 'PULL_DISABLED', error_description: 'Push & Pull server is disabled'}
			});
			return result;
		}

		var self = this;
		var now = (new Date()).getTime();
		var oldSession;
		if(!skipReconnectToLastSession && this.storage)
		{
			oldSession = this.storage.get(LS_SESSION);
		}
		if(Utils.isPlainObject(oldSession) && oldSession.hasOwnProperty('ttl') && oldSession.ttl >= now)
		{
			this.session.mid = oldSession.mid;
		}

		this.starting = true;
		this.loadConfig().catch(function(error)
		{
			self.starting = false;
			self.sendPullStatus(PullStatus.Offline);
			self.stopCheckConfig();
			console.error(Utils.getDateForLog() + ': Pull: could not read push-server config. ', error);
			result.reject(error);
		}).then(function(config)
		{
			self.setConfig(config, allowConfigCaching);
			self.init();
			self.connect();
			self.updateWatch();
			self.startCheckConfig();
			result.resolve(true);
		});

		return result;
	};

	Pull.prototype.getRestClientOptions = function()
	{
		var result = {};

		if(this.guestMode && this.guestUserId !== 0)
		{
			result.queryParams = {
				pull_guest_id: this.guestUserId
			}
		}
		return result;
	};

	Pull.prototype.setLastMessageId = function(lastMessageId)
	{
		this.session.mid = lastMessageId;
	};

	/**
	 *
	 * @param {object[]} publicIds
	 * @param {integer} publicIds.user_id
	 * @param {string} publicIds.public_id
	 * @param {string} publicIds.signature
	 * @param {Date} publicIds.start
	 * @param {Date} publicIds.end
	 */
	Pull.prototype.setPublicIds = function(publicIds)
	{
		return this.channelManager.setPublicIds(publicIds);
	};

	/**
	 * Send single message to the specified users.
	 *
	 * @param {integer[]} users User ids of the message receivers.
	 * @param {string} moduleId Name of the module to receive message,
	 * @param {string} command Command name.
	 * @param {object} params Command parameters.
	 * @param {integer} [expiry] Message expiry time in seconds.
	 * @return void
	 */
	Pull.prototype.sendMessage = function(users, moduleId, command, params, expiry)
	{
		return this.sendMessageBatch([{
			users: users,
			moduleId: moduleId,
			command: command,
			params: params,
			expiry: expiry
		}]);
	};

	/**
	 * Send single message to the specified public channels.
	 *
	 * @param {string[]} publicChannels Public ids of the channels to receive message.
	 * @param {string} moduleId Name of the module to receive message,
	 * @param {string} command Command name.
	 * @param {object} params Command parameters.
	 * @param {integer} [expiry] Message expiry time in seconds.
	 * @return void
	 */
	Pull.prototype.sendMessageToChannels = function(publicChannels, moduleId, command, params, expiry)
	{
		return this.sendMessageBatch([{
			publicChannels: publicChannels,
			moduleId: moduleId,
			command: command,
			params: params,
			expiry: expiry
		}]);
	}

	/**
	 * Sends batch of messages to the multiple public channels.
	 *
	 * @param {object[]} messageBatch Array of messages to send.
	 * @param  {int[]} messageBatch.users User ids the message receivers.
	 * @param  {string[]|object[]} messageBatch.publicChannels Public ids of the channels to send messages.
	 * @param {string} messageBatch.moduleId Name of the module to receive message,
	 * @param {string} messageBatch.command Command name.
	 * @param {object} messageBatch.params Command parameters.
	 * @param {integer} [messageBatch.expiry] Message expiry time in seconds.
	 * @return void
	 */
	Pull.prototype.sendMessageBatch = function(messageBatch)
	{
		if(!this.isPublishingEnabled())
		{
			console.error('Client publishing is not supported or is disabled');
			return false;
		}

		var userIds = {};
		for(var i = 0; i < messageBatch.length; i++)
		{
			if (messageBatch[i].users)
			{
				for(var j = 0; j < messageBatch[i].users.length; j++)
				{
					userIds[messageBatch[i].users[j]] = true;
				}
			}
		}

		this.channelManager.getPublicIds(Object.keys(userIds)).then(function(publicIds)
		{
			return this.connector.send(this.encodeMessageBatch(messageBatch, publicIds));
		}.bind(this))
	};

	Pull.prototype.encodeMessageBatch = function(messageBatch, publicIds)
	{
		var messages = [];
		messageBatch.forEach(function(messageFields)
		{
			var messageBody = {
				module_id: messageFields.moduleId,
				command: messageFields.command,
				params: messageFields.params
			};

			var receivers;
			if (messageFields.users)
			{
				receivers = this.createMessageReceivers(messageFields.users, publicIds);
			}
			else
			{
				receivers = [];
			}

			if (messageFields.publicChannels)
			{
				if (!BX.type.isArray(messageFields.publicChannels))
				{
					throw new Error('messageFields.publicChannels must be an array');
				}
				messageFields.publicChannels.forEach(function(publicChannel)
				{
					var publicId;
					var signature;
					if (typeof(publicChannel) === 'string' && publicChannel.includes('.'))
					{
						var fields = publicChannel.toString().split('.');
						publicId = fields[0];
						signature = fields[1];
					}
					else if (typeof(publicChannel) === 'object' && ('publicId' in publicChannel) && ('signature' in publicChannel))
					{
						publicId = publicChannel.publicId;
						signature = publicChannel.signature;
					}
					else
					{
						throw new Error('Public channel MUST be either a string, formatted like "{publicId}.{signature}" or an object with fields \'publicId\' and \'signature\'');
					}

					receivers.push(Receiver.create({
						id: this.encodeId(publicId),
						signature: this.encodeId(signature)
					}))
				}.bind(this))
			}

			var message = IncomingMessage.create({
				receivers: receivers,
				body: JSON.stringify(messageBody),
				expiry: messageFields.expiry || 0
			});
			messages.push(message);
		}, this);

		var requestBatch = RequestBatch.create({
			requests: [{
				incomingMessages: {
					messages: messages
				}
			}]
		});

		return RequestBatch.encode(requestBatch).finish();
	};

	Pull.prototype.createMessageReceivers = function(users, publicIds)
	{
		var result = [];
		for(var i = 0; i < users.length; i++)
		{
			var userId = users[i];
			if(!publicIds[userId] || !publicIds[userId].publicId)
			{
				throw new Error('Could not determine public id for user ' + userId);
			}

			result.push(Receiver.create({
				id: this.encodeId(publicIds[userId].publicId),
				signature: this.encodeId(publicIds[userId].signature)
			}))
		}
		return result;
	};

	Pull.prototype.restart = function(disconnectCode, disconnectReason)
	{
		var self = this;
		this.disconnect(disconnectCode, disconnectReason);
		if(this.storage)
		{
			this.storage.remove('bx-pull-config');
		}
		this.config = null;

		this.loadConfig().catch(function(error)
		{
			console.error(Utils.getDateForLog() + ': Pull: could not read push-server config', error);
			self.sendPullStatus(PullStatus.Offline);

			clearTimeout(self.reconnectTimeout);
			if(error.status == 401 || error.status == 403)
			{
				self.stopCheckConfig();

				if(BX && BX.onCustomEvent)
				{
					BX.onCustomEvent(window, 'onPullError', ['AUTHORIZE_ERROR']);
				}
			}
		}).then(function(config)
		{
			self.setConfig(config, true);
			self.connect();
			self.updateWatch();
			self.startCheckConfig();
		});
	};

	Pull.prototype.loadConfig = function ()
	{
		var result = new BX.Promise();
		if (!this.config)
		{
			this.config = {
				api: {},
				channels: {},
				publicChannels: {},
				server: { timeShift: 0 },
				clientId: null
			};

			var config;
			if(this.storage)
			{
				config = this.storage.get('bx-pull-config');
			}
			if(this.isConfigActual(config) && this.checkRevision(config.api.revision_web))
			{
				result.resolve(config);
				return result;
			}
			else if (this.storage)
			{
				this.storage.remove('bx-pull-config')
			}
		}
		else if(this.isConfigActual(this.config) && this.checkRevision(this.config.api.revision_web))
		{
			result.resolve(this.config);
			return result;
		}
		else
		{
			this.config = {
				api: {},
				channels: {},
				publicChannels: {},
				server: { timeShift: 0 },
				clientId: null
			};
		}

		this.restClient.callMethod(this.configGetMethod, {'CACHE': 'N'}).then(function(response) {
			var timeShift = 0;
			var data = response.data();
			timeShift = Math.floor((Utils.getTimestamp() - new Date(data.serverTime).getTime())/1000);
			delete data.serverTime;

			var config = Object.assign({}, data);
			config.server.timeShift = timeShift;

			result.resolve(config)
		}).catch(function(response)
		{
				var error = response.error();
				if(error.getError().error == "AUTHORIZE_ERROR" || error.getError().error == "WRONG_AUTH_TYPE")
				{
					error.status = 403;
				}
				result.reject(error);
		});

		return result;
	};

	Pull.prototype.isConfigActual = function(config)
	{
		if(!Utils.isPlainObject(config))
		{
			return false;
		}

		if(config.server.config_timestamp < this.configTimestamp)
		{
			return false;
		}

		var now = new Date();

		var channelCount = Object.keys(config.channels).length;
		if(channelCount === 0)
		{
			return false;
		}

		for(var channelType in config.channels)
		{
			if (!config.channels.hasOwnProperty(channelType))
			{
				continue;
			}

			var channel = config.channels[channelType];
			var channelEnd = new Date(channel.end);

			if(channelEnd < now)
			{
				return false;
			}
		}

		return true;
	};

	Pull.prototype.startCheckConfig = function()
	{
		if(this.checkInterval)
		{
			clearInterval(this.checkInterval);
		}

		this.checkInterval = setInterval(this.checkConfig.bind(this), CONFIG_CHECK_INTERVAL)
	};

	Pull.prototype.stopCheckConfig = function()
	{
		if(this.checkInterval)
		{
			clearInterval(this.checkInterval);
		}
		this.checkInterval = null;
	};

	Pull.prototype.checkConfig = function()
	{
		if(this.isConfigActual(this.config))
		{
			if(!this.checkRevision(this.config.api.revision_web))
			{
				return false;
			}
		}
		else
		{
			this.logToConsole("Stale config detected. Restarting");
			this.restart(CloseReasons.CONFIG_EXPIRED, "Config update required");
		}
	};

	Pull.prototype.setConfig = function(config, allowCaching)
	{
		for (var key in config)
		{
			if(config.hasOwnProperty(key) && this.config.hasOwnProperty(key))
			{
				this.config[key] = config[key];
			}
		}

		if (config.publicChannels)
		{
			this.setPublicIds(Utils.objectValues(config.publicChannels));
		}

		if(this.storage && allowCaching)
		{
			try
			{
				this.storage.set('bx-pull-config', config);
			}
			catch (e)
			{
				// try to delete the key "history" (landing site change history, see http://jabber.bx/view.php?id=136492)
				if (localStorage && localStorage.removeItem)
				{
					localStorage.removeItem('history');
				}
				console.error(Utils.getDateForLog() + " Pull: Could not cache config in local storage. Error: ", e);
			}
		}
	};

	Pull.prototype.isWebSocketSupported = function()
	{
		return typeof(window.WebSocket) !== "undefined";
	};

	Pull.prototype.isWebSocketAllowed = function()
	{
		if(this.sharedConfig.isWebSocketBlocked())
		{
			return false;
		}

		return this.isWebSocketEnabled();
	};

	Pull.prototype.isWebSocketEnabled = function()
	{
		if(!this.isWebSocketSupported())
		{
			return false;
		}

		return (this.config && this.config.server && this.config.server.websocket_enabled === true);
	};

	Pull.prototype.isPublishingSupported = function ()
	{
		return this.getServerVersion() > 3;
	};

	Pull.prototype.isPublishingEnabled = function ()
	{
		if(!this.isPublishingSupported())
		{
			return false;
		}

		return (this.config && this.config.server && this.config.server.publish_enabled === true);
	};

	Pull.prototype.isProtobufSupported = function()
	{
		return (this.getServerVersion() > 3 && !Utils.browser.IsIe());
	};

	Pull.prototype.isSharedMode = function()
	{
		return (this.getServerMode() == ServerMode.Shared)
	};

	Pull.prototype.disconnect = function(disconnectCode, disconnectReason)
	{
		if(this.connector)
		{
			this.isManualDisconnect = true;
			this.connector.disconnect(disconnectCode, disconnectReason);
		}
	};

	Pull.prototype.stop = function(disconnectCode, disconnectReason)
	{
		this.disconnect(disconnectCode, disconnectReason);
		this.stopCheckConfig();
	};

	Pull.prototype.reconnect = function(disconnectCode, disconnectReason, delay)
	{
		this.disconnect(disconnectCode, disconnectReason);

		delay = delay || 1;
		this.scheduleReconnect(delay);
	};

	Pull.prototype.restoreWebSocketConnection = function()
	{
		if(this.connectionType == ConnectionType.WebSocket)
		{
			return true;
		}

		this._connectors.webSocket.connect();
	};

	Pull.prototype.scheduleReconnect = function(connectionDelay)
	{
		if(!this.enabled)
			return false;

		if(!connectionDelay)
		{
			if(this.connectionAttempt > 3 && this.connectionType === ConnectionType.WebSocket && !this.sharedConfig.isLongPollingBlocked())
			{
				// Websocket seems to be closed by network filter. Trying to fallback to long polling
				this.sharedConfig.setWebSocketBlocked(true);
				this.connectionType = ConnectionType.LongPolling;
				this.connectionAttempt = 1;
				connectionDelay = 1;
			}
			else
			{
				connectionDelay = this.getConnectionAttemptDelay(this.connectionAttempt);
			}
		}
		if(this.reconnectTimeout)
		{
			clearTimeout(this.reconnectTimeout);
		}

		this.logToConsole('Pull: scheduling reconnection in ' + connectionDelay + ' seconds; attempt # ' + this.connectionAttempt);

		this.reconnectTimeout = setTimeout(this.connect.bind(this), connectionDelay * 1000);
	};

	Pull.prototype.scheduleRestoreWebSocketConnection = function()
	{
		this.logToConsole('Pull: scheduling restoration of websocket connection in ' + RESTORE_WEBSOCKET_TIMEOUT + ' seconds');

		var self = this;
		if(this.restoreWebSocketTimeout)
		{
			return;
		}

		this.restoreWebSocketTimeout = setTimeout(function()
		{
			self.restoreWebSocketTimeout = 0;
			self.restoreWebSocketConnection();
		}, RESTORE_WEBSOCKET_TIMEOUT * 1000);
	};

	Pull.prototype.connect = function()
	{
		if(!this.enabled || this.connector.connected)
		{
			return false;
		}

		if(this.reconnectTimeout)
		{
			clearTimeout(this.reconnectTimeout);
		}

		this.sendPullStatus(PullStatus.Connecting);
		this.connectionAttempt++;
		this.connector.connect();
	};

	Pull.prototype.parseResponse = function (response)
	{
		var events = this.extractMessages(response);
		var messages = [];
		if (events.length === 0)
		{
			this.session.mid = null;
			return;
		}

		for (var i = 0; i < events.length; i++)
		{
			var event = events[i];
			if (event.mid && this.session.lastMessageIds.includes(event.mid))
			{
				console.warn("Duplicate message " + event.mid + " skipped");
				continue;
			}

			this.session.mid = event.mid || null;
			this.session.tag = event.tag || null;
			this.session.time = event.time || null;
			if (event.mid)
			{
				this.session.lastMessageIds.push(event.mid);
			}
			messages.push(event.text);

			if (!this.session.history[event.text.module_id])
			{
				this.session.history[event.text.module_id] = {};
			}
			if (!this.session.history[event.text.module_id][event.text.command])
			{
				this.session.history[event.text.module_id][event.text.command] = 0;
			}
			this.session.history[event.text.module_id][event.text.command]++;
			this.session.messageCount++;
		}

		if (this.session.lastMessageIds.length > MAX_IDS_TO_STORE)
		{
			this.session.lastMessageIds = this.session.lastMessageIds.slice( - MAX_IDS_TO_STORE);
		}
		this.broadcastMessages(messages);
	};

	Pull.prototype.extractMessages = function (pullEvent)
	{
		if(pullEvent instanceof ArrayBuffer)
		{
			return this.extractProtobufMessages(pullEvent);
		}
		else if(Utils.isNotEmptyString(pullEvent))
		{
			return this.extractPlainTextMessages(pullEvent)
		}
	};

	Pull.prototype.extractProtobufMessages = function(pullEvent)
	{
		var result = [];
		try
		{
			var responseBatch = ResponseBatch.decode(new Uint8Array(pullEvent));
			for (var i = 0; i < responseBatch.responses.length; i++)
			{
				var response = responseBatch.responses[i];
				if (response.command != "outgoingMessages")
				{
					continue;
				}

				var messages = responseBatch.responses[i].outgoingMessages.messages;
				for (var m = 0; m < messages.length; m++)
				{
					var message = messages[m];
					var messageFields;
					try
					{
						messageFields = JSON.parse(message.body)
					}
					catch (e)
					{
						console.error(Utils.getDateForLog() + ": Pull: Could not parse message body", e);
						continue;
					}

					if(!messageFields.extra)
					{
						messageFields.extra = {}
					}
					messageFields.extra.sender = {
						type: message.sender.type
					};

					if(message.sender.id instanceof Uint8Array)
					{
						messageFields.extra.sender.id = this.decodeId(message.sender.id)
					}

					var compatibleMessage = {
						mid: this.decodeId(message.id),
						text: messageFields
					};

					result.push(compatibleMessage);
				}
			}
		}
		catch(e)
		{
			console.error(Utils.getDateForLog() + ": Pull: Could not parse message", e)
		}
		return result;
	};

	Pull.prototype.extractPlainTextMessages = function(pullEvent)
	{
		var result = [];
		var dataArray = pullEvent.match(/#!NGINXNMS!#(.*?)#!NGINXNME!#/gm);
		if (dataArray === null)
		{
			text = "\n========= PULL ERROR ===========\n"+
				"Error type: parseResponse error parsing message\n"+
				"\n"+
				"Data string: " + pullEvent + "\n"+
				"================================\n\n";
			console.warn(text);
			return result;
		}
		for (var i = 0; i < dataArray.length; i++)
		{
			dataArray[i] = dataArray[i].substring(12, dataArray[i].length - 12);
			if (dataArray[i].length <= 0)
			{
				continue;
			}

			try
			{
				var data = JSON.parse(dataArray[i])
			}
			catch(e)
			{
				continue;
			}

			result.push(data);
		}
		return result;
	};

	/**
	 * Converts message id from byte[] to string
	 * @param {Uint8Array} encodedId
	 * @return {string}
	 */
	Pull.prototype.decodeId = function(encodedId)
	{
		if(!(encodedId instanceof Uint8Array))
		{
			throw new Error("encodedId should be an instance of Uint8Array");
		}

		var result = "";
		for (var i = 0; i < encodedId.length; i++)
		{
			var hexByte = encodedId[i].toString(16);
			if (hexByte.length === 1)
			{
				result += '0';
			}
			result += hexByte;
		}
		return result;
	};

	/**
	 * Converts message id from hex-encoded string to byte[]
	 * @param {string} id Hex-encoded string.
	 * @return {Uint8Array}
	 */
	Pull.prototype.encodeId = function(id)
	{
		if (!id)
		{
			return new Uint8Array();
		}

		var result = [];
		for (var i = 0; i < id.length; i += 2)
		{
			result.push(parseInt(id.substr(i, 2), 16));
		}

		return new Uint8Array(result);
	};

	Pull.prototype.broadcastMessages = function (messages)
	{
		messages.forEach(function (message)
		{
			var moduleId = message.module_id = message.module_id.toLowerCase();
			var command = message.command;

			if(!message.extra)
			{
				message.extra = {};
			}

			if(message.extra.server_time_unix)
			{
				message.extra.server_time_ago = ((Utils.getTimestamp() - (message.extra.server_time_unix * 1000)) / 1000)-(this.config.server.timeShift? this.config.server.timeShift: 0);
				message.extra.server_time_ago = message.extra.server_time_ago > 0 ? message.extra.server_time_ago : 0;
			}

			this.logMessage(message);
			try
			{
				if(message.extra.sender && message.extra.sender.type === SenderType.Client)
				{
					if (typeof BX.onCustomEvent !== 'undefined')
					{
						BX.onCustomEvent(window, 'onPullClientEvent-' + moduleId, [command, message.params, message.extra], true);
						BX.onCustomEvent(window, 'onPullClientEvent', [moduleId, command, message.params, message.extra], true);
					}

					this.emit({
						type: SubscriptionType.Client,
						moduleId: moduleId,
						data: {
							command: command,
							params: Utils.clone(message.params),
							extra: Utils.clone(message.extra)
						}
					});
				}
				else if (moduleId === 'pull')
				{
					this.handleInternalPullEvent(command, message);
				}
				else if (moduleId == 'online')
				{
					if (message.extra.server_time_ago < 240)
					{
						if (typeof BX.onCustomEvent !== 'undefined')
						{
							BX.onCustomEvent(window, 'onPullOnlineEvent', [command, message.params, message.extra], true);
						}

						this.emit({
							type: SubscriptionType.Online,
							data: {
								command: command,
								params: Utils.clone(message.params),
								extra: Utils.clone(message.extra)
							}
						});
					}
				}
				else
				{
					if (typeof BX.onCustomEvent !== 'undefined')
					{
						BX.onCustomEvent(window, 'onPullEvent-' + moduleId, [command, message.params, message.extra], true);
						BX.onCustomEvent(window, 'onPullEvent', [moduleId, command, message.params, message.extra], true);
					}

					this.emit({
						type: SubscriptionType.Server,
						moduleId: moduleId,
						data: {
							command: command,
							params: Utils.clone(message.params),
							extra: Utils.clone(message.extra)
						}
					});
				}
			}
			catch(e)
			{
				if (typeof(console) == 'object')
				{
					console.warn(
						"\n========= PULL ERROR ===========\n"+
						"Error type: broadcastMessages execute error\n"+
						"Error event: ", e, "\n"+
						"Message: ", message, "\n"+
						"================================\n"
					);
					if (typeof BX.debug !== 'undefined')
					{
						BX.debug(e);
					}
				}
			}

			if(message.extra && message.extra.revision_web)
			{
				this.checkRevision(message.extra.revision_web);
			}
		}, this);
	};

	Pull.prototype.logToConsole = function(message)
	{
		if(this.loggingEnabled)
		{
			console.log(Utils.getDateForLog() + ': ' + message);
		}
	};

	Pull.prototype.logMessage = function(message)
	{
		if(!this.debug)
		{
			return;
		}

		if(message.extra.sender && message.extra.sender.type === SenderType.Client)
		{
			console.info('onPullClientEvent-' + message.module_id, message.command, message.params, message.extra);
		}
		else if (message.moduleId == 'online')
		{
			console.info('onPullOnlineEvent', message.command, message.params, message.extra);
		}
		else
		{
			console.info('onPullEvent', message.module_id, message.command, message.params, message.extra);
		}
	};

	Pull.prototype.onLongPollingOpen = function()
	{
		this.unloading = false;
		this.starting = false;
		this.connectionAttempt = 0;
		this.isManualDisconnect = false;
		this.sendPullStatus(PullStatus.Online);

		if(this.offlineTimeout)
		{
			clearTimeout(this.offlineTimeout);
			this.offlineTimeout = null;
		}

		this.logToConsole('Pull: Long polling connection with push-server opened');
		if(this.isWebSocketEnabled())
		{
			this.scheduleRestoreWebSocketConnection();
		}
	};

	Pull.prototype.onWebSocketBlockChanged = function(e)
	{
		var isWebSocketBlocked = e.isWebSocketBlocked;

		if(isWebSocketBlocked && this.connectionType === ConnectionType.WebSocket && !this.isConnected())
		{
			clearTimeout(this.reconnectTimeout);

			this.connectionAttempt = 0;
			this.connectionType = ConnectionType.LongPolling;
			this.scheduleReconnect(1);
		}
		else if(!isWebSocketBlocked && this.connectionType === ConnectionType.LongPolling)
		{
			clearTimeout(this.reconnectTimeout);
			clearTimeout(this.restoreWebSocketTimeout);

			this.connectionAttempt = 0;
			this.connectionType = ConnectionType.WebSocket;
			this.scheduleReconnect(1);
		}
	};

	Pull.prototype.onWebSocketOpen = function()
	{
		this.unloading = false;
		this.starting = false;
		this.connectionAttempt = 0;
		this.isManualDisconnect = false;
		this.sendPullStatus(PullStatus.Online);
		this.sharedConfig.setWebSocketBlocked(false);

		// to prevent fallback to long polling in case of networking problems
		this.sharedConfig.setLongPollingBlocked(true);

		if(this.connectionType == ConnectionType.LongPolling)
		{
			this.connectionType = ConnectionType.WebSocket;
			this._connectors.longPolling.disconnect();
		}

		if(this.offlineTimeout)
		{
			clearTimeout(this.offlineTimeout);
			this.offlineTimeout = null;
		}
		if (this.restoreWebSocketTimeout)
		{
			clearTimeout(this.restoreWebSocketTimeout);
			this.restoreWebSocketTimeout = null;
		}
		this.logToConsole('Pull: Websocket connection with push-server opened');
	};

	Pull.prototype.onWebSocketDisconnect = function(e)
	{
		if(this.connectionType === ConnectionType.WebSocket)
		{
			if(e.code != CloseReasons.CONFIG_EXPIRED && e.code != CloseReasons.CHANNEL_EXPIRED && e.code != CloseReasons.CONFIG_REPLACED)
			{
				this.sendPullStatus(PullStatus.Offline);
			}
			else
			{
				this.offlineTimeout = setTimeout(function()
				{
					this.sendPullStatus(PullStatus.Offline);
				}.bind(this), 5000)
			}
		}

		if(!e)
		{
			e = {};
		}

		this.logToConsole('Pull: Websocket connection with push-server closed. Code: ' + e.code + ', reason: ' + e.reason);
		if(!this.isManualDisconnect)
		{
			this.scheduleReconnect();
		}

		// to prevent fallback to long polling in case of networking problems
		this.sharedConfig.setLongPollingBlocked(true);
		this.isManualDisconnect = false;
	};

	Pull.prototype.onWebSocketError = function(e)
	{
		this.starting = false;
		if(this.connectionType === ConnectionType.WebSocket)
		{
			this.sendPullStatus(PullStatus.Offline);
		}

		console.error(Utils.getDateForLog() + ": Pull: WebSocket connection error", e);
		this.scheduleReconnect();
	};

	Pull.prototype.onLongPollingDisconnect = function(e)
	{
		if(this.connectionType === ConnectionType.LongPolling)
		{
			if(e.code != CloseReasons.CONFIG_EXPIRED && e.code != CloseReasons.CHANNEL_EXPIRED && e.code != CloseReasons.CONFIG_REPLACED)
			{
				this.sendPullStatus(PullStatus.Offline);
			}
			else
			{
				this.offlineTimeout = setTimeout(function()
				{
					this.sendPullStatus(PullStatus.Offline);
				}.bind(this), 5500)
			}
		}

		if(!e)
		{
			e = {};
		}

		this.logToConsole('Pull: Long polling connection with push-server closed. Code: ' + e.code + ', reason: ' + e.reason);
		if(!this.isManualDisconnect)
		{
			this.scheduleReconnect();
		}
		this.isManualDisconnect = false;
	};

	Pull.prototype.onLongPollingError = function(e)
	{
		this.starting = false;
		if(this.connectionType === ConnectionType.LongPolling)
		{
			this.sendPullStatus(PullStatus.Offline);
		}
		console.error(Utils.getDateForLog() + ': Pull: Long polling connection error', e);
		this.scheduleReconnect();
	};

	Pull.prototype.isConnected = function()
	{
		return this.connector ? this.connector.connected : false;
	};

	Pull.prototype.onBeforeUnload = function()
	{
		this.unloading = true;

		var session = Utils.clone(this.session);
		session.ttl = (new Date()).getTime() + LS_SESSION_CACHE_TIME * 1000;
		if(this.storage)
		{
			try
			{
				this.storage.set(LS_SESSION, JSON.stringify(session), LS_SESSION_CACHE_TIME);
			}
			catch (e)
			{
				console.error(Utils.getDateForLog() + " Pull: Could not save session info in local storage. Error: ", e);
			}
		}

		this.scheduleReconnect(15);
	};

	Pull.prototype.onOffline = function()
	{
		this.disconnect("1000", "offline");
	};

	Pull.prototype.onOnline = function()
	{
		this.connect();
	};

	Pull.prototype.handleInternalPullEvent = function(command, message)
	{
		switch (command.toUpperCase())
		{
			case SystemCommands.CHANNEL_EXPIRE:
			{
				if (message.params.action == 'reconnect')
				{
					this.config.channels[message.params.channel.type] = message.params.new_channel;
					this.logToConsole("Pull: new config for " + message.params.channel.type + " channel set:\n", this.config.channels[message.params.channel.type]);

					this.reconnect(CloseReasons.CONFIG_REPLACED, "config was replaced");
				}
				else
				{
					this.restart(CloseReasons.CHANNEL_EXPIRED, "channel expired");
				}
				break;
			}
			case SystemCommands.CONFIG_EXPIRE:
			{
				this.restart(CloseReasons.CONFIG_EXPIRED, "config expired");
				break;
			}
			case SystemCommands.SERVER_RESTART:
			{
				this.reconnect(CloseReasons.SERVER_RESTARTED, "server was restarted", 15);
				break;
			}
			default://
		}
	};

	Pull.prototype.checkRevision = function(serverRevision)
	{
		if (this.skipCheckRevision)
		{
			return true;
		}

		serverRevision = parseInt(serverRevision);
		if (serverRevision > 0 && serverRevision != REVISION)
		{
			this.enabled = false;
			if (typeof BX.message !== 'undefined')
			{
				this.showNotification(BX.message('PULL_OLD_REVISION'));
			}
			this.disconnect(CloseReasons.NORMAL_CLOSURE, 'check_revision');

			if (typeof BX.onCustomEvent !== 'undefined')
			{
				BX.onCustomEvent(window, 'onPullRevisionUp', [serverRevision, REVISION]);
			}

			this.emit({
				type: SubscriptionType.Revision,
				data: {
					server: serverRevision,
					client: REVISION
				}
			});

			this.logToConsole("Pull revision changed from " + REVISION + " to " + serverRevision + ". Reload required");

			return false;
		}
		return true;
	};

	Pull.prototype.showNotification = function(text)
	{
		var self = this;
		if (this.notificationPopup || typeof BX.PopupWindow === 'undefined')
			return;

		this.notificationPopup = new BX.PopupWindow('bx-notifier-popup-confirm', null, {
			zIndex: 200,
			autoHide: false,
			closeByEsc: false,
			overlay: true,
			content : BX.create("div", {
				props: {className: "bx-messenger-confirm"},
				html: text
			}),
			buttons: [
				new BX.PopupWindowButton({
					text: BX.message('JS_CORE_WINDOW_CLOSE'),
					className: "popup-window-button-decline",
					events: {
						click: function(e)
						{
							self.notificationPopup.close();
						}
					}
				})
			],
			events: {
				onPopupClose: function()
				{
					this.destroy()
				},
				onPopupDestroy: function()
				{
					self.notificationPopup = null;
				}
			}
		});
		this.notificationPopup.show();
	};

	Pull.prototype.getRevision = function()
	{
		return (this.config && this.config.api) ? this.config.api.revision_web : null;
	};

	Pull.prototype.getServerVersion = function()
	{
		return (this.config && this.config.server) ? this.config.server.version : 0;
	};

	Pull.prototype.getServerMode = function()
	{
		return (this.config && this.config.server) ? this.config.server.mode : null;
	};

	Pull.prototype.getConfig = function()
	{
		return this.config;
	};

	Pull.prototype.getDebugInfo = function()
	{
		if (!console || !console.info || !JSON || !JSON.stringify)
			return false;

		var configDump;

		if(this.config && this.config.channels && this.config.channels.private)
		{
			configDump = "ChannelID: " + this.config.channels.private.id + "\n" +
				"ChannelDie: " + this.config.channels.private.end + "\n" +
				("shared" in this.config.channels ? "ChannelDieShared: " + this.config.channels.shared.end : "");
		}
		else
		{
			configDump = "Config error: config is not loaded";
		}

		var watchTagsDump = JSON.stringify(this.watchTagsQueue);
		var text = "\n========= PULL DEBUG ===========\n"+
			"UserId: " + this.userId + " " + (this.userId > 0 ?  '': '(guest)') + "\n" +
			(this.guestMode && this.guestUserId !== 0? "Guest userId: " + this.guestUserId + "\n":"") +
			"Browser online: " + (navigator.onLine ? 'Y' : 'N') + "\n" +
			"Connect: " + (this.isConnected() ? 'Y': 'N') + "\n" +
			"Server type: " + (this.isSharedMode() ? 'cloud' : 'local') + "\n" +
			"WebSocket support: " + (this.isWebSocketSupported() ? 'Y': 'N') + "\n" +
			"WebSocket connect: " + (this._connectors.webSocket && this._connectors.webSocket.connected ? 'Y': 'N') + "\n"+
			"WebSocket mode: " + (this._connectors.webSocket && this._connectors.webSocket.socket ? (this._connectors.webSocket.socket.url.search("binaryMode=true") != -1 ? "protobuf" : "text") : '-') + "\n"+

			"Try connect: " + (this.reconnectTimeout? 'Y': 'N') + "\n" +
			"Try number: " + (this.connectionAttempt) + "\n" +
			"\n"+
			"Path: " + (this.connector ? this.connector.path : '-') + "\n" +
			configDump + "\n" +
			"\n"+
			"Last message: " + (this.session.mid > 0? this.session.mid : '-') + "\n" +
			"Session history: " + JSON.stringify(this.session.history) + "\n" +
			"Watch tags: " + (watchTagsDump == '{}'? '-' : watchTagsDump) + "\n"+
			"================================\n";

		return console.info(text);
	};

	Pull.prototype.enableLogging = function(loggingFlag)
	{
		if(loggingFlag === undefined)
		{
			loggingFlag = true;
		}
		loggingFlag = loggingFlag === true;

		this.sharedConfig.setLoggingEnabled(loggingFlag);
		this.loggingEnabled = loggingFlag;
	};

	Pull.prototype.capturePullEvent = function(debugFlag)
	{
		if(debugFlag === undefined)
		{
			debugFlag = true;
		}

		this.debug = debugFlag;
	};

	Pull.prototype.getConnectionPath = function(connectionType)
	{
		var path;

		switch(connectionType)
		{
			case ConnectionType.WebSocket:
				path = this.isSecure? this.config.server.websocket_secure: this.config.server.websocket;
				break;
			case ConnectionType.LongPolling:
				path = this.isSecure? this.config.server.long_pooling_secure: this.config.server.long_polling;
				break;
			default:
				throw new Error("Unknown connection type " + connectionType);
		}

		if(!Utils.isNotEmptyString(path))
		{
			return false;
		}

		var channels = [];
		['private', 'shared'].forEach(function(type)
		{
			if (typeof this.config.channels[type] !== 'undefined')
			{
				channels.push(this.config.channels[type].id);
			}
		}, this);

		if(channels.length === 0)
		{
			 return false;
		}

		var params = {
			CHANNEL_ID: channels.join('/')
		};

		if(this.isProtobufSupported())
		{
			params.binaryMode = 'true';
		}
		if (this.isSharedMode())
		{
			if(!this.config.clientId)
			{
				throw new Error("Push-server is in shared mode, but clientId is not set");
			}
			params.clientId = this.config.clientId;
		}
		if (this.session.mid)
		{
			params.mid = this.session.mid;
		}
		if (this.session.tag)
		{
			params.tag = this.session.tag;
		}
		if (this.session.time)
		{
			params.time = this.session.time;
		}
		params.revision = REVISION;

		return path + '?' + Utils.buildQueryString(params);
	};

	Pull.prototype.getPublicationPath = function()
	{
		var path = this.isSecure? this.config.server.publish_secure: this.config.server.publish;
		if(!path)
		{
			return '';
		}

		var channels = [];
		for (var type in this.config.channels)
		{
			if (!this.config.channels.hasOwnProperty(type))
			{
				continue;
			}
			channels.push(this.config.channels[type].id);
		}

		var params = {
			CHANNEL_ID: channels.join('/')
		};

		return path + '?' + Utils.buildQueryString(params);
	};

	/**
	 * Returns reconnect delay in seconds
	 * @param attemptNumber
	 * @return {number}
	 */
	Pull.prototype.getConnectionAttemptDelay = function(attemptNumber)
	{
		var result;
		if(attemptNumber < 1)
		{
			result = 0.5;
		}
		else if(attemptNumber < 3)
		{
			result = 15;
		}
		else if(attemptNumber < 5)
		{
			result = 45;
		}
		else if (attemptNumber < 10)
		{
			result = 600;
		}
		else
		{
			result = 3600;
		}

		return result + (result * Math.random() * 0.2);
	};

	Pull.prototype.sendPullStatus = function(status)
	{
		if(this.unloading)
		{
			return;
		}

		if (typeof BX.onCustomEvent !== 'undefined')
		{
			BX.onCustomEvent(window, 'onPullStatus', [status]);
		}

		this.emit({
			type: SubscriptionType.Status,
			data: {
				status: status
			}
		});
	};

	Pull.prototype.extendWatch = function (tag, force)
	{
		if (!tag || this.watchTagsQueue[tag])
		{
			return false;
		}

		this.watchTagsQueue[tag] = true;
		if (force)
		{
			this.updateWatch(force);
		}
	};

	Pull.prototype.updateWatch = function (force)
	{
		clearTimeout(this.watchUpdateTimeout);
		this.watchUpdateTimeout = setTimeout(function ()
		{
			var watchTags = Object.keys(this.watchTagsQueue);
			if (watchTags.length > 0)
			{
				this.restClient.callMethod('pull.watch.extend', {tags: watchTags}, function(result)
				{
					if(result.error())
					{
						this.updateWatch();

						return false;
					}

					var updatedTags = result.data();

					for (var tagId in updatedTags)
					{
						if (updatedTags.hasOwnProperty(tagId) && !updatedTags[tagId])
						{
							this.clearWatch(tagId);
						}
					}
					this.updateWatch();

				}.bind(this))
			}
			else
			{
				this.updateWatch();
			}
		}.bind(this), force ? this.watchForceUpdateInterval : this.watchUpdateInterval);
	};

	Pull.prototype.clearWatch = function (tagId)
	{
		delete this.watchTagsQueue[tagId];
	};

	// old functions, not used anymore.
	Pull.prototype.setPrivateVar = function(){};
	Pull.prototype.returnPrivateVar = function(){};
	Pull.prototype.expireConfig = function(){};
	Pull.prototype.updateChannelID = function(){};
	Pull.prototype.tryConnect = function(){};
	Pull.prototype.tryConnectDelay = function(){};
	Pull.prototype.tryConnectSet = function(){};
	Pull.prototype.updateState = function(){};
	Pull.prototype.setUpdateStateStepCount = function(){};
	Pull.prototype.supportWebSocket = function()
	{
		return this.isWebSocketSupported();
	};
	Pull.prototype.isWebSoketConnected = function()
	{
		return this.isConnected() && this.connectionType == ConnectionType.WebSocket;
	};
	Pull.prototype.getPullServerStatus = function(){return this.isConnected()};
	Pull.prototype.closeConfirm = function()
	{
		if (this.notificationPopup)
		{
			this.notificationPopup.destroy();
		}
	};

	var SharedConfig = function(params)
	{
		params = params || {};
		this.storage = params.storage || new StorageManager();

		this.ttl = 24 * 60 * 60;

		this.lsKeys = {
			websocketBlocked: 'bx-pull-websocket-blocked',
			longPollingBlocked: 'bx-pull-longpolling-blocked',
			loggingEnabled: 'bx-pull-logging-enabled'
		};

		this.callbacks = {
			onWebSocketBlockChanged: (Utils.isFunction(params.onWebSocketBlockChanged) ? params.onWebSocketBlockChanged : function(){})
		};

		if (this.storage)
		{
			window.addEventListener('storage', this.onLocalStorageSet.bind(this));
		}
	};

	SharedConfig.prototype.onLocalStorageSet = function(params)
	{
		if(
			this.storage.compareKey(params.key, this.lsKeys.websocketBlocked)
			&& params.newValue != params.oldValue
		)
		{
			this.callbacks.onWebSocketBlockChanged({
				isWebSocketBlocked: this.isWebSocketBlocked()
			})
		}
	};

	SharedConfig.prototype.isWebSocketBlocked = function()
	{
		if (!this.storage)
		{
			return false;
		}

		return this.storage.get(this.lsKeys.websocketBlocked, 0) > Utils.getTimestamp();
	};

	SharedConfig.prototype.setWebSocketBlocked = function(isWebSocketBlocked)
	{
		if (!this.storage)
		{
			return false;
		}

		try
		{
			this.storage.set(this.lsKeys.websocketBlocked, (isWebSocketBlocked ? Utils.getTimestamp()+this.ttl : 0));
		}
		catch (e)
		{
			console.error(Utils.getDateForLog() + " Pull: Could not save WS_blocked flag in local storage. Error: ", e);
		}
	};

	SharedConfig.prototype.isLongPollingBlocked = function()
	{
		if (!this.storage)
		{
			return false;
		}

		return this.storage.get(this.lsKeys.longPollingBlocked, 0) > Utils.getTimestamp();
	};

	SharedConfig.prototype.setLongPollingBlocked = function(isLongPollingBlocked)
	{
		if (!this.storage)
		{
			return false;
		}

		try
		{
			this.storage.set(this.lsKeys.longPollingBlocked, (isLongPollingBlocked ? Utils.getTimestamp()+this.ttl : 0));
		}
		catch (e)
		{
			console.error(Utils.getDateForLog() + " Pull: Could not save LP_blocked flag in local storage. Error: ", e);
		}
	};

	SharedConfig.prototype.isLoggingEnabled = function()
	{
		if (!this.storage)
		{
			return false;
		}

		return this.storage.get(this.lsKeys.loggingEnabled, 0) > Utils.getTimestamp();
	};

	SharedConfig.prototype.setLoggingEnabled = function(isLoggingEnabled)
	{
		if (!this.storage)
		{
			return false;
		}

		try
		{
			this.storage.set(this.lsKeys.loggingEnabled, (isLoggingEnabled ? Utils.getTimestamp()+this.ttl : 0));
		}
		catch (e)
		{
			console.error("LocalStorage error: ", e);
			return false;
		}
	};

	var ObjectExtend = function(child, parent)
	{
		var f = function() {};
		f.prototype = parent.prototype;

		child.prototype = new f();
		child.prototype.constructor = child;

		child.superclass = parent.prototype;
		if(parent.prototype.constructor == Object.prototype.constructor)
		{
			parent.prototype.constructor = parent;
		}
	};

	var AbstractConnector = function(config)
	{
		this.parent = config.parent;
		this.callbacks = {
			onOpen: Utils.isFunction(config.onOpen) ? config.onOpen : function() {},
			onDisconnect: Utils.isFunction(config.onDisconnect) ? config.onDisconnect : function() {},
			onError: Utils.isFunction(config.onError) ? config.onError : function() {},
			onMessage: Utils.isFunction(config.onMessage) ? config.onMessage : function() {}
		};

		this._connected = false;
		this.connectionType = "";

		this.disconnectCode = '';
		this.disconnectReason = '';

		Object.defineProperty(this, "connected", {
			get: function()
			{
				return this._connected
			},
			set: function(connected)
			{
				if(connected == this._connected)
					return;

				this._connected = connected;

				if(this._connected)
				{
					this.callbacks.onOpen();
				}
				else
				{
					this.callbacks.onDisconnect({
						code: this.disconnectCode,
						reason: this.disconnectReason
					});
				}
			}
		});

		Object.defineProperty(this, "path", {
			get: function()
			{
				return this.parent.getConnectionPath(this.connectionType);
			}
		})
	};

	var WebSocketConnector = function(config)
	{
		WebSocketConnector.superclass.constructor.apply(this, arguments);
		this.connectionType = ConnectionType.WebSocket;
		this.socket = null;

		this.onSocketOpenHandler = this.onSocketOpen.bind(this);
		this.onSocketCloseHandler = this.onSocketClose.bind(this);
		this.onSocketErrorHandler = this.onSocketError.bind(this);
		this.onSocketMessageHandler = this.onSocketMessage.bind(this);
	};

	ObjectExtend(WebSocketConnector, AbstractConnector);

	WebSocketConnector.prototype.connect = function()
	{
		if(this.socket)
		{
			if(this.socket.readyState === 1)
			{
				// already connected
				return true;
			}
			else
			{
				this.socket.removeEventListener('open', this.onSocketOpenHandler);
				this.socket.removeEventListener('close', this.onSocketCloseHandler);
				this.socket.removeEventListener('error', this.onSocketErrorHandler);
				this.socket.removeEventListener('message', this.onSocketMessageHandler);

				this.socket.close();
				this.socket = null;
			}
		}

		this.createSocket();
	};

	WebSocketConnector.prototype.disconnect = function(code, message)
	{
		if (this.socket !== null)
		{
			this.socket.removeEventListener('open', this.onSocketOpenHandler);
			this.socket.removeEventListener('close', this.onSocketCloseHandler);
			this.socket.removeEventListener('error', this.onSocketErrorHandler);
			this.socket.removeEventListener('message', this.onSocketMessageHandler);

			this.socket.close(code, message);
		}
		this.socket = null;
		this.disconnectCode = code;
		this.disconnectReason = message;
		this.connected = false;
	};

	WebSocketConnector.prototype.createSocket = function()
	{
		if(this.socket)
		{
			throw new Error("Socket already exists");
		}

		if(!this.path)
		{
			throw new Error("Websocket connection path is not defined");
		}

		this.socket = new WebSocket(this.path);
		this.socket.binaryType = 'arraybuffer';

		this.socket.addEventListener('open', this.onSocketOpenHandler);
		this.socket.addEventListener('close', this.onSocketCloseHandler);
		this.socket.addEventListener('error', this.onSocketErrorHandler);
		this.socket.addEventListener('message', this.onSocketMessageHandler);
	};

	/**
	 * Sends some data to the server via websocket connection.
	 * @param {ArrayBuffer} buffer Data to send.
	 * @return {boolean}
	 */
	WebSocketConnector.prototype.send = function(buffer)
	{
		if(!this.socket || this.socket.readyState !== 1)
		{
			console.error(Utils.getDateForLog() + ": Pull: WebSocket is not connected");
			return false;
		}

		this.socket.send(buffer);
	};

	WebSocketConnector.prototype.onSocketOpen = function()
	{
		this.connected = true;
	};

	WebSocketConnector.prototype.onSocketClose = function(e)
	{
		this.socket = null;
		this.disconnectCode = e.code;
		this.disconnectReason = e.reason;
		this.connected = false;
	};

	WebSocketConnector.prototype.onSocketError = function(e)
	{
		this.callbacks.onError(e);
	};

	WebSocketConnector.prototype.onSocketMessage = function(e)
	{
		this.callbacks.onMessage(e.data);
	};

	WebSocketConnector.prototype.destroy = function()
	{
		if(this.socket)
		{
			this.socket.close();
			this.socket = null;
		}
	};

	var LongPollingConnector = function(config)
	{
		LongPollingConnector.superclass.constructor.apply(this, arguments);

		this.active = false;
		this.connectionType = ConnectionType.LongPolling;
		this.requestTimeout = null;
		this.failureTimeout = null;
		this.xhr = this.createXhr();
		this.requestAborted = false;
	};

	ObjectExtend(LongPollingConnector, AbstractConnector);

	LongPollingConnector.prototype.createXhr = function()
	{
		var result = new XMLHttpRequest();
		if(this.parent.isProtobufSupported())
		{
			result.responseType = "arraybuffer";
		}
		result.addEventListener("readystatechange", this.onXhrReadyStateChange.bind(this));
		return result;
	};

	LongPollingConnector.prototype.connect = function()
	{
		this.active = true;
		this.performRequest();
	};

	LongPollingConnector.prototype.disconnect = function(code, reason)
	{
		this.active = false;

		if(this.failureTimeout)
		{
			clearTimeout(this.failureTimeout);
			this.failureTimeout = null;
		}
		if(this.requestTimeout)
		{
			clearTimeout(this.requestTimeout);
			this.requestTimeout = null;
		}

		if(this.xhr)
		{
			this.requestAborted = true;
			this.xhr.abort();
		}

		this.disconnectCode = code;
		this.disconnectReason = reason;
		this.connected = false;
	};

	LongPollingConnector.prototype.performRequest = function()
	{
		var self = this;
		if(!this.active)
			return;

		if(!this.path)
		{
			throw new Error("Long polling connection path is not defined");
		}
		if(this.xhr.readyState !== 0 && this.xhr.readyState !== 4)
		{
			return;
		}

		clearTimeout(this.failureTimeout);
		clearTimeout(this.requestTimeout);

		this.failureTimeout = setTimeout(function()
		{
			self.connected = true;
		}, 5000);

		this.requestTimeout = setTimeout(this.onRequestTimeout.bind(this), LONG_POLLING_TIMEOUT * 1000);

		this.xhr.open("GET", this.path);
		this.xhr.send();
	};

	LongPollingConnector.prototype.onRequestTimeout = function()
	{
		this.requestAborted = true;
		this.xhr.abort();
		this.performRequest();
	};

	LongPollingConnector.prototype.onXhrReadyStateChange = function (e)
	{
		if (this.xhr.readyState === 4)
		{
			if(!this.requestAborted || this.xhr.status == 200)
			{
				this.onResponse(this.xhr.response);
			}
			this.requestAborted = false;
		}
	};

	/**
	 * Sends some data to the server via http request.
	 * @param {ArrayBuffer} buffer Data to send.
	 * @return {bool}
	 */
	LongPollingConnector.prototype.send = function(buffer)
	{
		var path = this.parent.getPublicationPath();
		if(!path)
		{
			console.error(Utils.getDateForLog() + ": Pull: publication path is empty");
			return false;
		}

		var xhr = new XMLHttpRequest();
		xhr.open("POST", path);
		xhr.send(buffer);
	};

	LongPollingConnector.prototype.onResponse = function(response)
	{
		if(this.failureTimeout)
		{
			clearTimeout(this.failureTimeout);
			this.failureTimeout = 0;
		}
		if(this.requestTimeout)
		{
			clearTimeout(this.requestTimeout);
			this.requestTimeout = 0;
		}

		if(this.xhr.status == 200)
		{
			this.connected = true;
			if(Utils.isNotEmptyString(response) || (response instanceof ArrayBuffer))
			{
				this.callbacks.onMessage(response);
			}
			else
			{
				this.parent.session.mid = null;
			}
			this.performRequest();
		}
		else if(this.xhr.status == 304)
		{
			this.connected = true;
			if (this.xhr.getResponseHeader("Expires") === "Thu, 01 Jan 1973 11:11:01 GMT")
			{
				var lastMessageId = this.xhr.getResponseHeader("Last-Message-Id");
				if (Utils.isNotEmptyString(lastMessageId))
				{
					this.parent.setLastMessageId(lastMessageId);
				}
			}
			this.performRequest();
		}
		else
		{
			this.callbacks.onError('Could not connect to the server');
			this.connected = false;
		}
	};

	var ChannelManager = function (params)
	{
		this.publicIds = {};

		this.restClient = typeof params.restClient !== "undefined"? params.restClient: BX.rest;

		this.getPublicListMethod = params.getPublicListMethod;
	};

	/**
	 *
	 * @param {Array} users Array of user ids.
	 * @return {BX.Promise}
	 */
	ChannelManager.prototype.getPublicIds = function(users)
	{
		var promise = new BX.Promise();
		var result = {};
		var now = new Date();
		var unknownUsers = [];

		for(var i = 0; i < users.length; i++)
		{
			var userId = users[i];
			if(this.publicIds[userId] && this.publicIds[userId]['end'] > now)
			{
				result[userId] = this.publicIds[userId];
			}
			else
			{
				unknownUsers.push(userId);
			}
		}

		if(unknownUsers.length === 0)
		{
			promise.resolve(result);
			return promise;
		}

		this.restClient.callMethod(this.getPublicListMethod, {users: unknownUsers}).then(function(response)
		{
			if(response.error())
			{
				promise.resolve({});
				return promise;
			}

			var data = response.data();

			this.setPublicIds(Utils.objectValues(data));
			unknownUsers.forEach(function(userId) {
				result[userId] = this.publicIds[userId];
			}, this);

			promise.resolve(result);

		}.bind(this));

		return promise;
	};

	/**
	 *
	 * @param {object[]} publicIds
	 * @param {integer} publicIds.user_id
	 * @param {string} publicIds.public_id
	 * @param {string} publicIds.signature
	 * @param {Date} publicIds.start
	 * @param {Date} publicIds.end
	 */
	ChannelManager.prototype.setPublicIds = function(publicIds)
	{
		for(var i = 0; i < publicIds.length; i++)
		{
			var publicIdDescriptor = publicIds[i];
			var userId = publicIdDescriptor.user_id;
			this.publicIds[userId] = {
				userId: userId,
				publicId: publicIdDescriptor.public_id,
				signature: publicIdDescriptor.signature,
				start: new Date(publicIdDescriptor.start),
				end: new Date(publicIdDescriptor.end)
			}
		}
	};


	var StorageManager = function (params)
	{
		params = params || {};

		this.userId = params.userId? params.userId: (typeof BX.message !== 'undefined' && BX.message.USER_ID? BX.message.USER_ID: 0);
		this.siteId = params.siteId? params.siteId: (typeof BX.message !== 'undefined' && BX.message.SITE_ID? BX.message.SITE_ID: 'none');
	};

	StorageManager.prototype.set = function(name, value)
	{
		if (typeof window.localStorage === 'undefined')
		{
			return false;
		}
		if (typeof value != 'string')
		{
			if (value)
			{
				value = JSON.stringify(value);
			}
		}
		return window.localStorage.setItem(this.getKey(name), value)
	};


	StorageManager.prototype.get = function(name, defaultValue)
	{
		if (typeof window.localStorage === 'undefined')
		{
			return defaultValue || null;
		}

		var result = window.localStorage.getItem(this.getKey(name));
		if (result === null)
		{
			return defaultValue || null;
		}

		return JSON.parse(result);
	};

	StorageManager.prototype.remove = function(name)
	{
		if (typeof window.localStorage === 'undefined')
		{
			return false;
		}
		return window.localStorage.removeItem(this.getKey(name));
	};

	StorageManager.prototype.getKey = function (name)
	{
		return 'bx-pull-' + this.userId + '-' + this.siteId + '-' + name;
	};

	StorageManager.prototype.compareKey = function (eventKey, userKey)
	{
		return eventKey === this.getKey(userKey);
	};

	var Utils = {
		browser: {
			IsChrome: function()
			{
				return navigator.userAgent.toLowerCase().indexOf('chrome') != -1;
			},
			IsFirefox: function()
			{
				return navigator.userAgent.toLowerCase().indexOf('firefox') != -1;
			},
			IsIe: function ()
			{
				return navigator.userAgent.match(/(Trident\/|MSIE\/)/) !== null;
			}
		},
		getTimestamp: function()
		{
			return (new Date()).getTime();
		},
		/**
		 * Reduces errors array to single string.
		 * @param {array} errors
		 * @return {string}
		 */
		errorsToString: function(errors)
		{
			if(!this.isArray(errors))
			{
				return "";
			}
			else
			{
				return errors.reduce(function(result, currentValue)
				{
					if(result != "")
					{
						result += "; ";
					}
					return result + currentValue.code + ": " + currentValue.message;
				}, "");
			}
		},
		isString: function(item) {
			return item === '' ? true : (item ? (typeof (item) == "string" || item instanceof String) : false);
		},
		isArray: function(item) {
			return item && Object.prototype.toString.call(item) == "[object Array]";
		},
		isFunction: function(item) {
			return item === null ? false : (typeof (item) == "function" || item instanceof Function);
		},
		isDomNode: function(item) {
			return item && typeof (item) == "object" && "nodeType" in item;
		},
		isDate: function(item) {
			return item && Object.prototype.toString.call(item) == "[object Date]";
		},
		isPlainObject: function(item)
		{
			if(!item || typeof(item) !== "object" || item.nodeType)
			{
				return false;
			}

			var hasProp = Object.prototype.hasOwnProperty;
			try
			{
				if (item.constructor && !hasProp.call(item, "constructor") && !hasProp.call(item.constructor.prototype, "isPrototypeOf") )
				{
					return false;
				}
			}
			catch (e)
			{
				return false;
			}

			var key;
			for (key in item)
			{
			}
			return typeof(key) === "undefined" || hasProp.call(item, key);
		},
		isNotEmptyString: function(item) {
			return this.isString(item) ? item.length > 0 : false;
		},
		buildQueryString: function(params)
		{
			var result = '';
			for (var key in params)
			{
				if (!params.hasOwnProperty(key))
				{
					continue;
				}
				var value = params[key];
				if(Utils.isArray(value))
				{
					value.forEach(function(valueElement, index)
					{
						result += encodeURIComponent(key + "[" + index + "]") + "=" + encodeURIComponent(valueElement) + "&";
					});
				}
				else
				{
					result += encodeURIComponent(key) + "=" + encodeURIComponent(value) + "&";
				}
			}

			if(result.length > 0)
			{
				result = result.substr(0, result.length - 1);
			}
			return result;
		},
		objectValues: function values(obj)
		{
			var result = [];
			for (var key in obj)
			{
				if(obj.hasOwnProperty(key) && obj.propertyIsEnumerable(key))
				{
					result.push(obj[key]);
				}
			}
			return result;
		},
		clone: function(obj, bCopyObj)
		{
			var _obj, i, l;
			if (bCopyObj !== false)
				bCopyObj = true;

			if (obj === null)
				return null;

			if (this.isDomNode(obj))
			{
				_obj = obj.cloneNode(bCopyObj);
			}
			else if (typeof obj == 'object')
			{
				if (this.isArray(obj))
				{
					_obj = [];
					for (i=0,l=obj.length;i<l;i++)
					{
						if (typeof obj[i] == "object" && bCopyObj)
							_obj[i] = this.clone(obj[i], bCopyObj);
						else
							_obj[i] = obj[i];
					}
				}
				else
				{
					_obj =  {};
					if (obj.constructor)
					{
						if (this.isDate(obj))
							_obj = new Date(obj);
						else
							_obj = new obj.constructor();
					}

					for (i in obj)
					{
						if (!obj.hasOwnProperty(i))
						{
							continue;
						}
						if (typeof obj[i] == "object" && bCopyObj)
							_obj[i] = this.clone(obj[i], bCopyObj);
						else
							_obj[i] = obj[i];
					}
				}

			}
			else
			{
				_obj = obj;
			}

			return _obj;
		},

		getDateForLog: function()
		{
			var d = new Date();

			return d.getFullYear() + "-" + Utils.lpad(d.getMonth(), 2, '0') + "-" + Utils.lpad(d.getDate(), 2, '0') + " " + Utils.lpad(d.getHours(), 2, '0') + ":" + Utils.lpad(d.getMinutes(), 2, '0');
		},

		lpad: function(str, length, chr)
		{
			str = str.toString();
			chr = chr || ' ';

			if(str.length > length)
			{
				return str;
			}

			var result = '';
			for(var i = 0; i < length - str.length; i++)
			{
				result += chr;
			}

			return result + str;
		}
	};

	if (
		typeof BX.namespace !== 'undefined'
		&& typeof BX.PULL === 'undefined'
	)
	{
		BX.PULL = new Pull();
	}

	BX.PullClient = Pull;
	BX.PullClient.PullStatus = PullStatus;
	BX.PullClient.SubscriptionType = SubscriptionType;
	BX.PullClient.CloseReasons = CloseReasons;
	BX.PullClient.StorageManager = StorageManager;
})();



// file: /bitrix/js/pull/component/status/dist/status.bundle.js
(function (exports,ui_vue,pull_client) {
	'use strict';

	/**
	 * Bitrix UI
	 * Pull connection status Vue component
	 *
	 * @package bitrix
	 * @subpackage pull
	 * @copyright 2001-2019 Bitrix
	 */
	ui_vue.WidgetBitrixVue.component('bx-pull-component-status', {
	  /**
	   * @emits 'reconnect' {} - work only with props.canReconnect = true
	   */
	  props: {
	    canReconnect: {
	      "default": false
	    }
	  },
	  data: function data() {
	    return {
	      status: pull_client.PullClient.PullStatus.Online,
	      showed: null
	    };
	  },
	  created: function created() {
	    var _this = this;

	    this.isMac = navigator.userAgent.toLowerCase().includes('macintosh');
	    this.setStatusTimeout = null;
	    this.hideTimeout = null;

	    this.pullUnSubscribe = function () {};

	    if (this.$Bitrix.PullClient.get()) {
	      this.subscribe();
	    }

	    this.$Bitrix.eventEmitter.subscribe(ui_vue.WidgetBitrixVue.events.pullClientChange, function () {
	      return _this.subscribe();
	    });
	    window.component = this;
	  },
	  beforeDestroy: function beforeDestroy() {
	    this.pullUnSubscribe();
	  },
	  methods: {
	    subscribe: function subscribe() {
	      var _this2 = this;

	      this.pullUnSubscribe();
	      this.pullUnSubscribe = this.$Bitrix.PullClient.get().subscribe({
	        type: pull_client.PullClient.SubscriptionType.Status,
	        callback: function callback(event) {
	          return _this2.statusChange(event.status);
	        }
	      });
	    },
	    reconnect: function reconnect() {
	      if (this.canReconnect) {
	        this.$emit('reconnect');
	      } else {
	        location.reload();
	      }
	    },
	    statusChange: function statusChange(status) {
	      var _this3 = this;

	      clearTimeout(this.setStatusTimeout);

	      if (this.status === status) {
	        return false;
	      }

	      var validStatus = [pull_client.PullClient.PullStatus.Online, pull_client.PullClient.PullStatus.Offline, pull_client.PullClient.PullStatus.Connecting];

	      if (validStatus.indexOf(status) < 0) {
	        return false;
	      }

	      var timeout = 500;

	      if (status === pull_client.PullClient.PullStatus.Connecting) {
	        timeout = 5000;
	      } else if (status === pull_client.PullClient.PullStatus.Offline) {
	        timeout = 2000;
	      }

	      this.setStatusTimeout = setTimeout(function () {
	        _this3.status = status;
	        _this3.showed = true;
	      }, timeout);
	      return true;
	    },
	    isMobile: function isMobile() {
	      return navigator.userAgent.toLowerCase().includes('android') || navigator.userAgent.toLowerCase().includes('webos') || navigator.userAgent.toLowerCase().includes('iphone') || navigator.userAgent.toLowerCase().includes('ipad') || navigator.userAgent.toLowerCase().includes('ipod') || navigator.userAgent.toLowerCase().includes('blackberry') || navigator.userAgent.toLowerCase().includes('windows phone');
	    }
	  },
	  watch: {
	    status: function status() {
	      var _this4 = this;

	      clearTimeout(this.hideTimeout);

	      if (this.status === pull_client.PullClient.PullStatus.Online) {
	        clearTimeout(this.hideTimeout);
	        this.hideTimeout = setTimeout(function () {
	          return _this4.showed = false;
	        }, 4000);
	      }
	    }
	  },
	  computed: {
	    connectionClass: function connectionClass() {
	      var result = '';

	      if (this.showed === true) {
	        result = "bx-pull-status-show";
	      } else if (this.showed === false) {
	        result = "bx-pull-status-hide";
	      }

	      if (this.status === pull_client.PullClient.PullStatus.Online) {
	        result += " bx-pull-status-online";
	      } else if (this.status === pull_client.PullClient.PullStatus.Offline) {
	        result += " bx-pull-status-offline";
	      } else if (this.status === pull_client.PullClient.PullStatus.Connecting) {
	        result += " bx-pull-status-connecting";
	      }

	      return result;
	    },
	    connectionText: function connectionText() {
	      var result = '';

	      if (this.status === pull_client.PullClient.PullStatus.Online) {
	        result = this.localize.BX_PULL_STATUS_ONLINE;
	      } else if (this.status === pull_client.PullClient.PullStatus.Offline) {
	        result = this.localize.BX_PULL_STATUS_OFFLINE;
	      } else if (this.status === pull_client.PullClient.PullStatus.Connecting) {
	        result = this.localize.BX_PULL_STATUS_CONNECTING;
	      }

	      return result;
	    },
	    button: function button() {
	      var hotkey = '';
	      var name = '';

	      if (this.canReconnect) {
	        name = this.localize.BX_PULL_STATUS_BUTTON_RECONNECT;
	      } else {
	        hotkey = this.isMac ? '&#8984;+R' : "Ctrl+R";
	        name = this.localize.BX_PULL_STATUS_BUTTON_RELOAD;
	      }

	      return {
	        title: name,
	        key: hotkey
	      };
	    },
	    localize: function localize() {
	      return ui_vue.WidgetBitrixVue.getFilteredPhrases('BX_PULL_STATUS_', this);
	    }
	  },
	  template: "\n\t\t<div v-if=\"!isMobile()\" :class=\"['bx-pull-status', connectionClass]\">\n\t\t\t<div class=\"bx-pull-status-wrap\">\n\t\t\t\t<span class=\"bx-pull-status-text\">{{connectionText}}</span>\n\t\t\t\t<span class=\"bx-pull-status-button\" @click=\"reconnect\">\n\t\t\t\t\t<span class=\"bx-pull-status-button-title\">{{button.title}}</span>\n\t\t\t\t\t<span class=\"bx-pull-status-button-key\" v-html=\"button.key\"></span>\n\t\t\t\t</span>\n\t\t\t</div>\n\t\t</div>\n\t"
	});

}((this.window = this.window || {}),BX,BX));
 




// file: /bitrix/js/main/polyfill/intersectionobserver/js/intersectionobserver.js
/**
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the W3C SOFTWARE AND DOCUMENT NOTICE AND LICENSE.
 *
 * https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
 *
 */

;(function(window, document) {
	'use strict';

	if ('IntersectionObserver' in window &&
		'IntersectionObserverEntry' in window &&
		'intersectionRatio' in window.IntersectionObserverEntry.prototype)
	{

		// Minimal polyfill for Edge 15's lack of `isIntersecting`
		// See: https://github.com/w3c/IntersectionObserver/issues/211
		if (!('isIntersecting' in window.IntersectionObserverEntry.prototype))
		{
			Object.defineProperty(window.IntersectionObserverEntry.prototype,
				'isIntersecting', {
					get: function ()
					{
						return this.intersectionRatio > 0;
					}
				});
		}

		return;
	}


	/**
	 * An IntersectionObserver registry. This registry exists to hold a strong
	 * reference to IntersectionObserver instances currently observering a target
	 * element. Without this registry, instances without another reference may be
	 * garbage collected.
	 */
	var registry = [];


	/**
	 * Creates the global IntersectionObserverEntry constructor.
	 * https://w3c.github.io/IntersectionObserver/#intersection-observer-entry
	 * @param {Object} entry A dictionary of instance properties.
	 * @constructor
	 */
	function IntersectionObserverEntry(entry)
	{
		this.time = entry.time;
		this.target = entry.target;
		this.rootBounds = entry.rootBounds;
		this.boundingClientRect = entry.boundingClientRect;
		this.intersectionRect = entry.intersectionRect || getEmptyRect();
		this.isIntersecting = !!entry.intersectionRect;

		// Calculates the intersection ratio.
		var targetRect = this.boundingClientRect;
		var targetArea = targetRect.width * targetRect.height;
		var intersectionRect = this.intersectionRect;
		var intersectionArea = intersectionRect.width * intersectionRect.height;

		// Sets intersection ratio.
		if (targetArea)
		{
			this.intersectionRatio = intersectionArea / targetArea;
		}
		else
		{
			// If area is zero and is intersecting, sets to 1, otherwise to 0
			this.intersectionRatio = this.isIntersecting ? 1 : 0;
		}
	}


	/**
	 * Creates the global IntersectionObserver constructor.
	 * https://w3c.github.io/IntersectionObserver/#intersection-observer-interface
	 * @param {Function} callback The function to be invoked after intersection
	 *     changes have queued. The function is not invoked if the queue has
	 *     been emptied by calling the `takeRecords` method.
	 * @param {Object=} opt_options Optional configuration options.
	 * @constructor
	 */
	function IntersectionObserver(callback, opt_options)
	{
		var options = opt_options || {};

		if (typeof callback !== 'function')
		{
			throw new Error('callback must be a function');
		}

		if (options.root && options.root.nodeType !== 1)
		{
			throw new Error('root must be an Element');
		}

		// Binds and throttles `this._checkForIntersections`.
		this._checkForIntersections = throttle(
			this._checkForIntersections.bind(this), this.THROTTLE_TIMEOUT);

		// Private properties.
		this._callback = callback;
		this._observationTargets = [];
		this._queuedEntries = [];
		this._rootMarginValues = this._parseRootMargin(options.rootMargin);

		// Public properties.
		this.thresholds = this._initThresholds(options.threshold);
		this.root = options.root || null;
		this.rootMargin = this._rootMarginValues.map(function(margin) {
			return margin.value + margin.unit;
		}).join(' ');
	}


	/**
	 * The minimum interval within which the document will be checked for
	 * intersection changes.
	 */
	IntersectionObserver.prototype.THROTTLE_TIMEOUT = 100;


	/**
	 * The frequency in which the polyfill polls for intersection changes.
	 * this can be updated on a per instance basis and must be set prior to
	 * calling `observe` on the first target.
	 */
	IntersectionObserver.prototype.POLL_INTERVAL = null;

	/**
	 * Use a mutation observer on the root element
	 * to detect intersection changes.
	 */
	IntersectionObserver.prototype.USE_MUTATION_OBSERVER = true;


	/**
	 * Starts observing a target element for intersection changes based on
	 * the thresholds values.
	 * @param {Element} target The DOM element to observe.
	 */
	IntersectionObserver.prototype.observe = function(target)
	{
		var isTargetAlreadyObserved = this._observationTargets.some(function(item) {
			return item.element === target;
		});

		if (isTargetAlreadyObserved)
		{
			return;
		}

		if (!(target && target.nodeType === 1))
		{
			throw new Error('target must be an Element');
		}

		this._registerInstance();
		this._observationTargets.push({element: target, entry: null});
		this._monitorIntersections();
		this._checkForIntersections();
	};


	// noinspection JSUnusedGlobalSymbols
	/**
	 * Stops observing a target element for intersection changes.
	 * @param {Element} target The DOM element to observe.
	 */
	IntersectionObserver.prototype.unobserve = function(target)
	{
		this._observationTargets = this._observationTargets.filter(function(item) {
			return item.element !== target;
		});

		if (!this._observationTargets.length)
		{
			this._unmonitorIntersections();
			this._unregisterInstance();
		}
	};


	/**
	 * Stops observing all target elements for intersection changes.
	 */
	IntersectionObserver.prototype.disconnect = function()
	{
		this._observationTargets = [];
		this._unmonitorIntersections();
		this._unregisterInstance();
	};


	/**
	 * Returns any queue entries that have not yet been reported to the
	 * callback and clears the queue. This can be used in conjunction with the
	 * callback to obtain the absolute most up-to-date intersection information.
	 * @return {Array} The currently queued entries.
	 */
	IntersectionObserver.prototype.takeRecords = function()
	{
		var records = this._queuedEntries.slice();
		this._queuedEntries = [];
		return records;
	};


	/**
	 * Accepts the threshold value from the user configuration object and
	 * returns a sorted array of unique threshold values. If a value is not
	 * between 0 and 1 and error is thrown.
	 * @private
	 * @param {Array|number=} opt_threshold An optional threshold value or
	 *     a list of threshold values, defaulting to [0].
	 * @return {Array} A sorted list of unique and valid threshold values.
	 */
	IntersectionObserver.prototype._initThresholds = function(opt_threshold)
	{
		var threshold = opt_threshold || [0];

		if (!Array.isArray(threshold))
		{
			threshold = [threshold];
		}

		return threshold.sort().filter(function(t, i, a) {
			if (typeof t !== 'number' || isNaN(t) || t < 0 || t > 1)
			{
				throw new Error('threshold must be a number between 0 and 1 inclusively');
			}
			return t !== a[i - 1];
		});
	};


	/**
	 * Accepts the rootMargin value from the user configuration object
	 * and returns an array of the four margin values as an object containing
	 * the value and unit properties. If any of the values are not properly
	 * formatted or use a unit other than px or %, and error is thrown.
	 * @private
	 * @param {string=} opt_rootMargin An optional rootMargin value,
	 *     defaulting to '0px'.
	 * @return {Array<Object>} An array of margin objects with the keys
	 *     value and unit.
	 */
	IntersectionObserver.prototype._parseRootMargin = function(opt_rootMargin) {
		var marginString = opt_rootMargin || '0px';
		var margins = marginString.split(/\s+/).map(function(margin) {
			var parts = /^(-?\d*\.?\d+)(px|%)$/.exec(margin);
			if (!parts)
			{
				throw new Error('rootMargin must be specified in pixels or percent');
			}

			return {value: parseFloat(parts[1]), unit: parts[2]};
		});

		// Handles shorthand.
		margins[1] = margins[1] || margins[0];
		margins[2] = margins[2] || margins[0];
		margins[3] = margins[3] || margins[1];

		return margins;
	};


	/**
	 * Starts polling for intersection changes if the polling is not already
	 * happening, and if the page's visibilty state is visible.
	 * @private
	 */
	IntersectionObserver.prototype._monitorIntersections = function()
	{
		if (!this._monitoringIntersections)
		{
			this._monitoringIntersections = true;

			// If a poll interval is set, use polling instead of listening to
			// resize and scroll events or DOM mutations.
			if (this.POLL_INTERVAL)
			{
				this._monitoringInterval = setInterval(
					this._checkForIntersections, this.POLL_INTERVAL);
			}
			else
			{
				addEvent(window, 'resize', this._checkForIntersections, true);
				addEvent(document, 'scroll', this._checkForIntersections, true);

				if (this.USE_MUTATION_OBSERVER && 'MutationObserver' in window)
				{
					this._domObserver = new MutationObserver(this._checkForIntersections);
					this._domObserver.observe(document, {
						attributes: true,
						childList: true,
						characterData: true,
						subtree: true
					});
				}
			}
		}
	};


	/**
	 * Stops polling for intersection changes.
	 * @private
	 */
	IntersectionObserver.prototype._unmonitorIntersections = function()
	{
		if (this._monitoringIntersections)
		{
			this._monitoringIntersections = false;

			clearInterval(this._monitoringInterval);
			this._monitoringInterval = null;

			removeEvent(window, 'resize', this._checkForIntersections, true);
			removeEvent(document, 'scroll', this._checkForIntersections, true);

			if (this._domObserver)
			{
				this._domObserver.disconnect();
				this._domObserver = null;
			}
		}
	};


	/**
	 * Scans each observation target for intersection changes and adds them
	 * to the internal entries queue. If new entries are found, it
	 * schedules the callback to be invoked.
	 * @private
	 */
	IntersectionObserver.prototype._checkForIntersections = function()
	{
		var rootIsInDom = this._rootIsInDom();
		var rootRect = rootIsInDom ? this._getRootRect() : getEmptyRect();

		this._observationTargets.forEach(function(item) {
			var target = item.element;
			var targetRect = getBoundingClientRect(target);
			var rootContainsTarget = this._rootContainsTarget(target);
			var oldEntry = item.entry;
			var intersectionRect = rootIsInDom && rootContainsTarget &&
				this._computeTargetAndRootIntersection(target, rootRect);

			var newEntry = item.entry = new IntersectionObserverEntry({
				time: now(),
				target: target,
				boundingClientRect: targetRect,
				rootBounds: rootRect,
				intersectionRect: intersectionRect
			});

			if (!oldEntry)
			{
				this._queuedEntries.push(newEntry);
			}
			else if (rootIsInDom && rootContainsTarget)
			{
				// If the new entry intersection ratio has crossed any of the
				// thresholds, add a new entry.
				if (this._hasCrossedThreshold(oldEntry, newEntry))
				{
					this._queuedEntries.push(newEntry);
				}
			}
			else
			{
				// If the root is not in the DOM or target is not contained within
				// root but the previous entry for this target had an intersection,
				// add a new record indicating removal.
				if (oldEntry && oldEntry.isIntersecting)
				{
					this._queuedEntries.push(newEntry);
				}
			}
		}, this);

		if (this._queuedEntries.length)
		{
			this._callback(this.takeRecords(), this);
		}
	};


	/**
	 * Accepts a target and root rect computes the intersection between then
	 * following the algorithm in the spec.
	 * TODO(philipwalton): at this time clip-path is not considered.
	 * https://w3c.github.io/IntersectionObserver/#calculate-intersection-rect-algo
	 * @param {Element} target The target DOM element
	 * @param {Object} rootRect The bounding rect of the root after being
	 *     expanded by the rootMargin value.
	 * @return {?Object} The final intersection rect object or undefined if no
	 *     intersection is found.
	 * @private
	 */
	IntersectionObserver.prototype._computeTargetAndRootIntersection = function(target, rootRect)
	{
		// If the element isn't displayed, an intersection can't happen.
		if (window.getComputedStyle(target).display === 'none')
		{
			return;
		}

		var intersectionRect = getBoundingClientRect(target);
		var parent = getParentNode(target);
		var atRoot = false;

		while (!atRoot)
		{
			var parentRect = null;
			var parentComputedStyle = parent.nodeType === 1 ?
				window.getComputedStyle(parent) : {};

			// If the parent isn't displayed, an intersection can't happen.
			// noinspection EqualityComparisonWithCoercionJS
			if (parentComputedStyle.display == 'none')
			{
				return;
			}

			if (parent === this.root || parent === document)
			{
				atRoot = true;
				parentRect = rootRect;
			}
			else
			{
				// If the element has a non-visible overflow, and it's not the <body>
				// or <html> element, update the intersection rect.
				// Note: <body> and <html> cannot be clipped to a rect that's not also
				// the document rect, so no need to compute a new intersection.
				// noinspection EqualityComparisonWithCoercionJS
				if (parent != document.body &&
					parent != document.documentElement &&
					parentComputedStyle.overflow != 'visible')
				{
					parentRect = getBoundingClientRect(parent);
				}
			}

			// If either of the above conditionals set a new parentRect,
			// calculate new intersection data.
			if (parentRect)
			{
				intersectionRect = computeRectIntersection(parentRect, intersectionRect);

				if (!intersectionRect)
				{
					break;
				}
			}

			parent = getParentNode(parent);
		}

		return intersectionRect;
	};


	/**
	 * Returns the root rect after being expanded by the rootMargin value.
	 * @return {Object} The expanded root rect.
	 * @private
	 */
	IntersectionObserver.prototype._getRootRect = function()
	{
		var rootRect;

		if (this.root)
		{
			rootRect = getBoundingClientRect(this.root);
		}
		else
		{
			// Use <html>/<body> instead of window since scroll bars affect size.
			var html = document.documentElement;
			var body = document.body;
			rootRect = {
				top: 0,
				left: 0,
				right: html.clientWidth || body.clientWidth,
				width: html.clientWidth || body.clientWidth,
				bottom: html.clientHeight || body.clientHeight,
				height: html.clientHeight || body.clientHeight
			};
		}

		return this._expandRectByRootMargin(rootRect);
	};


	/**
	 * Accepts a rect and expands it by the rootMargin value.
	 * @param {Object} rect The rect object to expand.
	 * @return {Object} The expanded rect.
	 * @private
	 */
	IntersectionObserver.prototype._expandRectByRootMargin = function(rect)
	{
		var margins = this._rootMarginValues.map(function(margin, i) {
			return margin.unit === 'px' ? margin.value :
				margin.value * (i % 2 ? rect.width : rect.height) / 100;
		});
		var newRect = {
			top: rect.top - margins[0],
			right: rect.right + margins[1],
			bottom: rect.bottom + margins[2],
			left: rect.left - margins[3]
		};
		newRect.width = newRect.right - newRect.left;
		newRect.height = newRect.bottom - newRect.top;

		return newRect;
	};


	/**
	 * Accepts an old and new entry and returns true if at least one of the
	 * threshold values has been crossed.
	 * @param {?IntersectionObserverEntry} oldEntry The previous entry for a
	 *    particular target element or null if no previous entry exists.
	 * @param {IntersectionObserverEntry} newEntry The current entry for a
	 *    particular target element.
	 * @return {boolean} Returns true if a any threshold has been crossed.
	 * @private
	 */
	IntersectionObserver.prototype._hasCrossedThreshold = function(oldEntry, newEntry)
	{
		// To make comparing easier, an entry that has a ratio of 0
		// but does not actually intersect is given a value of -1
		var oldRatio = oldEntry && oldEntry.isIntersecting ?
			oldEntry.intersectionRatio || 0 : -1;
		var newRatio = newEntry.isIntersecting ?
			newEntry.intersectionRatio || 0 : -1;

		// Ignore unchanged ratios
		if (oldRatio === newRatio)
		{
			return;
		}

		for (var i = 0; i < this.thresholds.length; i++)
		{
			var threshold = this.thresholds[i];

			// Return true if an entry matches a threshold or if the new ratio
			// and the old ratio are on the opposite sides of a threshold.
			// noinspection EqualityComparisonWithCoercionJS
			if (threshold == oldRatio || threshold == newRatio ||
				threshold < oldRatio !== threshold < newRatio)
			{
				return true;
			}
		}
	};


	/**
	 * Returns whether or not the root element is an element and is in the DOM.
	 * @return {boolean} True if the root element is an element and is in the DOM.
	 * @private
	 */
	IntersectionObserver.prototype._rootIsInDom = function()
	{
		return !this.root || containsDeep(document, this.root);
	};


	/**
	 * Returns whether or not the target element is a child of root.
	 * @param {Element} target The target element to check.
	 * @return {boolean} True if the target element is a child of root.
	 * @private
	 */
	IntersectionObserver.prototype._rootContainsTarget = function(target)
	{
		return containsDeep(this.root || document, target);
	};


	/**
	 * Adds the instance to the global IntersectionObserver registry if it isn't
	 * already present.
	 * @private
	 */
	IntersectionObserver.prototype._registerInstance = function()
	{
		if (registry.indexOf(this) < 0)
		{
			registry.push(this);
		}
	};


	/**
	 * Removes the instance from the global IntersectionObserver registry.
	 * @private
	 */
	IntersectionObserver.prototype._unregisterInstance = function()
	{
		var index = registry.indexOf(this);

		if (index !== -1)
		{
			registry.splice(index, 1);
		}
	};


	/**
	 * Returns the result of the performance.now() method or null in browsers
	 * that don't support the API.
	 * @return {number} The elapsed time since the page was requested.
	 */
	function now()
	{
		return window.performance && performance.now && performance.now();
	}


	/**
	 * Throttles a function and delays its executiong, so it's only called at most
	 * once within a given time period.
	 * @param {Function} fn The function to throttle.
	 * @param {number} timeout The amount of time that must pass before the
	 *     function can be called again.
	 * @return {Function} The throttled function.
	 */
	function throttle(fn, timeout)
	{
		var timer = null;
		return function () {
			if (!timer) {
				timer = setTimeout(function() {
					fn();
					timer = null;
				}, timeout);
			}
		};
	}


	/**
	 * Adds an event handler to a DOM node ensuring cross-browser compatibility.
	 * @param {Node|Window|HTMLDocument} node The DOM node to add the event handler to.
	 * @param {string} event The event name.
	 * @param {Function} fn The event handler to add.
	 * @param {boolean} opt_useCapture Optionally adds the even to the capture
	 *     phase. Note: this only works in modern browsers.
	 */
	function addEvent(node, event, fn, opt_useCapture)
	{
		// noinspection EqualityComparisonWithCoercionJS
		if (typeof node.addEventListener == 'function')
		{
			node.addEventListener(event, fn, opt_useCapture || false);
		}
		else if (typeof node.attachEvent === 'function')
		{
			node.attachEvent('on' + event, fn);
		}
	}


	/**
	 * Removes a previously added event handler from a DOM node.
	 * @param {Node|Window|Document} node The DOM node to remove the event handler from.
	 * @param {string} event The event name.
	 * @param {Function} fn The event handler to remove.
	 * @param {boolean} opt_useCapture If the event handler was added with this
	 *     flag set to true, it should be set to true here in order to remove it.
	 */
	function removeEvent(node, event, fn, opt_useCapture)
	{
		if (typeof node.removeEventListener === 'function')
		{
			node.removeEventListener(event, fn, opt_useCapture || false);
		}
		else if (typeof node.detatchEvent === 'function')
		{
			node.detatchEvent('on' + event, fn);
		}
	}


	/**
	 * Returns the intersection between two rect objects.
	 * @param {Object} rect1 The first rect.
	 * @param {Object} rect2 The second rect.
	 * @return {?Object} The intersection rect or undefined if no intersection
	 *     is found.
	 */
	function computeRectIntersection(rect1, rect2)
	{
		var top = Math.max(rect1.top, rect2.top);
		var bottom = Math.min(rect1.bottom, rect2.bottom);
		var left = Math.max(rect1.left, rect2.left);
		var right = Math.min(rect1.right, rect2.right);
		var width = right - left;
		var height = bottom - top;

		return (width >= 0 && height >= 0) && {
			top: top,
			bottom: bottom,
			left: left,
			right: right,
			width: width,
			height: height
		};
	}


	/**
	 * Shims the native getBoundingClientRect for compatibility with older IE.
	 * @param {Element} el The element whose bounding rect to get.
	 * @return {Object} The (possibly shimmed) rect of the element.
	 */
	function getBoundingClientRect(el)
	{
		var rect;

		try
		{
			rect = el.getBoundingClientRect();
		}
		catch (err)
		{
			// Ignore Windows 7 IE11 "Unspecified error"
			// https://github.com/w3c/IntersectionObserver/pull/205
		}

		if (!rect)
		{
			return getEmptyRect();
		}

		// Older IE
		if (!(rect.width && rect.height))
		{
			rect = {
				top: rect.top,
				right: rect.right,
				bottom: rect.bottom,
				left: rect.left,
				width: rect.right - rect.left,
				height: rect.bottom - rect.top
			};
		}

		return rect;
	}


	/**
	 * Returns an empty rect object. An empty rect is returned when an element
	 * is not in the DOM.
	 * @return {Object} The empty rect.
	 */
	function getEmptyRect()
	{
		return {
			top: 0,
			bottom: 0,
			left: 0,
			right: 0,
			width: 0,
			height: 0
		};
	}

	/**
	 * Checks to see if a parent element contains a child element (including inside
	 * shadow DOM).
	 * @param {Node} parent The parent element.
	 * @param {Node} child The child element.
	 * @return {boolean} True if the parent node contains the child node.
	 */
	function containsDeep(parent, child)
	{
		var node = child;

		while (node)
		{
			if (node === parent)
			{
				return true;
			}

			node = getParentNode(node);
		}

		return false;
	}


	/**
	 * Gets the parent node of an element or its host element if the parent node
	 * is a shadow root.
	 * @param {Node} node The node whose parent to get.
	 * @return {Node|null} The parent node or null if no parent exists.
	 */
	function getParentNode(node)
	{
		var parent = node.parentNode;

		// noinspection EqualityComparisonWithCoercionJS
		if (parent && parent.nodeType == 11 && parent.host)
		{
			// If the parent is a shadow root, return the host element.
			return parent.host;
		}

		return parent;
	}

	// Exposes the constructors globally.
	window.IntersectionObserver = IntersectionObserver;
	window.IntersectionObserverEntry = IntersectionObserverEntry;

}(window, document));



// file: /bitrix/js/ui/vue/directives/lazyload/dist/lazyload.bundle.js
(function (exports,ui_vue) {
	'use strict';

	/**
	 * Image Lazy Load Vue directive
	 *
	 * @package bitrix
	 * @subpackage ui
	 * @copyright 2001-2019 Bitrix
	 */
	var WATCH = 'bx-lazyload-watch';
	var LOADING = 'bx-lazyload-loading';
	var SUCCESS = 'bx-lazyload-success';
	var ERROR = 'bx-lazyload-error';
	var HIDDEN = 'bx-lazyload-hidden';
	var BLANK_IMAGE = "data:image/svg+xml,%3Csvg width='1px' height='1px' xmlns='http://www.w3.org/2000/svg'%3E%3C/svg%3E";
	var lazyloadObserver = null;

	var lazyloadLoadImage = function lazyloadLoadImage(currentImage, callback) {
	  var SUCCESS_CLASS = currentImage.dataset.lazyloadSuccessClass ? currentImage.dataset.lazyloadSuccessClass.split(" ") : [];
	  delete currentImage.dataset.lazyloadSuccessClass;
	  SUCCESS_CLASS = [SUCCESS].concat(babelHelpers.toConsumableArray(SUCCESS_CLASS));
	  var ERROR_CLASS = currentImage.dataset.lazyloadErrorClass ? currentImage.dataset.lazyloadErrorClass.split(" ") : [];
	  delete currentImage.dataset.lazyloadErrorClass;
	  ERROR_CLASS = [ERROR].concat(babelHelpers.toConsumableArray(ERROR_CLASS));
	  currentImage.classList.add(LOADING);
	  var newImage = new Image();
	  newImage.src = currentImage.dataset.lazyloadSrc;

	  if (!currentImage.dataset.lazyloadHiddenSrc) {
	    currentImage.dataset.lazyloadHiddenSrc = currentImage.src;
	  }

	  newImage.onload = function () {
	    var _currentImage$classLi;

	    if (currentImage.classList.contains(HIDDEN)) {
	      return false;
	    }

	    if (currentImage.dataset.lazyloadSrc) {
	      currentImage.src = currentImage.dataset.lazyloadSrc;
	    }

	    currentImage.classList.remove(LOADING);

	    (_currentImage$classLi = currentImage.classList).add.apply(_currentImage$classLi, babelHelpers.toConsumableArray(SUCCESS_CLASS));

	    if (typeof currentImage.lazyloadCallback === 'function') {
	      currentImage.lazyloadCallback({
	        element: currentImage,
	        state: 'success'
	      });
	      delete currentImage.lazyloadCallback;
	    }
	  };

	  newImage.onerror = function () {
	    var _currentImage$classLi2;

	    if (currentImage.classList.contains(HIDDEN)) {
	      return false;
	    }

	    currentImage.classList.remove(LOADING);

	    (_currentImage$classLi2 = currentImage.classList).add.apply(_currentImage$classLi2, babelHelpers.toConsumableArray(ERROR_CLASS));

	    currentImage.title = '';
	    currentImage.alt = '';

	    if (typeof currentImage.lazyloadCallback === 'function') {
	      currentImage.lazyloadCallback({
	        element: currentImage,
	        state: 'error'
	      });
	      delete currentImage.lazyloadCallback;
	    }
	  };

	  if (typeof currentImage.dataset.lazyloadDontHide !== 'undefined') {
	    currentImage.classList.remove(WATCH);
	    delete currentImage.dataset.lazyloadDontHide;

	    if (lazyloadObserver) {
	      lazyloadObserver.unobserve(currentImage);
	    }
	  }
	};

	if (typeof window.IntersectionObserver !== 'undefined') {
	  lazyloadObserver = new IntersectionObserver(function (entries, observer) {
	    entries.forEach(function (entry) {
	      var currentImage = entry.target;

	      if (entry.isIntersecting) {
	        if (currentImage.classList.contains(HIDDEN)) {
	          if (currentImage.dataset.lazyloadSrc) {
	            currentImage.src = currentImage.dataset.lazyloadSrc;
	          }

	          currentImage.classList.remove(HIDDEN);
	        } else if (currentImage.classList.contains(WATCH)) {
	          return true;
	        } else {
	          currentImage.classList.add(WATCH);
	          lazyloadLoadImage(currentImage);
	        }
	      } else {
	        if (currentImage.classList.contains(HIDDEN) || !currentImage.classList.contains(WATCH)) {
	          return true;
	        }

	        if (currentImage.dataset.lazyloadHiddenSrc) {
	          currentImage.src = currentImage.dataset.lazyloadHiddenSrc;
	        }

	        currentImage.classList.remove(LOADING);
	        currentImage.classList.add(HIDDEN);
	      }
	    });
	  }, {
	    threshold: [0, 1]
	  });
	}

	ui_vue.WidgetBitrixVue.directive('bx-lazyload', {
	  bind: function bind(element, bindings) {
	    if (babelHelpers["typeof"](bindings.value) === 'object' && typeof bindings.value.callback === 'function') {
	      element.lazyloadCallback = bindings.value.callback;
	    }

	    if (!element.src || element.src === location.href.replace(location.hash, '')) {
	      element.src = BLANK_IMAGE;
	    }

	    if (lazyloadObserver) {
	      lazyloadObserver.observe(element);
	    } else {
	      lazyloadLoadImage(element);
	    }
	  },
	  componentUpdated: function componentUpdated(element) {
	    if (!element.classList.contains(SUCCESS) && !element.classList.contains(ERROR) && !element.classList.contains(WATCH) && !element.classList.contains(LOADING)) {
	      element.classList.add(LOADING);
	    } else if ((element.classList.contains(SUCCESS) || element.classList.contains(ERROR)) && element.dataset.lazyloadSrc && element.dataset.lazyloadSrc !== element.src) {
	      if (!element.dataset.lazyloadSrc.startsWith('http')) {
	        var url = document.createElement('a');
	        url.href = element.dataset.lazyloadSrc;

	        if (url.href === element.src) {
	          return;
	        }
	      }

	      lazyloadLoadImage(element);
	    }
	  },
	  unbind: function unbind(element) {
	    if (lazyloadObserver) {
	      lazyloadObserver.unobserve(element);
	    }
	  }
	});

}((this.window = this.window || {}),BX));
 




// file: /bitrix/js/ui/dexie/dist/dexie.bitrix.bundle.js
(function (exports) {
   'use strict';

   /*
    * Dexie.js - a minimalistic wrapper for IndexedDB
    * ===============================================
    *
    * By David Fahlander, david.fahlander@gmail.com
    *
    * Version 2.0.4, Fri May 25 2018
    *
    * http://dexie.org
    *
    * Apache License Version 2.0, January 2004, http://www.apache.org/licenses/
    */

   /**
    * Modify list for integration with Bitrix Framework:
    * - removed integration with third-party package builders;
    * - add check variables before using them, see tags: 28122018;
    * - add alternative Promise check for Bitrix Cli, see tags: 02032020;
    * - add export for work in Bitrix CoreJS extensions;
    */
   var keys = Object.keys;
   var isArray = Array.isArray;

   var _global = typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : global;

   function extend(obj, extension) {
     if (babelHelpers["typeof"](extension) !== 'object') return obj;
     keys(extension).forEach(function (key) {
       obj[key] = extension[key];
     });
     return obj;
   }

   var getProto = Object.getPrototypeOf;
   var _hasOwn = {}.hasOwnProperty;

   function hasOwn(obj, prop) {
     return _hasOwn.call(obj, prop);
   }

   function props(proto, extension) {
     if (typeof extension === 'function') extension = extension(getProto(proto)); // tag start 28122018

     if (babelHelpers["typeof"](extension) !== 'object') return; // tag end 28122018

     keys(extension).forEach(function (key) {
       setProp(proto, key, extension[key]);
     });
   }

   var defineProperty = Object.defineProperty;

   function setProp(obj, prop, functionOrGetSet, options) {
     defineProperty(obj, prop, extend(functionOrGetSet && hasOwn(functionOrGetSet, "get") && typeof functionOrGetSet.get === 'function' ? {
       get: functionOrGetSet.get,
       set: functionOrGetSet.set,
       configurable: true
     } : {
       value: functionOrGetSet,
       configurable: true,
       writable: true
     }, options));
   }

   function derive(Child) {
     return {
       from: function from(Parent) {
         Child.prototype = Object.create(Parent.prototype);
         setProp(Child.prototype, "constructor", Child);
         return {
           extend: props.bind(null, Child.prototype)
         };
       }
     };
   }

   var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

   function getPropertyDescriptor(obj, prop) {
     var pd = getOwnPropertyDescriptor(obj, prop),
         proto;
     return pd || (proto = getProto(obj)) && getPropertyDescriptor(proto, prop);
   }

   var _slice = [].slice;

   function slice(args, start, end) {
     return _slice.call(args, start, end);
   }

   function override(origFunc, overridedFactory) {
     return overridedFactory(origFunc);
   }

   function assert(b) {
     if (!b) throw new Error("Assertion Failed");
   }

   function asap(fn) {
     if (_global.setImmediate) setImmediate(fn);else setTimeout(fn, 0);
   }
   /** Generate an object (hash map) based on given array.
    * @param extractor Function taking an array item and its index and returning an array of 2 items ([key, value]) to
    *        instert on the resulting object for each item in the array. If this function returns a falsy value, the
    *        current item wont affect the resulting object.
    */


   function arrayToObject(array, extractor) {
     return array.reduce(function (result, item, i) {
       var nameAndValue = extractor(item, i);
       if (nameAndValue) result[nameAndValue[0]] = nameAndValue[1];
       return result;
     }, {});
   }

   function trycatcher(fn, reject) {
     return function () {
       try {
         fn.apply(this, arguments);
       } catch (e) {
         reject(e);
       }
     };
   }

   function tryCatch(fn, onerror, args) {
     try {
       fn.apply(null, args);
     } catch (ex) {
       onerror && onerror(ex);
     }
   }

   function getByKeyPath(obj, keyPath) {
     // http://www.w3.org/TR/IndexedDB/#steps-for-extracting-a-key-from-a-value-using-a-key-path
     if (hasOwn(obj, keyPath)) return obj[keyPath]; // This line is moved from last to first for optimization purpose.

     if (!keyPath) return obj;

     if (typeof keyPath !== 'string') {
       var rv = [];

       for (var i = 0, l = keyPath.length; i < l; ++i) {
         var val = getByKeyPath(obj, keyPath[i]);
         rv.push(val);
       }

       return rv;
     }

     var period = keyPath.indexOf('.');

     if (period !== -1) {
       var innerObj = obj[keyPath.substr(0, period)];
       return innerObj === undefined ? undefined : getByKeyPath(innerObj, keyPath.substr(period + 1));
     }

     return undefined;
   }

   function setByKeyPath(obj, keyPath, value) {
     if (!obj || keyPath === undefined) return;
     if ('isFrozen' in Object && Object.isFrozen(obj)) return;

     if (typeof keyPath !== 'string' && 'length' in keyPath) {
       assert(typeof value !== 'string' && 'length' in value);

       for (var i = 0, l = keyPath.length; i < l; ++i) {
         setByKeyPath(obj, keyPath[i], value[i]);
       }
     } else {
       var period = keyPath.indexOf('.');

       if (period !== -1) {
         var currentKeyPath = keyPath.substr(0, period);
         var remainingKeyPath = keyPath.substr(period + 1);
         if (remainingKeyPath === "") {
           if (value === undefined) delete obj[currentKeyPath];else obj[currentKeyPath] = value;
         } else {
           var innerObj = obj[currentKeyPath];
           if (!innerObj) innerObj = obj[currentKeyPath] = {};
           setByKeyPath(innerObj, remainingKeyPath, value);
         }
       } else {
         if (value === undefined) delete obj[keyPath];else obj[keyPath] = value;
       }
     }
   }

   function delByKeyPath(obj, keyPath) {
     if (typeof keyPath === 'string') setByKeyPath(obj, keyPath, undefined);else if ('length' in keyPath) [].map.call(keyPath, function (kp) {
       setByKeyPath(obj, kp, undefined);
     });
   }

   function shallowClone(obj) {
     var rv = {};

     for (var m in obj) {
       if (hasOwn(obj, m)) rv[m] = obj[m];
     }

     return rv;
   }

   var concat = [].concat;

   function flatten(a) {
     return concat.apply([], a);
   } //https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm


   var intrinsicTypes = "Boolean,String,Date,RegExp,Blob,File,FileList,ArrayBuffer,DataView,Uint8ClampedArray,ImageData,Map,Set".split(',').concat(flatten([8, 16, 32, 64].map(function (num) {
     return ["Int", "Uint", "Float"].map(function (t) {
       return t + num + "Array";
     });
   }))).filter(function (t) {
     return _global[t];
   }).map(function (t) {
     return _global[t];
   });

   function deepClone(any) {
     if (!any || babelHelpers["typeof"](any) !== 'object') return any;
     var rv;

     if (isArray(any)) {
       rv = [];

       for (var i = 0, l = any.length; i < l; ++i) {
         rv.push(deepClone(any[i]));
       }
     } else if (intrinsicTypes.indexOf(any.constructor) >= 0) {
       rv = any;
     } else {
       rv = any.constructor ? Object.create(any.constructor.prototype) : {};

       for (var prop in any) {
         if (hasOwn(any, prop)) {
           rv[prop] = deepClone(any[prop]);
         }
       }
     }

     return rv;
   }

   function getObjectDiff(a, b, rv, prfx) {
     // Compares objects a and b and produces a diff object.
     rv = rv || {};
     prfx = prfx || '';
     keys(a).forEach(function (prop) {
       if (!hasOwn(b, prop)) rv[prfx + prop] = undefined; // Property removed
       else {
         var ap = a[prop],
             bp = b[prop];
         if (babelHelpers["typeof"](ap) === 'object' && babelHelpers["typeof"](bp) === 'object' && ap && bp && // Now compare constructors are same (not equal because wont work in Safari)
         '' + ap.constructor === '' + bp.constructor) // Same type of object but its properties may have changed
           getObjectDiff(ap, bp, rv, prfx + prop + ".");else if (ap !== bp) rv[prfx + prop] = b[prop]; // Primitive value changed
       }
     });
     keys(b).forEach(function (prop) {
       if (!hasOwn(a, prop)) {
         rv[prfx + prop] = b[prop]; // Property added
       }
     });
     return rv;
   } // If first argument is iterable or array-like, return it as an array


   var iteratorSymbol = typeof Symbol !== 'undefined' && Symbol.iterator;
   var getIteratorOf = iteratorSymbol ? function (x) {
     var i;
     return x != null && (i = x[iteratorSymbol]) && i.apply(x);
   } : function () {
     return null;
   };
   var NO_CHAR_ARRAY = {}; // Takes one or several arguments and returns an array based on the following criteras:
   // * If several arguments provided, return arguments converted to an array in a way that
   //   still allows javascript engine to optimize the code.
   // * If single argument is an array, return a clone of it.
   // * If this-pointer equals NO_CHAR_ARRAY, don't accept strings as valid iterables as a special
   //   case to the two bullets below.
   // * If single argument is an iterable, convert it to an array and return the resulting array.
   // * If single argument is array-like (has length of type number), convert it to an array.

   function getArrayOf(arrayLike) {
     var i, a, x, it;

     if (arguments.length === 1) {
       if (isArray(arrayLike)) return arrayLike.slice();
       if (this === NO_CHAR_ARRAY && typeof arrayLike === 'string') return [arrayLike];

       if (it = getIteratorOf(arrayLike)) {
         a = [];

         while (x = it.next(), !x.done) {
           a.push(x.value);
         }

         return a;
       }

       if (arrayLike == null) return [arrayLike];
       i = arrayLike.length;

       if (typeof i === 'number') {
         a = new Array(i);

         while (i--) {
           a[i] = arrayLike[i];
         }

         return a;
       }

       return [arrayLike];
     }

     i = arguments.length;
     a = new Array(i);

     while (i--) {
       a[i] = arguments[i];
     }

     return a;
   } // By default, debug will be true only if platform is a web platform and its page is served from localhost.
   // When debug = true, error's stacks will contain asyncronic long stacks.


   var debug = typeof location !== 'undefined' && // By default, use debug mode if served from localhost.
   /^(http|https):\/\/(localhost|127\.0\.0\.1)/.test(location.href);

   function setDebug(value, filter) {
     debug = value;
     libraryFilter = filter;
   }

   var libraryFilter = function libraryFilter() {
     return true;
   };

   var NEEDS_THROW_FOR_STACK = !new Error("").stack;

   function getErrorWithStack() {

     if (NEEDS_THROW_FOR_STACK) try {
       throw new Error(); // Fallback if above line don't throw.
     } catch (e) {
       return e;
     }
     return new Error();
   }

   function prettyStack(exception, numIgnoredFrames) {
     var stack = exception.stack;
     if (!stack) return "";
     numIgnoredFrames = numIgnoredFrames || 0;
     if (stack.indexOf(exception.name) === 0) numIgnoredFrames += (exception.name + exception.message).split('\n').length;
     return stack.split('\n').slice(numIgnoredFrames).filter(libraryFilter).map(function (frame) {
       return "\n" + frame;
     }).join('');
   }

   function deprecated(what, fn) {
     return function () {
       console.warn(what + " is deprecated. See https://github.com/dfahlander/Dexie.js/wiki/Deprecations. " + prettyStack(getErrorWithStack(), 1));
       return fn.apply(this, arguments);
     };
   }

   var dexieErrorNames = ['Modify', 'Bulk', 'OpenFailed', 'VersionChange', 'Schema', 'Upgrade', 'InvalidTable', 'MissingAPI', 'NoSuchDatabase', 'InvalidArgument', 'SubTransaction', 'Unsupported', 'Internal', 'DatabaseClosed', 'PrematureCommit', 'ForeignAwait'];
   var idbDomErrorNames = ['Unknown', 'Constraint', 'Data', 'TransactionInactive', 'ReadOnly', 'Version', 'NotFound', 'InvalidState', 'InvalidAccess', 'Abort', 'Timeout', 'QuotaExceeded', 'Syntax', 'DataClone'];
   var errorList = dexieErrorNames.concat(idbDomErrorNames);
   var defaultTexts = {
     VersionChanged: "Database version changed by other database connection",
     DatabaseClosed: "Database has been closed",
     Abort: "Transaction aborted",
     TransactionInactive: "Transaction has already completed or failed"
   }; //
   // DexieError - base class of all out exceptions.
   //

   function DexieError(name, msg) {
     // Reason we don't use ES6 classes is because:
     // 1. It bloats transpiled code and increases size of minified code.
     // 2. It doesn't give us much in this case.
     // 3. It would require sub classes to call super(), which
     //    is not needed when deriving from Error.
     this._e = getErrorWithStack();
     this.name = name;
     this.message = msg;
   }

   derive(DexieError).from(Error).extend({
     stack: {
       get: function get() {
         return this._stack || (this._stack = this.name + ": " + this.message + prettyStack(this._e, 2));
       }
     },
     toString: function toString() {
       return this.name + ": " + this.message;
     }
   });

   function getMultiErrorMessage(msg, failures) {
     return msg + ". Errors: " + failures.map(function (f) {
       return f.toString();
     }).filter(function (v, i, s) {
       return s.indexOf(v) === i;
     }) // Only unique error strings
     .join('\n');
   } //
   // ModifyError - thrown in Collection.modify()
   // Specific constructor because it contains members failures and failedKeys.
   //


   function ModifyError(msg, failures, successCount, failedKeys) {
     this._e = getErrorWithStack();
     this.failures = failures;
     this.failedKeys = failedKeys;
     this.successCount = successCount;
   }

   derive(ModifyError).from(DexieError);

   function BulkError(msg, failures) {
     this._e = getErrorWithStack();
     this.name = "BulkError";
     this.failures = failures;
     this.message = getMultiErrorMessage(msg, failures);
   }

   derive(BulkError).from(DexieError); //
   //
   // Dynamically generate error names and exception classes based
   // on the names in errorList.
   //
   //
   // Map of {ErrorName -> ErrorName + "Error"}

   var errnames = errorList.reduce(function (obj, name) {
     return obj[name] = name + "Error", obj;
   }, {}); // Need an alias for DexieError because we're gonna create subclasses with the same name.

   var BaseException = DexieError; // Map of {ErrorName -> exception constructor}

   var exceptions = errorList.reduce(function (obj, name) {
     // Let the name be "DexieError" because this name may
     // be shown in call stack and when debugging. DexieError is
     // the most true name because it derives from DexieError,
     // and we cannot change Function.name programatically without
     // dynamically create a Function object, which would be considered
     // 'eval-evil'.
     var fullName = name + "Error";

     function DexieError(msgOrInner, inner) {
       this._e = getErrorWithStack();
       this.name = fullName;

       if (!msgOrInner) {
         this.message = defaultTexts[name] || fullName;
         this.inner = null;
       } else if (typeof msgOrInner === 'string') {
         this.message = msgOrInner;
         this.inner = inner || null;
       } else if (babelHelpers["typeof"](msgOrInner) === 'object') {
         this.message = msgOrInner.name + " " + msgOrInner.message;
         this.inner = msgOrInner;
       }
     }

     derive(DexieError).from(BaseException);
     obj[name] = DexieError;
     return obj;
   }, {}); // Use ECMASCRIPT standard exceptions where applicable:

   exceptions.Syntax = SyntaxError;
   exceptions.Type = TypeError;
   exceptions.Range = RangeError;
   var exceptionMap = idbDomErrorNames.reduce(function (obj, name) {
     obj[name + "Error"] = exceptions[name];
     return obj;
   }, {});

   function mapError(domError, message) {
     if (!domError || domError instanceof DexieError || domError instanceof TypeError || domError instanceof SyntaxError || !domError.name || !exceptionMap[domError.name]) return domError;
     var rv = new exceptionMap[domError.name](message || domError.message, domError);

     if ("stack" in domError) {
       // Derive stack from inner exception if it has a stack
       setProp(rv, "stack", {
         get: function get() {
           return this.inner.stack;
         }
       });
     }

     return rv;
   }

   var fullNameExceptions = errorList.reduce(function (obj, name) {
     if (["Syntax", "Type", "Range"].indexOf(name) === -1) obj[name + "Error"] = exceptions[name];
     return obj;
   }, {});
   fullNameExceptions.ModifyError = ModifyError;
   fullNameExceptions.DexieError = DexieError;
   fullNameExceptions.BulkError = BulkError;

   function nop() {}

   function mirror(val) {
     return val;
   }

   function pureFunctionChain(f1, f2) {
     // Enables chained events that takes ONE argument and returns it to the next function in chain.
     // This pattern is used in the hook("reading") event.
     if (f1 == null || f1 === mirror) return f2;
     return function (val) {
       return f2(f1(val));
     };
   }

   function callBoth(on1, on2) {
     return function () {
       on1.apply(this, arguments);
       on2.apply(this, arguments);
     };
   }

   function hookCreatingChain(f1, f2) {
     // Enables chained events that takes several arguments and may modify first argument by making a modification and then returning the same instance.
     // This pattern is used in the hook("creating") event.
     if (f1 === nop) return f2;
     return function () {
       var res = f1.apply(this, arguments);
       if (res !== undefined) arguments[0] = res;
       var onsuccess = this.onsuccess,
           // In case event listener has set this.onsuccess
       onerror = this.onerror; // In case event listener has set this.onerror

       this.onsuccess = null;
       this.onerror = null;
       var res2 = f2.apply(this, arguments);
       if (onsuccess) this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;
       if (onerror) this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;
       return res2 !== undefined ? res2 : res;
     };
   }

   function hookDeletingChain(f1, f2) {
     if (f1 === nop) return f2;
     return function () {
       f1.apply(this, arguments);
       var onsuccess = this.onsuccess,
           // In case event listener has set this.onsuccess
       onerror = this.onerror; // In case event listener has set this.onerror

       this.onsuccess = this.onerror = null;
       f2.apply(this, arguments);
       if (onsuccess) this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;
       if (onerror) this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;
     };
   }

   function hookUpdatingChain(f1, f2) {
     if (f1 === nop) return f2;
     return function (modifications) {
       var res = f1.apply(this, arguments);
       extend(modifications, res); // If f1 returns new modifications, extend caller's modifications with the result before calling next in chain.

       var onsuccess = this.onsuccess,
           // In case event listener has set this.onsuccess
       onerror = this.onerror; // In case event listener has set this.onerror

       this.onsuccess = null;
       this.onerror = null;
       var res2 = f2.apply(this, arguments);
       if (onsuccess) this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;
       if (onerror) this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;
       return res === undefined ? res2 === undefined ? undefined : res2 : extend(res, res2);
     };
   }

   function reverseStoppableEventChain(f1, f2) {
     if (f1 === nop) return f2;
     return function () {
       if (f2.apply(this, arguments) === false) return false;
       return f1.apply(this, arguments);
     };
   }

   function promisableChain(f1, f2) {
     if (f1 === nop) return f2;
     return function () {
       var res = f1.apply(this, arguments);

       if (res && typeof res.then === 'function') {
         var thiz = this,
             i = arguments.length,
             args = new Array(i);

         while (i--) {
           args[i] = arguments[i];
         }

         return res.then(function () {
           return f2.apply(thiz, args);
         });
       }

       return f2.apply(this, arguments);
     };
   }
   /*
    * Copyright (c) 2014-2017 David Fahlander
    * Apache License Version 2.0, January 2004, http://www.apache.org/licenses/LICENSE-2.0
    */
   //
   // Promise and Zone (PSD) for Dexie library
   //
   // I started out writing this Promise class by copying promise-light (https://github.com/taylorhakes/promise-light) by
   // https://github.com/taylorhakes - an A+ and ECMASCRIPT 6 compliant Promise implementation.
   //
   // In previous versions this was fixed by not calling setTimeout when knowing that the resolve() or reject() came from another
   // tick. In Dexie v1.4.0, I've rewritten the Promise class entirely. Just some fragments of promise-light is left. I use
   // another strategy now that simplifies everything a lot: to always execute callbacks in a new micro-task, but have an own micro-task
   // engine that is indexedDB compliant across all browsers.
   // Promise class has also been optimized a lot with inspiration from bluebird - to avoid closures as much as possible.
   // Also with inspiration from bluebird, asyncronic stacks in debug mode.
   //
   // Specific non-standard features of this Promise class:
   // * Custom zone support (a.k.a. PSD) with ability to keep zones also when using native promises as well as
   //   native async / await.
   // * Promise.follow() method built upon the custom zone engine, that allows user to track all promises created from current stack frame
   //   and below + all promises that those promises creates or awaits.
   // * Detect any unhandled promise in a PSD-scope (PSD.onunhandled).
   //
   // David Fahlander, https://github.com/dfahlander
   //
   // Just a pointer that only this module knows about.
   // Used in Promise constructor to emulate a private constructor.


   var INTERNAL = {}; // Async stacks (long stacks) must not grow infinitely.

   var LONG_STACKS_CLIP_LIMIT = 100;
   var MAX_LONG_STACKS = 20;
   var ZONE_ECHO_LIMIT = 7;

   var nativePromiseInstanceAndProto = function () {
     try {
       // Be able to patch native async functions
       return new Function("let F=async ()=>{},p=F();return [p,Object.getPrototypeOf(p),Promise.resolve(),F.constructor];")();
     } catch (e) {
       var P = _global.Promise;
       return P ? [P.resolve(), P.prototype, P.resolve()] : [];
     }
   }();

   var resolvedNativePromise = nativePromiseInstanceAndProto[0];
   var nativePromiseProto = nativePromiseInstanceAndProto[1];
   var resolvedGlobalPromise = nativePromiseInstanceAndProto[2];
   var nativePromiseThen = nativePromiseProto && nativePromiseProto.then;
   var NativePromise = resolvedNativePromise && resolvedNativePromise.constructor;
   var AsyncFunction = nativePromiseInstanceAndProto[3];
   var patchGlobalPromise = !!resolvedGlobalPromise;
   var stack_being_generated = false;
   /* The default function used only for the very first promise in a promise chain.
      As soon as then promise is resolved or rejected, all next tasks will be executed in micro ticks
      emulated in this module. For indexedDB compatibility, this means that every method needs to
      execute at least one promise before doing an indexedDB operation. Dexie will always call
      db.ready().then() for every operation to make sure the indexedDB event is started in an
      indexedDB-compatible emulated micro task loop.
   */

   var schedulePhysicalTick = resolvedGlobalPromise ? function () {
     resolvedGlobalPromise.then(physicalTick);
   } : _global.setImmediate ? // setImmediate supported. Those modern platforms also supports Function.bind().
   setImmediate.bind(null, physicalTick) : _global.MutationObserver ? // MutationObserver supported
   function () {
     var hiddenDiv = document.createElement("div");
     new MutationObserver(function () {
       physicalTick();
       hiddenDiv = null;
     }).observe(hiddenDiv, {
       attributes: true
     });
     hiddenDiv.setAttribute('i', '1');
   } : // No support for setImmediate or MutationObserver. No worry, setTimeout is only called
   // once time. Every tick that follows will be our emulated micro tick.
   // Could have uses setTimeout.bind(null, 0, physicalTick) if it wasnt for that FF13 and below has a bug
   function () {
     setTimeout(physicalTick, 0);
   }; // Configurable through Promise.scheduler.
   // Don't export because it would be unsafe to let unknown
   // code call it unless they do try..catch within their callback.
   // This function can be retrieved through getter of Promise.scheduler though,
   // but users must not do Promise.scheduler = myFuncThatThrowsException

   var asap$1 = function asap$1(callback, args) {
     microtickQueue.push([callback, args]);

     if (needsNewPhysicalTick) {
       schedulePhysicalTick();
       needsNewPhysicalTick = false;
     }
   };

   var isOutsideMicroTick = true;
   var needsNewPhysicalTick = true;
   var unhandledErrors = [];
   var rejectingErrors = [];
   var currentFulfiller = null;
   var rejectionMapper = mirror; // Remove in next major when removing error mapping of DOMErrors and DOMExceptions

   var globalPSD = {
     id: 'global',
     global: true,
     ref: 0,
     unhandleds: [],
     onunhandled: globalError,
     pgp: false,
     env: {},
     finalize: function finalize() {
       this.unhandleds.forEach(function (uh) {
         try {
           globalError(uh[0], uh[1]);
         } catch (e) {}
       });
     }
   };
   var PSD = globalPSD;
   var microtickQueue = []; // Callbacks to call in this or next physical tick.

   var numScheduledCalls = 0; // Number of listener-calls left to do in this physical tick.

   var tickFinalizers = []; // Finalizers to call when there are no more async calls scheduled within current physical tick.

   function Promise(fn) {
     if (babelHelpers["typeof"](this) !== 'object') throw new TypeError('Promises must be constructed via new');
     this._listeners = [];
     this.onuncatched = nop; // Deprecate in next major. Not needed. Better to use global error handler.
     // A library may set `promise._lib = true;` after promise is created to make resolve() or reject()
     // execute the microtask engine implicitely within the call to resolve() or reject().
     // To remain A+ compliant, a library must only set `_lib=true` if it can guarantee that the stack
     // only contains library code when calling resolve() or reject().
     // RULE OF THUMB: ONLY set _lib = true for promises explicitely resolving/rejecting directly from
     // global scope (event handler, timer etc)!

     this._lib = false; // Current async scope

     var psd = this._PSD = PSD;

     if (debug) {
       this._stackHolder = getErrorWithStack();
       this._prev = null;
       this._numPrev = 0; // Number of previous promises (for long stacks)
     }

     if (typeof fn !== 'function') {
       if (fn !== INTERNAL) throw new TypeError('Not a function'); // Private constructor (INTERNAL, state, value).
       // Used internally by Promise.resolve() and Promise.reject().

       this._state = arguments[1];
       this._value = arguments[2];
       if (this._state === false) handleRejection(this, this._value); // Map error, set stack and addPossiblyUnhandledError().

       return;
     }

     this._state = null; // null (=pending), false (=rejected) or true (=resolved)

     this._value = null; // error or result

     ++psd.ref; // Refcounting current scope

     executePromiseTask(this, fn);
   } // Prepare a property descriptor to put onto Promise.prototype.then


   var thenProp = {
     get: function get() {
       var psd = PSD,
           microTaskId = totalEchoes;

       function then(onFulfilled, onRejected) {
         var _this = this;

         var possibleAwait = !psd.global && (psd !== PSD || microTaskId !== totalEchoes);
         if (possibleAwait) decrementExpectedAwaits();
         var rv = new Promise(function (resolve, reject) {
           propagateToListener(_this, new Listener(nativeAwaitCompatibleWrap(onFulfilled, psd, possibleAwait), nativeAwaitCompatibleWrap(onRejected, psd, possibleAwait), resolve, reject, psd));
         });
         debug && linkToPreviousPromise(rv, this);
         return rv;
       }

       then.prototype = INTERNAL; // For idempotense, see setter below.

       return then;
     },
     // Be idempotent and allow another framework (such as zone.js or another instance of a Dexie.Promise module) to replace Promise.prototype.then
     // and when that framework wants to restore the original property, we must identify that and restore the original property descriptor.
     set: function set(value) {
       setProp(this, 'then', value && value.prototype === INTERNAL ? thenProp : // Restore to original property descriptor.
       {
         get: function get() {
           return value; // Getter returning provided value (behaves like value is just changed)
         },
         set: thenProp.set // Keep a setter that is prepared to restore original.

       });
     }
   };
   props(Promise.prototype, {
     then: thenProp,
     _then: function _then(onFulfilled, onRejected) {
       // A little tinier version of then() that don't have to create a resulting promise.
       propagateToListener(this, new Listener(null, null, onFulfilled, onRejected, PSD));
     },
     "catch": function _catch(onRejected) {
       if (arguments.length === 1) return this.then(null, onRejected); // First argument is the Error type to catch

       var type = arguments[0],
           handler = arguments[1];
       return typeof type === 'function' ? this.then(null, function (err) {
         // Catching errors by its constructor type (similar to java / c++ / c#)
         // Sample: promise.catch(TypeError, function (e) { ... });
         return err instanceof type ? handler(err) : PromiseReject(err);
       }) : this.then(null, function (err) {
         // Catching errors by the error.name property. Makes sense for indexedDB where error type
         // is always DOMError but where e.name tells the actual error type.
         // Sample: promise.catch('ConstraintError', function (e) { ... });
         return err && err.name === type ? handler(err) : PromiseReject(err);
       });
     },
     "finally": function _finally(onFinally) {
       return this.then(function (value) {
         onFinally();
         return value;
       }, function (err) {
         onFinally();
         return PromiseReject(err);
       });
     },
     stack: {
       get: function get() {
         if (this._stack) return this._stack;

         try {
           stack_being_generated = true;
           var stacks = getStack(this, [], MAX_LONG_STACKS);
           var stack = stacks.join("\nFrom previous: ");
           if (this._state !== null) this._stack = stack; // Stack may be updated on reject.

           return stack;
         } finally {
           stack_being_generated = false;
         }
       }
     },
     timeout: function timeout(ms, msg) {
       var _this = this;

       return ms < Infinity ? new Promise(function (resolve, reject) {
         var handle = setTimeout(function () {
           return reject(new exceptions.Timeout(msg));
         }, ms);

         _this.then(resolve, reject)["finally"](clearTimeout.bind(null, handle));
       }) : this;
     }
   });
   if (typeof Symbol !== 'undefined' && Symbol.toStringTag) setProp(Promise.prototype, Symbol.toStringTag, 'Promise'); // Now that Promise.prototype is defined, we have all it takes to set globalPSD.env.
   // Environment globals snapshotted on leaving global zone

   globalPSD.env = snapShot();

   function Listener(onFulfilled, onRejected, resolve, reject, zone) {
     this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;
     this.onRejected = typeof onRejected === 'function' ? onRejected : null;
     this.resolve = resolve;
     this.reject = reject;
     this.psd = zone;
   } // Promise Static Properties


   props(Promise, {
     all: function all() {
       var values = getArrayOf.apply(null, arguments) // Supports iterables, implicit arguments and array-like.
       .map(onPossibleParallellAsync); // Handle parallell async/awaits

       return new Promise(function (resolve, reject) {
         if (values.length === 0) resolve([]);
         var remaining = values.length;
         values.forEach(function (a, i) {
           return Promise.resolve(a).then(function (x) {
             values[i] = x;
             if (! --remaining) resolve(values);
           }, reject);
         });
       });
     },
     resolve: function resolve(value) {
       if (value instanceof Promise) return value;
       if (value && typeof value.then === 'function') return new Promise(function (resolve, reject) {
         value.then(resolve, reject);
       });
       var rv = new Promise(INTERNAL, true, value);
       linkToPreviousPromise(rv, currentFulfiller);
       return rv;
     },
     reject: PromiseReject,
     race: function race() {
       var values = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);
       return new Promise(function (resolve, reject) {
         values.map(function (value) {
           return Promise.resolve(value).then(resolve, reject);
         });
       });
     },
     PSD: {
       get: function get() {
         return PSD;
       },
       set: function set(value) {
         return PSD = value;
       }
     },
     //totalEchoes: {get: ()=>totalEchoes},
     //task: {get: ()=>task},
     newPSD: newScope,
     usePSD: usePSD,
     scheduler: {
       get: function get() {
         return asap$1;
       },
       set: function set(value) {
         asap$1 = value;
       }
     },
     rejectionMapper: {
       get: function get() {
         return rejectionMapper;
       },
       set: function set(value) {
         rejectionMapper = value;
       } // Map reject failures

     },
     follow: function follow(fn, zoneProps) {
       return new Promise(function (resolve, reject) {
         return newScope(function (resolve, reject) {
           var psd = PSD;
           psd.unhandleds = []; // For unhandled standard- or 3rd party Promises. Checked at psd.finalize()

           psd.onunhandled = reject; // Triggered directly on unhandled promises of this library.

           psd.finalize = callBoth(function () {
             var _this = this; // Unhandled standard or 3rd part promises are put in PSD.unhandleds and
             // examined upon scope completion while unhandled rejections in this Promise
             // will trigger directly through psd.onunhandled


             run_at_end_of_this_or_next_physical_tick(function () {
               _this.unhandleds.length === 0 ? resolve() : reject(_this.unhandleds[0]);
             });
           }, psd.finalize);
           fn();
         }, zoneProps, resolve, reject);
       });
     }
   });
   /**
   * Take a potentially misbehaving resolver function and make sure
   * onFulfilled and onRejected are only called once.
   *
   * Makes no guarantees about asynchrony.
   */

   function executePromiseTask(promise, fn) {
     // Promise Resolution Procedure:
     // https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure
     try {
       fn(function (value) {
         if (promise._state !== null) return; // Already settled

         if (value === promise) throw new TypeError('A promise cannot be resolved with itself.');
         var shouldExecuteTick = promise._lib && beginMicroTickScope();

         if (value && typeof value.then === 'function') {
           executePromiseTask(promise, function (resolve, reject) {
             value instanceof Promise ? value._then(resolve, reject) : value.then(resolve, reject);
           });
         } else {
           promise._state = true;
           promise._value = value;
           propagateAllListeners(promise);
         }

         if (shouldExecuteTick) endMicroTickScope();
       }, handleRejection.bind(null, promise)); // If Function.bind is not supported. Exception is handled in catch below
     } catch (ex) {
       handleRejection(promise, ex);
     }
   }

   function handleRejection(promise, reason) {
     rejectingErrors.push(reason);
     if (!promise || promise._state !== null) // tag 28122018
       return;
     var shouldExecuteTick = promise._lib && beginMicroTickScope();
     reason = rejectionMapper(reason);
     promise._state = false;
     promise._value = reason;
     debug && reason !== null && babelHelpers["typeof"](reason) === 'object' && !reason._promise && tryCatch(function () {
       var origProp = getPropertyDescriptor(reason, "stack");
       reason._promise = promise;
       setProp(reason, "stack", {
         get: function get() {
           return stack_being_generated ? origProp && (origProp.get ? origProp.get.apply(reason) : origProp.value) : promise.stack;
         }
       });
     }); // Add the failure to a list of possibly uncaught errors

     addPossiblyUnhandledError(promise);
     propagateAllListeners(promise);
     if (shouldExecuteTick) endMicroTickScope();
   }

   function propagateAllListeners(promise) {
     //debug && linkToPreviousPromise(promise);
     var listeners = promise._listeners;
     promise._listeners = [];

     for (var i = 0, len = listeners.length; i < len; ++i) {
       propagateToListener(promise, listeners[i]);
     }

     var psd = promise._PSD;
     --psd.ref || psd.finalize(); // if psd.ref reaches zero, call psd.finalize();

     if (numScheduledCalls === 0) {
       // If numScheduledCalls is 0, it means that our stack is not in a callback of a scheduled call,
       // and that no deferreds where listening to this rejection or success.
       // Since there is a risk that our stack can contain application code that may
       // do stuff after this code is finished that may generate new calls, we cannot
       // call finalizers here.
       ++numScheduledCalls;
       asap$1(function () {
         if (--numScheduledCalls === 0) finalizePhysicalTick(); // Will detect unhandled errors
       }, []);
     }
   }

   function propagateToListener(promise, listener) {
     if (promise._state === null) {
       promise._listeners.push(listener);

       return;
     }

     var cb = promise._state ? listener.onFulfilled : listener.onRejected;

     if (cb === null) {
       // This Listener doesnt have a listener for the event being triggered (onFulfilled or onReject) so lets forward the event to any eventual listeners on the Promise instance returned by then() or catch()
       return (promise._state ? listener.resolve : listener.reject)(promise._value);
     }

     ++listener.psd.ref;
     ++numScheduledCalls;
     asap$1(callListener, [cb, promise, listener]);
   }

   function callListener(cb, promise, listener) {
     try {
       // Set static variable currentFulfiller to the promise that is being fullfilled,
       // so that we connect the chain of promises (for long stacks support)
       currentFulfiller = promise; // Call callback and resolve our listener with it's return value.

       var ret,
           value = promise._value;

       if (promise._state) {
         // cb is onResolved
         ret = cb(value);
       } else {
         // cb is onRejected
         if (rejectingErrors.length) rejectingErrors = [];
         ret = cb(value);
         if (rejectingErrors.indexOf(value) === -1) markErrorAsHandled(promise); // Callback didnt do Promise.reject(err) nor reject(err) onto another promise.
       }

       listener.resolve(ret);
     } catch (e) {
       // Exception thrown in callback. Reject our listener.
       listener.reject(e);
     } finally {
       // Restore env and currentFulfiller.
       currentFulfiller = null;
       if (--numScheduledCalls === 0) finalizePhysicalTick();
       --listener.psd.ref || listener.psd.finalize();
     }
   }

   function getStack(promise, stacks, limit) {
     if (stacks.length === limit) return stacks;
     var stack = "";

     if (promise._state === false) {
       var failure = promise._value,
           errorName,
           message;

       if (failure != null) {
         errorName = failure.name || "Error";
         message = failure.message || failure;
         stack = prettyStack(failure, 0);
       } else {
         errorName = failure; // If error is undefined or null, show that.

         message = "";
       }

       stacks.push(errorName + (message ? ": " + message : "") + stack);
     }

     if (debug) {
       stack = prettyStack(promise._stackHolder, 2);
       if (stack && stacks.indexOf(stack) === -1) stacks.push(stack);
       if (promise._prev) getStack(promise._prev, stacks, limit);
     }

     return stacks;
   }

   function linkToPreviousPromise(promise, prev) {
     // Support long stacks by linking to previous completed promise.
     var numPrev = prev ? prev._numPrev + 1 : 0;

     if (numPrev < LONG_STACKS_CLIP_LIMIT) {
       promise._prev = prev;
       promise._numPrev = numPrev;
     }
   }
   /* The callback to schedule with setImmediate() or setTimeout().
      It runs a virtual microtick and executes any callback registered in microtickQueue.
    */


   function physicalTick() {
     beginMicroTickScope() && endMicroTickScope();
   }

   function beginMicroTickScope() {
     var wasRootExec = isOutsideMicroTick;
     isOutsideMicroTick = false;
     needsNewPhysicalTick = false;
     return wasRootExec;
   }
   /* Executes micro-ticks without doing try..catch.
      This can be possible because we only use this internally and
      the registered functions are exception-safe (they do try..catch
      internally before calling any external method). If registering
      functions in the microtickQueue that are not exception-safe, this
      would destroy the framework and make it instable. So we don't export
      our asap method.
   */


   function endMicroTickScope() {
     var callbacks, i, l;

     do {
       while (microtickQueue.length > 0) {
         callbacks = microtickQueue;
         microtickQueue = [];
         l = callbacks.length;

         for (i = 0; i < l; ++i) {
           var item = callbacks[i];
           item[0].apply(null, item[1]);
         }
       }
     } while (microtickQueue.length > 0);

     isOutsideMicroTick = true;
     needsNewPhysicalTick = true;
   }

   function finalizePhysicalTick() {
     var unhandledErrs = unhandledErrors;
     unhandledErrors = [];
     unhandledErrs.forEach(function (p) {
       p._PSD.onunhandled.call(null, p._value, p);
     });
     var finalizers = tickFinalizers.slice(0); // Clone first because finalizer may remove itself from list.

     var i = finalizers.length;

     while (i) {
       finalizers[--i]();
     }
   }

   function run_at_end_of_this_or_next_physical_tick(fn) {
     function finalizer() {
       fn();
       tickFinalizers.splice(tickFinalizers.indexOf(finalizer), 1);
     }

     tickFinalizers.push(finalizer);
     ++numScheduledCalls;
     asap$1(function () {
       if (--numScheduledCalls === 0) finalizePhysicalTick();
     }, []);
   }

   function addPossiblyUnhandledError(promise) {
     // Only add to unhandledErrors if not already there. The first one to add to this list
     // will be upon the first rejection so that the root cause (first promise in the
     // rejection chain) is the one listed.
     if (!unhandledErrors.some(function (p) {
       return p._value === promise._value;
     })) unhandledErrors.push(promise);
   }

   function markErrorAsHandled(promise) {
     // Called when a reject handled is actually being called.
     // Search in unhandledErrors for any promise whos _value is this promise_value (list
     // contains only rejected promises, and only one item per error)
     var i = unhandledErrors.length;

     while (i) {
       if (unhandledErrors[--i]._value === promise._value) {
         // Found a promise that failed with this same error object pointer,
         // Remove that since there is a listener that actually takes care of it.
         unhandledErrors.splice(i, 1);
         return;
       }
     }
   }

   function PromiseReject(reason) {
     return new Promise(INTERNAL, false, reason);
   }

   function wrap(fn, errorCatcher) {
     var psd = PSD;
     return function () {
       var wasRootExec = beginMicroTickScope(),
           outerScope = PSD;

       try {
         switchToZone(psd, true);
         return fn.apply(this, arguments);
       } catch (e) {
         errorCatcher && errorCatcher(e);
       } finally {
         switchToZone(outerScope, false);
         if (wasRootExec) endMicroTickScope();
       }
     };
   } //
   // variables used for native await support
   //


   var task = {
     awaits: 0,
     echoes: 0,
     id: 0
   }; // The ongoing macro-task when using zone-echoing.

   var taskCounter = 0; // ID counter for macro tasks.

   var zoneStack = []; // Stack of left zones to restore asynchronically.

   var zoneEchoes = 0; // zoneEchoes is a must in order to persist zones between native await expressions.

   var totalEchoes = 0; // ID counter for micro-tasks. Used to detect possible native await in our Promise.prototype.then.

   var zone_id_counter = 0;

   function newScope(fn, props$$1, a1, a2) {
     var parent = PSD,
         psd = Object.create(parent);
     psd.parent = parent;
     psd.ref = 0;
     psd.global = false;
     psd.id = ++zone_id_counter; // Prepare for promise patching (done in usePSD):

     var globalEnv = globalPSD.env;
     psd.env = patchGlobalPromise ? {
       Promise: Promise,
       PromiseProp: {
         value: Promise,
         configurable: true,
         writable: true
       },
       all: Promise.all,
       race: Promise.race,
       resolve: Promise.resolve,
       reject: Promise.reject,
       nthen: getPatchedPromiseThen(globalEnv.nthen, psd),
       gthen: getPatchedPromiseThen(globalEnv.gthen, psd) // global then

     } : {};
     if (props$$1) extend(psd, props$$1); // unhandleds and onunhandled should not be specifically set here.
     // Leave them on parent prototype.
     // unhandleds.push(err) will push to parent's prototype
     // onunhandled() will call parents onunhandled (with this scope's this-pointer though!)

     ++parent.ref;

     psd.finalize = function () {
       --this.parent.ref || this.parent.finalize();
     };

     var rv = usePSD(psd, fn, a1, a2);
     if (psd.ref === 0) psd.finalize();
     return rv;
   } // Function to call if scopeFunc returns NativePromise
   // Also for each NativePromise in the arguments to Promise.all()


   function incrementExpectedAwaits() {
     if (!task.id) task.id = ++taskCounter;
     ++task.awaits;
     task.echoes += ZONE_ECHO_LIMIT;
     return task.id;
   } // Function to call when 'then' calls back on a native promise where onAwaitExpected() had been called.
   // Also call this when a native await calls then method on a promise. In that case, don't supply
   // sourceTaskId because we already know it refers to current task.


   function decrementExpectedAwaits(sourceTaskId) {
     if (!task.awaits || sourceTaskId && sourceTaskId !== task.id) return;
     if (--task.awaits === 0) task.id = 0;
     task.echoes = task.awaits * ZONE_ECHO_LIMIT; // Will reset echoes to 0 if awaits is 0.
   } // Call from Promise.all() and Promise.race()


   function onPossibleParallellAsync(possiblePromise) {
     if (task.echoes && possiblePromise && possiblePromise.constructor === NativePromise) {
       incrementExpectedAwaits();
       return possiblePromise.then(function (x) {
         decrementExpectedAwaits();
         return x;
       }, function (e) {
         decrementExpectedAwaits();
         return rejection(e);
       });
     }

     return possiblePromise;
   }

   function zoneEnterEcho(targetZone) {
     ++totalEchoes;

     if (!task.echoes || --task.echoes === 0) {
       task.echoes = task.id = 0; // Cancel zone echoing.
     }

     zoneStack.push(PSD);
     switchToZone(targetZone, true);
   }

   function zoneLeaveEcho() {
     var zone = zoneStack[zoneStack.length - 1];
     zoneStack.pop();
     switchToZone(zone, false);
   }

   function switchToZone(targetZone, bEnteringZone) {
     var currentZone = PSD;

     if (bEnteringZone ? task.echoes && (!zoneEchoes++ || targetZone !== PSD) : zoneEchoes && (! --zoneEchoes || targetZone !== PSD)) {
       // Enter or leave zone asynchronically as well, so that tasks initiated during current tick
       // will be surrounded by the zone when they are invoked.
       enqueueNativeMicroTask(bEnteringZone ? zoneEnterEcho.bind(null, targetZone) : zoneLeaveEcho);
     }

     if (targetZone === PSD) return;
     PSD = targetZone; // The actual zone switch occurs at this line.
     // Snapshot on every leave from global zone.

     if (currentZone === globalPSD) globalPSD.env = snapShot();

     if (patchGlobalPromise) {
       // Let's patch the global and native Promises (may be same or may be different)
       var GlobalPromise = globalPSD.env.Promise; // Swich environments (may be PSD-zone or the global zone. Both apply.)

       var targetEnv = targetZone.env; // Change Promise.prototype.then for native and global Promise (they MAY differ on polyfilled environments, but both can be accessed)
       // Must be done on each zone change because the patched method contains targetZone in its closure.

       nativePromiseProto.then = targetEnv.nthen;
       GlobalPromise.prototype.then = targetEnv.gthen;

       if (currentZone.global || targetZone.global) {
         // Leaving or entering global zone. It's time to patch / restore global Promise.
         // Set this Promise to window.Promise so that transiled async functions will work on Firefox, Safari and IE, as well as with Zonejs and angular.
         Object.defineProperty(_global, 'Promise', targetEnv.PromiseProp); // Support Promise.all() etc to work indexedDB-safe also when people are including es6-promise as a module (they might
         // not be accessing global.Promise but a local reference to it)

         GlobalPromise.all = targetEnv.all;
         GlobalPromise.race = targetEnv.race;
         GlobalPromise.resolve = targetEnv.resolve;
         GlobalPromise.reject = targetEnv.reject;
       }
     }
   }

   function snapShot() {
     var GlobalPromise = _global.Promise || Promise; // tag 02032020

     return patchGlobalPromise ? {
       Promise: GlobalPromise,
       PromiseProp: Object.getOwnPropertyDescriptor(_global, "Promise"),
       all: GlobalPromise.all,
       race: GlobalPromise.race,
       resolve: GlobalPromise.resolve,
       reject: GlobalPromise.reject,
       nthen: nativePromiseProto.then,
       gthen: GlobalPromise.prototype.then
     } : {};
   }

   function usePSD(psd, fn, a1, a2, a3) {
     var outerScope = PSD;

     try {
       switchToZone(psd, true);
       return fn(a1, a2, a3);
     } finally {
       switchToZone(outerScope, false);
     }
   }

   function enqueueNativeMicroTask(job) {
     //
     // Precondition: nativePromiseThen !== undefined
     //
     nativePromiseThen.call(resolvedNativePromise, job);
   }

   function nativeAwaitCompatibleWrap(fn, zone, possibleAwait) {
     return typeof fn !== 'function' ? fn : function () {
       var outerZone = PSD;
       if (possibleAwait) incrementExpectedAwaits();
       switchToZone(zone, true);

       try {
         return fn.apply(this, arguments);
       } finally {
         switchToZone(outerZone, false);
       }
     };
   }

   function getPatchedPromiseThen(origThen, zone) {
     return function (onResolved, onRejected) {
       return origThen.call(this, nativeAwaitCompatibleWrap(onResolved, zone, false), nativeAwaitCompatibleWrap(onRejected, zone, false));
     };
   }

   var UNHANDLEDREJECTION = "unhandledrejection";

   function globalError(err, promise) {
     var rv;

     try {
       rv = promise.onuncatched(err);
     } catch (e) {}

     if (rv !== false) try {
       var event,
           eventData = {
         promise: promise,
         reason: err
       };

       if (_global.document && document.createEvent) {
         event = document.createEvent('Event');
         event.initEvent(UNHANDLEDREJECTION, true, true);
         extend(event, eventData);
       } else if (_global.CustomEvent) {
         event = new CustomEvent(UNHANDLEDREJECTION, {
           detail: eventData
         });
         extend(event, eventData);
       }

       if (event && _global.dispatchEvent) {
         dispatchEvent(event);
         if (!_global.PromiseRejectionEvent && _global.onunhandledrejection) // No native support for PromiseRejectionEvent but user has set window.onunhandledrejection. Manually call it.
           try {
             _global.onunhandledrejection(event);
           } catch (_) {}
       }

       if (!event.defaultPrevented) {
         console.warn("Unhandled rejection: " + (err.stack || err));
       }
     } catch (e) {}
   }

   var rejection = Promise.reject;

   function Events(ctx) {
     var evs = {};

     var rv = function rv(eventName, subscriber) {
       if (subscriber) {
         // Subscribe. If additional arguments than just the subscriber was provided, forward them as well.
         var i = arguments.length,
             args = new Array(i - 1);

         while (--i) {
           args[i - 1] = arguments[i];
         }

         evs[eventName].subscribe.apply(null, args);
         return ctx;
       } else if (typeof eventName === 'string') {
         // Return interface allowing to fire or unsubscribe from event
         return evs[eventName];
       }
     };

     rv.addEventType = add;

     for (var i = 1, l = arguments.length; i < l; ++i) {
       add(arguments[i]);
     }

     return rv;

     function add(eventName, chainFunction, defaultFunction) {
       if (babelHelpers["typeof"](eventName) === 'object') return addConfiguredEvents(eventName);
       if (!chainFunction) chainFunction = reverseStoppableEventChain;
       if (!defaultFunction) defaultFunction = nop;
       var context = {
         subscribers: [],
         fire: defaultFunction,
         subscribe: function subscribe(cb) {
           if (context.subscribers.indexOf(cb) === -1) {
             context.subscribers.push(cb);
             context.fire = chainFunction(context.fire, cb);
           }
         },
         unsubscribe: function unsubscribe(cb) {
           context.subscribers = context.subscribers.filter(function (fn) {
             return fn !== cb;
           });
           context.fire = context.subscribers.reduce(chainFunction, defaultFunction);
         }
       };
       evs[eventName] = rv[eventName] = context;
       return context;
     }

     function addConfiguredEvents(cfg) {
       // events(this, {reading: [functionChain, nop]});
       keys(cfg).forEach(function (eventName) {
         var args = cfg[eventName];

         if (isArray(args)) {
           add(eventName, cfg[eventName][0], cfg[eventName][1]);
         } else if (args === 'asap') {
           // Rather than approaching event subscription using a functional approach, we here do it in a for-loop where subscriber is executed in its own stack
           // enabling that any exception that occur wont disturb the initiator and also not nescessary be catched and forgotten.
           var context = add(eventName, mirror, function fire() {
             // Optimazation-safe cloning of arguments into args.
             var i = arguments.length,
                 args = new Array(i);

             while (i--) {
               args[i] = arguments[i];
             } // All each subscriber:


             context.subscribers.forEach(function (fn) {
               asap(function fireEvent() {
                 fn.apply(null, args);
               });
             });
           });
         } else throw new exceptions.InvalidArgument("Invalid event config");
       });
     }
   }
   /*
    * Dexie.js - a minimalistic wrapper for IndexedDB
    * ===============================================
    *
    * Copyright (c) 2014-2017 David Fahlander
    *
    * Version 2.0.4, Fri May 25 2018
    *
    * http://dexie.org
    *
    * Apache License Version 2.0, January 2004, http://www.apache.org/licenses/LICENSE-2.0
    *
    */


   var DEXIE_VERSION = '2.0.4';
   var maxString = String.fromCharCode(65535);

   var maxKey = function () {
     try {
       IDBKeyRange.only([[]]);
       return [[]];
     } catch (e) {
       return maxString;
     }
   }();

   var minKey = -Infinity;
   var INVALID_KEY_ARGUMENT = "Invalid key provided. Keys must be of type string, number, Date or Array<string | number | Date>.";
   var STRING_EXPECTED = "String expected.";
   var connections = [];
   var isIEOrEdge = typeof navigator !== 'undefined' && /(MSIE|Trident|Edge)/.test(navigator.userAgent);
   var hasIEDeleteObjectStoreBug = isIEOrEdge;
   var hangsOnDeleteLargeKeyRange = isIEOrEdge;

   var dexieStackFrameFilter = function dexieStackFrameFilter(frame) {
     return !/(dexie\.js|dexie\.min\.js)/.test(frame);
   };

   var dbNamesDB; // Global database for backing Dexie.getDatabaseNames() on browser without indexedDB.webkitGetDatabaseNames()
   // Init debug

   setDebug(debug, dexieStackFrameFilter);

   function Dexie(dbName, options) {
     /// <param name="options" type="Object" optional="true">Specify only if you wich to control which addons that should run on this instance</param>
     var deps = Dexie.dependencies;
     var opts = extend({
       // Default Options
       addons: Dexie.addons,
       autoOpen: true,
       indexedDB: deps.indexedDB,
       IDBKeyRange: deps.IDBKeyRange // Backend IDBKeyRange api. Default to browser env.

     }, options);
     var addons = opts.addons,
         autoOpen = opts.autoOpen,
         indexedDB = opts.indexedDB,
         IDBKeyRange = opts.IDBKeyRange;
     var globalSchema = this._dbSchema = {};
     var versions = [];
     var dbStoreNames = [];
     var allTables = {}; ///<var type="IDBDatabase" />

     var idbdb = null; // Instance of IDBDatabase

     var dbOpenError = null;
     var isBeingOpened = false;
     var onReadyBeingFired = null;
     var openComplete = false;
     var READONLY = "readonly",
         READWRITE = "readwrite";
     var db = this;
     var dbReadyResolve,
         dbReadyPromise = new Promise(function (resolve) {
       dbReadyResolve = resolve;
     }),
         cancelOpen,
         openCanceller = new Promise(function (_, reject) {
       cancelOpen = reject;
     });
     var autoSchema = true;
     var hasNativeGetDatabaseNames = !!getNativeGetDatabaseNamesFn(indexedDB),
         hasGetAll;

     function init() {
       // Default subscribers to "versionchange" and "blocked".
       // Can be overridden by custom handlers. If custom handlers return false, these default
       // behaviours will be prevented.
       db.on("versionchange", function (ev) {
         // Default behavior for versionchange event is to close database connection.
         // Caller can override this behavior by doing db.on("versionchange", function(){ return false; });
         // Let's not block the other window from making it's delete() or open() call.
         // NOTE! This event is never fired in IE,Edge or Safari.
         if (ev.newVersion > 0) console.warn("Another connection wants to upgrade database '" + db.name + "'. Closing db now to resume the upgrade.");else console.warn("Another connection wants to delete database '" + db.name + "'. Closing db now to resume the delete request.");
         db.close(); // In many web applications, it would be recommended to force window.reload()
         // when this event occurs. To do that, subscribe to the versionchange event
         // and call window.location.reload(true) if ev.newVersion > 0 (not a deletion)
         // The reason for this is that your current web app obviously has old schema code that needs
         // to be updated. Another window got a newer version of the app and needs to upgrade DB but
         // your window is blocking it unless we close it here.
       });
       db.on("blocked", function (ev) {
         if (!ev.newVersion || ev.newVersion < ev.oldVersion) console.warn("Dexie.delete('" + db.name + "') was blocked");else console.warn("Upgrade '" + db.name + "' blocked by other connection holding version " + ev.oldVersion / 10);
       });
     } //
     //
     //
     // ------------------------- Versioning Framework---------------------------
     //
     //
     //


     this.version = function (versionNumber) {
       /// <param name="versionNumber" type="Number"></param>
       /// <returns type="Version"></returns>
       if (idbdb || isBeingOpened) throw new exceptions.Schema("Cannot add version when database is open");
       this.verno = Math.max(this.verno, versionNumber);
       var versionInstance = versions.filter(function (v) {
         return v._cfg.version === versionNumber;
       })[0];
       if (versionInstance) return versionInstance;
       versionInstance = new Version(versionNumber);
       versions.push(versionInstance);
       versions.sort(lowerVersionFirst); // Disable autoschema mode, as at least one version is specified.

       autoSchema = false;
       return versionInstance;
     };

     function Version(versionNumber) {
       this._cfg = {
         version: versionNumber,
         storesSource: null,
         dbschema: {},
         tables: {},
         contentUpgrade: null
       };
       this.stores({}); // Derive earlier schemas by default.
     }

     extend(Version.prototype, {
       stores: function stores(_stores) {
         /// <summary>
         ///   Defines the schema for a particular version
         /// </summary>
         /// <param name="stores" type="Object">
         /// Example: <br/>
         ///   {users: "id++,first,last,&amp;username,*email", <br/>
         ///   passwords: "id++,&amp;username"}<br/>
         /// <br/>
         /// Syntax: {Table: "[primaryKey][++],[&amp;][*]index1,[&amp;][*]index2,..."}<br/><br/>
         /// Special characters:<br/>
         ///  "&amp;"  means unique key, <br/>
         ///  "*"  means value is multiEntry, <br/>
         ///  "++" means auto-increment and only applicable for primary key <br/>
         /// </param>
         this._cfg.storesSource = this._cfg.storesSource ? extend(this._cfg.storesSource, _stores) : _stores; // Derive stores from earlier versions if they are not explicitely specified as null or a new syntax.

         var storesSpec = {};
         versions.forEach(function (version) {
           extend(storesSpec, version._cfg.storesSource);
         });
         var dbschema = this._cfg.dbschema = {};

         this._parseStoresSpec(storesSpec, dbschema); // Update the latest schema to this version
         // Update API


         globalSchema = db._dbSchema = dbschema;
         removeTablesApi([allTables, db, Transaction.prototype]); // Keep Transaction.prototype even though it should be depr.

         setApiOnPlace([allTables, db, Transaction.prototype, this._cfg.tables], keys(dbschema), dbschema);
         dbStoreNames = keys(dbschema);
         return this;
       },
       upgrade: function upgrade(upgradeFunction) {
         this._cfg.contentUpgrade = upgradeFunction;
         return this;
       },
       _parseStoresSpec: function _parseStoresSpec(stores, outSchema) {
         keys(stores).forEach(function (tableName) {
           if (stores[tableName] !== null) {
             var instanceTemplate = {};
             var indexes = parseIndexSyntax(stores[tableName]);
             var primKey = indexes.shift();
             if (primKey.multi) throw new exceptions.Schema("Primary key cannot be multi-valued");
             if (primKey.keyPath) setByKeyPath(instanceTemplate, primKey.keyPath, primKey.auto ? 0 : primKey.keyPath);
             indexes.forEach(function (idx) {
               if (idx.auto) throw new exceptions.Schema("Only primary key can be marked as autoIncrement (++)");
               if (!idx.keyPath) throw new exceptions.Schema("Index must have a name and cannot be an empty string");
               setByKeyPath(instanceTemplate, idx.keyPath, idx.compound ? idx.keyPath.map(function () {
                 return "";
               }) : "");
             });
             outSchema[tableName] = new TableSchema(tableName, primKey, indexes, instanceTemplate);
           }
         });
       }
     });

     function runUpgraders(oldVersion, idbtrans, reject) {
       var trans = db._createTransaction(READWRITE, dbStoreNames, globalSchema);

       trans.create(idbtrans);

       trans._completion["catch"](reject);

       var rejectTransaction = trans._reject.bind(trans);

       newScope(function () {
         PSD.trans = trans;

         if (oldVersion === 0) {
           // Create tables:
           keys(globalSchema).forEach(function (tableName) {
             createTable(idbtrans, tableName, globalSchema[tableName].primKey, globalSchema[tableName].indexes);
           });
           Promise.follow(function () {
             return db.on.populate.fire(trans);
           })["catch"](rejectTransaction);
         } else updateTablesAndIndexes(oldVersion, trans, idbtrans)["catch"](rejectTransaction);
       });
     }

     function updateTablesAndIndexes(oldVersion, trans, idbtrans) {
       // Upgrade version to version, step-by-step from oldest to newest version.
       // Each transaction object will contain the table set that was current in that version (but also not-yet-deleted tables from its previous version)
       var queue = [];
       var oldVersionStruct = versions.filter(function (version) {
         return version._cfg.version === oldVersion;
       })[0];
       if (!oldVersionStruct) throw new exceptions.Upgrade("Dexie specification of currently installed DB version is missing");
       globalSchema = db._dbSchema = oldVersionStruct._cfg.dbschema;
       var anyContentUpgraderHasRun = false;
       var versToRun = versions.filter(function (v) {
         return v._cfg.version > oldVersion;
       });
       versToRun.forEach(function (version) {
         /// <param name="version" type="Version"></param>
         queue.push(function () {
           var oldSchema = globalSchema;
           var newSchema = version._cfg.dbschema;
           adjustToExistingIndexNames(oldSchema, idbtrans);
           adjustToExistingIndexNames(newSchema, idbtrans);
           globalSchema = db._dbSchema = newSchema;
           var diff = getSchemaDiff(oldSchema, newSchema); // Add tables

           diff.add.forEach(function (tuple) {
             createTable(idbtrans, tuple[0], tuple[1].primKey, tuple[1].indexes);
           }); // Change tables

           diff.change.forEach(function (change) {
             if (change.recreate) {
               throw new exceptions.Upgrade("Not yet support for changing primary key");
             } else {
               var store = idbtrans.objectStore(change.name); // Add indexes

               change.add.forEach(function (idx) {
                 addIndex(store, idx);
               }); // Update indexes

               change.change.forEach(function (idx) {
                 store.deleteIndex(idx.name);
                 addIndex(store, idx);
               }); // Delete indexes

               change.del.forEach(function (idxName) {
                 store.deleteIndex(idxName);
               });
             }
           });

           if (version._cfg.contentUpgrade) {
             anyContentUpgraderHasRun = true;
             return Promise.follow(function () {
               version._cfg.contentUpgrade(trans);
             });
           }
         });
         queue.push(function (idbtrans) {
           if (!anyContentUpgraderHasRun || !hasIEDeleteObjectStoreBug) {
             var newSchema = version._cfg.dbschema; // Delete old tables

             deleteRemovedTables(newSchema, idbtrans);
           }
         });
       }); // Now, create a queue execution engine

       function runQueue() {
         return queue.length ? Promise.resolve(queue.shift()(trans.idbtrans)).then(runQueue) : Promise.resolve();
       }

       return runQueue().then(function () {
         createMissingTables(globalSchema, idbtrans); // At last, make sure to create any missing tables. (Needed by addons that add stores to DB without specifying version)
       });
     }

     function getSchemaDiff(oldSchema, newSchema) {
       var diff = {
         del: [],
         add: [],
         change: [] // Array of {name: tableName, recreate: newDefinition, del: delIndexNames, add: newIndexDefs, change: changedIndexDefs}

       };

       for (var table in oldSchema) {
         if (!newSchema[table]) diff.del.push(table);
       }

       for (table in newSchema) {
         var oldDef = oldSchema[table],
             newDef = newSchema[table];

         if (!oldDef) {
           diff.add.push([table, newDef]);
         } else {
           var change = {
             name: table,
             def: newDef,
             recreate: false,
             del: [],
             add: [],
             change: []
           };

           if (oldDef.primKey.src !== newDef.primKey.src) {
             // Primary key has changed. Remove and re-add table.
             change.recreate = true;
             diff.change.push(change);
           } else {
             // Same primary key. Just find out what differs:
             var oldIndexes = oldDef.idxByName;
             var newIndexes = newDef.idxByName;

             for (var idxName in oldIndexes) {
               if (!newIndexes[idxName]) change.del.push(idxName);
             }

             for (idxName in newIndexes) {
               var oldIdx = oldIndexes[idxName],
                   newIdx = newIndexes[idxName];
               if (!oldIdx) change.add.push(newIdx);else if (oldIdx.src !== newIdx.src) change.change.push(newIdx);
             }

             if (change.del.length > 0 || change.add.length > 0 || change.change.length > 0) {
               diff.change.push(change);
             }
           }
         }
       }

       return diff;
     }

     function createTable(idbtrans, tableName, primKey, indexes) {
       /// <param name="idbtrans" type="IDBTransaction"></param>
       var store = idbtrans.db.createObjectStore(tableName, primKey.keyPath ? {
         keyPath: primKey.keyPath,
         autoIncrement: primKey.auto
       } : {
         autoIncrement: primKey.auto
       });
       indexes.forEach(function (idx) {
         addIndex(store, idx);
       });
       return store;
     }

     function createMissingTables(newSchema, idbtrans) {
       keys(newSchema).forEach(function (tableName) {
         if (!idbtrans.db.objectStoreNames.contains(tableName)) {
           createTable(idbtrans, tableName, newSchema[tableName].primKey, newSchema[tableName].indexes);
         }
       });
     }

     function deleteRemovedTables(newSchema, idbtrans) {
       for (var i = 0; i < idbtrans.db.objectStoreNames.length; ++i) {
         var storeName = idbtrans.db.objectStoreNames[i];

         if (newSchema[storeName] == null) {
           idbtrans.db.deleteObjectStore(storeName);
         }
       }
     }

     function addIndex(store, idx) {
       store.createIndex(idx.name, idx.keyPath, {
         unique: idx.unique,
         multiEntry: idx.multi
       });
     } //
     //
     //      Dexie Protected API
     //
     //


     this._allTables = allTables;

     this._createTransaction = function (mode, storeNames, dbschema, parentTransaction) {
       return new Transaction(mode, storeNames, dbschema, parentTransaction);
     };
     /* Generate a temporary transaction when db operations are done outside a transaction scope.
     */


     function tempTransaction(mode, storeNames, fn) {
       if (!openComplete && !PSD.letThrough) {
         if (!isBeingOpened) {
           if (!autoOpen) return rejection(new exceptions.DatabaseClosed());
           db.open()["catch"](nop); // Open in background. If if fails, it will be catched by the final promise anyway.
         }

         return dbReadyPromise.then(function () {
           return tempTransaction(mode, storeNames, fn);
         });
       } else {
         var trans = db._createTransaction(mode, storeNames, globalSchema);

         try {
           trans.create();
         } catch (ex) {
           return rejection(ex);
         }

         return trans._promise(mode, function (resolve, reject) {
           return newScope(function () {
             PSD.trans = trans;
             return fn(resolve, reject, trans);
           });
         }).then(function (result) {
           // Instead of resolving value directly, wait with resolving it until transaction has completed.
           // Otherwise the data would not be in the DB if requesting it in the then() operation.
           // Specifically, to ensure that the following expression will work:
           //
           //   db.friends.put({name: "Arne"}).then(function () {
           //       db.friends.where("name").equals("Arne").count(function(count) {
           //           assert (count === 1);
           //       });
           //   });
           //
           return trans._completion.then(function () {
             return result;
           });
         });
         /*.catch(err => { // Don't do this as of now. If would affect bulk- and modify methods in a way that could be more intuitive. But wait! Maybe change in next major.
         trans._reject(err);
         return rejection(err);
         });*/
       }
     }

     this._whenReady = function (fn) {
       return openComplete || PSD.letThrough ? fn() : new Promise(function (resolve, reject) {
         if (!isBeingOpened) {
           if (!autoOpen) {
             reject(new exceptions.DatabaseClosed());
             return;
           }

           db.open()["catch"](nop); // Open in background. If if fails, it will be catched by the final promise anyway.
         }

         dbReadyPromise.then(resolve, reject);
       }).then(fn);
     }; //
     //
     //
     //
     //      Dexie API
     //
     //
     //


     this.verno = 0;

     this.open = function () {
       if (isBeingOpened || idbdb) return dbReadyPromise.then(function () {
         return dbOpenError ? rejection(dbOpenError) : db;
       });
       debug && (openCanceller._stackHolder = getErrorWithStack()); // Let stacks point to when open() was called rather than where new Dexie() was called.

       isBeingOpened = true;
       dbOpenError = null;
       openComplete = false; // Function pointers to call when the core opening process completes.

       var resolveDbReady = dbReadyResolve,
           // upgradeTransaction to abort on failure.
       upgradeTransaction = null;
       return Promise.race([openCanceller, new Promise(function (resolve, reject) {
         // Multiply db.verno with 10 will be needed to workaround upgrading bug in IE:
         // IE fails when deleting objectStore after reading from it.
         // A future version of Dexie.js will stopover an intermediate version to workaround this.
         // At that point, we want to be backward compatible. Could have been multiplied with 2, but by using 10, it is easier to map the number to the real version number.
         // If no API, throw!
         if (!indexedDB) throw new exceptions.MissingAPI("indexedDB API not found. If using IE10+, make sure to run your code on a server URL " + "(not locally). If using old Safari versions, make sure to include indexedDB polyfill.");
         var req = autoSchema ? indexedDB.open(dbName) : indexedDB.open(dbName, Math.round(db.verno * 10));
         if (!req) throw new exceptions.MissingAPI("IndexedDB API not available"); // May happen in Safari private mode, see https://github.com/dfahlander/Dexie.js/issues/134

         req.onerror = eventRejectHandler(reject);
         req.onblocked = wrap(fireOnBlocked);
         req.onupgradeneeded = wrap(function (e) {
           upgradeTransaction = req.transaction;

           if (autoSchema && !db._allowEmptyDB) {
             // Caller did not specify a version or schema. Doing that is only acceptable for opening alread existing databases.
             // If onupgradeneeded is called it means database did not exist. Reject the open() promise and make sure that we
             // do not create a new database by accident here.
             req.onerror = preventDefault; // Prohibit onabort error from firing before we're done!

             upgradeTransaction.abort(); // Abort transaction (would hope that this would make DB disappear but it doesnt.)
             // Close database and delete it.

             req.result.close();
             var delreq = indexedDB.deleteDatabase(dbName); // The upgrade transaction is atomic, and javascript is single threaded - meaning that there is no risk that we delete someone elses database here!

             delreq.onsuccess = delreq.onerror = wrap(function () {
               reject(new exceptions.NoSuchDatabase("Database " + dbName + " doesnt exist"));
             });
           } else {
             upgradeTransaction.onerror = eventRejectHandler(reject);
             var oldVer = e.oldVersion > Math.pow(2, 62) ? 0 : e.oldVersion; // Safari 8 fix.

             runUpgraders(oldVer / 10, upgradeTransaction, reject, req);
           }
         }, reject);
         req.onsuccess = wrap(function () {
           // Core opening procedure complete. Now let's just record some stuff.
           upgradeTransaction = null;
           idbdb = req.result;
           connections.push(db); // Used for emulating versionchange event on IE/Edge/Safari.

           if (autoSchema) readGlobalSchema();else if (idbdb.objectStoreNames.length > 0) {
             try {
               adjustToExistingIndexNames(globalSchema, idbdb.transaction(safariMultiStoreFix(idbdb.objectStoreNames), READONLY));
             } catch (e) {// Safari may bail out if > 1 store names. However, this shouldnt be a showstopper. Issue #120.
             }
           }
           idbdb.onversionchange = wrap(function (ev) {
             db._vcFired = true; // detect implementations that not support versionchange (IE/Edge/Safari)

             db.on("versionchange").fire(ev);
           });

           if (!hasNativeGetDatabaseNames && dbName !== '__dbnames') {
             dbNamesDB.dbnames.put({
               name: dbName
             })["catch"](nop);
           }

           resolve();
         }, reject);
       })]).then(function () {
         // Before finally resolving the dbReadyPromise and this promise,
         // call and await all on('ready') subscribers:
         // Dexie.vip() makes subscribers able to use the database while being opened.
         // This is a must since these subscribers take part of the opening procedure.
         onReadyBeingFired = [];
         return Promise.resolve(Dexie.vip(db.on.ready.fire)).then(function fireRemainders() {
           if (onReadyBeingFired.length > 0) {
             // In case additional subscribers to db.on('ready') were added during the time db.on.ready.fire was executed.
             var remainders = onReadyBeingFired.reduce(promisableChain, nop);
             onReadyBeingFired = [];
             return Promise.resolve(Dexie.vip(remainders)).then(fireRemainders);
           }
         });
       })["finally"](function () {
         onReadyBeingFired = null;
       }).then(function () {
         // Resolve the db.open() with the db instance.
         isBeingOpened = false;
         return db;
       })["catch"](function (err) {
         try {
           // Did we fail within onupgradeneeded? Make sure to abort the upgrade transaction so it doesnt commit.
           upgradeTransaction && upgradeTransaction.abort();
         } catch (e) {}

         isBeingOpened = false; // Set before calling db.close() so that it doesnt reject openCanceller again (leads to unhandled rejection event).

         db.close(); // Closes and resets idbdb, removes connections, resets dbReadyPromise and openCanceller so that a later db.open() is fresh.
         // A call to db.close() may have made on-ready subscribers fail. Use dbOpenError if set, since err could be a follow-up error on that.

         dbOpenError = err; // Record the error. It will be used to reject further promises of db operations.

         return rejection(dbOpenError);
       })["finally"](function () {
         openComplete = true;
         resolveDbReady(); // dbReadyPromise is resolved no matter if open() rejects or resolved. It's just to wake up waiters.
       });
     };

     this.close = function () {
       var idx = connections.indexOf(db);
       if (idx >= 0) connections.splice(idx, 1);

       if (idbdb) {
         try {
           idbdb.close();
         } catch (e) {}

         idbdb = null;
       }

       autoOpen = false;
       dbOpenError = new exceptions.DatabaseClosed();
       if (isBeingOpened) cancelOpen(dbOpenError); // Reset dbReadyPromise promise:

       dbReadyPromise = new Promise(function (resolve) {
         dbReadyResolve = resolve;
       });
       openCanceller = new Promise(function (_, reject) {
         cancelOpen = reject;
       });
     };

     this["delete"] = function () {
       var hasArguments = arguments.length > 0;
       return new Promise(function (resolve, reject) {
         if (hasArguments) throw new exceptions.InvalidArgument("Arguments not allowed in db.delete()");

         if (isBeingOpened) {
           dbReadyPromise.then(doDelete);
         } else {
           doDelete();
         }

         function doDelete() {
           db.close();
           var req = indexedDB.deleteDatabase(dbName);
           req.onsuccess = wrap(function () {
             if (!hasNativeGetDatabaseNames) {
               dbNamesDB.dbnames["delete"](dbName)["catch"](nop);
             }

             resolve();
           });
           req.onerror = eventRejectHandler(reject);
           req.onblocked = fireOnBlocked;
         }
       });
     };

     this.backendDB = function () {
       return idbdb;
     };

     this.isOpen = function () {
       return idbdb !== null;
     };

     this.hasBeenClosed = function () {
       return dbOpenError && dbOpenError instanceof exceptions.DatabaseClosed;
     };

     this.hasFailed = function () {
       return dbOpenError !== null;
     };

     this.dynamicallyOpened = function () {
       return autoSchema;
     }; //
     // Properties
     //


     this.name = dbName; // db.tables - an array of all Table instances.

     props(this, {
       tables: {
         get: function get() {
           /// <returns type="Array" elementType="Table" />
           return keys(allTables).map(function (name) {
             return allTables[name];
           });
         }
       }
     }); //
     // Events
     //

     this.on = Events(this, "populate", "blocked", "versionchange", {
       ready: [promisableChain, nop]
     });
     this.on.ready.subscribe = override(this.on.ready.subscribe, function (subscribe) {
       return function (subscriber, bSticky) {
         Dexie.vip(function () {
           if (openComplete) {
             // Database already open. Call subscriber asap.
             if (!dbOpenError) Promise.resolve().then(subscriber); // bSticky: Also subscribe to future open sucesses (after close / reopen)

             if (bSticky) subscribe(subscriber);
           } else if (onReadyBeingFired) {
             // db.on('ready') subscribers are currently being executed and have not yet resolved or rejected
             onReadyBeingFired.push(subscriber);
             if (bSticky) subscribe(subscriber);
           } else {
             // Database not yet open. Subscribe to it.
             subscribe(subscriber); // If bSticky is falsy, make sure to unsubscribe subscriber when fired once.

             if (!bSticky) subscribe(function unsubscribe() {
               db.on.ready.unsubscribe(subscriber);
               db.on.ready.unsubscribe(unsubscribe);
             });
           }
         });
       };
     });

     this.transaction = function () {
       /// <summary>
       ///
       /// </summary>
       /// <param name="mode" type="String">"r" for readonly, or "rw" for readwrite</param>
       /// <param name="tableInstances">Table instance, Array of Table instances, String or String Array of object stores to include in the transaction</param>
       /// <param name="scopeFunc" type="Function">Function to execute with transaction</param>
       var args = extractTransactionArgs.apply(this, arguments);
       return this._transaction.apply(this, args);
     };

     function extractTransactionArgs(mode, _tableArgs_, scopeFunc) {
       // Let table arguments be all arguments between mode and last argument.
       var i = arguments.length;
       if (i < 2) throw new exceptions.InvalidArgument("Too few arguments"); // Prevent optimzation killer (https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#32-leaking-arguments)
       // and clone arguments except the first one into local var 'args'.

       var args = new Array(i - 1);

       while (--i) {
         args[i - 1] = arguments[i];
       } // Let scopeFunc be the last argument and pop it so that args now only contain the table arguments.


       scopeFunc = args.pop();
       var tables = flatten(args); // Support using array as middle argument, or a mix of arrays and non-arrays.

       return [mode, tables, scopeFunc];
     }

     this._transaction = function (mode, tables, scopeFunc) {
       var parentTransaction = PSD.trans; // Check if parent transactions is bound to this db instance, and if caller wants to reuse it

       if (!parentTransaction || parentTransaction.db !== db || mode.indexOf('!') !== -1) parentTransaction = null;
       var onlyIfCompatible = mode.indexOf('?') !== -1;
       mode = mode.replace('!', '').replace('?', ''); // Ok. Will change arguments[0] as well but we wont touch arguments henceforth.

       try {
         //
         // Get storeNames from arguments. Either through given table instances, or through given table names.
         //
         var storeNames = tables.map(function (table) {
           var storeName = table instanceof Table ? table.name : table;
           if (typeof storeName !== 'string') throw new TypeError("Invalid table argument to Dexie.transaction(). Only Table or String are allowed");
           return storeName;
         }); //
         // Resolve mode. Allow shortcuts "r" and "rw".
         //

         if (mode == "r" || mode == READONLY) mode = READONLY;else if (mode == "rw" || mode == READWRITE) mode = READWRITE;else throw new exceptions.InvalidArgument("Invalid transaction mode: " + mode);

         if (parentTransaction) {
           // Basic checks
           if (parentTransaction.mode === READONLY && mode === READWRITE) {
             if (onlyIfCompatible) {
               // Spawn new transaction instead.
               parentTransaction = null;
             } else throw new exceptions.SubTransaction("Cannot enter a sub-transaction with READWRITE mode when parent transaction is READONLY");
           }

           if (parentTransaction) {
             storeNames.forEach(function (storeName) {
               if (parentTransaction && parentTransaction.storeNames.indexOf(storeName) === -1) {
                 if (onlyIfCompatible) {
                   // Spawn new transaction instead.
                   parentTransaction = null;
                 } else throw new exceptions.SubTransaction("Table " + storeName + " not included in parent transaction.");
               }
             });
           }

           if (onlyIfCompatible && parentTransaction && !parentTransaction.active) {
             // '?' mode should not keep using an inactive transaction.
             parentTransaction = null;
           }
         }
       } catch (e) {
         return parentTransaction ? parentTransaction._promise(null, function (_, reject) {
           reject(e);
         }) : rejection(e);
       } // If this is a sub-transaction, lock the parent and then launch the sub-transaction.


       return parentTransaction ? parentTransaction._promise(mode, enterTransactionScope, "lock") : PSD.trans ? // no parent transaction despite PSD.trans exists. Make sure also
       // that the zone we create is not a sub-zone of current, because
       // Promise.follow() should not wait for it if so.
       usePSD(PSD.transless, function () {
         return db._whenReady(enterTransactionScope);
       }) : db._whenReady(enterTransactionScope);

       function enterTransactionScope() {
         return Promise.resolve().then(function () {
           // Keep a pointer to last non-transactional PSD to use if someone calls Dexie.ignoreTransaction().
           var transless = PSD.transless || PSD; // Our transaction.
           //return new Promise((resolve, reject) => {

           var trans = db._createTransaction(mode, storeNames, globalSchema, parentTransaction); // Let the transaction instance be part of a Promise-specific data (PSD) value.


           var zoneProps = {
             trans: trans,
             transless: transless
           };

           if (parentTransaction) {
             // Emulate transaction commit awareness for inner transaction (must 'commit' when the inner transaction has no more operations ongoing)
             trans.idbtrans = parentTransaction.idbtrans;
           } else {
             trans.create(); // Create the backend transaction so that complete() or error() will trigger even if no operation is made upon it.
           } // Support for native async await.


           if (scopeFunc.constructor === AsyncFunction) {
             incrementExpectedAwaits();
           }

           var returnValue;
           var promiseFollowed = Promise.follow(function () {
             // Finally, call the scope function with our table and transaction arguments.
             returnValue = scopeFunc.call(trans, trans);

             if (returnValue) {
               if (returnValue.constructor === NativePromise) {
                 var decrementor = decrementExpectedAwaits.bind(null, null);
                 returnValue.then(decrementor, decrementor);
               } else if (typeof returnValue.next === 'function' && typeof returnValue["throw"] === 'function') {
                 // scopeFunc returned an iterator with throw-support. Handle yield as await.
                 returnValue = awaitIterator(returnValue);
               }
             }
           }, zoneProps);
           return (returnValue && typeof returnValue.then === 'function' ? // Promise returned. User uses promise-style transactions.
           Promise.resolve(returnValue).then(function (x) {
             return trans.active ? x // Transaction still active. Continue.
             : rejection(new exceptions.PrematureCommit("Transaction committed too early. See http://bit.ly/2kdckMn"));
           }) // No promise returned. Wait for all outstanding promises before continuing.
           : promiseFollowed.then(function () {
             return returnValue;
           })).then(function (x) {
             // sub transactions don't react to idbtrans.oncomplete. We must trigger a completion:
             if (parentTransaction) trans._resolve(); // wait for trans._completion
             // (if root transaction, this means 'complete' event. If sub-transaction, we've just fired it ourselves)

             return trans._completion.then(function () {
               return x;
             });
           })["catch"](function (e) {
             trans._reject(e); // Yes, above then-handler were maybe not called because of an unhandled rejection in scopeFunc!


             return rejection(e);
           });
         });
       }
     };

     this.table = function (tableName) {
       /// <returns type="Table"></returns>
       if (!hasOwn(allTables, tableName)) {
         throw new exceptions.InvalidTable("Table " + tableName + " does not exist");
       }

       return allTables[tableName];
     }; //
     //
     //
     // Table Class
     //
     //
     //


     function Table(name, tableSchema, optionalTrans) {
       /// <param name="name" type="String"></param>
       this.name = name;
       this.schema = tableSchema;
       this._tx = optionalTrans;
       this.hook = allTables[name] ? allTables[name].hook : Events(null, {
         "creating": [hookCreatingChain, nop],
         "reading": [pureFunctionChain, mirror],
         "updating": [hookUpdatingChain, nop],
         "deleting": [hookDeletingChain, nop]
       });
     }

     function BulkErrorHandlerCatchAll(errorList, done, supportHooks) {
       return (supportHooks ? hookedEventRejectHandler : eventRejectHandler)(function (e) {
         errorList.push(e);
         done && done();
       });
     }

     function _bulkDelete(idbstore, trans, keysOrTuples, hasDeleteHook, deletingHook) {
       // If hasDeleteHook, keysOrTuples must be an array of tuples: [[key1, value2],[key2,value2],...],
       // else keysOrTuples must be just an array of keys: [key1, key2, ...].
       return new Promise(function (resolve, reject) {
         var len = keysOrTuples.length,
             lastItem = len - 1;
         if (len === 0) return resolve();

         if (!hasDeleteHook) {
           for (var i = 0; i < len; ++i) {
             var req = idbstore["delete"](keysOrTuples[i]);
             req.onerror = eventRejectHandler(reject);
             if (i === lastItem) req.onsuccess = wrap(function () {
               return resolve();
             });
           }
         } else {
           var hookCtx,
               errorHandler = hookedEventRejectHandler(reject),
               successHandler = hookedEventSuccessHandler(null);
           tryCatch(function () {
             for (var i = 0; i < len; ++i) {
               hookCtx = {
                 onsuccess: null,
                 onerror: null
               };
               var tuple = keysOrTuples[i];
               deletingHook.call(hookCtx, tuple[0], tuple[1], trans);
               var req = idbstore["delete"](tuple[0]);
               req._hookCtx = hookCtx;
               req.onerror = errorHandler;
               if (i === lastItem) req.onsuccess = hookedEventSuccessHandler(resolve);else req.onsuccess = successHandler;
             }
           }, function (err) {
             hookCtx.onerror && hookCtx.onerror(err);
             throw err;
           });
         }
       });
     }

     props(Table.prototype, {
       //
       // Table Protected Methods
       //
       _trans: function getTransaction(mode, fn, writeLocked) {
         var trans = this._tx || PSD.trans;
         return trans && trans.db === db ? trans === PSD.trans ? trans._promise(mode, fn, writeLocked) : newScope(function () {
           return trans._promise(mode, fn, writeLocked);
         }, {
           trans: trans,
           transless: PSD.transless || PSD
         }) : tempTransaction(mode, [this.name], fn);
       },
       _idbstore: function getIDBObjectStore(mode, fn, writeLocked) {
         var tableName = this.name;

         function supplyIdbStore(resolve, reject, trans) {
           if (trans.storeNames.indexOf(tableName) === -1) throw new exceptions.NotFound("Table" + tableName + " not part of transaction");
           return fn(resolve, reject, trans.idbtrans.objectStore(tableName), trans);
         }

         return this._trans(mode, supplyIdbStore, writeLocked);
       },
       //
       // Table Public Methods
       //
       get: function get(keyOrCrit, cb) {
         if (keyOrCrit && keyOrCrit.constructor === Object) return this.where(keyOrCrit).first(cb);
         var self = this;
         return this._idbstore(READONLY, function (resolve, reject, idbstore) {
           var req = idbstore.get(keyOrCrit);
           req.onerror = eventRejectHandler(reject);
           req.onsuccess = wrap(function () {
             resolve(self.hook.reading.fire(req.result));
           }, reject);
         }).then(cb);
       },
       where: function where(indexOrCrit) {
         if (typeof indexOrCrit === 'string') return new WhereClause(this, indexOrCrit);
         if (isArray(indexOrCrit)) return new WhereClause(this, "[" + indexOrCrit.join('+') + "]"); // indexOrCrit is an object map of {[keyPath]:value}

         var keyPaths = keys(indexOrCrit);
         if (keyPaths.length === 1) // Only one critera. This was the easy case:
           return this.where(keyPaths[0]).equals(indexOrCrit[keyPaths[0]]); // Multiple criterias.
         // Let's try finding a compound index that matches all keyPaths in
         // arbritary order:

         var compoundIndex = this.schema.indexes.concat(this.schema.primKey).filter(function (ix) {
           return ix.compound && keyPaths.every(function (keyPath) {
             return ix.keyPath.indexOf(keyPath) >= 0;
           }) && ix.keyPath.every(function (keyPath) {
             return keyPaths.indexOf(keyPath) >= 0;
           });
         })[0];
         if (compoundIndex && maxKey !== maxString) // Cool! We found such compound index
           // and this browser supports compound indexes (maxKey !== maxString)!
           return this.where(compoundIndex.name).equals(compoundIndex.keyPath.map(function (kp) {
             return indexOrCrit[kp];
           }));
         if (!compoundIndex) console.warn("The query " + JSON.stringify(indexOrCrit) + " on " + this.name + " would benefit of a " + ("compound index [" + keyPaths.join('+') + "]")); // Ok, now let's fallback to finding at least one matching index
         // and filter the rest.

         var idxByName = this.schema.idxByName;
         var simpleIndex = keyPaths.reduce(function (r, keyPath) {
           return [r[0] || idxByName[keyPath], r[0] || !idxByName[keyPath] ? combine(r[1], function (x) {
             return '' + getByKeyPath(x, keyPath) == '' + indexOrCrit[keyPath];
           }) : r[1]];
         }, [null, null]);
         var idx = simpleIndex[0];
         return idx ? this.where(idx.name).equals(indexOrCrit[idx.keyPath]).filter(simpleIndex[1]) : compoundIndex ? this.filter(simpleIndex[1]) : // Has compound but browser bad. Allow filter.
         this.where(keyPaths).equals(''); // No index at all. Fail lazily.
       },
       count: function count(cb) {
         return this.toCollection().count(cb);
       },
       offset: function offset(_offset) {
         return this.toCollection().offset(_offset);
       },
       limit: function limit(numRows) {
         return this.toCollection().limit(numRows);
       },
       reverse: function reverse() {
         return this.toCollection().reverse();
       },
       filter: function filter(filterFunction) {
         return this.toCollection().and(filterFunction);
       },
       each: function each(fn) {
         return this.toCollection().each(fn);
       },
       toArray: function toArray(cb) {
         return this.toCollection().toArray(cb);
       },
       orderBy: function orderBy(index) {
         return new Collection(new WhereClause(this, isArray(index) ? "[" + index.join('+') + "]" : index));
       },
       toCollection: function toCollection() {
         return new Collection(new WhereClause(this));
       },
       mapToClass: function mapToClass(constructor, structure) {
         /// <summary>
         ///     Map table to a javascript constructor function. Objects returned from the database will be instances of this class, making
         ///     it possible to the instanceOf operator as well as extending the class using constructor.prototype.method = function(){...}.
         /// </summary>
         /// <param name="constructor">Constructor function representing the class.</param>
         /// <param name="structure" optional="true">Helps IDE code completion by knowing the members that objects contain and not just the indexes. Also
         /// know what type each member has. Example: {name: String, emailAddresses: [String], password}</param>
         this.schema.mappedClass = constructor;
         var instanceTemplate = Object.create(constructor.prototype);

         if (structure) {
           // structure and instanceTemplate is for IDE code competion only while constructor.prototype is for actual inheritance.
           applyStructure(instanceTemplate, structure);
         }

         this.schema.instanceTemplate = instanceTemplate; // Now, subscribe to the when("reading") event to make all objects that come out from this table inherit from given class
         // no matter which method to use for reading (Table.get() or Table.where(...)... )

         var readHook = function readHook(obj) {
           if (!obj) return obj; // No valid object. (Value is null). Return as is.
           // Create a new object that derives from constructor:

           var res = Object.create(constructor.prototype); // Clone members:

           for (var m in obj) {
             if (hasOwn(obj, m)) try {
               res[m] = obj[m];
             } catch (_) {}
           }

           return res;
         };

         if (this.schema.readHook) {
           this.hook.reading.unsubscribe(this.schema.readHook);
         }

         this.schema.readHook = readHook;
         this.hook("reading", readHook);
         return constructor;
       },
       defineClass: function defineClass(structure) {
         /// <summary>
         ///     Define all members of the class that represents the table. This will help code completion of when objects are read from the database
         ///     as well as making it possible to extend the prototype of the returned constructor function.
         /// </summary>
         /// <param name="structure">Helps IDE code completion by knowing the members that objects contain and not just the indexes. Also
         /// know what type each member has. Example: {name: String, emailAddresses: [String], properties: {shoeSize: Number}}</param>
         return this.mapToClass(Dexie.defineClass(structure), structure);
       },
       bulkDelete: function bulkDelete(keys$$1) {
         if (this.hook.deleting.fire === nop) {
           return this._idbstore(READWRITE, function (resolve, reject, idbstore, trans) {
             resolve(_bulkDelete(idbstore, trans, keys$$1, false, nop));
           });
         } else {
           return this.where(':id').anyOf(keys$$1)["delete"]().then(function () {}); // Resolve with undefined.
         }
       },
       bulkPut: function bulkPut(objects, keys$$1) {
         var _this = this;

         return this._idbstore(READWRITE, function (resolve, reject, idbstore) {
           if (!idbstore.keyPath && !_this.schema.primKey.auto && !keys$$1) throw new exceptions.InvalidArgument("bulkPut() with non-inbound keys requires keys array in second argument");
           if (idbstore.keyPath && keys$$1) throw new exceptions.InvalidArgument("bulkPut(): keys argument invalid on tables with inbound keys");
           if (keys$$1 && keys$$1.length !== objects.length) throw new exceptions.InvalidArgument("Arguments objects and keys must have the same length");
           if (objects.length === 0) return resolve(); // Caller provided empty list.

           var done = function done(result) {
             if (errorList.length === 0) resolve(result);else reject(new BulkError(_this.name + ".bulkPut(): " + errorList.length + " of " + numObjs + " operations failed", errorList));
           };

           var req,
               errorList = [],
               errorHandler,
               numObjs = objects.length,
               table = _this;

           if (_this.hook.creating.fire === nop && _this.hook.updating.fire === nop) {
             //
             // Standard Bulk (no 'creating' or 'updating' hooks to care about)
             //
             errorHandler = BulkErrorHandlerCatchAll(errorList);

             for (var i = 0, l = objects.length; i < l; ++i) {
               req = keys$$1 ? idbstore.put(objects[i], keys$$1[i]) : idbstore.put(objects[i]);
               req.onerror = errorHandler;
             } // Only need to catch success or error on the last operation
             // according to the IDB spec.


             req.onerror = BulkErrorHandlerCatchAll(errorList, done);
             req.onsuccess = eventSuccessHandler(done);
           } else {
             var effectiveKeys = keys$$1 || idbstore.keyPath && objects.map(function (o) {
               return getByKeyPath(o, idbstore.keyPath);
             }); // Generate map of {[key]: object}

             var objectLookup = effectiveKeys && arrayToObject(effectiveKeys, function (key, i) {
               return key != null && [key, objects[i]];
             });
             var promise = !effectiveKeys ? // Auto-incremented key-less objects only without any keys argument.
             table.bulkAdd(objects) : // Keys provided. Either as inbound in provided objects, or as a keys argument.
             // Begin with updating those that exists in DB:
             table.where(':id').anyOf(effectiveKeys.filter(function (key) {
               return key != null;
             })).modify(function () {
               this.value = objectLookup[this.primKey];
               objectLookup[this.primKey] = null; // Mark as "don't add this"
             })["catch"](ModifyError, function (e) {
               errorList = e.failures; // No need to concat here. These are the first errors added.
             }).then(function () {
               // Now, let's examine which items didnt exist so we can add them:
               var objsToAdd = [],
                   keysToAdd = keys$$1 && []; // Iterate backwards. Why? Because if same key was used twice, just add the last one.

               for (var i = effectiveKeys.length - 1; i >= 0; --i) {
                 var key = effectiveKeys[i];

                 if (key == null || objectLookup[key]) {
                   objsToAdd.push(objects[i]);
                   keys$$1 && keysToAdd.push(key);
                   if (key != null) objectLookup[key] = null; // Mark as "dont add again"
                 }
               } // The items are in reverse order so reverse them before adding.
               // Could be important in order to get auto-incremented keys the way the caller
               // would expect. Could have used unshift instead of push()/reverse(),
               // but: http://jsperf.com/unshift-vs-reverse


               objsToAdd.reverse();
               keys$$1 && keysToAdd.reverse();
               return table.bulkAdd(objsToAdd, keysToAdd);
             }).then(function (lastAddedKey) {
               // Resolve with key of the last object in given arguments to bulkPut():
               var lastEffectiveKey = effectiveKeys[effectiveKeys.length - 1]; // Key was provided.

               return lastEffectiveKey != null ? lastEffectiveKey : lastAddedKey;
             });
             promise.then(done)["catch"](BulkError, function (e) {
               // Concat failure from ModifyError and reject using our 'done' method.
               errorList = errorList.concat(e.failures);
               done();
             })["catch"](reject);
           }
         }, "locked"); // If called from transaction scope, lock transaction til all steps are done.
       },
       bulkAdd: function bulkAdd(objects, keys$$1) {
         var self = this,
             creatingHook = this.hook.creating.fire;
         return this._idbstore(READWRITE, function (resolve, reject, idbstore, trans) {
           if (!idbstore.keyPath && !self.schema.primKey.auto && !keys$$1) throw new exceptions.InvalidArgument("bulkAdd() with non-inbound keys requires keys array in second argument");
           if (idbstore.keyPath && keys$$1) throw new exceptions.InvalidArgument("bulkAdd(): keys argument invalid on tables with inbound keys");
           if (keys$$1 && keys$$1.length !== objects.length) throw new exceptions.InvalidArgument("Arguments objects and keys must have the same length");
           if (objects.length === 0) return resolve(); // Caller provided empty list.

           function done(result) {
             if (errorList.length === 0) resolve(result);else reject(new BulkError(self.name + ".bulkAdd(): " + errorList.length + " of " + numObjs + " operations failed", errorList));
           }

           var req,
               errorList = [],
               errorHandler,
               successHandler,
               numObjs = objects.length;

           if (creatingHook !== nop) {
             //
             // There are subscribers to hook('creating')
             // Must behave as documented.
             //
             var keyPath = idbstore.keyPath,
                 hookCtx;
             errorHandler = BulkErrorHandlerCatchAll(errorList, null, true);
             successHandler = hookedEventSuccessHandler(null);
             tryCatch(function () {
               for (var i = 0, l = objects.length; i < l; ++i) {
                 hookCtx = {
                   onerror: null,
                   onsuccess: null
                 };
                 var key = keys$$1 && keys$$1[i];
                 var obj = objects[i],
                     effectiveKey = keys$$1 ? key : keyPath ? getByKeyPath(obj, keyPath) : undefined,
                     keyToUse = creatingHook.call(hookCtx, effectiveKey, obj, trans);

                 if (effectiveKey == null && keyToUse != null) {
                   if (keyPath) {
                     obj = deepClone(obj);
                     setByKeyPath(obj, keyPath, keyToUse);
                   } else {
                     key = keyToUse;
                   }
                 }

                 req = key != null ? idbstore.add(obj, key) : idbstore.add(obj);
                 req._hookCtx = hookCtx;

                 if (i < l - 1) {
                   req.onerror = errorHandler;
                   if (hookCtx.onsuccess) req.onsuccess = successHandler;
                 }
               }
             }, function (err) {
               hookCtx.onerror && hookCtx.onerror(err);
               throw err;
             });
             req.onerror = BulkErrorHandlerCatchAll(errorList, done, true);
             req.onsuccess = hookedEventSuccessHandler(done);
           } else {
             //
             // Standard Bulk (no 'creating' hook to care about)
             //
             errorHandler = BulkErrorHandlerCatchAll(errorList);

             for (var i = 0, l = objects.length; i < l; ++i) {
               req = keys$$1 ? idbstore.add(objects[i], keys$$1[i]) : idbstore.add(objects[i]);
               req.onerror = errorHandler;
             } // Only need to catch success or error on the last operation
             // according to the IDB spec.


             req.onerror = BulkErrorHandlerCatchAll(errorList, done);
             req.onsuccess = eventSuccessHandler(done);
           }
         });
       },
       add: function add(obj, key) {
         /// <summary>
         ///   Add an object to the database. In case an object with same primary key already exists, the object will not be added.
         /// </summary>
         /// <param name="obj" type="Object">A javascript object to insert</param>
         /// <param name="key" optional="true">Primary key</param>
         var creatingHook = this.hook.creating.fire;
         return this._idbstore(READWRITE, function (resolve, reject, idbstore, trans) {
           var hookCtx = {
             onsuccess: null,
             onerror: null
           };

           if (creatingHook !== nop) {
             var effectiveKey = key != null ? key : idbstore.keyPath ? getByKeyPath(obj, idbstore.keyPath) : undefined;
             var keyToUse = creatingHook.call(hookCtx, effectiveKey, obj, trans); // Allow subscribers to when("creating") to generate the key.

             if (effectiveKey == null && keyToUse != null) {
               if (idbstore.keyPath) setByKeyPath(obj, idbstore.keyPath, keyToUse);else key = keyToUse;
             }
           }

           try {
             var req = key != null ? idbstore.add(obj, key) : idbstore.add(obj);
             req._hookCtx = hookCtx;
             req.onerror = hookedEventRejectHandler(reject);
             req.onsuccess = hookedEventSuccessHandler(function (result) {
               // TODO: Remove these two lines in next major release (2.0?)
               // It's no good practice to have side effects on provided parameters
               var keyPath = idbstore.keyPath;
               if (keyPath) setByKeyPath(obj, keyPath, result);
               resolve(result);
             });
           } catch (e) {
             if (hookCtx.onerror) hookCtx.onerror(e);
             throw e;
           }
         });
       },
       put: function put(obj, key) {
         var _this = this; /// <summary>
         ///   Add an object to the database but in case an object with same primary key alread exists, the existing one will get updated.
         /// </summary>
         /// <param name="obj" type="Object">A javascript object to insert or update</param>
         /// <param name="key" optional="true">Primary key</param>


         var creatingHook = this.hook.creating.fire,
             updatingHook = this.hook.updating.fire;

         if (creatingHook !== nop || updatingHook !== nop) {
           //
           // People listens to when("creating") or when("updating") events!
           // We must know whether the put operation results in an CREATE or UPDATE.
           //
           var keyPath = this.schema.primKey.keyPath;
           var effectiveKey = key !== undefined ? key : keyPath && getByKeyPath(obj, keyPath);
           if (effectiveKey == null) return this.add(obj); // Since key is optional, make sure we get it from obj if not provided
           // Primary key exist. Lock transaction and try modifying existing. If nothing modified, call add().
           // clone obj before this async call. If caller modifies obj the line after put(), the IDB spec requires that it should not affect operation.

           obj = deepClone(obj);
           return this._trans(READWRITE, function () {
             return _this.where(":id").equals(effectiveKey).modify(function () {
               // Replace extisting value with our object
               // CRUD event firing handled in Collection.modify()
               this.value = obj;
             }).then(function (count) {
               return count === 0 ? _this.add(obj, key) : effectiveKey;
             });
           }, "locked"); // Lock needed because operation is splitted into modify() and add().
         } else {
           // Use the standard IDB put() method.
           return this._idbstore(READWRITE, function (resolve, reject, idbstore) {
             var req = key !== undefined ? idbstore.put(obj, key) : idbstore.put(obj);
             req.onerror = eventRejectHandler(reject);
             req.onsuccess = wrap(function (ev) {
               var keyPath = idbstore.keyPath;
               if (keyPath) setByKeyPath(obj, keyPath, ev.target.result);
               resolve(req.result);
             });
           });
         }
       },
       'delete': function _delete(key) {
         /// <param name="key">Primary key of the object to delete</param>
         if (this.hook.deleting.subscribers.length) {
           // People listens to when("deleting") event. Must implement delete using Collection.delete() that will
           // call the CRUD event. Only Collection.delete() will know whether an object was actually deleted.
           return this.where(":id").equals(key)["delete"]();
         } else {
           // No one listens. Use standard IDB delete() method.
           return this._idbstore(READWRITE, function (resolve, reject, idbstore) {
             var req = idbstore["delete"](key);
             req.onerror = eventRejectHandler(reject);
             req.onsuccess = wrap(function () {
               resolve(req.result);
             });
           });
         }
       },
       clear: function clear() {
         if (this.hook.deleting.subscribers.length) {
           // People listens to when("deleting") event. Must implement delete using Collection.delete() that will
           // call the CRUD event. Only Collection.delete() will knows which objects that are actually deleted.
           return this.toCollection()["delete"]();
         } else {
           return this._idbstore(READWRITE, function (resolve, reject, idbstore) {
             var req = idbstore.clear();
             req.onerror = eventRejectHandler(reject);
             req.onsuccess = wrap(function () {
               resolve(req.result);
             });
           });
         }
       },
       update: function update(keyOrObject, modifications) {
         if (babelHelpers["typeof"](modifications) !== 'object' || isArray(modifications)) throw new exceptions.InvalidArgument("Modifications must be an object.");

         if (babelHelpers["typeof"](keyOrObject) === 'object' && !isArray(keyOrObject)) {
           // object to modify. Also modify given object with the modifications:
           keys(modifications).forEach(function (keyPath) {
             setByKeyPath(keyOrObject, keyPath, modifications[keyPath]);
           });
           var key = getByKeyPath(keyOrObject, this.schema.primKey.keyPath);
           if (key === undefined) return rejection(new exceptions.InvalidArgument("Given object does not contain its primary key"));
           return this.where(":id").equals(key).modify(modifications);
         } else {
           // key to modify
           return this.where(":id").equals(keyOrObject).modify(modifications);
         }
       }
     }); //
     //
     //
     // Transaction Class
     //
     //
     //

     function Transaction(mode, storeNames, dbschema, parent) {
       var _this = this; /// <summary>
       ///    Transaction class. Represents a database transaction. All operations on db goes through a Transaction.
       /// </summary>
       /// <param name="mode" type="String">Any of "readwrite" or "readonly"</param>
       /// <param name="storeNames" type="Array">Array of table names to operate on</param>


       this.db = db;
       this.mode = mode;
       this.storeNames = storeNames;
       this.idbtrans = null;
       this.on = Events(this, "complete", "error", "abort");
       this.parent = parent || null;
       this.active = true;
       this._reculock = 0;
       this._blockedFuncs = [];
       this._resolve = null;
       this._reject = null;
       this._waitingFor = null;
       this._waitingQueue = null;
       this._spinCount = 0; // Just for debugging waitFor()

       this._completion = new Promise(function (resolve, reject) {
         _this._resolve = resolve;
         _this._reject = reject;
       });

       this._completion.then(function () {
         _this.active = false;

         _this.on.complete.fire();
       }, function (e) {
         var wasActive = _this.active;
         _this.active = false;

         _this.on.error.fire(e);

         _this.parent ? _this.parent._reject(e) : wasActive && _this.idbtrans && _this.idbtrans.abort();
         return rejection(e); // Indicate we actually DO NOT catch this error.
       });
     }

     props(Transaction.prototype, {
       //
       // Transaction Protected Methods (not required by API users, but needed internally and eventually by dexie extensions)
       //
       _lock: function _lock() {
         assert(!PSD.global); // Locking and unlocking reuires to be within a PSD scope.
         // Temporary set all requests into a pending queue if they are called before database is ready.

         ++this._reculock; // Recursive read/write lock pattern using PSD (Promise Specific Data) instead of TLS (Thread Local Storage)

         if (this._reculock === 1 && !PSD.global) PSD.lockOwnerFor = this;
         return this;
       },
       _unlock: function _unlock() {
         assert(!PSD.global); // Locking and unlocking reuires to be within a PSD scope.

         if (--this._reculock === 0) {
           if (!PSD.global) PSD.lockOwnerFor = null;

           while (this._blockedFuncs.length > 0 && !this._locked()) {
             var fnAndPSD = this._blockedFuncs.shift();

             try {
               usePSD(fnAndPSD[1], fnAndPSD[0]);
             } catch (e) {}
           }
         }

         return this;
       },
       _locked: function _locked() {
         // Checks if any write-lock is applied on this transaction.
         // To simplify the Dexie API for extension implementations, we support recursive locks.
         // This is accomplished by using "Promise Specific Data" (PSD).
         // PSD data is bound to a Promise and any child Promise emitted through then() or resolve( new Promise() ).
         // PSD is local to code executing on top of the call stacks of any of any code executed by Promise():
         //         * callback given to the Promise() constructor  (function (resolve, reject){...})
         //         * callbacks given to then()/catch()/finally() methods (function (value){...})
         // If creating a new independant Promise instance from within a Promise call stack, the new Promise will derive the PSD from the call stack of the parent Promise.
         // Derivation is done so that the inner PSD __proto__ points to the outer PSD.
         // PSD.lockOwnerFor will point to current transaction object if the currently executing PSD scope owns the lock.
         return this._reculock && PSD.lockOwnerFor !== this;
       },
       create: function create(idbtrans) {
         var _this = this;

         if (!this.mode) return this;
         assert(!this.idbtrans);

         if (!idbtrans && !idbdb) {
           switch (dbOpenError && dbOpenError.name) {
             case "DatabaseClosedError":
               // Errors where it is no difference whether it was caused by the user operation or an earlier call to db.open()
               throw new exceptions.DatabaseClosed(dbOpenError);

             case "MissingAPIError":
               // Errors where it is no difference whether it was caused by the user operation or an earlier call to db.open()
               throw new exceptions.MissingAPI(dbOpenError.message, dbOpenError);

             default:
               // Make it clear that the user operation was not what caused the error - the error had occurred earlier on db.open()!
               throw new exceptions.OpenFailed(dbOpenError);
           }
         }

         if (!this.active) throw new exceptions.TransactionInactive();
         assert(this._completion._state === null);
         idbtrans = this.idbtrans = idbtrans || idbdb.transaction(safariMultiStoreFix(this.storeNames), this.mode);
         idbtrans.onerror = wrap(function (ev) {
           preventDefault(ev); // Prohibit default bubbling to window.error

           _this._reject(idbtrans.error);
         });
         idbtrans.onabort = wrap(function (ev) {
           preventDefault(ev);
           _this.active && _this._reject(new exceptions.Abort(idbtrans.error));
           _this.active = false;

           _this.on("abort").fire(ev);
         });
         idbtrans.oncomplete = wrap(function () {
           _this.active = false;

           _this._resolve();
         });
         return this;
       },
       _promise: function _promise(mode, fn, bWriteLock) {
         var _this = this;

         if (mode === READWRITE && this.mode !== READWRITE) return rejection(new exceptions.ReadOnly("Transaction is readonly"));
         if (!this.active) return rejection(new exceptions.TransactionInactive());

         if (this._locked()) {
           return new Promise(function (resolve, reject) {
             _this._blockedFuncs.push([function () {
               _this._promise(mode, fn, bWriteLock).then(resolve, reject);
             }, PSD]);
           });
         } else if (bWriteLock) {
           return newScope(function () {
             var p = new Promise(function (resolve, reject) {
               _this._lock();

               var rv = fn(resolve, reject, _this);
               if (rv && rv.then) rv.then(resolve, reject);
             });
             p["finally"](function () {
               return _this._unlock();
             });
             p._lib = true;
             return p;
           });
         } else {
           var p = new Promise(function (resolve, reject) {
             var rv = fn(resolve, reject, _this);
             if (rv && rv.then) rv.then(resolve, reject);
           });
           p._lib = true;
           return p;
         }
       },
       _root: function _root() {
         return this.parent ? this.parent._root() : this;
       },
       waitFor: function waitFor(promise) {
         // Always operate on the root transaction (in case this is a sub stransaction)
         var root = this._root(); // For stability reasons, convert parameter to promise no matter what type is passed to waitFor().
         // (We must be able to call .then() on it.)


         promise = Promise.resolve(promise);

         if (root._waitingFor) {
           // Already called waitFor(). Wait for both to complete.
           root._waitingFor = root._waitingFor.then(function () {
             return promise;
           });
         } else {
           // We're not in waiting state. Start waiting state.
           root._waitingFor = promise;
           root._waitingQueue = []; // Start interacting with indexedDB until promise completes:

           var store = root.idbtrans.objectStore(root.storeNames[0]);

           (function spin() {
             ++root._spinCount; // For debugging only

             while (root._waitingQueue.length) {
               root._waitingQueue.shift()();
             }

             if (root._waitingFor) store.get(-Infinity).onsuccess = spin;
           })();
         }

         var currentWaitPromise = root._waitingFor;
         return new Promise(function (resolve, reject) {
           promise.then(function (res) {
             return root._waitingQueue.push(wrap(resolve.bind(null, res)));
           }, function (err) {
             return root._waitingQueue.push(wrap(reject.bind(null, err)));
           })["finally"](function () {
             if (root._waitingFor === currentWaitPromise) {
               // No one added a wait after us. Safe to stop the spinning.
               root._waitingFor = null;
             }
           });
         });
       },
       //
       // Transaction Public Properties and Methods
       //
       abort: function abort() {
         this.active && this._reject(new exceptions.Abort());
         this.active = false;
       },
       tables: {
         get: deprecated("Transaction.tables", function () {
           return allTables;
         })
       },
       table: function table(name) {
         var table = db.table(name); // Don't check that table is part of transaction. It must fail lazily!

         return new Table(name, table.schema, this);
       }
     }); //
     //
     //
     // WhereClause
     //
     //
     //

     function WhereClause(table, index, orCollection) {
       /// <param name="table" type="Table"></param>
       /// <param name="index" type="String" optional="true"></param>
       /// <param name="orCollection" type="Collection" optional="true"></param>
       this._ctx = {
         table: table,
         index: index === ":id" ? null : index,
         or: orCollection
       };
     }

     props(WhereClause.prototype, function () {
       // WhereClause private methods
       function fail(collectionOrWhereClause, err, T) {
         var collection = collectionOrWhereClause instanceof WhereClause ? new Collection(collectionOrWhereClause) : collectionOrWhereClause;
         collection._ctx.error = T ? new T(err) : new TypeError(err);
         return collection;
       }

       function emptyCollection(whereClause) {
         return new Collection(whereClause, function () {
           return IDBKeyRange.only("");
         }).limit(0);
       }

       function upperFactory(dir) {
         return dir === "next" ? function (s) {
           return s.toUpperCase();
         } : function (s) {
           return s.toLowerCase();
         };
       }

       function lowerFactory(dir) {
         return dir === "next" ? function (s) {
           return s.toLowerCase();
         } : function (s) {
           return s.toUpperCase();
         };
       }

       function nextCasing(key, lowerKey, upperNeedle, lowerNeedle, cmp, dir) {
         var length = Math.min(key.length, lowerNeedle.length);
         var llp = -1;

         for (var i = 0; i < length; ++i) {
           var lwrKeyChar = lowerKey[i];

           if (lwrKeyChar !== lowerNeedle[i]) {
             if (cmp(key[i], upperNeedle[i]) < 0) return key.substr(0, i) + upperNeedle[i] + upperNeedle.substr(i + 1);
             if (cmp(key[i], lowerNeedle[i]) < 0) return key.substr(0, i) + lowerNeedle[i] + upperNeedle.substr(i + 1);
             if (llp >= 0) return key.substr(0, llp) + lowerKey[llp] + upperNeedle.substr(llp + 1);
             return null;
           }

           if (cmp(key[i], lwrKeyChar) < 0) llp = i;
         }

         if (length < lowerNeedle.length && dir === "next") return key + upperNeedle.substr(key.length);
         if (length < key.length && dir === "prev") return key.substr(0, upperNeedle.length);
         return llp < 0 ? null : key.substr(0, llp) + lowerNeedle[llp] + upperNeedle.substr(llp + 1);
       }

       function addIgnoreCaseAlgorithm(whereClause, match, needles, suffix) {
         /// <param name="needles" type="Array" elementType="String"></param>
         var upper,
             lower,
             compare,
             upperNeedles,
             lowerNeedles,
             direction,
             nextKeySuffix,
             needlesLen = needles.length;

         if (!needles.every(function (s) {
           return typeof s === 'string';
         })) {
           return fail(whereClause, STRING_EXPECTED);
         }

         function initDirection(dir) {
           upper = upperFactory(dir);
           lower = lowerFactory(dir);
           compare = dir === "next" ? simpleCompare : simpleCompareReverse;
           var needleBounds = needles.map(function (needle) {
             return {
               lower: lower(needle),
               upper: upper(needle)
             };
           }).sort(function (a, b) {
             return compare(a.lower, b.lower);
           });
           upperNeedles = needleBounds.map(function (nb) {
             return nb.upper;
           });
           lowerNeedles = needleBounds.map(function (nb) {
             return nb.lower;
           });
           direction = dir;
           nextKeySuffix = dir === "next" ? "" : suffix;
         }

         initDirection("next");
         var c = new Collection(whereClause, function () {
           return IDBKeyRange.bound(upperNeedles[0], lowerNeedles[needlesLen - 1] + suffix);
         });

         c._ondirectionchange = function (direction) {
           // This event onlys occur before filter is called the first time.
           initDirection(direction);
         };

         var firstPossibleNeedle = 0;

         c._addAlgorithm(function (cursor, advance, resolve) {
           /// <param name="cursor" type="IDBCursor"></param>
           /// <param name="advance" type="Function"></param>
           /// <param name="resolve" type="Function"></param>
           var key = cursor.key;
           if (typeof key !== 'string') return false;
           var lowerKey = lower(key);

           if (match(lowerKey, lowerNeedles, firstPossibleNeedle)) {
             return true;
           } else {
             var lowestPossibleCasing = null;

             for (var i = firstPossibleNeedle; i < needlesLen; ++i) {
               var casing = nextCasing(key, lowerKey, upperNeedles[i], lowerNeedles[i], compare, direction);
               if (casing === null && lowestPossibleCasing === null) firstPossibleNeedle = i + 1;else if (lowestPossibleCasing === null || compare(lowestPossibleCasing, casing) > 0) {
                 lowestPossibleCasing = casing;
               }
             }

             if (lowestPossibleCasing !== null) {
               advance(function () {
                 cursor["continue"](lowestPossibleCasing + nextKeySuffix);
               });
             } else {
               advance(resolve);
             }

             return false;
           }
         });

         return c;
       } //
       // WhereClause public methods
       //


       return {
         between: function between(lower, upper, includeLower, includeUpper) {
           /// <summary>
           ///     Filter out records whose where-field lays between given lower and upper values. Applies to Strings, Numbers and Dates.
           /// </summary>
           /// <param name="lower"></param>
           /// <param name="upper"></param>
           /// <param name="includeLower" optional="true">Whether items that equals lower should be included. Default true.</param>
           /// <param name="includeUpper" optional="true">Whether items that equals upper should be included. Default false.</param>
           /// <returns type="Collection"></returns>
           includeLower = includeLower !== false; // Default to true

           includeUpper = includeUpper === true; // Default to false

           try {
             if (cmp(lower, upper) > 0 || cmp(lower, upper) === 0 && (includeLower || includeUpper) && !(includeLower && includeUpper)) return emptyCollection(this); // Workaround for idiotic W3C Specification that DataError must be thrown if lower > upper. The natural result would be to return an empty collection.

             return new Collection(this, function () {
               return IDBKeyRange.bound(lower, upper, !includeLower, !includeUpper);
             });
           } catch (e) {
             return fail(this, INVALID_KEY_ARGUMENT);
           }
         },
         equals: function equals(value) {
           return new Collection(this, function () {
             return IDBKeyRange.only(value);
           });
         },
         above: function above(value) {
           return new Collection(this, function () {
             return IDBKeyRange.lowerBound(value, true);
           });
         },
         aboveOrEqual: function aboveOrEqual(value) {
           return new Collection(this, function () {
             return IDBKeyRange.lowerBound(value);
           });
         },
         below: function below(value) {
           return new Collection(this, function () {
             return IDBKeyRange.upperBound(value, true);
           });
         },
         belowOrEqual: function belowOrEqual(value) {
           return new Collection(this, function () {
             return IDBKeyRange.upperBound(value);
           });
         },
         startsWith: function startsWith(str) {
           /// <param name="str" type="String"></param>
           if (typeof str !== 'string') return fail(this, STRING_EXPECTED);
           return this.between(str, str + maxString, true, true);
         },
         startsWithIgnoreCase: function startsWithIgnoreCase(str) {
           /// <param name="str" type="String"></param>
           if (str === "") return this.startsWith(str);
           return addIgnoreCaseAlgorithm(this, function (x, a) {
             return x.indexOf(a[0]) === 0;
           }, [str], maxString);
         },
         equalsIgnoreCase: function equalsIgnoreCase(str) {
           /// <param name="str" type="String"></param>
           return addIgnoreCaseAlgorithm(this, function (x, a) {
             return x === a[0];
           }, [str], "");
         },
         anyOfIgnoreCase: function anyOfIgnoreCase() {
           var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
           if (set.length === 0) return emptyCollection(this);
           return addIgnoreCaseAlgorithm(this, function (x, a) {
             return a.indexOf(x) !== -1;
           }, set, "");
         },
         startsWithAnyOfIgnoreCase: function startsWithAnyOfIgnoreCase() {
           var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
           if (set.length === 0) return emptyCollection(this);
           return addIgnoreCaseAlgorithm(this, function (x, a) {
             return a.some(function (n) {
               return x.indexOf(n) === 0;
             });
           }, set, maxString);
         },
         anyOf: function anyOf() {
           var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
           var compare = ascending;

           try {
             set.sort(compare);
           } catch (e) {
             return fail(this, INVALID_KEY_ARGUMENT);
           }

           if (set.length === 0) return emptyCollection(this);
           var c = new Collection(this, function () {
             return IDBKeyRange.bound(set[0], set[set.length - 1]);
           });

           c._ondirectionchange = function (direction) {
             compare = direction === "next" ? ascending : descending;
             set.sort(compare);
           };

           var i = 0;

           c._addAlgorithm(function (cursor, advance, resolve) {
             var key = cursor.key;

             while (compare(key, set[i]) > 0) {
               // The cursor has passed beyond this key. Check next.
               ++i;

               if (i === set.length) {
                 // There is no next. Stop searching.
                 advance(resolve);
                 return false;
               }
             }

             if (compare(key, set[i]) === 0) {
               // The current cursor value should be included and we should continue a single step in case next item has the same key or possibly our next key in set.
               return true;
             } else {
               // cursor.key not yet at set[i]. Forward cursor to the next key to hunt for.
               advance(function () {
                 cursor["continue"](set[i]);
               });
               return false;
             }
           });

           return c;
         },
         notEqual: function notEqual(value) {
           return this.inAnyRange([[minKey, value], [value, maxKey]], {
             includeLowers: false,
             includeUppers: false
           });
         },
         noneOf: function noneOf() {
           var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
           if (set.length === 0) return new Collection(this); // Return entire collection.

           try {
             set.sort(ascending);
           } catch (e) {
             return fail(this, INVALID_KEY_ARGUMENT);
           } // Transform ["a","b","c"] to a set of ranges for between/above/below: [[minKey,"a"], ["a","b"], ["b","c"], ["c",maxKey]]


           var ranges = set.reduce(function (res, val) {
             return res ? res.concat([[res[res.length - 1][1], val]]) : [[minKey, val]];
           }, null);
           ranges.push([set[set.length - 1], maxKey]);
           return this.inAnyRange(ranges, {
             includeLowers: false,
             includeUppers: false
           });
         },

         /** Filter out values withing given set of ranges.
         * Example, give children and elders a rebate of 50%:
         *
         *   db.friends.where('age').inAnyRange([[0,18],[65,Infinity]]).modify({Rebate: 1/2});
         *
         * @param {(string|number|Date|Array)[][]} ranges
         * @param {{includeLowers: boolean, includeUppers: boolean}} options
         */
         inAnyRange: function inAnyRange(ranges, options) {
           if (ranges.length === 0) return emptyCollection(this);

           if (!ranges.every(function (range) {
             return range[0] !== undefined && range[1] !== undefined && ascending(range[0], range[1]) <= 0;
           })) {
             return fail(this, "First argument to inAnyRange() must be an Array of two-value Arrays [lower,upper] where upper must not be lower than lower", exceptions.InvalidArgument);
           }

           var includeLowers = !options || options.includeLowers !== false; // Default to true

           var includeUppers = options && options.includeUppers === true; // Default to false

           function addRange(ranges, newRange) {
             for (var i = 0, l = ranges.length; i < l; ++i) {
               var range = ranges[i];

               if (cmp(newRange[0], range[1]) < 0 && cmp(newRange[1], range[0]) > 0) {
                 range[0] = min(range[0], newRange[0]);
                 range[1] = max(range[1], newRange[1]);
                 break;
               }
             }

             if (i === l) ranges.push(newRange);
             return ranges;
           }

           var sortDirection = ascending;

           function rangeSorter(a, b) {
             return sortDirection(a[0], b[0]);
           } // Join overlapping ranges


           var set;

           try {
             set = ranges.reduce(addRange, []);
             set.sort(rangeSorter);
           } catch (ex) {
             return fail(this, INVALID_KEY_ARGUMENT);
           }

           var i = 0;
           var keyIsBeyondCurrentEntry = includeUppers ? function (key) {
             return ascending(key, set[i][1]) > 0;
           } : function (key) {
             return ascending(key, set[i][1]) >= 0;
           };
           var keyIsBeforeCurrentEntry = includeLowers ? function (key) {
             return descending(key, set[i][0]) > 0;
           } : function (key) {
             return descending(key, set[i][0]) >= 0;
           };

           function keyWithinCurrentRange(key) {
             return !keyIsBeyondCurrentEntry(key) && !keyIsBeforeCurrentEntry(key);
           }

           var checkKey = keyIsBeyondCurrentEntry;
           var c = new Collection(this, function () {
             return IDBKeyRange.bound(set[0][0], set[set.length - 1][1], !includeLowers, !includeUppers);
           });

           c._ondirectionchange = function (direction) {
             if (direction === "next") {
               checkKey = keyIsBeyondCurrentEntry;
               sortDirection = ascending;
             } else {
               checkKey = keyIsBeforeCurrentEntry;
               sortDirection = descending;
             }

             set.sort(rangeSorter);
           };

           c._addAlgorithm(function (cursor, advance, resolve) {
             var key = cursor.key;

             while (checkKey(key)) {
               // The cursor has passed beyond this key. Check next.
               ++i;

               if (i === set.length) {
                 // There is no next. Stop searching.
                 advance(resolve);
                 return false;
               }
             }

             if (keyWithinCurrentRange(key)) {
               // The current cursor value should be included and we should continue a single step in case next item has the same key or possibly our next key in set.
               return true;
             } else if (cmp(key, set[i][1]) === 0 || cmp(key, set[i][0]) === 0) {
               // includeUpper or includeLower is false so keyWithinCurrentRange() returns false even though we are at range border.
               // Continue to next key but don't include this one.
               return false;
             } else {
               // cursor.key not yet at set[i]. Forward cursor to the next key to hunt for.
               advance(function () {
                 if (sortDirection === ascending) cursor["continue"](set[i][0]);else cursor["continue"](set[i][1]);
               });
               return false;
             }
           });

           return c;
         },
         startsWithAnyOf: function startsWithAnyOf() {
           var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);

           if (!set.every(function (s) {
             return typeof s === 'string';
           })) {
             return fail(this, "startsWithAnyOf() only works with strings");
           }

           if (set.length === 0) return emptyCollection(this);
           return this.inAnyRange(set.map(function (str) {
             return [str, str + maxString];
           }));
         }
       };
     }); //
     //
     //
     // Collection Class
     //
     //
     //

     function Collection(whereClause, keyRangeGenerator) {
       /// <summary>
       ///
       /// </summary>
       /// <param name="whereClause" type="WhereClause">Where clause instance</param>
       /// <param name="keyRangeGenerator" value="function(){ return IDBKeyRange.bound(0,1);}" optional="true"></param>
       var keyRange = null,
           error = null;
       if (keyRangeGenerator) try {
         keyRange = keyRangeGenerator();
       } catch (ex) {
         error = ex;
       }
       var whereCtx = whereClause._ctx,
           table = whereCtx.table;
       this._ctx = {
         table: table,
         index: whereCtx.index,
         isPrimKey: !whereCtx.index || table.schema.primKey.keyPath && whereCtx.index === table.schema.primKey.name,
         range: keyRange,
         keysOnly: false,
         dir: "next",
         unique: "",
         algorithm: null,
         filter: null,
         replayFilter: null,
         justLimit: true,
         isMatch: null,
         offset: 0,
         limit: Infinity,
         error: error,
         or: whereCtx.or,
         valueMapper: table.hook.reading.fire
       };
     }

     function isPlainKeyRange(ctx, ignoreLimitFilter) {
       return !(ctx.filter || ctx.algorithm || ctx.or) && (ignoreLimitFilter ? ctx.justLimit : !ctx.replayFilter);
     }

     props(Collection.prototype, function () {
       //
       // Collection Private Functions
       //
       function addFilter(ctx, fn) {
         ctx.filter = combine(ctx.filter, fn);
       }

       function addReplayFilter(ctx, factory, isLimitFilter) {
         var curr = ctx.replayFilter;
         ctx.replayFilter = curr ? function () {
           return combine(curr(), factory());
         } : factory;
         ctx.justLimit = isLimitFilter && !curr;
       }

       function addMatchFilter(ctx, fn) {
         ctx.isMatch = combine(ctx.isMatch, fn);
       }
       /** @param ctx {
        *      isPrimKey: boolean,
        *      table: Table,
        *      index: string
        * }
        * @param store IDBObjectStore
        **/


       function getIndexOrStore(ctx, store) {
         if (ctx.isPrimKey) return store;
         var indexSpec = ctx.table.schema.idxByName[ctx.index];
         if (!indexSpec) throw new exceptions.Schema("KeyPath " + ctx.index + " on object store " + store.name + " is not indexed");
         return store.index(indexSpec.name);
       }
       /** @param ctx {
        *      isPrimKey: boolean,
        *      table: Table,
        *      index: string,
        *      keysOnly: boolean,
        *      range?: IDBKeyRange,
        *      dir: "next" | "prev"
        * }
        */


       function openCursor(ctx, store) {
         var idxOrStore = getIndexOrStore(ctx, store);
         return ctx.keysOnly && 'openKeyCursor' in idxOrStore ? idxOrStore.openKeyCursor(ctx.range || null, ctx.dir + ctx.unique) : idxOrStore.openCursor(ctx.range || null, ctx.dir + ctx.unique);
       }

       function iter(ctx, fn, resolve, reject, idbstore) {
         var filter = ctx.replayFilter ? combine(ctx.filter, ctx.replayFilter()) : ctx.filter;

         if (!ctx.or) {
           iterate(openCursor(ctx, idbstore), combine(ctx.algorithm, filter), fn, resolve, reject, !ctx.keysOnly && ctx.valueMapper);
         } else (function () {
           var set = {};
           var resolved = 0;

           function resolveboth() {
             if (++resolved === 2) resolve(); // Seems like we just support or btwn max 2 expressions, but there are no limit because we do recursion.
           }

           function union(item, cursor, advance) {
             if (!filter || filter(cursor, advance, resolveboth, reject)) {
               var primaryKey = cursor.primaryKey;
               var key = '' + primaryKey;
               if (key === '[object ArrayBuffer]') key = '' + new Uint8Array(primaryKey);

               if (!hasOwn(set, key)) {
                 set[key] = true;
                 fn(item, cursor, advance);
               }
             }
           }

           ctx.or._iterate(union, resolveboth, reject, idbstore);

           iterate(openCursor(ctx, idbstore), ctx.algorithm, union, resolveboth, reject, !ctx.keysOnly && ctx.valueMapper);
         })();
       }

       return {
         //
         // Collection Protected Functions
         //
         _read: function _read(fn, cb) {
           var ctx = this._ctx;
           return ctx.error ? ctx.table._trans(null, rejection.bind(null, ctx.error)) : ctx.table._idbstore(READONLY, fn).then(cb);
         },
         _write: function _write(fn) {
           var ctx = this._ctx;
           return ctx.error ? ctx.table._trans(null, rejection.bind(null, ctx.error)) : ctx.table._idbstore(READWRITE, fn, "locked"); // When doing write operations on collections, always lock the operation so that upcoming operations gets queued.
         },
         _addAlgorithm: function _addAlgorithm(fn) {
           var ctx = this._ctx;
           ctx.algorithm = combine(ctx.algorithm, fn);
         },
         _iterate: function _iterate(fn, resolve, reject, idbstore) {
           return iter(this._ctx, fn, resolve, reject, idbstore);
         },
         clone: function clone(props$$1) {
           var rv = Object.create(this.constructor.prototype),
               ctx = Object.create(this._ctx);
           if (props$$1) extend(ctx, props$$1);
           rv._ctx = ctx;
           return rv;
         },
         raw: function raw() {
           this._ctx.valueMapper = null;
           return this;
         },
         //
         // Collection Public methods
         //
         each: function each(fn) {
           var ctx = this._ctx;
           return this._read(function (resolve, reject, idbstore) {
             iter(ctx, fn, resolve, reject, idbstore);
           });
         },
         count: function count(cb) {
           var ctx = this._ctx;

           if (isPlainKeyRange(ctx, true)) {
             // This is a plain key range. We can use the count() method if the index.
             return this._read(function (resolve, reject, idbstore) {
               var idx = getIndexOrStore(ctx, idbstore);
               var req = ctx.range ? idx.count(ctx.range) : idx.count();
               req.onerror = eventRejectHandler(reject);

               req.onsuccess = function (e) {
                 resolve(Math.min(e.target.result, ctx.limit));
               };
             }, cb);
           } else {
             // Algorithms, filters or expressions are applied. Need to count manually.
             var count = 0;
             return this._read(function (resolve, reject, idbstore) {
               iter(ctx, function () {
                 ++count;
                 return false;
               }, function () {
                 resolve(count);
               }, reject, idbstore);
             }, cb);
           }
         },
         sortBy: function sortBy(keyPath, cb) {
           /// <param name="keyPath" type="String"></param>
           var parts = keyPath.split('.').reverse(),
               lastPart = parts[0],
               lastIndex = parts.length - 1;

           function getval(obj, i) {
             if (i) return getval(obj[parts[i]], i - 1);
             return obj[lastPart];
           }

           var order = this._ctx.dir === "next" ? 1 : -1;

           function sorter(a, b) {
             var aVal = getval(a, lastIndex),
                 bVal = getval(b, lastIndex);
             return aVal < bVal ? -order : aVal > bVal ? order : 0;
           }

           return this.toArray(function (a) {
             return a.sort(sorter);
           }).then(cb);
         },
         toArray: function toArray(cb) {
           var ctx = this._ctx;
           return this._read(function (resolve, reject, idbstore) {
             if (hasGetAll && ctx.dir === 'next' && isPlainKeyRange(ctx, true) && ctx.limit > 0) {
               // Special optimation if we could use IDBObjectStore.getAll() or
               // IDBKeyRange.getAll():
               var readingHook = ctx.table.hook.reading.fire;
               var idxOrStore = getIndexOrStore(ctx, idbstore);
               var req = ctx.limit < Infinity ? idxOrStore.getAll(ctx.range, ctx.limit) : idxOrStore.getAll(ctx.range);
               req.onerror = eventRejectHandler(reject);
               req.onsuccess = readingHook === mirror ? eventSuccessHandler(resolve) : eventSuccessHandler(function (res) {
                 try {
                   resolve(res.map(readingHook));
                 } catch (e) {
                   reject(e);
                 }
               });
             } else {
               // Getting array through a cursor.
               var a = [];
               iter(ctx, function (item) {
                 a.push(item);
               }, function arrayComplete() {
                 resolve(a);
               }, reject, idbstore);
             }
           }, cb);
         },
         offset: function offset(_offset2) {
           var ctx = this._ctx;
           if (_offset2 <= 0) return this;
           ctx.offset += _offset2; // For count()

           if (isPlainKeyRange(ctx)) {
             addReplayFilter(ctx, function () {
               var offsetLeft = _offset2;
               return function (cursor, advance) {
                 if (offsetLeft === 0) return true;

                 if (offsetLeft === 1) {
                   --offsetLeft;
                   return false;
                 }

                 advance(function () {
                   cursor.advance(offsetLeft);
                   offsetLeft = 0;
                 });
                 return false;
               };
             });
           } else {
             addReplayFilter(ctx, function () {
               var offsetLeft = _offset2;
               return function () {
                 return --offsetLeft < 0;
               };
             });
           }

           return this;
         },
         limit: function limit(numRows) {
           this._ctx.limit = Math.min(this._ctx.limit, numRows); // For count()

           addReplayFilter(this._ctx, function () {
             var rowsLeft = numRows;
             return function (cursor, advance, resolve) {
               if (--rowsLeft <= 0) advance(resolve); // Stop after this item has been included

               return rowsLeft >= 0; // If numRows is already below 0, return false because then 0 was passed to numRows initially. Otherwise we wouldnt come here.
             };
           }, true);
           return this;
         },
         until: function until(filterFunction, bIncludeStopEntry) {
           addFilter(this._ctx, function (cursor, advance, resolve) {
             if (filterFunction(cursor.value)) {
               advance(resolve);
               return bIncludeStopEntry;
             } else {
               return true;
             }
           });
           return this;
         },
         first: function first(cb) {
           return this.limit(1).toArray(function (a) {
             return a[0];
           }).then(cb);
         },
         last: function last(cb) {
           return this.reverse().first(cb);
         },
         filter: function filter(filterFunction) {
           /// <param name="jsFunctionFilter" type="Function">function(val){return true/false}</param>
           addFilter(this._ctx, function (cursor) {
             return filterFunction(cursor.value);
           }); // match filters not used in Dexie.js but can be used by 3rd part libraries to test a
           // collection for a match without querying DB. Used by Dexie.Observable.

           addMatchFilter(this._ctx, filterFunction);
           return this;
         },
         and: function and(filterFunction) {
           return this.filter(filterFunction);
         },
         or: function or(indexName) {
           return new WhereClause(this._ctx.table, indexName, this);
         },
         reverse: function reverse() {
           this._ctx.dir = this._ctx.dir === "prev" ? "next" : "prev";
           if (this._ondirectionchange) this._ondirectionchange(this._ctx.dir);
           return this;
         },
         desc: function desc() {
           return this.reverse();
         },
         eachKey: function eachKey(cb) {
           var ctx = this._ctx;
           ctx.keysOnly = !ctx.isMatch;
           return this.each(function (val, cursor) {
             cb(cursor.key, cursor);
           });
         },
         eachUniqueKey: function eachUniqueKey(cb) {
           this._ctx.unique = "unique";
           return this.eachKey(cb);
         },
         eachPrimaryKey: function eachPrimaryKey(cb) {
           var ctx = this._ctx;
           ctx.keysOnly = !ctx.isMatch;
           return this.each(function (val, cursor) {
             cb(cursor.primaryKey, cursor);
           });
         },
         keys: function keys(cb) {
           var ctx = this._ctx;
           ctx.keysOnly = !ctx.isMatch;
           var a = [];
           return this.each(function (item, cursor) {
             a.push(cursor.key);
           }).then(function () {
             return a;
           }).then(cb);
         },
         primaryKeys: function primaryKeys(cb) {
           var ctx = this._ctx;

           if (hasGetAll && ctx.dir === 'next' && isPlainKeyRange(ctx, true) && ctx.limit > 0) {
             // Special optimation if we could use IDBObjectStore.getAllKeys() or
             // IDBKeyRange.getAllKeys():
             return this._read(function (resolve, reject, idbstore) {
               var idxOrStore = getIndexOrStore(ctx, idbstore);
               var req = ctx.limit < Infinity ? idxOrStore.getAllKeys(ctx.range, ctx.limit) : idxOrStore.getAllKeys(ctx.range);
               req.onerror = eventRejectHandler(reject);
               req.onsuccess = eventSuccessHandler(resolve);
             }).then(cb);
           }

           ctx.keysOnly = !ctx.isMatch;
           var a = [];
           return this.each(function (item, cursor) {
             a.push(cursor.primaryKey);
           }).then(function () {
             return a;
           }).then(cb);
         },
         uniqueKeys: function uniqueKeys(cb) {
           this._ctx.unique = "unique";
           return this.keys(cb);
         },
         firstKey: function firstKey(cb) {
           return this.limit(1).keys(function (a) {
             return a[0];
           }).then(cb);
         },
         lastKey: function lastKey(cb) {
           return this.reverse().firstKey(cb);
         },
         distinct: function distinct() {
           var ctx = this._ctx,
               idx = ctx.index && ctx.table.schema.idxByName[ctx.index];
           if (!idx || !idx.multi) return this; // distinct() only makes differencies on multiEntry indexes.

           var set = {};
           addFilter(this._ctx, function (cursor) {
             var strKey = cursor.primaryKey.toString(); // Converts any Date to String, String to String, Number to String and Array to comma-separated string

             var found = hasOwn(set, strKey);
             set[strKey] = true;
             return !found;
           });
           return this;
         },
         //
         // Methods that mutate storage
         //
         modify: function modify(changes) {
           var self = this,
               ctx = this._ctx,
               hook = ctx.table.hook,
               updatingHook = hook.updating.fire,
               deletingHook = hook.deleting.fire;
           return this._write(function (resolve, reject, idbstore, trans) {
             var modifyer;

             if (typeof changes === 'function') {
               // Changes is a function that may update, add or delete propterties or even require a deletion the object itself (delete this.item)
               if (updatingHook === nop && deletingHook === nop) {
                 // Noone cares about what is being changed. Just let the modifier function be the given argument as is.
                 modifyer = changes;
               } else {
                 // People want to know exactly what is being modified or deleted.
                 // Let modifyer be a proxy function that finds out what changes the caller is actually doing
                 // and call the hooks accordingly!
                 modifyer = function modifyer(item) {
                   var origItem = deepClone(item); // Clone the item first so we can compare laters.

                   if (changes.call(this, item, this) === false) return false; // Call the real modifyer function (If it returns false explicitely, it means it dont want to modify anyting on this object)

                   if (!hasOwn(this, "value")) {
                     // The real modifyer function requests a deletion of the object. Inform the deletingHook that a deletion is taking place.
                     deletingHook.call(this, this.primKey, item, trans);
                   } else {
                     // No deletion. Check what was changed
                     var objectDiff = getObjectDiff(origItem, this.value);
                     var additionalChanges = updatingHook.call(this, objectDiff, this.primKey, origItem, trans);

                     if (additionalChanges) {
                       // Hook want to apply additional modifications. Make sure to fullfill the will of the hook.
                       item = this.value;
                       keys(additionalChanges).forEach(function (keyPath) {
                         setByKeyPath(item, keyPath, additionalChanges[keyPath]); // Adding {keyPath: undefined} means that the keyPath should be deleted. Handled by setByKeyPath
                       });
                     }
                   }
                 };
               }
             } else if (updatingHook === nop) {
               // changes is a set of {keyPath: value} and no one is listening to the updating hook.
               var keyPaths = keys(changes);
               var numKeys = keyPaths.length;

               modifyer = function modifyer(item) {
                 var anythingModified = false;

                 for (var i = 0; i < numKeys; ++i) {
                   var keyPath = keyPaths[i],
                       val = changes[keyPath];

                   if (getByKeyPath(item, keyPath) !== val) {
                     setByKeyPath(item, keyPath, val); // Adding {keyPath: undefined} means that the keyPath should be deleted. Handled by setByKeyPath

                     anythingModified = true;
                   }
                 }

                 return anythingModified;
               };
             } else {
               // changes is a set of {keyPath: value} and people are listening to the updating hook so we need to call it and
               // allow it to add additional modifications to make.
               var origChanges = changes;
               changes = shallowClone(origChanges); // Let's work with a clone of the changes keyPath/value set so that we can restore it in case a hook extends it.

               modifyer = function modifyer(item) {
                 var anythingModified = false;
                 var additionalChanges = updatingHook.call(this, changes, this.primKey, deepClone(item), trans);
                 if (additionalChanges) extend(changes, additionalChanges);
                 keys(changes).forEach(function (keyPath) {
                   var val = changes[keyPath];

                   if (getByKeyPath(item, keyPath) !== val) {
                     setByKeyPath(item, keyPath, val);
                     anythingModified = true;
                   }
                 });
                 if (additionalChanges) changes = shallowClone(origChanges); // Restore original changes for next iteration

                 return anythingModified;
               };
             }

             var count = 0;
             var successCount = 0;
             var iterationComplete = false;
             var failures = [];
             var failKeys = [];
             var currentKey = null;

             function modifyItem(item, cursor) {
               currentKey = cursor.primaryKey;
               var thisContext = {
                 primKey: cursor.primaryKey,
                 value: item,
                 onsuccess: null,
                 onerror: null
               };

               function onerror(e) {
                 failures.push(e);
                 failKeys.push(thisContext.primKey);
                 checkFinished();
                 return true; // Catch these errors and let a final rejection decide whether or not to abort entire transaction
               }

               if (modifyer.call(thisContext, item, thisContext) !== false) {
                 var bDelete = !hasOwn(thisContext, "value");
                 ++count;
                 tryCatch(function () {
                   var req = bDelete ? cursor["delete"]() : cursor.update(thisContext.value);
                   req._hookCtx = thisContext;
                   req.onerror = hookedEventRejectHandler(onerror);
                   req.onsuccess = hookedEventSuccessHandler(function () {
                     ++successCount;
                     checkFinished();
                   });
                 }, onerror);
               } else if (thisContext.onsuccess) {
                 // Hook will expect either onerror or onsuccess to always be called!
                 thisContext.onsuccess(thisContext.value);
               }
             }

             function doReject(e) {
               if (e) {
                 failures.push(e);
                 failKeys.push(currentKey);
               }

               return reject(new ModifyError("Error modifying one or more objects", failures, successCount, failKeys));
             }

             function checkFinished() {
               if (iterationComplete && successCount + failures.length === count) {
                 if (failures.length > 0) doReject();else resolve(successCount);
               }
             }

             self.clone().raw()._iterate(modifyItem, function () {
               iterationComplete = true;
               checkFinished();
             }, doReject, idbstore);
           });
         },
         'delete': function _delete() {
           var _this = this;

           var ctx = this._ctx,
               range = ctx.range,
               deletingHook = ctx.table.hook.deleting.fire,
               hasDeleteHook = deletingHook !== nop;

           if (!hasDeleteHook && isPlainKeyRange(ctx) && (ctx.isPrimKey && !hangsOnDeleteLargeKeyRange || !range)) {
             // May use IDBObjectStore.delete(IDBKeyRange) in this case (Issue #208)
             // For chromium, this is the way most optimized version.
             // For IE/Edge, this could hang the indexedDB engine and make operating system instable
             // (https://gist.github.com/dfahlander/5a39328f029de18222cf2125d56c38f7)
             return this._write(function (resolve, reject, idbstore) {
               // Our API contract is to return a count of deleted items, so we have to count() before delete().
               var onerror = eventRejectHandler(reject),
                   countReq = range ? idbstore.count(range) : idbstore.count();
               countReq.onerror = onerror;

               countReq.onsuccess = function () {
                 var count = countReq.result;
                 tryCatch(function () {
                   var delReq = range ? idbstore["delete"](range) : idbstore.clear();
                   delReq.onerror = onerror;

                   delReq.onsuccess = function () {
                     return resolve(count);
                   };
                 }, function (err) {
                   return reject(err);
                 });
               };
             });
           } // Default version to use when collection is not a vanilla IDBKeyRange on the primary key.
           // Divide into chunks to not starve RAM.
           // If has delete hook, we will have to collect not just keys but also objects, so it will use
           // more memory and need lower chunk size.


           var CHUNKSIZE = hasDeleteHook ? 2000 : 10000;
           return this._write(function (resolve, reject, idbstore, trans) {
             var totalCount = 0; // Clone collection and change its table and set a limit of CHUNKSIZE on the cloned Collection instance.

             var collection = _this.clone({
               keysOnly: !ctx.isMatch && !hasDeleteHook
             }) // load just keys (unless filter() or and() or deleteHook has subscribers)
             .distinct() // In case multiEntry is used, never delete same key twice because resulting count
             .limit(CHUNKSIZE).raw(); // Don't filter through reading-hooks (like mapped classes etc)


             var keysOrTuples = []; // We're gonna do things on as many chunks that are needed.
             // Use recursion of nextChunk function:

             var nextChunk = function nextChunk() {
               return collection.each(hasDeleteHook ? function (val, cursor) {
                 // Somebody subscribes to hook('deleting'). Collect all primary keys and their values,
                 // so that the hook can be called with its values in bulkDelete().
                 keysOrTuples.push([cursor.primaryKey, cursor.value]);
               } : function (val, cursor) {
                 // No one subscribes to hook('deleting'). Collect only primary keys:
                 keysOrTuples.push(cursor.primaryKey);
               }).then(function () {
                 // Chromium deletes faster when doing it in sort order.
                 hasDeleteHook ? keysOrTuples.sort(function (a, b) {
                   return ascending(a[0], b[0]);
                 }) : keysOrTuples.sort(ascending);
                 return _bulkDelete(idbstore, trans, keysOrTuples, hasDeleteHook, deletingHook);
               }).then(function () {
                 var count = keysOrTuples.length;
                 totalCount += count;
                 keysOrTuples = [];
                 return count < CHUNKSIZE ? totalCount : nextChunk();
               });
             };

             resolve(nextChunk());
           });
         }
       };
     }); //
     //
     //
     // ------------------------- Help functions ---------------------------
     //
     //
     //

     function lowerVersionFirst(a, b) {
       return a._cfg.version - b._cfg.version;
     }

     function setApiOnPlace(objs, tableNames, dbschema) {
       tableNames.forEach(function (tableName) {
         var schema = dbschema[tableName];
         objs.forEach(function (obj) {
           if (!(tableName in obj)) {
             if (obj === Transaction.prototype || obj instanceof Transaction) {
               // obj is a Transaction prototype (or prototype of a subclass to Transaction)
               // Make the API a getter that returns this.table(tableName)
               setProp(obj, tableName, {
                 get: function get() {
                   return this.table(tableName);
                 }
               });
             } else {
               // Table will not be bound to a transaction (will use Dexie.currentTransaction)
               obj[tableName] = new Table(tableName, schema);
             }
           }
         });
       });
     }

     function removeTablesApi(objs) {
       objs.forEach(function (obj) {
         for (var key in obj) {
           if (obj[key] instanceof Table) delete obj[key];
         }
       });
     }

     function iterate(req, filter, fn, resolve, reject, valueMapper) {
       // Apply valueMapper (hook('reading') or mappped class)
       var mappedFn = valueMapper ? function (x, c, a) {
         return fn(valueMapper(x), c, a);
       } : fn; // Wrap fn with PSD and microtick stuff from Promise.

       var wrappedFn = wrap(mappedFn, reject);
       if (!req.onerror) req.onerror = eventRejectHandler(reject);

       if (filter) {
         req.onsuccess = trycatcher(function filter_record() {
           var cursor = req.result;

           if (cursor) {
             var c = function c() {
               cursor["continue"]();
             };

             if (filter(cursor, function (advancer) {
               c = advancer;
             }, resolve, reject)) wrappedFn(cursor.value, cursor, function (advancer) {
               c = advancer;
             });
             c();
           } else {
             resolve();
           }
         }, reject);
       } else {
         req.onsuccess = trycatcher(function filter_record() {
           var cursor = req.result;

           if (cursor) {
             var c = function c() {
               cursor["continue"]();
             };

             wrappedFn(cursor.value, cursor, function (advancer) {
               c = advancer;
             });
             c();
           } else {
             resolve();
           }
         }, reject);
       }
     }

     function parseIndexSyntax(indexes) {
       /// <param name="indexes" type="String"></param>
       /// <returns type="Array" elementType="IndexSpec"></returns>
       var rv = [];
       indexes.split(',').forEach(function (index) {
         index = index.trim();
         var name = index.replace(/([&*]|\+\+)/g, ""); // Remove "&", "++" and "*"
         // Let keyPath of "[a+b]" be ["a","b"]:

         var keyPath = /^\[/.test(name) ? name.match(/^\[(.*)\]$/)[1].split('+') : name;
         rv.push(new IndexSpec(name, keyPath || null, /\&/.test(index), /\*/.test(index), /\+\+/.test(index), isArray(keyPath), /\./.test(index)));
       });
       return rv;
     }

     function cmp(key1, key2) {
       return indexedDB.cmp(key1, key2);
     }

     function min(a, b) {
       return cmp(a, b) < 0 ? a : b;
     }

     function max(a, b) {
       return cmp(a, b) > 0 ? a : b;
     }

     function ascending(a, b) {
       return indexedDB.cmp(a, b);
     }

     function descending(a, b) {
       return indexedDB.cmp(b, a);
     }

     function simpleCompare(a, b) {
       return a < b ? -1 : a === b ? 0 : 1;
     }

     function simpleCompareReverse(a, b) {
       return a > b ? -1 : a === b ? 0 : 1;
     }

     function combine(filter1, filter2) {
       return filter1 ? filter2 ? function () {
         return filter1.apply(this, arguments) && filter2.apply(this, arguments);
       } : filter1 : filter2;
     }

     function readGlobalSchema() {
       db.verno = idbdb.version / 10;
       db._dbSchema = globalSchema = {};
       dbStoreNames = slice(idbdb.objectStoreNames, 0);
       if (dbStoreNames.length === 0) return; // Database contains no stores.

       var trans = idbdb.transaction(safariMultiStoreFix(dbStoreNames), 'readonly');
       dbStoreNames.forEach(function (storeName) {
         var store = trans.objectStore(storeName),
             keyPath = store.keyPath,
             dotted = keyPath && typeof keyPath === 'string' && keyPath.indexOf('.') !== -1;
         var primKey = new IndexSpec(keyPath, keyPath || "", false, false, !!store.autoIncrement, keyPath && typeof keyPath !== 'string', dotted);
         var indexes = [];

         for (var j = 0; j < store.indexNames.length; ++j) {
           var idbindex = store.index(store.indexNames[j]);
           keyPath = idbindex.keyPath;
           dotted = keyPath && typeof keyPath === 'string' && keyPath.indexOf('.') !== -1;
           var index = new IndexSpec(idbindex.name, keyPath, !!idbindex.unique, !!idbindex.multiEntry, false, keyPath && typeof keyPath !== 'string', dotted);
           indexes.push(index);
         }

         globalSchema[storeName] = new TableSchema(storeName, primKey, indexes, {});
       });
       setApiOnPlace([allTables], keys(globalSchema), globalSchema);
     }

     function adjustToExistingIndexNames(schema, idbtrans) {
       /// <summary>
       /// Issue #30 Problem with existing db - adjust to existing index names when migrating from non-dexie db
       /// </summary>
       /// <param name="schema" type="Object">Map between name and TableSchema</param>
       /// <param name="idbtrans" type="IDBTransaction"></param>
       var storeNames = idbtrans.db.objectStoreNames;

       for (var i = 0; i < storeNames.length; ++i) {
         var storeName = storeNames[i];
         var store = idbtrans.objectStore(storeName);
         hasGetAll = 'getAll' in store;

         for (var j = 0; j < store.indexNames.length; ++j) {
           var indexName = store.indexNames[j];
           var keyPath = store.index(indexName).keyPath;
           var dexieName = typeof keyPath === 'string' ? keyPath : "[" + slice(keyPath).join('+') + "]";

           if (schema[storeName]) {
             var indexSpec = schema[storeName].idxByName[dexieName];
             if (indexSpec) indexSpec.name = indexName;
           }
         }
       } // Bug with getAll() on Safari ver<604 on Workers only, see discussion following PR #579


       if (/Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && _global.WorkerGlobalScope && _global instanceof _global.WorkerGlobalScope && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604) {
         hasGetAll = false;
       }
     }

     function fireOnBlocked(ev) {
       db.on("blocked").fire(ev); // Workaround (not fully*) for missing "versionchange" event in IE,Edge and Safari:

       connections.filter(function (c) {
         return c.name === db.name && c !== db && !c._vcFired;
       }).map(function (c) {
         return c.on("versionchange").fire(ev);
       });
     }

     extend(this, {
       Collection: Collection,
       Table: Table,
       Transaction: Transaction,
       Version: Version,
       WhereClause: WhereClause
     });
     init();
     addons.forEach(function (fn) {
       fn(db);
     });
   }

   function parseType(type) {
     if (typeof type === 'function') {
       return new type();
     } else if (isArray(type)) {
       return [parseType(type[0])];
     } else if (type && babelHelpers["typeof"](type) === 'object') {
       var rv = {};
       applyStructure(rv, type);
       return rv;
     } else {
       return type;
     }
   }

   function applyStructure(obj, structure) {
     keys(structure).forEach(function (member) {
       var value = parseType(structure[member]);
       obj[member] = value;
     });
     return obj;
   }

   function hookedEventSuccessHandler(resolve) {
     // wrap() is needed when calling hooks because the rare scenario of:
     //  * hook does a db operation that fails immediately (IDB throws exception)
     //    For calling db operations on correct transaction, wrap makes sure to set PSD correctly.
     //    wrap() will also execute in a virtual tick.
     //  * If not wrapped in a virtual tick, direct exception will launch a new physical tick.
     //  * If this was the last event in the bulk, the promise will resolve after a physical tick
     //    and the transaction will have committed already.
     // If no hook, the virtual tick will be executed in the reject()/resolve of the final promise,
     // because it is always marked with _lib = true when created using Transaction._promise().
     return wrap(function (event) {
       var req = event.target,
           ctx = req._hookCtx,
           // Contains the hook error handler. Put here instead of closure to boost performance.
       result = ctx.value || req.result,
           // Pass the object value on updates. The result from IDB is the primary key.
       hookSuccessHandler = ctx && ctx.onsuccess;
       hookSuccessHandler && hookSuccessHandler(result);
       resolve && resolve(result);
     }, resolve);
   }

   function eventRejectHandler(reject) {
     return wrap(function (event) {
       preventDefault(event);
       reject(event.target.error);
       return false;
     });
   }

   function eventSuccessHandler(resolve) {
     return wrap(function (event) {
       resolve(event.target.result);
     });
   }

   function hookedEventRejectHandler(reject) {
     return wrap(function (event) {
       // See comment on hookedEventSuccessHandler() why wrap() is needed only when supporting hooks.
       var req = event.target,
           err = req.error,
           ctx = req._hookCtx,
           // Contains the hook error handler. Put here instead of closure to boost performance.
       hookErrorHandler = ctx && ctx.onerror;
       hookErrorHandler && hookErrorHandler(err);
       preventDefault(event);
       reject(err);
       return false;
     });
   }

   function preventDefault(event) {
     if (event.stopPropagation) event.stopPropagation();
     if (event.preventDefault) event.preventDefault();
   }

   function awaitIterator(iterator) {
     var callNext = function callNext(result) {
       return iterator.next(result);
     },
         doThrow = function doThrow(error) {
       return iterator["throw"](error);
     },
         onSuccess = step(callNext),
         onError = step(doThrow);

     function step(getNext) {
       return function (val) {
         var next = getNext(val),
             value = next.value;
         return next.done ? value : !value || typeof value.then !== 'function' ? isArray(value) ? Promise.all(value).then(onSuccess, onError) : onSuccess(value) : value.then(onSuccess, onError);
       };
     }

     return step(callNext)();
   } //
   // IndexSpec struct
   //


   function IndexSpec(name, keyPath, unique, multi, auto, compound, dotted) {
     /// <param name="name" type="String"></param>
     /// <param name="keyPath" type="String"></param>
     /// <param name="unique" type="Boolean"></param>
     /// <param name="multi" type="Boolean"></param>
     /// <param name="auto" type="Boolean"></param>
     /// <param name="compound" type="Boolean"></param>
     /// <param name="dotted" type="Boolean"></param>
     this.name = name;
     this.keyPath = keyPath;
     this.unique = unique;
     this.multi = multi;
     this.auto = auto;
     this.compound = compound;
     this.dotted = dotted;
     var keyPathSrc = typeof keyPath === 'string' ? keyPath : keyPath && '[' + [].join.call(keyPath, '+') + ']';
     this.src = (unique ? '&' : '') + (multi ? '*' : '') + (auto ? "++" : "") + keyPathSrc;
   } //
   // TableSchema struct
   //


   function TableSchema(name, primKey, indexes, instanceTemplate) {
     /// <param name="name" type="String"></param>
     /// <param name="primKey" type="IndexSpec"></param>
     /// <param name="indexes" type="Array" elementType="IndexSpec"></param>
     /// <param name="instanceTemplate" type="Object"></param>
     this.name = name;
     this.primKey = primKey || new IndexSpec();
     this.indexes = indexes || [new IndexSpec()];
     this.instanceTemplate = instanceTemplate;
     this.mappedClass = null;
     this.idxByName = arrayToObject(indexes, function (index) {
       return [index.name, index];
     });
   }

   function safariMultiStoreFix(storeNames) {
     return storeNames.length === 1 ? storeNames[0] : storeNames;
   }

   function getNativeGetDatabaseNamesFn(indexedDB) {
     var fn = indexedDB && (indexedDB.getDatabaseNames || indexedDB.webkitGetDatabaseNames);
     return fn && fn.bind(indexedDB);
   } // Export Error classes


   props(Dexie, fullNameExceptions); // Dexie.XXXError = class XXXError {...};
   //
   // Static methods and properties
   //

   props(Dexie, {
     //
     // Static delete() method.
     //
     "delete": function _delete(databaseName) {
       var db = new Dexie(databaseName),
           promise = db["delete"]();

       promise.onblocked = function (fn) {
         db.on("blocked", fn);
         return this;
       };

       return promise;
     },
     //
     // Static exists() method.
     //
     exists: function exists(name) {
       return new Dexie(name).open().then(function (db) {
         db.close();
         return true;
       })["catch"](Dexie.NoSuchDatabaseError, function () {
         return false;
       });
     },
     //
     // Static method for retrieving a list of all existing databases at current host.
     //
     getDatabaseNames: function getDatabaseNames(cb) {
       var getDatabaseNames = getNativeGetDatabaseNamesFn(Dexie.dependencies.indexedDB);
       return getDatabaseNames ? new Promise(function (resolve, reject) {
         var req = getDatabaseNames();

         req.onsuccess = function (event) {
           resolve(slice(event.target.result, 0)); // Converst DOMStringList to Array<String>
         };

         req.onerror = eventRejectHandler(reject);
       }).then(cb) : dbNamesDB.dbnames.toCollection().primaryKeys(cb);
     },
     defineClass: function defineClass() {
       // Default constructor able to copy given properties into this object.
       function Class(properties) {
         /// <param name="properties" type="Object" optional="true">Properties to initialize object with.
         /// </param>
         if (properties) extend(this, properties);
       }

       return Class;
     },
     applyStructure: applyStructure,
     ignoreTransaction: function ignoreTransaction(scopeFunc) {
       // In case caller is within a transaction but needs to create a separate transaction.
       // Example of usage:
       //
       // Let's say we have a logger function in our app. Other application-logic should be unaware of the
       // logger function and not need to include the 'logentries' table in all transaction it performs.
       // The logging should always be done in a separate transaction and not be dependant on the current
       // running transaction context. Then you could use Dexie.ignoreTransaction() to run code that starts a new transaction.
       //
       //     Dexie.ignoreTransaction(function() {
       //         db.logentries.add(newLogEntry);
       //     });
       //
       // Unless using Dexie.ignoreTransaction(), the above example would try to reuse the current transaction
       // in current Promise-scope.
       //
       // An alternative to Dexie.ignoreTransaction() would be setImmediate() or setTimeout(). The reason we still provide an
       // API for this because
       //  1) The intention of writing the statement could be unclear if using setImmediate() or setTimeout().
       //  2) setTimeout() would wait unnescessary until firing. This is however not the case with setImmediate().
       //  3) setImmediate() is not supported in the ES standard.
       //  4) You might want to keep other PSD state that was set in a parent PSD, such as PSD.letThrough.
       return PSD.trans ? usePSD(PSD.transless, scopeFunc) : // Use the closest parent that was non-transactional.
       scopeFunc(); // No need to change scope because there is no ongoing transaction.
     },
     vip: function vip(fn) {
       // To be used by subscribers to the on('ready') event.
       // This will let caller through to access DB even when it is blocked while the db.ready() subscribers are firing.
       // This would have worked automatically if we were certain that the Provider was using Dexie.Promise for all asyncronic operations. The promise PSD
       // from the provider.connect() call would then be derived all the way to when provider would call localDatabase.applyChanges(). But since
       // the provider more likely is using non-promise async APIs or other thenable implementations, we cannot assume that.
       // Note that this method is only useful for on('ready') subscribers that is returning a Promise from the event. If not using vip()
       // the database could deadlock since it wont open until the returned Promise is resolved, and any non-VIPed operation started by
       // the caller will not resolve until database is opened.
       return newScope(function () {
         PSD.letThrough = true; // Make sure we are let through if still blocking db due to onready is firing.

         return fn();
       });
     },
     async: function async(generatorFn) {
       return function () {
         try {
           var rv = awaitIterator(generatorFn.apply(this, arguments));
           if (!rv || typeof rv.then !== 'function') return Promise.resolve(rv);
           return rv;
         } catch (e) {
           return rejection(e);
         }
       };
     },
     spawn: function spawn(generatorFn, args, thiz) {
       try {
         var rv = awaitIterator(generatorFn.apply(thiz, args || []));
         if (!rv || typeof rv.then !== 'function') return Promise.resolve(rv);
         return rv;
       } catch (e) {
         return rejection(e);
       }
     },
     // Dexie.currentTransaction property
     currentTransaction: {
       get: function get() {
         return PSD.trans || null;
       }
     },
     waitFor: function waitFor(promiseOrFunction, optionalTimeout) {
       // If a function is provided, invoke it and pass the returning value to Transaction.waitFor()
       var promise = Promise.resolve(typeof promiseOrFunction === 'function' ? Dexie.ignoreTransaction(promiseOrFunction) : promiseOrFunction).timeout(optionalTimeout || 60000); // Default the timeout to one minute. Caller may specify Infinity if required.
       // Run given promise on current transaction. If no current transaction, just return a Dexie promise based
       // on given value.

       return PSD.trans ? PSD.trans.waitFor(promise) : promise;
     },
     // Export our Promise implementation since it can be handy as a standalone Promise implementation
     Promise: Promise,
     // Dexie.debug proptery:
     // Dexie.debug = false
     // Dexie.debug = true
     // Dexie.debug = "dexie" - don't hide dexie's stack frames.
     debug: {
       get: function get() {
         return debug;
       },
       set: function set(value) {
         setDebug(value, value === 'dexie' ? function () {
           return true;
         } : dexieStackFrameFilter);
       }
     },
     // Export our derive/extend/override methodology
     derive: derive,
     extend: extend,
     props: props,
     override: override,
     // Export our Events() function - can be handy as a toolkit
     Events: Events,
     // Utilities
     getByKeyPath: getByKeyPath,
     setByKeyPath: setByKeyPath,
     delByKeyPath: delByKeyPath,
     shallowClone: shallowClone,
     deepClone: deepClone,
     getObjectDiff: getObjectDiff,
     asap: asap,
     maxKey: maxKey,
     minKey: minKey,
     // Addon registry
     addons: [],
     // Global DB connection list
     connections: connections,
     MultiModifyError: exceptions.Modify,
     errnames: errnames,
     // Export other static classes
     IndexSpec: IndexSpec,
     TableSchema: TableSchema,
     //
     // Dependencies
     //
     // These will automatically work in browsers with indexedDB support, or where an indexedDB polyfill has been included.
     //
     // In node.js, however, these properties must be set "manually" before instansiating a new Dexie().
     // For node.js, you need to require indexeddb-js or similar and then set these deps.
     //
     dependencies: function () {
       try {
         return {
           // Required:
           indexedDB: _global.indexedDB || _global.mozIndexedDB || _global.webkitIndexedDB || _global.msIndexedDB,
           IDBKeyRange: _global.IDBKeyRange || _global.webkitIDBKeyRange
         };
       } catch (e) {
         return {
           indexedDB: null,
           IDBKeyRange: null
         };
       }
     }(),
     // API Version Number: Type Number, make sure to always set a version number that can be comparable correctly. Example: 0.9, 0.91, 0.92, 1.0, 1.01, 1.1, 1.2, 1.21, etc.
     semVer: DEXIE_VERSION,
     version: DEXIE_VERSION.split('.').map(function (n) {
       return parseInt(n);
     }).reduce(function (p, c, i) {
       return p + c / Math.pow(10, i * 2);
     }),
     // https://github.com/dfahlander/Dexie.js/issues/186
     // typescript compiler tsc in mode ts-->es5 & commonJS, will expect require() to return
     // x.default. Workaround: Set Dexie.default = Dexie.
     "default": Dexie,
     // Make it possible to import {Dexie} (non-default import)
     // Reason 1: May switch to that in future.
     // Reason 2: We declare it both default and named exported in d.ts to make it possible
     // to let addons extend the Dexie interface with Typescript 2.1 (works only when explicitely
     // exporting the symbol, not just default exporting)
     Dexie: Dexie
   }); // Map DOMErrors and DOMExceptions to corresponding Dexie errors. May change in Dexie v2.0.

   Promise.rejectionMapper = mapError; // Initialize dbNamesDB (won't ever be opened on chromium browsers')

   dbNamesDB = new Dexie('__dbnames');
   dbNamesDB.version(1).stores({
     dbnames: 'name'
   });

   (function () {
     // Migrate from Dexie 1.x database names stored in localStorage:
     var DBNAMES = 'Dexie.DatabaseNames';

     try {
       if ((typeof localStorage === "undefined" ? "undefined" : babelHelpers["typeof"](localStorage)) !== undefined && _global.document !== undefined) {
         // Have localStorage and is not executing in a worker. Lets migrate from Dexie 1.x.
         JSON.parse(localStorage.getItem(DBNAMES) || "[]").forEach(function (name) {
           return dbNamesDB.dbnames.put({
             name: name
           })["catch"](nop);
         });
         localStorage.removeItem(DBNAMES);
       }
     } catch (_e) {}
   })();

   /**
    * Bitrix UI
    * IndexedDB manager (integration with Dexie.js)
    *
    * @package bitrix
    * @subpackage ui
    * @copyright 2001-2019 Bitrix
    *
    * @see	https://dexie.org/docs/Tutorial/Getting-started
    */

   var Dexie$1 = function Dexie$$1(database) {
     babelHelpers.classCallCheck(this, Dexie$$1);
     return new Dexie(database);
   };

   Dexie$1["delete"] = Dexie["delete"];
   Dexie$1.exists = Dexie.exists;
   Dexie$1.getDatabaseNames = Dexie.getDatabaseNames;
   Dexie$1.defineClass = Dexie.defineClass;
   Dexie$1.applyStructure = Dexie.applyStructure;
   Dexie$1.ignoreTransaction = Dexie.ignoreTransaction;
   Dexie$1.vip = Dexie.vip;
   Dexie$1.async = Dexie.async;
   Dexie$1.spawn = Dexie.spawn;
   Dexie$1.currentTransaction = Dexie.currentTransaction;
   Dexie$1.waitFor = Dexie.waitFor;
   Dexie$1.Promise = Dexie.Promise;
   Dexie$1.debug = Dexie.debug;
   Dexie$1.derive = Dexie.derive;
   Dexie$1.extend = Dexie.extend;
   Dexie$1.props = Dexie.props;
   Dexie$1.override = Dexie.override;
   Dexie$1.Events = Dexie.Events;
   Dexie$1.getByKeyPath = Dexie.getByKeyPath;
   Dexie$1.setByKeyPath = Dexie.setByKeyPath;
   Dexie$1.delByKeyPath = Dexie.delByKeyPath;
   Dexie$1.shallowClone = Dexie.shallowClone;
   Dexie$1.deepClone = Dexie.deepClone;
   Dexie$1.getObjectDiff = Dexie.getObjectDiff;
   Dexie$1.asap = Dexie.asap;
   Dexie$1.maxKey = Dexie.maxKey;
   Dexie$1.minKey = Dexie.minKey;
   Dexie$1.addons = Dexie.addons;
   Dexie$1.connections = Dexie.connections;
   Dexie$1.MultiModifyError = Dexie.MultiModifyError;
   Dexie$1.errnames = Dexie.errnames;
   Dexie$1.IndexSpec = Dexie.IndexSpec;
   Dexie$1.TableSchema = Dexie.TableSchema;
   Dexie$1.dependencies = Dexie.dependencies;
   Dexie$1.semVer = Dexie.semVer;
   Dexie$1.version = Dexie.version;
   Dexie$1["default"] = Dexie["default"];
   Dexie$1.Dexie = Dexie.Dexie;

   exports.Dexie = Dexie$1;

}((this.BX = this.BX || {})));
 




// file: /bitrix/js/ui/vue/components/smiles/dist/smiles.bundle.js
(function (exports,ui_vue_directives_lazyload,ui_vue,ui_dexie) {
	'use strict';

	function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { babelHelpers.defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
	var SmileManager = /*#__PURE__*/function () {
	  function SmileManager(restClient) {
	    babelHelpers.classCallCheck(this, SmileManager);

	    if (typeof restClient !== 'undefined') {
	      this.restClient = restClient;
	    } else {
	      this.restClient = new BX.RestClient();
	    }

	    this.db = new ui_dexie.Dexie('bx-ui-smiles');
	    this.db.version(1).stores({
	      sets: "id, parentId, name, type, image",
	      smiles: "id, setId, name, image, typing, width, height, originalWidth, originalHeight, definition"
	    });
	  }

	  babelHelpers.createClass(SmileManager, [{
	    key: "loadFromCache",
	    value: function loadFromCache() {
	      var _this = this;

	      var promise = new BX.Promise();
	      var sets = [];
	      var smiles = [];
	      this.db.transaction('r', this.db.sets, this.db.smiles, function () {
	        _this.db.sets.each(function (set) {
	          return _this.db.smiles.where('setId').equals(set.id).first().then(function (smile) {
	            sets.push(_objectSpread(_objectSpread({}, set), {}, {
	              image: smile.image
	            }));
	          })["catch"](function (error) {
	            return promise.reject(error);
	          });
	        }).then(function () {
	          return _this.db.smiles.where('setId').equals(sets[0].id).each(function (smile) {
	            smiles.push(smile);
	          });
	        }).then(function () {
	          var promiseResult = {
	            sets: sets,
	            smiles: smiles
	          };
	          promise.resolve(promiseResult);
	        })["catch"](function (error) {
	          return promise.reject(error);
	        });
	      });
	      return promise;
	    }
	  }, {
	    key: "loadFromServer",
	    value: function loadFromServer() {
	      var _this2 = this;

	      var promise = new BX.Promise();
	      this.restClient.callMethod('smile.get').then(function (result) {
	        var sets = [];
	        var smiles = [];
	        var answer = result.data();
	        var setImage = {};
	        answer.smiles = answer.smiles.map(function (smile) {
	          if (!setImage[smile.setId]) {
	            setImage[smile.setId] = smile.image;
	          }

	          var originalWidth = smile.width;

	          if (smile.definition == 'HD') {
	            originalWidth = originalWidth * 2;
	          } else if (smile.definition == 'UHD') {
	            originalWidth = originalWidth * 4;
	          }

	          var originalHeight = smile.height;

	          if (smile.definition == 'HD') {
	            originalHeight = originalHeight * 2;
	          } else if (smile.definition == 'UHD') {
	            originalHeight = originalHeight * 4;
	          }

	          return _objectSpread(_objectSpread({}, smile), {}, {
	            originalWidth: originalWidth,
	            originalHeight: originalHeight
	          });
	        });
	        answer.sets.forEach(function (set) {
	          sets.push(_objectSpread(_objectSpread({}, set), {}, {
	            image: setImage[set.id]
	          }));
	        });
	        answer.smiles.forEach(function (smile) {
	          if (smile.setId == sets[0].id) {
	            smiles.push(smile);
	          }
	        });
	        var promiseResult = {
	          sets: sets,
	          smiles: smiles
	        };
	        promise.resolve(promiseResult);

	        _this2.db.smiles.clear().then(function () {
	          return _this2.db.sets.clear().then(function () {
	            _this2.db.sets.bulkAdd(sets);

	            _this2.db.smiles.bulkAdd(answer.smiles);
	          })["catch"](function (error) {
	            return promise.reject(error);
	          });
	        })["catch"](function (error) {
	          return promise.reject(error);
	        });
	      })["catch"](function (error) {
	        return promise.reject(error);
	      });
	      return promise;
	    }
	  }, {
	    key: "changeSet",
	    value: function changeSet(setId) {
	      var promise = new BX.Promise();
	      this.db.smiles.where('setId').equals(setId).toArray(function (smiles) {
	        promise.resolve(smiles);
	      })["catch"](function (error) {
	        return promise.reject(error);
	      });
	      return promise;
	    }
	  }]);
	  return SmileManager;
	}();

	var emoji = [{
	  id: 1,
	  code: 'PEOPLE',
	  showForWindows: true,
	  emoji: [{
	    symbol: "\uD83D\uDE00"
	  }, {
	    symbol: "\uD83D\uDE03"
	  }, {
	    symbol: "\uD83D\uDE04"
	  }, {
	    symbol: "\uD83D\uDE01"
	  }, {
	    symbol: "\uD83D\uDE06"
	  }, {
	    symbol: "\uD83D\uDE05"
	  }, {
	    symbol: "\uD83D\uDE02"
	  }, {
	    symbol: "\uD83E\uDD23"
	  }, {
	    symbol: "\uD83D\uDE0A"
	  }, {
	    symbol: "\uD83D\uDE07"
	  }, {
	    symbol: "\uD83D\uDE42"
	  }, {
	    symbol: "\uD83D\uDE43"
	  }, {
	    symbol: "\uD83D\uDE09"
	  }, {
	    symbol: "\uD83D\uDE0C"
	  }, {
	    symbol: "\uD83D\uDE0D"
	  }, {
	    symbol: "\uD83E\uDD70"
	  }, {
	    symbol: "\uD83D\uDE18"
	  }, {
	    symbol: "\uD83D\uDE17"
	  }, {
	    symbol: "\uD83D\uDE19"
	  }, {
	    symbol: "\uD83D\uDE1A"
	  }, {
	    symbol: "\uD83D\uDE0B"
	  }, {
	    symbol: "\uD83D\uDE1B"
	  }, {
	    symbol: "\uD83D\uDE1D"
	  }, {
	    symbol: "\uD83D\uDE1C"
	  }, {
	    symbol: "\uD83E\uDD2A"
	  }, {
	    symbol: "\uD83E\uDD28"
	  }, {
	    symbol: "\uD83E\uDDD0"
	  }, {
	    symbol: "\uD83E\uDD13"
	  }, {
	    symbol: "\uD83D\uDE0E"
	  }, {
	    symbol: "\uD83E\uDD29"
	  }, {
	    symbol: "\uD83E\uDD73"
	  }, {
	    symbol: "\uD83D\uDE0F"
	  }, {
	    symbol: "\uD83D\uDE12"
	  }, {
	    symbol: "\uD83D\uDE1E"
	  }, {
	    symbol: "\uD83D\uDE14"
	  }, {
	    symbol: "\uD83D\uDE1F"
	  }, {
	    symbol: "\uD83D\uDE15"
	  }, {
	    symbol: "\u2639"
	  }, {
	    symbol: "\uD83D\uDE41"
	  }, {
	    symbol: "\uD83D\uDE23"
	  }, {
	    symbol: "\uD83D\uDE2B"
	  }, {
	    symbol: "\uD83D\uDE29"
	  }, {
	    symbol: "\uD83E\uDD7A"
	  }, {
	    symbol: "\uD83D\uDE22"
	  }, {
	    symbol: "\uD83D\uDE2D"
	  }, {
	    symbol: "\uD83D\uDE24"
	  }, {
	    symbol: "\uD83D\uDE20"
	  }, {
	    symbol: "\uD83D\uDE21"
	  }, {
	    symbol: "\uD83E\uDD2C"
	  }, {
	    symbol: "\uD83E\uDD2F"
	  }, {
	    symbol: "\uD83D\uDE33"
	  }, {
	    symbol: "\uD83E\uDD75"
	  }, {
	    symbol: "\uD83E\uDD76"
	  }, {
	    symbol: "\uD83D\uDE31"
	  }, {
	    symbol: "\uD83D\uDE28"
	  }, {
	    symbol: "\uD83D\uDE30"
	  }, {
	    symbol: "\uD83D\uDE25"
	  }, {
	    symbol: "\uD83D\uDE13"
	  }, {
	    symbol: "\uD83E\uDD17"
	  }, {
	    symbol: "\uD83E\uDD14"
	  }, {
	    symbol: "\uD83E\uDD2D"
	  }, {
	    symbol: "\uD83E\uDD2B"
	  }, {
	    symbol: "\uD83E\uDD25"
	  }, {
	    symbol: "\uD83D\uDE36"
	  }, {
	    symbol: "\uD83D\uDE10"
	  }, {
	    symbol: "\uD83D\uDE11"
	  }, {
	    symbol: "\uD83D\uDE2C"
	  }, {
	    symbol: "\uD83D\uDE44"
	  }, {
	    symbol: "\uD83D\uDE2F"
	  }, {
	    symbol: "\uD83D\uDE26"
	  }, {
	    symbol: "\uD83D\uDE27"
	  }, {
	    symbol: "\uD83D\uDE2E"
	  }, {
	    symbol: "\uD83D\uDE32"
	  }, {
	    symbol: "\uD83D\uDE34"
	  }, {
	    symbol: "\uD83E\uDD24"
	  }, {
	    symbol: "\uD83D\uDE2A"
	  }, {
	    symbol: "\uD83D\uDE35"
	  }, {
	    symbol: "\uD83E\uDD10"
	  }, {
	    symbol: "\uD83E\uDD74"
	  }, {
	    symbol: "\uD83E\uDD22"
	  }, {
	    symbol: "\uD83E\uDD2E"
	  }, {
	    symbol: "\uD83E\uDD27"
	  }, {
	    symbol: "\uD83D\uDE37"
	  }, {
	    symbol: "\uD83E\uDD12"
	  }, {
	    symbol: "\uD83E\uDD15"
	  }, {
	    symbol: "\uD83E\uDD11"
	  }, {
	    symbol: "\uD83E\uDD20"
	  }, {
	    symbol: "\uD83D\uDE08"
	  }, {
	    symbol: "\uD83D\uDC7F"
	  }, {
	    symbol: "\uD83D\uDC79"
	  }, {
	    symbol: "\uD83D\uDC7A"
	  }, {
	    symbol: "\uD83E\uDD21"
	  }, {
	    symbol: "\uD83D\uDCA9"
	  }, {
	    symbol: "\uD83D\uDC7B"
	  }, {
	    symbol: "\u2620"
	  }, {
	    symbol: "\uD83D\uDC80"
	  }, {
	    symbol: "\uD83D\uDC7D"
	  }, {
	    symbol: "\uD83D\uDC7E"
	  }, {
	    symbol: "\uD83E\uDD16"
	  }, {
	    symbol: "\uD83C\uDF83"
	  }, {
	    symbol: "\uD83D\uDE3A"
	  }, {
	    symbol: "\uD83D\uDE38"
	  }, {
	    symbol: "\uD83D\uDE39"
	  }, {
	    symbol: "\uD83D\uDE3B"
	  }, {
	    symbol: "\uD83D\uDE3C"
	  }, {
	    symbol: "\uD83D\uDE3D"
	  }, {
	    symbol: "\uD83D\uDE40"
	  }, {
	    symbol: "\uD83D\uDE3F"
	  }, {
	    symbol: "\uD83D\uDE3E"
	  }, {
	    symbol: "\uD83E\uDD32"
	  }, {
	    symbol: "\uD83D\uDC50"
	  }, {
	    symbol: "\uD83D\uDE4C"
	  }, {
	    symbol: "\uD83D\uDC4F"
	  }, {
	    symbol: "\uD83E\uDD1D"
	  }, {
	    symbol: "\uD83D\uDC4D"
	  }, {
	    symbol: "\uD83D\uDC4E"
	  }, {
	    symbol: "\uD83D\uDC4A"
	  }, {
	    symbol: "\u270A"
	  }, {
	    symbol: "\uD83E\uDD1B"
	  }, {
	    symbol: "\uD83E\uDD1C"
	  }, {
	    symbol: "\uD83E\uDD1E"
	  }, {
	    symbol: "\u270C"
	  }, {
	    symbol: "\uD83E\uDD1F"
	  }, {
	    symbol: "\uD83E\uDD18"
	  }, {
	    symbol: "\uD83D\uDC4C"
	  }, {
	    symbol: "\uD83D\uDC48"
	  }, {
	    symbol: "\uD83D\uDC49"
	  }, {
	    symbol: "\uD83D\uDC46"
	  }, {
	    symbol: "\uD83D\uDC47"
	  }, {
	    symbol: "\uD83E\uDD1A"
	  }, {
	    symbol: "\uD83D\uDD90"
	  }, {
	    symbol: "\uD83D\uDD96"
	  }, {
	    symbol: "\uD83D\uDC4B"
	  }, {
	    symbol: "\uD83E\uDD19"
	  }, {
	    symbol: "\uD83D\uDCAA"
	  }, {
	    symbol: "\uD83D\uDD95"
	  }, {
	    symbol: "\u270D"
	  }, {
	    symbol: "\uD83D\uDE4F"
	  }, {
	    symbol: "\uD83E\uDDB6"
	  }, {
	    symbol: "\uD83E\uDDB5"
	  }, {
	    symbol: "\uD83D\uDC84"
	  }, {
	    symbol: "\uD83D\uDC8B"
	  }, {
	    symbol: "\uD83D\uDC44"
	  }, {
	    symbol: "\uD83E\uDDB7"
	  }, {
	    symbol: "\uD83D\uDC45"
	  }, {
	    symbol: "\uD83D\uDC43"
	  }, {
	    symbol: "\uD83D\uDC63"
	  }, {
	    symbol: "\uD83D\uDC41"
	  }, {
	    symbol: "\uD83D\uDC40"
	  }, {
	    symbol: "\uD83E\uDDE0"
	  }, {
	    symbol: "\uD83D\uDDE3"
	  }, {
	    symbol: "\uD83D\uDC64"
	  }, {
	    symbol: "\uD83D\uDC65"
	  }, {
	    symbol: "\uD83D\uDC76"
	  }, {
	    symbol: "\uD83D\uDC67"
	  }, {
	    symbol: "\uD83E\uDDD2"
	  }, {
	    symbol: "\uD83D\uDC66"
	  }, {
	    symbol: "\uD83D\uDC69"
	  }, {
	    symbol: "\uD83E\uDDD1"
	  }, {
	    symbol: "\uD83D\uDC68"
	  }, {
	    symbol: "\uD83D\uDC71"
	  }, {
	    symbol: "\uD83E\uDDD4"
	  }, {
	    symbol: "\uD83D\uDC75"
	  }, {
	    symbol: "\uD83E\uDDD3"
	  }, {
	    symbol: "\uD83D\uDC74"
	  }, {
	    symbol: "\uD83D\uDC72"
	  }, {
	    symbol: "\uD83D\uDC73"
	  }, {
	    symbol: "\uD83E\uDDD5"
	  }, {
	    symbol: "\uD83D\uDC6E"
	  }, {
	    symbol: "\uD83D\uDC77"
	  }, {
	    symbol: "\uD83D\uDC82"
	  }, {
	    symbol: "\uD83D\uDD75"
	  }, {
	    symbol: "\u2695"
	  }, {
	    symbol: "\uD83C\uDF3E"
	  }, {
	    symbol: "\uD83C\uDF73"
	  }, {
	    symbol: "\uD83C\uDF93"
	  }, {
	    symbol: "\uD83C\uDFA4"
	  }, {
	    symbol: "\uD83C\uDFEB"
	  }, {
	    symbol: "\uD83C\uDFED"
	  }, {
	    symbol: "\uD83D\uDCBB"
	  }, {
	    symbol: "\uD83D\uDCBC"
	  }, {
	    symbol: "\uD83D\uDC69"
	  }, {
	    symbol: "\u2764"
	  }, {
	    symbol: "\uD83D\uDD27"
	  }, {
	    symbol: "\uD83D\uDD2C"
	  }, {
	    symbol: "\uD83C\uDFA8"
	  }, {
	    symbol: "\uD83D\uDE92"
	  }, {
	    symbol: "\uD83D\uDE80"
	  }, {
	    symbol: "\uD83D\uDC70"
	  }, {
	    symbol: "\uD83E\uDD35"
	  }, {
	    symbol: "\uD83D\uDC78"
	  }, {
	    symbol: "\uD83E\uDD34"
	  }, {
	    symbol: "\uD83E\uDDB8"
	  }, {
	    symbol: "\uD83E\uDDB9"
	  }, {
	    symbol: "\uD83E\uDD36"
	  }, {
	    symbol: "\uD83C\uDF85"
	  }, {
	    symbol: "\uD83E\uDDD9"
	  }, {
	    symbol: "\uD83E\uDDDD"
	  }, {
	    symbol: "\uD83E\uDDDB"
	  }, {
	    symbol: "\uD83E\uDDDF"
	  }, {
	    symbol: "\uD83E\uDDDE"
	  }, {
	    symbol: "\uD83E\uDDDC"
	  }, {
	    symbol: "\uD83E\uDDDA"
	  }, {
	    symbol: "\uD83D\uDC7C"
	  }, {
	    symbol: "\uD83E\uDD30"
	  }, {
	    symbol: "\uD83E\uDD31"
	  }, {
	    symbol: "\uD83D\uDE47"
	  }, {
	    symbol: "\uD83D\uDC81"
	  }, {
	    symbol: "\uD83D\uDE45"
	  }, {
	    symbol: "\uD83D\uDE46"
	  }, {
	    symbol: "\uD83D\uDE4B"
	  }, {
	    symbol: "\uD83E\uDD26"
	  }, {
	    symbol: "\uD83E\uDD37"
	  }, {
	    symbol: "\uD83D\uDE4E"
	  }, {
	    symbol: "\uD83D\uDE4D"
	  }, {
	    symbol: "\uD83D\uDC87"
	  }, {
	    symbol: "\uD83D\uDC86"
	  }, {
	    symbol: "\uD83E\uDDD6"
	  }, {
	    symbol: "\uD83D\uDC85"
	  }, {
	    symbol: "\uD83E\uDD33"
	  }, {
	    symbol: "\uD83D\uDC83"
	  }, {
	    symbol: "\uD83D\uDD7A"
	  }, {
	    symbol: "\uD83D\uDC6F"
	  }, {
	    symbol: "\uD83D\uDD74"
	  }, {
	    symbol: "\uD83D\uDEB6"
	  }, {
	    symbol: "\uD83C\uDFC3"
	  }, {
	    symbol: "\uD83D\uDC6B"
	  }, {
	    symbol: "\uD83D\uDC6D"
	  }, {
	    symbol: "\uD83D\uDC6C"
	  }, {
	    symbol: "\uD83D\uDC91"
	  }, {
	    symbol: "\uD83D\uDC8F"
	  }, {
	    symbol: "\uD83D\uDC6A"
	  }, {
	    symbol: "\uD83E\uDDF6"
	  }, {
	    symbol: "\uD83E\uDDF5"
	  }, {
	    symbol: "\uD83E\uDDE5"
	  }, {
	    symbol: "\uD83E\uDD7C"
	  }, {
	    symbol: "\uD83D\uDC5A"
	  }, {
	    symbol: "\uD83D\uDC55"
	  }, {
	    symbol: "\uD83D\uDC56"
	  }, {
	    symbol: "\uD83D\uDC54"
	  }, {
	    symbol: "\uD83D\uDC57"
	  }, {
	    symbol: "\uD83D\uDC59"
	  }, {
	    symbol: "\uD83D\uDC58"
	  }, {
	    symbol: "\uD83E\uDD7F"
	  }, {
	    symbol: "\uD83D\uDC60"
	  }, {
	    symbol: "\uD83D\uDC61"
	  }, {
	    symbol: "\uD83D\uDC62"
	  }, {
	    symbol: "\uD83D\uDC5E"
	  }, {
	    symbol: "\uD83D\uDC5F"
	  }, {
	    symbol: "\uD83E\uDD7E"
	  }, {
	    symbol: "\uD83E\uDDE6"
	  }, {
	    symbol: "\uD83E\uDDE4"
	  }, {
	    symbol: "\uD83E\uDDE3"
	  }, {
	    symbol: "\uD83C\uDFA9"
	  }, {
	    symbol: "\uD83E\uDDE2"
	  }, {
	    symbol: "\uD83D\uDC52"
	  }, {
	    symbol: "\uD83C\uDF93"
	  }, {
	    symbol: "\u26D1"
	  }, {
	    symbol: "\uD83D\uDC51"
	  }, {
	    symbol: "\uD83D\uDC8D"
	  }, {
	    symbol: "\uD83D\uDC5D"
	  }, {
	    symbol: "\uD83D\uDC5B"
	  }, {
	    symbol: "\uD83D\uDC5C"
	  }, {
	    symbol: "\uD83D\uDCBC"
	  }, {
	    symbol: "\uD83C\uDF92"
	  }, {
	    symbol: "\uD83E\uDDF3"
	  }, {
	    symbol: "\uD83D\uDC53"
	  }, {
	    symbol: "\uD83D\uDD76"
	  }, {
	    symbol: "\uD83E\uDD7D"
	  }, {
	    symbol: "\uD83C\uDF02"
	  }]
	}, {
	  id: 2,
	  code: 'ANIMALS',
	  showForWindows: true,
	  emoji: [{
	    symbol: "\uD83D\uDC36"
	  }, {
	    symbol: "\uD83D\uDC31"
	  }, {
	    symbol: "\uD83D\uDC2D"
	  }, {
	    symbol: "\uD83D\uDC39"
	  }, {
	    symbol: "\uD83D\uDC30"
	  }, {
	    symbol: "\uD83E\uDD8A"
	  }, {
	    symbol: "\uD83D\uDC3B"
	  }, {
	    symbol: "\uD83D\uDC3C"
	  }, {
	    symbol: "\uD83D\uDC28"
	  }, {
	    symbol: "\uD83D\uDC2F"
	  }, {
	    symbol: "\uD83E\uDD81"
	  }, {
	    symbol: "\uD83D\uDC2E"
	  }, {
	    symbol: "\uD83D\uDC37"
	  }, {
	    symbol: "\uD83D\uDC3D"
	  }, {
	    symbol: "\uD83D\uDC38"
	  }, {
	    symbol: "\uD83D\uDC35"
	  }, {
	    symbol: "\uD83D\uDE48"
	  }, {
	    symbol: "\uD83D\uDE49"
	  }, {
	    symbol: "\uD83D\uDE4A"
	  }, {
	    symbol: "\uD83D\uDC12"
	  }, {
	    symbol: "\uD83D\uDC14"
	  }, {
	    symbol: "\uD83D\uDC27"
	  }, {
	    symbol: "\uD83D\uDC26"
	  }, {
	    symbol: "\uD83D\uDC24"
	  }, {
	    symbol: "\uD83D\uDC23"
	  }, {
	    symbol: "\uD83D\uDC25"
	  }, {
	    symbol: "\uD83E\uDD86"
	  }, {
	    symbol: "\uD83E\uDD85"
	  }, {
	    symbol: "\uD83E\uDD89"
	  }, {
	    symbol: "\uD83E\uDD87"
	  }, {
	    symbol: "\uD83D\uDC3A"
	  }, {
	    symbol: "\uD83D\uDC17"
	  }, {
	    symbol: "\uD83D\uDC34"
	  }, {
	    symbol: "\uD83E\uDD84"
	  }, {
	    symbol: "\uD83D\uDC1D"
	  }, {
	    symbol: "\uD83D\uDC1B"
	  }, {
	    symbol: "\uD83E\uDD8B"
	  }, {
	    symbol: "\uD83D\uDC0C"
	  }, {
	    symbol: "\uD83D\uDC1E"
	  }, {
	    symbol: "\uD83D\uDC1C"
	  }, {
	    symbol: "\uD83E\uDD9F"
	  }, {
	    symbol: "\uD83E\uDD97"
	  }, {
	    symbol: "\uD83D\uDD77"
	  }, {
	    symbol: "\uD83D\uDD78"
	  }, {
	    symbol: "\uD83E\uDD82"
	  }, {
	    symbol: "\uD83D\uDC22"
	  }, {
	    symbol: "\uD83D\uDC0D"
	  }, {
	    symbol: "\uD83E\uDD8E"
	  }, {
	    symbol: "\uD83E\uDD96"
	  }, {
	    symbol: "\uD83E\uDD95"
	  }, {
	    symbol: "\uD83D\uDC19"
	  }, {
	    symbol: "\uD83E\uDD91"
	  }, {
	    symbol: "\uD83E\uDD90"
	  }, {
	    symbol: "\uD83E\uDD9E"
	  }, {
	    symbol: "\uD83E\uDD80"
	  }, {
	    symbol: "\uD83D\uDC21"
	  }, {
	    symbol: "\uD83D\uDC20"
	  }, {
	    symbol: "\uD83D\uDC1F"
	  }, {
	    symbol: "\uD83D\uDC2C"
	  }, {
	    symbol: "\uD83D\uDC33"
	  }, {
	    symbol: "\uD83D\uDC0B"
	  }, {
	    symbol: "\uD83E\uDD88"
	  }, {
	    symbol: "\uD83D\uDC0A"
	  }, {
	    symbol: "\uD83D\uDC05"
	  }, {
	    symbol: "\uD83D\uDC06"
	  }, {
	    symbol: "\uD83E\uDD93"
	  }, {
	    symbol: "\uD83E\uDD8D"
	  }, {
	    symbol: "\uD83D\uDC18"
	  }, {
	    symbol: "\uD83E\uDD9B"
	  }, {
	    symbol: "\uD83E\uDD8F"
	  }, {
	    symbol: "\uD83D\uDC2A"
	  }, {
	    symbol: "\uD83D\uDC2B"
	  }, {
	    symbol: "\uD83E\uDD92"
	  }, {
	    symbol: "\uD83E\uDD98"
	  }, {
	    symbol: "\uD83D\uDC03"
	  }, {
	    symbol: "\uD83D\uDC02"
	  }, {
	    symbol: "\uD83D\uDC04"
	  }, {
	    symbol: "\uD83D\uDC0E"
	  }, {
	    symbol: "\uD83D\uDC16"
	  }, {
	    symbol: "\uD83D\uDC0F"
	  }, {
	    symbol: "\uD83D\uDC11"
	  }, {
	    symbol: "\uD83E\uDD99"
	  }, {
	    symbol: "\uD83D\uDC10"
	  }, {
	    symbol: "\uD83E\uDD8C"
	  }, {
	    symbol: "\uD83D\uDC15"
	  }, {
	    symbol: "\uD83D\uDC29"
	  }, {
	    symbol: "\uD83D\uDC08"
	  }, {
	    symbol: "\uD83D\uDC13"
	  }, {
	    symbol: "\uD83E\uDD83"
	  }, {
	    symbol: "\uD83E\uDD9A"
	  }, {
	    symbol: "\uD83E\uDD9C"
	  }, {
	    symbol: "\uD83E\uDDA2"
	  }, {
	    symbol: "\uD83D\uDD4A"
	  }, {
	    symbol: "\uD83D\uDC07"
	  }, {
	    symbol: "\uD83E\uDD9D"
	  }, {
	    symbol: "\uD83E\uDDA1"
	  }, {
	    symbol: "\uD83D\uDC01"
	  }, {
	    symbol: "\uD83D\uDC00"
	  }, {
	    symbol: "\uD83D\uDC3F"
	  }, {
	    symbol: "\uD83E\uDD94"
	  }, {
	    symbol: "\uD83D\uDC3E"
	  }, {
	    symbol: "\uD83D\uDC09"
	  }, {
	    symbol: "\uD83D\uDC32"
	  }, {
	    symbol: "\uD83C\uDF35"
	  }, {
	    symbol: "\uD83C\uDF84"
	  }, {
	    symbol: "\uD83C\uDF32"
	  }, {
	    symbol: "\uD83C\uDF33"
	  }, {
	    symbol: "\uD83C\uDF34"
	  }, {
	    symbol: "\uD83C\uDF31"
	  }, {
	    symbol: "\uD83C\uDF3F"
	  }, {
	    symbol: "\u2618"
	  }, {
	    symbol: "\uD83C\uDF40"
	  }, {
	    symbol: "\uD83C\uDF8D"
	  }, {
	    symbol: "\uD83C\uDF8B"
	  }, {
	    symbol: "\uD83C\uDF43"
	  }, {
	    symbol: "\uD83C\uDF42"
	  }, {
	    symbol: "\uD83C\uDF41"
	  }, {
	    symbol: "\uD83C\uDF44"
	  }, {
	    symbol: "\uD83D\uDC1A"
	  }, {
	    symbol: "\uD83C\uDF3E"
	  }, {
	    symbol: "\uD83D\uDC90"
	  }, {
	    symbol: "\uD83C\uDF37"
	  }, {
	    symbol: "\uD83C\uDF39"
	  }, {
	    symbol: "\uD83E\uDD40"
	  }, {
	    symbol: "\uD83C\uDF3A"
	  }, {
	    symbol: "\uD83C\uDF38"
	  }, {
	    symbol: "\uD83C\uDF3C"
	  }, {
	    symbol: "\uD83C\uDF3B"
	  }, {
	    symbol: "\uD83C\uDF1E"
	  }, {
	    symbol: "\uD83C\uDF1D"
	  }, {
	    symbol: "\uD83C\uDF1B"
	  }, {
	    symbol: "\uD83C\uDF1C"
	  }, {
	    symbol: "\uD83C\uDF1A"
	  }, {
	    symbol: "\uD83C\uDF15"
	  }, {
	    symbol: "\uD83C\uDF16"
	  }, {
	    symbol: "\uD83C\uDF17"
	  }, {
	    symbol: "\uD83C\uDF18"
	  }, {
	    symbol: "\uD83C\uDF11"
	  }, {
	    symbol: "\uD83C\uDF12"
	  }, {
	    symbol: "\uD83C\uDF13"
	  }, {
	    symbol: "\uD83C\uDF14"
	  }, {
	    symbol: "\uD83C\uDF19"
	  }, {
	    symbol: "\uD83C\uDF0E"
	  }, {
	    symbol: "\uD83C\uDF0D"
	  }, {
	    symbol: "\uD83C\uDF0F"
	  }, {
	    symbol: "\uD83D\uDCAB"
	  }, {
	    symbol: "\u2B50"
	  }, {
	    symbol: "\uD83C\uDF1F"
	  }, {
	    symbol: "\u2728"
	  }, {
	    symbol: "\u26A1"
	  }, {
	    symbol: "\u2604"
	  }, {
	    symbol: "\uD83D\uDCA5"
	  }, {
	    symbol: "\uD83D\uDD25"
	  }, {
	    symbol: "\uD83C\uDF2A"
	  }, {
	    symbol: "\uD83C\uDF08"
	  }, {
	    symbol: "\u2600"
	  }, {
	    symbol: "\uD83C\uDF24"
	  }, {
	    symbol: "\uD83C\uDF25"
	  }, {
	    symbol: "\uD83C\uDF26"
	  }, {
	    symbol: "\uD83C\uDF27"
	  }, {
	    symbol: "\uD83C\uDF29"
	  }, {
	    symbol: "\uD83C\uDF28"
	  }, {
	    symbol: "\u2744"
	  }, {
	    symbol: "\u2603"
	  }, {
	    symbol: "\u26C4"
	  }, {
	    symbol: "\uD83C\uDF2C"
	  }, {
	    symbol: "\uD83D\uDCA8"
	  }, {
	    symbol: "\uD83D\uDCA7"
	  }, {
	    symbol: "\uD83D\uDCA6"
	  }, {
	    symbol: "\u2614"
	  }, {
	    symbol: "\u2602"
	  }, {
	    symbol: "\uD83C\uDF0A"
	  }, {
	    symbol: "\uD83C\uDF2B"
	  }]
	}, {
	  id: 3,
	  code: 'FOOD',
	  showForWindows: true,
	  emoji: [{
	    symbol: "\uD83C\uDF4F"
	  }, {
	    symbol: "\uD83C\uDF4E"
	  }, {
	    symbol: "\uD83C\uDF50"
	  }, {
	    symbol: "\uD83C\uDF4A"
	  }, {
	    symbol: "\uD83C\uDF4B"
	  }, {
	    symbol: "\uD83C\uDF4C"
	  }, {
	    symbol: "\uD83C\uDF49"
	  }, {
	    symbol: "\uD83C\uDF47"
	  }, {
	    symbol: "\uD83C\uDF53"
	  }, {
	    symbol: "\uD83C\uDF48"
	  }, {
	    symbol: "\uD83C\uDF52"
	  }, {
	    symbol: "\uD83C\uDF51"
	  }, {
	    symbol: "\uD83E\uDD6D"
	  }, {
	    symbol: "\uD83C\uDF4D"
	  }, {
	    symbol: "\uD83E\uDD65"
	  }, {
	    symbol: "\uD83E\uDD5D"
	  }, {
	    symbol: "\uD83C\uDF45"
	  }, {
	    symbol: "\uD83C\uDF46"
	  }, {
	    symbol: "\uD83E\uDD51"
	  }, {
	    symbol: "\uD83E\uDD66"
	  }, {
	    symbol: "\uD83E\uDD6C"
	  }, {
	    symbol: "\uD83E\uDD52"
	  }, {
	    symbol: "\uD83C\uDF36"
	  }, {
	    symbol: "\uD83C\uDF3D"
	  }, {
	    symbol: "\uD83E\uDD55"
	  }, {
	    symbol: "\uD83E\uDD54"
	  }, {
	    symbol: "\uD83C\uDF60"
	  }, {
	    symbol: "\uD83E\uDD50"
	  }, {
	    symbol: "\uD83E\uDD6F"
	  }, {
	    symbol: "\uD83C\uDF5E"
	  }, {
	    symbol: "\uD83E\uDD56"
	  }, {
	    symbol: "\uD83E\uDD68"
	  }, {
	    symbol: "\uD83E\uDDC0"
	  }, {
	    symbol: "\uD83E\uDD5A"
	  }, {
	    symbol: "\uD83C\uDF73"
	  }, {
	    symbol: "\uD83E\uDD5E"
	  }, {
	    symbol: "\uD83E\uDD53"
	  }, {
	    symbol: "\uD83E\uDD69"
	  }, {
	    symbol: "\uD83C\uDF57"
	  }, {
	    symbol: "\uD83C\uDF56"
	  }, {
	    symbol: "\uD83E\uDDB4"
	  }, {
	    symbol: "\uD83C\uDF2D"
	  }, {
	    symbol: "\uD83C\uDF54"
	  }, {
	    symbol: "\uD83C\uDF5F"
	  }, {
	    symbol: "\uD83C\uDF55"
	  }, {
	    symbol: "\uD83E\uDD6A"
	  }, {
	    symbol: "\uD83E\uDD59"
	  }, {
	    symbol: "\uD83C\uDF2E"
	  }, {
	    symbol: "\uD83C\uDF2F"
	  }, {
	    symbol: "\uD83E\uDD57"
	  }, {
	    symbol: "\uD83E\uDD58"
	  }, {
	    symbol: "\uD83E\uDD6B"
	  }, {
	    symbol: "\uD83C\uDF5D"
	  }, {
	    symbol: "\uD83C\uDF5C"
	  }, {
	    symbol: "\uD83C\uDF72"
	  }, {
	    symbol: "\uD83C\uDF5B"
	  }, {
	    symbol: "\uD83C\uDF63"
	  }, {
	    symbol: "\uD83C\uDF71"
	  }, {
	    symbol: "\uD83E\uDD5F"
	  }, {
	    symbol: "\uD83C\uDF64"
	  }, {
	    symbol: "\uD83C\uDF59"
	  }, {
	    symbol: "\uD83C\uDF5A"
	  }, {
	    symbol: "\uD83C\uDF58"
	  }, {
	    symbol: "\uD83C\uDF65"
	  }, {
	    symbol: "\uD83E\uDD60"
	  }, {
	    symbol: "\uD83E\uDD6E"
	  }, {
	    symbol: "\uD83C\uDF62"
	  }, {
	    symbol: "\uD83C\uDF61"
	  }, {
	    symbol: "\uD83C\uDF67"
	  }, {
	    symbol: "\uD83C\uDF68"
	  }, {
	    symbol: "\uD83C\uDF66"
	  }, {
	    symbol: "\uD83E\uDD67"
	  }, {
	    symbol: "\uD83E\uDDC1"
	  }, {
	    symbol: "\uD83C\uDF70"
	  }, {
	    symbol: "\uD83C\uDF82"
	  }, {
	    symbol: "\uD83C\uDF6E"
	  }, {
	    symbol: "\uD83C\uDF6D"
	  }, {
	    symbol: "\uD83C\uDF6C"
	  }, {
	    symbol: "\uD83C\uDF6B"
	  }, {
	    symbol: "\uD83C\uDF7F"
	  }, {
	    symbol: "\uD83C\uDF69"
	  }, {
	    symbol: "\uD83C\uDF6A"
	  }, {
	    symbol: "\uD83C\uDF30"
	  }, {
	    symbol: "\uD83E\uDD5C"
	  }, {
	    symbol: "\uD83C\uDF6F"
	  }, {
	    symbol: "\uD83E\uDD5B"
	  }, {
	    symbol: "\uD83C\uDF7C"
	  }, {
	    symbol: "\u2615"
	  }, {
	    symbol: "\uD83C\uDF75"
	  }, {
	    symbol: "\uD83E\uDD64"
	  }, {
	    symbol: "\uD83C\uDF76"
	  }, {
	    symbol: "\uD83C\uDF7A"
	  }, {
	    symbol: "\uD83C\uDF7B"
	  }, {
	    symbol: "\uD83E\uDD42"
	  }, {
	    symbol: "\uD83C\uDF77"
	  }, {
	    symbol: "\uD83E\uDD43"
	  }, {
	    symbol: "\uD83C\uDF78"
	  }, {
	    symbol: "\uD83C\uDF79"
	  }, {
	    symbol: "\uD83C\uDF7E"
	  }, {
	    symbol: "\uD83E\uDD44"
	  }, {
	    symbol: "\uD83C\uDF74"
	  }, {
	    symbol: "\uD83C\uDF7D"
	  }, {
	    symbol: "\uD83E\uDD63"
	  }, {
	    symbol: "\uD83E\uDD61"
	  }, {
	    symbol: "\uD83E\uDD62"
	  }, {
	    symbol: "\uD83E\uDDC2"
	  }]
	}, {
	  id: 4,
	  code: 'HOBBY',
	  showForWindows: true,
	  emoji: [{
	    symbol: "\u26BD"
	  }, {
	    symbol: "\uD83C\uDFC0"
	  }, {
	    symbol: "\uD83C\uDFC8"
	  }, {
	    symbol: "\u26BE"
	  }, {
	    symbol: "\uD83E\uDD4E"
	  }, {
	    symbol: "\uD83C\uDFBE"
	  }, {
	    symbol: "\uD83C\uDFD0"
	  }, {
	    symbol: "\uD83C\uDFC9"
	  }, {
	    symbol: "\uD83E\uDD4F"
	  }, {
	    symbol: "\uD83C\uDFB1"
	  }, {
	    symbol: "\uD83C\uDFD3"
	  }, {
	    symbol: "\uD83C\uDFF8"
	  }, {
	    symbol: "\uD83C\uDFD2"
	  }, {
	    symbol: "\uD83C\uDFD1"
	  }, {
	    symbol: "\uD83E\uDD4D"
	  }, {
	    symbol: "\uD83C\uDFCF"
	  }, {
	    symbol: "\uD83E\uDD45"
	  }, {
	    symbol: "\u26F3"
	  }, {
	    symbol: "\uD83C\uDFF9"
	  }, {
	    symbol: "\uD83C\uDFA3"
	  }, {
	    symbol: "\uD83E\uDD4A"
	  }, {
	    symbol: "\uD83E\uDD4B"
	  }, {
	    symbol: "\uD83C\uDFBD"
	  }, {
	    symbol: "\uD83D\uDEF9"
	  }, {
	    symbol: "\uD83D\uDEF7"
	  }, {
	    symbol: "\u26F8"
	  }, {
	    symbol: "\uD83E\uDD4C"
	  }, {
	    symbol: "\uD83C\uDFBF"
	  }, {
	    symbol: "\u26F7"
	  }, {
	    symbol: "\uD83C\uDFC2"
	  }, {
	    symbol: "\uD83C\uDFCB"
	  }, {
	    symbol: "\uD83E\uDD3C"
	  }, {
	    symbol: "\uD83E\uDD38"
	  }, {
	    symbol: "\u26F9"
	  }, {
	    symbol: "\uD83E\uDD3A"
	  }, {
	    symbol: "\uD83E\uDD3E"
	  }, {
	    symbol: "\uD83C\uDFCC"
	  }, {
	    symbol: "\uD83C\uDFC7"
	  }, {
	    symbol: "\uD83E\uDDD8"
	  }, {
	    symbol: "\uD83C\uDFC4"
	  }, {
	    symbol: "\uD83C\uDFCA"
	  }, {
	    symbol: "\uD83E\uDD3D"
	  }, {
	    symbol: "\uD83D\uDEA3"
	  }, {
	    symbol: "\uD83E\uDDD7"
	  }, {
	    symbol: "\uD83D\uDEB5"
	  }, {
	    symbol: "\uD83D\uDEB4"
	  }, {
	    symbol: "\uD83C\uDFC6"
	  }, {
	    symbol: "\uD83E\uDD47"
	  }, {
	    symbol: "\uD83E\uDD48"
	  }, {
	    symbol: "\uD83E\uDD49"
	  }, {
	    symbol: "\uD83C\uDFC5"
	  }, {
	    symbol: "\uD83C\uDF96"
	  }, {
	    symbol: "\uD83C\uDFF5"
	  }, {
	    symbol: "\uD83C\uDF97"
	  }, {
	    symbol: "\uD83C\uDFAB"
	  }, {
	    symbol: "\uD83C\uDF9F"
	  }, {
	    symbol: "\uD83C\uDFAA"
	  }, {
	    symbol: "\uD83E\uDD39"
	  }, {
	    symbol: "\uD83C\uDFAD"
	  }, {
	    symbol: "\uD83C\uDFA8"
	  }, {
	    symbol: "\uD83C\uDFAC"
	  }, {
	    symbol: "\uD83C\uDFA4"
	  }, {
	    symbol: "\uD83C\uDFA7"
	  }, {
	    symbol: "\uD83C\uDFBC"
	  }, {
	    symbol: "\uD83C\uDFB9"
	  }, {
	    symbol: "\uD83E\uDD41"
	  }, {
	    symbol: "\uD83C\uDFB7"
	  }, {
	    symbol: "\uD83C\uDFBA"
	  }, {
	    symbol: "\uD83C\uDFB8"
	  }, {
	    symbol: "\uD83C\uDFBB"
	  }, {
	    symbol: "\uD83C\uDFB2"
	  }, {
	    symbol: "\u265F"
	  }, {
	    symbol: "\uD83C\uDFAF"
	  }, {
	    symbol: "\uD83C\uDFB3"
	  }, {
	    symbol: "\uD83C\uDFAE"
	  }, {
	    symbol: "\uD83C\uDFB0"
	  }, {
	    symbol: "\uD83E\uDDE9"
	  }]
	}, {
	  id: 5,
	  code: 'TRAVEL',
	  showForWindows: true,
	  emoji: [{
	    symbol: "\uD83D\uDE97"
	  }, {
	    symbol: "\uD83D\uDE95"
	  }, {
	    symbol: "\uD83D\uDE99"
	  }, {
	    symbol: "\uD83D\uDE8C"
	  }, {
	    symbol: "\uD83D\uDE8E"
	  }, {
	    symbol: "\uD83C\uDFCE"
	  }, {
	    symbol: "\uD83D\uDE93"
	  }, {
	    symbol: "\uD83D\uDE91"
	  }, {
	    symbol: "\uD83D\uDE92"
	  }, {
	    symbol: "\uD83D\uDE90"
	  }, {
	    symbol: "\uD83D\uDE9A"
	  }, {
	    symbol: "\uD83D\uDE9B"
	  }, {
	    symbol: "\uD83D\uDE9C"
	  }, {
	    symbol: "\uD83D\uDEF4"
	  }, {
	    symbol: "\uD83D\uDEB2"
	  }, {
	    symbol: "\uD83D\uDEF5"
	  }, {
	    symbol: "\uD83C\uDFCD"
	  }, {
	    symbol: "\uD83D\uDEA8"
	  }, {
	    symbol: "\uD83D\uDE94"
	  }, {
	    symbol: "\uD83D\uDE8D"
	  }, {
	    symbol: "\uD83D\uDE98"
	  }, {
	    symbol: "\uD83D\uDE96"
	  }, {
	    symbol: "\uD83D\uDEA1"
	  }, {
	    symbol: "\uD83D\uDEA0"
	  }, {
	    symbol: "\uD83D\uDE9F"
	  }, {
	    symbol: "\uD83D\uDE83"
	  }, {
	    symbol: "\uD83D\uDE8B"
	  }, {
	    symbol: "\uD83D\uDE9E"
	  }, {
	    symbol: "\uD83D\uDE9D"
	  }, {
	    symbol: "\uD83D\uDE84"
	  }, {
	    symbol: "\uD83D\uDE85"
	  }, {
	    symbol: "\uD83D\uDE88"
	  }, {
	    symbol: "\uD83D\uDE82"
	  }, {
	    symbol: "\uD83D\uDE86"
	  }, {
	    symbol: "\uD83D\uDE87"
	  }, {
	    symbol: "\uD83D\uDE8A"
	  }, {
	    symbol: "\uD83D\uDE89"
	  }, {
	    symbol: "\u2708"
	  }, {
	    symbol: "\uD83D\uDEEB"
	  }, {
	    symbol: "\uD83D\uDEEC"
	  }, {
	    symbol: "\uD83D\uDEE9"
	  }, {
	    symbol: "\uD83D\uDCBA"
	  }, {
	    symbol: "\uD83D\uDEF0"
	  }, {
	    symbol: "\uD83D\uDE80"
	  }, {
	    symbol: "\uD83D\uDEF8"
	  }, {
	    symbol: "\uD83D\uDE81"
	  }, {
	    symbol: "\uD83D\uDEF6"
	  }, {
	    symbol: "\u26F5"
	  }, {
	    symbol: "\uD83D\uDEA4"
	  }, {
	    symbol: "\uD83D\uDEE5"
	  }, {
	    symbol: "\uD83D\uDEF3"
	  }, {
	    symbol: "\u26F4"
	  }, {
	    symbol: "\uD83D\uDEA2"
	  }, {
	    symbol: "\u2693"
	  }, {
	    symbol: "\u26FD"
	  }, {
	    symbol: "\uD83D\uDEA7"
	  }, {
	    symbol: "\uD83D\uDEA6"
	  }, {
	    symbol: "\uD83D\uDEA5"
	  }, {
	    symbol: "\uD83D\uDE8F"
	  }, {
	    symbol: "\uD83D\uDDFA"
	  }, {
	    symbol: "\uD83D\uDDFF"
	  }, {
	    symbol: "\uD83D\uDDFD"
	  }, {
	    symbol: "\uD83D\uDDFC"
	  }, {
	    symbol: "\uD83C\uDFF0"
	  }, {
	    symbol: "\uD83C\uDFEF"
	  }, {
	    symbol: "\uD83C\uDFDF"
	  }, {
	    symbol: "\uD83C\uDFA1"
	  }, {
	    symbol: "\uD83C\uDFA2"
	  }, {
	    symbol: "\uD83C\uDFA0"
	  }, {
	    symbol: "\u26F2"
	  }, {
	    symbol: "\u26F1"
	  }, {
	    symbol: "\uD83C\uDFD6"
	  }, {
	    symbol: "\uD83C\uDFDD"
	  }, {
	    symbol: "\uD83C\uDFDC"
	  }, {
	    symbol: "\uD83C\uDF0B"
	  }, {
	    symbol: "\u26F0"
	  }, {
	    symbol: "\uD83C\uDFD4"
	  }, {
	    symbol: "\uD83D\uDDFB"
	  }, {
	    symbol: "\uD83C\uDFD5"
	  }, {
	    symbol: "\u26FA"
	  }, {
	    symbol: "\uD83C\uDFE0"
	  }, {
	    symbol: "\uD83C\uDFE1"
	  }, {
	    symbol: "\uD83C\uDFD8"
	  }, {
	    symbol: "\uD83C\uDFDA"
	  }, {
	    symbol: "\uD83C\uDFD7"
	  }, {
	    symbol: "\uD83C\uDFED"
	  }, {
	    symbol: "\uD83C\uDFE2"
	  }, {
	    symbol: "\uD83C\uDFEC"
	  }, {
	    symbol: "\uD83C\uDFE3"
	  }, {
	    symbol: "\uD83C\uDFE4"
	  }, {
	    symbol: "\uD83C\uDFE5"
	  }, {
	    symbol: "\uD83C\uDFE6"
	  }, {
	    symbol: "\uD83C\uDFE8"
	  }, {
	    symbol: "\uD83C\uDFEA"
	  }, {
	    symbol: "\uD83C\uDFEB"
	  }, {
	    symbol: "\uD83C\uDFE9"
	  }, {
	    symbol: "\uD83D\uDC92"
	  }, {
	    symbol: "\uD83C\uDFDB"
	  }, {
	    symbol: "\u26EA"
	  }, {
	    symbol: "\uD83D\uDD4C"
	  }, {
	    symbol: "\uD83D\uDD4D"
	  }, {
	    symbol: "\uD83D\uDD4B"
	  }, {
	    symbol: "\u26E9"
	  }, {
	    symbol: "\uD83D\uDEE4"
	  }, {
	    symbol: "\uD83D\uDEE3"
	  }, {
	    symbol: "\uD83D\uDDFE"
	  }, {
	    symbol: "\uD83C\uDF91"
	  }, {
	    symbol: "\uD83C\uDFDE"
	  }, {
	    symbol: "\uD83C\uDF05"
	  }, {
	    symbol: "\uD83C\uDF04"
	  }, {
	    symbol: "\uD83C\uDF20"
	  }, {
	    symbol: "\uD83C\uDF87"
	  }, {
	    symbol: "\uD83C\uDF86"
	  }, {
	    symbol: "\uD83C\uDF07"
	  }, {
	    symbol: "\uD83C\uDF06"
	  }, {
	    symbol: "\uD83C\uDFD9"
	  }, {
	    symbol: "\uD83C\uDF03"
	  }, {
	    symbol: "\uD83C\uDF0C"
	  }, {
	    symbol: "\uD83C\uDF09"
	  }, {
	    symbol: "\uD83C\uDF01"
	  }]
	}, {
	  id: 6,
	  code: 'OBJECTS',
	  showForWindows: true,
	  emoji: [{
	    symbol: "\u231A"
	  }, {
	    symbol: "\uD83D\uDCF1"
	  }, {
	    symbol: "\uD83D\uDCF2"
	  }, {
	    symbol: "\uD83D\uDCBB"
	  }, {
	    symbol: "\u2328"
	  }, {
	    symbol: "\uD83D\uDDA5"
	  }, {
	    symbol: "\uD83D\uDDA8"
	  }, {
	    symbol: "\uD83D\uDDB1"
	  }, {
	    symbol: "\uD83D\uDDB2"
	  }, {
	    symbol: "\uD83D\uDD79"
	  }, {
	    symbol: "\uD83D\uDDDC"
	  }, {
	    symbol: "\uD83D\uDCBD"
	  }, {
	    symbol: "\uD83D\uDCBE"
	  }, {
	    symbol: "\uD83D\uDCBF"
	  }, {
	    symbol: "\uD83D\uDCC0"
	  }, {
	    symbol: "\uD83D\uDCFC"
	  }, {
	    symbol: "\uD83D\uDCF7"
	  }, {
	    symbol: "\uD83D\uDCF8"
	  }, {
	    symbol: "\uD83D\uDCF9"
	  }, {
	    symbol: "\uD83C\uDFA5"
	  }, {
	    symbol: "\uD83D\uDCFD"
	  }, {
	    symbol: "\uD83C\uDF9E"
	  }, {
	    symbol: "\uD83D\uDCDE"
	  }, {
	    symbol: "\u260E"
	  }, {
	    symbol: "\uD83D\uDCDF"
	  }, {
	    symbol: "\uD83D\uDCE0"
	  }, {
	    symbol: "\uD83D\uDCFA"
	  }, {
	    symbol: "\uD83D\uDCFB"
	  }, {
	    symbol: "\uD83C\uDF99"
	  }, {
	    symbol: "\uD83C\uDF9A"
	  }, {
	    symbol: "\uD83C\uDF9B"
	  }, {
	    symbol: "\uD83E\uDDED"
	  }, {
	    symbol: "\u23F1"
	  }, {
	    symbol: "\u23F2"
	  }, {
	    symbol: "\u23F0"
	  }, {
	    symbol: "\uD83D\uDD70"
	  }, {
	    symbol: "\u231B"
	  }, {
	    symbol: "\u23F3"
	  }, {
	    symbol: "\uD83D\uDCE1"
	  }, {
	    symbol: "\uD83D\uDD0B"
	  }, {
	    symbol: "\uD83D\uDD0C"
	  }, {
	    symbol: "\uD83D\uDCA1"
	  }, {
	    symbol: "\uD83D\uDD26"
	  }, {
	    symbol: "\uD83D\uDD6F"
	  }, {
	    symbol: "\uD83E\uDDEF"
	  }, {
	    symbol: "\uD83D\uDEE2"
	  }, {
	    symbol: "\uD83D\uDCB8"
	  }, {
	    symbol: "\uD83D\uDCB5"
	  }, {
	    symbol: "\uD83D\uDCB4"
	  }, {
	    symbol: "\uD83D\uDCB6"
	  }, {
	    symbol: "\uD83D\uDCB7"
	  }, {
	    symbol: "\uD83D\uDCB0"
	  }, {
	    symbol: "\uD83D\uDCB3"
	  }, {
	    symbol: "\uD83D\uDC8E"
	  }, {
	    symbol: "\u2696"
	  }, {
	    symbol: "\uD83E\uDDF0"
	  }, {
	    symbol: "\uD83D\uDD27"
	  }, {
	    symbol: "\uD83D\uDD28"
	  }, {
	    symbol: "\u2692"
	  }, {
	    symbol: "\uD83D\uDEE0"
	  }, {
	    symbol: "\u26CF"
	  }, {
	    symbol: "\uD83D\uDD29"
	  }, {
	    symbol: "\u2699"
	  }, {
	    symbol: "\uD83E\uDDF1"
	  }, {
	    symbol: "\u26D3"
	  }, {
	    symbol: "\uD83E\uDDF2"
	  }, {
	    symbol: "\uD83D\uDD2B"
	  }, {
	    symbol: "\uD83D\uDCA3"
	  }, {
	    symbol: "\uD83E\uDDE8"
	  }, {
	    symbol: "\uD83D\uDD2A"
	  }, {
	    symbol: "\uD83D\uDDE1"
	  }, {
	    symbol: "\u2694"
	  }, {
	    symbol: "\uD83D\uDEE1"
	  }, {
	    symbol: "\uD83D\uDEAC"
	  }, {
	    symbol: "\u26B0"
	  }, {
	    symbol: "\u26B1"
	  }, {
	    symbol: "\uD83C\uDFFA"
	  }, {
	    symbol: "\uD83D\uDD2E"
	  }, {
	    symbol: "\uD83D\uDCFF"
	  }, {
	    symbol: "\uD83E\uDDFF"
	  }, {
	    symbol: "\uD83D\uDC88"
	  }, {
	    symbol: "\u2697"
	  }, {
	    symbol: "\uD83D\uDD2D"
	  }, {
	    symbol: "\uD83D\uDD2C"
	  }, {
	    symbol: "\uD83D\uDD73"
	  }, {
	    symbol: "\uD83D\uDC8A"
	  }, {
	    symbol: "\uD83D\uDC89"
	  }, {
	    symbol: "\uD83E\uDDEC"
	  }, {
	    symbol: "\uD83E\uDDA0"
	  }, {
	    symbol: "\uD83E\uDDEB"
	  }, {
	    symbol: "\uD83E\uDDEA"
	  }, {
	    symbol: "\uD83C\uDF21"
	  }, {
	    symbol: "\uD83E\uDDF9"
	  }, {
	    symbol: "\uD83E\uDDFA"
	  }, {
	    symbol: "\uD83E\uDDFB"
	  }, {
	    symbol: "\uD83D\uDEBD"
	  }, {
	    symbol: "\uD83D\uDEB0"
	  }, {
	    symbol: "\uD83D\uDEBF"
	  }, {
	    symbol: "\uD83D\uDEC1"
	  }, {
	    symbol: "\uD83D\uDEC0"
	  }, {
	    symbol: "\uD83E\uDDFC"
	  }, {
	    symbol: "\uD83E\uDDFD"
	  }, {
	    symbol: "\uD83E\uDDF4"
	  }, {
	    symbol: "\uD83D\uDECE"
	  }, {
	    symbol: "\uD83D\uDD11"
	  }, {
	    symbol: "\uD83D\uDDDD"
	  }, {
	    symbol: "\uD83D\uDEAA"
	  }, {
	    symbol: "\uD83D\uDECB"
	  }, {
	    symbol: "\uD83D\uDECF"
	  }, {
	    symbol: "\uD83D\uDECC"
	  }, {
	    symbol: "\uD83E\uDDF8"
	  }, {
	    symbol: "\uD83D\uDDBC"
	  }, {
	    symbol: "\uD83D\uDECD"
	  }, {
	    symbol: "\uD83D\uDED2"
	  }, {
	    symbol: "\uD83C\uDF81"
	  }, {
	    symbol: "\uD83C\uDF88"
	  }, {
	    symbol: "\uD83C\uDF8F"
	  }, {
	    symbol: "\uD83C\uDF80"
	  }, {
	    symbol: "\uD83C\uDF8A"
	  }, {
	    symbol: "\uD83C\uDF89"
	  }, {
	    symbol: "\uD83C\uDF8E"
	  }, {
	    symbol: "\uD83C\uDFEE"
	  }, {
	    symbol: "\uD83C\uDF90"
	  }, {
	    symbol: "\uD83E\uDDE7"
	  }, {
	    symbol: "\u2709"
	  }, {
	    symbol: "\uD83D\uDCE9"
	  }, {
	    symbol: "\uD83D\uDCE8"
	  }, {
	    symbol: "\uD83D\uDCE7"
	  }, {
	    symbol: "\uD83D\uDC8C"
	  }, {
	    symbol: "\uD83D\uDCE5"
	  }, {
	    symbol: "\uD83D\uDCE4"
	  }, {
	    symbol: "\uD83D\uDCE6"
	  }, {
	    symbol: "\uD83C\uDFF7"
	  }, {
	    symbol: "\uD83D\uDCEA"
	  }, {
	    symbol: "\uD83D\uDCEB"
	  }, {
	    symbol: "\uD83D\uDCEC"
	  }, {
	    symbol: "\uD83D\uDCED"
	  }, {
	    symbol: "\uD83D\uDCEE"
	  }, {
	    symbol: "\uD83D\uDCEF"
	  }, {
	    symbol: "\uD83D\uDCDC"
	  }, {
	    symbol: "\uD83D\uDCC3"
	  }, {
	    symbol: "\uD83D\uDCC4"
	  }, {
	    symbol: "\uD83D\uDCD1"
	  }, {
	    symbol: "\uD83E\uDDFE"
	  }, {
	    symbol: "\uD83D\uDCCA"
	  }, {
	    symbol: "\uD83D\uDCC8"
	  }, {
	    symbol: "\uD83D\uDCC9"
	  }, {
	    symbol: "\uD83D\uDDD2"
	  }, {
	    symbol: "\uD83D\uDDD3"
	  }, {
	    symbol: "\uD83D\uDCC6"
	  }, {
	    symbol: "\uD83D\uDCC5"
	  }, {
	    symbol: "\uD83D\uDDD1"
	  }, {
	    symbol: "\uD83D\uDCC7"
	  }, {
	    symbol: "\uD83D\uDDC3"
	  }, {
	    symbol: "\uD83D\uDDF3"
	  }, {
	    symbol: "\uD83D\uDDC4"
	  }, {
	    symbol: "\uD83D\uDCCB"
	  }, {
	    symbol: "\uD83D\uDCC1"
	  }, {
	    symbol: "\uD83D\uDCC2"
	  }, {
	    symbol: "\uD83D\uDDC2"
	  }, {
	    symbol: "\uD83D\uDDDE"
	  }, {
	    symbol: "\uD83D\uDCF0"
	  }, {
	    symbol: "\uD83D\uDCD3"
	  }, {
	    symbol: "\uD83D\uDCD4"
	  }, {
	    symbol: "\uD83D\uDCD2"
	  }, {
	    symbol: "\uD83D\uDCD5"
	  }, {
	    symbol: "\uD83D\uDCD7"
	  }, {
	    symbol: "\uD83D\uDCD8"
	  }, {
	    symbol: "\uD83D\uDCD9"
	  }, {
	    symbol: "\uD83D\uDCDA"
	  }, {
	    symbol: "\uD83D\uDCD6"
	  }, {
	    symbol: "\uD83D\uDD16"
	  }, {
	    symbol: "\uD83E\uDDF7"
	  }, {
	    symbol: "\uD83D\uDD17"
	  }, {
	    symbol: "\uD83D\uDCCE"
	  }, {
	    symbol: "\uD83D\uDD87"
	  }, {
	    symbol: "\uD83D\uDCD0"
	  }, {
	    symbol: "\uD83D\uDCCF"
	  }, {
	    symbol: "\uD83D\uDCCC"
	  }, {
	    symbol: "\uD83D\uDCCD"
	  }, {
	    symbol: "\u2702"
	  }, {
	    symbol: "\uD83D\uDD8A"
	  }, {
	    symbol: "\uD83D\uDD8B"
	  }, {
	    symbol: "\u2712"
	  }, {
	    symbol: "\uD83D\uDD8C"
	  }, {
	    symbol: "\uD83D\uDD8D"
	  }, {
	    symbol: "\uD83D\uDCDD"
	  }, {
	    symbol: "\u270F"
	  }, {
	    symbol: "\uD83D\uDD0D"
	  }, {
	    symbol: "\uD83D\uDD0E"
	  }, {
	    symbol: "\uD83D\uDD0F"
	  }, {
	    symbol: "\uD83D\uDD10"
	  }, {
	    symbol: "\uD83D\uDD12"
	  }, {
	    symbol: "\uD83D\uDD13"
	  }]
	}, {
	  id: 7,
	  code: 'SYMBOLS',
	  showForWindows: true,
	  emoji: [{
	    symbol: "\u2764"
	  }, {
	    symbol: "\uD83E\uDDE1"
	  }, {
	    symbol: "\uD83D\uDC9B"
	  }, {
	    symbol: "\uD83D\uDC9A"
	  }, {
	    symbol: "\uD83D\uDC99"
	  }, {
	    symbol: "\uD83D\uDC9C"
	  }, {
	    symbol: "\uD83D\uDDA4"
	  }, {
	    symbol: "\uD83D\uDC94"
	  }, {
	    symbol: "\u2763"
	  }, {
	    symbol: "\uD83D\uDC95"
	  }, {
	    symbol: "\uD83D\uDC9E"
	  }, {
	    symbol: "\uD83D\uDC93"
	  }, {
	    symbol: "\uD83D\uDC97"
	  }, {
	    symbol: "\uD83D\uDC96"
	  }, {
	    symbol: "\uD83D\uDC98"
	  }, {
	    symbol: "\uD83D\uDC9D"
	  }, {
	    symbol: "\uD83D\uDC9F"
	  }, {
	    symbol: "\u262E"
	  }, {
	    symbol: "\u271D"
	  }, {
	    symbol: "\u262A"
	  }, {
	    symbol: "\uD83D\uDD49"
	  }, {
	    symbol: "\u2638"
	  }, {
	    symbol: "\u2721"
	  }, {
	    symbol: "\uD83D\uDD2F"
	  }, {
	    symbol: "\uD83D\uDD4E"
	  }, {
	    symbol: "\u262F"
	  }, {
	    symbol: "\u2626"
	  }, {
	    symbol: "\uD83D\uDED0"
	  }, {
	    symbol: "\u26CE"
	  }, {
	    symbol: "\u2648"
	  }, {
	    symbol: "\u2649"
	  }, {
	    symbol: "\u264A"
	  }, {
	    symbol: "\u264B"
	  }, {
	    symbol: "\u264C"
	  }, {
	    symbol: "\u264D"
	  }, {
	    symbol: "\u264E"
	  }, {
	    symbol: "\u264F"
	  }, {
	    symbol: "\u2650"
	  }, {
	    symbol: "\u2651"
	  }, {
	    symbol: "\u2652"
	  }, {
	    symbol: "\u2653"
	  }, {
	    symbol: "\uD83C\uDD94"
	  }, {
	    symbol: "\u269B"
	  }, {
	    symbol: "\uD83C\uDE51"
	  }, {
	    symbol: "\u2622"
	  }, {
	    symbol: "\u2623"
	  }, {
	    symbol: "\uD83D\uDCF4"
	  }, {
	    symbol: "\uD83D\uDCF3"
	  }, {
	    symbol: "\uD83C\uDE36"
	  }, {
	    symbol: "\uD83C\uDE1A"
	  }, {
	    symbol: "\uD83C\uDE38"
	  }, {
	    symbol: "\uD83C\uDE3A"
	  }, {
	    symbol: "\uD83C\uDE37"
	  }, {
	    symbol: "\u2734"
	  }, {
	    symbol: "\uD83C\uDD9A"
	  }, {
	    symbol: "\uD83D\uDCAE"
	  }, {
	    symbol: "\uD83C\uDE50"
	  }, {
	    symbol: "\u3299"
	  }, {
	    symbol: "\u3297"
	  }, {
	    symbol: "\uD83C\uDE34"
	  }, {
	    symbol: "\uD83C\uDE35"
	  }, {
	    symbol: "\uD83C\uDE39"
	  }, {
	    symbol: "\uD83C\uDE32"
	  }, {
	    symbol: "\uD83C\uDD70"
	  }, {
	    symbol: "\uD83C\uDD71"
	  }, {
	    symbol: "\uD83C\uDD8E"
	  }, {
	    symbol: "\uD83C\uDD91"
	  }, {
	    symbol: "\uD83C\uDD7E"
	  }, {
	    symbol: "\uD83C\uDD98"
	  }, {
	    symbol: "\u274C"
	  }, {
	    symbol: "\u2B55"
	  }, {
	    symbol: "\uD83D\uDED1"
	  }, {
	    symbol: "\u26D4"
	  }, {
	    symbol: "\uD83D\uDCDB"
	  }, {
	    symbol: "\uD83D\uDEAB"
	  }, {
	    symbol: "\uD83D\uDCAF"
	  }, {
	    symbol: "\uD83D\uDCA2"
	  }, {
	    symbol: "\u2668"
	  }, {
	    symbol: "\uD83D\uDEB7"
	  }, {
	    symbol: "\uD83D\uDEAF"
	  }, {
	    symbol: "\uD83D\uDEB3"
	  }, {
	    symbol: "\uD83D\uDEB1"
	  }, {
	    symbol: "\uD83D\uDD1E"
	  }, {
	    symbol: "\uD83D\uDCF5"
	  }, {
	    symbol: "\uD83D\uDEAD"
	  }, {
	    symbol: "\u2757"
	  }, {
	    symbol: "\u2755"
	  }, {
	    symbol: "\u2753"
	  }, {
	    symbol: "\u2754"
	  }, {
	    symbol: "\u203C"
	  }, {
	    symbol: "\u2049"
	  }, {
	    symbol: "\uD83D\uDD05"
	  }, {
	    symbol: "\uD83D\uDD06"
	  }, {
	    symbol: "\u303D"
	  }, {
	    symbol: "\u26A0"
	  }, {
	    symbol: "\uD83D\uDEB8"
	  }, {
	    symbol: "\uD83D\uDD31"
	  }, {
	    symbol: "\u269C"
	  }, {
	    symbol: "\uD83D\uDD30"
	  }, {
	    symbol: "\u267B"
	  }, {
	    symbol: "\u2705"
	  }, {
	    symbol: "\uD83C\uDE2F"
	  }, {
	    symbol: "\uD83D\uDCB9"
	  }, {
	    symbol: "\u2747"
	  }, {
	    symbol: "\u2733"
	  }, {
	    symbol: "\u274E"
	  }, {
	    symbol: "\uD83C\uDF10"
	  }, {
	    symbol: "\uD83D\uDCA0"
	  }, {
	    symbol: "\u24C2"
	  }, {
	    symbol: "\uD83C\uDF00"
	  }, {
	    symbol: "\uD83D\uDCA4"
	  }, {
	    symbol: "\uD83C\uDFE7"
	  }, {
	    symbol: "\uD83D\uDEBE"
	  }, {
	    symbol: "\u267F"
	  }, {
	    symbol: "\uD83C\uDD7F"
	  }, {
	    symbol: "\uD83C\uDE33"
	  }, {
	    symbol: "\uD83C\uDE02"
	  }, {
	    symbol: "\uD83D\uDEC2"
	  }, {
	    symbol: "\uD83D\uDEC3"
	  }, {
	    symbol: "\uD83D\uDEC4"
	  }, {
	    symbol: "\uD83D\uDEC5"
	  }, {
	    symbol: "\uD83D\uDEB9"
	  }, {
	    symbol: "\uD83D\uDEBA"
	  }, {
	    symbol: "\uD83D\uDEBC"
	  }, {
	    symbol: "\uD83D\uDEBB"
	  }, {
	    symbol: "\uD83D\uDEAE"
	  }, {
	    symbol: "\uD83C\uDFA6"
	  }, {
	    symbol: "\uD83D\uDCF6"
	  }, {
	    symbol: "\uD83C\uDE01"
	  }, {
	    symbol: "\uD83D\uDD23"
	  }, {
	    symbol: "\u2139"
	  }, {
	    symbol: "\uD83D\uDD24"
	  }, {
	    symbol: "\uD83D\uDD21"
	  }, {
	    symbol: "\uD83D\uDD20"
	  }, {
	    symbol: "\uD83C\uDD96"
	  }, {
	    symbol: "\uD83C\uDD97"
	  }, {
	    symbol: "\uD83C\uDD99"
	  }, {
	    symbol: "\uD83C\uDD92"
	  }, {
	    symbol: "\uD83C\uDD95"
	  }, {
	    symbol: "\uD83C\uDD93"
	  }, {
	    symbol: "0"
	  }, {
	    symbol: "1"
	  }, {
	    symbol: "2"
	  }, {
	    symbol: "3"
	  }, {
	    symbol: "4"
	  }, {
	    symbol: "5"
	  }, {
	    symbol: "6"
	  }, {
	    symbol: "7"
	  }, {
	    symbol: "8"
	  }, {
	    symbol: "9"
	  }, {
	    symbol: "\uD83D\uDD1F"
	  }, {
	    symbol: "\uD83D\uDD22"
	  }, {
	    symbol: "#"
	  }, {
	    symbol: "*"
	  }, {
	    symbol: "\u23CF"
	  }, {
	    symbol: "\u25B6"
	  }, {
	    symbol: "\u23F8"
	  }, {
	    symbol: "\u23EF"
	  }, {
	    symbol: "\u23F9"
	  }, {
	    symbol: "\u23FA"
	  }, {
	    symbol: "\u23ED"
	  }, {
	    symbol: "\u23EE"
	  }, {
	    symbol: "\u23E9"
	  }, {
	    symbol: "\u23EA"
	  }, {
	    symbol: "\u23EB"
	  }, {
	    symbol: "\u23EC"
	  }, {
	    symbol: "\u25C0"
	  }, {
	    symbol: "\uD83D\uDD3C"
	  }, {
	    symbol: "\uD83D\uDD3D"
	  }, {
	    symbol: "\u27A1"
	  }, {
	    symbol: "\u2B05"
	  }, {
	    symbol: "\u2B06"
	  }, {
	    symbol: "\u2B07"
	  }, {
	    symbol: "\u2197"
	  }, {
	    symbol: "\u2198"
	  }, {
	    symbol: "\u2199"
	  }, {
	    symbol: "\u2196"
	  }, {
	    symbol: "\u2195"
	  }, {
	    symbol: "\u2194"
	  }, {
	    symbol: "\u21AA"
	  }, {
	    symbol: "\u21A9"
	  }, {
	    symbol: "\u2934"
	  }, {
	    symbol: "\u2935"
	  }, {
	    symbol: "\uD83D\uDD00"
	  }, {
	    symbol: "\uD83D\uDD01"
	  }, {
	    symbol: "\uD83D\uDD02"
	  }, {
	    symbol: "\uD83D\uDD04"
	  }, {
	    symbol: "\uD83D\uDD03"
	  }, {
	    symbol: "\uD83C\uDFB5"
	  }, {
	    symbol: "\uD83C\uDFB6"
	  }, {
	    symbol: "\u2795"
	  }, {
	    symbol: "\u2796"
	  }, {
	    symbol: "\u2797"
	  }, {
	    symbol: "\u2716"
	  }, {
	    symbol: "\u267E"
	  }, {
	    symbol: "\uD83D\uDCB2"
	  }, {
	    symbol: "\uD83D\uDCB1"
	  }, {
	    symbol: "\u2122"
	  }, {
	    symbol: "\xA9"
	  }, {
	    symbol: "\xAE"
	  }, {
	    symbol: "\uD83D\uDC41"
	  }, {
	    symbol: "\uD83D\uDDE8"
	  }, {
	    symbol: "\uD83D\uDD1A"
	  }, {
	    symbol: "\uD83D\uDD19"
	  }, {
	    symbol: "\uD83D\uDD1B"
	  }, {
	    symbol: "\uD83D\uDD1D"
	  }, {
	    symbol: "\uD83D\uDD1C"
	  }, {
	    symbol: "\u3030"
	  }, {
	    symbol: "\u27B0"
	  }, {
	    symbol: "\u27BF"
	  }, {
	    symbol: "\u2714"
	  }, {
	    symbol: "\u2611"
	  }, {
	    symbol: "\uD83D\uDD18"
	  }, {
	    symbol: "\u26AA"
	  }, {
	    symbol: "\u26AB"
	  }, {
	    symbol: "\uD83D\uDD34"
	  }, {
	    symbol: "\uD83D\uDD35"
	  }, {
	    symbol: "\uD83D\uDD3A"
	  }, {
	    symbol: "\uD83D\uDD3B"
	  }, {
	    symbol: "\uD83D\uDD38"
	  }, {
	    symbol: "\uD83D\uDD39"
	  }, {
	    symbol: "\uD83D\uDD36"
	  }, {
	    symbol: "\uD83D\uDD37"
	  }, {
	    symbol: "\uD83D\uDD33"
	  }, {
	    symbol: "\uD83D\uDD32"
	  }, {
	    symbol: "\u25AA"
	  }, {
	    symbol: "\u25AB"
	  }, {
	    symbol: "\u25FE"
	  }, {
	    symbol: "\u25FD"
	  }, {
	    symbol: "\u25FC"
	  }, {
	    symbol: "\u25FB"
	  }, {
	    symbol: "\u2B1B"
	  }, {
	    symbol: "\u2B1C"
	  }, {
	    symbol: "\uD83D\uDD08"
	  }, {
	    symbol: "\uD83D\uDD07"
	  }, {
	    symbol: "\uD83D\uDD09"
	  }, {
	    symbol: "\uD83D\uDD0A"
	  }, {
	    symbol: "\uD83D\uDD14"
	  }, {
	    symbol: "\uD83D\uDD15"
	  }, {
	    symbol: "\uD83D\uDCE3"
	  }, {
	    symbol: "\uD83D\uDCE2"
	  }, {
	    symbol: "\uD83D\uDCAC"
	  }, {
	    symbol: "\uD83D\uDCAD"
	  }, {
	    symbol: "\uD83D\uDDEF"
	  }, {
	    symbol: "\u2660"
	  }, {
	    symbol: "\u2663"
	  }, {
	    symbol: "\u2665"
	  }, {
	    symbol: "\u2666"
	  }, {
	    symbol: "\uD83C\uDCCF"
	  }, {
	    symbol: "\uD83C\uDFB4"
	  }, {
	    symbol: "\uD83C\uDC04"
	  }, {
	    symbol: "\uD83D\uDD50"
	  }, {
	    symbol: "\uD83D\uDD51"
	  }, {
	    symbol: "\uD83D\uDD52"
	  }, {
	    symbol: "\uD83D\uDD53"
	  }, {
	    symbol: "\uD83D\uDD54"
	  }, {
	    symbol: "\uD83D\uDD55"
	  }, {
	    symbol: "\uD83D\uDD56"
	  }, {
	    symbol: "\uD83D\uDD57"
	  }, {
	    symbol: "\uD83D\uDD58"
	  }, {
	    symbol: "\uD83D\uDD59"
	  }, {
	    symbol: "\uD83D\uDD5A"
	  }, {
	    symbol: "\uD83D\uDD5B"
	  }, {
	    symbol: "\uD83D\uDD5C"
	  }, {
	    symbol: "\uD83D\uDD5D"
	  }, {
	    symbol: "\uD83D\uDD5E"
	  }, {
	    symbol: "\uD83D\uDD5F"
	  }, {
	    symbol: "\uD83D\uDD60"
	  }, {
	    symbol: "\uD83D\uDD61"
	  }, {
	    symbol: "\uD83D\uDD62"
	  }, {
	    symbol: "\uD83D\uDD63"
	  }, {
	    symbol: "\uD83D\uDD64"
	  }, {
	    symbol: "\uD83D\uDD65"
	  }, {
	    symbol: "\uD83D\uDD66"
	  }, {
	    symbol: "\uD83D\uDD67"
	  }]
	}, {
	  id: 8,
	  code: 'FLAGS',
	  showForWindows: false,
	  emoji: [{
	    symbol: "\uD83C\uDFF3"
	  }, {
	    symbol: "\uD83C\uDFF4"
	  }, {
	    symbol: "\uD83C\uDFC1"
	  }, {
	    symbol: "\uD83D\uDEA9"
	  }, {
	    symbol: "\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08"
	  }, {
	    symbol: "\uD83C\uDDFA\uD83C\uDDF3"
	  }, {
	    symbol: "\uD83C\uDDE6\uD83C\uDDEB"
	  }, {
	    symbol: "\uD83C\uDDE6\uD83C\uDDFD"
	  }, {
	    symbol: "\uD83C\uDDE6\uD83C\uDDF1"
	  }, {
	    symbol: "\uD83C\uDDE9\uD83C\uDDFF"
	  }, {
	    symbol: "\uD83C\uDDE6\uD83C\uDDF8"
	  }, {
	    symbol: "\uD83C\uDDE6\uD83C\uDDE9"
	  }, {
	    symbol: "\uD83C\uDDE6\uD83C\uDDF4"
	  }, {
	    symbol: "\uD83C\uDDE6\uD83C\uDDEE"
	  }, {
	    symbol: "\uD83C\uDDE6\uD83C\uDDF6"
	  }, {
	    symbol: "\uD83C\uDDE6\uD83C\uDDEC"
	  }, {
	    symbol: "\uD83C\uDDE6\uD83C\uDDF7"
	  }, {
	    symbol: "\uD83C\uDDE6\uD83C\uDDF2"
	  }, {
	    symbol: "\uD83C\uDDE6\uD83C\uDDFC"
	  }, {
	    symbol: "\uD83C\uDDE6\uD83C\uDDFA"
	  }, {
	    symbol: "\uD83C\uDDE6\uD83C\uDDF9"
	  }, {
	    symbol: "\uD83C\uDDE6\uD83C\uDDFF"
	  }, {
	    symbol: "\uD83C\uDDE7\uD83C\uDDF8"
	  }, {
	    symbol: "\uD83C\uDDE7\uD83C\uDDED"
	  }, {
	    symbol: "\uD83C\uDDE7\uD83C\uDDE9"
	  }, {
	    symbol: "\uD83C\uDDE7\uD83C\uDDFE"
	  }, {
	    symbol: "\uD83C\uDDE7\uD83C\uDDEA"
	  }, {
	    symbol: "\uD83C\uDDE7\uD83C\uDDFF"
	  }, {
	    symbol: "\uD83C\uDDE7\uD83C\uDDEF"
	  }, {
	    symbol: "\uD83C\uDDE7\uD83C\uDDF2"
	  }, {
	    symbol: "\uD83C\uDDE7\uD83C\uDDF9"
	  }, {
	    symbol: "\uD83C\uDDE7\uD83C\uDDF4"
	  }, {
	    symbol: "\uD83C\uDDE7\uD83C\uDDE6"
	  }, {
	    symbol: "\uD83C\uDDE7\uD83C\uDDFC"
	  }, {
	    symbol: "\uD83C\uDDE7\uD83C\uDDF7"
	  }, {
	    symbol: "\uD83C\uDDEE\uD83C\uDDF4"
	  }, {
	    symbol: "\uD83C\uDDFB\uD83C\uDDEC"
	  }, {
	    symbol: "\uD83C\uDDE7\uD83C\uDDF3"
	  }, {
	    symbol: "\uD83C\uDDE7\uD83C\uDDEC"
	  }, {
	    symbol: "\uD83C\uDDE7\uD83C\uDDEB"
	  }, {
	    symbol: "\uD83C\uDDE7\uD83C\uDDEE"
	  }, {
	    symbol: "\uD83C\uDDF0\uD83C\uDDED"
	  }, {
	    symbol: "\uD83C\uDDE8\uD83C\uDDF2"
	  }, {
	    symbol: "\uD83C\uDDE8\uD83C\uDDE6"
	  }, {
	    symbol: "\uD83C\uDDEE\uD83C\uDDE8"
	  }, {
	    symbol: "\uD83C\uDDE8\uD83C\uDDFB"
	  }, {
	    symbol: "\uD83C\uDDE7\uD83C\uDDF6"
	  }, {
	    symbol: "\uD83C\uDDF0\uD83C\uDDFE"
	  }, {
	    symbol: "\uD83C\uDDE8\uD83C\uDDEB"
	  }, {
	    symbol: "\uD83C\uDDF9\uD83C\uDDE9"
	  }, {
	    symbol: "\uD83C\uDDE8\uD83C\uDDF1"
	  }, {
	    symbol: "\uD83C\uDDE8\uD83C\uDDF3"
	  }, {
	    symbol: "\uD83C\uDDE8\uD83C\uDDFD"
	  }, {
	    symbol: "\uD83C\uDDE8\uD83C\uDDF4"
	  }, {
	    symbol: "\uD83C\uDDF0\uD83C\uDDF2"
	  }, {
	    symbol: "\uD83C\uDDE8\uD83C\uDDEC"
	  }, {
	    symbol: "\uD83C\uDDE8\uD83C\uDDE9"
	  }, {
	    symbol: "\uD83C\uDDE8\uD83C\uDDF0"
	  }, {
	    symbol: "\uD83C\uDDE8\uD83C\uDDF7"
	  }, {
	    symbol: "\uD83C\uDDE8\uD83C\uDDEE"
	  }, {
	    symbol: "\uD83C\uDDED\uD83C\uDDF7"
	  }, {
	    symbol: "\uD83C\uDDE8\uD83C\uDDFA"
	  }, {
	    symbol: "\uD83C\uDDE8\uD83C\uDDFC"
	  }, {
	    symbol: "\uD83C\uDDE8\uD83C\uDDFE"
	  }, {
	    symbol: "\uD83C\uDDE8\uD83C\uDDFF"
	  }, {
	    symbol: "\uD83C\uDDE9\uD83C\uDDF0"
	  }, {
	    symbol: "\uD83C\uDDE9\uD83C\uDDEF"
	  }, {
	    symbol: "\uD83C\uDDE9\uD83C\uDDF2"
	  }, {
	    symbol: "\uD83C\uDDE9\uD83C\uDDF4"
	  }, {
	    symbol: "\uD83C\uDDEA\uD83C\uDDE8"
	  }, {
	    symbol: "\uD83C\uDDEA\uD83C\uDDEC"
	  }, {
	    symbol: "\uD83C\uDDF8\uD83C\uDDFB"
	  }, {
	    symbol: "\uD83C\uDDEC\uD83C\uDDF6"
	  }, {
	    symbol: "\uD83C\uDDEA\uD83C\uDDF7"
	  }, {
	    symbol: "\uD83C\uDDEA\uD83C\uDDF9"
	  }, {
	    symbol: "\uD83C\uDDEA\uD83C\uDDFA"
	  }, {
	    symbol: "\uD83C\uDDEB\uD83C\uDDF0"
	  }, {
	    symbol: "\uD83C\uDDEB\uD83C\uDDF4"
	  }, {
	    symbol: "\uD83C\uDDEB\uD83C\uDDEF"
	  }, {
	    symbol: "\uD83C\uDDEB\uD83C\uDDEE"
	  }, {
	    symbol: "\uD83C\uDDEB\uD83C\uDDF7"
	  }, {
	    symbol: "\uD83C\uDDEC\uD83C\uDDEB"
	  }, {
	    symbol: "\uD83C\uDDF5\uD83C\uDDEB"
	  }, {
	    symbol: "\uD83C\uDDEC\uD83C\uDDE6"
	  }, {
	    symbol: "\uD83C\uDDEC\uD83C\uDDF2"
	  }, {
	    symbol: "\uD83C\uDDEC\uD83C\uDDEA"
	  }, {
	    symbol: "\uD83C\uDDE9\uD83C\uDDEA"
	  }, {
	    symbol: "\uD83C\uDDEC\uD83C\uDDED"
	  }, {
	    symbol: "\uD83C\uDDEC\uD83C\uDDEE"
	  }, {
	    symbol: "\uD83C\uDDEC\uD83C\uDDF7"
	  }, {
	    symbol: "\uD83C\uDDEC\uD83C\uDDF1"
	  }, {
	    symbol: "\uD83C\uDDEC\uD83C\uDDE9"
	  }, {
	    symbol: "\uD83C\uDDEC\uD83C\uDDF5"
	  }, {
	    symbol: "\uD83C\uDDEC\uD83C\uDDFA"
	  }, {
	    symbol: "\uD83C\uDDEC\uD83C\uDDF9"
	  }, {
	    symbol: "\uD83C\uDDEC\uD83C\uDDF3"
	  }, {
	    symbol: "\uD83C\uDDEC\uD83C\uDDFC"
	  }, {
	    symbol: "\uD83C\uDDEC\uD83C\uDDFE"
	  }, {
	    symbol: "\uD83C\uDDED\uD83C\uDDF9"
	  }, {
	    symbol: "\uD83C\uDDED\uD83C\uDDF3"
	  }, {
	    symbol: "\uD83C\uDDED\uD83C\uDDF0"
	  }, {
	    symbol: "\uD83C\uDDED\uD83C\uDDFA"
	  }, {
	    symbol: "\uD83C\uDDEE\uD83C\uDDF8"
	  }, {
	    symbol: "\uD83C\uDDEE\uD83C\uDDF3"
	  }, {
	    symbol: "\uD83C\uDDEE\uD83C\uDDE9"
	  }, {
	    symbol: "\uD83C\uDDEE\uD83C\uDDF7"
	  }, {
	    symbol: "\uD83C\uDDEE\uD83C\uDDF6"
	  }, {
	    symbol: "\uD83C\uDDEE\uD83C\uDDEA"
	  }, {
	    symbol: "\uD83C\uDDEE\uD83C\uDDF2"
	  }, {
	    symbol: "\uD83C\uDDEE\uD83C\uDDF1"
	  }, {
	    symbol: "\uD83C\uDDEE\uD83C\uDDF9"
	  }, {
	    symbol: "\uD83C\uDDEF\uD83C\uDDF2"
	  }, {
	    symbol: "\uD83C\uDDEF\uD83C\uDDF5"
	  }, {
	    symbol: "\uD83C\uDDEF\uD83C\uDDEA"
	  }, {
	    symbol: "\uD83C\uDDEF\uD83C\uDDF4"
	  }, {
	    symbol: "\uD83C\uDDF0\uD83C\uDDFF"
	  }, {
	    symbol: "\uD83C\uDDF0\uD83C\uDDEA"
	  }, {
	    symbol: "\uD83C\uDDF0\uD83C\uDDEE"
	  }, {
	    symbol: "\uD83C\uDDFD\uD83C\uDDF0"
	  }, {
	    symbol: "\uD83C\uDDF0\uD83C\uDDFC"
	  }, {
	    symbol: "\uD83C\uDDF0\uD83C\uDDEC"
	  }, {
	    symbol: "\uD83C\uDDF1\uD83C\uDDE6"
	  }, {
	    symbol: "\uD83C\uDDF1\uD83C\uDDFB"
	  }, {
	    symbol: "\uD83C\uDDF1\uD83C\uDDE7"
	  }, {
	    symbol: "\uD83C\uDDF1\uD83C\uDDF8"
	  }, {
	    symbol: "\uD83C\uDDF1\uD83C\uDDF7"
	  }, {
	    symbol: "\uD83C\uDDF1\uD83C\uDDFE"
	  }, {
	    symbol: "\uD83C\uDDF1\uD83C\uDDEE"
	  }, {
	    symbol: "\uD83C\uDDF1\uD83C\uDDF9"
	  }, {
	    symbol: "\uD83C\uDDF1\uD83C\uDDFA"
	  }, {
	    symbol: "\uD83C\uDDF2\uD83C\uDDF4"
	  }, {
	    symbol: "\uD83C\uDDF2\uD83C\uDDF0"
	  }, {
	    symbol: "\uD83C\uDDF2\uD83C\uDDEC"
	  }, {
	    symbol: "\uD83C\uDDF2\uD83C\uDDFC"
	  }, {
	    symbol: "\uD83C\uDDF2\uD83C\uDDFE"
	  }, {
	    symbol: "\uD83C\uDDF2\uD83C\uDDFB"
	  }, {
	    symbol: "\uD83C\uDDF2\uD83C\uDDF1"
	  }, {
	    symbol: "\uD83C\uDDF2\uD83C\uDDF9"
	  }, {
	    symbol: "\uD83C\uDDF2\uD83C\uDDED"
	  }, {
	    symbol: "\uD83C\uDDF2\uD83C\uDDF7"
	  }, {
	    symbol: "\uD83C\uDDF2\uD83C\uDDFA"
	  }, {
	    symbol: "\uD83C\uDDFE\uD83C\uDDF9"
	  }, {
	    symbol: "\uD83C\uDDF2\uD83C\uDDFD"
	  }, {
	    symbol: "\uD83C\uDDEB\uD83C\uDDF2"
	  }, {
	    symbol: "\uD83C\uDDF2\uD83C\uDDE9"
	  }, {
	    symbol: "\uD83C\uDDF2\uD83C\uDDE8"
	  }, {
	    symbol: "\uD83C\uDDF2\uD83C\uDDF3"
	  }, {
	    symbol: "\uD83C\uDDF2\uD83C\uDDEA"
	  }, {
	    symbol: "\uD83C\uDDF2\uD83C\uDDF8"
	  }, {
	    symbol: "\uD83C\uDDF2\uD83C\uDDE6"
	  }, {
	    symbol: "\uD83C\uDDF2\uD83C\uDDFF"
	  }, {
	    symbol: "\uD83C\uDDF3\uD83C\uDDE6"
	  }, {
	    symbol: "\uD83C\uDDF3\uD83C\uDDF7"
	  }, {
	    symbol: "\uD83C\uDDF3\uD83C\uDDF5"
	  }, {
	    symbol: "\uD83C\uDDF3\uD83C\uDDF1"
	  }, {
	    symbol: "\uD83C\uDDF3\uD83C\uDDE8"
	  }, {
	    symbol: "\uD83C\uDDF3\uD83C\uDDFF"
	  }, {
	    symbol: "\uD83C\uDDF3\uD83C\uDDEE"
	  }, {
	    symbol: "\uD83C\uDDF3\uD83C\uDDEA"
	  }, {
	    symbol: "\uD83C\uDDF3\uD83C\uDDEC"
	  }, {
	    symbol: "\uD83C\uDDF3\uD83C\uDDFA"
	  }, {
	    symbol: "\uD83C\uDDF3\uD83C\uDDEB"
	  }, {
	    symbol: "\uD83C\uDDF0\uD83C\uDDF5"
	  }, {
	    symbol: "\uD83C\uDDF2\uD83C\uDDF5"
	  }, {
	    symbol: "\uD83C\uDDF3\uD83C\uDDF4"
	  }, {
	    symbol: "\uD83C\uDDF4\uD83C\uDDF2"
	  }, {
	    symbol: "\uD83C\uDDF5\uD83C\uDDF0"
	  }, {
	    symbol: "\uD83C\uDDF5\uD83C\uDDFC"
	  }, {
	    symbol: "\uD83C\uDDF5\uD83C\uDDF8"
	  }, {
	    symbol: "\uD83C\uDDF5\uD83C\uDDE6"
	  }, {
	    symbol: "\uD83C\uDDF5\uD83C\uDDEC"
	  }, {
	    symbol: "\uD83C\uDDF5\uD83C\uDDFE"
	  }, {
	    symbol: "\uD83C\uDDF5\uD83C\uDDEA"
	  }, {
	    symbol: "\uD83C\uDDF5\uD83C\uDDED"
	  }, {
	    symbol: "\uD83C\uDDF5\uD83C\uDDF3"
	  }, {
	    symbol: "\uD83C\uDDF5\uD83C\uDDF1"
	  }, {
	    symbol: "\uD83C\uDDF5\uD83C\uDDF9"
	  }, {
	    symbol: "\uD83C\uDDF5\uD83C\uDDF7"
	  }, {
	    symbol: "\uD83C\uDDF6\uD83C\uDDE6"
	  }, {
	    symbol: "\uD83C\uDDF7\uD83C\uDDF4"
	  }, {
	    symbol: "\uD83C\uDDF7\uD83C\uDDFA"
	  }, {
	    symbol: "\uD83C\uDDF7\uD83C\uDDFC"
	  }, {
	    symbol: "\uD83C\uDDFC\uD83C\uDDF8"
	  }, {
	    symbol: "\uD83C\uDDF8\uD83C\uDDF2"
	  }, {
	    symbol: "\uD83C\uDDF8\uD83C\uDDF9"
	  }, {
	    symbol: "\uD83C\uDDF8\uD83C\uDDE6"
	  }, {
	    symbol: "\uD83C\uDDF8\uD83C\uDDF3"
	  }, {
	    symbol: "\uD83C\uDDF7\uD83C\uDDF8"
	  }, {
	    symbol: "\uD83C\uDDF8\uD83C\uDDE8"
	  }, {
	    symbol: "\uD83C\uDDF8\uD83C\uDDF1"
	  }, {
	    symbol: "\uD83C\uDDF8\uD83C\uDDEC"
	  }, {
	    symbol: "\uD83C\uDDF8\uD83C\uDDFD"
	  }, {
	    symbol: "\uD83C\uDDF8\uD83C\uDDF0"
	  }, {
	    symbol: "\uD83C\uDDF8\uD83C\uDDEE"
	  }, {
	    symbol: "\uD83C\uDDEC\uD83C\uDDF8"
	  }, {
	    symbol: "\uD83C\uDDF8\uD83C\uDDE7"
	  }, {
	    symbol: "\uD83C\uDDF8\uD83C\uDDF4"
	  }, {
	    symbol: "\uD83C\uDDFF\uD83C\uDDE6"
	  }, {
	    symbol: "\uD83C\uDDF0\uD83C\uDDF7"
	  }, {
	    symbol: "\uD83C\uDDEA\uD83C\uDDF8"
	  }, {
	    symbol: "\uD83C\uDDF1\uD83C\uDDF0"
	  }, {
	    symbol: "\uD83C\uDDF8\uD83C\uDDED"
	  }, {
	    symbol: "\uD83C\uDDF0\uD83C\uDDF3"
	  }, {
	    symbol: "\uD83C\uDDF1\uD83C\uDDE8"
	  }, {
	    symbol: "\uD83C\uDDF5\uD83C\uDDF2"
	  }, {
	    symbol: "\uD83C\uDDFB\uD83C\uDDE8"
	  }, {
	    symbol: "\uD83C\uDDF8\uD83C\uDDE9"
	  }, {
	    symbol: "\uD83C\uDDF8\uD83C\uDDF7"
	  }, {
	    symbol: "\uD83C\uDDF8\uD83C\uDDFF"
	  }, {
	    symbol: "\uD83C\uDDF8\uD83C\uDDEA"
	  }, {
	    symbol: "\uD83C\uDDE8\uD83C\uDDED"
	  }, {
	    symbol: "\uD83C\uDDF8\uD83C\uDDFE"
	  }, {
	    symbol: "\uD83C\uDDF9\uD83C\uDDFC"
	  }, {
	    symbol: "\uD83C\uDDF9\uD83C\uDDEF"
	  }, {
	    symbol: "\uD83C\uDDF9\uD83C\uDDFF"
	  }, {
	    symbol: "\uD83C\uDDF9\uD83C\uDDED"
	  }, {
	    symbol: "\uD83C\uDDF9\uD83C\uDDF1"
	  }, {
	    symbol: "\uD83C\uDDF9\uD83C\uDDEC"
	  }, {
	    symbol: "\uD83C\uDDF9\uD83C\uDDF0"
	  }, {
	    symbol: "\uD83C\uDDF9\uD83C\uDDF4"
	  }, {
	    symbol: "\uD83C\uDDF9\uD83C\uDDF3"
	  }, {
	    symbol: "\uD83C\uDDF9\uD83C\uDDF7"
	  }, {
	    symbol: "\uD83C\uDDF9\uD83C\uDDF2"
	  }, {
	    symbol: "\uD83C\uDDF9\uD83C\uDDE8"
	  }, {
	    symbol: "\uD83C\uDDF9\uD83C\uDDFB"
	  }, {
	    symbol: "\uD83C\uDDFB\uD83C\uDDEE"
	  }, {
	    symbol: "\uD83C\uDDFA\uD83C\uDDEC"
	  }, {
	    symbol: "\uD83C\uDDFA\uD83C\uDDE6"
	  }, {
	    symbol: "\uD83C\uDDE6\uD83C\uDDEA"
	  }, {
	    symbol: "\uD83C\uDDEC\uD83C\uDDE7"
	  }, {
	    symbol: "\uD83C\uDDFA\uD83C\uDDF8"
	  }, {
	    symbol: "\uD83C\uDDFA\uD83C\uDDFE"
	  }, {
	    symbol: "\uD83C\uDDFA\uD83C\uDDFF"
	  }, {
	    symbol: "\uD83C\uDDFB\uD83C\uDDFA"
	  }, {
	    symbol: "\uD83C\uDDFB\uD83C\uDDE6"
	  }, {
	    symbol: "\uD83C\uDDFB\uD83C\uDDEA"
	  }, {
	    symbol: "\uD83C\uDDFB\uD83C\uDDF3"
	  }, {
	    symbol: "\uD83C\uDDFC\uD83C\uDDEB"
	  }, {
	    symbol: "\uD83C\uDDEA\uD83C\uDDED"
	  }, {
	    symbol: "\uD83C\uDDFE\uD83C\uDDEA"
	  }, {
	    symbol: "\uD83C\uDDFF\uD83C\uDDF2"
	  }, {
	    symbol: "\uD83C\uDDFF\uD83C\uDDFC"
	  }]
	}];

	/**
	 * Bitrix UI
	 * Smiles Vue component
	 *
	 * @package bitrix
	 * @subpackage ui
	 * @copyright 2001-2020 Bitrix
	 */
	ui_vue.WidgetBitrixVue.component('bx-smiles', {
	  /**
	   * @emits 'selectSmile' {text: string}
	   * @emits 'selectSet' {setId: number}
	   */
	  data: function data() {
	    return {
	      smiles: [],
	      sets: [],
	      emoji: [],
	      mode: 'smile',
	      emojiIcon: "\uD83D\uDE0D"
	    };
	  },
	  created: function created() {
	    var _this = this;

	    this.setSelected = 0;
	    this.serverLoad = false;
	    var restClient = this.$root.$bitrixRestClient || this.$Bitrix.RestClient.get();
	    this.smilesController = new SmileManager(restClient);
	    this.smilesController.loadFromCache().then(function (result) {
	      if (_this.serverLoad) return true;
	      _this.smiles = result.smiles;
	      _this.sets = result.sets.map(function (element, index) {
	        element.selected = _this.setSelected === index;
	        return element;
	      });
	    });
	    this.smilesController.loadFromServer().then(function (result) {
	      _this.smiles = result.smiles;
	      _this.sets = result.sets.map(function (element, index) {
	        element.selected = _this.setSelected === index;
	        return element;
	      });
	    });
	    this.emoji = emoji;
	  },
	  methods: {
	    selectSet: function selectSet(setId) {
	      var _this2 = this;

	      this.mode = "smile";
	      this.$emit('selectSet', {
	        setId: setId
	      });
	      this.smilesController.changeSet(setId).then(function (result) {
	        _this2.smiles = result;

	        _this2.sets.map(function (set) {
	          set.selected = set.id === setId;

	          if (set.selected) {
	            _this2.setSelected = setId;
	          }

	          return set;
	        });

	        _this2.$refs.elements.scrollTop = 0;
	      });
	    },
	    selectSmile: function selectSmile(text) {
	      this.$emit('selectSmile', {
	        text: ' ' + text + ' '
	      });
	    },
	    switchToEmoji: function switchToEmoji() {
	      this.mode = 'emoji';
	      this.sets.map(function (set) {
	        set.selected = false;
	      });
	    },
	    showCategory: function showCategory(category) {
	      if (this.isWindows()) {
	        return category.showForWindows;
	      } else {
	        return true;
	      }
	    },
	    isMac: function isMac() {
	      return navigator.userAgent.toLowerCase().includes('macintosh');
	    },
	    isLinux: function isLinux() {
	      return navigator.userAgent.toLowerCase().includes('linux');
	    },
	    isWindows: function isWindows() {
	      return navigator.userAgent.toLowerCase().includes('windows') || !this.isMac() && !this.isLinux();
	    }
	  },
	  computed: {
	    showEmoji: function showEmoji() {
	      return this.$Bitrix.Loc.getMessage('UTF_MODE') === 'Y';
	    },
	    isEmojiMode: function isEmojiMode() {
	      return this.mode === 'emoji';
	    },
	    isSmileMode: function isSmileMode() {
	      return this.mode === "smile";
	    },
	    emojiIconStyle: function emojiIconStyle() {
	      var style = 'bx-ui-smiles-set-emoji';

	      if (this.isMac()) {
	        return style += '-mac';
	      } else if (this.isLinux()) {
	        return style += '-linux';
	      } else if (this.isWindows()) {
	        return style += '-win';
	      } else {
	        return style;
	      }
	    }
	  },
	  template: "\n\t\t<div class=\"bx-ui-smiles-box\">\n\t\t\t<div class=\"bx-ui-smiles-elements-wrap\" ref=\"elements\">\n\t\t\t\t<template v-if=\"!smiles.length\">\n\t\t\t\t\t<svg class=\"bx-ui-smiles-loading-circular\" viewBox=\"25 25 50 50\">\n\t\t\t\t\t\t<circle class=\"bx-ui-smiles-loading-path\" cx=\"50\" cy=\"50\" r=\"20\" fill=\"none\" stroke-miterlimit=\"10\"/>\n\t\t\t\t\t\t<circle class=\"bx-ui-smiles-loading-inner-path\" cx=\"50\" cy=\"50\" r=\"20\" fill=\"none\" stroke-miterlimit=\"10\"/>\n\t\t\t\t\t</svg>\n\t\t\t\t</template>\n\t\t\t\t<template v-else-if=\"isSmileMode\">\n\t\t\t\t\t<template v-for=\"smile in smiles\">\n\t\t\t\t\t\t<div class=\"bx-ui-smiles-smile\">\n\t\t\t\t\t\t\t<img v-bx-lazyload :key=\"smile.id\"\n\t\t\t\t\t\t\t\tclass=\"bx-ui-smiles-smile-icon\"\n\t\t\t\t\t\t\t\t:data-lazyload-src=\"smile.image\"\n\t\t\t\t\t\t\t\tdata-lazyload-error-class=\"bx-ui-smiles-smile-icon-error\"\n\t\t\t\t\t\t\t\t:title=\"smile.name\"\n\t\t\t\t\t\t\t\t:style=\"{height: (smile.originalHeight*0.5)+'px', width: (smile.originalWidth*0.5)+'px'}\"\n\t\t\t\t\t\t\t\t@click=\"selectSmile(smile.typing)\"\n\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</template>\n\t\t\t\t</template>\n\t\t\t\t<template v-else-if=\"isEmojiMode\">\n\t\t\t\t\t<div v-for=\"category in emoji\" class=\"bx-ui-smiles-emoji-wrap\">\n\t\t\t\t\t\t<template v-if=\"showCategory(category)\">\n\t\t\t\t\t\t\t<div class=\"bx-ui-smiles-category\">\n\t\t\t\t\t\t\t\t{{ $Bitrix.Loc.getMessage('UI_VUE_SMILES_EMOJI_CATEGORY_' + category.code) }}\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t<template v-for=\"element in category.emoji\">\n\t\t\t\t\t\t\t\t<div class=\"bx-ui-smiles-smile\" style=\"font-size: 28px;\">\n\t\t\t\t\t\t\t\t\t<div class=\"bx-ui-smiles-smile-icon\" @click=\"selectSmile(element.symbol)\">\n\t\t\t\t\t\t\t\t\t\t{{ element.symbol }}\n\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t</template>\n\t\t\t\t\t\t</template>\n\t\t\t\t\t</div>\n\t\t\t\t</template>\n\t\t\t</div>\n\t\t\t<template v-if=\"sets.length > 1 || emoji && showEmoji\">\n\t\t\t\t<div class=\"bx-ui-smiles-sets\">\n\t\t\t\t\t<template v-for=\"set in sets\">\n\t\t\t\t\t\t<div :class=\"['bx-ui-smiles-set', {'bx-ui-smiles-set-selected': set.selected}]\">\n\t\t\t\t\t\t\t<img v-bx-lazyload\n\t\t\t\t\t\t\t\t:key=\"set.id\"\n\t\t\t\t\t\t\t\tclass=\"bx-ui-smiles-set-icon\"\n\t\t\t\t\t\t\t\t:data-lazyload-src=\"set.image\"\n\t\t\t\t\t\t\t\tdata-lazyload-error-class=\"bx-ui-smiles-set-icon-error\"\n\t\t\t\t\t\t\t\t:title=\"set.name\"\n\t\t\t\t\t\t\t\t@click=\"selectSet(set.id)\"\n\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</template>\n\t\t\t\t\t<div v-if=\"emoji && showEmoji\" :class=\"['bx-ui-smiles-set', {'bx-ui-smiles-set-selected': isEmojiMode}]\">\n\t\t\t\t\t\t<div :class=\"['bx-ui-smiles-set-icon', emojiIconStyle]\" @click=\"switchToEmoji\">\n\t\t\t\t\t\t \t{{ emojiIcon }}\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t</template>\n\t\t</div>\n\t"
	});

}((this.window = this.window || {}),window,BX,BX));
 




// file: /bitrix/js/ui/progressbarjs/progressbar.js
/*!
  * ProgressBar.js v1.1.0
  * (c) 2016 Kimmo Brunfeldt
  * @license MIT
  *
  * GitHub: https://kimmobrunfeldt.github.io/progressbar.js
  */

/**
 * Modify list for integration with Bitrix Framework:
 * - removed integration with third-party package builders;
 * - export ProgressBarJS to BX scope to exclude possibility of conflict with third-party sites;
 * - add check variables before using them, for fix NaN bug, see tags: 09052020;
 * - add catch branch for correct work with error in Tweenable function, see tags: 10052020;
 */

(function(f){
    if (typeof window.BX === 'undefined')
	{
		window.BX = {};
	}
	window.BX.ProgressBarJs = f();
})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
/*! Shifty 2.8.0 - https://github.com/jeremyckahn/shifty */
!function(t,n){"object"==typeof exports&&"object"==typeof module?module.exports=n():"function"==typeof define&&define.amd?define("shifty",[],n):"object"==typeof exports?exports.shifty=n():t.shifty=n()}(window,function(){return function(t){var n={};function e(r){if(n[r])return n[r].exports;var i=n[r]={i:r,l:!1,exports:{}};return t[r].call(i.exports,i,i.exports,e),i.l=!0,i.exports}return e.m=t,e.c=n,e.d=function(t,n,r){e.o(t,n)||Object.defineProperty(t,n,{enumerable:!0,get:r})},e.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},e.t=function(t,n){if(1&n&&(t=e(t)),8&n)return t;if(4&n&&"object"==typeof t&&t&&t.__esModule)return t;var r=Object.create(null);if(e.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:t}),2&n&&"string"!=typeof t)for(var i in t)e.d(r,i,function(n){return t[n]}.bind(null,i));return r},e.n=function(t){var n=t&&t.__esModule?function(){return t.default}:function(){return t};return e.d(n,"a",n),n},e.o=function(t,n){return Object.prototype.hasOwnProperty.call(t,n)},e.p="",e(e.s=3)}([function(t,n,e){"use strict";(function(t){e.d(n,"e",function(){return d}),e.d(n,"c",function(){return y}),e.d(n,"b",function(){return _}),e.d(n,"a",function(){return g}),e.d(n,"d",function(){return w});var r=e(1);function i(t,n){for(var e=0;e<n.length;e++){var r=n[e];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}function u(t){return(u="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}function o(t){for(var n=1;n<arguments.length;n++){var e=null!=arguments[n]?arguments[n]:{},r=Object.keys(e);"function"==typeof Object.getOwnPropertySymbols&&(r=r.concat(Object.getOwnPropertySymbols(e).filter(function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.forEach(function(n){a(t,n,e[n])})}return t}function a(t,n,e){return n in t?Object.defineProperty(t,n,{value:e,enumerable:!0,configurable:!0,writable:!0}):t[n]=e,t}var c="undefined"!=typeof window?window:t,f=c.requestAnimationFrame||c.webkitRequestAnimationFrame||c.oRequestAnimationFrame||c.msRequestAnimationFrame||c.mozCancelRequestAnimationFrame&&c.mozRequestAnimationFrame||setTimeout,s=function(){},l=null,h=null,p=o({},r),d=function(t,n,e,r,i,u,o){var a=t<u?0:(t-u)/i;for(var c in n){var f=o[c],s=f.call?f:p[f],l=e[c];n[c]=l+(r[c]-l)*s(a)}return n},v=function(t,n){var e=t._attachment,r=t._currentState,i=t._delay,u=t._easing,o=t._originalState,a=t._duration,c=t._step,f=t._targetState,s=t._timestamp,l=s+i+a,h=n>l?l:n,p=a-(l-h);h>=l?(c(f,e,p),t.stop(!0)):(t._applyFilter("beforeTween"),h<s+i?(h=1,a=1,s=1):s+=i,d(h,r,o,f,a,s,u),t._applyFilter("afterTween"),c(r,e,p))},y=function(){for(var t=g.now(),n=l;n;){var e=n._next;v(n,t),n=e}},_=function(t){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"linear",e={},r=u(n);if("string"===r||"function"===r)for(var i in t)e[i]=n;else for(var o in t)e[o]=n[o]||"linear";return e},m=function(t){if(t===l)(l=t._next)?l._previous=null:h=null;else if(t===h)(h=t._previous)?h._next=null:l=null;else{var n=t._previous,e=t._next;n._next=e,e._previous=n}t._previous=t._next=null},g=function(){function t(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:void 0;!function(t,n){if(!(t instanceof n))throw new TypeError("Cannot call a class as a function")}(this,t),this._currentState=n,this._configured=!1,this._filters=[],this._timestamp=null,this._next=null,this._previous=null,e&&this.setConfig(e)}var n,e,r;return n=t,(e=[{key:"_applyFilter",value:function(t){var n=!0,e=!1,r=void 0;try{for(var i,u=this._filters[Symbol.iterator]();!(n=(i=u.next()).done);n=!0){var o=i.value[t];o&&o(this)}}catch(t){e=!0,r=t}finally{try{n||null==u.return||u.return()}finally{if(e)throw r}}}},{key:"tween",value:function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:void 0,e=this._attachment,r=this._configured;return!n&&r||this.setConfig(n),this._pausedAtTime=null,this._timestamp=t.now(),this._start(this.get(),e),this.resume()}},{key:"setConfig",value:function(){var n=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},r=e.attachment,i=e.delay,u=void 0===i?0:i,a=e.duration,c=void 0===a?500:a,f=e.easing,l=e.from,h=e.promise,p=void 0===h?Promise:h,d=e.start,v=void 0===d?s:d,y=e.step,m=void 0===y?s:y,g=e.to;this._configured=!0,this._attachment=r,this._isPlaying=!1,this._pausedAtTime=null,this._scheduleId=null,this._delay=u,this._start=v,this._step=m,this._duration=c,this._currentState=o({},l||this.get()),this._originalState=this.get(),this._targetState=o({},g||this.get());var w=this._currentState;this._targetState=o({},w,this._targetState),this._easing=_(w,f);var b=t.filters;for(var S in this._filters.length=0,b)b[S].doesApply(this)&&this._filters.push(b[S]);return this._applyFilter("tweenCreated"),this._promise=new p(function(t,e){n._resolve=t,n._reject=e}),this._promise.catch(s),this}},{key:"get",value:function(){return o({},this._currentState)}},{key:"set",value:function(t){this._currentState=t}},{key:"pause",value:function(){if(this._isPlaying)return this._pausedAtTime=t.now(),this._isPlaying=!1,m(this),this}},{key:"resume",value:function(){if(null===this._timestamp)return this.tween();if(this._isPlaying)return this._promise;var n=t.now();return this._pausedAtTime&&(this._timestamp+=n-this._pausedAtTime,this._pausedAtTime=null),this._isPlaying=!0,null===l?(l=this,h=this,function t(){l&&(f.call(c,t,1e3/60),y())}()):(this._previous=h,h._next=this,h=this),this._promise}},{key:"seek",value:function(n){n=Math.max(n,0);var e=t.now();return this._timestamp+n===0?this:(this._timestamp=e-n,this._isPlaying||v(this,e),this)}},{key:"stop",value:function(){var t=arguments.length>0&&void 0!==arguments[0]&&arguments[0],n=this._attachment,e=this._currentState,r=this._easing,i=this._originalState,u=this._targetState;if(this._isPlaying)return this._isPlaying=!1,m(this),t?(this._applyFilter("beforeTween"),d(1,e,i,u,1,0,r),this._applyFilter("afterTween"),this._applyFilter("afterTweenEnd"),this._resolve(e,n)):this._reject(e,n),this}},{key:"isPlaying",value:function(){return this._isPlaying}},{key:"setScheduleFunction",value:function(n){t.setScheduleFunction(n)}},{key:"dispose",value:function(){for(var t in this)delete this[t]}}])&&i(n.prototype,e),r&&i(n,r),t}();function w(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},n=new g,e=n.tween(t);return e.tweenable=n,e}g.setScheduleFunction=function(t){return f=t},g.formulas=p,g.filters={},g.now=Date.now||function(){return+new Date}}).call(this,e(2))},function(t,n,e){"use strict";e.r(n),e.d(n,"linear",function(){return r}),e.d(n,"easeInQuad",function(){return i}),e.d(n,"easeOutQuad",function(){return u}),e.d(n,"easeInOutQuad",function(){return o}),e.d(n,"easeInCubic",function(){return a}),e.d(n,"easeOutCubic",function(){return c}),e.d(n,"easeInOutCubic",function(){return f}),e.d(n,"easeInQuart",function(){return s}),e.d(n,"easeOutQuart",function(){return l}),e.d(n,"easeInOutQuart",function(){return h}),e.d(n,"easeInQuint",function(){return p}),e.d(n,"easeOutQuint",function(){return d}),e.d(n,"easeInOutQuint",function(){return v}),e.d(n,"easeInSine",function(){return y}),e.d(n,"easeOutSine",function(){return _}),e.d(n,"easeInOutSine",function(){return m}),e.d(n,"easeInExpo",function(){return g}),e.d(n,"easeOutExpo",function(){return w}),e.d(n,"easeInOutExpo",function(){return b}),e.d(n,"easeInCirc",function(){return S}),e.d(n,"easeOutCirc",function(){return O}),e.d(n,"easeInOutCirc",function(){return M}),e.d(n,"easeOutBounce",function(){return k}),e.d(n,"easeInBack",function(){return j}),e.d(n,"easeOutBack",function(){return P}),e.d(n,"easeInOutBack",function(){return x}),e.d(n,"elastic",function(){return T}),e.d(n,"swingFromTo",function(){return F}),e.d(n,"swingFrom",function(){return A}),e.d(n,"swingTo",function(){return E}),e.d(n,"bounce",function(){return I}),e.d(n,"bouncePast",function(){return C}),e.d(n,"easeFromTo",function(){return q}),e.d(n,"easeFrom",function(){return Q}),e.d(n,"easeTo",function(){return D});
/*!
 * All equations are adapted from Thomas Fuchs'
 * [Scripty2](https://github.com/madrobby/scripty2/blob/master/src/effects/transitions/penner.js).
 *
 * Based on Easing Equations (c) 2003 [Robert
 * Penner](http://www.robertpenner.com/), all rights reserved. This work is
 * [subject to terms](http://www.robertpenner.com/easing_terms_of_use.html).
 */
/*!
 *  TERMS OF USE - EASING EQUATIONS
 *  Open source under the BSD License.
 *  Easing Equations (c) 2003 Robert Penner, all rights reserved.
 */
var r=function(t){return t},i=function(t){return Math.pow(t,2)},u=function(t){return-(Math.pow(t-1,2)-1)},o=function(t){return(t/=.5)<1?.5*Math.pow(t,2):-.5*((t-=2)*t-2)},a=function(t){return Math.pow(t,3)},c=function(t){return Math.pow(t-1,3)+1},f=function(t){return(t/=.5)<1?.5*Math.pow(t,3):.5*(Math.pow(t-2,3)+2)},s=function(t){return Math.pow(t,4)},l=function(t){return-(Math.pow(t-1,4)-1)},h=function(t){return(t/=.5)<1?.5*Math.pow(t,4):-.5*((t-=2)*Math.pow(t,3)-2)},p=function(t){return Math.pow(t,5)},d=function(t){return Math.pow(t-1,5)+1},v=function(t){return(t/=.5)<1?.5*Math.pow(t,5):.5*(Math.pow(t-2,5)+2)},y=function(t){return 1-Math.cos(t*(Math.PI/2))},_=function(t){return Math.sin(t*(Math.PI/2))},m=function(t){return-.5*(Math.cos(Math.PI*t)-1)},g=function(t){return 0===t?0:Math.pow(2,10*(t-1))},w=function(t){return 1===t?1:1-Math.pow(2,-10*t)},b=function(t){return 0===t?0:1===t?1:(t/=.5)<1?.5*Math.pow(2,10*(t-1)):.5*(2-Math.pow(2,-10*--t))},S=function(t){return-(Math.sqrt(1-t*t)-1)},O=function(t){return Math.sqrt(1-Math.pow(t-1,2))},M=function(t){return(t/=.5)<1?-.5*(Math.sqrt(1-t*t)-1):.5*(Math.sqrt(1-(t-=2)*t)+1)},k=function(t){return t<1/2.75?7.5625*t*t:t<2/2.75?7.5625*(t-=1.5/2.75)*t+.75:t<2.5/2.75?7.5625*(t-=2.25/2.75)*t+.9375:7.5625*(t-=2.625/2.75)*t+.984375},j=function(t){var n=1.70158;return t*t*((n+1)*t-n)},P=function(t){var n=1.70158;return(t-=1)*t*((n+1)*t+n)+1},x=function(t){var n=1.70158;return(t/=.5)<1?t*t*((1+(n*=1.525))*t-n)*.5:.5*((t-=2)*t*((1+(n*=1.525))*t+n)+2)},T=function(t){return-1*Math.pow(4,-8*t)*Math.sin((6*t-1)*(2*Math.PI)/2)+1},F=function(t){var n=1.70158;return(t/=.5)<1?t*t*((1+(n*=1.525))*t-n)*.5:.5*((t-=2)*t*((1+(n*=1.525))*t+n)+2)},A=function(t){var n=1.70158;return t*t*((n+1)*t-n)},E=function(t){var n=1.70158;return(t-=1)*t*((n+1)*t+n)+1},I=function(t){return t<1/2.75?7.5625*t*t:t<2/2.75?7.5625*(t-=1.5/2.75)*t+.75:t<2.5/2.75?7.5625*(t-=2.25/2.75)*t+.9375:7.5625*(t-=2.625/2.75)*t+.984375},C=function(t){return t<1/2.75?7.5625*t*t:t<2/2.75?2-(7.5625*(t-=1.5/2.75)*t+.75):t<2.5/2.75?2-(7.5625*(t-=2.25/2.75)*t+.9375):2-(7.5625*(t-=2.625/2.75)*t+.984375)},q=function(t){return(t/=.5)<1?.5*Math.pow(t,4):-.5*((t-=2)*Math.pow(t,3)-2)},Q=function(t){return Math.pow(t,4)},D=function(t){return Math.pow(t,.25)}},function(t,n){var e;e=function(){return this}();try{e=e||new Function("return this")()}catch(t){"object"==typeof window&&(e=window)}t.exports=e},function(t,n,e){"use strict";e.r(n);var r={};e.r(r),e.d(r,"doesApply",function(){return x}),e.d(r,"tweenCreated",function(){return T}),e.d(r,"beforeTween",function(){return F}),e.d(r,"afterTween",function(){return A});var i,u,o=e(0),a=/(\d|-|\.)/,c=/([^\-0-9.]+)/g,f=/[0-9.-]+/g,s=(i=f.source,u=/,\s*/.source,new RegExp("rgb\\(".concat(i).concat(u).concat(i).concat(u).concat(i,"\\)"),"g")),l=/^.*\(/,h=/#([0-9]|[a-f]){3,6}/gi,p=function(t,n){return t.map(function(t,e){return"_".concat(n,"_").concat(e)})};function d(t){return parseInt(t,16)}var v=function(t){return"rgb(".concat((n=t,3===(n=n.replace(/#/,"")).length&&(n=(n=n.split(""))[0]+n[0]+n[1]+n[1]+n[2]+n[2]),[d(n.substr(0,2)),d(n.substr(2,2)),d(n.substr(4,2))]).join(","),")");var n},y=function(t,n,e){var r=n.match(t),i=n.replace(t,"VAL");return r&&r.forEach(function(t){return i=i.replace("VAL",e(t))}),i},_=function(t){for(var n in t){var e=t[n];"string"==typeof e&&e.match(h)&&(t[n]=y(h,e,v))}},m=function(t){var n=t.match(f).map(Math.floor),e=t.match(l)[0];return"".concat(e).concat(n.join(","),")")},g=function(t){return t.match(f)},w=function(t){var n,e,r={};for(var i in t){var u=t[i];"string"==typeof u&&(r[i]={formatString:(n=u,e=void 0,e=n.match(c),e?(1===e.length||n.charAt(0).match(a))&&e.unshift(""):e=["",""],e.join("VAL")),chunkNames:p(g(u),i)})}return r},b=function(t,n){var e=function(e){g(t[e]).forEach(function(r,i){return t[n[e].chunkNames[i]]=+r}),delete t[e]};for(var r in n)e(r)},S=function(t,n){var e={};return n.forEach(function(n){e[n]=t[n],delete t[n]}),e},O=function(t,n){return n.map(function(n){return t[n]})},M=function(t,n){return n.forEach(function(n){return t=t.replace("VAL",+n.toFixed(4))}),t},k=function(t,n){for(var e in n){var r=n[e],i=r.chunkNames,u=r.formatString,o=M(u,O(S(t,i),i));t[e]=y(s,o,m)}},j=function(t,n){var e=function(e){var r=n[e].chunkNames,i=t[e];if("string"==typeof i){var u=i.split(" "),o=u[u.length-1];r.forEach(function(n,e){return t[n]=u[e]||o})}else r.forEach(function(n){return t[n]=i});delete t[e]};for(var r in n)e(r)},P=function(t,n){for(var e in n){var r=n[e].chunkNames,i=t[r[0]];t[e]="string"==typeof i?r.map(function(n){var e=t[n];return delete t[n],e}).join(" "):i}},x=function(t){var n=t._currentState;return Object.keys(n).some(function(t){return"string"==typeof n[t]})};function T(t){var n=t._currentState;[n,t._originalState,t._targetState].forEach(_),t._tokenData=w(n)}function F(t){var n=t._currentState,e=t._originalState,r=t._targetState,i=t._easing,u=t._tokenData;j(i,u),[n,e,r].forEach(function(t){return b(t,u)})}function A(t){var n=t._currentState,e=t._originalState,r=t._targetState,i=t._easing,u=t._tokenData;[n,e,r].forEach(function(t){return k(t,u)}),P(i,u)}function E(t,n,e){return n in t?Object.defineProperty(t,n,{value:e,enumerable:!0,configurable:!0,writable:!0}):t[n]=e,t}var I=new o.a,C=o.a.filters,q=function(t,n,e,r){var i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,u=function(t){for(var n=1;n<arguments.length;n++){var e=null!=arguments[n]?arguments[n]:{},r=Object.keys(e);"function"==typeof Object.getOwnPropertySymbols&&(r=r.concat(Object.getOwnPropertySymbols(e).filter(function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.forEach(function(n){E(t,n,e[n])})}return t}({},t),a=Object(o.b)(t,r);for(var c in I._filters.length=0,I.set({}),I._currentState=u,I._originalState=t,I._targetState=n,I._easing=a,C)C[c].doesApply(I)&&I._filters.push(C[c]);I._applyFilter("tweenCreated"),I._applyFilter("beforeTween");var f=Object(o.e)(e,u,t,n,1,i,a);return I._applyFilter("afterTween"),f};function Q(t){return function(t){if(Array.isArray(t)){for(var n=0,e=new Array(t.length);n<t.length;n++)e[n]=t[n];return e}}(t)||function(t){if(Symbol.iterator in Object(t)||"[object Arguments]"===Object.prototype.toString.call(t))return Array.from(t)}(t)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance")}()}function D(t,n){for(var e=0;e<n.length;e++){var r=n[e];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}function B(t,n){if(!n.has(t))throw new TypeError("attempted to get private field on non-instance");var e=n.get(t);return e.get?e.get.call(t):e.value}var N=function(){function t(){!function(t,n){if(!(t instanceof n))throw new TypeError("Cannot call a class as a function")}(this,t),R.set(this,{writable:!0,value:[]});for(var n=arguments.length,e=new Array(n),r=0;r<n;r++)e[r]=arguments[r];e.forEach(this.add.bind(this))}var n,e,r;return n=t,(e=[{key:"add",value:function(t){return B(this,R).push(t),t}},{key:"remove",value:function(t){var n=B(this,R).indexOf(t);return~n&&B(this,R).splice(n,1),t}},{key:"empty",value:function(){return this.tweenables.map(this.remove.bind(this))}},{key:"isPlaying",value:function(){return B(this,R).some(function(t){return t.isPlaying()})}},{key:"play",value:function(){return B(this,R).forEach(function(t){return t.tween()}),this}},{key:"pause",value:function(){return B(this,R).forEach(function(t){return t.pause()}),this}},{key:"resume",value:function(){return B(this,R).forEach(function(t){return t.resume()}),this}},{key:"stop",value:function(t){return B(this,R).forEach(function(n){return n.stop(t)}),this}},{key:"tweenables",get:function(){return Q(B(this,R))}},{key:"promises",get:function(){return B(this,R).map(function(t){return t._promise})}}])&&D(n.prototype,e),r&&D(n,r),t}(),R=new WeakMap;function z(t,n,e,r,i,u){var o=0,a=0,c=0,f=0,s=0,l=0,h=function(t){return((o*t+a)*t+c)*t},p=function(t){return t>=0?t:0-t};return o=1-(c=3*n)-(a=3*(r-n)-c),f=1-(l=3*e)-(s=3*(i-e)-l),function(t,n){return e=function(t,n){var e,r,i,u,f,s,l;for(i=t,s=0;s<8;s++){if(u=h(i)-t,p(u)<n)return i;if(p(f=(3*o*(l=i)+2*a)*l+c)<1e-6)break;i-=u/f}if((i=t)<(e=0))return e;if(i>(r=1))return r;for(;e<r;){if(u=h(i),p(u-t)<n)return i;t>u?e=i:r=i,i=.5*(r-e)+e}return i}(t,n),((f*e+s)*e+l)*e;var e}(t,function(t){return 1/(200*t)}(u))}var L=function(t,n,e,r,i){var u=function(t,n,e,r){return function(i){return z(i,t,n,e,r,1)}}(n,e,r,i);return u.displayName=t,u.x1=n,u.y1=e,u.x2=r,u.y2=i,o.a.formulas[t]=u},V=function(t){return delete o.a.formulas[t]};e.d(n,"processTweens",function(){return o.c}),e.d(n,"Tweenable",function(){return o.a}),e.d(n,"tween",function(){return o.d}),e.d(n,"interpolate",function(){return q}),e.d(n,"Scene",function(){return N}),e.d(n,"setBezierFunction",function(){return L}),e.d(n,"unsetBezierFunction",function(){return V}),o.a.filters.token=r}])});

},{}],2:[function(require,module,exports){
// Circle shaped progress bar

var Shape = require('./shape');
var utils = require('./utils');

var Circle = function Circle(container, options) {
    // Use two arcs to form a circle
    // See this answer http://stackoverflow.com/a/10477334/1446092
    this._pathTemplate =
        'M 50,50 m 0,-{radius}' +
        ' a {radius},{radius} 0 1 1 0,{2radius}' +
        ' a {radius},{radius} 0 1 1 0,-{2radius}';

    this.containerAspectRatio = 1;

    Shape.apply(this, arguments);
};

Circle.prototype = new Shape();
Circle.prototype.constructor = Circle;

Circle.prototype._pathString = function _pathString(opts) {
    var widthOfWider = opts.strokeWidth;
    if (opts.trailWidth && opts.trailWidth > opts.strokeWidth) {
        widthOfWider = opts.trailWidth;
    }

    var r = 50 - widthOfWider / 2;

    return utils.render(this._pathTemplate, {
        radius: r,
        '2radius': r * 2
    });
};

Circle.prototype._trailString = function _trailString(opts) {
    return this._pathString(opts);
};

module.exports = Circle;

},{"./shape":7,"./utils":9}],3:[function(require,module,exports){
// Line shaped progress bar

var Shape = require('./shape');
var utils = require('./utils');

var Line = function Line(container, options) {
    this._pathTemplate = 'M 0,{center} L 100,{center}';
    Shape.apply(this, arguments);
};

Line.prototype = new Shape();
Line.prototype.constructor = Line;

Line.prototype._initializeSvg = function _initializeSvg(svg, opts) {
    svg.setAttribute('viewBox', '0 0 100 ' + opts.strokeWidth);
    svg.setAttribute('preserveAspectRatio', 'none');
};

Line.prototype._pathString = function _pathString(opts) {
    return utils.render(this._pathTemplate, {
        center: opts.strokeWidth / 2
    });
};

Line.prototype._trailString = function _trailString(opts) {
    return this._pathString(opts);
};

module.exports = Line;

},{"./shape":7,"./utils":9}],4:[function(require,module,exports){
module.exports = {
    // Higher level API, different shaped progress bars
    Line: require('./line'),
    Circle: require('./circle'),
    SemiCircle: require('./semicircle'),
    Square: require('./square'),

    // Lower level API to use any SVG path
    Path: require('./path'),

    // Base-class for creating new custom shapes
    // to be in line with the API of built-in shapes
    // Undocumented.
    Shape: require('./shape'),

    // Internal utils, undocumented.
    utils: require('./utils')
};

},{"./circle":2,"./line":3,"./path":5,"./semicircle":6,"./shape":7,"./square":8,"./utils":9}],5:[function(require,module,exports){
// Lower level API to animate any kind of svg path

var shifty = require('shifty');
var utils = require('./utils');

var Tweenable = shifty.Tweenable;

var EASING_ALIASES = {
    easeIn: 'easeInCubic',
    easeOut: 'easeOutCubic',
    easeInOut: 'easeInOutCubic'
};

var Path = function Path(path, opts) {
    // Throw a better error if not initialized with `new` keyword
    if (!(this instanceof Path)) {
        throw new Error('Constructor was called without new keyword');
    }

    // Default parameters for animation
    opts = utils.extend({
        delay: 0,
        duration: 800,
        easing: 'linear',
        from: {},
        to: {},
        step: function() {}
    }, opts);

    var element;
    if (utils.isString(path)) {
        element = document.querySelector(path);
    } else {
        element = path;
    }

    // Reveal .path as public attribute
    this.path = element;
    this._opts = opts;
    this._tweenable = null;

    // Set up the starting positions
    var length = this.path.getTotalLength();
    this.path.style.strokeDasharray = length + ' ' + length;
    this.set(0);
};

Path.prototype.value = function value() {
    var offset = this._getComputedDashOffset();
    var length = this.path.getTotalLength();

    var progress = 1 - offset / length;
    // Round number to prevent returning very small number like 1e-30, which
    // is practically 0
    return parseFloat(progress.toFixed(6), 10);
};

Path.prototype.set = function set(progress) {
    this.stop();

    this.path.style.strokeDashoffset = this._progressToOffset(progress);

    var step = this._opts.step;
    if (utils.isFunction(step)) {
        var easing = this._easing(this._opts.easing);
        var values = this._calculateTo(progress, easing);
        var reference = this._opts.shape || this;
        step(values, reference, this._opts.attachment);
    }
};

Path.prototype.stop = function stop() {
    this._stopTween();
    this.path.style.strokeDashoffset = this._getComputedDashOffset();
};

// Method introduced here:
// http://jakearchibald.com/2013/animated-line-drawing-svg/
Path.prototype.animate = function animate(progress, opts, cb) {
    opts = opts || {};

    if (utils.isFunction(opts)) {
        cb = opts;
        opts = {};
    }

    var passedOpts = utils.extend({}, opts);

    // Copy default opts to new object so defaults are not modified
    var defaultOpts = utils.extend({}, this._opts);
    opts = utils.extend(defaultOpts, opts);

    var shiftyEasing = this._easing(opts.easing);
    var values = this._resolveFromAndTo(progress, shiftyEasing, passedOpts);

    this.stop();

    // Trigger a layout so styles are calculated & the browser
    // picks up the starting position before animating
    this.path.getBoundingClientRect();

    var offset = this._getComputedDashOffset();
    var newOffset = this._progressToOffset(progress);

    var self = this;
    this._tweenable = new Tweenable();
    this._tweenable.tween({
        from: utils.extend({ offset: offset }, values.from),
        to: utils.extend({ offset: newOffset }, values.to),
        duration: opts.duration,
        delay: opts.delay,
        easing: shiftyEasing,
        step: function(state) {
            self.path.style.strokeDashoffset = state.offset;
            var reference = opts.shape || self;
            opts.step(state, reference, opts.attachment);
        }
    }).then(function(state) {
        if (utils.isFunction(cb)) {
            cb();
        }
    }).catch(function(error) {}); // tag 10052020
};

Path.prototype._getComputedDashOffset = function _getComputedDashOffset() {
    var computedStyle = window.getComputedStyle(this.path, null);
    // tag start 09052020
    var strokeDashOffset = computedStyle.getPropertyValue('stroke-dashoffset');
    return strokeDashOffset? parseFloat(strokeDashOffset, 10): 0;
    // tag end 09052020
};

Path.prototype._progressToOffset = function _progressToOffset(progress) {
    var length = this.path.getTotalLength();
    return length - progress * length;
};

// Resolves from and to values for animation.
Path.prototype._resolveFromAndTo = function _resolveFromAndTo(progress, easing, opts) {
    if (opts.from && opts.to) {
        return {
            from: opts.from,
            to: opts.to
        };
    }

    return {
        from: this._calculateFrom(easing),
        to: this._calculateTo(progress, easing)
    };
};

// Calculate `from` values from options passed at initialization
Path.prototype._calculateFrom = function _calculateFrom(easing) {
    return shifty.interpolate(this._opts.from, this._opts.to, this.value(), easing);
};

// Calculate `to` values from options passed at initialization
Path.prototype._calculateTo = function _calculateTo(progress, easing) {
    return shifty.interpolate(this._opts.from, this._opts.to, progress, easing);
};

Path.prototype._stopTween = function _stopTween() {
    if (this._tweenable !== null) {
        this._tweenable.stop();
        this._tweenable = null;
    }
};

Path.prototype._easing = function _easing(easing) {
    if (EASING_ALIASES.hasOwnProperty(easing)) {
        return EASING_ALIASES[easing];
    }

    return easing;
};

module.exports = Path;

},{"./utils":9,"shifty":1}],6:[function(require,module,exports){
// Semi-SemiCircle shaped progress bar

var Shape = require('./shape');
var Circle = require('./circle');
var utils = require('./utils');

var SemiCircle = function SemiCircle(container, options) {
    // Use one arc to form a SemiCircle
    // See this answer http://stackoverflow.com/a/10477334/1446092
    this._pathTemplate =
        'M 50,50 m -{radius},0' +
        ' a {radius},{radius} 0 1 1 {2radius},0';

    this.containerAspectRatio = 2;

    Shape.apply(this, arguments);
};

SemiCircle.prototype = new Shape();
SemiCircle.prototype.constructor = SemiCircle;

SemiCircle.prototype._initializeSvg = function _initializeSvg(svg, opts) {
    svg.setAttribute('viewBox', '0 0 100 50');
};

SemiCircle.prototype._initializeTextContainer = function _initializeTextContainer(
    opts,
    container,
    textContainer
) {
    if (opts.text.style) {
        // Reset top style
        textContainer.style.top = 'auto';
        textContainer.style.bottom = '0';

        if (opts.text.alignToBottom) {
            utils.setStyle(textContainer, 'transform', 'translate(-50%, 0)');
        } else {
            utils.setStyle(textContainer, 'transform', 'translate(-50%, 50%)');
        }
    }
};

// Share functionality with Circle, just have different path
SemiCircle.prototype._pathString = Circle.prototype._pathString;
SemiCircle.prototype._trailString = Circle.prototype._trailString;

module.exports = SemiCircle;

},{"./circle":2,"./shape":7,"./utils":9}],7:[function(require,module,exports){
// Base object for different progress bar shapes

var Path = require('./path');
var utils = require('./utils');

var DESTROYED_ERROR = 'Object is destroyed';

var Shape = function Shape(container, opts) {
    // Throw a better error if progress bars are not initialized with `new`
    // keyword
    if (!(this instanceof Shape)) {
        throw new Error('Constructor was called without new keyword');
    }

    // Prevent calling constructor without parameters so inheritance
    // works correctly. To understand, this is how Shape is inherited:
    //
    //   Line.prototype = new Shape();
    //
    // We just want to set the prototype for Line.
    if (arguments.length === 0) {
        return;
    }

    // Default parameters for progress bar creation
    this._opts = utils.extend({
        color: '#555',
        strokeWidth: 1.0,
        trailColor: null,
        trailWidth: null,
        fill: null,
        text: {
            style: {
                color: null,
                position: 'absolute',
                left: '50%',
                top: '50%',
                padding: 0,
                margin: 0,
                transform: {
                    prefix: true,
                    value: 'translate(-50%, -50%)'
                }
            },
            autoStyleContainer: true,
            alignToBottom: true,
            value: null,
            className: 'progressbar-text'
        },
        svgStyle: {
            display: 'block',
            width: '100%'
        },
        warnings: false
    }, opts, true);  // Use recursive extend

    // If user specifies e.g. svgStyle or text style, the whole object
    // should replace the defaults to make working with styles easier
    if (utils.isObject(opts) && opts.svgStyle !== undefined) {
        this._opts.svgStyle = opts.svgStyle;
    }
    if (utils.isObject(opts) && utils.isObject(opts.text) && opts.text.style !== undefined) {
        this._opts.text.style = opts.text.style;
    }

    var svgView = this._createSvgView(this._opts);

    var element;
    if (utils.isString(container)) {
        element = document.querySelector(container);
    } else {
        element = container;
    }

    if (!element) {
        throw new Error('Container does not exist: ' + container);
    }

    this._container = element;
    this._container.appendChild(svgView.svg);
    if (this._opts.warnings) {
        this._warnContainerAspectRatio(this._container);
    }

    if (this._opts.svgStyle) {
        utils.setStyles(svgView.svg, this._opts.svgStyle);
    }

    // Expose public attributes before Path initialization
    this.svg = svgView.svg;
    this.path = svgView.path;
    this.trail = svgView.trail;
    this.text = null;

    var newOpts = utils.extend({
        attachment: undefined,
        shape: this
    }, this._opts);
    this._progressPath = new Path(svgView.path, newOpts);

    if (utils.isObject(this._opts.text) && this._opts.text.value !== null) {
        this.setText(this._opts.text.value);
    }
};

Shape.prototype.animate = function animate(progress, opts, cb) {
    if (this._progressPath === null) {
        throw new Error(DESTROYED_ERROR);
    }

    this._progressPath.animate(progress, opts, cb);
};

Shape.prototype.stop = function stop() {
    if (this._progressPath === null) {
        throw new Error(DESTROYED_ERROR);
    }

    // Don't crash if stop is called inside step function
    if (this._progressPath === undefined) {
        return;
    }

    this._progressPath.stop();
};

Shape.prototype.pause = function pause() {
    if (this._progressPath === null) {
        throw new Error(DESTROYED_ERROR);
    }

    if (this._progressPath === undefined) {
        return;
    }

    if (!this._progressPath._tweenable) {
        // It seems that we can't pause this
        return;
    }

    this._progressPath._tweenable.pause();
};

Shape.prototype.resume = function resume() {
    if (this._progressPath === null) {
        throw new Error(DESTROYED_ERROR);
    }

    if (this._progressPath === undefined) {
        return;
    }

    if (!this._progressPath._tweenable) {
        // It seems that we can't resume this
        return;
    }

    this._progressPath._tweenable.resume();
};

Shape.prototype.destroy = function destroy() {
    if (this._progressPath === null) {
        throw new Error(DESTROYED_ERROR);
    }

    this.stop();
    this.svg.parentNode.removeChild(this.svg);
    this.svg = null;
    this.path = null;
    this.trail = null;
    this._progressPath = null;

    if (this.text !== null) {
        this.text.parentNode.removeChild(this.text);
        this.text = null;
    }
};

Shape.prototype.set = function set(progress) {
    if (this._progressPath === null) {
        throw new Error(DESTROYED_ERROR);
    }

    this._progressPath.set(progress);
};

Shape.prototype.value = function value() {
    if (this._progressPath === null) {
        throw new Error(DESTROYED_ERROR);
    }

    if (this._progressPath === undefined) {
        return 0;
    }

    return this._progressPath.value();
};

Shape.prototype.setText = function setText(newText) {
    if (this._progressPath === null) {
        throw new Error(DESTROYED_ERROR);
    }

    if (this.text === null) {
        // Create new text node
        this.text = this._createTextContainer(this._opts, this._container);
        this._container.appendChild(this.text);
    }

    // Remove previous text and add new
    if (utils.isObject(newText)) {
        utils.removeChildren(this.text);
        this.text.appendChild(newText);
    } else {
        this.text.innerHTML = newText;
    }
};

Shape.prototype._createSvgView = function _createSvgView(opts) {
    var svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    this._initializeSvg(svg, opts);

    var trailPath = null;
    // Each option listed in the if condition are 'triggers' for creating
    // the trail path
    if (opts.trailColor || opts.trailWidth) {
        trailPath = this._createTrail(opts);
        svg.appendChild(trailPath);
    }

    var path = this._createPath(opts);
    svg.appendChild(path);

    return {
        svg: svg,
        path: path,
        trail: trailPath
    };
};

Shape.prototype._initializeSvg = function _initializeSvg(svg, opts) {
    svg.setAttribute('viewBox', '0 0 100 100');
};

Shape.prototype._createPath = function _createPath(opts) {
    var pathString = this._pathString(opts);
    return this._createPathElement(pathString, opts);
};

Shape.prototype._createTrail = function _createTrail(opts) {
    // Create path string with original passed options
    var pathString = this._trailString(opts);

    // Prevent modifying original
    var newOpts = utils.extend({}, opts);

    // Defaults for parameters which modify trail path
    if (!newOpts.trailColor) {
        newOpts.trailColor = '#eee';
    }
    if (!newOpts.trailWidth) {
        newOpts.trailWidth = newOpts.strokeWidth;
    }

    newOpts.color = newOpts.trailColor;
    newOpts.strokeWidth = newOpts.trailWidth;

    // When trail path is set, fill must be set for it instead of the
    // actual path to prevent trail stroke from clipping
    newOpts.fill = null;

    return this._createPathElement(pathString, newOpts);
};

Shape.prototype._createPathElement = function _createPathElement(pathString, opts) {
    var path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    path.setAttribute('d', pathString);
    path.setAttribute('stroke', opts.color);
    path.setAttribute('stroke-width', opts.strokeWidth);

    if (opts.fill) {
        path.setAttribute('fill', opts.fill);
    } else {
        path.setAttribute('fill-opacity', '0');
    }

    return path;
};

Shape.prototype._createTextContainer = function _createTextContainer(opts, container) {
    var textContainer = document.createElement('div');
    textContainer.className = opts.text.className;

    var textStyle = opts.text.style;
    if (textStyle) {
        if (opts.text.autoStyleContainer) {
            container.style.position = 'relative';
        }

        utils.setStyles(textContainer, textStyle);
        // Default text color to progress bar's color
        if (!textStyle.color) {
            textContainer.style.color = opts.color;
        }
    }

    this._initializeTextContainer(opts, container, textContainer);
    return textContainer;
};

// Give custom shapes possibility to modify text element
Shape.prototype._initializeTextContainer = function(opts, container, element) {
    // By default, no-op
    // Custom shapes should respect API options, such as text.style
};

Shape.prototype._pathString = function _pathString(opts) {
    throw new Error('Override this function for each progress bar');
};

Shape.prototype._trailString = function _trailString(opts) {
    throw new Error('Override this function for each progress bar');
};

Shape.prototype._warnContainerAspectRatio = function _warnContainerAspectRatio(container) {
    if (!this.containerAspectRatio) {
        return;
    }

    var computedStyle = window.getComputedStyle(container, null);
    var width = parseFloat(computedStyle.getPropertyValue('width'), 10);
    var height = parseFloat(computedStyle.getPropertyValue('height'), 10);
    if (!utils.floatEquals(this.containerAspectRatio, width / height)) {
        console.warn(
            'Incorrect aspect ratio of container',
            '#' + container.id,
            'detected:',
            computedStyle.getPropertyValue('width') + '(width)',
            '/',
            computedStyle.getPropertyValue('height') + '(height)',
            '=',
            width / height
        );

        console.warn(
            'Aspect ratio of should be',
            this.containerAspectRatio
        );
    }
};

module.exports = Shape;

},{"./path":5,"./utils":9}],8:[function(require,module,exports){
// Square shaped progress bar
// Note: Square is not core part of API anymore. It's left here
//       for reference. square is not included to the progressbar
//       build anymore

var Shape = require('./shape');
var utils = require('./utils');

var Square = function Square(container, options) {
    this._pathTemplate =
        'M 0,{halfOfStrokeWidth}' +
        ' L {width},{halfOfStrokeWidth}' +
        ' L {width},{width}' +
        ' L {halfOfStrokeWidth},{width}' +
        ' L {halfOfStrokeWidth},{strokeWidth}';

    this._trailTemplate =
        'M {startMargin},{halfOfStrokeWidth}' +
        ' L {width},{halfOfStrokeWidth}' +
        ' L {width},{width}' +
        ' L {halfOfStrokeWidth},{width}' +
        ' L {halfOfStrokeWidth},{halfOfStrokeWidth}';

    Shape.apply(this, arguments);
};

Square.prototype = new Shape();
Square.prototype.constructor = Square;

Square.prototype._pathString = function _pathString(opts) {
    var w = 100 - opts.strokeWidth / 2;

    return utils.render(this._pathTemplate, {
        width: w,
        strokeWidth: opts.strokeWidth,
        halfOfStrokeWidth: opts.strokeWidth / 2
    });
};

Square.prototype._trailString = function _trailString(opts) {
    var w = 100 - opts.strokeWidth / 2;

    return utils.render(this._trailTemplate, {
        width: w,
        strokeWidth: opts.strokeWidth,
        halfOfStrokeWidth: opts.strokeWidth / 2,
        startMargin: opts.strokeWidth / 2 - opts.trailWidth / 2
    });
};

module.exports = Square;

},{"./shape":7,"./utils":9}],9:[function(require,module,exports){
// Utility functions

var PREFIXES = 'Webkit Moz O ms'.split(' ');
var FLOAT_COMPARISON_EPSILON = 0.001;

// Copy all attributes from source object to destination object.
// destination object is mutated.
function extend(destination, source, recursive) {
    destination = destination || {};
    source = source || {};
    recursive = recursive || false;

    for (var attrName in source) {
        if (source.hasOwnProperty(attrName)) {
            var destVal = destination[attrName];
            var sourceVal = source[attrName];
            if (recursive && isObject(destVal) && isObject(sourceVal)) {
                destination[attrName] = extend(destVal, sourceVal, recursive);
            } else {
                destination[attrName] = sourceVal;
            }
        }
    }

    return destination;
}

// Renders templates with given variables. Variables must be surrounded with
// braces without any spaces, e.g. {variable}
// All instances of variable placeholders will be replaced with given content
// Example:
// render('Hello, {message}!', {message: 'world'})
function render(template, vars) {
    var rendered = template;

    for (var key in vars) {
        if (vars.hasOwnProperty(key)) {
            var val = vars[key];
            var regExpString = '\\{' + key + '\\}';
            var regExp = new RegExp(regExpString, 'g');

            rendered = rendered.replace(regExp, val);
        }
    }

    return rendered;
}

function setStyle(element, style, value) {
    var elStyle = element.style;  // cache for performance

    for (var i = 0; i < PREFIXES.length; ++i) {
        var prefix = PREFIXES[i];
        elStyle[prefix + capitalize(style)] = value;
    }

    elStyle[style] = value;
}

function setStyles(element, styles) {
    forEachObject(styles, function(styleValue, styleName) {
        // Allow disabling some individual styles by setting them
        // to null or undefined
        if (styleValue === null || styleValue === undefined) {
            return;
        }

        // If style's value is {prefix: true, value: '50%'},
        // Set also browser prefixed styles
        if (isObject(styleValue) && styleValue.prefix === true) {
            setStyle(element, styleName, styleValue.value);
        } else {
            element.style[styleName] = styleValue;
        }
    });
}

function capitalize(text) {
    return text.charAt(0).toUpperCase() + text.slice(1);
}

function isString(obj) {
    return typeof obj === 'string' || obj instanceof String;
}

function isFunction(obj) {
    return typeof obj === 'function';
}

function isArray(obj) {
    return Object.prototype.toString.call(obj) === '[object Array]';
}

// Returns true if `obj` is object as in {a: 1, b: 2}, not if it's function or
// array
function isObject(obj) {
    if (isArray(obj)) {
        return false;
    }

    var type = typeof obj;
    return type === 'object' && !!obj;
}

function forEachObject(object, callback) {
    for (var key in object) {
        if (object.hasOwnProperty(key)) {
            var val = object[key];
            callback(val, key);
        }
    }
}

function floatEquals(a, b) {
    return Math.abs(a - b) < FLOAT_COMPARISON_EPSILON;
}

// https://coderwall.com/p/nygghw/don-t-use-innerhtml-to-empty-dom-elements
function removeChildren(el) {
    while (el.firstChild) {
        el.removeChild(el.firstChild);
    }
}

module.exports = {
    extend: extend,
    render: render,
    setStyle: setStyle,
    setStyles: setStyles,
    capitalize: capitalize,
    isString: isString,
    isFunction: isFunction,
    isObject: isObject,
    forEachObject: forEachObject,
    floatEquals: floatEquals,
    removeChildren: removeChildren
};

},{}]},{},[4])(4)
});



// file: /bitrix/js/ui/progressbarjs/uploader/dist/uploader.bundle.js
this.BX = this.BX || {};
(function (exports) {
	'use strict';

	var Uploader = /*#__PURE__*/function () {
	  function Uploader() {
	    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	    babelHelpers.classCallCheck(this, Uploader);
	    this.container = params.container;

	    if (this.container && typeof params.blurElement === 'undefined') {
	      params.blurElement = this.container.firstElementChild;
	    }

	    this.blurElement = params.blurElement;
	    this.direction = Uploader.direction[params.direction] ? params.direction : Uploader.direction.vertical;
	    params.sizes = params.sizes && babelHelpers["typeof"](params.sizes) === 'object' ? params.sizes : {};
	    this.sizes = {
	      circle: params.sizes.circle ? params.sizes.circle : 54,
	      progress: params.sizes.progress ? params.sizes.progress : 4,
	      margin: params.sizes.margin ? params.sizes.margin : 0
	    };
	    params.labels = params.labels && babelHelpers["typeof"](params.labels) === 'object' ? params.labels : {};
	    this.labels = {
	      loading: params.labels.loading ? params.labels.loading : '',
	      completed: params.labels.completed ? params.labels.completed : '',
	      canceled: params.labels.canceled ? params.labels.canceled : '',
	      cancelTitle: params.labels.cancelTitle ? params.labels.cancelTitle : '',
	      megabyte: params.labels.megabyte ? params.labels.megabyte : 'MB'
	    };
	    this.cancelCallback = typeof params.cancelCallback === 'function' ? params.cancelCallback : null;
	    this.destroyCallback = typeof params.destroyCallback === 'function' ? params.destroyCallback : null;
	    this.icon = Uploader.icon[params.icon] ? params.icon : !this.cancelCallback ? Uploader.icon.cloud : Uploader.icon.cancel;
	    this.inited = !!this.container;
	    this.destroing = false;
	  }

	  babelHelpers.createClass(Uploader, [{
	    key: "start",
	    value: function start() {
	      var _this = this;

	      if (!this.inited) {
	        return false;
	      }

	      clearTimeout(this.timeoutSetIcon);
	      clearTimeout(this.timeout);
	      this.active = true;
	      this.canceled = false;
	      this.cancelCallbackDisabled = false;
	      this.wrapper = document.createElement('div');
	      this.wrapper.classList.add('ui-file-progressbar-loader-wrapper');
	      this.wrapper.innerHTML = "\n\t\t\t<div class=\"ui-file-progressbar-loader\">\n\t\t\t\t<div class=\"ui-file-progressbar-icon\"></div>\n\t\t\t\t<div class=\"ui-file-progressbar-progress ui-file-progressbar-rotating\"></div>\n\t\t\t</div>\n\t\t\t<div class=\"ui-file-progressbar-label\">".concat(this.labels.loading, "</div>\n\t\t");
	      this.processLoader = this.wrapper.getElementsByClassName('ui-file-progressbar-loader')[0];
	      this.processLoaderIcon = this.wrapper.getElementsByClassName('ui-file-progressbar-icon')[0];
	      this.processStatus = this.wrapper.getElementsByClassName('ui-file-progressbar-progress')[0];
	      this.proccesLabel = this.wrapper.getElementsByClassName('ui-file-progressbar-label')[0];

	      if (this.direction === Uploader.direction.horizontal) {
	        this.wrapper.classList.add('ui-file-progressbar-loader-horizontal');
	      }

	      this.container.classList.add('ui-file-progressbar-container-relative');
	      this.container.insertBefore(this.wrapper, this.container.firstChild);

	      if (this.blurElement) {
	        this.blurElement.classList.add("ui-file-progressbar-item-blurred");
	      }

	      var processLoaderStyle = "width: ".concat(this.sizes.circle, "px; height: ").concat(this.sizes.circle, "px;");

	      if (this.sizes.margin) {
	        processLoaderStyle = processLoaderStyle + "margin: ".concat(this.sizes.margin, "px;");
	        this.proccesLabel.style = "margin: ".concat(this.sizes.margin, "px;");
	      }

	      this.processLoader.style = processLoaderStyle;

	      if (this.cancelCallback) {
	        this.processLoader.addEventListener('click', function (event) {
	          if (_this.cancelCallbackDisabled) {
	            return false;
	          }

	          _this.setProgress(0);

	          if (_this.labels.canceled) {
	            _this.setProgressTitle(_this.labels.canceled);
	          }

	          _this.canceled = event;
	          _this.active = false;
	          clearTimeout(_this.timeout);
	          _this.timeout = setTimeout(function () {
	            return _this.destroy();
	          }, 1000);
	          return true;
	        });

	        if (this.labels.cancelTitle) {
	          this.processLoader.title = this.labels.cancelTitle;
	        }
	      }

	      if (!this.labels.loading) {
	        this.setProgressTitleVisibility(false);
	      }

	      this.setIcon(this.icon, true);
	      this.bar = new BX.ProgressBarJs.Circle(this.processStatus, {
	        easing: "linear",
	        strokeWidth: this.sizes.progress,
	        color: '#ffffff',
	        from: {
	          color: '#ffffff'
	        },
	        to: {
	          color: '#ffffff'
	        },
	        step: function step(state, bar) {
	          if (bar.value() == 1) {
	            clearTimeout(_this.timeout);
	            _this.timeout = setTimeout(function () {
	              if (_this.labels.completed) {
	                _this.setProgressTitle(_this.labels.completed);
	              }

	              _this.setIcon(Uploader.icon.done);

	              clearTimeout(_this.timeout);
	              _this.timeout = setTimeout(function () {
	                return _this.destroy();
	              }, 1000);
	            }, 200);
	          }
	        }
	      });
	    }
	  }, {
	    key: "setCancelDisable",
	    value: function setCancelDisable() {
	      var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
	      this.cancelCallbackDisabled = !!value;

	      if (this.labels.cancelTitle) {
	        this.processLoader.title = this.cancelCallbackDisabled ? '' : this.labels.cancelTitle;
	      }
	    }
	  }, {
	    key: "setIcon",
	    value: function setIcon(icon) {
	      var _this2 = this;

	      var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
	      this.processLoaderIcon.style.transform = "scale(0)";
	      clearTimeout(this.timeoutSetIcon);
	      this.timeoutSetIcon = setTimeout(function () {
	        _this2.processLoaderIcon.classList.remove("ui-file-progressbar-cancel", "ui-file-progressbar-done", "ui-file-progressbar-cloud", "ui-file-progressbar-error");

	        if (icon === Uploader.icon.done) {
	          _this2.processLoaderIcon.classList.add("ui-file-progressbar-done");

	          _this2.processLoaderIcon.style.transform = "scale(1)";
	        } else if (icon === Uploader.icon.cancel) {
	          _this2.processLoaderIcon.classList.add("ui-file-progressbar-cancel");

	          _this2.processLoaderIcon.style.transform = "scale(1)";
	        } else if (icon === Uploader.icon.error) {
	          _this2.processLoaderIcon.classList.add("ui-file-progressbar-error");

	          _this2.processLoaderIcon.style.transform = "scale(1)";
	        } else {
	          _this2.processLoaderIcon.classList.add("ui-file-progressbar-cloud");

	          _this2.processLoaderIcon.style.transform = "scale(1)";
	        }
	      }, force ? 0 : 200);
	      return true;
	    }
	  }, {
	    key: "setProgress",
	    value: function setProgress(percent) {
	      if (!this.active || this.canceled) {
	        return false;
	      }

	      this.bar.animate(percent / 100, {
	        duration: 500
	      });
	    }
	  }, {
	    key: "setProgressTitle",
	    value: function setProgressTitle(text) {
	      if (!this.proccesLabel) {
	        return false;
	      }

	      this.proccesLabel.innerHTML = text;
	    }
	  }, {
	    key: "setProgressTitleVisibility",
	    value: function setProgressTitleVisibility(visible) {
	      if (!this.proccesLabel) {
	        return;
	      }

	      if (visible) {
	        if (this.direction === Uploader.direction.horizontal) {
	          this.wrapper.classList.add('ui-file-progressbar-loader-horizontal');
	        }

	        this.proccesLabel.style.display = 'block';
	      } else {
	        if (this.direction === Uploader.direction.horizontal) {
	          this.wrapper.classList.remove('ui-file-progressbar-loader-horizontal');
	        }

	        this.proccesLabel.style.display = 'none';
	      }
	    }
	  }, {
	    key: "setByteSent",
	    value: function setByteSent(sent, total) {
	      if (this.canceled) {
	        return false;
	      }

	      this.setProgressTitle((sent / 1024 / 1024).toFixed(2) + " " + this.labels.megabyte + " " + " / " + (total / 1024 / 1024).toFixed(2) + " " + this.labels.megabyte);
	    }
	  }, {
	    key: "destroy",
	    value: function destroy() {
	      var _this3 = this;

	      var animated = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
	      clearTimeout(this.timeoutSetIcon);
	      clearTimeout(this.timeout);

	      if (this.destroing) {
	        return true;
	      }

	      this.active = false;
	      this.destroing = true;
	      this.processLoader.style.transform = "scale(0)";

	      if (this.proccesLabel) {
	        this.proccesLabel.style.transform = "scale(0)";
	      }

	      if (this.bar) {
	        this.bar.destroy();
	      }

	      if (this.blurElement) {
	        this.blurElement.classList.remove("ui-file-progressbar-item-blurred");
	      }

	      if (this.canceled && !this.cancelCallbackDisabled) {
	        if (this.cancelCallback) {
	          this.cancelCallback(this.canceled);
	        }

	        this.canceled = false;
	      }

	      if (animated) {
	        this.timeout = setTimeout(function () {
	          return _this3.destroyFinally();
	        }, 400);
	      } else {
	        this.destroyFinally();
	      }
	    }
	  }, {
	    key: "destroyFinally",
	    value: function destroyFinally() {
	      if (this.container) {
	        this.container.classList.remove('ui-file-progressbar-container-relative');
	        this.container.removeChild(this.wrapper);
	      }

	      if (this.destroyCallback) {
	        this.destroyCallback();
	      }
	    }
	  }]);
	  return Uploader;
	}();
	Uploader.direction = {
	  horizontal: 'horizontal',
	  vertical: 'vertical'
	};
	Uploader.icon = {
	  cloud: 'cloud',
	  cancel: 'cancel',
	  error: 'error',
	  done: 'done'
	};

	exports.Uploader = Uploader;

}((this.BX.ProgressBarJs = this.BX.ProgressBarJs || {})));
 




// file: /bitrix/js/main/md5/dist/md5.bundle.js
(function (exports) {
  'use strict';

  /**
   * [js-md5]{@link https://github.com/emn178/js-md5}
   *
   * @namespace md5
   * @version 0.7.3
   * @author Chen, Yi-Cyuan [emn178@gmail.com]
   * @copyright Chen, Yi-Cyuan 2014-2017
   * @license MIT
   */

  /**
   * Modify list for integration with Bitrix Framework:
   * - removed integration with third-party package builders;
   * - add import & export for work in Bitrix CoreJS extensions;
   */

  /**
   * @method md5
   * @description Md5 hash function, export to global in browsers.
   * @param {String|Array|Uint8Array|ArrayBuffer} message message to hash
   * @returns {String} md5 hashes
   * @example
   * md5(''); // d41d8cd98f00b204e9800998ecf8427e
   * md5('The quick brown fox jumps over the lazy dog'); // 9e107d9d372bb6826bd81d3542a419d6
   * md5('The quick brown fox jumps over the lazy dog.'); // e4d909c290d0fb1ca068ffaddf22cbd0
   *
   * // It also supports UTF-8 encoding
   * md5('??'); // a7bac2239fcdcb3a067903d8077c4a07
   *
   * // It also supports byte `Array`, `Uint8Array`, `ArrayBuffer`
   * md5([]); // d41d8cd98f00b204e9800998ecf8427e
   * md5(new Uint8Array([])); // d41d8cd98f00b204e9800998ecf8427e
   */
  var md5 = function () {

    var ERROR = 'input is invalid type';
    var WINDOW = (typeof window === "undefined" ? "undefined" : babelHelpers.typeof(window)) === 'object';
    var root = WINDOW ? window : {};

    if (root.JS_MD5_NO_WINDOW) {
      WINDOW = false;
    }

    var WEB_WORKER = !WINDOW && (typeof self === "undefined" ? "undefined" : babelHelpers.typeof(self)) === 'object';
    var NODE_JS = !root.JS_MD5_NO_NODE_JS && (typeof process === "undefined" ? "undefined" : babelHelpers.typeof(process)) === 'object' && process.versions && process.versions.node;

    if (NODE_JS) {
      root = global;
    } else if (WEB_WORKER) {
      root = self;
    }

    var COMMON_JS = !root.JS_MD5_NO_COMMON_JS && (typeof module === "undefined" ? "undefined" : babelHelpers.typeof(module)) === 'object' && module.exports;
    var AMD = typeof define === 'function' && define.amd;
    var ARRAY_BUFFER = !root.JS_MD5_NO_ARRAY_BUFFER && typeof ArrayBuffer !== 'undefined';
    var HEX_CHARS = '0123456789abcdef'.split('');
    var EXTRA = [128, 32768, 8388608, -2147483648];
    var SHIFT = [0, 8, 16, 24];
    var OUTPUT_TYPES = ['hex', 'array', 'digest', 'buffer', 'arrayBuffer', 'base64'];
    var BASE64_ENCODE_CHAR = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');
    var blocks = [],
        buffer8;

    if (ARRAY_BUFFER) {
      var buffer = new ArrayBuffer(68);
      buffer8 = new Uint8Array(buffer);
      blocks = new Uint32Array(buffer);
    }

    if (root.JS_MD5_NO_NODE_JS || !Array.isArray) {
      Array.isArray = function (obj) {
        return Object.prototype.toString.call(obj) === '[object Array]';
      };
    }

    if (ARRAY_BUFFER && (root.JS_MD5_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
      ArrayBuffer.isView = function (obj) {
        return babelHelpers.typeof(obj) === 'object' && obj.buffer && obj.buffer.constructor === ArrayBuffer;
      };
    }
    /**
     * @method hex
     * @memberof md5
     * @description Output hash as hex string
     * @param {String|Array|Uint8Array|ArrayBuffer} message message to hash
     * @returns {String} Hex string
     * @example
     * md5.hex('The quick brown fox jumps over the lazy dog');
     * // equal to
     * md5('The quick brown fox jumps over the lazy dog');
     */

    /**
     * @method digest
     * @memberof md5
     * @description Output hash as bytes array
     * @param {String|Array|Uint8Array|ArrayBuffer} message message to hash
     * @returns {Array} Bytes array
     * @example
     * md5.digest('The quick brown fox jumps over the lazy dog');
     */

    /**
     * @method array
     * @memberof md5
     * @description Output hash as bytes array
     * @param {String|Array|Uint8Array|ArrayBuffer} message message to hash
     * @returns {Array} Bytes array
     * @example
     * md5.array('The quick brown fox jumps over the lazy dog');
     */

    /**
     * @method arrayBuffer
     * @memberof md5
     * @description Output hash as ArrayBuffer
     * @param {String|Array|Uint8Array|ArrayBuffer} message message to hash
     * @returns {ArrayBuffer} ArrayBuffer
     * @example
     * md5.arrayBuffer('The quick brown fox jumps over the lazy dog');
     */

    /**
     * @method buffer
     * @deprecated This maybe confuse with Buffer in node.js. Please use arrayBuffer instead.
     * @memberof md5
     * @description Output hash as ArrayBuffer
     * @param {String|Array|Uint8Array|ArrayBuffer} message message to hash
     * @returns {ArrayBuffer} ArrayBuffer
     * @example
     * md5.buffer('The quick brown fox jumps over the lazy dog');
     */

    /**
     * @method base64
     * @memberof md5
     * @description Output hash as base64 string
     * @param {String|Array|Uint8Array|ArrayBuffer} message message to hash
     * @returns {String} base64 string
     * @example
     * md5.base64('The quick brown fox jumps over the lazy dog');
     */


    var createOutputMethod = function createOutputMethod(outputType) {
      return function (message) {
        return new Md5(true).update(message)[outputType]();
      };
    };
    /**
     * @method create
     * @memberof md5
     * @description Create Md5 object
     * @returns {Md5} Md5 object.
     * @example
     * var hash = md5.create();
     */

    /**
     * @method update
     * @memberof md5
     * @description Create and update Md5 object
     * @param {String|Array|Uint8Array|ArrayBuffer} message message to hash
     * @returns {Md5} Md5 object.
     * @example
     * var hash = md5.update('The quick brown fox jumps over the lazy dog');
     * // equal to
     * var hash = md5.create();
     * hash.update('The quick brown fox jumps over the lazy dog');
     */


    var createMethod = function createMethod() {
      var method = createOutputMethod('hex');

      if (NODE_JS) {
        method = nodeWrap(method);
      }

      method.create = function () {
        return new Md5();
      };

      method.update = function (message) {
        return method.create().update(message);
      };

      for (var i = 0; i < OUTPUT_TYPES.length; ++i) {
        var type = OUTPUT_TYPES[i];
        method[type] = createOutputMethod(type);
      }

      return method;
    };

    var nodeWrap = function nodeWrap(method) {
      var crypto = eval("require('crypto')");
      var Buffer = eval("require('buffer').Buffer");

      var nodeMethod = function nodeMethod(message) {
        if (typeof message === 'string') {
          return crypto.createHash('md5').update(message, 'utf8').digest('hex');
        } else {
          if (message === null || message === undefined) {
            throw ERROR;
          } else if (message.constructor === ArrayBuffer) {
            message = new Uint8Array(message);
          }
        }

        if (Array.isArray(message) || ArrayBuffer.isView(message) || message.constructor === Buffer) {
          return crypto.createHash('md5').update(new Buffer(message)).digest('hex');
        } else {
          return method(message);
        }
      };

      return nodeMethod;
    };
    /**
     * Md5 class
     * @class Md5
     * @description This is internal class.
     * @see {@link md5.create}
     */


    function Md5(sharedMemory) {
      if (sharedMemory) {
        blocks[0] = blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
        this.blocks = blocks;
        this.buffer8 = buffer8;
      } else {
        if (ARRAY_BUFFER) {
          var buffer = new ArrayBuffer(68);
          this.buffer8 = new Uint8Array(buffer);
          this.blocks = new Uint32Array(buffer);
        } else {
          this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        }
      }

      this.h0 = this.h1 = this.h2 = this.h3 = this.start = this.bytes = this.hBytes = 0;
      this.finalized = this.hashed = false;
      this.first = true;
    }
    /**
     * @method update
     * @memberof Md5
     * @instance
     * @description Update hash
     * @param {String|Array|Uint8Array|ArrayBuffer} message message to hash
     * @returns {Md5} Md5 object.
     * @see {@link md5.update}
     */


    Md5.prototype.update = function (message) {
      if (this.finalized) {
        return;
      }

      var notString,
          type = babelHelpers.typeof(message);

      if (type !== 'string') {
        if (type === 'object') {
          if (message === null) {
            throw ERROR;
          } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {
            message = new Uint8Array(message);
          } else if (!Array.isArray(message)) {
            if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {
              throw ERROR;
            }
          }
        } else {
          throw ERROR;
        }

        notString = true;
      }

      var code,
          index = 0,
          i,
          length = message.length,
          blocks = this.blocks;
      var buffer8 = this.buffer8;

      while (index < length) {
        if (this.hashed) {
          this.hashed = false;
          blocks[0] = blocks[16];
          blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
        }

        if (notString) {
          if (ARRAY_BUFFER) {
            for (i = this.start; index < length && i < 64; ++index) {
              buffer8[i++] = message[index];
            }
          } else {
            for (i = this.start; index < length && i < 64; ++index) {
              blocks[i >> 2] |= message[index] << SHIFT[i++ & 3];
            }
          }
        } else {
          if (ARRAY_BUFFER) {
            for (i = this.start; index < length && i < 64; ++index) {
              code = message.charCodeAt(index);

              if (code < 0x80) {
                buffer8[i++] = code;
              } else if (code < 0x800) {
                buffer8[i++] = 0xc0 | code >> 6;
                buffer8[i++] = 0x80 | code & 0x3f;
              } else if (code < 0xd800 || code >= 0xe000) {
                buffer8[i++] = 0xe0 | code >> 12;
                buffer8[i++] = 0x80 | code >> 6 & 0x3f;
                buffer8[i++] = 0x80 | code & 0x3f;
              } else {
                code = 0x10000 + ((code & 0x3ff) << 10 | message.charCodeAt(++index) & 0x3ff);
                buffer8[i++] = 0xf0 | code >> 18;
                buffer8[i++] = 0x80 | code >> 12 & 0x3f;
                buffer8[i++] = 0x80 | code >> 6 & 0x3f;
                buffer8[i++] = 0x80 | code & 0x3f;
              }
            }
          } else {
            for (i = this.start; index < length && i < 64; ++index) {
              code = message.charCodeAt(index);

              if (code < 0x80) {
                blocks[i >> 2] |= code << SHIFT[i++ & 3];
              } else if (code < 0x800) {
                blocks[i >> 2] |= (0xc0 | code >> 6) << SHIFT[i++ & 3];
                blocks[i >> 2] |= (0x80 | code & 0x3f) << SHIFT[i++ & 3];
              } else if (code < 0xd800 || code >= 0xe000) {
                blocks[i >> 2] |= (0xe0 | code >> 12) << SHIFT[i++ & 3];
                blocks[i >> 2] |= (0x80 | code >> 6 & 0x3f) << SHIFT[i++ & 3];
                blocks[i >> 2] |= (0x80 | code & 0x3f) << SHIFT[i++ & 3];
              } else {
                code = 0x10000 + ((code & 0x3ff) << 10 | message.charCodeAt(++index) & 0x3ff);
                blocks[i >> 2] |= (0xf0 | code >> 18) << SHIFT[i++ & 3];
                blocks[i >> 2] |= (0x80 | code >> 12 & 0x3f) << SHIFT[i++ & 3];
                blocks[i >> 2] |= (0x80 | code >> 6 & 0x3f) << SHIFT[i++ & 3];
                blocks[i >> 2] |= (0x80 | code & 0x3f) << SHIFT[i++ & 3];
              }
            }
          }
        }

        this.lastByteIndex = i;
        this.bytes += i - this.start;

        if (i >= 64) {
          this.start = i - 64;
          this.hash();
          this.hashed = true;
        } else {
          this.start = i;
        }
      }

      if (this.bytes > 4294967295) {
        this.hBytes += this.bytes / 4294967296 << 0;
        this.bytes = this.bytes % 4294967296;
      }

      return this;
    };

    Md5.prototype.finalize = function () {
      if (this.finalized) {
        return;
      }

      this.finalized = true;
      var blocks = this.blocks,
          i = this.lastByteIndex;
      blocks[i >> 2] |= EXTRA[i & 3];

      if (i >= 56) {
        if (!this.hashed) {
          this.hash();
        }

        blocks[0] = blocks[16];
        blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
      }

      blocks[14] = this.bytes << 3;
      blocks[15] = this.hBytes << 3 | this.bytes >>> 29;
      this.hash();
    };

    Md5.prototype.hash = function () {
      var a,
          b,
          c,
          d,
          bc,
          da,
          blocks = this.blocks;

      if (this.first) {
        a = blocks[0] - 680876937;
        a = (a << 7 | a >>> 25) - 271733879 << 0;
        d = (-1732584194 ^ a & 2004318071) + blocks[1] - 117830708;
        d = (d << 12 | d >>> 20) + a << 0;
        c = (-271733879 ^ d & (a ^ -271733879)) + blocks[2] - 1126478375;
        c = (c << 17 | c >>> 15) + d << 0;
        b = (a ^ c & (d ^ a)) + blocks[3] - 1316259209;
        b = (b << 22 | b >>> 10) + c << 0;
      } else {
        a = this.h0;
        b = this.h1;
        c = this.h2;
        d = this.h3;
        a += (d ^ b & (c ^ d)) + blocks[0] - 680876936;
        a = (a << 7 | a >>> 25) + b << 0;
        d += (c ^ a & (b ^ c)) + blocks[1] - 389564586;
        d = (d << 12 | d >>> 20) + a << 0;
        c += (b ^ d & (a ^ b)) + blocks[2] + 606105819;
        c = (c << 17 | c >>> 15) + d << 0;
        b += (a ^ c & (d ^ a)) + blocks[3] - 1044525330;
        b = (b << 22 | b >>> 10) + c << 0;
      }

      a += (d ^ b & (c ^ d)) + blocks[4] - 176418897;
      a = (a << 7 | a >>> 25) + b << 0;
      d += (c ^ a & (b ^ c)) + blocks[5] + 1200080426;
      d = (d << 12 | d >>> 20) + a << 0;
      c += (b ^ d & (a ^ b)) + blocks[6] - 1473231341;
      c = (c << 17 | c >>> 15) + d << 0;
      b += (a ^ c & (d ^ a)) + blocks[7] - 45705983;
      b = (b << 22 | b >>> 10) + c << 0;
      a += (d ^ b & (c ^ d)) + blocks[8] + 1770035416;
      a = (a << 7 | a >>> 25) + b << 0;
      d += (c ^ a & (b ^ c)) + blocks[9] - 1958414417;
      d = (d << 12 | d >>> 20) + a << 0;
      c += (b ^ d & (a ^ b)) + blocks[10] - 42063;
      c = (c << 17 | c >>> 15) + d << 0;
      b += (a ^ c & (d ^ a)) + blocks[11] - 1990404162;
      b = (b << 22 | b >>> 10) + c << 0;
      a += (d ^ b & (c ^ d)) + blocks[12] + 1804603682;
      a = (a << 7 | a >>> 25) + b << 0;
      d += (c ^ a & (b ^ c)) + blocks[13] - 40341101;
      d = (d << 12 | d >>> 20) + a << 0;
      c += (b ^ d & (a ^ b)) + blocks[14] - 1502002290;
      c = (c << 17 | c >>> 15) + d << 0;
      b += (a ^ c & (d ^ a)) + blocks[15] + 1236535329;
      b = (b << 22 | b >>> 10) + c << 0;
      a += (c ^ d & (b ^ c)) + blocks[1] - 165796510;
      a = (a << 5 | a >>> 27) + b << 0;
      d += (b ^ c & (a ^ b)) + blocks[6] - 1069501632;
      d = (d << 9 | d >>> 23) + a << 0;
      c += (a ^ b & (d ^ a)) + blocks[11] + 643717713;
      c = (c << 14 | c >>> 18) + d << 0;
      b += (d ^ a & (c ^ d)) + blocks[0] - 373897302;
      b = (b << 20 | b >>> 12) + c << 0;
      a += (c ^ d & (b ^ c)) + blocks[5] - 701558691;
      a = (a << 5 | a >>> 27) + b << 0;
      d += (b ^ c & (a ^ b)) + blocks[10] + 38016083;
      d = (d << 9 | d >>> 23) + a << 0;
      c += (a ^ b & (d ^ a)) + blocks[15] - 660478335;
      c = (c << 14 | c >>> 18) + d << 0;
      b += (d ^ a & (c ^ d)) + blocks[4] - 405537848;
      b = (b << 20 | b >>> 12) + c << 0;
      a += (c ^ d & (b ^ c)) + blocks[9] + 568446438;
      a = (a << 5 | a >>> 27) + b << 0;
      d += (b ^ c & (a ^ b)) + blocks[14] - 1019803690;
      d = (d << 9 | d >>> 23) + a << 0;
      c += (a ^ b & (d ^ a)) + blocks[3] - 187363961;
      c = (c << 14 | c >>> 18) + d << 0;
      b += (d ^ a & (c ^ d)) + blocks[8] + 1163531501;
      b = (b << 20 | b >>> 12) + c << 0;
      a += (c ^ d & (b ^ c)) + blocks[13] - 1444681467;
      a = (a << 5 | a >>> 27) + b << 0;
      d += (b ^ c & (a ^ b)) + blocks[2] - 51403784;
      d = (d << 9 | d >>> 23) + a << 0;
      c += (a ^ b & (d ^ a)) + blocks[7] + 1735328473;
      c = (c << 14 | c >>> 18) + d << 0;
      b += (d ^ a & (c ^ d)) + blocks[12] - 1926607734;
      b = (b << 20 | b >>> 12) + c << 0;
      bc = b ^ c;
      a += (bc ^ d) + blocks[5] - 378558;
      a = (a << 4 | a >>> 28) + b << 0;
      d += (bc ^ a) + blocks[8] - 2022574463;
      d = (d << 11 | d >>> 21) + a << 0;
      da = d ^ a;
      c += (da ^ b) + blocks[11] + 1839030562;
      c = (c << 16 | c >>> 16) + d << 0;
      b += (da ^ c) + blocks[14] - 35309556;
      b = (b << 23 | b >>> 9) + c << 0;
      bc = b ^ c;
      a += (bc ^ d) + blocks[1] - 1530992060;
      a = (a << 4 | a >>> 28) + b << 0;
      d += (bc ^ a) + blocks[4] + 1272893353;
      d = (d << 11 | d >>> 21) + a << 0;
      da = d ^ a;
      c += (da ^ b) + blocks[7] - 155497632;
      c = (c << 16 | c >>> 16) + d << 0;
      b += (da ^ c) + blocks[10] - 1094730640;
      b = (b << 23 | b >>> 9) + c << 0;
      bc = b ^ c;
      a += (bc ^ d) + blocks[13] + 681279174;
      a = (a << 4 | a >>> 28) + b << 0;
      d += (bc ^ a) + blocks[0] - 358537222;
      d = (d << 11 | d >>> 21) + a << 0;
      da = d ^ a;
      c += (da ^ b) + blocks[3] - 722521979;
      c = (c << 16 | c >>> 16) + d << 0;
      b += (da ^ c) + blocks[6] + 76029189;
      b = (b << 23 | b >>> 9) + c << 0;
      bc = b ^ c;
      a += (bc ^ d) + blocks[9] - 640364487;
      a = (a << 4 | a >>> 28) + b << 0;
      d += (bc ^ a) + blocks[12] - 421815835;
      d = (d << 11 | d >>> 21) + a << 0;
      da = d ^ a;
      c += (da ^ b) + blocks[15] + 530742520;
      c = (c << 16 | c >>> 16) + d << 0;
      b += (da ^ c) + blocks[2] - 995338651;
      b = (b << 23 | b >>> 9) + c << 0;
      a += (c ^ (b | ~d)) + blocks[0] - 198630844;
      a = (a << 6 | a >>> 26) + b << 0;
      d += (b ^ (a | ~c)) + blocks[7] + 1126891415;
      d = (d << 10 | d >>> 22) + a << 0;
      c += (a ^ (d | ~b)) + blocks[14] - 1416354905;
      c = (c << 15 | c >>> 17) + d << 0;
      b += (d ^ (c | ~a)) + blocks[5] - 57434055;
      b = (b << 21 | b >>> 11) + c << 0;
      a += (c ^ (b | ~d)) + blocks[12] + 1700485571;
      a = (a << 6 | a >>> 26) + b << 0;
      d += (b ^ (a | ~c)) + blocks[3] - 1894986606;
      d = (d << 10 | d >>> 22) + a << 0;
      c += (a ^ (d | ~b)) + blocks[10] - 1051523;
      c = (c << 15 | c >>> 17) + d << 0;
      b += (d ^ (c | ~a)) + blocks[1] - 2054922799;
      b = (b << 21 | b >>> 11) + c << 0;
      a += (c ^ (b | ~d)) + blocks[8] + 1873313359;
      a = (a << 6 | a >>> 26) + b << 0;
      d += (b ^ (a | ~c)) + blocks[15] - 30611744;
      d = (d << 10 | d >>> 22) + a << 0;
      c += (a ^ (d | ~b)) + blocks[6] - 1560198380;
      c = (c << 15 | c >>> 17) + d << 0;
      b += (d ^ (c | ~a)) + blocks[13] + 1309151649;
      b = (b << 21 | b >>> 11) + c << 0;
      a += (c ^ (b | ~d)) + blocks[4] - 145523070;
      a = (a << 6 | a >>> 26) + b << 0;
      d += (b ^ (a | ~c)) + blocks[11] - 1120210379;
      d = (d << 10 | d >>> 22) + a << 0;
      c += (a ^ (d | ~b)) + blocks[2] + 718787259;
      c = (c << 15 | c >>> 17) + d << 0;
      b += (d ^ (c | ~a)) + blocks[9] - 343485551;
      b = (b << 21 | b >>> 11) + c << 0;

      if (this.first) {
        this.h0 = a + 1732584193 << 0;
        this.h1 = b - 271733879 << 0;
        this.h2 = c - 1732584194 << 0;
        this.h3 = d + 271733878 << 0;
        this.first = false;
      } else {
        this.h0 = this.h0 + a << 0;
        this.h1 = this.h1 + b << 0;
        this.h2 = this.h2 + c << 0;
        this.h3 = this.h3 + d << 0;
      }
    };
    /**
     * @method hex
     * @memberof Md5
     * @instance
     * @description Output hash as hex string
     * @returns {String} Hex string
     * @see {@link md5.hex}
     * @example
     * hash.hex();
     */


    Md5.prototype.hex = function () {
      this.finalize();
      var h0 = this.h0,
          h1 = this.h1,
          h2 = this.h2,
          h3 = this.h3;
      return HEX_CHARS[h0 >> 4 & 0x0F] + HEX_CHARS[h0 & 0x0F] + HEX_CHARS[h0 >> 12 & 0x0F] + HEX_CHARS[h0 >> 8 & 0x0F] + HEX_CHARS[h0 >> 20 & 0x0F] + HEX_CHARS[h0 >> 16 & 0x0F] + HEX_CHARS[h0 >> 28 & 0x0F] + HEX_CHARS[h0 >> 24 & 0x0F] + HEX_CHARS[h1 >> 4 & 0x0F] + HEX_CHARS[h1 & 0x0F] + HEX_CHARS[h1 >> 12 & 0x0F] + HEX_CHARS[h1 >> 8 & 0x0F] + HEX_CHARS[h1 >> 20 & 0x0F] + HEX_CHARS[h1 >> 16 & 0x0F] + HEX_CHARS[h1 >> 28 & 0x0F] + HEX_CHARS[h1 >> 24 & 0x0F] + HEX_CHARS[h2 >> 4 & 0x0F] + HEX_CHARS[h2 & 0x0F] + HEX_CHARS[h2 >> 12 & 0x0F] + HEX_CHARS[h2 >> 8 & 0x0F] + HEX_CHARS[h2 >> 20 & 0x0F] + HEX_CHARS[h2 >> 16 & 0x0F] + HEX_CHARS[h2 >> 28 & 0x0F] + HEX_CHARS[h2 >> 24 & 0x0F] + HEX_CHARS[h3 >> 4 & 0x0F] + HEX_CHARS[h3 & 0x0F] + HEX_CHARS[h3 >> 12 & 0x0F] + HEX_CHARS[h3 >> 8 & 0x0F] + HEX_CHARS[h3 >> 20 & 0x0F] + HEX_CHARS[h3 >> 16 & 0x0F] + HEX_CHARS[h3 >> 28 & 0x0F] + HEX_CHARS[h3 >> 24 & 0x0F];
    };
    /**
     * @method toString
     * @memberof Md5
     * @instance
     * @description Output hash as hex string
     * @returns {String} Hex string
     * @see {@link md5.hex}
     * @example
     * hash.toString();
     */


    Md5.prototype.toString = Md5.prototype.hex;
    /**
     * @method digest
     * @memberof Md5
     * @instance
     * @description Output hash as bytes array
     * @returns {Array} Bytes array
     * @see {@link md5.digest}
     * @example
     * hash.digest();
     */

    Md5.prototype.digest = function () {
      this.finalize();
      var h0 = this.h0,
          h1 = this.h1,
          h2 = this.h2,
          h3 = this.h3;
      return [h0 & 0xFF, h0 >> 8 & 0xFF, h0 >> 16 & 0xFF, h0 >> 24 & 0xFF, h1 & 0xFF, h1 >> 8 & 0xFF, h1 >> 16 & 0xFF, h1 >> 24 & 0xFF, h2 & 0xFF, h2 >> 8 & 0xFF, h2 >> 16 & 0xFF, h2 >> 24 & 0xFF, h3 & 0xFF, h3 >> 8 & 0xFF, h3 >> 16 & 0xFF, h3 >> 24 & 0xFF];
    };
    /**
     * @method array
     * @memberof Md5
     * @instance
     * @description Output hash as bytes array
     * @returns {Array} Bytes array
     * @see {@link md5.array}
     * @example
     * hash.array();
     */


    Md5.prototype.array = Md5.prototype.digest;
    /**
     * @method arrayBuffer
     * @memberof Md5
     * @instance
     * @description Output hash as ArrayBuffer
     * @returns {ArrayBuffer} ArrayBuffer
     * @see {@link md5.arrayBuffer}
     * @example
     * hash.arrayBuffer();
     */

    Md5.prototype.arrayBuffer = function () {
      this.finalize();
      var buffer = new ArrayBuffer(16);
      var blocks = new Uint32Array(buffer);
      blocks[0] = this.h0;
      blocks[1] = this.h1;
      blocks[2] = this.h2;
      blocks[3] = this.h3;
      return buffer;
    };
    /**
     * @method buffer
     * @deprecated This maybe confuse with Buffer in node.js. Please use arrayBuffer instead.
     * @memberof Md5
     * @instance
     * @description Output hash as ArrayBuffer
     * @returns {ArrayBuffer} ArrayBuffer
     * @see {@link md5.buffer}
     * @example
     * hash.buffer();
     */


    Md5.prototype.buffer = Md5.prototype.arrayBuffer;
    /**
     * @method base64
     * @memberof Md5
     * @instance
     * @description Output hash as base64 string
     * @returns {String} base64 string
     * @see {@link md5.base64}
     * @example
     * hash.base64();
     */

    Md5.prototype.base64 = function () {
      var v1,
          v2,
          v3,
          base64Str = '',
          bytes = this.array();

      for (var i = 0; i < 15;) {
        v1 = bytes[i++];
        v2 = bytes[i++];
        v3 = bytes[i++];
        base64Str += BASE64_ENCODE_CHAR[v1 >>> 2] + BASE64_ENCODE_CHAR[(v1 << 4 | v2 >>> 4) & 63] + BASE64_ENCODE_CHAR[(v2 << 2 | v3 >>> 6) & 63] + BASE64_ENCODE_CHAR[v3 & 63];
      }

      v1 = bytes[i];
      base64Str += BASE64_ENCODE_CHAR[v1 >>> 2] + BASE64_ENCODE_CHAR[v1 << 4 & 63] + '==';
      return base64Str;
    };

    return createMethod();
  }();

  exports.md5 = md5;

}((this.BX = this.BX || {})));
 




// file: /bitrix/js/ui/vue/vuex/dist/vuex.bundle.js
;(function() {

	if (
		typeof this.BX !== 'undefined'
		&& typeof this.BX.WidgetVuex !== 'undefined'
	)
	{
		var currentVersion = '3.6.2';

		if (this.BX.WidgetVuex.version !== currentVersion)
		{
			console.warn('BX.WidgetVuex already loaded. Loaded: ' + this.BX.WidgetVuex.version + ', Skipped: ' + currentVersion + '. Version differences may cause errors!');
		}

		return;
	}

(function (exports,ui_vue,ui_dexie,main_md5) {
	'use strict';

	/**
	 * Bitrix Vuex wrapper
	 * IndexedDB driver for Vuex Builder
	 *
	 * @package bitrix
	 * @subpackage ui
	 * @copyright 2001-2019 Bitrix
	 */
	var VuexBuilderDatabaseIndexedDB = /*#__PURE__*/function () {
	  function VuexBuilderDatabaseIndexedDB() {
	    var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	    babelHelpers.classCallCheck(this, VuexBuilderDatabaseIndexedDB);
	    this.siteId = config.siteId || 'default';
	    this.userId = config.userId || 0;
	    this.storage = config.storage || 'default';
	    this.name = config.name || '';
	    this.code = (window.md5 || main_md5.md5)(this.siteId + '/' + this.userId + '/' + this.storage + '/' + this.name);
	    this.db = new ui_dexie.Dexie('bx-vuex-model');
	    this.db.version(1).stores({
	      data: "code, value"
	    });
	  }

	  babelHelpers.createClass(VuexBuilderDatabaseIndexedDB, [{
	    key: "get",
	    value: function get() {
	      var _this = this;

	      return new Promise(function (resolve, reject) {
	        _this.db.data.where('code').equals(_this.code).first().then(function (data) {
	          resolve(data ? data.value : null);
	        }, function (error) {
	          reject(error);
	        });
	      });
	    }
	  }, {
	    key: "set",
	    value: function set(value) {
	      var _this2 = this;

	      return new Promise(function (resolve, reject) {
	        _this2.db.data.put({
	          code: _this2.code,
	          value: value
	        }).then(function (data) {
	          resolve(true);
	        }, function (error) {
	          reject(error);
	        });
	      });
	    }
	  }, {
	    key: "clear",
	    value: function clear() {
	      var _this3 = this;

	      return new Promise(function (resolve, reject) {
	        _this3.db.data["delete"](_this3.code).then(function (data) {
	          resolve(true);
	        }, function (error) {
	          reject(error);
	        });
	      });
	    }
	  }]);
	  return VuexBuilderDatabaseIndexedDB;
	}();

	/**
	 * Bitrix Vuex wrapper
	 * LocalStorage driver for Vuex Builder
	 *
	 * @package bitrix
	 * @subpackage ui
	 * @copyright 2001-2019 Bitrix
	 */
	var VuexBuilderDatabaseLocalStorage = /*#__PURE__*/function () {
	  function VuexBuilderDatabaseLocalStorage() {
	    var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	    babelHelpers.classCallCheck(this, VuexBuilderDatabaseLocalStorage);
	    this.siteId = config.siteId || 'default';
	    this.userId = config.userId || 0;
	    this.storage = config.storage || 'default';
	    this.name = config.name || '';
	    this.enabled = false;

	    if (typeof window.localStorage !== 'undefined') {
	      try {
	        window.localStorage.setItem('__bx_test_ls_feature__', 'ok');

	        if (window.localStorage.getItem('__bx_test_ls_feature__') === 'ok') {
	          window.localStorage.removeItem('__bx_test_ls_feature__');
	          this.enabled = true;
	        }
	      } catch (e) {}
	    }

	    this.code = 'bx-vuex-' + (window.md5 || main_md5.md5)(this.siteId + '/' + this.userId + '/' + this.storage + '/' + this.name);
	  }

	  babelHelpers.createClass(VuexBuilderDatabaseLocalStorage, [{
	    key: "get",
	    value: function get() {
	      var _this = this;

	      return new Promise(function (resolve, reject) {
	        if (!_this.enabled) {
	          resolve(null);
	          return true;
	        }

	        var result = window.localStorage.getItem(_this.code);

	        if (typeof result !== "string") {
	          resolve(null);
	          return true;
	        }

	        try {
	          resolve(_this.prepareValueAfterGet(JSON.parse(result)));
	        } catch (error) {
	          reject(error);
	        }
	      });
	    }
	  }, {
	    key: "set",
	    value: function set(value) {
	      var _this2 = this;

	      return new Promise(function (resolve, reject) {
	        if (_this2.enabled) {
	          window.localStorage.setItem(_this2.code, JSON.stringify(_this2.prepareValueBeforeSet(value)));
	        }

	        resolve(true);
	      });
	    }
	  }, {
	    key: "clear",
	    value: function clear() {
	      var _this3 = this;

	      return new Promise(function (resolve, reject) {
	        if (_this3.enabled) {
	          window.localStorage.removeItem(_this3.code);
	        }

	        resolve(true);
	      });
	    }
	    /**
	     * @private
	     */

	  }, {
	    key: "prepareValueAfterGet",
	    value: function prepareValueAfterGet(value) {
	      var _this4 = this;

	      if (value instanceof Array) {
	        value = value.map(function (element) {
	          return _this4.prepareValueAfterGet(element);
	        });
	      } else if (value instanceof Date) ; else if (value && babelHelpers["typeof"](value) === 'object') {
	        for (var index in value) {
	          if (value.hasOwnProperty(index)) {
	            value[index] = this.prepareValueAfterGet(value[index]);
	          }
	        }
	      } else if (typeof value === 'string') {
	        if (value.startsWith('#DT#')) {
	          value = new Date(value.substring(4));
	        }
	      }

	      return value;
	    }
	    /**
	     * @private
	     */

	  }, {
	    key: "prepareValueBeforeSet",
	    value: function prepareValueBeforeSet(value) {
	      var _this5 = this;

	      if (value instanceof Array) {
	        value = value.map(function (element) {
	          return _this5.prepareValueBeforeSet(element);
	        });
	      } else if (value instanceof Date) {
	        value = '#DT#' + value.toISOString();
	      } else if (value && babelHelpers["typeof"](value) === 'object') {
	        for (var index in value) {
	          if (value.hasOwnProperty(index)) {
	            value[index] = this.prepareValueBeforeSet(value[index]);
	          }
	        }
	      }

	      return value;
	    }
	  }]);
	  return VuexBuilderDatabaseLocalStorage;
	}();

	/**
	 * Bitrix Vuex wrapper
	 * BitrixMobile ApplicationStorage driver for Vuex Builder
	 *
	 * @package bitrix
	 * @subpackage ui
	 * @copyright 2001-2019 Bitrix
	 */
	var VuexBuilderDatabaseJnSharedStorage = /*#__PURE__*/function () {
	  function VuexBuilderDatabaseJnSharedStorage() {
	    var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	    babelHelpers.classCallCheck(this, VuexBuilderDatabaseJnSharedStorage);
	    this.siteId = config.siteId || 'default';
	    this.userId = config.userId || 0;
	    this.storage = config.storage || 'default';
	    this.name = config.name || '';
	    this.code = (window.md5 || main_md5.md5)(this.siteId + '/' + this.userId + '/' + this.storage + '/' + this.name);

	    if (!this.isJnContext() && typeof ApplicationStorage === 'undefined') {
	      console.error('ApplicationStorage is not defined, load "webcomponent/storage" extension.');
	    }
	  }

	  babelHelpers.createClass(VuexBuilderDatabaseJnSharedStorage, [{
	    key: "get",
	    value: function get() {
	      var _this = this;

	      return new Promise(function (resolve, reject) {
	        if (_this.isJnContext()) {
	          var result = Application.sharedStorage.get(_this.code);
	          resolve(result ? result : null);
	        } else if (typeof ApplicationStorage !== 'undefined') {
	          ApplicationStorage.get(_this.code, null).then(function (data) {
	            return resolve(_this.prepareValueAfterGet(JSON.parse(data)));
	          });
	        } else {
	          resolve(null);
	        }
	      });
	    }
	  }, {
	    key: "set",
	    value: function set(value) {
	      var _this2 = this;

	      return new Promise(function (resolve, reject) {
	        if (_this2.isJnContext()) {
	          Application.sharedStorage().set(_this2.code, JSON.stringify(_this2.prepareValueBeforeSet(value)));
	          resolve();
	        } else if (typeof ApplicationStorage !== 'undefined') {
	          ApplicationStorage.set(_this2.code, JSON.stringify(_this2.prepareValueBeforeSet(value))).then(function (data) {
	            return resolve();
	          });
	        } else {
	          resolve();
	        }
	      });
	    }
	  }, {
	    key: "clear",
	    value: function clear() {
	      return this.set(null);
	    }
	    /**
	     * @private
	     */

	  }, {
	    key: "isJnContext",
	    value: function isJnContext() {
	      return typeof env !== 'undefined';
	    }
	    /**
	     * @private
	     */

	  }, {
	    key: "prepareValueAfterGet",
	    value: function prepareValueAfterGet(value) {
	      var _this3 = this;

	      if (value instanceof Array) {
	        value = value.map(function (element) {
	          return _this3.prepareValueAfterGet(element);
	        });
	      } else if (value instanceof Date) ; else if (value && babelHelpers["typeof"](value) === 'object') {
	        for (var index in value) {
	          if (value.hasOwnProperty(index)) {
	            value[index] = this.prepareValueAfterGet(value[index]);
	          }
	        }
	      } else if (typeof value === 'string') {
	        if (value.startsWith('#DT#')) {
	          value = new Date(value.substring(4));
	        }
	      }

	      return value;
	    }
	    /**
	     * @private
	     */

	  }, {
	    key: "prepareValueBeforeSet",
	    value: function prepareValueBeforeSet(value) {
	      var _this4 = this;

	      if (value instanceof Array) {
	        value = value.map(function (element) {
	          return _this4.prepareValueBeforeSet(element);
	        });
	      } else if (value instanceof Date) {
	        value = '#DT#' + value.toISOString();
	      } else if (value && babelHelpers["typeof"](value) === 'object') {
	        for (var index in value) {
	          if (value.hasOwnProperty(index)) {
	            value[index] = this.prepareValueBeforeSet(value[index]);
	          }
	        }
	      }

	      return value;
	    }
	  }]);
	  return VuexBuilderDatabaseJnSharedStorage;
	}();

	/**
	 * Bitrix Vuex wrapper
	 * Interface Vuex model (Vuex builder model)
	 *
	 * @package bitrix
	 * @subpackage ui
	 * @copyright 2001-2019 Bitrix
	 */
	var VuexBuilderModel$$1 = /*#__PURE__*/function () {
	  babelHelpers.createClass(VuexBuilderModel$$1, [{
	    key: "getName",

	    /**
	     * Get name of model
	     *
	     * @override
	     *
	     * @returns {String}
	     */
	    value: function getName() {
	      return '';
	    }
	    /**
	     * Get default state
	     *
	    	 * @override
	     *
	     * @returns {Object}
	     */

	  }, {
	    key: "getState",
	    value: function getState() {
	      return {};
	    }
	    /**
	     * Get default element state for models with collection.
	     *
	    	 * @override
	     *
	     * @returns {Object}
	     */

	  }, {
	    key: "getElementState",
	    value: function getElementState() {
	      return {};
	    }
	    /**
	     * Get object containing fields to exclude during the save to database.
	     *
	    	 * @override
	     *
	     * @returns {Object}
	     */

	  }, {
	    key: "getStateSaveException",
	    value: function getStateSaveException() {
	      return undefined;
	    }
	    /**
	     * Get getters
	     *
	    	 * @override
	     *
	     * @returns {Object}
	     */

	  }, {
	    key: "getGetters",
	    value: function getGetters() {
	      return {};
	    }
	    /**
	     * Get actions
	     *
	    	 * @override
	     *
	     * @returns {Object}
	     */

	  }, {
	    key: "getActions",
	    value: function getActions() {
	      return {};
	    }
	    /**
	     * Get mutations
	     *
	    	 * @override
	     *
	     * @returns {Object}
	     */

	  }, {
	    key: "getMutations",
	    value: function getMutations() {
	      return {};
	    }
	    /**
	     * Method for validation and sanitizing input fields before save in model
	     *
	     * @override
	     *
	     * @param fields {Object}
	     * @param options {Object}
	     *
	     * @returns {Object} - Sanitizing fields
	     */

	  }, {
	    key: "validate",
	    value: function validate(fields) {
	      return {};
	    }
	    /**
	     * Set external variable.
	     *
	     * @param variables {Object}
	     * @returns {VuexBuilderModel}
	     */

	  }, {
	    key: "setVariables",
	    value: function setVariables() {
	      var variables = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	      if (!(babelHelpers["typeof"](variables) === 'object' && variables)) {
	        this.logger('error', 'VuexBuilderModel.setVars: passed variables is not a Object', store);
	        return this;
	      }

	      this.variables = variables;
	      return this;
	    }
	  }, {
	    key: "getVariable",
	    value: function getVariable(name) {
	      var defaultValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

	      if (!name) {
	        return defaultValue;
	      }

	      var nameParts = name.toString().split('.');

	      if (nameParts.length === 1) {
	        return this.variables[nameParts[0]];
	      }

	      var result;
	      var variables = Object.assign({}, this.variables);

	      for (var i = 0; i < nameParts.length; i++) {
	        if (typeof variables[nameParts[i]] !== 'undefined') {
	          variables = result = variables[nameParts[i]];
	        } else {
	          result = defaultValue;
	          break;
	        }
	      }

	      return result;
	    }
	    /**
	     * Get namespace
	     *
	     * @returns {String}
	     */

	  }, {
	    key: "getNamespace",
	    value: function getNamespace() {
	      return this.namespace ? this.namespace : this.getName();
	    }
	    /**
	     * Set namespace
	     *
	     * @param name {String}
	     *
	     * @returns {VuexBuilderModel}
	     */

	  }, {
	    key: "setNamespace",
	    value: function setNamespace(name) {
	      this.namespace = name.toString();
	      this.databaseConfig.name = this.namespace;
	      return this;
	    }
	    /**
	     * Set database config for model or disable this feature.
	     *
	     * @param active {boolean}
	     * @param config {{name: String, siteId: String, userId: Number, type: VuexBuilder.DatabaseType}}
	     *
	     * @returns {VuexBuilderModel}
	     */

	  }, {
	    key: "useDatabase",
	    value: function useDatabase(active) {
	      var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	      this.databaseConfig.active = !!active;
	      var updateDriver = this.db === null;

	      if (config.type) {
	        this.databaseConfig.type = config.type.toString();
	        updateDriver = true;
	      }

	      if (config.storage) {
	        this.databaseConfig.storage = config.storage.toString();
	      }

	      if (config.siteId) {
	        this.databaseConfig.siteId = config.siteId.toString();
	      }

	      if (config.userId) {
	        this.databaseConfig.userId = config.userId;
	      }

	      if (typeof config.timeout === 'number') {
	        this.databaseConfig.timeout = config.timeout;
	      }

	      if (!this.databaseConfig.active && this.db !== null) {
	        this.databaseConfig.type = null;
	        updateDriver = true;
	      }

	      if (updateDriver) {
	        if (this.databaseConfig.type === VuexBuilder$$1.DatabaseType.indexedDb) {
	          this.db = new VuexBuilderDatabaseIndexedDB(this.databaseConfig);
	        } else if (this.databaseConfig.type === VuexBuilder$$1.DatabaseType.localStorage) {
	          this.db = new VuexBuilderDatabaseLocalStorage(this.databaseConfig);
	        } else if (this.databaseConfig.type === VuexBuilder$$1.DatabaseType.jnSharedStorage) {
	          this.db = new VuexBuilderDatabaseJnSharedStorage(this.databaseConfig);
	        } else {
	          this.db = null;
	        }
	      }

	      return this;
	    }
	    /**
	     * @returns {VuexBuilderModel}
	     * @deprecated
	     */

	  }, {
	    key: "useNamespace",
	    value: function useNamespace(active) {
	      if (ui_vue.WidgetBitrixVue.developerMode) {
	        if (active) {
	          console.warn('VuexBuilderModel: Method `useNamespace` is deprecated, please remove this call.');
	        } else {
	          console.error('VuexBuilderModel: Method `useNamespace` is deprecated, using VuexBuilder without namespaces is no longer supported.');
	        }
	      }

	      return this;
	    }
	    /**
	     * @returns {Promise}
	     * @deprecated use getModule instead.
	     */

	  }, {
	    key: "getStore",
	    value: function getStore() {
	      return this.getModule();
	    }
	    /**
	     * Get Vuex module.
	     *
	     * @returns {Promise}
	     */

	  }, {
	    key: "getModule",
	    value: function getModule() {
	      var _this = this;

	      return new Promise(function (resolve, reject) {
	        var namespace = _this.namespace ? _this.namespace : _this.getName();

	        if (!namespace) {
	          _this.logger('error', 'VuexBuilderModel.getStore: current model can not be run in Vuex modules mode', _this.getState());

	          reject();
	        }

	        if (_this.db) {
	          _this._getStoreFromDatabase().then(function (state) {
	            return resolve({
	              namespace: namespace,
	              module: _this._createStore(state)
	            });
	          });
	        } else {
	          resolve({
	            namespace: namespace,
	            module: _this._createStore(_this.getState())
	          });
	        }
	      });
	    }
	    /**
	     * Get default state of Vuex module.
	     *
	     * @returns {Object}
	     */

	  }, {
	    key: "getModuleWithDefaultState",
	    value: function getModuleWithDefaultState() {
	      var namespace = this.namespace ? this.namespace : this.getName();

	      if (!namespace) {
	        this.logger('error', 'VuexBuilderModel.getStore: current model can not be run in Vuex modules mode', this.getState());
	        return null;
	      }

	      return {
	        namespace: namespace,
	        module: this._createStore(this.getState())
	      };
	    }
	    /**
	     * Get timeout for save to database
	     *
	    	 * @override
	     *
	     * @returns {number}
	     */

	  }, {
	    key: "getSaveTimeout",
	    value: function getSaveTimeout() {
	      return 150;
	    }
	    /**
	     * Get timeout for load from database
	     *
	     * @override
	     *
	     * @returns {number|boolean}
	     */

	  }, {
	    key: "getLoadTimeout",
	    value: function getLoadTimeout() {
	      return 1000;
	    }
	    /**
	     * Get state after load from database
	     *
	    	 * @param state {Object}
	     *
	     * @override
	     *
	     * @returns {Object}
	     */

	  }, {
	    key: "getLoadedState",
	    value: function getLoadedState() {
	      var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	      return state;
	    }
	    /**
	     * Save current state after change state to database
	     *
	    	 * @param state {Object|function}
	     *
	     * @returns {Promise}
	     */

	  }, {
	    key: "saveState",
	    value: function saveState() {
	      var _this2 = this;

	      var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	      if (!this.isSaveAvailable()) {
	        return true;
	      }

	      this.lastSaveState = state;

	      if (this.saveStateTimeout) {
	        this.logger('log', 'VuexModel.saveState: wait save...', this.getName());
	        return true;
	      }

	      this.logger('log', 'VuexModel.saveState: start saving', this.getName());
	      var timeout = this.getSaveTimeout();

	      if (typeof this.databaseConfig.timeout === 'number') {
	        timeout = this.databaseConfig.timeout;
	      }

	      this.saveStateTimeout = setTimeout(function () {
	        _this2.logger('log', 'VuexModel.saveState: saved!', _this2.getName());

	        var lastState = _this2.lastSaveState;

	        if (typeof lastState === 'function') {
	          lastState = lastState();

	          if (babelHelpers["typeof"](lastState) !== 'object' || !lastState) {
	            return false;
	          }
	        }

	        _this2.db.set(_this2.cloneState(lastState, _this2.getStateSaveException()));

	        _this2.lastState = null;
	        _this2.saveStateTimeout = null;
	      }, timeout);
	      return true;
	    }
	    /**
	     * Reset current store to default state
	     **
	     * @returns {Promise}
	     */

	  }, {
	    key: "clearState",
	    value: function clearState() {
	      if (this.store) {
	        this.store.commit(this.getNamespace() + '/' + 'vuexBuilderModelClearState');
	        return true;
	      }

	      return this.saveState(this.getState());
	    }
	    /**
	     * Clear database only, store state does not change
	     **
	     * @returns {Promise}
	     */

	  }, {
	    key: "clearDatabase",
	    value: function clearDatabase() {
	      if (!this.isSaveAvailable()) {
	        return true;
	      }

	      this.db.clear();
	      return true;
	    }
	  }, {
	    key: "isSaveAvailable",
	    value: function isSaveAvailable() {
	      return this.db && this.databaseConfig.active;
	    }
	  }, {
	    key: "isSaveNeeded",
	    value: function isSaveNeeded(payload) {
	      if (!this.isSaveAvailable()) {
	        return false;
	      }

	      var checkFunction = function checkFunction(payload) {
	        var filter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

	        if (!filter) {
	          return true;
	        }

	        for (var field in payload) {
	          if (!payload.hasOwnProperty(field)) {
	            continue;
	          }

	          if (typeof filter[field] === 'undefined') {
	            return true;
	          } else if (babelHelpers["typeof"](filter[field]) === 'object' && filter[field]) {
	            var result = checkFunction(payload[field], filter[field]);

	            if (result) {
	              return true;
	            }
	          }
	        }

	        return false;
	      };

	      return checkFunction(payload, this.getStateSaveException());
	    }
	    /**
	     * Create new instance of model.
	     */

	  }], [{
	    key: "create",

	    /**
	     * Create new instance of model.
	     *
	     * @returns {VuexBuilderModel}
	     */
	    value: function create() {
	      return new this();
	    }
	  }]);

	  function VuexBuilderModel$$1() {
	    babelHelpers.classCallCheck(this, VuexBuilderModel$$1);
	    this.databaseConfig = {
	      type: VuexBuilder$$1.DatabaseType.indexedDb,
	      active: null,
	      storage: 'default',
	      name: this.getName(),
	      siteId: 'default',
	      userId: 0,
	      timeout: null
	    };
	    this.db = null;
	    this.store = null;
	    this.namespace = null;
	    this.variables = {};
	  }

	  babelHelpers.createClass(VuexBuilderModel$$1, [{
	    key: "setStore",
	    value: function setStore(store) {
	      if (!(store instanceof Vuex.Store)) {
	        this.logger('error', 'VuexBuilderModel.setStore: passed store is not a Vuex.Store', store);
	        return this;
	      }

	      this.store = store;
	      return this;
	    }
	  }, {
	    key: "_getStoreFromDatabase",
	    value: function _getStoreFromDatabase() {
	      var _this3 = this;

	      clearTimeout(this.cacheTimeout);
	      return new Promise(function (resolve) {
	        var loadTimeout = _this3.getLoadTimeout();

	        if (loadTimeout !== false && typeof loadTimeout === 'number') {
	          _this3.cacheTimeout = setTimeout(function () {
	            _this3.logger('warn', 'VuexModel.getStoreFromDatabase: Cache loading timeout', _this3.getName());

	            resolve(_this3.getState());
	          }, loadTimeout);
	        } else {
	          _this3.cacheTimeout = null;
	        }

	        _this3.db.get().then(function (cache) {
	          clearTimeout(_this3.cacheTimeout);
	          cache = _this3.getLoadedState(cache ? cache : {});

	          var state = _this3.getState();

	          if (cache) {
	            state = _this3._mergeState(state, cache);
	          }

	          resolve(state);
	        }, function (error) {
	          clearTimeout(_this3.cacheTimeout);
	          resolve(_this3.getState());
	        });
	      });
	    }
	  }, {
	    key: "_mergeState",
	    value: function _mergeState(currentState, newState) {
	      for (var key in currentState) {
	        if (!currentState.hasOwnProperty(key)) {
	          continue;
	        }

	        if (typeof newState[key] === 'undefined') {
	          newState[key] = currentState[key];
	        } else if (!(newState[key] instanceof Array) && babelHelpers["typeof"](newState[key]) === 'object' && newState[key] && babelHelpers["typeof"](currentState[key]) === 'object' && currentState[key]) {
	          newState[key] = Object.assign({}, currentState[key], newState[key]);
	        }
	      }

	      return newState;
	    }
	  }, {
	    key: "_createStore",
	    value: function _createStore(state) {
	      var _this4 = this;

	      var result = {
	        namespaced: true,
	        state: state,
	        getters: this.getGetters(),
	        actions: this.getActions(),
	        mutations: this.getMutations()
	      };

	      result.mutations.vuexBuilderModelClearState = function (state) {
	        state = Object.assign(state, _this4.getState());

	        _this4.saveState(state);
	      };

	      return result;
	    }
	    /**
	     * Utils. Convert Object to Array
	     * @param object
	     * @returns {Array}
	     */

	  }, {
	    key: "cloneState",

	    /**
	     * Clone state without observers
	     * @param element {object}
	     * @param exceptions {object}
	     */
	    value: function cloneState(element) {
	      var _this5 = this;

	      var exceptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
	      var result;

	      if (element instanceof Array) {
	        result = [].concat(element.map(function (element) {
	          return _this5.cloneState(element);
	        }));
	      } else if (element instanceof Date) {
	        result = new Date(element.toISOString());
	      } else if (babelHelpers["typeof"](element) === 'object' && element) {
	        result = {};

	        for (var param in element) {
	          if (!element.hasOwnProperty(param)) {
	            continue;
	          }

	          if (typeof exceptions === 'undefined' || typeof exceptions[param] === 'undefined') {
	            result[param] = this.cloneState(element[param]);
	          } else if (babelHelpers["typeof"](exceptions[param]) === 'object' && exceptions[param]) {
	            result[param] = this.cloneState(element[param], exceptions[param]);
	          }
	        }
	      } else {
	        result = element;
	      }

	      return result;
	    }
	  }, {
	    key: "logger",
	    value: function logger(type) {
	      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	        args[_key - 1] = arguments[_key];
	      }

	      if (type === 'error') {
	        var _console;

	        (_console = console).error.apply(_console, args);

	        return undefined;
	      } else if (typeof BX.WidgetVueDevTools === 'undefined') {
	        return undefined;
	      }

	      if (type === 'log') {
	        var _console2;

	        (_console2 = console).log.apply(_console2, args);
	      } else if (type === 'info') {
	        var _console3;

	        (_console3 = console).info.apply(_console3, args);
	      } else if (type === 'warn') {
	        var _console4;

	        (_console4 = console).warn.apply(_console4, args);
	      }
	    }
	  }], [{
	    key: "convertToArray",
	    value: function convertToArray(object) {
	      var result = [];

	      for (var i in object) {
	        if (object.hasOwnProperty(i)) {
	          result.push(object[i]);
	        }
	      }

	      return result;
	    }
	  }]);
	  return VuexBuilderModel$$1;
	}();

	/**
	 * Bitrix Vuex wrapper
	 * Vuex builder
	 *
	 * @package bitrix
	 * @subpackage ui
	 * @copyright 2001-2019 Bitrix
	 */
	var DatabaseType = Object.freeze({
	  indexedDb: 'indexedDb',
	  localStorage: 'localStorage',
	  jnSharedStorage: 'jnSharedStorage'
	});
	var VuexBuilder$$1 = /*#__PURE__*/function () {
	  babelHelpers.createClass(VuexBuilder$$1, null, [{
	    key: "create",

	    /**
	     * @deprecated use init() method.
	     * @returns {VuexBuilder}
	     */
	    value: function create() {
	      if (ui_vue.WidgetBitrixVue.developerMode) {
	        console.warn('VuexBuilder: Method VuexBuilder.create is deprecated, use VuexBuilder.init instead.');
	      }

	      return new this();
	    }
	    /**
	     * Create new instance of builder and initialize Vuex store
	     *
	     * @param store {Vuex}
	     *
	     * @returns {VuexBuilder}
	     */

	  }, {
	    key: "init",
	    value: function init(store) {
	      if (store) {
	        if (!(store instanceof Vuex.Store)) {
	          console.warn('VuexBuilder.init: passed store is not a Vuex.Store', store);
	          return new this();
	        }
	      }

	      return new this(store);
	    }
	  }]);

	  function VuexBuilder$$1(store) {
	    babelHelpers.classCallCheck(this, VuexBuilder$$1);
	    this.models = [];
	    this.databaseConfig = {
	      name: null,
	      type: null,
	      siteId: null,
	      userId: null,
	      timeout: null
	    };
	    this.store = store;
	    this.builded = false;
	  }
	  /**
	   * Add Vuex module.
	   *
	   * @param model {VuexBuilderModel}
	   *
	   * @returns {VuexBuilder}
	   */


	  babelHelpers.createClass(VuexBuilder$$1, [{
	    key: "addModel",
	    value: function addModel(model) {
	      if (this.builded) {
	        return this;
	      }

	      if (!(model instanceof VuexBuilderModel$$1)) {
	        console.error('BX.WidgetVuexBuilder.addModel: passed model is not a BX.WidgetVuexBuilderModel', model, name);
	        return this;
	      }

	      this.models.push(model);
	      return this;
	    }
	    /**
	     * Add dynamic Vuex module.
	     *
	     * @param model {VuexBuilderModel}
	     *
	     * @returns {Promise}
	     */

	  }, {
	    key: "addDynamicModel",
	    value: function addDynamicModel(model) {
	      var _this = this;

	      if (!(model instanceof VuexBuilderModel$$1)) {
	        return new Promise(function (resolve, reject) {
	          console.error('BX.WidgetVuexBuilder.addDynamicModel: passed model is not a BX.WidgetVuexBuilderModel', model);
	          reject('MODEL_ERROR');
	        });
	      }

	      if (this.store.hasModule(model.getNamespace()) || this.models.find(function (stored) {
	        return stored.getNamespace() === model.getNamespace();
	      })) {
	        return new Promise(function (resolve, reject) {
	          console.error('BX.WidgetVuexBuilder.addDynamicModel: model `' + model.getNamespace() + '` was not added because it is already registered.');
	          reject('DUPLICATE_MODEL');
	        });
	      }

	      this.models.push(model);

	      if (this.databaseConfig.active && model.databaseConfig.active !== false) {
	        model.useDatabase(true, this.databaseConfig);
	      } else {
	        model.useDatabase(false);
	      }

	      model.setStore(this.store);
	      var promise = model.getModule();
	      return new Promise(function (resolve, reject) {
	        promise.then(function (result) {
	          _this.store.registerModule(result.namespace, result.module);

	          resolve();
	        }, function (error) {
	          console.error('BX.WidgetVuexBuilder.addDynamicModel: storage was not created due to runtime errors.', error ? error : '');
	          reject('ERROR_IN_MODEL');
	        });
	      });
	    }
	    /**
	     * Remove dynamic Vuex module.
	     *
	     * @param namespace {string}
	     *
	     * @returns {VuexBuilder}
	     */

	  }, {
	    key: "removeDynamicModel",
	    value: function removeDynamicModel(namespace) {
	      if (!this.builded) {
	        console.error('BX.WidgetVuexBuilder.removeDynamicModel: you cannot use the method until builder is built.');
	        return this;
	      }

	      if (!this.store.hasModule(namespace)) {
	        console.error('BX.WidgetVuexBuilder.removeDynamicModel: module `' + namespace + '` not registered.');
	        return this;
	      }

	      this.models = this.models.filter(function (stored) {
	        return stored.getNamespace() !== namespace;
	      });
	      this.store.unregisterModule(namespace);
	      return this;
	    }
	    /**
	     * @returns {VuexBuilder}
	     * @deprecated
	     */

	  }, {
	    key: "useNamespace",
	    value: function useNamespace(active) {
	      if (ui_vue.WidgetBitrixVue.developerMode) {
	        if (active) {
	          console.warn('VuexBuilder: Method `useNamespace` is deprecated, please remove this call.');
	        } else {
	          console.error('VuexBuilder: Method `useNamespace` is deprecated, using VuexBuilder without namespaces is no longer supported.');
	        }
	      }

	      return this;
	    }
	    /**
	     * Set database config for all models (except models with "no database" option).
	     *
	     * @param config {{name: String, siteId: String, userId: Number, type: DatabaseType}}
	     * @returns {VuexBuilder}
	     */

	  }, {
	    key: "setDatabaseConfig",
	    value: function setDatabaseConfig() {
	      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	      if (!(babelHelpers["typeof"](config) === 'object' && config)) {
	        return this;
	      }

	      this.databaseConfig.active = true;
	      this.databaseConfig.storage = config.name;
	      this.databaseConfig.type = config.type || this.databaseConfig.type;
	      this.databaseConfig.siteId = config.siteId || this.databaseConfig.siteId;
	      this.databaseConfig.userId = config.userId || this.databaseConfig.userId;
	      this.databaseConfig.timeout = typeof config.timeout !== 'undefined' ? config.timeout : this.databaseConfig.timeout;
	      return this;
	    }
	  }, {
	    key: "clearModelState",
	    value: function clearModelState() {
	      var callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

	      if (!this.builded) {
	        return new Promise(function (resolve, reject) {
	          console.error('BX.WidgetVuexBuilder.clearModelState: you cannot use the method until builder is built.');

	          if (typeof callback !== 'function') {
	            reject('BUILDER_NOT_BUILD');
	          }
	        });
	      }

	      var results = [];
	      this.models.forEach(function (model) {
	        results.push(model.clearState());
	      });
	      return new Promise(function (resolve, reject) {
	        Promise.all(results).then(function (stores) {
	          resolve(true);

	          if (typeof callback === 'function') {
	            callback(true);
	          }
	        }, function (error) {
	          console.error('BX.WidgetVuexBuilder.clearModelState: storage was not clear due to runtime errors.', error ? error : '');

	          if (typeof callback !== 'function') {
	            reject('ERROR_WHILE_CLEARING');
	          }
	        });
	      });
	    }
	  }, {
	    key: "clearDatabase",
	    value: function clearDatabase() {
	      if (!this.builded) {
	        return new Promise(function (resolve, reject) {
	          console.error('BX.WidgetVuexBuilder.clearModelState: you cannot use the method until builder is built.');
	          reject('BUILDER_NOT_BUILD');
	        });
	      }

	      this.models.forEach(function (model) {
	        return model.clearDatabase();
	      });
	      return new Promise(function (resolve, reject) {
	        return resolve(true);
	      });
	    }
	    /**
	     * Build Vuex Store asynchronously
	     *
	     * @param callback {Function|null}
	     * @returns {Promise<any>}
	     */

	  }, {
	    key: "build",
	    value: function build() {
	      var _this2 = this;

	      var callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

	      if (this.builded) {
	        return this;
	      }

	      var promises = [];

	      if (!this.store) {
	        this.store = Vuex.createStore();
	      }

	      this.models.forEach(function (model) {
	        if (_this2.databaseConfig.active && model.databaseConfig.active !== false) {
	          model.useDatabase(true, _this2.databaseConfig);
	        }

	        model.setStore(_this2.store);
	        promises.push(model.getModule());
	      });
	      return new Promise(function (resolve, reject) {
	        Promise.all(promises).then(function (modules) {
	          modules.forEach(function (result) {
	            _this2.store.registerModule(result.namespace, result.module);
	          });
	          var result = {
	            store: _this2.store,
	            models: _this2.models,
	            builder: _this2
	          };
	          _this2.builded = true;

	          if (typeof callback === 'function') {
	            callback(result);
	          }

	          resolve(result);
	        }, function (error) {
	          console.error('BX.WidgetVuexBuilder.create: storage was not created due to runtime errors.', error ? error : '');

	          if (typeof callback !== 'function') {
	            reject('ERROR_IN_MODEL');
	          }
	        });
	      });
	    }
	    /**
	     * Build Vuex Store synchronously
	     *
	     * @returns {Object<any>}
	     */

	  }, {
	    key: "syncBuild",
	    value: function syncBuild() {
	      var _this3 = this;

	      if (this.builded) {
	        return {
	          store: this.store,
	          models: this.models,
	          builder: this
	        };
	      }

	      if (!this.store) {
	        this.store = Vuex.createStore();
	      }

	      if (this.databaseConfig.active) {
	        if (ui_vue.WidgetBitrixVue.developerMode) {
	          console.error('VuexBuilder: Method `syncBuild` creates storage in synchronous mode, the database does not work in this mode.');
	        }

	        this.databaseConfig.active = false;
	      }

	      this.models.forEach(function (model) {
	        model.useDatabase(false);
	        model.setStore(_this3.store);

	        var _model$getModuleWithD = model.getModuleWithDefaultState(),
	            namespace = _model$getModuleWithD.namespace,
	            module = _model$getModuleWithD.module;

	        _this3.store.registerModule(namespace, module);
	      });
	      this.builded = true;
	      return {
	        store: this.store,
	        models: this.models,
	        builder: this
	      };
	    }
	  }]);
	  return VuexBuilder$$1;
	}();
	VuexBuilder$$1.DatabaseType = DatabaseType;

	/*!
	 * vuex v3.6.2
	 * (c) 2021 Evan You
	 * @license MIT
	 *
	 * @source: https://cdn.jsdelivr.net/npm/vuex@3.6.2/dist/vuex.esm.browser.js
	 */

	function applyMixin(Vue) {
	  var version = Number(Vue.version.split('.')[0]);

	  if (version >= 2) {
	    Vue.mixin({
	      beforeCreate: vuexInit
	    });
	  } else {
	    // override init and inject vuex init procedure
	    // for 1.x backwards compatibility.
	    var _init = Vue.prototype._init;

	    Vue.prototype._init = function () {
	      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	      options.init = options.init ? [vuexInit].concat(options.init) : vuexInit;

	      _init.call(this, options);
	    };
	  }
	  /**
	   * Vuex init hook, injected into each instances init hooks list.
	   */


	  function vuexInit() {
	    var options = this.$options; // store injection

	    if (options.store) {
	      this.$store = typeof options.store === 'function' ? options.store() : options.store;
	    } else if (options.parent && options.parent.$store) {
	      this.$store = options.parent.$store;
	    }
	  }
	}

	var target = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : {};
	var devtoolHook = target.__VUE_DEVTOOLS_GLOBAL_HOOK__;

	function devtoolPlugin(store) {
	  if (!devtoolHook) return;
	  store._devtoolHook = devtoolHook;
	  devtoolHook.emit('vuex:init', store);
	  devtoolHook.on('vuex:travel-to-state', function (targetState) {
	    store.replaceState(targetState);
	  });
	  store.subscribe(function (mutation, state) {
	    devtoolHook.emit('vuex:mutation', mutation, state);
	  }, {
	    prepend: true
	  });
	  store.subscribeAction(function (action, state) {
	    devtoolHook.emit('vuex:action', action, state);
	  }, {
	    prepend: true
	  });
	}
	/**
	 * Get the first item that pass the test
	 * by second argument function
	 *
	 * @param {Array} list
	 * @param {Function} f
	 * @return {*}
	 */


	function find(list, f) {
	  return list.filter(f)[0];
	}
	/**
	 * Deep copy the given object considering circular structure.
	 * This function caches all nested objects and its copies.
	 * If it detects circular structure, use cached copy to avoid infinite loop.
	 *
	 * @param {*} obj
	 * @param {Array<Object>} cache
	 * @return {*}
	 */


	function deepCopy(obj) {
	  var cache = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

	  // just return if obj is immutable value
	  if (obj === null || babelHelpers["typeof"](obj) !== 'object') {
	    return obj;
	  } // if obj is hit, it is in circular structure


	  var hit = find(cache, function (c) {
	    return c.original === obj;
	  });

	  if (hit) {
	    return hit.copy;
	  }

	  var copy = Array.isArray(obj) ? [] : {}; // put the copy into cache at first
	  // because we want to refer it in recursive deepCopy

	  cache.push({
	    original: obj,
	    copy: copy
	  });
	  Object.keys(obj).forEach(function (key) {
	    copy[key] = deepCopy(obj[key], cache);
	  });
	  return copy;
	}
	/**
	 * forEach for object
	 */


	function forEachValue(obj, fn) {
	  Object.keys(obj).forEach(function (key) {
	    return fn(obj[key], key);
	  });
	}

	function isObject(obj) {
	  return obj !== null && babelHelpers["typeof"](obj) === 'object';
	}

	function isPromise(val) {
	  return val && typeof val.then === 'function';
	}

	function assert(condition, msg) {
	  if (!condition) throw new Error("[vuex] ".concat(msg));
	}

	function partial(fn, arg) {
	  return function () {
	    return fn(arg);
	  };
	} // Base data struct for store's module, package with some attribute and method


	var Module = /*#__PURE__*/function () {
	  function Module(rawModule, runtime) {
	    babelHelpers.classCallCheck(this, Module);
	    this.runtime = runtime; // Store some children item

	    this._children = Object.create(null); // Store the origin module object which passed by programmer

	    this._rawModule = rawModule;
	    var rawState = rawModule.state; // Store the origin module's state

	    this.state = (typeof rawState === 'function' ? rawState() : rawState) || {};
	  }

	  babelHelpers.createClass(Module, [{
	    key: "addChild",
	    value: function addChild(key, module) {
	      this._children[key] = module;
	    }
	  }, {
	    key: "removeChild",
	    value: function removeChild(key) {
	      delete this._children[key];
	    }
	  }, {
	    key: "getChild",
	    value: function getChild(key) {
	      return this._children[key];
	    }
	  }, {
	    key: "hasChild",
	    value: function hasChild(key) {
	      return key in this._children;
	    }
	  }, {
	    key: "update",
	    value: function update(rawModule) {
	      this._rawModule.namespaced = rawModule.namespaced;

	      if (rawModule.actions) {
	        this._rawModule.actions = rawModule.actions;
	      }

	      if (rawModule.mutations) {
	        this._rawModule.mutations = rawModule.mutations;
	      }

	      if (rawModule.getters) {
	        this._rawModule.getters = rawModule.getters;
	      }
	    }
	  }, {
	    key: "forEachChild",
	    value: function forEachChild(fn) {
	      forEachValue(this._children, fn);
	    }
	  }, {
	    key: "forEachGetter",
	    value: function forEachGetter(fn) {
	      if (this._rawModule.getters) {
	        forEachValue(this._rawModule.getters, fn);
	      }
	    }
	  }, {
	    key: "forEachAction",
	    value: function forEachAction(fn) {
	      if (this._rawModule.actions) {
	        forEachValue(this._rawModule.actions, fn);
	      }
	    }
	  }, {
	    key: "forEachMutation",
	    value: function forEachMutation(fn) {
	      if (this._rawModule.mutations) {
	        forEachValue(this._rawModule.mutations, fn);
	      }
	    }
	  }, {
	    key: "namespaced",
	    get: function get() {
	      return !!this._rawModule.namespaced;
	    }
	  }]);
	  return Module;
	}();

	var ModuleCollection = /*#__PURE__*/function () {
	  function ModuleCollection(rawRootModule) {
	    babelHelpers.classCallCheck(this, ModuleCollection);
	    // register root module (Vuex.Store options)
	    this.register([], rawRootModule, false);
	  }

	  babelHelpers.createClass(ModuleCollection, [{
	    key: "get",
	    value: function get(path) {
	      return path.reduce(function (module, key) {
	        return module.getChild(key);
	      }, this.root);
	    }
	  }, {
	    key: "getNamespace",
	    value: function getNamespace(path) {
	      var module = this.root;
	      return path.reduce(function (namespace, key) {
	        module = module.getChild(key);
	        return namespace + (module.namespaced ? key + '/' : '');
	      }, '');
	    }
	  }, {
	    key: "update",
	    value: function update(rawRootModule) {
	      _update([], this.root, rawRootModule);
	    }
	  }, {
	    key: "register",
	    value: function register(path, rawModule) {
	      var _this = this;

	      var runtime = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
	      {
	        assertRawModule(path, rawModule);
	      }
	      var newModule = new Module(rawModule, runtime);

	      if (path.length === 0) {
	        this.root = newModule;
	      } else {
	        var parent = this.get(path.slice(0, -1));
	        parent.addChild(path[path.length - 1], newModule);
	      } // register nested modules


	      if (rawModule.modules) {
	        forEachValue(rawModule.modules, function (rawChildModule, key) {
	          _this.register(path.concat(key), rawChildModule, runtime);
	        });
	      }
	    }
	  }, {
	    key: "unregister",
	    value: function unregister(path) {
	      var parent = this.get(path.slice(0, -1));
	      var key = path[path.length - 1];
	      var child = parent.getChild(key);

	      if (!child) {
	        {
	          console.warn("[vuex] trying to unregister module '".concat(key, "', which is ") + "not registered");
	        }
	        return;
	      }

	      if (!child.runtime) {
	        return;
	      }

	      parent.removeChild(key);
	    }
	  }, {
	    key: "isRegistered",
	    value: function isRegistered(path) {
	      var parent = this.get(path.slice(0, -1));
	      var key = path[path.length - 1];

	      if (parent) {
	        return parent.hasChild(key);
	      }

	      return false;
	    }
	  }]);
	  return ModuleCollection;
	}();

	function _update(path, targetModule, newModule) {
	  {
	    assertRawModule(path, newModule);
	  } // update target module

	  targetModule.update(newModule); // update nested modules

	  if (newModule.modules) {
	    for (var key in newModule.modules) {
	      if (!targetModule.getChild(key)) {
	        {
	          console.warn("[vuex] trying to add a new module '".concat(key, "' on hot reloading, ") + 'manual reload is needed');
	        }
	        return;
	      }

	      _update(path.concat(key), targetModule.getChild(key), newModule.modules[key]);
	    }
	  }
	}

	var functionAssert = {
	  assert: function assert(value) {
	    return typeof value === 'function';
	  },
	  expected: 'function'
	};
	var objectAssert = {
	  assert: function assert(value) {
	    return typeof value === 'function' || babelHelpers["typeof"](value) === 'object' && typeof value.handler === 'function';
	  },
	  expected: 'function or object with "handler" function'
	};
	var assertTypes = {
	  getters: functionAssert,
	  mutations: functionAssert,
	  actions: objectAssert
	};

	function assertRawModule(path, rawModule) {
	  Object.keys(assertTypes).forEach(function (key) {
	    if (!rawModule[key]) return;
	    var assertOptions = assertTypes[key];
	    forEachValue(rawModule[key], function (value, type) {
	      assert(assertOptions.assert(value), makeAssertionMessage(path, key, type, value, assertOptions.expected));
	    });
	  });
	}

	function makeAssertionMessage(path, key, type, value, expected) {
	  var buf = "".concat(key, " should be ").concat(expected, " but \"").concat(key, ".").concat(type, "\"");

	  if (path.length > 0) {
	    buf += " in module \"".concat(path.join('.'), "\"");
	  }

	  buf += " is ".concat(JSON.stringify(value), ".");
	  return buf;
	}

	var Store = /*#__PURE__*/function () {
	  function Store() {
	    var _this2 = this;

	    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	    babelHelpers.classCallCheck(this, Store);

	    // Auto install if it is not done yet and `window` has `Vue`.
	    // To allow users to avoid auto-installation in some cases,
	    // this code should be placed here. See #731
	    if (!ui_vue.WidgetVueVendor && typeof window !== 'undefined' && window.Vue) {
	      install(window.Vue);
	    }

	    {
	      assert(ui_vue.WidgetVueVendor, "must call Vue.use(Vuex) before creating a store instance.");
	      assert(typeof Promise !== 'undefined', "vuex requires a Promise polyfill in this browser.");
	      assert(this instanceof Store, "store must be called with the new operator.");
	    }
	    var _options$plugins = options.plugins,
	        plugins = _options$plugins === void 0 ? [] : _options$plugins,
	        _options$strict = options.strict,
	        strict = _options$strict === void 0 ? false : _options$strict; // store internal state

	    this._committing = false;
	    this._actions = Object.create(null);
	    this._actionSubscribers = [];
	    this._mutations = Object.create(null);
	    this._wrappedGetters = Object.create(null);
	    this._modules = new ModuleCollection(options);
	    this._modulesNamespaceMap = Object.create(null);
	    this._subscribers = [];
	    this._watcherVM = new ui_vue.WidgetVueVendor();
	    this._makeLocalGettersCache = Object.create(null); // bind commit and dispatch to self

	    var store = this;
	    var dispatch = this.dispatch,
	        commit = this.commit;

	    this.dispatch = function boundDispatch(type, payload) {
	      return dispatch.call(store, type, payload);
	    };

	    this.commit = function boundCommit(type, payload, options) {
	      return commit.call(store, type, payload, options);
	    }; // strict mode


	    this.strict = strict;
	    var state = this._modules.root.state; // init root module.
	    // this also recursively registers all sub-modules
	    // and collects all module getters inside this._wrappedGetters

	    installModule(this, state, [], this._modules.root); // initialize the store vm, which is responsible for the reactivity
	    // (also registers _wrappedGetters as computed properties)

	    resetStoreVM(this, state); // apply plugins

	    plugins.forEach(function (plugin) {
	      return plugin(_this2);
	    });
	    var useDevtools = options.devtools !== undefined ? options.devtools : ui_vue.WidgetVueVendor.config.devtools;

	    if (useDevtools) {
	      devtoolPlugin(this);
	    }
	  }

	  babelHelpers.createClass(Store, [{
	    key: "commit",
	    value: function commit(_type, _payload, _options) {
	      var _this3 = this;

	      // check object-style commit
	      var _unifyObjectStyle = unifyObjectStyle(_type, _payload, _options),
	          type = _unifyObjectStyle.type,
	          payload = _unifyObjectStyle.payload,
	          options = _unifyObjectStyle.options;

	      var mutation = {
	        type: type,
	        payload: payload
	      };
	      var entry = this._mutations[type];

	      if (!entry) {
	        {
	          console.error("[vuex] unknown mutation type: ".concat(type));
	        }
	        return;
	      }

	      this._withCommit(function () {
	        entry.forEach(function commitIterator(handler) {
	          handler(payload);
	        });
	      });

	      this._subscribers.slice() // shallow copy to prevent iterator invalidation if subscriber synchronously calls unsubscribe
	      .forEach(function (sub) {
	        return sub(mutation, _this3.state);
	      });

	      if (options && options.silent) {
	        console.warn("[vuex] mutation type: ".concat(type, ". Silent option has been removed. ") + 'Use the filter functionality in the vue-devtools');
	      }
	    }
	  }, {
	    key: "dispatch",
	    value: function dispatch(_type, _payload) {
	      var _this4 = this;

	      // check object-style dispatch
	      var _unifyObjectStyle2 = unifyObjectStyle(_type, _payload),
	          type = _unifyObjectStyle2.type,
	          payload = _unifyObjectStyle2.payload;

	      var action = {
	        type: type,
	        payload: payload
	      };
	      var entry = this._actions[type];

	      if (!entry) {
	        {
	          console.error("[vuex] unknown action type: ".concat(type));
	        }
	        return;
	      }

	      try {
	        this._actionSubscribers.slice() // shallow copy to prevent iterator invalidation if subscriber synchronously calls unsubscribe
	        .filter(function (sub) {
	          return sub.before;
	        }).forEach(function (sub) {
	          return sub.before(action, _this4.state);
	        });
	      } catch (e) {
	        {
	          console.warn("[vuex] error in before action subscribers: ");
	          console.error(e);
	        }
	      }

	      var result = entry.length > 1 ? Promise.all(entry.map(function (handler) {
	        return handler(payload);
	      })) : entry[0](payload);
	      return new Promise(function (resolve, reject) {
	        result.then(function (res) {
	          try {
	            _this4._actionSubscribers.filter(function (sub) {
	              return sub.after;
	            }).forEach(function (sub) {
	              return sub.after(action, _this4.state);
	            });
	          } catch (e) {
	            {
	              console.warn("[vuex] error in after action subscribers: ");
	              console.error(e);
	            }
	          }

	          resolve(res);
	        }, function (error) {
	          try {
	            _this4._actionSubscribers.filter(function (sub) {
	              return sub.error;
	            }).forEach(function (sub) {
	              return sub.error(action, _this4.state, error);
	            });
	          } catch (e) {
	            {
	              console.warn("[vuex] error in error action subscribers: ");
	              console.error(e);
	            }
	          }

	          reject(error);
	        });
	      });
	    }
	  }, {
	    key: "subscribe",
	    value: function subscribe(fn, options) {
	      return genericSubscribe(fn, this._subscribers, options);
	    }
	  }, {
	    key: "subscribeAction",
	    value: function subscribeAction(fn, options) {
	      var subs = typeof fn === 'function' ? {
	        before: fn
	      } : fn;
	      return genericSubscribe(subs, this._actionSubscribers, options);
	    }
	  }, {
	    key: "watch",
	    value: function watch(getter, cb, options) {
	      var _this5 = this;

	      {
	        assert(typeof getter === 'function', "store.watch only accepts a function.");
	      }
	      return this._watcherVM.$watch(function () {
	        return getter(_this5.state, _this5.getters);
	      }, cb, options);
	    }
	  }, {
	    key: "replaceState",
	    value: function replaceState(state) {
	      var _this6 = this;

	      this._withCommit(function () {
	        _this6._vm._data.$$state = state;
	      });
	    }
	  }, {
	    key: "registerModule",
	    value: function registerModule(path, rawModule) {
	      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
	      if (typeof path === 'string') path = [path];
	      {
	        assert(Array.isArray(path), "module path must be a string or an Array.");
	        assert(path.length > 0, 'cannot register the root module by using registerModule.');
	      }

	      this._modules.register(path, rawModule);

	      installModule(this, this.state, path, this._modules.get(path), options.preserveState); // reset store to update getters...

	      resetStoreVM(this, this.state);
	    }
	  }, {
	    key: "unregisterModule",
	    value: function unregisterModule(path) {
	      var _this7 = this;

	      if (typeof path === 'string') path = [path];
	      {
	        assert(Array.isArray(path), "module path must be a string or an Array.");
	      }

	      this._modules.unregister(path);

	      this._withCommit(function () {
	        var parentState = getNestedState(_this7.state, path.slice(0, -1));
	        ui_vue.WidgetVueVendor["delete"](parentState, path[path.length - 1]);
	      });

	      resetStore(this);
	    }
	  }, {
	    key: "hasModule",
	    value: function hasModule(path) {
	      if (typeof path === 'string') path = [path];
	      {
	        assert(Array.isArray(path), "module path must be a string or an Array.");
	      }
	      return this._modules.isRegistered(path);
	    }
	  }, {
	    key: "hotUpdate",
	    value: function hotUpdate(newOptions) {
	      this._modules.update(newOptions);

	      resetStore(this, true);
	    }
	  }, {
	    key: "_withCommit",
	    value: function _withCommit(fn) {
	      var committing = this._committing;
	      this._committing = true;
	      fn();
	      this._committing = committing;
	    }
	  }, {
	    key: "state",
	    get: function get() {
	      return this._vm._data.$$state;
	    },
	    set: function set(v) {
	      {
	        assert(false, "use store.replaceState() to explicit replace store state.");
	      }
	    }
	  }]);
	  return Store;
	}();

	function genericSubscribe(fn, subs, options) {
	  if (subs.indexOf(fn) < 0) {
	    options && options.prepend ? subs.unshift(fn) : subs.push(fn);
	  }

	  return function () {
	    var i = subs.indexOf(fn);

	    if (i > -1) {
	      subs.splice(i, 1);
	    }
	  };
	}

	function resetStore(store, hot) {
	  store._actions = Object.create(null);
	  store._mutations = Object.create(null);
	  store._wrappedGetters = Object.create(null);
	  store._modulesNamespaceMap = Object.create(null);
	  var state = store.state; // init all modules

	  installModule(store, state, [], store._modules.root, true); // reset vm

	  resetStoreVM(store, state, hot);
	}

	function resetStoreVM(store, state, hot) {
	  var oldVm = store._vm; // bind store public getters

	  store.getters = {}; // reset local getters cache

	  store._makeLocalGettersCache = Object.create(null);
	  var wrappedGetters = store._wrappedGetters;
	  var computed = {};
	  forEachValue(wrappedGetters, function (fn, key) {
	    // use computed to leverage its lazy-caching mechanism
	    // direct inline function use will lead to closure preserving oldVm.
	    // using partial to return function with only arguments preserved in closure environment.
	    computed[key] = partial(fn, store);
	    Object.defineProperty(store.getters, key, {
	      get: function get() {
	        return store._vm[key];
	      },
	      enumerable: true // for local getters

	    });
	  }); // use a Vue instance to store the state tree
	  // suppress warnings just in case the user has added
	  // some funky global mixins

	  var silent = ui_vue.WidgetVueVendor.config.silent;
	  ui_vue.WidgetVueVendor.config.silent = true;
	  store._vm = new ui_vue.WidgetVueVendor({
	    data: {
	      $$state: state
	    },
	    computed: computed
	  });
	  ui_vue.WidgetVueVendor.config.silent = silent; // enable strict mode for new vm

	  if (store.strict) {
	    enableStrictMode(store);
	  }

	  if (oldVm) {
	    if (hot) {
	      // dispatch changes in all subscribed watchers
	      // to force getter re-evaluation for hot reloading.
	      store._withCommit(function () {
	        oldVm._data.$$state = null;
	      });
	    }

	    ui_vue.WidgetVueVendor.nextTick(function () {
	      return oldVm.$destroy();
	    });
	  }
	}

	function installModule(store, rootState, path, module, hot) {
	  var isRoot = !path.length;

	  var namespace = store._modules.getNamespace(path); // register in namespace map


	  if (module.namespaced) {
	    if (store._modulesNamespaceMap[namespace] && true) {
	      console.error("[vuex] duplicate namespace ".concat(namespace, " for the namespaced module ").concat(path.join('/')));
	    }

	    store._modulesNamespaceMap[namespace] = module;
	  } // set state


	  if (!isRoot && !hot) {
	    var parentState = getNestedState(rootState, path.slice(0, -1));
	    var moduleName = path[path.length - 1];

	    store._withCommit(function () {
	      {
	        if (moduleName in parentState) {
	          console.warn("[vuex] state field \"".concat(moduleName, "\" was overridden by a module with the same name at \"").concat(path.join('.'), "\""));
	        }
	      }
	      ui_vue.WidgetVueVendor.set(parentState, moduleName, module.state);
	    });
	  }

	  var local = module.context = makeLocalContext(store, namespace, path);
	  module.forEachMutation(function (mutation, key) {
	    var namespacedType = namespace + key;
	    registerMutation(store, namespacedType, mutation, local);
	  });
	  module.forEachAction(function (action, key) {
	    var type = action.root ? key : namespace + key;
	    var handler = action.handler || action;
	    registerAction(store, type, handler, local);
	  });
	  module.forEachGetter(function (getter, key) {
	    var namespacedType = namespace + key;
	    registerGetter(store, namespacedType, getter, local);
	  });
	  module.forEachChild(function (child, key) {
	    installModule(store, rootState, path.concat(key), child, hot);
	  });
	}
	/**
	 * make localized dispatch, commit, getters and state
	 * if there is no namespace, just use root ones
	 */


	function makeLocalContext(store, namespace, path) {
	  var noNamespace = namespace === '';
	  var local = {
	    dispatch: noNamespace ? store.dispatch : function (_type, _payload, _options) {
	      var args = unifyObjectStyle(_type, _payload, _options);
	      var payload = args.payload,
	          options = args.options;
	      var type = args.type;

	      if (!options || !options.root) {
	        type = namespace + type;

	        if (!store._actions[type]) {
	          console.error("[vuex] unknown local action type: ".concat(args.type, ", global type: ").concat(type));
	          return;
	        }
	      }

	      return store.dispatch(type, payload);
	    },
	    commit: noNamespace ? store.commit : function (_type, _payload, _options) {
	      var args = unifyObjectStyle(_type, _payload, _options);
	      var payload = args.payload,
	          options = args.options;
	      var type = args.type;

	      if (!options || !options.root) {
	        type = namespace + type;

	        if (!store._mutations[type]) {
	          console.error("[vuex] unknown local mutation type: ".concat(args.type, ", global type: ").concat(type));
	          return;
	        }
	      }

	      store.commit(type, payload, options);
	    }
	  }; // getters and state object must be gotten lazily
	  // because they will be changed by vm update

	  Object.defineProperties(local, {
	    getters: {
	      get: noNamespace ? function () {
	        return store.getters;
	      } : function () {
	        return makeLocalGetters(store, namespace);
	      }
	    },
	    state: {
	      get: function get() {
	        return getNestedState(store.state, path);
	      }
	    }
	  });
	  return local;
	}

	function makeLocalGetters(store, namespace) {
	  if (!store._makeLocalGettersCache[namespace]) {
	    var gettersProxy = {};
	    var splitPos = namespace.length;
	    Object.keys(store.getters).forEach(function (type) {
	      // skip if the target getter is not match this namespace
	      if (type.slice(0, splitPos) !== namespace) return; // extract local getter type

	      var localType = type.slice(splitPos); // Add a port to the getters proxy.
	      // Define as getter property because
	      // we do not want to evaluate the getters in this time.

	      Object.defineProperty(gettersProxy, localType, {
	        get: function get() {
	          return store.getters[type];
	        },
	        enumerable: true
	      });
	    });
	    store._makeLocalGettersCache[namespace] = gettersProxy;
	  }

	  return store._makeLocalGettersCache[namespace];
	}

	function registerMutation(store, type, handler, local) {
	  var entry = store._mutations[type] || (store._mutations[type] = []);
	  entry.push(function wrappedMutationHandler(payload) {
	    handler.call(store, local.state, payload);
	  });
	}

	function registerAction(store, type, handler, local) {
	  var entry = store._actions[type] || (store._actions[type] = []);
	  entry.push(function wrappedActionHandler(payload) {
	    var res = handler.call(store, {
	      dispatch: local.dispatch,
	      commit: local.commit,
	      getters: local.getters,
	      state: local.state,
	      rootGetters: store.getters,
	      rootState: store.state
	    }, payload);

	    if (!isPromise(res)) {
	      res = Promise.resolve(res);
	    }

	    if (store._devtoolHook) {
	      return res["catch"](function (err) {
	        store._devtoolHook.emit('vuex:error', err);

	        throw err;
	      });
	    } else {
	      return res;
	    }
	  });
	}

	function registerGetter(store, type, rawGetter, local) {
	  if (store._wrappedGetters[type]) {
	    {
	      console.error("[vuex] duplicate getter key: ".concat(type));
	    }
	    return;
	  }

	  store._wrappedGetters[type] = function wrappedGetter(store) {
	    return rawGetter(local.state, // local state
	    local.getters, // local getters
	    store.state, // root state
	    store.getters // root getters
	    );
	  };
	}

	function enableStrictMode(store) {
	  store._vm.$watch(function () {
	    return this._data.$$state;
	  }, function () {
	    {
	      assert(store._committing, "do not mutate vuex store state outside mutation handlers.");
	    }
	  }, {
	    deep: true,
	    sync: true
	  });
	}

	function getNestedState(state, path) {
	  return path.reduce(function (state, key) {
	    return state[key];
	  }, state);
	}

	function unifyObjectStyle(type, payload, options) {
	  if (isObject(type) && type.type) {
	    options = payload;
	    payload = type;
	    type = type.type;
	  }

	  {
	    assert(typeof type === 'string', "expects string as the type, but found ".concat(babelHelpers["typeof"](type), "."));
	  }
	  return {
	    type: type,
	    payload: payload,
	    options: options
	  };
	}

	function install(_Vue) {
	  applyMixin(_Vue);
	}
	/**
	 * Reduce the code which written in Vue.js for getting the state.
	 * @param {String} [namespace] - Module's namespace
	 * @param {Object|Array} states # Object's item can be a function which accept state and getters for param, you can do something for state and getters in it.
	 * @param {Object}
	 */


	var mapState = normalizeNamespace(function (namespace, states) {
	  var res = {};

	  if (!isValidMap(states)) {
	    console.error('[vuex] mapState: mapper parameter must be either an Array or an Object');
	  }

	  normalizeMap(states).forEach(function (_ref) {
	    var key = _ref.key,
	        val = _ref.val;

	    res[key] = function mappedState() {
	      var state = this.$store.state;
	      var getters = this.$store.getters;

	      if (namespace) {
	        var module = getModuleByNamespace(this.$store, 'mapState', namespace);

	        if (!module) {
	          return;
	        }

	        state = module.context.state;
	        getters = module.context.getters;
	      }

	      return typeof val === 'function' ? val.call(this, state, getters) : state[val];
	    }; // mark vuex getter for devtools


	    res[key].vuex = true;
	  });
	  return res;
	});
	/**
	 * Reduce the code which written in Vue.js for committing the mutation
	 * @param {String} [namespace] - Module's namespace
	 * @param {Object|Array} mutations # Object's item can be a function which accept `commit` function as the first param, it can accept another params. You can commit mutation and do any other things in this function. specially, You need to pass anthor params from the mapped function.
	 * @return {Object}
	 */

	var mapMutations = normalizeNamespace(function (namespace, mutations) {
	  var res = {};

	  if (!isValidMap(mutations)) {
	    console.error('[vuex] mapMutations: mapper parameter must be either an Array or an Object');
	  }

	  normalizeMap(mutations).forEach(function (_ref2) {
	    var key = _ref2.key,
	        val = _ref2.val;

	    res[key] = function mappedMutation() {
	      // Get the commit method from store
	      var commit = this.$store.commit;

	      if (namespace) {
	        var module = getModuleByNamespace(this.$store, 'mapMutations', namespace);

	        if (!module) {
	          return;
	        }

	        commit = module.context.commit;
	      }

	      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
	        args[_key] = arguments[_key];
	      }

	      return typeof val === 'function' ? val.apply(this, [commit].concat(args)) : commit.apply(this.$store, [val].concat(args));
	    };
	  });
	  return res;
	});
	/**
	 * Reduce the code which written in Vue.js for getting the getters
	 * @param {String} [namespace] - Module's namespace
	 * @param {Object|Array} getters
	 * @return {Object}
	 */

	var mapGetters = normalizeNamespace(function (namespace, getters) {
	  var res = {};

	  if (!isValidMap(getters)) {
	    console.error('[vuex] mapGetters: mapper parameter must be either an Array or an Object');
	  }

	  normalizeMap(getters).forEach(function (_ref3) {
	    var key = _ref3.key,
	        val = _ref3.val;
	    // The namespace has been mutated by normalizeNamespace
	    val = namespace + val;

	    res[key] = function mappedGetter() {
	      if (namespace && !getModuleByNamespace(this.$store, 'mapGetters', namespace)) {
	        return;
	      }

	      if (!(val in this.$store.getters)) {
	        console.error("[vuex] unknown getter: ".concat(val));
	        return;
	      }

	      return this.$store.getters[val];
	    }; // mark vuex getter for devtools


	    res[key].vuex = true;
	  });
	  return res;
	});
	/**
	 * Reduce the code which written in Vue.js for dispatch the action
	 * @param {String} [namespace] - Module's namespace
	 * @param {Object|Array} actions # Object's item can be a function which accept `dispatch` function as the first param, it can accept anthor params. You can dispatch action and do any other things in this function. specially, You need to pass anthor params from the mapped function.
	 * @return {Object}
	 */

	var mapActions = normalizeNamespace(function (namespace, actions) {
	  var res = {};

	  if (!isValidMap(actions)) {
	    console.error('[vuex] mapActions: mapper parameter must be either an Array or an Object');
	  }

	  normalizeMap(actions).forEach(function (_ref4) {
	    var key = _ref4.key,
	        val = _ref4.val;

	    res[key] = function mappedAction() {
	      // get dispatch function from store
	      var dispatch = this.$store.dispatch;

	      if (namespace) {
	        var module = getModuleByNamespace(this.$store, 'mapActions', namespace);

	        if (!module) {
	          return;
	        }

	        dispatch = module.context.dispatch;
	      }

	      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
	        args[_key2] = arguments[_key2];
	      }

	      return typeof val === 'function' ? val.apply(this, [dispatch].concat(args)) : dispatch.apply(this.$store, [val].concat(args));
	    };
	  });
	  return res;
	});
	/**
	 * Rebinding namespace param for mapXXX function in special scoped, and return them by simple object
	 * @param {String} namespace
	 * @return {Object}
	 */

	var createNamespacedHelpers = function createNamespacedHelpers(namespace) {
	  return {
	    mapState: mapState.bind(null, namespace),
	    mapGetters: mapGetters.bind(null, namespace),
	    mapMutations: mapMutations.bind(null, namespace),
	    mapActions: mapActions.bind(null, namespace)
	  };
	};
	/**
	 * Normalize the map
	 * normalizeMap([1, 2, 3]) => [ { key: 1, val: 1 }, { key: 2, val: 2 }, { key: 3, val: 3 } ]
	 * normalizeMap({a: 1, b: 2, c: 3}) => [ { key: 'a', val: 1 }, { key: 'b', val: 2 }, { key: 'c', val: 3 } ]
	 * @param {Array|Object} map
	 * @return {Object}
	 */


	function normalizeMap(map) {
	  if (!isValidMap(map)) {
	    return [];
	  }

	  return Array.isArray(map) ? map.map(function (key) {
	    return {
	      key: key,
	      val: key
	    };
	  }) : Object.keys(map).map(function (key) {
	    return {
	      key: key,
	      val: map[key]
	    };
	  });
	}
	/**
	 * Validate whether given map is valid or not
	 * @param {*} map
	 * @return {Boolean}
	 */


	function isValidMap(map) {
	  return Array.isArray(map) || isObject(map);
	}
	/**
	 * Return a function expect two param contains namespace and map. it will normalize the namespace and then the param's function will handle the new namespace and the map.
	 * @param {Function} fn
	 * @return {Function}
	 */


	function normalizeNamespace(fn) {
	  return function (namespace, map) {
	    if (typeof namespace !== 'string') {
	      map = namespace;
	      namespace = '';
	    } else if (namespace.charAt(namespace.length - 1) !== '/') {
	      namespace += '/';
	    }

	    return fn(namespace, map);
	  };
	}
	/**
	 * Search a special module from store by namespace. if module not exist, print error message.
	 * @param {Object} store
	 * @param {String} helper
	 * @param {String} namespace
	 * @return {Object}
	 */


	function getModuleByNamespace(store, helper, namespace) {
	  var module = store._modulesNamespaceMap[namespace];

	  if (!module) {
	    console.error("[vuex] module namespace not found in ".concat(helper, "(): ").concat(namespace));
	  }

	  return module;
	} // Credits: borrowed code from fcomb/redux-logger


	function createLogger() {
	  var _ref5 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	      _ref5$collapsed = _ref5.collapsed,
	      collapsed = _ref5$collapsed === void 0 ? true : _ref5$collapsed,
	      _ref5$filter = _ref5.filter,
	      filter = _ref5$filter === void 0 ? function (mutation, stateBefore, stateAfter) {
	    return true;
	  } : _ref5$filter,
	      _ref5$transformer = _ref5.transformer,
	      transformer = _ref5$transformer === void 0 ? function (state) {
	    return state;
	  } : _ref5$transformer,
	      _ref5$mutationTransfo = _ref5.mutationTransformer,
	      mutationTransformer = _ref5$mutationTransfo === void 0 ? function (mut) {
	    return mut;
	  } : _ref5$mutationTransfo,
	      _ref5$actionFilter = _ref5.actionFilter,
	      actionFilter = _ref5$actionFilter === void 0 ? function (action, state) {
	    return true;
	  } : _ref5$actionFilter,
	      _ref5$actionTransform = _ref5.actionTransformer,
	      actionTransformer = _ref5$actionTransform === void 0 ? function (act) {
	    return act;
	  } : _ref5$actionTransform,
	      _ref5$logMutations = _ref5.logMutations,
	      logMutations = _ref5$logMutations === void 0 ? true : _ref5$logMutations,
	      _ref5$logActions = _ref5.logActions,
	      logActions = _ref5$logActions === void 0 ? true : _ref5$logActions,
	      _ref5$logger = _ref5.logger,
	      logger = _ref5$logger === void 0 ? console : _ref5$logger;

	  return function (store) {
	    var prevState = deepCopy(store.state);

	    if (typeof logger === 'undefined') {
	      return;
	    }

	    if (logMutations) {
	      store.subscribe(function (mutation, state) {
	        var nextState = deepCopy(state);

	        if (filter(mutation, prevState, nextState)) {
	          var formattedTime = getFormattedTime();
	          var formattedMutation = mutationTransformer(mutation);
	          var message = "mutation ".concat(mutation.type).concat(formattedTime);
	          startMessage(logger, message, collapsed);
	          logger.log('%c prev state', 'color: #9E9E9E; font-weight: bold', transformer(prevState));
	          logger.log('%c mutation', 'color: #03A9F4; font-weight: bold', formattedMutation);
	          logger.log('%c next state', 'color: #4CAF50; font-weight: bold', transformer(nextState));
	          endMessage(logger);
	        }

	        prevState = nextState;
	      });
	    }

	    if (logActions) {
	      store.subscribeAction(function (action, state) {
	        if (actionFilter(action, state)) {
	          var formattedTime = getFormattedTime();
	          var formattedAction = actionTransformer(action);
	          var message = "action ".concat(action.type).concat(formattedTime);
	          startMessage(logger, message, collapsed);
	          logger.log('%c action', 'color: #03A9F4; font-weight: bold', formattedAction);
	          endMessage(logger);
	        }
	      });
	    }
	  };
	}

	function startMessage(logger, message, collapsed) {
	  var startMessage = collapsed ? logger.groupCollapsed : logger.group; // render

	  try {
	    startMessage.call(logger, message);
	  } catch (e) {
	    logger.log(message);
	  }
	}

	function endMessage(logger) {
	  try {
	    logger.groupEnd();
	  } catch (e) {
	    logger.log('—— log end ——');
	  }
	}

	function getFormattedTime() {
	  var time = new Date();
	  return " @ ".concat(pad(time.getHours(), 2), ":").concat(pad(time.getMinutes(), 2), ":").concat(pad(time.getSeconds(), 2), ".").concat(pad(time.getMilliseconds(), 3));
	}

	function repeat(str, times) {
	  return new Array(times + 1).join(str);
	}

	function pad(num, maxLength) {
	  return repeat('0', maxLength - num.toString().length) + num;
	}

	var Vuex = {
	  store: function store(params) {
	    return new Store(params);
	  },
	  createStore: function createStore(params) {
	    return new Store(params);
	  },
	  Store: Store,
	  install: install,
	  version: '3.6.2',
	  mapState: mapState,
	  mapMutations: mapMutations,
	  mapGetters: mapGetters,
	  mapActions: mapActions,
	  createNamespacedHelpers: createNamespacedHelpers,
	  createLogger: createLogger
	};
	ui_vue.WidgetVueVendor.use(Vuex);

	exports.WidgetVuexBuilder = VuexBuilder$$1;
	exports.WidgetVuexBuilderModel = VuexBuilderModel$$1;
	exports.WidgetVuex = Vuex;
	exports.WidgetVuexVendorV3 = Vuex;
	exports.WidgetVuexVendor = Vuex;

}((this.BX = this.BX || {}),BX,BX,BX));



})();
 



// file: /bitrix/js/im/lib/logger/dist/logger.bundle.js
this.BX = this.BX || {};
this.BX.Messenger = this.BX.Messenger || {};
(function (exports) {
	'use strict';

	function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { babelHelpers.defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

	function _classPrivateFieldInitSpec(obj, privateMap, value) { _checkPrivateRedeclaration(obj, privateMap); privateMap.set(obj, value); }

	function _checkPrivateRedeclaration(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError("Cannot initialize the same private elements twice on an object"); } }

	var _types = /*#__PURE__*/new WeakMap();

	var _config = /*#__PURE__*/new WeakMap();

	var _custom = /*#__PURE__*/new WeakMap();

	/**
	 * Bitrix Messenger
	 * Logger class
	 *
	 * @package bitrix
	 * @subpackage im
	 * @copyright 2001-2019 Bitrix
	 */
	var Logger = /*#__PURE__*/function () {
	  function Logger() {
	    babelHelpers.classCallCheck(this, Logger);

	    _classPrivateFieldInitSpec(this, _types, {
	      writable: true,
	      value: {}
	    });

	    _classPrivateFieldInitSpec(this, _config, {
	      writable: true,
	      value: {}
	    });

	    _classPrivateFieldInitSpec(this, _custom, {
	      writable: true,
	      value: {}
	    });

	    babelHelpers.classPrivateFieldSet(this, _types, {
	      desktop: true,
	      log: false,
	      info: false,
	      warn: false,
	      error: true,
	      trace: true
	    });
	    babelHelpers.classPrivateFieldSet(this, _config, babelHelpers.classPrivateFieldGet(this, _types));

	    this.__load();
	  }

	  babelHelpers.createClass(Logger, [{
	    key: "setConfig",
	    value: function setConfig(types) {
	      for (var type in types) {
	        if (types.hasOwnProperty(type) && typeof babelHelpers.classPrivateFieldGet(this, _types)[type] !== 'undefined') {
	          babelHelpers.classPrivateFieldGet(this, _types)[type] = !!types[type];
	          babelHelpers.classPrivateFieldGet(this, _config)[type] = !!types[type];
	        }
	      }

	      this.__load();
	    }
	  }, {
	    key: "enable",
	    value: function enable(type) {
	      if (typeof babelHelpers.classPrivateFieldGet(this, _types)[type] === 'undefined') {
	        return false;
	      }

	      babelHelpers.classPrivateFieldGet(this, _types)[type] = true;
	      babelHelpers.classPrivateFieldGet(this, _custom)[type] = true;

	      this.__save();

	      return true;
	    }
	  }, {
	    key: "disable",
	    value: function disable(type) {
	      if (typeof babelHelpers.classPrivateFieldGet(this, _types)[type] === 'undefined') {
	        return false;
	      }

	      babelHelpers.classPrivateFieldGet(this, _types)[type] = false;
	      babelHelpers.classPrivateFieldGet(this, _custom)[type] = false;

	      this.__save();

	      return true;
	    }
	  }, {
	    key: "isEnabled",
	    value: function isEnabled(type) {
	      return babelHelpers.classPrivateFieldGet(this, _types)[type] === true;
	    }
	  }, {
	    key: "desktop",
	    value: function desktop() {
	      if (this.isEnabled('desktop')) {
	        var _console;

	        for (var _len = arguments.length, params = new Array(_len), _key = 0; _key < _len; _key++) {
	          params[_key] = arguments[_key];
	        }

	        (_console = console).log.apply(_console, [].concat(babelHelpers.toConsumableArray(this.__getStyles('desktop')), params));
	      }
	    }
	  }, {
	    key: "log",
	    value: function log() {
	      if (this.isEnabled('log')) {
	        var _console2;

	        for (var _len2 = arguments.length, params = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
	          params[_key2] = arguments[_key2];
	        }

	        (_console2 = console).log.apply(_console2, [].concat(babelHelpers.toConsumableArray(this.__getStyles('log')), params));
	      }
	    }
	  }, {
	    key: "info",
	    value: function info() {
	      if (this.isEnabled('info')) {
	        var _console3;

	        for (var _len3 = arguments.length, params = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
	          params[_key3] = arguments[_key3];
	        }

	        (_console3 = console).info.apply(_console3, [].concat(babelHelpers.toConsumableArray(this.__getStyles('info')), params));
	      }
	    }
	  }, {
	    key: "warn",
	    value: function warn() {
	      if (this.isEnabled('warn')) {
	        var _console4;

	        for (var _len4 = arguments.length, params = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
	          params[_key4] = arguments[_key4];
	        }

	        (_console4 = console).warn.apply(_console4, [].concat(babelHelpers.toConsumableArray(this.__getStyles('warn')), params));
	      }
	    }
	  }, {
	    key: "error",
	    value: function error() {
	      if (this.isEnabled('error')) {
	        var _console5;

	        for (var _len5 = arguments.length, params = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
	          params[_key5] = arguments[_key5];
	        }

	        (_console5 = console).error.apply(_console5, [].concat(babelHelpers.toConsumableArray(this.__getStyles('error')), params));
	      }
	    }
	  }, {
	    key: "trace",
	    value: function trace() {
	      if (this.isEnabled('trace')) {
	        var _console6;

	        (_console6 = console).trace.apply(_console6, arguments);
	      }
	    }
	  }, {
	    key: "__save",
	    value: function __save() {
	      if (typeof window.localStorage !== 'undefined') {
	        try {
	          var custom = {};

	          for (var type in babelHelpers.classPrivateFieldGet(this, _custom)) {
	            if (babelHelpers.classPrivateFieldGet(this, _custom).hasOwnProperty(type) && babelHelpers.classPrivateFieldGet(this, _config)[type] !== babelHelpers.classPrivateFieldGet(this, _custom)[type]) {
	              custom[type] = !!babelHelpers.classPrivateFieldGet(this, _custom)[type];
	            }
	          }

	          console.warn(JSON.stringify(custom));
	          window.localStorage.setItem('bx-messenger-logger', JSON.stringify(custom));
	        } catch (e) {}
	      }
	    }
	  }, {
	    key: "__load",
	    value: function __load() {
	      if (typeof window.localStorage !== 'undefined') {
	        try {
	          var custom = window.localStorage.getItem('bx-messenger-logger');

	          if (typeof custom === 'string') {
	            babelHelpers.classPrivateFieldSet(this, _custom, JSON.parse(custom));
	            babelHelpers.classPrivateFieldSet(this, _types, _objectSpread(_objectSpread({}, babelHelpers.classPrivateFieldGet(this, _types)), babelHelpers.classPrivateFieldGet(this, _custom)));
	          }
	        } catch (e) {}
	      }
	    }
	  }, {
	    key: "__getStyles",
	    value: function __getStyles() {
	      var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'all';
	      var styles = {
	        'desktop': ["%cDESKTOP", "color: white; font-style: italic; background-color: #29619b; padding: 0 6\px"],
	        'log': ["%cLOG", "color: #2a323b; font-style: italic; background-color: #ccc; padding: 0 6\px"],
	        'info': ["%cINFO", "color: #fff; font-style: italic; background-color: #6b7f96; padding: 0 6\px"],
	        'warn': ["%cWARNING", "color: white; font-style: italic; padding: 0 6\px; border: 1px solid #f0a74f"],
	        'error': ["%cERROR", "color: white; font-style: italic; padding: 0 6\px; border: 1px solid #8a3232"]
	      };

	      if (type === 'all') {
	        return styles;
	      }

	      if (styles[type]) {
	        return styles[type];
	      }

	      return [];
	    }
	  }, {
	    key: "__getRemoveString",
	    value: function __getRemoveString() {
	      var styles = this.__getStyles();

	      var result = [];

	      for (var type in styles) {
	        if (styles.hasOwnProperty(type)) {
	          result.push(styles[type][1]);
	        }
	      }

	      return result;
	    }
	  }]);
	  return Logger;
	}();

	var logger = new Logger();

	exports.Logger = logger;

}((this.BX.Messenger.Lib = this.BX.Messenger.Lib || {})));
 




// file: /bitrix/js/im/const/dist/registry.bundle.js
this.BX = this.BX || {};
this.BX.Messenger = this.BX.Messenger || {};
(function (exports) {
	'use strict';

	/**
	 * Bitrix Messenger
	 * Date constants
	 *
	 * @package bitrix
	 * @subpackage im
	 * @copyright 2001-2020 Bitrix
	 */
	var DateFormat = Object.freeze({
	  groupTitle: 'groupTitle',
	  message: 'message',
	  recentTitle: 'recentTitle',
	  recentLinesTitle: 'recentLinesTitle',
	  readedTitle: 'readedTitle',
	  "default": 'default',
	  vacationTitle: 'vacationTitle'
	});

	/**
	 * Bitrix Messenger
	 * Device constants
	 *
	 * @package bitrix
	 * @subpackage im
	 * @copyright 2001-2020 Bitrix
	 */
	var DeviceType = Object.freeze({
	  mobile: 'mobile',
	  desktop: 'desktop'
	});
	var DeviceOrientation = Object.freeze({
	  horizontal: 'horizontal',
	  portrait: 'portrait'
	});

	/**
	 * Bitrix Messenger
	 * Common constants
	 *
	 * @package bitrix
	 * @subpackage im
	 * @copyright 2001-2020 Bitrix
	 */
	var MutationType = Object.freeze({
	  none: 'none',
	  add: 'delete',
	  update: 'update',
	  "delete": 'delete',
	  set: 'set',
	  setAfter: 'after',
	  setBefore: 'before'
	});
	var StorageLimit = Object.freeze({
	  dialogues: 50,
	  messages: 100
	});

	/**
	 * Bitrix Messenger
	 * Device constants
	 *
	 * @package bitrix
	 * @subpackage im
	 * @copyright 2001-2020 Bitrix
	 */
	var RestMethod = Object.freeze({
	  imMessageAdd: 'im.message.add',
	  imMessageUpdate: 'im.message.update',
	  imMessageDelete: 'im.message.delete',
	  imMessageLike: 'im.message.like',
	  imMessageCommand: 'im.message.command',
	  imMessageShare: 'im.message.share',
	  imChatGet: 'im.chat.get',
	  imChatLeave: 'im.chat.leave',
	  imChatMute: 'im.chat.mute',
	  imChatParentJoin: 'im.chat.parent.join',
	  imDialogGet: 'im.dialog.get',
	  imDialogMessagesGet: 'im.dialog.messages.get',
	  imDialogRead: 'im.dialog.read',
	  imDialogUnread: 'im.dialog.unread',
	  imDialogWriting: 'im.dialog.writing',
	  imUserGet: 'im.user.get',
	  imUserListGet: 'im.user.list.get',
	  imDiskFolderGet: 'im.disk.folder.get',
	  imDiskFileUpload: 'disk.folder.uploadfile',
	  imDiskFileCommit: 'im.disk.file.commit',
	  mobileBrowserConstGet: 'mobile.browser.const.get',
	  imRecentGet: 'im.recent.get',
	  imRecentList: 'im.recent.list',
	  imCallGetCallLimits: 'im.call.getCallLimits',
	  imNotifyGet: 'im.notify.get',
	  imNotifySchemaGet: 'im.notify.schema.get'
	});
	var RestMethodHandler = Object.freeze({
	  imChatGet: 'im.chat.get',
	  imMessageAdd: 'im.message.add',
	  imDialogRead: 'im.dialog.read',
	  imDialogMessagesGet: 'im.dialog.messages.get',
	  imDialogMessagesGetInit: 'im.dialog.messages.get.init',
	  imDialogMessagesGetUnread: 'im.dialog.messages.get.unread',
	  imDiskFolderGet: 'im.disk.folder.get',
	  imDiskFileUpload: 'disk.folder.uploadfile',
	  imDiskFileCommit: 'im.disk.file.commit',
	  imUserGet: 'im.user.get',
	  imUserListGet: 'im.user.list.get',
	  mobileBrowserConstGet: 'mobile.browser.const.get',
	  imRecentGet: 'im.recent.get',
	  imRecentList: 'im.recent.list',
	  imCallGetCallLimits: 'im.call.getCallLimits',
	  imNotifyGet: 'im.notify.get',
	  imNotifySchemaGet: 'im.notify.schema.get'
	});

	/**
	 * Bitrix Messenger
	 * Event names constants
	 *
	 * @package bitrix
	 * @subpackage im
	 * @copyright 2001-2020 Bitrix
	 */
	var EventType = Object.freeze({
	  dialog: {
	    newMessage: 'EventType.dialog.newMessage',
	    scrollOnStart: 'IM.Dialog:scrollOnStart',
	    scrollToBottom: 'IM.Dialog:scrollToBottom',
	    readVisibleMessages: 'IM.Dialog.readVisibleMessages',
	    requestUnread: 'IM.Dialog.requestUnread',
	    readMessage: 'IM.Dialog:readMessage',
	    quoteMessage: 'IM.Dialog:quoteMessage',
	    clickOnCommand: 'IM.Dialog:clickOnCommand',
	    clickOnMention: 'IM.Dialog:clickOnMention',
	    clickOnUserName: 'IM.Dialog:clickOnUserName',
	    clickOnMessageMenu: 'IM.Dialog:clickOnMessageMenu',
	    clickOnMessageRetry: 'IM.Dialog:clickOnMessageRetry',
	    clickOnUploadCancel: 'IM.Dialog:clickOnUploadCancel',
	    clickOnReadList: 'IM.Dialog:clickOnReadList',
	    setMessageReaction: 'IM.Dialog:setMessageReaction',
	    openMessageReactionList: 'IM.Dialog:openMessageReactionList',
	    clickOnKeyboardButton: 'IM.Dialog:clickOnKeyboardButton',
	    clickOnChatTeaser: 'IM.Dialog:clickOnChatTeaser',
	    clickOnDialog: 'IM.Dialog:clickOnDialog',
	    quotePanelClose: 'IM.Dialog:quotePanelClose',
	    beforeMobileKeyboard: 'IM.Dialog:beforeMobileKeyboard',
	    messagesSet: 'IM.Dialog:messagesSet'
	  },
	  textarea: {
	    focus: 'IM.Textarea:focus',
	    setFocus: 'IM.Textarea:setFocus',
	    blur: 'IM.Textarea:blur',
	    setBlur: 'IM.Textarea:setBlur',
	    keyUp: 'IM.Textarea:keyUp',
	    edit: 'IM.Textarea:edit',
	    insertText: 'IM.Textarea:insertText',
	    sendMessage: 'IM.Textarea:sendMessage',
	    fileSelected: 'IM.Textarea:fileSelected',
	    startWriting: 'IM.Textarea:startWriting',
	    appButtonClick: 'IM.Textarea:appButtonClick'
	  },
	  conference: {
	    setPasswordFocus: 'IM.Conference:setPasswordFocus',
	    hideSmiles: 'IM.Conference:hideSmiles',
	    requestPermissions: 'IM.Conference:requestPermissions',
	    waitForStart: 'IM.Conference:waitForStart',
	    userRenameFocus: 'IM.Conference:userRenameFocus',
	    userRenameBlur: 'IM.Conference:userRenameBlur'
	  },
	  notification: {
	    updateState: 'IM.Notifications:restoreConnection'
	  }
	});

	/**
	 * Bitrix Messenger
	 * Event names constants
	 *
	 * @package bitrix
	 * @subpackage im
	 * @copyright 2001-2020 Bitrix
	 */
	var DialogType = Object.freeze({
	  "private": 'private',
	  chat: 'chat',
	  open: 'open',
	  call: 'call',
	  crm: 'crm'
	});
	var DialogCrmType = Object.freeze({
	  lead: 'lead',
	  company: 'company',
	  contact: 'contact',
	  deal: 'deal',
	  none: 'none'
	});
	var DialogReferenceClassName = Object.freeze({
	  listBody: 'bx-im-dialog-list',
	  listItem: 'bx-im-dialog-list-item-reference',
	  listItemName: 'bx-im-dialog-list-item-name-reference',
	  listItemBody: 'bx-im-dialog-list-item-content-reference',
	  listUnreadLoader: 'bx-im-dialog-list-unread-loader-reference'
	});
	var DialogTemplateType = Object.freeze({
	  message: 'message',
	  delimiter: 'delimiter',
	  group: 'group',
	  historyLoader: 'historyLoader',
	  unreadLoader: 'unreadLoader',
	  button: 'button',
	  placeholder: 'placeholder'
	});
	var DialogState = Object.freeze({
	  loading: 'loading',
	  empty: 'empty',
	  show: 'show'
	});

	/**
	 * Bitrix Messenger
	 * File constants
	 *
	 * @package bitrix
	 * @subpackage im
	 * @copyright 2001-2020 Bitrix
	 */
	var FileStatus = Object.freeze({
	  upload: 'upload',
	  wait: 'wait',
	  done: 'done',
	  error: 'error'
	});
	var FileType = Object.freeze({
	  image: 'image',
	  video: 'video',
	  audio: 'audio',
	  file: 'file'
	});

	/**
	 * Bitrix Messenger
	 * Message constants
	 *
	 * @package bitrix
	 * @subpackage im
	 * @copyright 2001-2020 Bitrix
	 */
	var MessageType = Object.freeze({
	  self: 'self',
	  opponent: 'opponent',
	  system: 'system'
	});

	/**
	 * Bitrix Messenger
	 * Conference constants
	 *
	 * @package bitrix
	 * @subpackage im
	 * @copyright 2001-2020 Bitrix
	 */
	var ConferenceFieldState = Object.freeze({
	  view: 'view',
	  edit: 'edit',
	  create: 'create'
	});
	var ConferenceStateType = Object.freeze({
	  preparation: 'preparation',
	  call: 'call'
	});
	var ConferenceErrorCode = Object.freeze({
	  userLimitReached: 'userLimitReached',
	  detectIntranetUser: 'detectIntranetUser',
	  bitrix24only: 'bitrix24only',
	  kickedFromCall: 'kickedFromCall',
	  unsupportedBrowser: 'unsupportedBrowser',
	  missingMicrophone: 'missingMicrophone',
	  unsafeConnection: 'unsafeConnection',
	  wrongAlias: 'wrongAlias',
	  notStarted: 'notStarted',
	  finished: 'finished',
	  userLeftCall: 'userLeftCall',
	  noSignalFromCamera: 'noSignalFromCamera'
	});
	var ConferenceRightPanelMode = Object.freeze({
	  hidden: 'hidden',
	  chat: 'chat',
	  users: 'users',
	  split: 'split'
	}); //BX.Call.UserState sync

	var ConferenceUserState = Object.freeze({
	  Idle: 'Idle',
	  Busy: 'Busy',
	  Calling: 'Calling',
	  Unavailable: 'Unavailable',
	  Declined: 'Declined',
	  Ready: 'Ready',
	  Connecting: 'Connecting',
	  Connected: 'Connected',
	  Failed: 'Failed'
	});

	/**
	 * Bitrix Messenger
	 * Recent list constants
	 *
	 * @package bitrix
	 * @subpackage im
	 * @copyright 2001-2020 Bitrix
	 */
	var ChatTypes = {
	  chat: 'chat',
	  open: 'open',
	  user: 'user',
	  notification: 'notification'
	};
	var TemplateTypes = {
	  item: 'item',
	  placeholder: 'placeholder'
	};
	var RecentSection = {
	  general: 'general',
	  pinned: 'pinned'
	};
	var MessageStatus = {
	  received: 'received',
	  delivered: 'delivered',
	  error: 'error'
	};

	var NotificationTypesCodes = Object.freeze({
	  confirm: 1,
	  simple: 3,
	  placeholder: 5
	});

	exports.DateFormat = DateFormat;
	exports.DeviceType = DeviceType;
	exports.DeviceOrientation = DeviceOrientation;
	exports.MutationType = MutationType;
	exports.StorageLimit = StorageLimit;
	exports.RestMethod = RestMethod;
	exports.RestMethodHandler = RestMethodHandler;
	exports.EventType = EventType;
	exports.DialogType = DialogType;
	exports.DialogCrmType = DialogCrmType;
	exports.DialogReferenceClassName = DialogReferenceClassName;
	exports.DialogTemplateType = DialogTemplateType;
	exports.DialogState = DialogState;
	exports.FileStatus = FileStatus;
	exports.FileType = FileType;
	exports.MessageType = MessageType;
	exports.ConferenceFieldState = ConferenceFieldState;
	exports.ConferenceStateType = ConferenceStateType;
	exports.ConferenceErrorCode = ConferenceErrorCode;
	exports.ConferenceRightPanelMode = ConferenceRightPanelMode;
	exports.ConferenceUserState = ConferenceUserState;
	exports.ChatTypes = ChatTypes;
	exports.TemplateTypes = TemplateTypes;
	exports.RecentSection = RecentSection;
	exports.MessageStatus = MessageStatus;
	exports.NotificationTypesCodes = NotificationTypesCodes;

}((this.BX.Messenger.Const = this.BX.Messenger.Const || {})));
 




// file: /bitrix/js/main/date/main.date.js
;(function(window)
{
	/****************** ATTENTION *******************************
	 * Please do not use Bitrix CoreJS in this class.
	 * This class can be called on page without Bitrix Framework
	*************************************************************/

	if (!window.BX)
	{
		window.BX = {};
	}

	if (!window.BX.Main)
	{
		window.BX.Main = {};
	}
	else if (window.BX.Main.Date)
	{
		return;
	}

	var BX = window.BX;

	BX.Main.Date = {

		AM_PM_MODE: {
			UPPER: 1,
			LOWER: 2,
			NONE: false
		},

		format: function(format, timestamp, now, utc)
		{
			var _this = this;

			/*
			PHP to Javascript:
				time() = new Date()
				mktime(...) = new Date(...)
				gmmktime(...) = new Date(Date.UTC(...))
				mktime(0,0,0, 1, 1, 1970) != 0          new Date(1970,0,1).getTime() != 0
				gmmktime(0,0,0, 1, 1, 1970) == 0        new Date(Date.UTC(1970,0,1)).getTime() == 0
				date("d.m.Y H:i:s") = BX.Main.Date.format("d.m.Y H:i:s")
				gmdate("d.m.Y H:i:s") = BX.Main.Date.format("d.m.Y H:i:s", null, null, true);
			*/
			var date = Utils.isDate(timestamp) ? new Date(timestamp.getTime()) : Utils.isNumber(timestamp) ? new Date(timestamp * 1000) : new Date();
			var nowDate = Utils.isDate(now) ? new Date(now.getTime()) : Utils.isNumber(now) ? new Date(now * 1000) : new Date();
			var isUTC = !!utc;

			if (Utils.isArray(format))
				return _formatDateInterval(format, date, nowDate, isUTC);
			else if (!Utils.isNotEmptyString(format))
				return "";

			var replaceMap = (format.match(/{{([^{}]*)}}/g) || []).map(function(x) { return (x.match(/[^{}]+/) || [''])[0]; });
			if (replaceMap.length > 0)
			{
				replaceMap.forEach(function(element, index) {
					format = format.replace("{{"+element+"}}", "{{"+index+"}}");
				});
			}

			var formatRegex = /\\?(sago|iago|isago|Hago|dago|mago|Yago|sdiff|idiff|Hdiff|ddiff|mdiff|Ydiff|sshort|ishort|Hshort|dshort|mhort|Yshort|yesterday|today|tommorow|tomorrow|[a-z])/gi;

			var dateFormats = {
				d : function() {
					// Day of the month 01 to 31
					return Utils.strPadLeft(getDate(date).toString(), 2, "0");
				},

				D : function() {
					//Mon through Sun
					return _this._getMessage("DOW_" + getDay(date));
				},

				j : function() {
					//Day of the month 1 to 31
					return getDate(date);
				},

				l : function() {
					//Sunday through Saturday
					return _this._getMessage("DAY_OF_WEEK_" + getDay(date));
				},

				N : function() {
					//1 (for Monday) through 7 (for Sunday)
					return getDay(date) || 7;
				},

				S : function() {
					//st, nd, rd or th. Works well with j
					if (getDate(date) % 10 == 1 && getDate(date) != 11)
						return "st";
					else if (getDate(date) % 10 == 2 && getDate(date) != 12)
						return "nd";
					else if (getDate(date) % 10 == 3 && getDate(date) != 13)
						return "rd";
					else
						return "th";
				},

				w : function() {
					//0 (for Sunday) through 6 (for Saturday)
					return getDay(date);
				},

				z : function() {
					//0 through 365
					var firstDay = new Date(getFullYear(date), 0, 1);
					var currentDay = new Date(getFullYear(date), getMonth(date), getDate(date));
					return Math.ceil( (currentDay - firstDay) / (24 * 3600 * 1000) );
				},

				W : function() {
					//ISO-8601 week number of year
					var newDate  = new Date(date.getTime());
					var dayNumber   = (getDay(date) + 6) % 7;
					setDate(newDate, getDate(newDate) - dayNumber + 3);
					var firstThursday = newDate.getTime();
					setMonth(newDate, 0, 1);
					if (getDay(newDate) != 4)
						setMonth(newDate, 0, 1 + ((4 - getDay(newDate)) + 7) % 7);
					var weekNumber = 1 + Math.ceil((firstThursday - newDate) / (7 * 24 * 3600 * 1000));
					return Utils.strPadLeft(weekNumber.toString(), 2, "0");
				},

				F : function() {
					//January through December
					return _this._getMessage("MONTH_" + (getMonth(date) + 1) + "_S");
				},

				f : function() {
					//January through December
					return _this._getMessage("MONTH_" + (getMonth(date) + 1));
				},

				m : function() {
					//Numeric representation of a month 01 through 12
					return Utils.strPadLeft((getMonth(date) + 1).toString(), 2, "0");
				},

				M : function() {
					//A short textual representation of a month, three letters Jan through Dec
					return _this._getMessage("MON_" + (getMonth(date) + 1));
				},

				n : function() {
					//Numeric representation of a month 1 through 12
					return getMonth(date) + 1;
				},

				t : function() {
					//Number of days in the given month 28 through 31
					var lastMonthDay = isUTC ? new Date(Date.UTC(getFullYear(date), getMonth(date) + 1, 0)) : new Date(getFullYear(date), getMonth(date) + 1, 0);
					return getDate(lastMonthDay);
				},

				L : function() {
					//1 if it is a leap year, 0 otherwise.
					var year = getFullYear(date);
					return (year % 4 == 0 && year % 100 != 0 || year % 400 == 0 ? 1 : 0);
				},

				o : function() {
					//ISO-8601 year number
					var correctDate  = new Date(date.getTime());
					setDate(correctDate, getDate(correctDate) - ((getDay(date) + 6) % 7) + 3);
					return getFullYear(correctDate);
				},

				Y : function() {
					//A full numeric representation of a year, 4 digits
					return getFullYear(date);
				},

				y : function() {
					//A two digit representation of a year
					return getFullYear(date).toString().slice(2);
				},

				a : function() {
					//am or pm
					return getHours(date) > 11 ? "pm" : "am";
				},

				A : function() {
					//AM or PM
					return getHours(date) > 11 ? "PM" : "AM";
				},

				B : function() {
					//000 through 999
					var swatch = ((date.getUTCHours() + 1) % 24) + date.getUTCMinutes() / 60 + date.getUTCSeconds() / 3600;
					return Utils.strPadLeft(Math.floor(swatch * 1000 / 24).toString(), 3, "0");
				},

				g : function() {
					//12-hour format of an hour without leading zeros 1 through 12
					return getHours(date) % 12 || 12;
				},

				G : function() {
					//24-hour format of an hour without leading zeros 0 through 23
					return getHours(date);
				},

				h : function() {
					//12-hour format of an hour with leading zeros 01 through 12
					return Utils.strPadLeft((getHours(date) % 12 || 12).toString(), 2, "0");
				},

				H : function() {
					//24-hour format of an hour with leading zeros 00 through 23
					return Utils.strPadLeft(getHours(date).toString(), 2, "0");
				},

				i : function() {
					//Minutes with leading zeros 00 to 59
					return Utils.strPadLeft(getMinutes(date).toString(), 2, "0");
				},

				s : function() {
					//Seconds, with leading zeros 00 through 59
					return Utils.strPadLeft(getSeconds(date).toString(), 2, "0");
				},

				u : function() {
					//Microseconds
					return Utils.strPadLeft((getMilliseconds(date) * 1000).toString(), 6, "0");
				},

				e : function() {
					if (isUTC)
						return "UTC";
					return "";
				},

				I : function() {
					if (isUTC)
						return 0;

					//Whether or not the date is in daylight saving time 1 if Daylight Saving Time, 0 otherwise
					var firstJanuary = new Date(getFullYear(date), 0, 1);
					var firstJanuaryUTC = Date.UTC(getFullYear(date), 0, 1);
					var firstJuly = new Date(getFullYear(date), 6, 0);
					var firstJulyUTC = Date.UTC(getFullYear(date), 6, 0);
					return 0 + ((firstJanuary - firstJanuaryUTC) !== (firstJuly - firstJulyUTC));
				},

				O : function() {
					if (isUTC)
						return "+0000";

					//Difference to Greenwich time (GMT) in hours +0200
					var timezoneOffset = date.getTimezoneOffset();
					var timezoneOffsetAbs = Math.abs(timezoneOffset);
					return (timezoneOffset > 0 ? "-" : "+") + Utils.strPadLeft((Math.floor(timezoneOffsetAbs / 60) * 100 + timezoneOffsetAbs % 60).toString(), 4, "0");
				},

				P : function() {
					if (isUTC)
						return "+00:00";

					//Difference to Greenwich time (GMT) with colon between hours and minutes +02:00
					var difference = this.O();
					return difference.substr(0, 3) + ":" + difference.substr(3);
				},

				Z : function() {
					if (isUTC)
						return 0;
					//Timezone offset in seconds. The offset for timezones west of UTC is always negative,
					//and for those east of UTC is always positive.
					return -date.getTimezoneOffset() * 60;
				},

				c : function() {
					//ISO 8601 date
					return "Y-m-d\\TH:i:sP".replace(formatRegex, _replaceDateFormat);
				},

				r : function() {
					//RFC 2822 formatted date
					return "D, d M Y H:i:s O".replace(formatRegex, _replaceDateFormat);
				},

				U : function() {
					//Seconds since the Unix Epoch
					return Math.floor(date.getTime() / 1000);
				},

				sago : function() {
					return _formatDateMessage(intval((nowDate - date) / 1000), {
						"0" : "FD_SECOND_AGO_0",
						"1" : "FD_SECOND_AGO_1",
						"10_20" : "FD_SECOND_AGO_10_20",
						"MOD_1" : "FD_SECOND_AGO_MOD_1",
						"MOD_2_4" : "FD_SECOND_AGO_MOD_2_4",
						"MOD_OTHER" : "FD_SECOND_AGO_MOD_OTHER"
					});
				},

				sdiff : function() {
					return _formatDateMessage(intval((nowDate - date) / 1000), {
						"0" : "FD_SECOND_DIFF_0",
						"1" : "FD_SECOND_DIFF_1",
						"10_20" : "FD_SECOND_DIFF_10_20",
						"MOD_1" : "FD_SECOND_DIFF_MOD_1",
						"MOD_2_4" : "FD_SECOND_DIFF_MOD_2_4",
						"MOD_OTHER" : "FD_SECOND_DIFF_MOD_OTHER"
					});
				},

				sshort : function() {
					return _this._getMessage("FD_SECOND_SHORT").replace(/#VALUE#/g, intval((nowDate - date) / 1000));
				},

				iago : function() {
					return _formatDateMessage(intval((nowDate - date) / 60 / 1000), {
						"0" : "FD_MINUTE_AGO_0",
						"1" : "FD_MINUTE_AGO_1",
						"10_20" : "FD_MINUTE_AGO_10_20",
						"MOD_1" : "FD_MINUTE_AGO_MOD_1",
						"MOD_2_4" : "FD_MINUTE_AGO_MOD_2_4",
						"MOD_OTHER" : "FD_MINUTE_AGO_MOD_OTHER"
					});
				},

				idiff : function() {
					return _formatDateMessage(intval((nowDate - date) / 60 / 1000), {
						"0" : "FD_MINUTE_DIFF_0",
						"1" : "FD_MINUTE_DIFF_1",
						"10_20" : "FD_MINUTE_DIFF_10_20",
						"MOD_1" : "FD_MINUTE_DIFF_MOD_1",
						"MOD_2_4" : "FD_MINUTE_DIFF_MOD_2_4",
						"MOD_OTHER" : "FD_MINUTE_DIFF_MOD_OTHER"
					});
				},

				isago : function() {
					var minutesAgo = intval((nowDate - date) / 60 / 1000);
					var result = _formatDateMessage(minutesAgo, {
						"0" : "FD_MINUTE_0",
						"1" : "FD_MINUTE_1",
						"10_20" : "FD_MINUTE_10_20",
						"MOD_1" : "FD_MINUTE_MOD_1",
						"MOD_2_4" : "FD_MINUTE_MOD_2_4",
						"MOD_OTHER" : "FD_MINUTE_MOD_OTHER"
					});

					result += " ";

					var secondsAgo = intval((nowDate - date) / 1000) - (minutesAgo * 60);
					result += _formatDateMessage(secondsAgo, {
						"0" : "FD_SECOND_AGO_0",
						"1" : "FD_SECOND_AGO_1",
						"10_20" : "FD_SECOND_AGO_10_20",
						"MOD_1" : "FD_SECOND_AGO_MOD_1",
						"MOD_2_4" : "FD_SECOND_AGO_MOD_2_4",
						"MOD_OTHER" : "FD_SECOND_AGO_MOD_OTHER"
					});
					return result;
				},

				ishort : function() {
					return _this._getMessage("FD_MINUTE_SHORT").replace(/#VALUE#/g, intval((nowDate - date) / 60 / 1000));
				},

				Hago : function() {
					return _formatDateMessage(intval((nowDate - date) / 60 / 60 / 1000), {
						"0" : "FD_HOUR_AGO_0",
						"1" : "FD_HOUR_AGO_1",
						"10_20" : "FD_HOUR_AGO_10_20",
						"MOD_1" : "FD_HOUR_AGO_MOD_1",
						"MOD_2_4" : "FD_HOUR_AGO_MOD_2_4",
						"MOD_OTHER" : "FD_HOUR_AGO_MOD_OTHER"
					});
				},

				Hdiff : function() {
					return _formatDateMessage(intval((nowDate - date) / 60 / 60 / 1000), {
						"0" : "FD_HOUR_DIFF_0",
						"1" : "FD_HOUR_DIFF_1",
						"10_20" : "FD_HOUR_DIFF_10_20",
						"MOD_1" : "FD_HOUR_DIFF_MOD_1",
						"MOD_2_4" : "FD_HOUR_DIFF_MOD_2_4",
						"MOD_OTHER" : "FD_HOUR_DIFF_MOD_OTHER"
					});
				},

				Hshort : function() {
					return _this._getMessage("FD_HOUR_SHORT").replace(/#VALUE#/g, intval((nowDate - date) / 60 / 60 / 1000));
				},

				yesterday : function() {
					return _this._getMessage("FD_YESTERDAY");
				},

				today : function() {
					return _this._getMessage("FD_TODAY");
				},

				tommorow : function() {
					return _this._getMessage("FD_TOMORROW");
				},

				tomorrow : function() {
					return _this._getMessage("FD_TOMORROW");
				},

				dago : function() {
					return _formatDateMessage(intval((nowDate - date) / 60 / 60 / 24 / 1000), {
						"0" : "FD_DAY_AGO_0",
						"1" : "FD_DAY_AGO_1",
						"10_20" : "FD_DAY_AGO_10_20",
						"MOD_1" : "FD_DAY_AGO_MOD_1",
						"MOD_2_4" : "FD_DAY_AGO_MOD_2_4",
						"MOD_OTHER" : "FD_DAY_AGO_MOD_OTHER"
					});
				},

				ddiff : function() {
					return _formatDateMessage(intval((nowDate - date) / 60 / 60 / 24 / 1000), {
						"0" : "FD_DAY_DIFF_0",
						"1" : "FD_DAY_DIFF_1",
						"10_20" : "FD_DAY_DIFF_10_20",
						"MOD_1" : "FD_DAY_DIFF_MOD_1",
						"MOD_2_4" : "FD_DAY_DIFF_MOD_2_4",
						"MOD_OTHER" : "FD_DAY_DIFF_MOD_OTHER"
					});
				},

				dshort : function() {
					return _this._getMessage("FD_DAY_SHORT").replace(/#VALUE#/g, intval((nowDate - date) / 60 / 60 / 24 / 1000));
				},

				mago : function() {
					return _formatDateMessage(intval((nowDate - date) / 60 / 60 / 24 / 31 / 1000), {
						"0" : "FD_MONTH_AGO_0",
						"1" : "FD_MONTH_AGO_1",
						"10_20" : "FD_MONTH_AGO_10_20",
						"MOD_1" : "FD_MONTH_AGO_MOD_1",
						"MOD_2_4" : "FD_MONTH_AGO_MOD_2_4",
						"MOD_OTHER" : "FD_MONTH_AGO_MOD_OTHER"
					});
				},

				mdiff : function() {
					return _formatDateMessage(intval((nowDate - date) / 60 / 60 / 24 / 31 / 1000), {
						"0" : "FD_MONTH_DIFF_0",
						"1" : "FD_MONTH_DIFF_1",
						"10_20" : "FD_MONTH_DIFF_10_20",
						"MOD_1" : "FD_MONTH_DIFF_MOD_1",
						"MOD_2_4" : "FD_MONTH_DIFF_MOD_2_4",
						"MOD_OTHER" : "FD_MONTH_DIFF_MOD_OTHER"
					});
				},

				mshort : function() {
					return _this._getMessage("FD_MONTH_SHORT").replace(/#VALUE#/g, intval((nowDate - date) / 60 / 60 / 24 / 31 / 1000));
				},

				Yago : function() {
					return _formatDateMessage(intval((nowDate - date) / 60 / 60 / 24 / 365 / 1000), {
						"0" : "FD_YEARS_AGO_0",
						"1" : "FD_YEARS_AGO_1",
						"10_20" : "FD_YEARS_AGO_10_20",
						"MOD_1" : "FD_YEARS_AGO_MOD_1",
						"MOD_2_4" : "FD_YEARS_AGO_MOD_2_4",
						"MOD_OTHER" : "FD_YEARS_AGO_MOD_OTHER"
					});
				},

				Ydiff : function() {
					return _formatDateMessage(intval((nowDate - date) / 60 / 60 / 24 / 365 / 1000), {
						"0" : "FD_YEARS_DIFF_0",
						"1" : "FD_YEARS_DIFF_1",
						"10_20" : "FD_YEARS_DIFF_10_20",
						"MOD_1" : "FD_YEARS_DIFF_MOD_1",
						"MOD_2_4" : "FD_YEARS_DIFF_MOD_2_4",
						"MOD_OTHER" : "FD_YEARS_DIFF_MOD_OTHER"
					});
				},

				Yshort : function() {
					return _formatDateMessage(intval((nowDate - date) / 60 / 60 / 24 / 365 / 1000), {
						"0" : "FD_YEARS_SHORT_0",
						"1" : "FD_YEARS_SHORT_1",
						"10_20" : "FD_YEARS_SHORT_10_20",
						"MOD_1" : "FD_YEARS_SHORT_MOD_1",
						"MOD_2_4" : "FD_YEARS_SHORT_MOD_2_4",
						"MOD_OTHER" : "FD_YEARS_SHORT_MOD_OTHER"
					});
				},

				x : function() {
					var ampm = _this.isAmPmMode(true);
					var timeFormat = (ampm === _this.AM_PM_MODE.LOWER? "g:i a" : (ampm === _this.AM_PM_MODE.UPPER? "g:i A" : "H:i"));

					return _this.format([
						["tomorrow", "tomorrow, "+timeFormat],
						["-", _this.convertBitrixFormat(_this._getMessage("FORMAT_DATETIME")).replace(/:s/g, "")],
						["s", "sago"],
						["i", "iago"],
						["today", "today, "+timeFormat],
						["yesterday", "yesterday, "+timeFormat],
						["", _this.convertBitrixFormat(_this._getMessage("FORMAT_DATETIME")).replace(/:s/g, "")]
					], date, nowDate, isUTC);
				},

				X : function() {

					var ampm = _this.isAmPmMode(true);
					var timeFormat = (ampm === _this.AM_PM_MODE.LOWER? "g:i a" : (ampm === _this.AM_PM_MODE.UPPER? "g:i A" : "H:i"));

					var day = _this.format([
						["tomorrow", "tomorrow"],
						["-", _this.convertBitrixFormat(_this._getMessage("FORMAT_DATE"))],
						["today", "today"],
						["yesterday", "yesterday"],
						["", _this.convertBitrixFormat(_this._getMessage("FORMAT_DATE"))]
					], date, nowDate, isUTC);

					var time = _this.format([
						["tomorrow", timeFormat],
						["today", timeFormat],
						["yesterday", timeFormat],
						["", ""]
					], date, nowDate, isUTC);

					if (time.length > 0)
						return _this._getMessage("FD_DAY_AT_TIME").replace(/#DAY#/g, day).replace(/#TIME#/g, time);
					else
						return day;
				},

				Q : function() {
					var daysAgo = intval((nowDate - date) / 60 / 60 / 24 / 1000);
					if(daysAgo == 0)
						return _this._getMessage("FD_DAY_DIFF_1").replace(/#VALUE#/g, 1);
					else
						return _this.format([ ["d", "ddiff"], ["m", "mdiff"], ["", "Ydiff"] ], date, nowDate);
				}
			};

			var cutZeroTime = false;
			if (format[0] && format[0] == "^")
			{
				cutZeroTime = true;
				format = format.substr(1);
			}

			var result = format.replace(formatRegex, _replaceDateFormat);

			if (cutZeroTime)
			{
				/* 	15.04.12 13:00:00 => 15.04.12 13:00
					00:01:00 => 00:01
					4 may 00:00:00 => 4 may
					01-01-12 00:00 => 01-01-12
				*/

				result = result.replace(/\s*00:00:00\s*/g, "").
								replace(/(\d\d:\d\d)(:00)/g, "$1").
								replace(/(\s*00:00\s*)(?!:)/g, "");
			}

			if (replaceMap.length > 0)
			{
				replaceMap.forEach(function(element, index) {
					result = result.replace("{{"+index+"}}", element);
				});
			}

			return result;

			function _formatDateInterval(formats, date, nowDate, isUTC)
			{
				var secondsAgo = intval((nowDate - date) / 1000);
				for (var i = 0; i < formats.length; i++)
				{
					var formatInterval = formats[i][0];
					var formatValue = formats[i][1];
					var match = null;
					if (formatInterval == "s")
					{
						if (secondsAgo < 60)
							return _this.format(formatValue, date, nowDate, isUTC);
					}
					else if ((match = /^s(\d+)\>?(\d+)?/.exec(formatInterval)) != null)
					{
						if (match[1] && match[2])
						{
							if (
								secondsAgo < match[1]
								&& secondsAgo > match[2]
							)
							{
								return _this.format(formatValue, date, nowDate, isUTC);
							}
						}
						else if (secondsAgo < match[1])
						{
							return _this.format(formatValue, date, nowDate, isUTC);
						}
					}
					else if (formatInterval == "i")
					{
						if (secondsAgo < 60 * 60)
							return _this.format(formatValue, date, nowDate, isUTC);
					}
					else if ((match = /^i(\d+)\>?(\d+)?/.exec(formatInterval)) != null)
					{
						if (match[1] && match[2])
						{
							if (
								secondsAgo < match[1] * 60
								&& secondsAgo > match[2] * 60
							)
							{
								return _this.format(formatValue, date, nowDate, isUTC);
							}
						}
						else if (secondsAgo < match[1] * 60)
						{
							return _this.format(formatValue, date, nowDate, isUTC);
						}
					}
					else if (formatInterval == "H")
					{
						if (secondsAgo < 24 * 60 * 60)
							return _this.format(formatValue, date, nowDate, isUTC);
					}
					else if ((match = /^H(\d+)\>?(\d+)?/.exec(formatInterval)) != null)
					{
						if (match[1] && match[2])
						{
							if (
								secondsAgo < match[1] * 60 * 60
								&& secondsAgo > match[2] * 60 * 60
							)
							{
								return _this.format(formatValue, date, nowDate, isUTC);
							}
						}
						else if (secondsAgo < match[1] * 60 * 60)
						{
							return _this.format(formatValue, date, nowDate, isUTC);
						}
					}
					else if (formatInterval == "d")
					{
						if (secondsAgo < 31 *24 * 60 * 60)
							return _this.format(formatValue, date, nowDate, isUTC);
					}
					else if ((match = /^d(\d+)\>?(\d+)?/.exec(formatInterval)) != null)
					{
						if (match[1] && match[2])
						{
							if (
								secondsAgo < match[1] * 24 * 60 * 60
								&& secondsAgo > match[2] * 24 * 60 * 60
							)
							{
								return _this.format(formatValue, date, nowDate, isUTC);
							}
						}
						else if (secondsAgo < match[1] * 24 * 60 * 60)
						{
							return _this.format(formatValue, date, nowDate, isUTC);
						}
					}
					else if (formatInterval == "m")
					{
						if (secondsAgo < 365 * 24 * 60 * 60)
							return _this.format(formatValue, date, nowDate, isUTC);
					}
					else if ((match = /^m(\d+)\>?(\d+)?/.exec(formatInterval)) != null)
					{
						if (match[1] && match[2])
						{
							if (
								secondsAgo < match[1] * 31 * 24 * 60 * 60
								&& secondsAgo > match[2] * 31 * 24 * 60 * 60
							)
							{
								return _this.format(formatValue, date, nowDate, isUTC);
							}
						}
						else if (secondsAgo < match[1] * 31 * 24 * 60 * 60)
						{
							return _this.format(formatValue, date, nowDate, isUTC);
						}
					}
					else if (formatInterval == "now")
					{
						if (date.getTime() == nowDate.getTime())
						{
							return _this.format(formatValue, date, nowDate, isUTC);
						}
					}
					else if (formatInterval == "today")
					{
						var year = getFullYear(nowDate), month = getMonth(nowDate), day = getDate(nowDate);
						var todayStart = isUTC ? new Date(Date.UTC(year, month, day, 0, 0, 0, 0)) : new Date(year, month, day, 0, 0, 0, 0);
						var todayEnd = isUTC ? new Date(Date.UTC(year, month, day+1, 0, 0, 0, 0)) : new Date(year, month, day+1, 0, 0, 0, 0);
						if (date >= todayStart && date < todayEnd)
							return _this.format(formatValue, date, nowDate, isUTC);
					}
					else if (formatInterval == "todayFuture")
					{
						var year = getFullYear(nowDate), month = getMonth(nowDate), day = getDate(nowDate);
						var todayStart = nowDate.getTime();
						var todayEnd = isUTC ? new Date(Date.UTC(year, month, day+1, 0, 0, 0, 0)) : new Date(year, month, day+1, 0, 0, 0, 0);
						if (date >= todayStart && date < todayEnd)
							return _this.format(formatValue, date, nowDate, isUTC);
					}
					else if (formatInterval == "yesterday")
					{
						year = getFullYear(nowDate); month = getMonth(nowDate); day = getDate(nowDate);
						var yesterdayStart = isUTC ? new Date(Date.UTC(year, month, day-1, 0, 0, 0, 0)) : new Date(year, month, day-1, 0, 0, 0, 0);
						var yesterdayEnd = isUTC ? new Date(Date.UTC(year, month, day, 0, 0, 0, 0)) : new Date(year, month, day, 0, 0, 0, 0);
						if (date >= yesterdayStart && date < yesterdayEnd)
							return _this.format(formatValue, date, nowDate, isUTC);
					}
					else if (formatInterval == "tommorow" || formatInterval == "tomorrow")
					{
						year = getFullYear(nowDate); month = getMonth(nowDate); day = getDate(nowDate);
						var tomorrowStart = isUTC ? new Date(Date.UTC(year, month, day+1, 0, 0, 0, 0)) : new Date(year, month, day+1, 0, 0, 0, 0);
						var tomorrowEnd = isUTC ? new Date(Date.UTC(year, month, day+2, 0, 0, 0, 0)) : new Date(year, month, day+2, 0, 0, 0, 0);
						if (date >= tomorrowStart && date < tomorrowEnd)
							return _this.format(formatValue, date, nowDate, isUTC);
					}
					else if (formatInterval == "-")
					{
						if (secondsAgo < 0)
							return _this.format(formatValue, date, nowDate, isUTC);
					}
				}

				//return formats.length > 0 ? _this.format(formats.pop()[1], date, nowDate, isUTC) : "";
				return formats.length > 0 ? _this.format(formats[formats.length - 1][1], date, nowDate, isUTC) : "";
			}

			function getFullYear(date) { return isUTC ? date.getUTCFullYear() : date.getFullYear(); }
			function getDate(date) { return isUTC ? date.getUTCDate() : date.getDate(); }
			function getMonth(date) { return isUTC ? date.getUTCMonth() : date.getMonth(); }
			function getHours(date) { return isUTC ? date.getUTCHours() : date.getHours(); }
			function getMinutes(date) { return isUTC ? date.getUTCMinutes() : date.getMinutes(); }
			function getSeconds(date) { return isUTC ? date.getUTCSeconds() : date.getSeconds(); }
			function getMilliseconds(date) { return isUTC ? date.getUTCMilliseconds() : date.getMilliseconds(); }
			function getDay(date) { return isUTC ? date.getUTCDay() : date.getDay(); }
			function setDate(date, dayValue) { return isUTC ? date.setUTCDate(dayValue) : date.setDate(dayValue); }
			function setMonth(date, monthValue, dayValue) { return isUTC ? date.setUTCMonth(monthValue, dayValue) : date.setMonth(monthValue, dayValue); }

			function _formatDateMessage(value, messages)
			{
				var val = value < 100 ? Math.abs(value) : Math.abs(value % 100);
				var dec = val % 10;
				var message = "";

				if(val == 0)
					message = _this._getMessage(messages["0"]);
				else if (val == 1)
					message = _this._getMessage(messages["1"]);
				else if (val >= 10 && val <= 20)
					message = _this._getMessage(messages["10_20"]);
				else if (dec == 1)
					message = _this._getMessage(messages["MOD_1"]);
				else if (2 <= dec && dec <= 4)
					message = _this._getMessage(messages["MOD_2_4"]);
				else
					message = _this._getMessage(messages["MOD_OTHER"]);

				return message.replace(/#VALUE#/g, value);
			}

			function _replaceDateFormat(match, matchFull)
			{
				if (dateFormats[match])
					return dateFormats[match]();
				else
					return matchFull;
			}

			function intval(number)
			{
				return number >= 0 ? Math.floor(number) : Math.ceil(number);
			}
		},

		convertBitrixFormat: function(format)
		{
			if (!Utils.isNotEmptyString(format))
				return "";

			return format.replace("YYYY", "Y")	// 1999
						 .replace("MMMM", "F")	// January - December
						 .replace("MM", "m")	// 01 - 12
						 .replace("M", "M")	// Jan - Dec
						 .replace("DD", "d")	// 01 - 31
						 .replace("G", "g")	//  1 - 12
						 .replace(/GG/i, "G")	//  0 - 23
						 .replace("H", "h")	// 01 - 12
						 .replace(/HH/i, "H")	// 00 - 24
						 .replace("MI", "i")	// 00 - 59
						 .replace("SS", "s")	// 00 - 59
						 .replace("TT", "A")	// AM - PM
						 .replace("T", "a");	// am - pm
		},

		convertToUTC: function(date)
		{
			if (!Utils.isDate(date))
				return null;

			return new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()));
		},

		/**
		 * Function creates and returns Javascript Date() object from server timestamp regardless of local browser (system) timezone.
		 * For example can be used to convert timestamp from some exact date on server to the JS Date object with the same value.
		 *
		 * @param timestamp - timestamp in seconds
		 * @returns {Date}
		 */
		getNewDate: function(timestamp)
		{
			return new Date(this.getBrowserTimestamp(timestamp));
		},

		/**
		 * Function transforms server timestamp (in sec) to javascript timestamp (calculated depend on local browser timezone offset). Returns timestamp in milliseconds.
		 * Also see BX.Main.Date.getNewDate description.
		 *
		 * @param timestamp - timestamp in seconds
		 * @returns {number}
		 */
		getBrowserTimestamp: function(timestamp)
		{
			timestamp = parseInt(timestamp, 10);
			var browserOffset = new Date(timestamp * 1000).getTimezoneOffset() * 60;
			return (parseInt(timestamp, 10) + parseInt(this._getMessage('SERVER_TZ_OFFSET')) + browserOffset) * 1000;
		},

		/**
		 * Function transforms local browser timestamp (in ms) to server timestamp (calculated depend on local browser timezone offset). Returns timestamp in seconds.
		 *
		 * @param timestamp - timestamp in milliseconds
		 * @returns {number}
		 */
		getServerTimestamp: function(timestamp)
		{
			timestamp = parseInt(timestamp, 10);
			var browserOffset = new Date(timestamp).getTimezoneOffset() * 60;
			return Math.round(timestamp / 1000 - (parseInt(this._getMessage('SERVER_TZ_OFFSET'), 10) + parseInt(browserOffset, 10)));
		},

		formatLastActivityDate: function(timestamp, now, utc)
		{
			var ampm = this.isAmPmMode(true);
			var timeFormat = (ampm === this.AM_PM_MODE.LOWER? "g:i a" : (ampm === this.AM_PM_MODE.UPPER? "g:i A" : "H:i"));

			var format = [
			   ["tomorrow", "#01#"+timeFormat],
			   ["now" , "#02#"],
			   ["todayFuture", "#03#"+timeFormat],
			   ["yesterday", "#04#"+timeFormat],
			   ["-", this.convertBitrixFormat(this._getMessage("FORMAT_DATETIME")).replace(/:s/g, "")],
			   ["s60", "sago"],
			   ["i60", "iago"],
			   ["H5", "Hago"],
			   ["H24", "#03#"+timeFormat],
			   ["d31", "dago"],
			   ["m12>1", "mago"],
			   ["m12>0", "dago"],
			   ["", "#05#"]
			];
			var formattedDate = this.format(format, timestamp, now, utc);
			var match = null;
			if ((match = /^#(\d+)#(.*)/.exec(formattedDate)) != null)
			{
				switch (match[1])
				{
					case "01":
						formattedDate = this._getMessage('FD_LAST_SEEN_TOMORROW').replace("#TIME#", match[2]);
					break;
					case "02":
						formattedDate = this._getMessage('FD_LAST_SEEN_NOW');
					break;
					case "03":
						formattedDate = this._getMessage('FD_LAST_SEEN_TODAY').replace("#TIME#", match[2]);
					break;
					case "04":
						formattedDate = this._getMessage('FD_LAST_SEEN_YESTERDAY').replace("#TIME#", match[2]);
					break;
					case "05":
						formattedDate = this._getMessage('FD_LAST_SEEN_MORE_YEAR');
					break;
					default:
						formattedDate = match[2];
					break;
				}
			}

			return formattedDate;
		},

		isAmPmMode: function(returnConst)
		{
			if (returnConst === true)
			{
				return this._getMessage('AMPM_MODE');
			}

			return this._getMessage('AMPM_MODE') !== false;
		},

		/**
		 * The method is designed to replace the localization storage on sites without Bitrix Framework.
		 *
		 * @param message
		 * @returns {*}
		 * @private
		 */
		_getMessage: function(message)
		{
			return BX.message(message);
		},

		/**
		 * The method used to parse date from string by given format.
		 *
		 * @param {string} str - date in given format
		 * @param {boolean} isUTC - is date in UTC
		 * @param {string} formatDate - format of the date without time
		 * @param {string} formatDatetime - format of the date with time
		 * @returns {Date|null} - returns Date object if string was parsed or null
		 */
		parse: function(str, isUTC, formatDate, formatDatetime)
		{
			if (Utils.isNotEmptyString(str))
			{
				if (!formatDate)
					formatDate = this._getMessage('FORMAT_DATE');
				if (!formatDatetime)
					formatDatetime = this._getMessage('FORMAT_DATETIME');

				var regMonths = '';
				for (i = 1; i <= 12; i++)
				{
					regMonths = regMonths + '|' + this._getMessage('MON_'+i);
				}

				var
					expr = new RegExp('([0-9]+|[a-z]+' + regMonths + ')', 'ig'),
					aDate = str.match(expr),
					aFormat = formatDate.match(/(DD|MI|MMMM|MM|M|YYYY)/ig),
					i, cnt,
					aDateArgs=[], aFormatArgs=[],
					aResult={};

				if (!aDate)
				{
					return null;
				}

				if(aDate.length > aFormat.length)
				{
					aFormat = formatDatetime.match(/(DD|MI|MMMM|MM|M|YYYY|HH|H|SS|TT|T|GG|G)/ig);
				}

				for(i = 0, cnt = aDate.length; i < cnt; i++)
				{
					if(aDate[i].trim() !== '')
					{
						aDateArgs[aDateArgs.length] = aDate[i];
					}
				}

				for(i = 0, cnt = aFormat.length; i < cnt; i++)
				{
					if(aFormat[i].trim() !== '')
					{
						aFormatArgs[aFormatArgs.length] = aFormat[i];
					}
				}

				var m = Utils.array_search('MMMM', aFormatArgs);
				if (m > 0)
				{
					aDateArgs[m] = this.getMonthIndex(aDateArgs[m]);
					aFormatArgs[m] = "MM";
				}
				else
				{
					m = Utils.array_search('M', aFormatArgs);
					if (m > 0)
					{
						aDateArgs[m] = this.getMonthIndex(aDateArgs[m]);
						aFormatArgs[m] = "MM";
					}
				}

				for(i = 0, cnt = aFormatArgs.length; i < cnt; i++)
				{
					var k = aFormatArgs[i].toUpperCase();
					aResult[k] = k === 'T' || k === 'TT' ? aDateArgs[i] : parseInt(aDateArgs[i], 10);
				}

				if(aResult['DD'] > 0 && aResult['MM'] > 0 && aResult['YYYY'] > 0)
				{
					var d = new Date();

					if(isUTC)
					{
						d.setUTCDate(1);
						d.setUTCFullYear(aResult['YYYY']);
						d.setUTCMonth(aResult['MM'] - 1);
						d.setUTCDate(aResult['DD']);
						d.setUTCHours(0, 0, 0, 0);
					}
					else
					{
						d.setDate(1);
						d.setFullYear(aResult['YYYY']);
						d.setMonth(aResult['MM'] - 1);
						d.setDate(aResult['DD']);
						d.setHours(0, 0, 0, 0);
					}

					if(
						(!isNaN(aResult['HH']) || !isNaN(aResult['GG']) || !isNaN(aResult['H']) || !isNaN(aResult['G']))
						&& !isNaN(aResult['MI'])
					)
					{
						if (!isNaN(aResult['H']) || !isNaN(aResult['G']))
						{
							var
								bPM = (aResult['T']||aResult['TT']||'am').toUpperCase() === 'PM',
								h = parseInt(aResult['H']||aResult['G']||0, 10);

							if(bPM)
							{
								aResult['HH'] = h + (h === 12 ? 0 : 12);
							}
							else
							{
								aResult['HH'] = h < 12 ? h : 0;
							}
						}
						else
						{
							aResult['HH'] = parseInt(aResult['HH']||aResult['GG']||0, 10);
						}

						if (isNaN(aResult['SS']))
							aResult['SS'] = 0;

						if(isUTC)
						{
							d.setUTCHours(aResult['HH'], aResult['MI'], aResult['SS']);
						}
						else
						{
							d.setHours(aResult['HH'], aResult['MI'], aResult['SS']);
						}
					}

					return d;
				}
			}

			return null;
		},

		getMonthIndex: function(month)
		{
			var
				i,
				q = month.toUpperCase(),
				wordMonthCut = ['jan', 'feb', 'mar', 'apr', 'may', 'jun', 'jul', 'aug', 'sep', 'oct', 'nov', 'dec'],
				wordMonth = ['january', 'february', 'march', 'april', 'may', 'june', 'july', 'august', 'september', 'october', 'november', 'december'];

			for (i = 1; i <= 12; i++)
			{
				if (q === this._getMessage('MON_'+i).toUpperCase()
					|| q === this._getMessage('MONTH_'+i).toUpperCase()
					|| q === wordMonthCut[i-1].toUpperCase()
					|| q === wordMonth[i-1].toUpperCase())
				{
					return i;
				}
			}
			return month;
		}
	};

	/**
	 * @private
	 */
	var Utils = {
		isDate: function(item) {
			return item && Object.prototype.toString.call(item) == "[object Date]";
		},
		isNumber: function(item) {
			return item === 0 ? true : (item ? (typeof (item) == "number" || item instanceof Number) : false);
		},
		isArray: function(item) {
			return item && Object.prototype.toString.call(item) == "[object Array]";
		},
		isString: function(item) {
			return item === '' ? true : (item ? (typeof (item) == "string" || item instanceof String) : false);
		},
		isNotEmptyString: function(item) {
			return this.isString(item) ? item.length > 0 : false;
		},
		strPadLeft: function(input, padLength, padString)
		{
			var i = input.length, q=padString.length;
			if (i >= padLength) return input;

			for(;i<padLength;i+=q)
				input = padString + input;

			return input;
		},
		/**
		 * @deprecated
		 * @use myArr.findIndex(item => item === needle);
		 */
		array_search: function(needle, haystack)
		{
			for(var i = 0; i < haystack.length; i++)
			{
				if(haystack[i] == needle)
					return i;
			}
			return -1;
		},
	};

})(window);




// file: /bitrix/js/im/lib/utils/dist/utils.bundle.js
this.BX = this.BX || {};
this.BX.Messenger = this.BX.Messenger || {};
(function (exports,im_const) {
	'use strict';

	/**
	 * Bitrix Messenger
	 * Utils
	 *
	 * @package bitrix
	 * @subpackage im
	 * @copyright 2001-2019 Bitrix
	 */
	var Utils = {
	  browser: {
	    isSafari: function isSafari() {
	      if (this.isChrome()) {
	        return false;
	      }

	      if (!navigator.userAgent.toLowerCase().includes('safari')) {
	        return false;
	      }

	      return !this.isSafariBased();
	    },
	    isSafariBased: function isSafariBased() {
	      if (!navigator.userAgent.toLowerCase().includes('applewebkit')) {
	        return false;
	      }

	      return navigator.userAgent.toLowerCase().includes('yabrowser') || navigator.userAgent.toLowerCase().includes('yaapp_ios_browser') || navigator.userAgent.toLowerCase().includes('crios');
	    },
	    isChrome: function isChrome() {
	      return navigator.userAgent.toLowerCase().includes('chrome');
	    },
	    isFirefox: function isFirefox() {
	      return navigator.userAgent.toLowerCase().includes('firefox');
	    },
	    isIe: function isIe() {
	      return navigator.userAgent.match(/(Trident\/|MSIE\/)/) !== null;
	    },
	    findParent: function findParent(item, findTag) {
	      var isHtmlElement = findTag instanceof HTMLElement;

	      if (!findTag || typeof findTag !== 'string' && !isHtmlElement) {
	        return null;
	      }

	      for (; item && item !== document; item = item.parentNode) {
	        if (typeof findTag === 'string') {
	          if (item.classList.contains(findTag)) {
	            return item;
	          }
	        } else if (isHtmlElement) {
	          if (item === findTag) {
	            return item;
	          }
	        }
	      }

	      return null;
	    }
	  },
	  platform: {
	    isMac: function isMac() {
	      return navigator.userAgent.toLowerCase().includes('macintosh');
	    },
	    isLinux: function isLinux() {
	      return navigator.userAgent.toLowerCase().includes('linux');
	    },
	    isWindows: function isWindows() {
	      return navigator.userAgent.toLowerCase().includes('windows') || !this.isMac() && !this.isLinux();
	    },
	    isBitrixMobile: function isBitrixMobile() {
	      return navigator.userAgent.toLowerCase().includes('bitrixmobile');
	    },
	    isBitrixDesktop: function isBitrixDesktop() {
	      return navigator.userAgent.toLowerCase().includes('bitrixdesktop');
	    },
	    getDesktopVersion: function getDesktopVersion() {
	      if (typeof this.getDesktopVersionStatic !== 'undefined') {
	        return this.getDesktopVersionStatic;
	      }

	      if (typeof BXDesktopSystem === 'undefined') {
	        return 0;
	      }

	      var version = BXDesktopSystem.GetProperty('versionParts');
	      this.getDesktopVersionStatic = version[3];
	      return this.getDesktopVersionStatic;
	    },
	    isMobile: function isMobile() {
	      return this.isAndroid() || this.isIos() || this.isBitrixMobile();
	    },
	    isIos: function isIos() {
	      return navigator.userAgent.toLowerCase().includes('iphone') || navigator.userAgent.toLowerCase().includes('ipad');
	    },
	    getIosVersion: function getIosVersion() {
	      if (!this.isIos()) {
	        return null;
	      }

	      var matches = navigator.userAgent.toLowerCase().match(/(iphone|ipad)(.+)(OS\s([0-9]+)([_.]([0-9]+))?)/i);

	      if (!matches || !matches[4]) {
	        return null;
	      }

	      return parseFloat(matches[4] + '.' + (matches[6] ? matches[6] : 0));
	    },
	    isAndroid: function isAndroid() {
	      return navigator.userAgent.toLowerCase().includes('android');
	    },
	    openNewPage: function openNewPage(url) {
	      if (!url) {
	        return false;
	      }

	      if (this.isBitrixMobile()) {
	        if (typeof BX.MobileTools !== 'undefined') {
	          var openWidget = BX.MobileTools.resolveOpenFunction(url);

	          if (openWidget) {
	            openWidget();
	            return true;
	          }
	        }

	        app.openNewPage(url);
	      } else {
	        window.open(url, '_blank');
	      }

	      return true;
	    }
	  },
	  device: {
	    isDesktop: function isDesktop() {
	      return !this.isMobile();
	    },
	    isMobile: function isMobile() {
	      if (typeof this.isMobileStatic !== 'undefined') {
	        return this.isMobileStatic;
	      }

	      this.isMobileStatic = navigator.userAgent.toLowerCase().includes('android') || navigator.userAgent.toLowerCase().includes('webos') || navigator.userAgent.toLowerCase().includes('iphone') || navigator.userAgent.toLowerCase().includes('ipad') || navigator.userAgent.toLowerCase().includes('ipod') || navigator.userAgent.toLowerCase().includes('blackberry') || navigator.userAgent.toLowerCase().includes('windows phone');
	      return this.isMobileStatic;
	    },
	    orientationHorizontal: 'horizontal',
	    orientationPortrait: 'portrait',
	    getOrientation: function getOrientation() {
	      if (!this.isMobile()) {
	        return this.orientationHorizontal;
	      }

	      return Math.abs(window.orientation) === 0 ? this.orientationPortrait : this.orientationHorizontal;
	    }
	  },
	  types: {
	    isString: function isString(item) {
	      return item === '' ? true : item ? typeof item == "string" || item instanceof String : false;
	    },
	    isArray: function isArray(item) {
	      return item && Object.prototype.toString.call(item) == "[object Array]";
	    },
	    isFunction: function isFunction(item) {
	      return item === null ? false : typeof item == "function" || item instanceof Function;
	    },
	    isDomNode: function isDomNode(item) {
	      return item && babelHelpers["typeof"](item) == "object" && "nodeType" in item;
	    },
	    isDate: function isDate(item) {
	      return item && Object.prototype.toString.call(item) == "[object Date]";
	    },
	    isPlainObject: function isPlainObject(item) {
	      if (!item || babelHelpers["typeof"](item) !== "object" || item.nodeType) {
	        return false;
	      }

	      var hasProp = Object.prototype.hasOwnProperty;

	      try {
	        if (item.constructor && !hasProp.call(item, "constructor") && !hasProp.call(item.constructor.prototype, "isPrototypeOf")) {
	          return false;
	        }
	      } catch (e) {
	        return false;
	      }

	      var key;

	      return typeof key === "undefined" || hasProp.call(item, key);
	    },
	    isUuidV4: function isUuidV4(uuid) {
	      if (!this.isString(uuid)) {
	        return false;
	      }

	      var uuidV4pattern = new RegExp(/^[0-9A-F]{8}-[0-9A-F]{4}-4[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i);
	      return uuid.search(uuidV4pattern) === 0;
	    }
	  },
	  dialog: {
	    getChatIdByDialogId: function getChatIdByDialogId(dialogId) {
	      if (!this.isChatId(dialogId)) {
	        return 0;
	      }

	      return parseInt(dialogId.toString().substr(4));
	    },
	    isChatId: function isChatId(dialogId) {
	      return dialogId.toString().startsWith('chat');
	    },
	    isEmptyDialogId: function isEmptyDialogId(dialogId) {
	      if (!dialogId) {
	        return true;
	      }

	      if (typeof dialogId === "string") {
	        if (dialogId === 'chat0' || dialogId === "0") {
	          return true;
	        }
	      }

	      return false;
	    }
	  },
	  text: {
	    quote: function quote(text, params) {
	      var files = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
	      var localize = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

	      if (typeof text !== 'string') {
	        return text.toString();
	      }

	      if (!localize) {
	        localize = BX.message;
	      }

	      text = text.replace(/\[USER=([0-9]{1,})](.*?)\[\/USER]/ig, function (whole, userId, text) {
	        return text;
	      });
	      text = text.replace(/\[CHAT=(imol\|)?([0-9]{1,})](.*?)[\/CHAT]/ig, function (whole, imol, chatId, text) {
	        return text;
	      });
	      text = text.replace(/\[CALL(?:=(.+?))?](.+?)?\[\/CALL]/ig, function (whole, command, text) {
	        return text ? text : command;
	      });
	      text = text.replace(/\[ATTACH=([0-9]{1,})]/ig, function (whole, command, text) {
	        return command === 10000 ? '' : '[' + localize['IM_UTILS_TEXT_ATTACH'] + '] ';
	      });
	      text = text.replace(/\[RATING=([1-5]{1})]/ig, function (whole, rating) {
	        return '[' + localize.IM_F_RATING + '] ';
	      });
	      text = text.replace(/&nbsp;/ig, " ");
	      text = text.replace(/\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D([\s\S]*?)\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D/gmi, "[" + localize["IM_UTILS_TEXT_QUOTE"] + "]");
	      text = text.replace(/^(>>(.*)\n)/gi, "[" + localize["IM_UTILS_TEXT_QUOTE"] + "]\n");

	      if (params && params.FILE_ID && params.FILE_ID.length > 0) {
	        var filesText = [];
	        params.FILE_ID.forEach(function (fileId) {
	          if (files[fileId].type === 'image') {
	            filesText.push(localize['IM_UTILS_TEXT_IMAGE']);
	          } else if (files[fileId].type === 'audio') {
	            filesText.push(localize['IM_UTILS_TEXT_AUDIO']);
	          } else if (files[fileId].type === 'video') {
	            filesText.push(localize['IM_UTILS_TEXT_VIDEO']);
	          } else {
	            filesText.push(files[fileId].name);
	          }
	        });

	        if (filesText.length <= 0) {
	          filesText.push(localize['IM_UTILS_TEXT_FILE']);
	        }

	        text = filesText.join('\n') + text;
	      } else if (params && params.ATTACH && params.ATTACH.length > 0) {
	        text = '[' + localize['IM_UTILS_TEXT_ATTACH'] + ']\n' + text;
	      }

	      if (text.length <= 0) {
	        text = localize['IM_UTILS_TEXT_DELETED'];
	      }

	      return text.trim();
	    },
	    purify: function purify(text, params) {
	      var files = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
	      var localize = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

	      if (typeof text !== 'string') {
	        return text.toString();
	      }

	      if (!localize) {
	        localize = BX.message;
	      }

	      text = text.trim();

	      if (text.startsWith('/me')) {
	        text = text.substr(4);
	      } else if (text.startsWith('/loud')) {
	        text = text.substr(6);
	      }

	      text = text.replace(/<br><br \/>/ig, '<br />');
	      text = text.replace(/<br \/><br>/ig, '<br />');
	      var codeReplacement = [];
	      text = text.replace(/\[CODE\]\n?([\0-\uFFFF]*?)\[\/CODE\]/ig, function (whole, text) {
	        var id = codeReplacement.length;
	        codeReplacement.push(text);
	        return '####REPLACEMENT_CODE_' + id + '####';
	      });
	      text = text.replace(/\[PUT(?:=(?:.+?))?\](?:.+?)?\[\/PUT]/ig, function (match) {
	        return match.replace(/\[PUT(?:=(.+))?\](.+?)?\[\/PUT]/ig, function (whole, command, text) {
	          return text ? text : command;
	        });
	      });
	      text = text.replace(/\[SEND(?:=(?:.+?))?\](?:.+?)?\[\/SEND]/ig, function (match) {
	        return match.replace(/\[SEND(?:=(.+))?\](.+?)?\[\/SEND]/ig, function (whole, command, text) {
	          return text ? text : command;
	        });
	      });
	      text = text.replace(/\[[buis]](.*?)\[\/[buis]]/ig, '$1');
	      text = text.replace(/\[url](.*?)\[\/url]/ig, '$1');
	      text = text.replace(/\[RATING=([1-5]{1})]/ig, function () {
	        return '[' + localize['IM_UTILS_TEXT_RATING'] + '] ';
	      });
	      text = text.replace(/\[ATTACH=([0-9]{1,})]/ig, function () {
	        return '[' + localize['IM_UTILS_TEXT_ATTACH'] + '] ';
	      });
	      text = text.replace(/\[USER=([0-9]{1,})](.*?)\[\/USER]/ig, '$2');
	      text = text.replace(/\[CHAT=([0-9]{1,})](.*?)\[\/CHAT]/ig, '$2');
	      text = text.replace(/\[SEND(?:=(?:.+?))?\](.+?)?\[\/SEND]/ig, '$1');
	      text = text.replace(/\[PUT(?:=(?:.+?))?\](.+?)?\[\/PUT]/ig, '$1');
	      text = text.replace(/\[CALL=([0-9]{1,})](.*?)\[\/CALL]/ig, '$2');
	      text = text.replace(/\[PCH=([0-9]{1,})](.*?)\[\/PCH]/ig, '$2');
	      text = text.replace(/<img.*?data-code="([^"]*)".*?>/ig, '$1');
	      text = text.replace(/<span.*?title="([^"]*)".*?>.*?<\/span>/ig, '($1)');
	      text = text.replace(/<img.*?title="([^"]*)".*?>/ig, '($1)');
	      text = text.replace(/\[ATTACH=([0-9]{1,})]/ig, function (whole, command, text) {
	        return command === 10000 ? '' : '[' + localize['IM_UTILS_TEXT_ATTACH'] + '] ';
	      });
	      text = text.replace(/<s>([^"]*)<\/s>/ig, ' ');
	      text = text.replace(/\[s]([^"]*)\[\/s]/ig, ' ');
	      text = text.replace(/\[icon=([^\]]*)]/ig, function (whole) {
	        var title = whole.match(/title=(.*[^\s\]])/i);

	        if (title && title[1]) {
	          title = title[1];

	          if (title.indexOf('width=') > -1) {
	            title = title.substr(0, title.indexOf('width='));
	          }

	          if (title.indexOf('height=') > -1) {
	            title = title.substr(0, title.indexOf('height='));
	          }

	          if (title.indexOf('size=') > -1) {
	            title = title.substr(0, title.indexOf('size='));
	          }

	          if (title) {
	            title = '(' + title.trim() + ')';
	          }
	        } else {
	          title = '(' + localize['IM_UTILS_TEXT_ICON'] + ')';
	        }

	        return title;
	      });
	      codeReplacement.forEach(function (element, index) {
	        text = text.replace('####REPLACEMENT_CODE_' + index + '####', element);
	      });
	      text = text.replace(/\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D([\s\S]*?)\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D/gmi, "[" + localize["IM_UTILS_TEXT_QUOTE"] + "] ");
	      text = text.replace(/^(>>(.*)(\n)?)/gmi, "[" + localize["IM_UTILS_TEXT_QUOTE"] + "] ");
	      text = text.replace(/<\/?[^>]+>/gi, '');

	      if (params && params.FILE_ID && params.FILE_ID.length > 0) {
	        var filesText = [];

	        if (babelHelpers["typeof"](files) === 'object') {
	          params.FILE_ID.forEach(function (fileId) {
	            if (typeof files[fileId] === 'undefined') ; else if (files[fileId].type === 'image') {
	              filesText.push(localize['IM_UTILS_TEXT_IMAGE']);
	            } else if (files[fileId].type === 'audio') {
	              filesText.push(localize['IM_UTILS_TEXT_AUDIO']);
	            } else if (files[fileId].type === 'video') {
	              filesText.push(localize['IM_UTILS_TEXT_VIDEO']);
	            } else {
	              filesText.push(files[fileId].name);
	            }
	          });
	        }

	        if (filesText.length <= 0) {
	          filesText.push(localize['IM_UTILS_TEXT_FILE']);
	        }

	        text = filesText.join(' ') + text;
	      } else if (params && (params.WITH_ATTACH || params.ATTACH && params.ATTACH.length > 0)) {
	        text = '[' + localize['IM_UTILS_TEXT_ATTACH'] + '] ' + text;
	      } else if (params && params.WITH_FILE) {
	        text = '[' + localize['IM_UTILS_TEXT_FILE'] + '] ' + text;
	      }

	      if (text.length <= 0) {
	        text = localize['IM_UTILS_TEXT_DELETED'];
	      }

	      return text.replace('\n', ' ').trim();
	    },
	    htmlspecialchars: function htmlspecialchars(text) {
	      if (typeof text !== 'string') {
	        return text;
	      }

	      return text.replace(/&/g, '&amp;').replace(/"/g, '&quot;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
	    },
	    htmlspecialcharsback: function htmlspecialcharsback(text) {
	      if (typeof text !== 'string') {
	        return text;
	      }

	      return text.replace(/\&quot;/g, '"').replace(/&#039;/g, "'").replace(/\&lt;/g, '<').replace(/\&gt;/g, '>').replace(/\&amp;/g, '&').replace(/\&nbsp;/g, ' ');
	    },
	    getLocalizeForNumber: function getLocalizeForNumber(phrase, number) {
	      var language = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'en';
	      var localize = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

	      if (!localize) {
	        localize = BX.message;
	      }

	      var pluralFormType = 1;
	      number = parseInt(number);

	      if (number < 0) {
	        number = number * -1;
	      }

	      if (language) {
	        switch (language) {
	          case 'de':
	          case 'en':
	            pluralFormType = number !== 1 ? 1 : 0;
	            break;

	          case 'ru':
	          case 'ua':
	            pluralFormType = number % 10 === 1 && number % 100 !== 11 ? 0 : number % 10 >= 2 && number % 10 <= 4 && (number % 100 < 10 || number % 100 >= 20) ? 1 : 2;
	            break;
	        }
	      }

	      return localize[phrase + '_PLURAL_' + pluralFormType];
	    }
	  },
	  date: {
	    getFormatType: function getFormatType() {
	      var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : im_const.DateFormat["default"];
	      var localize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

	      if (!localize) {
	        localize = BX.message;
	      }

	      var format = [];

	      if (type === im_const.DateFormat.groupTitle) {
	        format = [["tommorow", "tommorow"], ["today", "today"], ["yesterday", "yesterday"], ["", localize["IM_UTILS_FORMAT_DATE"]]];
	      } else if (type === im_const.DateFormat.message) {
	        format = [["", localize["IM_UTILS_FORMAT_TIME"]]];
	      } else if (type === im_const.DateFormat.recentTitle) {
	        format = [["tommorow", "today"], ["today", "today"], ["yesterday", "yesterday"], ["", localize["IM_UTILS_FORMAT_DATE_RECENT"]]];
	      } else if (type === im_const.DateFormat.recentLinesTitle) {
	        format = [["tommorow", "tommorow"], ["today", "today"], ["yesterday", "yesterday"], ["", localize["IM_UTILS_FORMAT_DATE_RECENT"]]];
	      } else if (type === im_const.DateFormat.readedTitle) {
	        format = [["tommorow", "tommorow, " + localize["IM_UTILS_FORMAT_TIME"]], ["today", "today, " + localize["IM_UTILS_FORMAT_TIME"]], ["yesterday", "yesterday, " + localize["IM_UTILS_FORMAT_TIME"]], ["", localize["IM_UTILS_FORMAT_READED"]]];
	      } else if (type === im_const.DateFormat.vacationTitle) {
	        format = [["", localize["IM_UTILS_FORMAT_DATE_SHORT"]]];
	      } else {
	        format = [["tommorow", "tommorow, " + localize["IM_UTILS_FORMAT_TIME"]], ["today", "today, " + localize["IM_UTILS_FORMAT_TIME"]], ["yesterday", "yesterday, " + localize["IM_UTILS_FORMAT_TIME"]], ["", localize["IM_UTILS_FORMAT_DATE_TIME"]]];
	      }

	      return format;
	    },
	    getDateFunction: function getDateFunction() {
	      var localize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

	      if (this.dateFormatFunction) {
	        return this.dateFormatFunction;
	      }

	      this.dateFormatFunction = Object.create(BX.Main.Date);

	      if (localize) {
	        this.dateFormatFunction._getMessage = function (phrase) {
	          return localize[phrase];
	        };
	      }

	      return this.dateFormatFunction;
	    },
	    format: function format(timestamp) {
	      var format = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
	      var localize = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

	      if (!format) {
	        format = this.getFormatType(im_const.DateFormat["default"], localize);
	      }

	      return this.getDateFunction(localize).format(format, timestamp);
	    },
	    cast: function cast(date) {
	      var def = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Date();
	      var result = def;

	      if (date instanceof Date) {
	        result = date;
	      } else if (typeof date === "string") {
	        result = new Date(date);
	      } else if (typeof date === "number") {
	        result = new Date(date * 1000);
	      }

	      if (result instanceof Date && Number.isNaN(result.getTime())) {
	        result = def;
	      }

	      return result;
	    }
	  },
	  object: {
	    countKeys: function countKeys(obj) {
	      var result = 0;

	      for (var i in obj) {
	        if (obj.hasOwnProperty(i)) {
	          result++;
	        }
	      }

	      return result;
	    }
	  },
	  user: {
	    getLastDateText: function getLastDateText(params) {
	      var localize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

	      if (!params) {
	        return '';
	      }

	      var dateFunction = Utils.date.getDateFunction(localize);

	      if (!localize) {
	        localize = BX.message || {};
	      }

	      var text = '';
	      var online = {};

	      if (params.bot || params.network) {
	        text = '';
	      } else if (params.absent && !this.isMobileActive(params, localize)) {
	        online = this.getOnlineStatus(params, localize);
	        text = localize['IM_STATUS_VACATION_TITLE'].replace('#DATE#', dateFunction.format(Utils.date.getFormatType(im_const.DateFormat.vacationTitle, localize), params.absent.getTime() / 1000));

	        if (online.isOnline && params.idle) {
	          text = localize['IM_STATUS_AWAY_TITLE'].replace('#TIME#', this.getIdleText(params, localize)) + '. ' + text;
	        } else if (online.isOnline && !online.lastSeenText) {
	          text = online.statusText + '. ' + text;
	        } else if (online.lastSeenText) {
	          if (!Utils.platform.isMobile()) {
	            text = text + '. ' + localize['IM_LAST_SEEN_' + (params.gender === 'F' ? 'F' : 'M')].replace('#POSITION#', text).replace('#LAST_SEEN#', online.lastSeenText);
	          }
	        }
	      } else if (params.lastActivityDate) {
	        online = this.getOnlineStatus(params, localize);

	        if (online.isOnline && params.idle && !this.isMobileActive(params, localize)) {
	          text = localize['IM_STATUS_AWAY_TITLE'].replace('#TIME#', this.getIdleText(params, localize));
	        } else if (online.isOnline && !online.lastSeenText) {
	          if (Utils.platform.isMobile() && this.isMobileActive(params, localize)) {
	            text = localize['IM_STATUS_MOBILE'];
	          } else {
	            text = online.statusText;
	          }
	        } else if (online.lastSeenText) {
	          if (Utils.platform.isMobile()) {
	            text = localize['IM_LAST_SEEN_SHORT_' + (params.gender === 'F' ? 'F' : 'M')].replace('#LAST_SEEN#', online.lastSeenText);
	          } else {
	            text = localize['IM_LAST_SEEN_' + (params.gender === 'F' ? 'F' : 'M')].replace('#POSITION#', text).replace('#LAST_SEEN#', online.lastSeenText);
	          }
	        }
	      }

	      return text;
	    },
	    getIdleText: function getIdleText(params) {
	      var localize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

	      if (!params) {
	        return '';
	      }

	      if (!params.idle) {
	        return '';
	      }

	      return Utils.date.getDateFunction(localize).format([["s60", "sdiff"], ["i60", "idiff"], ["H24", "Hdiff"], ["", "ddiff"]], params.idle);
	    },
	    getOnlineStatus: function getOnlineStatus(params) {
	      var localize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
	      var result = {
	        'isOnline': false,
	        'status': 'offline',
	        'statusText': localize ? localize.IM_STATUS_OFFLINE : 'offline',
	        'lastSeen': params.lastActivityDate,
	        'lastSeenText': ''
	      };

	      if (!params.lastActivityDate || params.lastActivityDate.getTime() === 0) {
	        return result;
	      }

	      var date = new Date();
	      result.isOnline = date.getTime() - params.lastActivityDate.getTime() <= this.getOnlineLimit(localize) * 1000;
	      result.status = result.isOnline ? params.status : 'offline';
	      result.statusText = localize && localize['IM_STATUS_' + result.status.toUpperCase()] ? localize['IM_STATUS_' + result.status.toUpperCase()] : result.status;

	      if (localize && params.lastActivityDate.getTime() > 0 && date.getTime() - params.lastActivityDate.getTime() > 300 * 1000) {
	        result.lastSeenText = Utils.date.getDateFunction(localize).formatLastActivityDate(params.lastActivityDate);
	      }

	      return result;
	    },
	    isMobileActive: function isMobileActive(params) {
	      var localize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

	      if (!params) {
	        return false;
	      }

	      if (!localize) {
	        localize = BX.message || {};
	      }

	      return params.mobileLastDate && new Date() - params.mobileLastDate < this.getOnlineLimit(localize) * 1000 && params.lastActivityDate - params.mobileLastDate < 300 * 1000;
	    },
	    getOnlineLimit: function getOnlineLimit() {
	      var localize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

	      if (!localize) {
	        localize = BX.message || {};
	      }

	      return localize.LIMIT_ONLINE ? parseInt(localize.LIMIT_ONLINE) : 15 * 60;
	    }
	  },
	  isDarkColor: function isDarkColor(hex) {
	    if (!hex || !hex.match(/^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/)) {
	      return false;
	    }

	    if (hex.length === 4) {
	      hex = hex.replace(/#([A-Fa-f0-9])/gi, "$1$1");
	    } else {
	      hex = hex.replace(/#([A-Fa-f0-9])/gi, "$1");
	    }

	    hex = hex.toLowerCase();
	    var darkColor = ["#17a3ea", "#00aeef", "#00c4fb", "#47d1e2", "#75d900", "#ffab00", "#ff5752", "#468ee5", "#1eae43"];

	    if (darkColor.includes('#' + hex)) {
	      return true;
	    }

	    var bigint = parseInt(hex, 16);
	    var red = bigint >> 16 & 255;
	    var green = bigint >> 8 & 255;
	    var blue = bigint & 255;
	    var brightness = (red * 299 + green * 587 + blue * 114) / 1000;
	    return brightness < 128;
	  },
	  hashCode: function hashCode() {
	    var string = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
	    var hash = 0;

	    if (babelHelpers["typeof"](string) === 'object' && string) {
	      string = JSON.stringify(string);
	    } else if (typeof string !== 'string') {
	      string = string.toString();
	    }

	    if (typeof string !== 'string') {
	      return hash;
	    }

	    for (var i = 0; i < string.length; i++) {
	      var _char = string.charCodeAt(i);

	      hash = (hash << 5) - hash + _char;
	      hash = hash & hash;
	    }

	    return hash;
	  },

	  /**
	   * The method compares versions, and returns - 0 if they are the same, 1 if version1 is greater, -1 if version1 is less
	   *
	   * @param version1
	   * @param version2
	   * @returns {number|NaN}
	   */
	  versionCompare: function versionCompare(version1, version2) {
	    var isNumberRegExp = /^([\d+\.]+)$/;

	    if (!isNumberRegExp.test(version1) || !isNumberRegExp.test(version2)) {
	      return NaN;
	    }

	    version1 = version1.toString().split('.');
	    version2 = version2.toString().split('.');

	    if (version1.length < version2.length) {
	      while (version1.length < version2.length) {
	        version1.push(0);
	      }
	    } else if (version2.length < version1.length) {
	      while (version2.length < version1.length) {
	        version2.push(0);
	      }
	    }

	    for (var i = 0; i < version1.length; i++) {
	      if (version1[i] > version2[i]) {
	        return 1;
	      } else if (version1[i] < version2[i]) {
	        return -1;
	      }
	    }

	    return 0;
	  },

	  /**
	   * Throttle function. Callback will be executed no more than 'wait' period (in ms).
	   *
	   * @param callback
	   * @param wait
	   * @param context
	   * @returns {Function}
	   */
	  throttle: function throttle(callback, wait) {
	    var context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this;
	    var timeout = null;
	    var callbackArgs = null;

	    var nextCallback = function nextCallback() {
	      callback.apply(context, callbackArgs);
	      timeout = null;
	    };

	    return function () {
	      if (!timeout) {
	        callbackArgs = arguments;
	        timeout = setTimeout(nextCallback, wait);
	      }
	    };
	  },

	  /**
	   * Debounce function. Callback will be executed if it hast been called for longer than 'wait' period (in ms).
	   *
	   * @param callback
	   * @param wait
	   * @param context
	   * @returns {Function}
	   */
	  debounce: function debounce(callback, wait) {
	    var context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this;
	    var timeout = null;
	    var callbackArgs = null;

	    var nextCallback = function nextCallback() {
	      callback.apply(context, callbackArgs);
	    };

	    return function () {
	      callbackArgs = arguments;
	      clearTimeout(timeout);
	      timeout = setTimeout(nextCallback, wait);
	    };
	  },
	  getLogTrackingParams: function getLogTrackingParams() {
	    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	    var result = [];
	    var _params$name = params.name,
	        name = _params$name === void 0 ? 'tracking' : _params$name,
	        _params$data = params.data,
	        data = _params$data === void 0 ? [] : _params$data,
	        _params$dialog = params.dialog,
	        dialog = _params$dialog === void 0 ? null : _params$dialog,
	        _params$message = params.message,
	        message = _params$message === void 0 ? null : _params$message,
	        _params$files = params.files,
	        files = _params$files === void 0 ? null : _params$files;
	    name = encodeURIComponent(name);

	    if (data && !(data instanceof Array) && babelHelpers["typeof"](data) === 'object') {
	      var dataArray = [];

	      for (var _name in data) {
	        if (data.hasOwnProperty(_name)) {
	          dataArray.push(encodeURIComponent(_name) + "=" + encodeURIComponent(data[_name]));
	        }
	      }

	      data = dataArray;
	    } else if (!data instanceof Array) {
	      data = [];
	    }

	    if (dialog) {
	      result.push('timType=' + dialog.type);

	      if (dialog.type === 'lines') {
	        result.push('timLinesType=' + dialog.entityId.split('|')[0]);
	      }
	    }

	    if (files) {
	      var type = 'file';

	      if (files instanceof Array && files[0]) {
	        type = files[0].type;
	      } else {
	        type = files.type;
	      }

	      result.push('timMessageType=' + type);
	    } else if (message) {
	      result.push('timMessageType=text');
	    }

	    if (this.platform.isBitrixMobile()) {
	      result.push('timDevice=bitrixMobile');
	    } else if (this.platform.isBitrixDesktop()) {
	      result.push('timDevice=bitrixDesktop');
	    } else if (this.platform.isIos() || this.platform.isAndroid()) {
	      result.push('timDevice=mobile');
	    } else {
	      result.push('timDevice=web');
	    }

	    return name + (data.length ? '&' + data.join('&') : '') + (result.length ? '&' + result.join('&') : '');
	  }
	};

	exports.Utils = Utils;

}((this.BX.Messenger.Lib = this.BX.Messenger.Lib || {}),BX.Messenger.Const));
 




// file: /bitrix/js/im/model/dist/registry.bundle.js
this.BX = this.BX || {};
this.BX.Messenger = this.BX.Messenger || {};
(function (exports,im_lib_logger,main_core_events,im_lib_utils,ui_vue,ui_vue_vuex,main_core,im_const) {
	'use strict';

	/**
	 * Bitrix Messenger
	 * Application model (Vuex Builder model)
	 *
	 * @package bitrix
	 * @subpackage im
	 * @copyright 2001-2020 Bitrix
	 */
	var ApplicationModel = /*#__PURE__*/function (_VuexBuilderModel) {
	  babelHelpers.inherits(ApplicationModel, _VuexBuilderModel);

	  function ApplicationModel() {
	    babelHelpers.classCallCheck(this, ApplicationModel);
	    return babelHelpers.possibleConstructorReturn(this, babelHelpers.getPrototypeOf(ApplicationModel).apply(this, arguments));
	  }

	  babelHelpers.createClass(ApplicationModel, [{
	    key: "getName",
	    value: function getName() {
	      return 'application';
	    }
	  }, {
	    key: "getState",
	    value: function getState() {
	      return {
	        common: {
	          host: this.getVariable('common.host', location.protocol + '//' + location.host),
	          siteId: this.getVariable('common.siteId', 'default'),
	          userId: this.getVariable('common.userId', 0),
	          languageId: this.getVariable('common.languageId', 'en')
	        },
	        dialog: {
	          dialogId: this.getVariable('dialog.dialogId', '0'),
	          chatId: this.getVariable('dialog.chatId', 0),
	          diskFolderId: this.getVariable('dialog.diskFolderId', 0),
	          messageLimit: this.getVariable('dialog.messageLimit', 20),
	          enableReadMessages: this.getVariable('dialog.enableReadMessages', true),
	          messageExtraCount: 0
	        },
	        disk: {
	          enabled: false,
	          maxFileSize: 5242880
	        },
	        call: {
	          serverEnabled: false,
	          maxParticipants: 24
	        },
	        mobile: {
	          keyboardShow: false
	        },
	        device: {
	          type: this.getVariable('device.type', im_const.DeviceType.desktop),
	          orientation: this.getVariable('device.orientation', im_const.DeviceOrientation.portrait)
	        },
	        options: {
	          quoteEnable: this.getVariable('options.quoteEnable', true),
	          quoteFromRight: this.getVariable('options.quoteFromRight', true),
	          autoplayVideo: this.getVariable('options.autoplayVideo', true),
	          darkBackground: this.getVariable('options.darkBackground', false),
	          showSmiles: false
	        },
	        error: {
	          active: false,
	          code: '',
	          description: ''
	        }
	      };
	    }
	  }, {
	    key: "getStateSaveException",
	    value: function getStateSaveException() {
	      return Object.assign({
	        common: this.getVariable('saveException.common', null),
	        dialog: this.getVariable('saveException.dialog', null),
	        mobile: this.getVariable('saveException.mobile', null),
	        device: this.getVariable('saveException.device', null),
	        error: this.getVariable('saveException.error', null)
	      });
	    }
	  }, {
	    key: "getActions",
	    value: function getActions() {
	      var _this = this;

	      return {
	        set: function set(store, payload) {
	          store.commit('set', _this.validate(payload));
	        },
	        showSmiles: function showSmiles(store, payload) {
	          store.commit('showSmiles');
	        },
	        hideSmiles: function hideSmiles(store, payload) {
	          store.commit('hideSmiles');
	        }
	      };
	    }
	  }, {
	    key: "getMutations",
	    value: function getMutations() {
	      var _this2 = this;

	      return {
	        set: function set(state, payload) {
	          var hasChange = false;

	          for (var group in payload) {
	            if (!payload.hasOwnProperty(group)) {
	              continue;
	            }

	            for (var field in payload[group]) {
	              if (!payload[group].hasOwnProperty(field)) {
	                continue;
	              }

	              state[group][field] = payload[group][field];
	              hasChange = true;
	            }
	          }

	          if (hasChange && _this2.isSaveNeeded(payload)) {
	            _this2.saveState(state);
	          }
	        },
	        increaseDialogExtraCount: function increaseDialogExtraCount(state) {
	          var payload = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	          var _payload$count = payload.count,
	              count = _payload$count === void 0 ? 1 : _payload$count;
	          state.dialog.messageExtraCount += count;
	        },
	        decreaseDialogExtraCount: function decreaseDialogExtraCount(state) {
	          var payload = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	          var _payload$count2 = payload.count,
	              count = _payload$count2 === void 0 ? 1 : _payload$count2;
	          var newCounter = state.dialog.messageExtraCount - count;

	          if (newCounter <= 0) {
	            newCounter = 0;
	          }

	          state.dialog.messageExtraCount = newCounter;
	        },
	        clearDialogExtraCount: function clearDialogExtraCount(state) {
	          state.dialog.messageExtraCount = 0;
	        },
	        showSmiles: function showSmiles(state) {
	          state.options.showSmiles = true;
	        },
	        hideSmiles: function hideSmiles(state) {
	          state.options.showSmiles = false;
	        }
	      };
	    }
	  }, {
	    key: "validate",
	    value: function validate(fields) {
	      var result = {};

	      if (babelHelpers["typeof"](fields.common) === 'object' && fields.common) {
	        result.common = {};

	        if (typeof fields.common.userId === 'number') {
	          result.common.userId = fields.common.userId;
	        }

	        if (typeof fields.common.languageId === 'string') {
	          result.common.languageId = fields.common.languageId;
	        }
	      }

	      if (babelHelpers["typeof"](fields.dialog) === 'object' && fields.dialog) {
	        result.dialog = {};

	        if (typeof fields.dialog.dialogId === 'number') {
	          result.dialog.dialogId = fields.dialog.dialogId.toString();
	          result.dialog.chatId = 0;
	        } else if (typeof fields.dialog.dialogId === 'string') {
	          result.dialog.dialogId = fields.dialog.dialogId;

	          if (typeof fields.dialog.chatId !== 'number') {
	            var chatId = fields.dialog.dialogId;

	            if (chatId.startsWith('chat')) {
	              chatId = fields.dialog.dialogId.substr(4);
	            }

	            chatId = parseInt(chatId);
	            result.dialog.chatId = !isNaN(chatId) ? chatId : 0;
	            fields.dialog.chatId = result.dialog.chatId;
	          }
	        }

	        if (typeof fields.dialog.chatId === 'number') {
	          result.dialog.chatId = fields.dialog.chatId;
	        }

	        if (typeof fields.dialog.diskFolderId === 'number') {
	          result.dialog.diskFolderId = fields.dialog.diskFolderId;
	        }

	        if (typeof fields.dialog.messageLimit === 'number') {
	          result.dialog.messageLimit = fields.dialog.messageLimit;
	        }

	        if (typeof fields.dialog.messageExtraCount === 'number') {
	          result.dialog.messageExtraCount = fields.dialog.messageExtraCount;
	        }

	        if (typeof fields.dialog.enableReadMessages === 'boolean') {
	          result.dialog.enableReadMessages = fields.dialog.enableReadMessages;
	        }
	      }

	      if (babelHelpers["typeof"](fields.disk) === 'object' && fields.disk) {
	        result.disk = {};

	        if (typeof fields.disk.enabled === 'boolean') {
	          result.disk.enabled = fields.disk.enabled;
	        }

	        if (typeof fields.disk.maxFileSize === 'number') {
	          result.disk.maxFileSize = fields.disk.maxFileSize;
	        }
	      }

	      if (babelHelpers["typeof"](fields.call) === 'object' && fields.call) {
	        result.call = {};

	        if (typeof fields.call.serverEnabled === 'boolean') {
	          result.call.serverEnabled = fields.call.serverEnabled;
	        }

	        if (typeof fields.call.maxParticipants === 'number') {
	          result.call.maxParticipants = fields.call.maxParticipants;
	        }
	      }

	      if (babelHelpers["typeof"](fields.mobile) === 'object' && fields.mobile) {
	        result.mobile = {};

	        if (typeof fields.mobile.keyboardShow === 'boolean') {
	          result.mobile.keyboardShow = fields.mobile.keyboardShow;
	        }
	      }

	      if (babelHelpers["typeof"](fields.device) === 'object' && fields.device) {
	        result.device = {};

	        if (typeof fields.device.type === 'string' && typeof im_const.DeviceType[fields.device.type] !== 'undefined') {
	          result.device.type = fields.device.type;
	        }

	        if (typeof fields.device.orientation === 'string' && typeof im_const.DeviceOrientation[fields.device.orientation] !== 'undefined') {
	          result.device.orientation = fields.device.orientation;
	        }
	      }

	      if (babelHelpers["typeof"](fields.error) === 'object' && fields.error) {
	        if (typeof fields.error.active === 'boolean') {
	          result.error = {
	            active: fields.error.active,
	            code: fields.error.code.toString() || '',
	            description: fields.error.description.toString() || ''
	          };
	        }
	      }

	      return result;
	    }
	  }]);
	  return ApplicationModel;
	}(ui_vue_vuex.WidgetVuexBuilderModel);

	/**
	 * Bitrix Messenger
	 * Call Application model (Vuex Builder model)
	 *
	 * @package bitrix
	 * @subpackage im
	 * @copyright 2001-2020 Bitrix
	 */
	var ConferenceModel = /*#__PURE__*/function (_VuexBuilderModel) {
	  babelHelpers.inherits(ConferenceModel, _VuexBuilderModel);

	  function ConferenceModel() {
	    babelHelpers.classCallCheck(this, ConferenceModel);
	    return babelHelpers.possibleConstructorReturn(this, babelHelpers.getPrototypeOf(ConferenceModel).apply(this, arguments));
	  }

	  babelHelpers.createClass(ConferenceModel, [{
	    key: "getName",
	    value: function getName() {
	      return 'conference';
	    }
	  }, {
	    key: "getState",
	    value: function getState() {
	      return {
	        common: {
	          inited: false,
	          passChecked: true,
	          showChat: false,
	          userCount: 0,
	          messageCount: 0,
	          userInCallCount: 0,
	          state: im_const.ConferenceStateType.preparation,
	          callEnded: false,
	          showSmiles: false,
	          error: '',
	          conferenceTitle: '',
	          alias: '',
	          permissionsRequested: false,
	          conferenceStarted: null,
	          conferenceStartDate: null,
	          joinWithVideo: null,
	          userReadyToJoin: false,
	          isBroadcast: false,
	          users: [],
	          usersInCall: [],
	          presenters: [],
	          rightPanelMode: im_const.ConferenceRightPanelMode.hidden
	        },
	        user: {
	          id: -1,
	          hash: ''
	        }
	      };
	    }
	  }, {
	    key: "getActions",
	    value: function getActions() {
	      return {
	        showChat: function showChat(store, payload) {
	          if (typeof payload.newState !== 'boolean') {
	            return false;
	          }

	          store.commit('showChat', payload);
	        },
	        changeRightPanelMode: function changeRightPanelMode(store, payload) {
	          if (!im_const.ConferenceRightPanelMode[payload.mode]) {
	            return false;
	          }

	          store.commit('changeRightPanelMode', payload);
	        },
	        setPermissionsRequested: function setPermissionsRequested(store, payload) {
	          if (typeof payload.status !== 'boolean') {
	            return false;
	          }

	          store.commit('setPermissionsRequested', payload);
	        },
	        setPresenters: function setPresenters(store, payload) {
	          if (!Array.isArray(payload.presenters)) {
	            payload.presenters = [payload.presenters];
	          }

	          store.commit('setPresenters', payload);
	        },
	        setUsers: function setUsers(store, payload) {
	          if (!Array.isArray(payload.users)) {
	            payload.users = [payload.users];
	          }

	          store.commit('setUsers', payload);
	        },
	        removeUsers: function removeUsers(store, payload) {
	          if (!Array.isArray(payload.users)) {
	            payload.users = [payload.users];
	          }

	          store.commit('removeUsers', payload);
	        },
	        setUsersInCall: function setUsersInCall(store, payload) {
	          if (!Array.isArray(payload.users)) {
	            payload.users = [payload.users];
	          }

	          store.commit('setUsersInCall', payload);
	        },
	        removeUsersInCall: function removeUsersInCall(store, payload) {
	          if (!Array.isArray(payload.users)) {
	            payload.users = [payload.users];
	          }

	          store.commit('removeUsersInCall', payload);
	        },
	        setConferenceTitle: function setConferenceTitle(store, payload) {
	          if (typeof payload.conferenceTitle !== 'string') {
	            return false;
	          }

	          store.commit('setConferenceTitle', payload);
	        },
	        setBroadcastMode: function setBroadcastMode(store, payload) {
	          if (typeof payload.broadcastMode !== 'boolean') {
	            return false;
	          }

	          store.commit('setBroadcastMode', payload);
	        }
	      };
	    }
	  }, {
	    key: "getMutations",
	    value: function getMutations() {
	      var _this = this;

	      return {
	        common: function common(state, payload) {
	          if (typeof payload.inited === 'boolean') {
	            state.common.inited = payload.inited;
	          }

	          if (typeof payload.passChecked === 'boolean') {
	            state.common.passChecked = payload.passChecked;
	          }

	          if (typeof payload.userCount === 'number' || typeof payload.userCount === 'string') {
	            state.common.userCount = parseInt(payload.userCount);
	          }

	          if (typeof payload.messageCount === 'number' || typeof payload.messageCount === 'string') {
	            state.common.messageCount = parseInt(payload.messageCount);
	          }

	          if (typeof payload.userInCallCount === 'number' || typeof payload.userInCallCount === 'string') {
	            state.common.userInCallCount = parseInt(payload.userInCallCount);
	          }

	          if (typeof payload.componentError === 'string') {
	            state.common.componentError = payload.componentError;
	          }

	          if (typeof payload.isBroadcast === 'boolean') {
	            state.common.isBroadcast = payload.isBroadcast;
	          }

	          if (Array.isArray(payload.presenters)) {
	            state.common.presenters = payload.presenters;
	          }
	        },
	        user: function user(state, payload) {
	          if (typeof payload.id === 'number') {
	            state.user.id = payload.id;
	          }

	          if (typeof payload.hash === 'string' && payload.hash !== state.user.hash) {
	            state.user.hash = payload.hash;
	          }

	          if (_this.isSaveNeeded({
	            user: payload
	          })) {
	            _this.saveState(state);
	          }
	        },
	        showChat: function showChat(state, _ref) {
	          var newState = _ref.newState;
	          state.common.showChat = newState;
	        },
	        changeRightPanelMode: function changeRightPanelMode(state, _ref2) {
	          var mode = _ref2.mode;
	          state.common.rightPanelMode = mode;
	        },
	        setPermissionsRequested: function setPermissionsRequested(state, payload) {
	          state.common.permissionsRequested = payload.status;
	        },
	        startCall: function startCall(state, payload) {
	          state.common.state = im_const.ConferenceStateType.call;
	          state.common.callEnded = false;
	        },
	        endCall: function endCall(state, payload) {
	          state.common.state = im_const.ConferenceStateType.preparation;
	          state.common.callEnded = true;
	        },
	        returnToPreparation: function returnToPreparation(state, payload) {
	          state.common.state = im_const.ConferenceStateType.preparation;
	        },
	        toggleSmiles: function toggleSmiles(state, payload) {
	          state.common.showSmiles = !state.common.showSmiles;
	        },
	        setError: function setError(state, payload) {
	          if (typeof payload.errorCode === 'string') {
	            state.common.error = payload.errorCode;
	          }
	        },
	        setConferenceTitle: function setConferenceTitle(state, payload) {
	          state.common.conferenceTitle = payload.conferenceTitle;
	        },
	        setBroadcastMode: function setBroadcastMode(state, payload) {
	          state.common.isBroadcast = payload.broadcastMode;
	        },
	        setAlias: function setAlias(state, payload) {
	          if (typeof payload.alias === 'string') {
	            state.common.alias = payload.alias;
	          }
	        },
	        setJoinType: function setJoinType(state, payload) {
	          if (typeof payload.joinWithVideo === 'boolean') {
	            state.common.joinWithVideo = payload.joinWithVideo;
	          }
	        },
	        setConferenceStatus: function setConferenceStatus(state, payload) {
	          if (typeof payload.conferenceStarted === 'boolean') {
	            state.common.conferenceStarted = payload.conferenceStarted;
	          }
	        },
	        setConferenceStartDate: function setConferenceStartDate(state, payload) {
	          if (payload.conferenceStartDate instanceof Date) {
	            state.common.conferenceStartDate = payload.conferenceStartDate;
	          }
	        },
	        setUserReadyToJoin: function setUserReadyToJoin(state, payload) {
	          state.common.userReadyToJoin = true;
	        },
	        setPresenters: function setPresenters(state, payload) {
	          if (payload.replace) {
	            state.common.presenters = payload.presenters;
	          } else {
	            payload.presenters.forEach(function (presenter) {
	              presenter = parseInt(presenter);

	              if (!state.common.presenters.includes(presenter)) {
	                state.common.presenters.push(presenter);
	              }
	            });
	          }
	        },
	        setUsers: function setUsers(state, payload) {
	          payload.users.forEach(function (user) {
	            user = parseInt(user);

	            if (!state.common.users.includes(user)) {
	              state.common.users.push(user);
	            }
	          });
	        },
	        removeUsers: function removeUsers(state, payload) {
	          state.common.users = state.common.users.filter(function (user) {
	            return !payload.users.includes(parseInt(user));
	          });
	        },
	        setUsersInCall: function setUsersInCall(state, payload) {
	          payload.users.forEach(function (user) {
	            user = parseInt(user);

	            if (!state.common.usersInCall.includes(user)) {
	              state.common.usersInCall.push(user);
	            }
	          });
	        },
	        removeUsersInCall: function removeUsersInCall(state, payload) {
	          state.common.usersInCall = state.common.usersInCall.filter(function (user) {
	            return !payload.users.includes(parseInt(user));
	          });
	        }
	      };
	    }
	  }, {
	    key: "getStateSaveException",
	    value: function getStateSaveException() {
	      return {
	        common: {
	          inited: null,
	          state: null,
	          showSmiles: null,
	          userCount: null,
	          messageCount: null,
	          userInCallCount: null,
	          error: null,
	          conferenceTitle: null,
	          alias: null,
	          conferenceStarted: null,
	          conferenceStartDate: null,
	          joinWithVideo: null,
	          userReadyToJoin: null,
	          rightPanelMode: null,
	          presenters: null,
	          users: null
	        }
	      };
	    }
	  }]);
	  return ConferenceModel;
	}(ui_vue_vuex.WidgetVuexBuilderModel);

	function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

	function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

	function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
	var IntersectionType = {
	  empty: 'empty',
	  equal: 'equal',
	  none: 'none',
	  found: 'found',
	  foundReverse: 'foundReverse'
	};
	var MessagesModel = /*#__PURE__*/function (_VuexBuilderModel) {
	  babelHelpers.inherits(MessagesModel, _VuexBuilderModel);

	  function MessagesModel() {
	    babelHelpers.classCallCheck(this, MessagesModel);
	    return babelHelpers.possibleConstructorReturn(this, babelHelpers.getPrototypeOf(MessagesModel).apply(this, arguments));
	  }

	  babelHelpers.createClass(MessagesModel, [{
	    key: "getName",
	    value: function getName() {
	      return 'messages';
	    }
	  }, {
	    key: "getState",
	    value: function getState() {
	      return {
	        created: 0,
	        collection: {},
	        mutationType: {},
	        saveMessageList: {},
	        saveFileList: {},
	        saveUserList: {},
	        host: this.getVariable('host', location.protocol + '//' + location.host)
	      };
	    }
	  }, {
	    key: "getElementState",
	    value: function getElementState() {
	      return {
	        templateId: 0,
	        templateType: 'message',
	        placeholderType: 0,
	        id: 0,
	        chatId: 0,
	        authorId: 0,
	        date: new Date(),
	        text: "",
	        textConverted: "",
	        params: {
	          TYPE: 'default',
	          COMPONENT_ID: 'bx-im-view-message'
	        },
	        push: false,
	        unread: false,
	        sending: false,
	        error: false,
	        retry: false,
	        blink: false
	      };
	    }
	  }, {
	    key: "getGetters",
	    value: function getGetters() {
	      var _this = this;

	      return {
	        getMutationType: function getMutationType(state) {
	          return function (chatId) {
	            if (!state.mutationType[chatId]) {
	              return {
	                initialType: im_const.MutationType.none,
	                appliedType: im_const.MutationType.none
	              };
	            }

	            return state.mutationType[chatId];
	          };
	        },
	        getLastId: function getLastId(state) {
	          return function (chatId) {
	            if (!state.collection[chatId] || state.collection[chatId].length <= 0) {
	              return null;
	            }

	            var lastId = 0;

	            for (var i = 0; i < state.collection[chatId].length; i++) {
	              var element = state.collection[chatId][i];

	              if (element.push || element.sending || element.id.toString().startsWith('temporary')) {
	                continue;
	              }

	              if (lastId < element.id) {
	                lastId = element.id;
	              }
	            }

	            return lastId ? lastId : null;
	          };
	        },
	        getMessage: function getMessage(state) {
	          return function (chatId, messageId) {
	            if (!state.collection[chatId] || state.collection[chatId].length <= 0) {
	              return null;
	            }

	            for (var index = state.collection[chatId].length - 1; index >= 0; index--) {
	              if (state.collection[chatId][index].id === messageId) {
	                return state.collection[chatId][index];
	              }
	            }

	            return null;
	          };
	        },
	        get: function get(state) {
	          return function (chatId) {
	            if (!state.collection[chatId] || state.collection[chatId].length <= 0) {
	              return [];
	            }

	            return state.collection[chatId];
	          };
	        },
	        getBlank: function getBlank(state) {
	          return function (params) {
	            return _this.getElementState();
	          };
	        },
	        getSaveFileList: function getSaveFileList(state) {
	          return function (params) {
	            return state.saveFileList;
	          };
	        },
	        getSaveUserList: function getSaveUserList(state) {
	          return function (params) {
	            return state.saveUserList;
	          };
	        }
	      };
	    }
	  }, {
	    key: "getActions",
	    value: function getActions() {
	      var _this2 = this;

	      return {
	        add: function add(store, payload) {
	          var result = _this2.validate(Object.assign({}, payload));

	          result.params = Object.assign({}, _this2.getElementState().params, result.params);

	          if (payload.id) {
	            if (store.state.collection[payload.chatId]) {
	              var countMessages = store.state.collection[payload.chatId].length - 1;

	              for (var index = countMessages; index >= 0; index--) {
	                var message = store.state.collection[payload.chatId][index];

	                if (message.templateId === payload.id) {
	                  return;
	                }
	              }
	            }

	            result.id = payload.id;
	          } else {
	            result.id = 'temporary' + new Date().getTime() + store.state.created;
	          }

	          result.templateId = result.id;
	          result.unread = false;
	          store.commit('add', Object.assign({}, _this2.getElementState(), result));

	          if (payload.sending !== false) {
	            store.dispatch('actionStart', {
	              id: result.id,
	              chatId: result.chatId
	            });
	          }

	          return result.id;
	        },
	        actionStart: function actionStart(store, payload) {
	          if (/^\d+$/.test(payload.id)) {
	            payload.id = parseInt(payload.id);
	          }

	          payload.chatId = parseInt(payload.chatId);
	          ui_vue.WidgetVue.nextTick(function () {
	            store.commit('update', {
	              id: payload.id,
	              chatId: payload.chatId,
	              fields: {
	                sending: true
	              }
	            });
	          });
	        },
	        actionError: function actionError(store, payload) {
	          if (/^\d+$/.test(payload.id)) {
	            payload.id = parseInt(payload.id);
	          }

	          payload.chatId = parseInt(payload.chatId);
	          ui_vue.WidgetVue.nextTick(function () {
	            store.commit('update', {
	              id: payload.id,
	              chatId: payload.chatId,
	              fields: {
	                sending: false,
	                error: true,
	                retry: payload.retry !== false
	              }
	            });
	          });
	        },
	        actionFinish: function actionFinish(store, payload) {
	          if (/^\d+$/.test(payload.id)) {
	            payload.id = parseInt(payload.id);
	          }

	          payload.chatId = parseInt(payload.chatId);
	          ui_vue.WidgetVue.nextTick(function () {
	            store.commit('update', {
	              id: payload.id,
	              chatId: payload.chatId,
	              fields: {
	                sending: false,
	                error: false,
	                retry: false
	              }
	            });
	          });
	        },
	        set: function set(store, payload) {
	          if (payload instanceof Array) {
	            payload = payload.map(function (message) {
	              return _this2.prepareMessage(message, {
	                host: store.state.host
	              });
	            });
	          } else {
	            var result = _this2.prepareMessage(payload, {
	              host: store.state.host
	            });

	            (payload = []).push(result);
	          }

	          store.commit('set', {
	            insertType: im_const.MutationType.set,
	            data: payload
	          });
	          return 'set is done';
	        },
	        addPlaceholders: function addPlaceholders(store, payload) {
	          if (payload.placeholders instanceof Array) {
	            payload.placeholders = payload.placeholders.map(function (message) {
	              return _this2.prepareMessage(message, {
	                host: store.state.host
	              });
	            });
	          } else {
	            return false;
	          }

	          var insertType = payload.requestMode === 'history' ? im_const.MutationType.setBefore : im_const.MutationType.setAfter;

	          if (insertType === im_const.MutationType.setBefore) {
	            payload.placeholders = payload.placeholders.reverse();
	          }

	          store.commit('set', {
	            insertType: insertType,
	            data: payload.placeholders
	          });
	          return payload.placeholders[0].id;
	        },
	        clearPlaceholders: function clearPlaceholders(store, payload) {
	          store.commit('clearPlaceholders', payload);
	        },
	        updatePlaceholders: function updatePlaceholders(store, payload) {
	          if (payload.data instanceof Array) {
	            payload.data = payload.data.map(function (message) {
	              return _this2.prepareMessage(message, {
	                host: store.state.host
	              });
	            });
	          } else {
	            return false;
	          }

	          store.commit('updatePlaceholders', payload);
	          return true;
	        },
	        setAfter: function setAfter(store, payload) {
	          if (payload instanceof Array) {
	            payload = payload.map(function (message) {
	              return _this2.prepareMessage(message);
	            });
	          } else {
	            var result = _this2.prepareMessage(payload);

	            (payload = []).push(result);
	          }

	          store.commit('set', {
	            insertType: im_const.MutationType.setAfter,
	            data: payload
	          });
	        },
	        setBefore: function setBefore(store, payload) {
	          if (payload instanceof Array) {
	            payload = payload.map(function (message) {
	              return _this2.prepareMessage(message);
	            });
	          } else {
	            var result = _this2.prepareMessage(payload);

	            (payload = []).push(result);
	          }

	          store.commit('set', {
	            insertType: im_const.MutationType.setBefore,
	            data: payload
	          });
	        },
	        update: function update(store, payload) {
	          if (/^\d+$/.test(payload.id)) {
	            payload.id = parseInt(payload.id);
	          }

	          if (/^\d+$/.test(payload.chatId)) {
	            payload.chatId = parseInt(payload.chatId);
	          }

	          store.commit('initCollection', {
	            chatId: payload.chatId
	          });

	          if (!store.state.collection[payload.chatId]) {
	            return false;
	          }

	          var index = store.state.collection[payload.chatId].findIndex(function (el) {
	            return el.id === payload.id;
	          });

	          if (index < 0) {
	            return false;
	          }

	          var result = _this2.validate(Object.assign({}, payload.fields));

	          if (result.params) {
	            result.params = Object.assign({}, _this2.getElementState().params, store.state.collection[payload.chatId][index].params, result.params);
	          }

	          store.commit('update', {
	            id: payload.id,
	            chatId: payload.chatId,
	            index: index,
	            fields: result
	          });

	          if (payload.fields.blink) {
	            setTimeout(function () {
	              store.commit('update', {
	                id: payload.id,
	                chatId: payload.chatId,
	                fields: {
	                  blink: false
	                }
	              });
	            }, 1000);
	          }

	          return true;
	        },
	        "delete": function _delete(store, payload) {
	          if (!(payload.id instanceof Array)) {
	            payload.id = [payload.id];
	          }

	          payload.id = payload.id.map(function (id) {
	            if (/^\d+$/.test(id)) {
	              id = parseInt(id);
	            }

	            return id;
	          });
	          store.commit('delete', {
	            chatId: payload.chatId,
	            elements: payload.id
	          });
	          return true;
	        },
	        clear: function clear(store, payload) {
	          payload.chatId = parseInt(payload.chatId);

	          if (payload.keepPlaceholders) {
	            store.commit('clearMessages', {
	              chatId: payload.chatId
	            });
	          } else {
	            store.commit('clear', {
	              chatId: payload.chatId
	            });
	          }

	          return true;
	        },
	        applyMutationType: function applyMutationType(store, payload) {
	          payload.chatId = parseInt(payload.chatId);
	          store.commit('applyMutationType', {
	            chatId: payload.chatId
	          });
	          return true;
	        },
	        readMessages: function readMessages(store, payload) {
	          payload.readId = parseInt(payload.readId) || 0;
	          payload.chatId = parseInt(payload.chatId);

	          if (typeof store.state.collection[payload.chatId] === 'undefined') {
	            return {
	              count: 0
	            };
	          }

	          var count = 0;

	          for (var index = store.state.collection[payload.chatId].length - 1; index >= 0; index--) {
	            var element = store.state.collection[payload.chatId][index];
	            if (!element.unread) continue;

	            if (payload.readId === 0 || element.id <= payload.readId) {
	              count++;
	            }
	          }

	          store.commit('readMessages', {
	            chatId: payload.chatId,
	            readId: payload.readId
	          });
	          return {
	            count: count
	          };
	        },
	        unreadMessages: function unreadMessages(store, payload) {
	          payload.unreadId = parseInt(payload.unreadId) || 0;
	          payload.chatId = parseInt(payload.chatId);

	          if (typeof store.state.collection[payload.chatId] === 'undefined' || !payload.unreadId) {
	            return {
	              count: 0
	            };
	          }

	          var count = 0;

	          for (var index = store.state.collection[payload.chatId].length - 1; index >= 0; index--) {
	            var element = store.state.collection[payload.chatId][index];
	            if (element.unread) continue;

	            if (element.id >= payload.unreadId) {
	              count++;
	            }
	          }

	          store.commit('unreadMessages', {
	            chatId: payload.chatId,
	            unreadId: payload.unreadId
	          });
	          return {
	            count: count
	          };
	        }
	      };
	    }
	  }, {
	    key: "getMutations",
	    value: function getMutations() {
	      var _this3 = this;

	      return {
	        initCollection: function initCollection(state, payload) {
	          return _this3.initCollection(state, payload);
	        },
	        add: function add(state, payload) {
	          _this3.initCollection(state, {
	            chatId: payload.chatId
	          });

	          state.collection[payload.chatId].push(payload);
	          state.saveMessageList[payload.chatId].push(payload.id);
	          state.created += 1;
	          state.collection[payload.chatId].sort(function (a, b) {
	            return a.id - b.id;
	          });

	          _this3.saveState(state, payload.chatId);

	          im_lib_logger.Logger.warn('Messages model: saving state after add');
	        },
	        clearPlaceholders: function clearPlaceholders(state, payload) {
	          if (!state.collection[payload.chatId]) {
	            return false;
	          }

	          state.collection[payload.chatId] = state.collection[payload.chatId].filter(function (element) {
	            return !element.id.toString().startsWith('placeholder');
	          });
	        },
	        updatePlaceholders: function updatePlaceholders(state, payload) {
	          var firstPlaceholderId = "placeholder".concat(payload.firstMessage);
	          var firstPlaceholderIndex = state.collection[payload.chatId].findIndex(function (message) {
	            return message.id === firstPlaceholderId;
	          }); // Logger.warn('firstPlaceholderIndex', firstPlaceholderIndex);

	          if (firstPlaceholderIndex >= 0) {
	            var _state$collection$pay;

	            // Logger.warn('before delete', state.collection[payload.chatId].length, [...state.collection[payload.chatId]]);
	            state.collection[payload.chatId].splice(firstPlaceholderIndex, payload.amount); // Logger.warn('after delete', state.collection[payload.chatId].length, [...state.collection[payload.chatId]]);

	            (_state$collection$pay = state.collection[payload.chatId]).splice.apply(_state$collection$pay, [firstPlaceholderIndex, 0].concat(babelHelpers.toConsumableArray(payload.data))); // Logger.warn('after add', state.collection[payload.chatId].length, [...state.collection[payload.chatId]]);

	          }

	          state.collection[payload.chatId].sort(function (a, b) {
	            return a.id - b.id;
	          });
	          im_lib_logger.Logger.warn('Messages model: saving state after updating placeholders');

	          _this3.saveState(state, payload.chatId);
	        },
	        set: function set(state, payload) {
	          im_lib_logger.Logger.warn('Messages model: set mutation', payload);
	          var chats = [];
	          var chatsSave = [];
	          var isPush = false;
	          payload.data = MessagesModel.getPayloadWithTempMessages(state, payload);
	          var initialType = payload.insertType;

	          if (payload.insertType === im_const.MutationType.set) {
	            (function () {
	              payload.insertType = im_const.MutationType.setAfter;
	              var elements = {};
	              payload.data.forEach(function (element) {
	                if (!elements[element.chatId]) {
	                  elements[element.chatId] = [];
	                }

	                elements[element.chatId].push(element.id);
	              });

	              var _loop = function _loop(chatId) {
	                if (!elements.hasOwnProperty(chatId)) return "continue";

	                _this3.initCollection(state, {
	                  chatId: chatId
	                });

	                im_lib_logger.Logger.warn('Messages model: messages before adding from request - ', state.collection[chatId].length);

	                if (state.saveMessageList[chatId].length > elements[chatId].length || elements[chatId].length < im_const.StorageLimit.messages) {
	                  state.collection[chatId] = state.collection[chatId].filter(function (element) {
	                    return elements[chatId].includes(element.id);
	                  });
	                  state.saveMessageList[chatId] = state.saveMessageList[chatId].filter(function (id) {
	                    return elements[chatId].includes(id);
	                  });
	                }

	                im_lib_logger.Logger.warn('Messages model: cache length', state.saveMessageList[chatId].length);

	                var intersection = _this3.manageCacheBeforeSet(babelHelpers.toConsumableArray(state.saveMessageList[chatId].reverse()), elements[chatId]);

	                im_lib_logger.Logger.warn('Messages model: set intersection with cache', intersection);

	                if (intersection.type === IntersectionType.none) {
	                  if (intersection.foundElements.length > 0) {
	                    state.collection[chatId] = state.collection[chatId].filter(function (element) {
	                      return !intersection.foundElements.includes(element.id);
	                    });
	                    state.saveMessageList[chatId] = state.saveMessageList[chatId].filter(function (id) {
	                      return !intersection.foundElements.includes(id);
	                    });
	                  }

	                  im_lib_logger.Logger.warn('Messages model: no intersection - removing cache');
	                  _this3.removeIntersectionCacheElements = state.collection[chatId].map(function (element) {
	                    return element.id;
	                  });
	                  state.collection[chatId] = state.collection[chatId].filter(function (element) {
	                    return !_this3.removeIntersectionCacheElements.includes(element.id);
	                  });
	                  state.saveMessageList[chatId] = state.saveMessageList[chatId].filter(function (id) {
	                    return !_this3.removeIntersectionCacheElements.includes(id);
	                  });
	                  _this3.removeIntersectionCacheElements = [];
	                } else if (intersection.type === IntersectionType.foundReverse) {
	                  im_lib_logger.Logger.warn('Messages model: found reverse intersection');
	                  payload.insertType = im_const.MutationType.setBefore;
	                  payload.data = payload.data.reverse();
	                }
	              };

	              for (var chatId in elements) {
	                var _ret = _loop(chatId);

	                if (_ret === "continue") continue;
	              }
	            })();
	          }

	          im_lib_logger.Logger.warn('Messages model: adding messages to model', payload.data);

	          var _iterator = _createForOfIteratorHelper(payload.data),
	              _step;

	          try {
	            var _loop2 = function _loop2() {
	              var element = _step.value;

	              _this3.initCollection(state, {
	                chatId: element.chatId
	              });

	              var index = state.collection[element.chatId].findIndex(function (localMessage) {
	                if (MessagesModel.isTemporaryMessage(localMessage)) {
	                  return localMessage.templateId === element.templateId;
	                }

	                return localMessage.id === element.id;
	              });

	              if (index > -1) {
	                state.collection[element.chatId][index] = Object.assign(state.collection[element.chatId][index], element);
	              } else if (payload.insertType === im_const.MutationType.setBefore) {
	                state.collection[element.chatId].unshift(element);
	              } else if (payload.insertType === im_const.MutationType.setAfter) {
	                state.collection[element.chatId].push(element);
	              }

	              chats.push(element.chatId);

	              if (_this3.store.getters['dialogues/canSaveChat'] && _this3.store.getters['dialogues/canSaveChat'](element.chatId)) {
	                chatsSave.push(element.chatId);
	              }
	            };

	            for (_iterator.s(); !(_step = _iterator.n()).done;) {
	              _loop2();
	            }
	          } catch (err) {
	            _iterator.e(err);
	          } finally {
	            _iterator.f();
	          }

	          chats = babelHelpers.toConsumableArray(new Set(chats));
	          chatsSave = babelHelpers.toConsumableArray(new Set(chatsSave));
	          isPush = payload.data.every(function (element) {
	            return element.push === true;
	          });
	          im_lib_logger.Logger.warn('Is it fake push message?', isPush);
	          chats.forEach(function (chatId) {
	            state.collection[chatId].sort(function (a, b) {
	              return a.id - b.id;
	            });

	            if (!isPush) {
	              //send event that messages are ready and we can start reading etc
	              im_lib_logger.Logger.warn('setting messagesSet = true for chatId = ', chatId);
	              setTimeout(function () {
	                main_core_events.EventEmitter.emit(im_const.EventType.dialog.messagesSet, {
	                  chatId: chatId
	                });
	                main_core_events.EventEmitter.emit(im_const.EventType.dialog.readVisibleMessages, {
	                  chatId: chatId
	                });
	              }, 100);
	            }
	          });

	          if (initialType !== im_const.MutationType.setBefore) {
	            chatsSave.forEach(function (chatId) {
	              im_lib_logger.Logger.warn('Messages model: saving state after set');

	              _this3.saveState(state, chatId);
	            });
	          }
	        },
	        update: function update(state, payload) {
	          _this3.initCollection(state, {
	            chatId: payload.chatId
	          });

	          var index = -1;

	          if (typeof payload.index !== 'undefined' && state.collection[payload.chatId][payload.index]) {
	            index = payload.index;
	          } else {
	            index = state.collection[payload.chatId].findIndex(function (el) {
	              return el.id === payload.id;
	            });
	          }

	          if (index >= 0) {
	            var isSaveState = state.saveMessageList[payload.chatId].includes(state.collection[payload.chatId][index].id) || payload.fields.id && !payload.fields.id.toString().startsWith('temporary') && state.collection[payload.chatId][index].id.toString().startsWith('temporary');
	            state.collection[payload.chatId][index] = Object.assign(state.collection[payload.chatId][index], payload.fields);

	            if (isSaveState) {
	              im_lib_logger.Logger.warn('Messages model: saving state after update');

	              _this3.saveState(state, payload.chatId);
	            }
	          }
	        },
	        "delete": function _delete(state, payload) {
	          _this3.initCollection(state, {
	            chatId: payload.chatId
	          });

	          state.collection[payload.chatId] = state.collection[payload.chatId].filter(function (element) {
	            return !payload.elements.includes(element.id);
	          });

	          if (state.saveMessageList[payload.chatId].length > 0) {
	            var _iterator2 = _createForOfIteratorHelper(payload.elements),
	                _step2;

	            try {
	              for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
	                var id = _step2.value;

	                if (state.saveMessageList[payload.chatId].includes(id)) {
	                  im_lib_logger.Logger.warn('Messages model: saving state after delete');

	                  _this3.saveState(state, payload.chatId);

	                  break;
	                }
	              }
	            } catch (err) {
	              _iterator2.e(err);
	            } finally {
	              _iterator2.f();
	            }
	          }
	        },
	        clear: function clear(state, payload) {
	          _this3.initCollection(state, {
	            chatId: payload.chatId
	          });

	          state.collection[payload.chatId] = [];
	          state.saveMessageList[payload.chatId] = [];
	        },
	        clearMessages: function clearMessages(state, payload) {
	          _this3.initCollection(state, {
	            chatId: payload.chatId
	          });

	          state.collection[payload.chatId] = state.collection[payload.chatId].filter(function (element) {
	            return element.id.toString().startsWith('placeholder');
	          });
	          state.saveMessageList[payload.chatId] = [];
	        },
	        applyMutationType: function applyMutationType(state, payload) {
	          if (typeof state.mutationType[payload.chatId] === 'undefined') {
	            ui_vue.WidgetVue.set(state.mutationType, payload.chatId, {
	              applied: false,
	              initialType: im_const.MutationType.none,
	              appliedType: im_const.MutationType.none,
	              scrollStickToTop: 0,
	              scrollMessageId: 0
	            });
	          }

	          state.mutationType[payload.chatId].applied = true;
	        },
	        readMessages: function readMessages(state, payload) {
	          _this3.initCollection(state, {
	            chatId: payload.chatId
	          });

	          var saveNeeded = false;

	          for (var index = state.collection[payload.chatId].length - 1; index >= 0; index--) {
	            var element = state.collection[payload.chatId][index];
	            if (!element.unread) continue;

	            if (payload.readId === 0 || element.id <= payload.readId) {
	              state.collection[payload.chatId][index] = Object.assign(state.collection[payload.chatId][index], {
	                unread: false
	              });
	              saveNeeded = true;
	            }
	          }

	          if (saveNeeded) {
	            im_lib_logger.Logger.warn('Messages model: saving state after reading');

	            _this3.saveState(state, payload.chatId);
	          }
	        },
	        unreadMessages: function unreadMessages(state, payload) {
	          _this3.initCollection(state, {
	            chatId: payload.chatId
	          });

	          var saveNeeded = false;

	          for (var index = state.collection[payload.chatId].length - 1; index >= 0; index--) {
	            var element = state.collection[payload.chatId][index];
	            if (element.unread) continue;

	            if (element.id >= payload.unreadId) {
	              state.collection[payload.chatId][index] = Object.assign(state.collection[payload.chatId][index], {
	                unread: true
	              });
	              saveNeeded = true;
	            }
	          }

	          if (saveNeeded) {
	            im_lib_logger.Logger.warn('Messages model: saving state after unreading');

	            _this3.saveState(state, payload.chatId);

	            _this3.updateSubordinateStates();
	          }
	        }
	      };
	    }
	  }, {
	    key: "initCollection",
	    value: function initCollection(state, payload) {
	      if (typeof payload.chatId === 'undefined') {
	        return false;
	      }

	      if (typeof payload.chatId === 'undefined' || typeof state.collection[payload.chatId] !== 'undefined') {
	        return true;
	      }

	      ui_vue.WidgetVue.set(state.collection, payload.chatId, payload.messages ? [].concat(payload.messages) : []);
	      ui_vue.WidgetVue.set(state.saveMessageList, payload.chatId, []);
	      ui_vue.WidgetVue.set(state.saveFileList, payload.chatId, []);
	      ui_vue.WidgetVue.set(state.saveUserList, payload.chatId, []);
	      return true;
	    }
	  }, {
	    key: "prepareMessage",
	    value: function prepareMessage(message) {
	      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	      var result = this.validate(Object.assign({}, message), options);
	      result.params = Object.assign({}, this.getElementState().params, result.params);

	      if (!result.templateId) {
	        result.templateId = result.id;
	      }

	      return Object.assign({}, this.getElementState(), result);
	    }
	  }, {
	    key: "manageCacheBeforeSet",
	    value: function manageCacheBeforeSet(cache, elements) {
	      var recursive = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
	      im_lib_logger.Logger.warn('manageCacheBeforeSet', cache, elements);
	      var result = {
	        type: IntersectionType.empty,
	        foundElements: [],
	        noneElements: []
	      };

	      if (!cache || cache.length <= 0) {
	        return result;
	      }

	      var _iterator3 = _createForOfIteratorHelper(elements),
	          _step3;

	      try {
	        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
	          var id = _step3.value;

	          if (cache.includes(id)) {
	            if (result.type === IntersectionType.empty) {
	              result.type = IntersectionType.found;
	            }

	            result.foundElements.push(id);
	          } else {
	            if (result.type === IntersectionType.empty) {
	              result.type = IntersectionType.none;
	            }

	            result.noneElements.push(id);
	          }
	        }
	      } catch (err) {
	        _iterator3.e(err);
	      } finally {
	        _iterator3.f();
	      }

	      if (result.type === IntersectionType.found && cache.length === elements.length && result.foundElements.length === elements.length) {
	        result.type = IntersectionType.equal;
	      } else if (result.type === IntersectionType.none && !recursive && result.foundElements.length > 0) {
	        var reverseResult = this.manageCacheBeforeSet(cache.reverse(), elements.reverse(), true);

	        if (reverseResult.type === IntersectionType.found) {
	          reverseResult.type = IntersectionType.foundReverse;
	          return reverseResult;
	        }
	      }

	      return result;
	    }
	  }, {
	    key: "updateSaveLists",
	    value: function updateSaveLists(state, chatId) {
	      if (!this.isSaveAvailable()) {
	        return true;
	      }

	      if (!chatId || !this.store.getters['dialogues/canSaveChat'] || !this.store.getters['dialogues/canSaveChat'](chatId)) {
	        return false;
	      }

	      this.initCollection(state, {
	        chatId: chatId
	      });
	      var count = 0;
	      var saveMessageList = [];
	      var saveFileList = [];
	      var saveUserList = [];
	      var dialog = this.store.getters['dialogues/getByChatId'](chatId);

	      if (dialog && dialog.type === 'private') {
	        saveUserList.push(parseInt(dialog.dialogId));
	      }

	      var readCounter = 0;

	      for (var index = state.collection[chatId].length - 1; index >= 0; index--) {
	        if (state.collection[chatId][index].id.toString().startsWith('temporary')) {
	          continue;
	        }

	        if (!state.collection[chatId][index].unread) {
	          readCounter++;
	        }

	        if (count >= im_const.StorageLimit.messages && readCounter >= 50) {
	          break;
	        }

	        saveMessageList.unshift(state.collection[chatId][index].id);
	        count++;
	      }

	      saveMessageList = saveMessageList.slice(0, im_const.StorageLimit.messages);
	      state.collection[chatId].filter(function (element) {
	        return saveMessageList.includes(element.id);
	      }).forEach(function (element) {
	        if (element.authorId > 0) {
	          saveUserList.push(element.authorId);
	        }

	        if (element.params.FILE_ID instanceof Array) {
	          saveFileList = element.params.FILE_ID.concat(saveFileList);
	        }
	      });
	      state.saveMessageList[chatId] = saveMessageList;
	      state.saveFileList[chatId] = babelHelpers.toConsumableArray(new Set(saveFileList));
	      state.saveUserList[chatId] = babelHelpers.toConsumableArray(new Set(saveUserList));
	      return true;
	    }
	  }, {
	    key: "getSaveTimeout",
	    value: function getSaveTimeout() {
	      return 150;
	    }
	  }, {
	    key: "saveState",
	    value: function saveState(state, chatId) {
	      if (!this.updateSaveLists(state, chatId)) {
	        return false;
	      }

	      babelHelpers.get(babelHelpers.getPrototypeOf(MessagesModel.prototype), "saveState", this).call(this, function () {
	        var storedState = {
	          collection: {},
	          saveMessageList: {},
	          saveUserList: {},
	          saveFileList: {}
	        };

	        var _loop3 = function _loop3(_chatId) {
	          if (!state.saveMessageList.hasOwnProperty(_chatId)) {
	            return "continue";
	          }

	          if (!state.collection[_chatId]) {
	            return "continue";
	          }

	          if (!storedState.collection[_chatId]) {
	            storedState.collection[_chatId] = [];
	          }

	          state.collection[_chatId].filter(function (element) {
	            return state.saveMessageList[_chatId].includes(element.id);
	          }).forEach(function (element) {
	            if (element.templateType !== 'placeholder') {
	              storedState.collection[_chatId].push(element);
	            }
	          });

	          im_lib_logger.Logger.warn('Cache after updating', storedState.collection[_chatId]);
	          storedState.saveMessageList[_chatId] = state.saveMessageList[_chatId];
	          storedState.saveFileList[_chatId] = state.saveFileList[_chatId];
	          storedState.saveUserList[_chatId] = state.saveUserList[_chatId];
	        };

	        for (var _chatId in state.saveMessageList) {
	          var _ret2 = _loop3(_chatId);

	          if (_ret2 === "continue") continue;
	        }

	        return storedState;
	      });
	    }
	  }, {
	    key: "updateSubordinateStates",
	    value: function updateSubordinateStates() {
	      this.store.dispatch('users/saveState');
	      this.store.dispatch('files/saveState');
	    }
	  }, {
	    key: "validate",
	    value: function validate(fields, options) {
	      var result = {};

	      if (typeof fields.id === "number") {
	        result.id = fields.id;
	      } else if (typeof fields.id === "string") {
	        if (fields.id.startsWith('temporary') || fields.id.startsWith('placeholder') || im_lib_utils.Utils.types.isUuidV4(fields.id)) {
	          result.id = fields.id;
	        } else {
	          result.id = parseInt(fields.id);
	        }
	      }

	      if (typeof fields.uuid === "string") {
	        result.templateId = fields.uuid;
	      } else if (typeof fields.templateId === "number") {
	        result.templateId = fields.templateId;
	      } else if (typeof fields.templateId === "string") {
	        if (fields.templateId.startsWith('temporary') || im_lib_utils.Utils.types.isUuidV4(fields.templateId)) {
	          result.templateId = fields.templateId;
	        } else {
	          result.templateId = parseInt(fields.templateId);
	        }
	      }

	      if (typeof fields.templateType === "string") {
	        result.templateType = fields.templateType;
	      }

	      if (typeof fields.placeholderType === "number") {
	        result.placeholderType = fields.placeholderType;
	      }

	      if (typeof fields.chat_id !== 'undefined') {
	        fields.chatId = fields.chat_id;
	      }

	      if (typeof fields.chatId === "number" || typeof fields.chatId === "string") {
	        result.chatId = parseInt(fields.chatId);
	      }

	      if (typeof fields.date !== "undefined") {
	        result.date = im_lib_utils.Utils.date.cast(fields.date);
	      } // previous P&P format


	      if (typeof fields.textOriginal === "string" || typeof fields.textOriginal === "number") {
	        result.text = fields.textOriginal.toString();

	        if (typeof fields.text === "string" || typeof fields.text === "number") {
	          result.textConverted = this.convertToHtml({
	            text: fields.text.toString(),
	            isConverted: true
	          });
	        }
	      } else // modern format
	        {
	          if (typeof fields.text_converted !== 'undefined') {
	            fields.textConverted = fields.text_converted;
	          }

	          if (typeof fields.textConverted === "string" || typeof fields.textConverted === "number") {
	            result.textConverted = fields.textConverted.toString();
	          }

	          if (typeof fields.text === "string" || typeof fields.text === "number") {
	            result.text = fields.text.toString();
	            var isConverted = typeof result.textConverted !== 'undefined';
	            result.textConverted = this.convertToHtml({
	              text: isConverted ? result.textConverted : result.text,
	              isConverted: isConverted
	            });
	          }
	        }

	      if (typeof fields.senderId !== 'undefined') {
	        fields.authorId = fields.senderId;
	      } else if (typeof fields.author_id !== 'undefined') {
	        fields.authorId = fields.author_id;
	      }

	      if (typeof fields.authorId === "number" || typeof fields.authorId === "string") {
	        if (fields.system === true || fields.system === 'Y') {
	          result.authorId = 0;
	        } else {
	          result.authorId = parseInt(fields.authorId);
	        }
	      }

	      if (babelHelpers["typeof"](fields.params) === "object" && fields.params !== null) {
	        var params = this.validateParams(fields.params, options);

	        if (params) {
	          result.params = params;
	        }
	      }

	      if (typeof fields.push === "boolean") {
	        result.push = fields.push;
	      }

	      if (typeof fields.sending === "boolean") {
	        result.sending = fields.sending;
	      }

	      if (typeof fields.unread === "boolean") {
	        result.unread = fields.unread;
	      }

	      if (typeof fields.blink === "boolean") {
	        result.blink = fields.blink;
	      }

	      if (typeof fields.error === "boolean" || typeof fields.error === "string") {
	        result.error = fields.error;
	      }

	      if (typeof fields.retry === "boolean") {
	        result.retry = fields.retry;
	      }

	      return result;
	    }
	  }, {
	    key: "validateParams",
	    value: function validateParams(params, options) {
	      var result = {};

	      try {
	        for (var field in params) {
	          if (!params.hasOwnProperty(field)) {
	            continue;
	          }

	          if (field === 'COMPONENT_ID') {
	            if (typeof params[field] === "string" && BX.WidgetVue.isComponent(params[field])) {
	              result[field] = params[field];
	            }
	          } else if (field === 'LIKE') {
	            if (params[field] instanceof Array) {
	              result['REACTION'] = {
	                like: params[field].map(function (element) {
	                  return parseInt(element);
	                })
	              };
	            }
	          } else if (field === 'CHAT_LAST_DATE') {
	            result[field] = im_lib_utils.Utils.date.cast(params[field]);
	          } else if (field === 'AVATAR') {
	            if (params[field]) {
	              result[field] = params[field].startsWith('http') ? params[field] : options.host + params[field];
	            }
	          } else if (field === 'NAME') {
	            if (params[field]) {
	              result[field] = params[field];
	            }
	          } else if (field === 'LINK_ACTIVE') {
	            if (params[field]) {
	              result[field] = params[field].map(function (userId) {
	                return parseInt(userId);
	              });
	            }
	          } else if (field === 'ATTACH') {
	            result[field] = this.decodeAttach(params[field]);
	          } else {
	            result[field] = params[field];
	          }
	        }
	      } catch (e) {}

	      var hasResultElements = false;

	      for (var _field in result) {
	        if (!result.hasOwnProperty(_field)) {
	          continue;
	        }

	        hasResultElements = true;
	        break;
	      }

	      return hasResultElements ? result : null;
	    }
	  }, {
	    key: "convertToHtml",
	    value: function convertToHtml() {
	      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	      var _params$quote = params.quote,
	          quote = _params$quote === void 0 ? true : _params$quote,
	          _params$image = params.image,
	          image = _params$image === void 0 ? true : _params$image,
	          _params$text = params.text,
	          text = _params$text === void 0 ? '' : _params$text,
	          _params$isConverted = params.isConverted,
	          isConverted = _params$isConverted === void 0 ? false : _params$isConverted,
	          _params$enableBigSmil = params.enableBigSmile,
	          enableBigSmile = _params$enableBigSmil === void 0 ? true : _params$enableBigSmil;
	      text = text.trim();

	      if (!isConverted) {
	        text = text.replace(/&/g, '&amp;').replace(/"/g, '&quot;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
	      }

	      if (text.startsWith('/me')) {
	        text = "<i>".concat(text.substr(4), "</i>");
	      } else if (text.startsWith('/loud')) {
	        text = "<b>".concat(text.substr(6), "</b>");
	      }

	      var quoteSign = "&gt;&gt;";

	      if (quote && text.indexOf(quoteSign) >= 0) {
	        var textPrepare = text.split(isConverted ? "<br />" : "\n");

	        for (var i = 0; i < textPrepare.length; i++) {
	          if (textPrepare[i].startsWith(quoteSign)) {
	            textPrepare[i] = textPrepare[i].replace(quoteSign, '<div class="bx-im-message-content-quote"><div class="bx-im-message-content-quote-wrap">');

	            while (++i < textPrepare.length && textPrepare[i].startsWith(quoteSign)) {
	              textPrepare[i] = textPrepare[i].replace(quoteSign, '');
	            }

	            textPrepare[i - 1] += '</div></div><br>';
	          }
	        }

	        text = textPrepare.join("<br />");
	      }

	      text = text.replace(/\n/gi, '<br />');
	      text = text.replace(/\t/gi, '&nbsp;&nbsp;&nbsp;&nbsp;');
	      text = this.decodeBbCode(text, false, enableBigSmile);

	      if (quote) {
	        text = text.replace(/------------------------------------------------------<br \/>(.*?)\[(.*?)\]<br \/>(.*?)------------------------------------------------------(<br \/>)?/g, function (whole, p1, p2, p3, p4, offset) {
	          return (offset > 0 ? '<br>' : '') + "<div class=\"bx-im-message-content-quote\"><div class=\"bx-im-message-content-quote-wrap\"><div class=\"bx-im-message-content-quote-name\"><span class=\"bx-im-message-content-quote-name-text\">" + p1 + "</span><span class=\"bx-im-message-content-quote-name-time\">" + p2 + "</span></div>" + p3 + "</div></div><br />";
	        });
	        text = text.replace(/------------------------------------------------------<br \/>(.*?)------------------------------------------------------(<br \/>)?/g, function (whole, p1, p2, p3, offset) {
	          return (offset > 0 ? '<br>' : '') + "<div class=\"bx-im-message-content-quote\"><div class=\"bx-im-message-content-quote-wrap\">" + p1 + "</div></div><br />";
	        });
	      }

	      if (image) {
	        var changed = false;
	        text = text.replace(/<a(.*?)>(http[s]{0,1}:\/\/.*?)<\/a>/ig, function (whole, aInner, text, offset) {
	          if (!text.match(/(\.(jpg|jpeg|png|gif|webp)\?|\.(jpg|jpeg|png|gif|webp)$)/i) || text.indexOf("/docs/pub/") > 0 || text.indexOf("logout=yes") > 0) {
	            return whole;
	          } else {
	            changed = true;
	            return (offset > 0 ? '<br />' : '') + '<a' + aInner + ' target="_blank" class="bx-im-element-file-image"><img src="' + text + '" class="bx-im-element-file-image-source-text" onerror="BX.Messenger.Model.MessagesModel.hideErrorImage(this)"></a></span>';
	          }
	        });

	        if (changed) {
	          text = text.replace(/<\/span>(\n?)<br(\s\/?)>/ig, '</span>').replace(/<br(\s\/?)>(\n?)<br(\s\/?)>(\n?)<span/ig, '<br /><span');
	        }
	      }

	      if (enableBigSmile) {
	        text = text.replace(/^(\s*<img\s+src=[^>]+?data-code=[^>]+?data-definition="UHD"[^>]+?style="width:)(\d+)(px[^>]+?height:)(\d+)(px[^>]+?class="bx-smile"\s*\/?>\s*)$/, function doubleSmileSize(match, start, width, middle, height, end) {
	          return start + parseInt(width, 10) * 1.7 + middle + parseInt(height, 10) * 1.7 + end;
	        });
	      }

	      if (text.substr(-6) == '<br />') {
	        text = text.substr(0, text.length - 6);
	      }

	      text = text.replace(/<br><br \/>/ig, '<br />');
	      text = text.replace(/<br \/><br>/ig, '<br />');
	      return text;
	    }
	  }, {
	    key: "decodeBbCode",
	    value: function decodeBbCode(text) {
	      var textOnly = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
	      var enableBigSmile = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
	      return MessagesModel.decodeBbCode({
	        text: text,
	        textOnly: textOnly,
	        enableBigSmile: enableBigSmile
	      });
	    }
	  }, {
	    key: "decodeAttach",
	    value: function decodeAttach(item) {
	      var _this4 = this;

	      if (Array.isArray(item)) {
	        item.forEach(function (arrayElement) {
	          arrayElement = _this4.decodeAttach(arrayElement);
	        });
	      } else if (babelHelpers["typeof"](item) === 'object' && item !== null) {
	        for (var prop in item) {
	          if (item.hasOwnProperty(prop)) {
	            item[prop] = this.decodeAttach(item[prop]);
	          }
	        }
	      } else {
	        if (typeof item === 'string') {
	          item = im_lib_utils.Utils.text.htmlspecialcharsback(item);
	        }
	      }

	      return item;
	    }
	  }], [{
	    key: "decodeBbCode",
	    value: function decodeBbCode() {
	      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	      var text = params.text,
	          _params$textOnly = params.textOnly,
	          textOnly = _params$textOnly === void 0 ? false : _params$textOnly,
	          _params$enableBigSmil2 = params.enableBigSmile,
	          enableBigSmile = _params$enableBigSmil2 === void 0 ? true : _params$enableBigSmil2;
	      var putReplacement = [];
	      text = text.replace(/\[PUT(?:=(.+?))?\](.+?)?\[\/PUT\]/ig, function (whole) {
	        var id = putReplacement.length;
	        putReplacement.push(whole);
	        return '####REPLACEMENT_PUT_' + id + '####';
	      });
	      var sendReplacement = [];
	      text = text.replace(/\[SEND(?:=(.+?))?\](.+?)?\[\/SEND\]/ig, function (whole) {
	        var id = sendReplacement.length;
	        sendReplacement.push(whole);
	        return '####REPLACEMENT_SEND_' + id + '####';
	      });
	      var codeReplacement = [];
	      text = text.replace(/\[CODE\]\n?([\s\S]*?)\[\/CODE\]/ig, function (whole, text) {
	        var id = codeReplacement.length;
	        codeReplacement.push(text);
	        return '####REPLACEMENT_CODE_' + id + '####';
	      });
	      text = text.replace(/\[url=([^\]]+)\](.*?)\[\/url\]/ig, function (whole, link, text) {
	        var tag = document.createElement('a');
	        tag.href = im_lib_utils.Utils.text.htmlspecialcharsback(link);
	        tag.target = '_blank';
	        tag.text = im_lib_utils.Utils.text.htmlspecialcharsback(text);
	        var allowList = ["http:", "https:", "ftp:", "file:", "tel:", "callto:", "mailto:", "skype:", "viber:"];

	        if (allowList.indexOf(tag.protocol) <= -1) {
	          return whole;
	        }

	        return tag.outerHTML;
	      });
	      text = text.replace(/\[url\]([^\]]+)\[\/url\]/ig, function (whole, link) {
	        link = im_lib_utils.Utils.text.htmlspecialcharsback(link);
	        var tag = document.createElement('a');
	        tag.href = link;
	        tag.target = '_blank';
	        tag.text = link;
	        var allowList = ["http:", "https:", "ftp:", "file:", "tel:", "callto:", "mailto:", "skype:", "viber:"];

	        if (allowList.indexOf(tag.protocol) <= -1) {
	          return whole;
	        }

	        return tag.outerHTML;
	      });
	      text = text.replace(/\[LIKE\]/ig, '<span class="bx-smile bx-im-smile-like"></span>');
	      text = text.replace(/\[DISLIKE\]/ig, '<span class="bx-smile bx-im-smile-dislike"></span>');
	      text = text.replace(/\[BR\]/ig, '<br/>');
	      text = text.replace(/\[([buis])\](.*?)\[(\/[buis])\]/ig, function (whole, open, inner, close) {
	        return '<' + open + '>' + inner + '<' + close + '>';
	      }); // TODO tag USER
	      // this code needs to be ported to im/install/js/im/view/message/body/src/body.js:229

	      text = text.replace(/\[CHAT=(imol\|)?([0-9]{1,})\](.*?)\[\/CHAT\]/ig, function (whole, openlines, chatId, inner) {
	        return openlines ? inner : '<span class="bx-im-mention" data-type="CHAT" data-value="chat' + chatId + '">' + inner + '</span>';
	      }); // TODO tag CHAT

	      text = text.replace(/\[CALL(?:=(.+?))?\](.+?)?\[\/CALL\]/ig, function (whole, number, text) {
	        return '<span class="bx-im-mention" data-type="CALL" data-value="' + im_lib_utils.Utils.text.htmlspecialchars(number) + '">' + text + '</span>';
	      }); // TODO tag CHAT

	      text = text.replace(/\[PCH=([0-9]{1,})\](.*?)\[\/PCH\]/ig, function (whole, historyId, text) {
	        return text;
	      }); // TODO tag PCH

	      var textElementSize = 0;

	      if (enableBigSmile) {
	        textElementSize = text.replace(/\[icon\=([^\]]*)\]/ig, '').trim().length;
	      }

	      text = text.replace(/\[icon\=([^\]]*)\]/ig, function (whole) {
	        var url = whole.match(/icon\=(\S+[^\s.,> )\];\'\"!?])/i);

	        if (url && url[1]) {
	          url = url[1];
	        } else {
	          return '';
	        }

	        var attrs = {
	          'src': url,
	          'border': 0
	        };
	        var size = whole.match(/size\=(\d+)/i);

	        if (size && size[1]) {
	          attrs['width'] = size[1];
	          attrs['height'] = size[1];
	        } else {
	          var width = whole.match(/width\=(\d+)/i);

	          if (width && width[1]) {
	            attrs['width'] = width[1];
	          }

	          var height = whole.match(/height\=(\d+)/i);

	          if (height && height[1]) {
	            attrs['height'] = height[1];
	          }

	          if (attrs['width'] && !attrs['height']) {
	            attrs['height'] = attrs['width'];
	          } else if (attrs['height'] && !attrs['width']) {
	            attrs['width'] = attrs['height'];
	          } else if (attrs['height'] && attrs['width']) ; else {
	            attrs['width'] = 20;
	            attrs['height'] = 20;
	          }
	        }

	        attrs['width'] = attrs['width'] > 100 ? 100 : attrs['width'];
	        attrs['height'] = attrs['height'] > 100 ? 100 : attrs['height'];

	        if (enableBigSmile && textElementSize === 0 && attrs['width'] === attrs['height'] && attrs['width'] === 20) {
	          attrs['width'] = 40;
	          attrs['height'] = 40;
	        }

	        var title = whole.match(/title\=(.*[^\s\]])/i);

	        if (title && title[1]) {
	          title = title[1];

	          if (title.indexOf('width=') > -1) {
	            title = title.substr(0, title.indexOf('width='));
	          }

	          if (title.indexOf('height=') > -1) {
	            title = title.substr(0, title.indexOf('height='));
	          }

	          if (title.indexOf('size=') > -1) {
	            title = title.substr(0, title.indexOf('size='));
	          }

	          if (title) {
	            attrs['title'] = im_lib_utils.Utils.text.htmlspecialchars(title).trim();
	            attrs['alt'] = attrs['title'];
	          }
	        }

	        var attributes = '';

	        for (var name in attrs) {
	          if (attrs.hasOwnProperty(name)) {
	            attributes += name + '="' + attrs[name] + '" ';
	          }
	        }

	        return '<img class="bx-smile bx-icon" ' + attributes + '>';
	      });
	      sendReplacement.forEach(function (value, index) {
	        text = text.replace('####REPLACEMENT_SEND_' + index + '####', value);
	      });
	      text = text.replace(/\[SEND(?:=(?:.+?))?\](?:.+?)?\[\/SEND]/ig, function (match) {
	        return match.replace(/\[SEND(?:=(.+))?\](.+?)?\[\/SEND]/ig, function (whole, command, text) {
	          var html = '';
	          text = text ? text : command;
	          command = (command ? command : text).replace('<br />', '\n');

	          if (!textOnly && text) {
	            text = text.replace(/<([\w]+)[^>]*>(.*?)<\\1>/i, "$2", text);
	            text = text.replace(/\[([\w]+)[^\]]*\](.*?)\[\/\1\]/i, "$2", text);
	            command = command.split('####REPLACEMENT_PUT_').join('####REPLACEMENT_SP_');
	            html = '<!--IM_COMMAND_START-->' + '<span class="bx-im-message-command-wrap">' + '<span class="bx-im-message-command" data-entity="send">' + text + '</span>' + '<span class="bx-im-message-command-data">' + command + '</span>' + '</span>' + '<!--IM_COMMAND_END-->';
	          } else {
	            html = text;
	          }

	          return html;
	        });
	      });
	      putReplacement.forEach(function (value, index) {
	        text = text.replace('####REPLACEMENT_PUT_' + index + '####', value);
	      });
	      text = text.replace(/\[PUT(?:=(?:.+?))?\](?:.+?)?\[\/PUT]/ig, function (match) {
	        return match.replace(/\[PUT(?:=(.+))?\](.+?)?\[\/PUT]/ig, function (whole, command, text) {
	          var html = '';
	          text = text ? text : command;
	          command = (command ? command : text).replace('<br />', '\n');

	          if (!textOnly && text) {
	            text = text.replace(/<([\w]+)[^>]*>(.*?)<\/\1>/i, "$2", text);
	            text = text.replace(/\[([\w]+)[^\]]*\](.*?)\[\/\1\]/i, "$2", text);
	            html = '<!--IM_COMMAND_START-->' + '<span class="bx-im-message-command-wrap">' + '<span class="bx-im-message-command" data-entity="put">' + text + '</span>' + '<span class="bx-im-message-command-data">' + command + '</span>' + '</span>' + '<!--IM_COMMAND_END-->';
	          } else {
	            html = text;
	          }

	          return html;
	        });
	      });
	      codeReplacement.forEach(function (code, index) {
	        text = text.replace('####REPLACEMENT_CODE_' + index + '####', !textOnly ? '<div class="bx-im-message-content-code">' + code + '</div>' : code);
	      });

	      if (sendReplacement.length > 0) {
	        do {
	          sendReplacement.forEach(function (value, index) {
	            text = text.replace('####REPLACEMENT_SEND_' + index + '####', value);
	          });
	        } while (text.includes('####REPLACEMENT_SEND_'));
	      }

	      text = text.split('####REPLACEMENT_SP_').join('####REPLACEMENT_PUT_');

	      if (putReplacement.length > 0) {
	        do {
	          putReplacement.forEach(function (value, index) {
	            text = text.replace('####REPLACEMENT_PUT_' + index + '####', value);
	          });
	        } while (text.includes('####REPLACEMENT_PUT_'));
	      }

	      return text;
	    }
	  }, {
	    key: "hideErrorImage",
	    value: function hideErrorImage(element) {
	      if (element.parentNode && element.parentNode) {
	        element.parentNode.innerHTML = '<a href="' + element.src + '" target="_blank">' + element.src + '</a>';
	      }

	      return true;
	    }
	  }, {
	    key: "isTemporaryMessage",
	    value: function isTemporaryMessage(element) {
	      return element.id && (im_lib_utils.Utils.types.isUuidV4(element.id) || element.id.toString().startsWith('temporary'));
	    }
	  }, {
	    key: "getPayloadWithTempMessages",
	    value: function getPayloadWithTempMessages(state, payload) {
	      var payloadData = babelHelpers.toConsumableArray(payload.data);

	      if (!im_lib_utils.Utils.platform.isBitrixMobile()) {
	        return payloadData;
	      }

	      if (!payload.data || payload.data.length <= 0) {
	        return payloadData;
	      } // consider that in the payload we have messages only for one chat, so we get the value from the first message.


	      var payloadChatId = payload.data[0].chatId;

	      if (!state.collection[payloadChatId]) {
	        return payloadData;
	      }

	      state.collection[payloadChatId].forEach(function (message) {
	        if (MessagesModel.isTemporaryMessage(message) && !MessagesModel.existsInPayload(payload, message.templateId) && MessagesModel.doesTaskExist(message)) {
	          payloadData.push(message);
	        }
	      });
	      return payloadData;
	    }
	  }, {
	    key: "existsInPayload",
	    value: function existsInPayload(payload, templateId) {
	      return payload.data.find(function (payloadMessage) {
	        return payloadMessage.templateId === templateId;
	      });
	    }
	  }, {
	    key: "doesTaskExist",
	    value: function doesTaskExist(message) {
	      if (Array.isArray(message.params.FILE_ID)) {
	        var foundUploadTasks = false;
	        message.params.FILE_ID.forEach(function (fileId) {
	          if (!foundUploadTasks) {
	            foundUploadTasks = window.imDialogUploadTasks.find(function (task) {
	              return task.taskId.split('|')[1] === fileId;
	            });
	          }
	        });
	        return !!foundUploadTasks;
	      }

	      if (message.templateId) {
	        var foundMessageTask = window.imDialogMessagesTasks.find(function (task) {
	          return task.taskId.split('|')[1] === message.templateId;
	        });
	        return !!foundMessageTask;
	      }

	      return false;
	    }
	  }]);
	  return MessagesModel;
	}(ui_vue_vuex.WidgetVuexBuilderModel);

	function _createForOfIteratorHelper$1(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$1(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

	function _unsupportedIterableToArray$1(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$1(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$1(o, minLen); }

	function _arrayLikeToArray$1(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
	var DialoguesModel = /*#__PURE__*/function (_VuexBuilderModel) {
	  babelHelpers.inherits(DialoguesModel, _VuexBuilderModel);

	  function DialoguesModel() {
	    babelHelpers.classCallCheck(this, DialoguesModel);
	    return babelHelpers.possibleConstructorReturn(this, babelHelpers.getPrototypeOf(DialoguesModel).apply(this, arguments));
	  }

	  babelHelpers.createClass(DialoguesModel, [{
	    key: "getName",
	    value: function getName() {
	      return 'dialogues';
	    }
	  }, {
	    key: "getState",
	    value: function getState() {
	      return {
	        host: this.getVariable('host', location.protocol + '//' + location.host),
	        collection: {},
	        saveDialogList: [],
	        saveChatList: []
	      };
	    }
	  }, {
	    key: "getStateSaveException",
	    value: function getStateSaveException() {
	      return {
	        host: null
	      };
	    }
	  }, {
	    key: "getElementStateSaveException",
	    value: function getElementStateSaveException() {
	      return {
	        writingList: null,
	        quoteId: null
	      };
	    }
	  }, {
	    key: "getElementState",
	    value: function getElementState() {
	      return {
	        dialogId: '0',
	        chatId: 0,
	        counter: 0,
	        userCounter: 0,
	        messageCount: 0,
	        unreadId: 0,
	        lastMessageId: 0,
	        managerList: [],
	        readedList: [],
	        writingList: [],
	        muteList: [],
	        textareaMessage: "",
	        quoteId: 0,
	        editId: 0,
	        init: false,
	        name: "",
	        owner: 0,
	        extranet: false,
	        avatar: "",
	        color: "#17A3EA",
	        type: "chat",
	        entityType: "",
	        entityId: "",
	        entityData1: "",
	        entityData2: "",
	        entityData3: "",
	        dateCreate: new Date(),
	        restrictions: {
	          avatar: true,
	          extend: true,
	          leave: true,
	          leaveOwner: true,
	          rename: true,
	          send: true,
	          userList: true,
	          mute: true,
	          call: true
	        },
	        "public": {
	          code: '',
	          link: ''
	        }
	      };
	    }
	  }, {
	    key: "getGetters",
	    value: function getGetters() {
	      var _this = this;

	      return {
	        get: function get(state) {
	          return function (dialogId) {
	            if (!state.collection[dialogId]) {
	              return null;
	            }

	            return state.collection[dialogId];
	          };
	        },
	        getByChatId: function getByChatId(state) {
	          return function (chatId) {
	            chatId = parseInt(chatId);

	            for (var dialogId in state.collection) {
	              if (!state.collection.hasOwnProperty(dialogId)) {
	                continue;
	              }

	              if (state.collection[dialogId].chatId === chatId) {
	                return state.collection[dialogId];
	              }
	            }

	            return null;
	          };
	        },
	        getBlank: function getBlank(state) {
	          return function (params) {
	            return _this.getElementState();
	          };
	        },
	        getQuoteId: function getQuoteId(state) {
	          return function (dialogId) {
	            if (!state.collection[dialogId]) {
	              return 0;
	            }

	            return state.collection[dialogId].quoteId;
	          };
	        },
	        getEditId: function getEditId(state) {
	          return function (dialogId) {
	            if (!state.collection[dialogId]) {
	              return 0;
	            }

	            return state.collection[dialogId].editId;
	          };
	        },
	        canSaveChat: function canSaveChat(state) {
	          return function (chatId) {
	            if (/^\d+$/.test(chatId)) {
	              chatId = parseInt(chatId);
	            }

	            return state.saveChatList.includes(parseInt(chatId));
	          };
	        },
	        canSaveDialog: function canSaveDialog(state) {
	          return function (dialogId) {
	            return state.saveDialogList.includes(dialogId.toString());
	          };
	        },
	        isPrivateDialog: function isPrivateDialog(state) {
	          return function (dialogId) {
	            dialogId = dialogId.toString();
	            return state.collection[dialogId.toString()] && state.collection[dialogId].type === 'private';
	          };
	        }
	      };
	    }
	  }, {
	    key: "getActions",
	    value: function getActions() {
	      var _this2 = this;

	      return {
	        set: function set(store, payload) {
	          if (payload instanceof Array) {
	            payload = payload.map(function (dialog) {
	              return Object.assign({}, _this2.validate(Object.assign({}, dialog), {
	                host: store.state.host
	              }), {
	                init: true
	              });
	            });
	          } else {
	            var result = [];
	            result.push(Object.assign({}, _this2.validate(Object.assign({}, payload), {
	              host: store.state.host
	            }), {
	              init: true
	            }));
	            payload = result;
	          }

	          store.commit('set', payload);
	        },
	        update: function update(store, payload) {
	          if (typeof store.state.collection[payload.dialogId] === 'undefined' || store.state.collection[payload.dialogId].init === false) {
	            return true;
	          }

	          store.commit('update', {
	            dialogId: payload.dialogId,
	            fields: _this2.validate(Object.assign({}, payload.fields), {
	              host: store.state.host
	            })
	          });
	          return true;
	        },
	        "delete": function _delete(store, payload) {
	          store.commit('delete', payload.dialogId);
	          return true;
	        },
	        updateWriting: function updateWriting(store, payload) {
	          if (typeof store.state.collection[payload.dialogId] === 'undefined' || store.state.collection[payload.dialogId].init === false) {
	            return true;
	          }

	          var index = store.state.collection[payload.dialogId].writingList.findIndex(function (el) {
	            return el.userId === payload.userId;
	          });

	          if (payload.action) {
	            if (index >= 0) {
	              return true;
	            } else {
	              var writingList = [].concat(store.state.collection[payload.dialogId].writingList);
	              writingList.unshift({
	                userId: payload.userId,
	                userName: payload.userName
	              });
	              store.commit('update', {
	                actionName: 'updateWriting/1',
	                dialogId: payload.dialogId,
	                fields: _this2.validate({
	                  writingList: writingList
	                }, {
	                  host: store.state.host
	                })
	              });
	            }
	          } else {
	            if (index >= 0) {
	              var _writingList = store.state.collection[payload.dialogId].writingList.filter(function (el) {
	                return el.userId !== payload.userId;
	              });

	              store.commit('update', {
	                actionName: 'updateWriting/2',
	                dialogId: payload.dialogId,
	                fields: _this2.validate({
	                  writingList: _writingList
	                }, {
	                  host: store.state.host
	                })
	              });
	              return true;
	            } else {
	              return true;
	            }
	          }

	          return false;
	        },
	        updateReaded: function updateReaded(store, payload) {
	          if (typeof store.state.collection[payload.dialogId] === 'undefined' || store.state.collection[payload.dialogId].init === false) {
	            return true;
	          }

	          var readedList = store.state.collection[payload.dialogId].readedList.filter(function (el) {
	            return el.userId !== payload.userId;
	          });

	          if (payload.action) {
	            readedList.push({
	              userId: payload.userId,
	              userName: payload.userName || '',
	              messageId: payload.messageId,
	              date: payload.date || new Date()
	            });
	          }

	          store.commit('update', {
	            actionName: 'updateReaded',
	            dialogId: payload.dialogId,
	            fields: _this2.validate({
	              readedList: readedList
	            }, {
	              host: store.state.host
	            })
	          });
	          return false;
	        },
	        increaseCounter: function increaseCounter(store, payload) {
	          var _store$rootState$appl;

	          if (typeof store.state.collection[payload.dialogId] === 'undefined' || store.state.collection[payload.dialogId].init === false) {
	            return true;
	          }

	          var counter = store.state.collection[payload.dialogId].counter;

	          if (counter === 100) {
	            return true;
	          }

	          var increasedCounter = counter + payload.count;

	          if (increasedCounter > 100) {
	            increasedCounter = 100;
	          }

	          var userId = (_store$rootState$appl = store.rootState.application) === null || _store$rootState$appl === void 0 ? void 0 : _store$rootState$appl.common.userId;
	          var dialogMuted = userId && store.state.collection[payload.dialogId].muteList.includes(userId);
	          store.commit('update', {
	            actionName: 'increaseCounter',
	            dialogId: payload.dialogId,
	            dialogMuted: dialogMuted,
	            fields: {
	              counter: increasedCounter,
	              previousCounter: counter
	            }
	          });
	          return false;
	        },
	        decreaseCounter: function decreaseCounter(store, payload) {
	          if (typeof store.state.collection[payload.dialogId] === 'undefined' || store.state.collection[payload.dialogId].init === false) {
	            return true;
	          }

	          var counter = store.state.collection[payload.dialogId].counter;

	          if (counter === 100) {
	            return true;
	          }

	          var decreasedCounter = counter - payload.count;

	          if (decreasedCounter < 0) {
	            decreasedCounter = 0;
	          }

	          var unreadId = payload.unreadId > store.state.collection[payload.dialogId].unreadId ? payload.unreadId : store.state.collection[payload.dialogId].unreadId;

	          if (store.state.collection[payload.dialogId].unreadId !== unreadId || store.state.collection[payload.dialogId].counter !== decreasedCounter) {
	            var _store$rootState$appl2;

	            var previousCounter = store.state.collection[payload.dialogId].counter;

	            if (decreasedCounter === 0) {
	              unreadId = 0;
	            }

	            var userId = (_store$rootState$appl2 = store.rootState.application) === null || _store$rootState$appl2 === void 0 ? void 0 : _store$rootState$appl2.common.userId;
	            var dialogMuted = userId && store.state.collection[payload.dialogId].muteList.includes(userId);
	            store.commit('update', {
	              actionName: 'decreaseCounter',
	              dialogId: payload.dialogId,
	              dialogMuted: dialogMuted,
	              fields: {
	                counter: decreasedCounter,
	                previousCounter: previousCounter,
	                unreadId: unreadId
	              }
	            });
	          }

	          return false;
	        },
	        increaseMessageCounter: function increaseMessageCounter(store, payload) {
	          if (typeof store.state.collection[payload.dialogId] === 'undefined' || store.state.collection[payload.dialogId].init === false) {
	            return true;
	          }

	          var currentCounter = store.state.collection[payload.dialogId].messageCount;
	          store.commit('update', {
	            actionName: 'increaseMessageCount',
	            dialogId: payload.dialogId,
	            fields: {
	              messageCount: currentCounter + payload.count
	            }
	          });
	        },
	        saveDialog: function saveDialog(store, payload) {
	          if (typeof store.state.collection[payload.dialogId] === 'undefined' || store.state.collection[payload.dialogId].init === false) {
	            return true;
	          }

	          store.commit('saveDialog', {
	            dialogId: payload.dialogId,
	            chatId: payload.chatId
	          });
	          return false;
	        }
	      };
	    }
	  }, {
	    key: "getMutations",
	    value: function getMutations() {
	      var _this3 = this;

	      return {
	        initCollection: function initCollection(state, payload) {
	          _this3.initCollection(state, payload);
	        },
	        saveDialog: function saveDialog(state, payload) {
	          // TODO if payload.dialogId is IMOL, skip update this flag
	          if (!(payload.chatId > 0 && payload.dialogId.length > 0)) {
	            return false;
	          }

	          var saveDialogList = state.saveDialogList.filter(function (element) {
	            return element !== payload.dialogId;
	          });
	          saveDialogList.unshift(payload.dialogId);
	          saveDialogList = saveDialogList.slice(0, im_const.StorageLimit.dialogues);

	          if (state.saveDialogList.join(',') === saveDialogList.join(',')) {
	            return true;
	          }

	          state.saveDialogList = saveDialogList;
	          var saveChatList = state.saveChatList.filter(function (element) {
	            return element !== payload.chatId;
	          });
	          saveChatList.unshift(payload.chatId);
	          state.saveChatList = saveChatList.slice(0, im_const.StorageLimit.dialogues);

	          _this3.saveState(state);
	        },
	        set: function set(state, payload) {
	          var _iterator = _createForOfIteratorHelper$1(payload),
	              _step;

	          try {
	            for (_iterator.s(); !(_step = _iterator.n()).done;) {
	              var element = _step.value;

	              _this3.initCollection(state, {
	                dialogId: element.dialogId
	              });

	              state.collection[element.dialogId] = Object.assign(_this3.getElementState(), state.collection[element.dialogId], element);
	            } // TODO if payload.dialogId is IMOL, skip update cache

	          } catch (err) {
	            _iterator.e(err);
	          } finally {
	            _iterator.f();
	          }

	          _this3.saveState(state);
	        },
	        update: function update(state, payload) {
	          _this3.initCollection(state, payload);

	          state.collection[payload.dialogId] = Object.assign(state.collection[payload.dialogId], payload.fields); // TODO if payload.dialogId is IMOL, skip update cache

	          _this3.saveState(state);
	        },
	        "delete": function _delete(state, payload) {
	          delete state.collection[payload.dialogId]; // TODO if payload.dialogId is IMOL, skip update cache

	          _this3.saveState(state);
	        }
	      };
	    }
	  }, {
	    key: "initCollection",
	    value: function initCollection(state, payload) {
	      if (typeof state.collection[payload.dialogId] !== 'undefined') {
	        return true;
	      }

	      ui_vue.WidgetVue.set(state.collection, payload.dialogId, this.getElementState());

	      if (payload.fields) {
	        state.collection[payload.dialogId] = Object.assign(state.collection[payload.dialogId], this.validate(Object.assign({}, payload.fields), {
	          host: state.host
	        }));
	      }

	      return true;
	    }
	  }, {
	    key: "getSaveTimeout",
	    value: function getSaveTimeout() {
	      return 100;
	    }
	  }, {
	    key: "saveState",
	    value: function saveState() {
	      var _this4 = this;

	      var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	      if (!this.isSaveAvailable()) {
	        return true;
	      }

	      babelHelpers.get(babelHelpers.getPrototypeOf(DialoguesModel.prototype), "saveState", this).call(this, function () {
	        var storedState = {
	          collection: {},
	          saveDialogList: [].concat(state.saveDialogList),
	          saveChatList: [].concat(state.saveChatList)
	        };
	        state.saveDialogList.forEach(function (dialogId) {
	          if (!state.collection[dialogId]) return false;
	          storedState.collection[dialogId] = Object.assign(_this4.getElementState(), _this4.cloneState(state.collection[dialogId], _this4.getElementStateSaveException()));
	        });
	        return storedState;
	      });
	    }
	  }, {
	    key: "validate",
	    value: function validate(fields) {
	      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	      var result = {};
	      options.host = options.host || this.getState().host;

	      if (typeof fields.dialog_id !== 'undefined') {
	        fields.dialogId = fields.dialog_id;
	      }

	      if (typeof fields.dialogId === "number" || typeof fields.dialogId === "string") {
	        result.dialogId = fields.dialogId.toString();
	      }

	      if (typeof fields.chat_id !== 'undefined') {
	        fields.chatId = fields.chat_id;
	      } else if (typeof fields.id !== 'undefined') {
	        fields.chatId = fields.id;
	      }

	      if (typeof fields.chatId === "number" || typeof fields.chatId === "string") {
	        result.chatId = parseInt(fields.chatId);
	      }

	      if (typeof fields.quoteId === "number") {
	        result.quoteId = parseInt(fields.quoteId);
	      }

	      if (typeof fields.editId === "number") {
	        result.editId = parseInt(fields.editId);
	      }

	      if (typeof fields.counter === "number" || typeof fields.counter === "string") {
	        result.counter = parseInt(fields.counter);
	      }

	      if (typeof fields.user_counter === "number" || typeof fields.user_counter === "string") {
	        result.userCounter = parseInt(fields.user_counter);
	      }

	      if (typeof fields.userCounter === "number" || typeof fields.userCounter === "string") {
	        result.userCounter = parseInt(fields.userCounter);
	      }

	      if (typeof fields.message_count === "number" || typeof fields.message_count === "string") {
	        result.messageCount = parseInt(fields.message_count);
	      }

	      if (typeof fields.messageCount === "number" || typeof fields.messageCount === "string") {
	        result.messageCount = parseInt(fields.messageCount);
	      }

	      if (typeof fields.unread_id !== 'undefined') {
	        fields.unreadId = fields.unread_id;
	      }

	      if (typeof fields.unreadId === "number" || typeof fields.unreadId === "string") {
	        result.unreadId = parseInt(fields.unreadId);
	      }

	      if (typeof fields.last_message_id !== 'undefined') {
	        fields.lastMessageId = fields.last_message_id;
	      }

	      if (typeof fields.lastMessageId === "number" || typeof fields.lastMessageId === "string") {
	        result.lastMessageId = parseInt(fields.lastMessageId);
	      }

	      if (typeof fields.readed_list !== 'undefined') {
	        fields.readedList = fields.readed_list;
	      }

	      if (typeof fields.readedList !== 'undefined') {
	        result.readedList = [];

	        if (fields.readedList instanceof Array) {
	          fields.readedList.forEach(function (element) {
	            var record = {};

	            if (typeof element.user_id !== 'undefined') {
	              element.userId = element.user_id;
	            }

	            if (typeof element.user_name !== 'undefined') {
	              element.userName = element.user_name;
	            }

	            if (typeof element.message_id !== 'undefined') {
	              element.messageId = element.message_id;
	            }

	            if (!element.userId || !element.userName || !element.messageId) {
	              return false;
	            }

	            record.userId = parseInt(element.userId);
	            record.userName = element.userName.toString();
	            record.messageId = parseInt(element.messageId);
	            record.date = im_lib_utils.Utils.date.cast(element.date);
	            result.readedList.push(record);
	          });
	        }
	      }

	      if (typeof fields.writing_list !== 'undefined') {
	        fields.writingList = fields.writing_list;
	      }

	      if (typeof fields.writingList !== 'undefined') {
	        result.writingList = [];

	        if (fields.writingList instanceof Array) {
	          fields.writingList.forEach(function (element) {
	            var record = {};

	            if (!element.userId) {
	              return false;
	            }

	            record.userId = parseInt(element.userId);
	            record.userName = im_lib_utils.Utils.text.htmlspecialcharsback(element.userName);
	            result.writingList.push(record);
	          });
	        }
	      }

	      if (typeof fields.manager_list !== 'undefined') {
	        fields.managerList = fields.manager_list;
	      }

	      if (typeof fields.managerList !== 'undefined') {
	        result.managerList = [];

	        if (fields.managerList instanceof Array) {
	          fields.managerList.forEach(function (userId) {
	            userId = parseInt(userId);

	            if (userId > 0) {
	              result.managerList.push(userId);
	            }
	          });
	        }
	      }

	      if (typeof fields.mute_list !== 'undefined') {
	        fields.muteList = fields.mute_list;
	      }

	      if (typeof fields.muteList !== 'undefined') {
	        result.muteList = [];

	        if (fields.muteList instanceof Array) {
	          fields.muteList.forEach(function (userId) {
	            userId = parseInt(userId);

	            if (userId > 0) {
	              result.muteList.push(userId);
	            }
	          });
	        } else if (babelHelpers["typeof"](fields.muteList) === 'object') {
	          Object.entries(fields.muteList).forEach(function (entry) {
	            if (entry[1] === true) {
	              var userId = parseInt(entry[0]);

	              if (userId > 0) {
	                result.muteList.push(userId);
	              }
	            }
	          });
	        }
	      }

	      if (typeof fields.textareaMessage !== 'undefined') {
	        result.textareaMessage = fields.textareaMessage.toString();
	      }

	      if (typeof fields.title !== 'undefined') {
	        fields.name = fields.title;
	      }

	      if (typeof fields.name === "string" || typeof fields.name === "number") {
	        result.name = im_lib_utils.Utils.text.htmlspecialcharsback(fields.name.toString());
	      }

	      if (typeof fields.owner !== 'undefined') {
	        fields.ownerId = fields.owner;
	      }

	      if (typeof fields.ownerId === "number" || typeof fields.ownerId === "string") {
	        result.ownerId = parseInt(fields.ownerId);
	      }

	      if (typeof fields.extranet === "boolean") {
	        result.extranet = fields.extranet;
	      }

	      if (typeof fields.avatar === 'string') {
	        var avatar;

	        if (!fields.avatar || fields.avatar.endsWith('/js/im/images/blank.gif')) {
	          avatar = '';
	        } else if (fields.avatar.startsWith('http')) {
	          avatar = fields.avatar;
	        } else {
	          avatar = options.host + fields.avatar;
	        }

	        if (avatar) {
	          result.avatar = encodeURI(avatar);
	        }
	      }

	      if (typeof fields.color === "string") {
	        result.color = fields.color.toString();
	      }

	      if (typeof fields.type === "string") {
	        result.type = fields.type.toString();
	      }

	      if (typeof fields.entity_type !== 'undefined') {
	        fields.entityType = fields.entity_type;
	      }

	      if (typeof fields.entityType === "string") {
	        result.entityType = fields.entityType.toString();
	      }

	      if (typeof fields.entity_id !== 'undefined') {
	        fields.entityId = fields.entity_id;
	      }

	      if (typeof fields.entityId === "string" || typeof fields.entityId === "number") {
	        result.entityId = fields.entityId.toString();
	      }

	      if (typeof fields.entity_data_1 !== 'undefined') {
	        fields.entityData1 = fields.entity_data_1;
	      }

	      if (typeof fields.entityData1 === "string") {
	        result.entityData1 = fields.entityData1.toString();
	      }

	      if (typeof fields.entity_data_2 !== 'undefined') {
	        fields.entityData2 = fields.entity_data_2;
	      }

	      if (typeof fields.entityData2 === "string") {
	        result.entityData2 = fields.entityData2.toString();
	      }

	      if (typeof fields.entity_data_3 !== 'undefined') {
	        fields.entityData3 = fields.entity_data_3;
	      }

	      if (typeof fields.entityData3 === "string") {
	        result.entityData3 = fields.entityData3.toString();
	      }

	      if (typeof fields.date_create !== 'undefined') {
	        fields.dateCreate = fields.date_create;
	      }

	      if (typeof fields.dateCreate !== "undefined") {
	        result.dateCreate = im_lib_utils.Utils.date.cast(fields.dateCreate);
	      }

	      if (typeof fields.dateLastOpen !== "undefined") {
	        result.dateLastOpen = im_lib_utils.Utils.date.cast(fields.dateLastOpen);
	      }

	      if (babelHelpers["typeof"](fields.restrictions) === 'object' && fields.restrictions) {
	        result.restrictions = {};

	        if (typeof fields.restrictions.avatar === 'boolean') {
	          result.restrictions.avatar = fields.restrictions.avatar;
	        }

	        if (typeof fields.restrictions.extend === 'boolean') {
	          result.restrictions.extend = fields.restrictions.extend;
	        }

	        if (typeof fields.restrictions.leave === 'boolean') {
	          result.restrictions.leave = fields.restrictions.leave;
	        }

	        if (typeof fields.restrictions.leave_owner === 'boolean') {
	          result.restrictions.leaveOwner = fields.restrictions.leave_owner;
	        }

	        if (typeof fields.restrictions.rename === 'boolean') {
	          result.restrictions.rename = fields.restrictions.rename;
	        }

	        if (typeof fields.restrictions.send === 'boolean') {
	          result.restrictions.send = fields.restrictions.send;
	        }

	        if (typeof fields.restrictions.user_list === 'boolean') {
	          result.restrictions.userList = fields.restrictions.user_list;
	        }

	        if (typeof fields.restrictions.mute === 'boolean') {
	          result.restrictions.mute = fields.restrictions.mute;
	        }

	        if (typeof fields.restrictions.call === 'boolean') {
	          result.restrictions.call = fields.restrictions.call;
	        }
	      }

	      if (babelHelpers["typeof"](fields["public"]) === 'object' && fields["public"]) {
	        result["public"] = {};

	        if (typeof fields["public"].code === 'string') {
	          result["public"].code = fields["public"].code;
	        }

	        if (typeof fields["public"].link === 'string') {
	          result["public"].link = fields["public"].link;
	        }
	      }

	      return result;
	    }
	  }]);
	  return DialoguesModel;
	}(ui_vue_vuex.WidgetVuexBuilderModel);

	function _createForOfIteratorHelper$2(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$2(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

	function _unsupportedIterableToArray$2(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$2(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$2(o, minLen); }

	function _arrayLikeToArray$2(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
	var UsersModel = /*#__PURE__*/function (_VuexBuilderModel) {
	  babelHelpers.inherits(UsersModel, _VuexBuilderModel);

	  function UsersModel() {
	    babelHelpers.classCallCheck(this, UsersModel);
	    return babelHelpers.possibleConstructorReturn(this, babelHelpers.getPrototypeOf(UsersModel).apply(this, arguments));
	  }

	  babelHelpers.createClass(UsersModel, [{
	    key: "getName",
	    value: function getName() {
	      return 'users';
	    }
	  }, {
	    key: "getState",
	    value: function getState() {
	      this.startOnlineCheckInterval();
	      return {
	        host: this.getVariable('host', location.protocol + '//' + location.host),
	        collection: {},
	        onlineList: [],
	        mobileOnlineList: [],
	        absentList: []
	      };
	    }
	  }, {
	    key: "getElementState",
	    value: function getElementState() {
	      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	      var _params$id = params.id,
	          id = _params$id === void 0 ? 0 : _params$id,
	          _params$name = params.name,
	          name = _params$name === void 0 ? this.getVariable('default.name', '') : _params$name,
	          _params$firstName = params.firstName,
	          firstName = _params$firstName === void 0 ? this.getVariable('default.name', '') : _params$firstName,
	          _params$lastName = params.lastName,
	          lastName = _params$lastName === void 0 ? '' : _params$lastName;
	      return {
	        id: id,
	        name: name,
	        firstName: firstName,
	        lastName: lastName,
	        workPosition: "",
	        color: "#048bd0",
	        avatar: "",
	        gender: "M",
	        birthday: false,
	        isBirthday: false,
	        extranet: false,
	        network: false,
	        bot: false,
	        connector: false,
	        externalAuthId: "default",
	        status: "online",
	        idle: false,
	        lastActivityDate: false,
	        mobileLastDate: false,
	        isOnline: false,
	        isMobileOnline: false,
	        absent: false,
	        isAbsent: false,
	        departments: [],
	        phones: {
	          workPhone: "",
	          personalMobile: "",
	          personalPhone: "",
	          innerPhone: ""
	        },
	        init: false
	      };
	    }
	  }, {
	    key: "getGetters",
	    value: function getGetters() {
	      var _this = this;

	      return {
	        get: function get(state) {
	          return function (userId) {
	            var getTemporary = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
	            userId = parseInt(userId);

	            if (userId <= 0) {
	              if (getTemporary) {
	                userId = 0;
	              } else {
	                return null;
	              }
	            }

	            if (!getTemporary && (!state.collection[userId] || !state.collection[userId].init)) {
	              return null;
	            }

	            if (!state.collection[userId]) {
	              return _this.getElementState({
	                id: userId
	              });
	            }

	            return state.collection[userId];
	          };
	        },
	        getBlank: function getBlank(state) {
	          return function (params) {
	            return _this.getElementState(params);
	          };
	        },
	        getList: function getList(state) {
	          return function (userList) {
	            var result = [];

	            if (!Array.isArray(userList)) {
	              return null;
	            }

	            userList.forEach(function (id) {
	              if (state.collection[id]) {
	                result.push(state.collection[id]);
	              } else {
	                result.push(_this.getElementState({
	                  id: id
	                }));
	              }
	            });
	            return result;
	          };
	        }
	      };
	    }
	  }, {
	    key: "getActions",
	    value: function getActions() {
	      var _this2 = this;

	      return {
	        set: function set(store, payload) {
	          if (payload instanceof Array) {
	            payload = payload.map(function (user) {
	              return Object.assign({}, _this2.getElementState(), _this2.validate(Object.assign({}, user), {
	                host: store.state.host
	              }), {
	                init: true
	              });
	            });
	          } else {
	            var result = [];
	            result.push(Object.assign({}, _this2.getElementState(), _this2.validate(Object.assign({}, payload), {
	              host: store.state.host
	            }), {
	              init: true
	            }));
	            payload = result;
	          }

	          store.commit('set', payload);
	        },
	        update: function update(store, payload) {
	          payload.id = parseInt(payload.id);

	          if (typeof store.state.collection[payload.id] === 'undefined' || store.state.collection[payload.id].init === false) {
	            return true;
	          }

	          store.commit('update', {
	            id: payload.id,
	            fields: _this2.validate(Object.assign({}, payload.fields), {
	              host: store.state.host
	            })
	          });
	          return true;
	        },
	        "delete": function _delete(store, payload) {
	          store.commit('delete', payload.id);
	          return true;
	        },
	        saveState: function saveState(store, payload) {
	          store.commit('saveState', {});
	          return true;
	        }
	      };
	    }
	  }, {
	    key: "getMutations",
	    value: function getMutations() {
	      var _this3 = this;

	      return {
	        set: function set(state, payload) {
	          var _iterator = _createForOfIteratorHelper$2(payload),
	              _step;

	          try {
	            var _loop = function _loop() {
	              var element = _step.value;

	              _this3.initCollection(state, {
	                id: element.id
	              });

	              state.collection[element.id] = Object.assign(state.collection[element.id], element);
	              var status = im_lib_utils.Utils.user.getOnlineStatus(element);

	              if (status.isOnline) {
	                state.collection[element.id].isOnline = true;

	                _this3.addToOnlineList(state, element.id);
	              }

	              var mobileStatus = im_lib_utils.Utils.user.isMobileActive(element);

	              if (mobileStatus) {
	                state.collection[element.id].isMobileOnline = true;

	                _this3.addToMobileOnlineList(state, element.id);
	              }

	              if (element.birthday) {
	                var today = im_lib_utils.Utils.date.format(new Date(), "d-m");

	                if (element.birthday === today) {
	                  state.collection[element.id].isBirthday = true;

	                  var timeToNextMidnight = _this3.getTimeToNextMidnight();

	                  setTimeout(function () {
	                    state.collection[element.id].isBirthday = false;
	                  }, timeToNextMidnight);
	                }
	              }

	              if (element.absent) {
	                element.isAbsent = true;

	                if (!state.absentList.includes(element.id)) {
	                  _this3.addToAbsentList(state, element.id);

	                  var _timeToNextMidnight = _this3.getTimeToNextMidnight();

	                  var timeToNextDay = 1000 * 60 * 60 * 24;
	                  setTimeout(function () {
	                    setInterval(function () {
	                      return _this3.startAbsentCheckInterval(state);
	                    }, timeToNextDay);
	                  }, _timeToNextMidnight);
	                }
	              }

	              _this3.saveState(state);
	            };

	            for (_iterator.s(); !(_step = _iterator.n()).done;) {
	              _loop();
	            }
	          } catch (err) {
	            _iterator.e(err);
	          } finally {
	            _iterator.f();
	          }
	        },
	        update: function update(state, payload) {
	          _this3.initCollection(state, payload);

	          if (typeof payload.fields.lastActivityDate !== 'undefined' && state.collection[payload.id].lastActivityDate) {
	            var lastActivityDate = state.collection[payload.id].lastActivityDate.getTime();
	            var newActivityDate = payload.fields.lastActivityDate.getTime();

	            if (newActivityDate > lastActivityDate) {
	              var status = im_lib_utils.Utils.user.getOnlineStatus(payload.fields);

	              if (status.isOnline) {
	                state.collection[payload.id].isOnline = true;

	                _this3.addToOnlineList(state, payload.fields.id);
	              }
	            }
	          }

	          if (typeof payload.fields.mobileLastDate !== 'undefined' && state.collection[payload.id].mobileLastDate !== payload.fields.mobileLastDate) {
	            var mobileStatus = im_lib_utils.Utils.user.isMobileActive(payload.fields);

	            if (mobileStatus) {
	              state.collection[payload.id].isMobileOnline = true;

	              _this3.addToMobileOnlineList(state, payload.fields.id);
	            }
	          }

	          state.collection[payload.id] = Object.assign(state.collection[payload.id], payload.fields);

	          _this3.saveState(state);
	        },
	        "delete": function _delete(state, payload) {
	          delete state.collection[payload.id];

	          _this3.saveState(state);
	        },
	        saveState: function saveState(state, payload) {
	          _this3.saveState(state);
	        }
	      };
	    }
	  }, {
	    key: "initCollection",
	    value: function initCollection(state, payload) {
	      if (typeof state.collection[payload.id] !== 'undefined') {
	        return true;
	      }

	      ui_vue.WidgetVue.set(state.collection, payload.id, this.getElementState());
	      return true;
	    }
	  }, {
	    key: "getSaveUserList",
	    value: function getSaveUserList() {
	      if (!this.db) {
	        return [];
	      }

	      if (!this.store.getters['messages/getSaveUserList']) {
	        return [];
	      }

	      var list = this.store.getters['messages/getSaveUserList']();

	      if (!list) {
	        return [];
	      }

	      return list;
	    }
	  }, {
	    key: "getSaveTimeout",
	    value: function getSaveTimeout() {
	      return 250;
	    }
	  }, {
	    key: "saveState",
	    value: function saveState(state) {
	      var _this4 = this;

	      if (!this.isSaveAvailable()) {
	        return false;
	      }

	      babelHelpers.get(babelHelpers.getPrototypeOf(UsersModel.prototype), "saveState", this).call(this, function () {
	        var list = _this4.getSaveUserList();

	        if (!list) {
	          return false;
	        }

	        var storedState = {
	          collection: {}
	        };
	        var exceptionList = {
	          absent: true,
	          idle: true,
	          mobileLastDate: true,
	          lastActivityDate: true
	        };

	        for (var chatId in list) {
	          if (!list.hasOwnProperty(chatId)) {
	            continue;
	          }

	          list[chatId].forEach(function (userId) {
	            if (!state.collection[userId]) {
	              return false;
	            }

	            storedState.collection[userId] = _this4.cloneState(state.collection[userId], exceptionList);
	          });
	        }

	        return storedState;
	      });
	    }
	  }, {
	    key: "validate",
	    value: function validate(fields) {
	      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	      var result = {};
	      options.host = options.host || this.getState().host;

	      if (typeof fields.id === "number" || typeof fields.id === "string") {
	        result.id = parseInt(fields.id);
	      }

	      if (typeof fields.first_name !== "undefined") {
	        fields.firstName = im_lib_utils.Utils.text.htmlspecialcharsback(fields.first_name);
	      }

	      if (typeof fields.last_name !== "undefined") {
	        fields.lastName = im_lib_utils.Utils.text.htmlspecialcharsback(fields.last_name);
	      }

	      if (typeof fields.name === "string" || typeof fields.name === "number") {
	        fields.name = im_lib_utils.Utils.text.htmlspecialcharsback(fields.name.toString());
	        result.name = fields.name;
	      }

	      if (typeof fields.firstName === "string" || typeof fields.firstName === "number") {
	        result.firstName = im_lib_utils.Utils.text.htmlspecialcharsback(fields.firstName.toString());
	      }

	      if (typeof fields.lastName === "string" || typeof fields.lastName === "number") {
	        result.lastName = im_lib_utils.Utils.text.htmlspecialcharsback(fields.lastName.toString());
	      }

	      if (typeof fields.work_position !== "undefined") {
	        fields.workPosition = fields.work_position;
	      }

	      if (typeof fields.workPosition === "string" || typeof fields.workPosition === "number") {
	        result.workPosition = fields.workPosition.toString();
	      }

	      if (typeof fields.color === "string") {
	        result.color = fields.color;
	      }

	      if (typeof fields.avatar === 'string') {
	        var avatar;

	        if (!fields.avatar || fields.avatar.endsWith('/js/im/images/blank.gif')) {
	          avatar = '';
	        } else if (fields.avatar.startsWith('http')) {
	          avatar = fields.avatar;
	        } else {
	          avatar = options.host + fields.avatar;
	        }

	        if (avatar) {
	          result.avatar = encodeURI(avatar);
	        }
	      }

	      if (typeof fields.gender !== 'undefined') {
	        result.gender = fields.gender === 'F' ? 'F' : 'M';
	      }

	      if (typeof fields.birthday === "string") {
	        result.birthday = fields.birthday;
	      }

	      if (typeof fields.extranet === "boolean") {
	        result.extranet = fields.extranet;
	      }

	      if (typeof fields.network === "boolean") {
	        result.network = fields.network;
	      }

	      if (typeof fields.bot === "boolean") {
	        result.bot = fields.bot;
	      }

	      if (typeof fields.connector === "boolean") {
	        result.connector = fields.connector;
	      }

	      if (typeof fields.external_auth_id !== "undefined") {
	        fields.externalAuthId = fields.external_auth_id;
	      }

	      if (typeof fields.externalAuthId === "string" && fields.externalAuthId) {
	        result.externalAuthId = fields.externalAuthId;
	      }

	      if (typeof fields.status === "string") {
	        result.status = fields.status;
	      }

	      if (typeof fields.idle !== "undefined") {
	        result.idle = im_lib_utils.Utils.date.cast(fields.idle, false);
	      }

	      if (typeof fields.last_activity_date !== "undefined") {
	        fields.lastActivityDate = fields.last_activity_date;
	      }

	      if (typeof fields.lastActivityDate !== "undefined") {
	        result.lastActivityDate = im_lib_utils.Utils.date.cast(fields.lastActivityDate, false);
	      }

	      if (typeof fields.mobile_last_date !== "undefined") {
	        fields.mobileLastDate = fields.mobile_last_date;
	      }

	      if (typeof fields.mobileLastDate !== "undefined") {
	        result.mobileLastDate = im_lib_utils.Utils.date.cast(fields.mobileLastDate, false);
	      }

	      if (typeof fields.absent !== "undefined") {
	        result.absent = im_lib_utils.Utils.date.cast(fields.absent, false);
	      }

	      if (typeof fields.departments !== 'undefined') {
	        result.departments = [];

	        if (fields.departments instanceof Array) {
	          fields.departments.forEach(function (departmentId) {
	            departmentId = parseInt(departmentId);

	            if (departmentId > 0) {
	              result.departments.push(departmentId);
	            }
	          });
	        }
	      }

	      if (babelHelpers["typeof"](fields.phones) === 'object' && fields.phones) {
	        result.phones = {};

	        if (typeof fields.phones.work_phone !== "undefined") {
	          fields.phones.workPhone = fields.phones.work_phone;
	        }

	        if (typeof fields.phones.workPhone === 'string' || typeof fields.phones.workPhone === 'number') {
	          result.phones.workPhone = fields.phones.workPhone.toString();
	        }

	        if (typeof fields.phones.personal_mobile !== "undefined") {
	          fields.phones.personalMobile = fields.phones.personal_mobile;
	        }

	        if (typeof fields.phones.personalMobile === 'string' || typeof fields.phones.personalMobile === 'number') {
	          result.phones.personalMobile = fields.phones.personalMobile.toString();
	        }

	        if (typeof fields.phones.personal_phone !== "undefined") {
	          fields.phones.personalPhone = fields.phones.personal_phone;
	        }

	        if (typeof fields.phones.personalPhone === 'string' || typeof fields.phones.personalPhone === 'number') {
	          result.phones.personalPhone = fields.phones.personalPhone.toString();
	        }

	        if (typeof fields.phones.inner_phone !== "undefined") {
	          fields.phones.innerPhone = fields.phones.inner_phone;
	        }

	        if (typeof fields.phones.innerPhone === 'string' || typeof fields.phones.innerPhone === 'number') {
	          result.phones.innerPhone = fields.phones.innerPhone.toString();
	        }
	      }

	      return result;
	    }
	  }, {
	    key: "addToOnlineList",
	    value: function addToOnlineList(state, id) {
	      if (!state.onlineList.includes(id)) {
	        state.onlineList.push(id);
	      }
	    }
	  }, {
	    key: "addToMobileOnlineList",
	    value: function addToMobileOnlineList(state, id) {
	      if (!state.mobileOnlineList.includes(id)) {
	        state.mobileOnlineList.push(id);
	      }
	    }
	  }, {
	    key: "addToAbsentList",
	    value: function addToAbsentList(state, id) {
	      if (!state.absentList.includes(id)) {
	        state.absentList.push(id);
	      }
	    }
	  }, {
	    key: "getTimeToNextMidnight",
	    value: function getTimeToNextMidnight() {
	      var nextMidnight = new Date(new Date().setHours(24, 0, 0)).getTime();
	      return nextMidnight - new Date();
	    }
	  }, {
	    key: "startAbsentCheckInterval",
	    value: function startAbsentCheckInterval(state) {
	      var _iterator2 = _createForOfIteratorHelper$2(state.absentList),
	          _step2;

	      try {
	        var _loop2 = function _loop2() {
	          var userId = _step2.value;
	          var user = state.collection[userId];

	          if (!user) {
	            return "continue";
	          }

	          var currentTime = new Date().getTime();
	          var absentEnd = new Date(state.collection[userId].absent).getTime();

	          if (absentEnd <= currentTime) {
	            state.absentList = state.absentList.filter(function (element) {
	              return element !== userId;
	            });
	            user.isAbsent = false;
	          }
	        };

	        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
	          var _ret = _loop2();

	          if (_ret === "continue") continue;
	        }
	      } catch (err) {
	        _iterator2.e(err);
	      } finally {
	        _iterator2.f();
	      }
	    }
	  }, {
	    key: "startOnlineCheckInterval",
	    value: function startOnlineCheckInterval() {
	      var _this5 = this;

	      var intervalTime = 60000;
	      setInterval(function () {
	        var _iterator3 = _createForOfIteratorHelper$2(_this5.store.state.users.onlineList),
	            _step3;

	        try {
	          var _loop3 = function _loop3() {
	            var userId = _step3.value;
	            var user = _this5.store.state.users.collection[userId];

	            if (!user) {
	              return "continue";
	            }

	            var status = im_lib_utils.Utils.user.getOnlineStatus(user);

	            if (status.isOnline) {
	              user.isOnline = true;
	            } else {
	              user.isOnline = false;
	              _this5.store.state.users.onlineList = _this5.store.state.users.onlineList.filter(function (element) {
	                return element !== userId;
	              });
	            }
	          };

	          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
	            var _ret2 = _loop3();

	            if (_ret2 === "continue") continue;
	          }
	        } catch (err) {
	          _iterator3.e(err);
	        } finally {
	          _iterator3.f();
	        }

	        var _iterator4 = _createForOfIteratorHelper$2(_this5.store.state.users.mobileOnlineList),
	            _step4;

	        try {
	          var _loop4 = function _loop4() {
	            var userId = _step4.value;
	            var user = _this5.store.state.users.collection[userId];

	            if (!user) {
	              return "continue";
	            }

	            var mobileStatus = im_lib_utils.Utils.user.isMobileActive(user);

	            if (mobileStatus) {
	              user.isMobileOnline = true;
	            } else {
	              user.isMobileOnline = false;
	              _this5.store.state.users.mobileOnlineList = _this5.store.state.users.mobileOnlineList.filter(function (element) {
	                return element !== userId;
	              });
	            }
	          };

	          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
	            var _ret3 = _loop4();

	            if (_ret3 === "continue") continue;
	          }
	        } catch (err) {
	          _iterator4.e(err);
	        } finally {
	          _iterator4.f();
	        }
	      }, intervalTime);
	    }
	  }]);
	  return UsersModel;
	}(ui_vue_vuex.WidgetVuexBuilderModel);

	function _createForOfIteratorHelper$3(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$3(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

	function _unsupportedIterableToArray$3(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$3(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$3(o, minLen); }

	function _arrayLikeToArray$3(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
	var FilesModel = /*#__PURE__*/function (_VuexBuilderModel) {
	  babelHelpers.inherits(FilesModel, _VuexBuilderModel);

	  function FilesModel() {
	    babelHelpers.classCallCheck(this, FilesModel);
	    return babelHelpers.possibleConstructorReturn(this, babelHelpers.getPrototypeOf(FilesModel).apply(this, arguments));
	  }

	  babelHelpers.createClass(FilesModel, [{
	    key: "getName",
	    value: function getName() {
	      return 'files';
	    }
	  }, {
	    key: "getState",
	    value: function getState() {
	      return {
	        created: 0,
	        host: this.getVariable('host', location.protocol + '//' + location.host),
	        collection: {},
	        index: {}
	      };
	    }
	  }, {
	    key: "getElementState",
	    value: function getElementState() {
	      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	      var _params$id = params.id,
	          id = _params$id === void 0 ? 0 : _params$id,
	          _params$chatId = params.chatId,
	          chatId = _params$chatId === void 0 ? 0 : _params$chatId,
	          _params$name = params.name,
	          name = _params$name === void 0 ? this.getVariable('default.name', '') : _params$name;
	      return {
	        id: id,
	        chatId: chatId,
	        name: name,
	        templateId: id,
	        date: new Date(),
	        type: 'file',
	        extension: "",
	        icon: "empty",
	        size: 0,
	        image: false,
	        status: im_const.FileStatus.done,
	        progress: 100,
	        authorId: 0,
	        authorName: "",
	        urlPreview: "",
	        urlShow: "",
	        urlDownload: "",
	        init: false,
	        viewerAttrs: {}
	      };
	    }
	  }, {
	    key: "getGetters",
	    value: function getGetters() {
	      var _this = this;

	      return {
	        get: function get(state) {
	          return function (chatId, fileId) {
	            var getTemporary = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

	            if (!chatId || !fileId) {
	              return null;
	            }

	            if (!state.index[chatId] || !state.index[chatId][fileId]) {
	              return null;
	            }

	            if (!getTemporary && !state.index[chatId][fileId].init) {
	              return null;
	            }

	            return state.index[chatId][fileId];
	          };
	        },
	        getList: function getList(state) {
	          return function (chatId) {
	            if (!state.index[chatId]) {
	              return null;
	            }

	            return state.index[chatId];
	          };
	        },
	        getBlank: function getBlank(state) {
	          return function (params) {
	            return _this.getElementState(params);
	          };
	        }
	      };
	    }
	  }, {
	    key: "getActions",
	    value: function getActions() {
	      var _this2 = this;

	      return {
	        add: function add(store, payload) {
	          var result = _this2.validate(Object.assign({}, payload), {
	            host: store.state.host
	          });

	          if (payload.id) {
	            result.id = payload.id;
	          } else {
	            result.id = 'temporary' + new Date().getTime() + store.state.created;
	          }

	          result.templateId = result.id;
	          result.init = true;
	          store.commit('add', Object.assign({}, _this2.getElementState(), result));
	          return result.id;
	        },
	        set: function set(store, payload) {
	          if (payload instanceof Array) {
	            payload = payload.map(function (file) {
	              var result = _this2.validate(Object.assign({}, file), {
	                host: store.state.host
	              });

	              result.templateId = result.id;
	              return Object.assign({}, _this2.getElementState(), result, {
	                init: true
	              });
	            });
	          } else {
	            var result = _this2.validate(Object.assign({}, payload), {
	              host: store.state.host
	            });

	            result.templateId = result.id;
	            payload = [];
	            payload.push(Object.assign({}, _this2.getElementState(), result, {
	              init: true
	            }));
	          }

	          store.commit('set', {
	            insertType: im_const.MutationType.setAfter,
	            data: payload
	          });
	        },
	        setBefore: function setBefore(store, payload) {
	          if (payload instanceof Array) {
	            payload = payload.map(function (file) {
	              var result = _this2.validate(Object.assign({}, file), {
	                host: store.state.host
	              });

	              result.templateId = result.id;
	              return Object.assign({}, _this2.getElementState(), result, {
	                init: true
	              });
	            });
	          } else {
	            var result = _this2.validate(Object.assign({}, payload), {
	              host: store.state.host
	            });

	            result.templateId = result.id;
	            payload = [];
	            payload.push(Object.assign({}, _this2.getElementState(), result, {
	              init: true
	            }));
	          }

	          store.commit('set', {
	            actionName: 'setBefore',
	            insertType: im_const.MutationType.setBefore,
	            data: payload
	          });
	        },
	        update: function update(store, payload) {
	          var result = _this2.validate(Object.assign({}, payload.fields), {
	            host: store.state.host
	          });

	          store.commit('initCollection', {
	            chatId: payload.chatId
	          });
	          var index = store.state.collection[payload.chatId].findIndex(function (el) {
	            return el.id === payload.id;
	          });

	          if (index < 0) {
	            return false;
	          }

	          store.commit('update', {
	            id: payload.id,
	            chatId: payload.chatId,
	            index: index,
	            fields: result
	          });

	          if (payload.fields.blink) {
	            setTimeout(function () {
	              store.commit('update', {
	                id: payload.id,
	                chatId: payload.chatId,
	                fields: {
	                  blink: false
	                }
	              });
	            }, 1000);
	          }

	          return true;
	        },
	        "delete": function _delete(store, payload) {
	          store.commit('delete', {
	            id: payload.id,
	            chatId: payload.chatId
	          });
	          return true;
	        },
	        saveState: function saveState(store, payload) {
	          store.commit('saveState', {});
	          return true;
	        }
	      };
	    }
	  }, {
	    key: "getMutations",
	    value: function getMutations() {
	      var _this3 = this;

	      return {
	        initCollection: function initCollection(state, payload) {
	          _this3.initCollection(state, payload);
	        },
	        add: function add(state, payload) {
	          _this3.initCollection(state, payload);

	          state.collection[payload.chatId].push(payload);
	          state.index[payload.chatId][payload.id] = payload;
	          state.created += 1;

	          _this3.saveState(state);
	        },
	        set: function set(state, payload) {
	          var _iterator = _createForOfIteratorHelper$3(payload.data),
	              _step;

	          try {
	            var _loop = function _loop() {
	              var element = _step.value;

	              _this3.initCollection(state, {
	                chatId: element.chatId
	              });

	              var index = state.collection[element.chatId].findIndex(function (el) {
	                return el.id === element.id;
	              });

	              if (index > -1) {
	                delete element.templateId;
	                state.collection[element.chatId][index] = Object.assign(state.collection[element.chatId][index], element);
	              } else if (payload.insertType === im_const.MutationType.setBefore) {
	                state.collection[element.chatId].unshift(element);
	              } else {
	                state.collection[element.chatId].push(element);
	              }

	              state.index[element.chatId][element.id] = element;

	              _this3.saveState(state);
	            };

	            for (_iterator.s(); !(_step = _iterator.n()).done;) {
	              _loop();
	            }
	          } catch (err) {
	            _iterator.e(err);
	          } finally {
	            _iterator.f();
	          }
	        },
	        update: function update(state, payload) {
	          _this3.initCollection(state, payload);

	          var index = -1;

	          if (typeof payload.index !== 'undefined' && state.collection[payload.chatId][payload.index]) {
	            index = payload.index;
	          } else {
	            index = state.collection[payload.chatId].findIndex(function (el) {
	              return el.id === payload.id;
	            });
	          }

	          if (index >= 0) {
	            delete payload.fields.templateId;
	            var element = Object.assign(state.collection[payload.chatId][index], payload.fields);
	            state.collection[payload.chatId][index] = element;
	            state.index[payload.chatId][element.id] = element;

	            _this3.saveState(state);
	          }
	        },
	        "delete": function _delete(state, payload) {
	          _this3.initCollection(state, payload);

	          state.collection[payload.chatId] = state.collection[payload.chatId].filter(function (element) {
	            return element.id !== payload.id;
	          });
	          delete state.index[payload.chatId][payload.id];

	          _this3.saveState(state);
	        },
	        saveState: function saveState(state, payload) {
	          _this3.saveState(state);
	        }
	      };
	    }
	  }, {
	    key: "initCollection",
	    value: function initCollection(state, payload) {
	      if (typeof state.collection[payload.chatId] !== 'undefined') {
	        return true;
	      }

	      ui_vue.WidgetVue.set(state.collection, payload.chatId, []);
	      ui_vue.WidgetVue.set(state.index, payload.chatId, {});
	      return true;
	    }
	  }, {
	    key: "getLoadedState",
	    value: function getLoadedState(state) {
	      if (!state || babelHelpers["typeof"](state) !== 'object') {
	        return state;
	      }

	      if (babelHelpers["typeof"](state.collection) !== 'object') {
	        return state;
	      }

	      state.index = {};

	      var _loop2 = function _loop2(chatId) {
	        if (!state.collection.hasOwnProperty(chatId)) {
	          return "continue";
	        }

	        state.index[chatId] = {};
	        state.collection[chatId].filter(function (file) {
	          return file != null;
	        }).forEach(function (file) {
	          state.index[chatId][file.id] = file;
	        });
	      };

	      for (var chatId in state.collection) {
	        var _ret = _loop2(chatId);

	        if (_ret === "continue") continue;
	      }

	      return state;
	    }
	  }, {
	    key: "getSaveFileList",
	    value: function getSaveFileList() {
	      if (!this.db) {
	        return [];
	      }

	      if (!this.store.getters['messages/getSaveFileList']) {
	        return [];
	      }

	      var list = this.store.getters['messages/getSaveFileList']();

	      if (!list) {
	        return [];
	      }

	      return list;
	    }
	  }, {
	    key: "getSaveTimeout",
	    value: function getSaveTimeout() {
	      return 250;
	    }
	  }, {
	    key: "saveState",
	    value: function saveState(state) {
	      var _this4 = this;

	      if (!this.isSaveAvailable()) {
	        return false;
	      }

	      babelHelpers.get(babelHelpers.getPrototypeOf(FilesModel.prototype), "saveState", this).call(this, function () {
	        var list = _this4.getSaveFileList();

	        if (!list) {
	          return false;
	        }

	        var storedState = {
	          collection: {}
	        };

	        var _loop3 = function _loop3(chatId) {
	          if (!list.hasOwnProperty(chatId)) {
	            return "continue";
	          }

	          list[chatId].forEach(function (fileId) {
	            if (!state.index[chatId]) {
	              return false;
	            }

	            if (!state.index[chatId][fileId]) {
	              return false;
	            }

	            if (!storedState.collection[chatId]) {
	              storedState.collection[chatId] = [];
	            }

	            storedState.collection[chatId].push(state.index[chatId][fileId]);
	          });
	        };

	        for (var chatId in list) {
	          var _ret2 = _loop3(chatId);

	          if (_ret2 === "continue") continue;
	        }

	        return storedState;
	      });
	    }
	  }, {
	    key: "validate",
	    value: function validate(fields) {
	      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	      var result = {};
	      options.host = options.host || this.getState().host;

	      if (typeof fields.id === "number") {
	        result.id = fields.id;
	      } else if (typeof fields.id === "string") {
	        if (fields.id.startsWith('temporary')) {
	          result.id = fields.id;
	        } else {
	          result.id = parseInt(fields.id);
	        }
	      }

	      if (typeof fields.templateId === "number") {
	        result.templateId = fields.templateId;
	      } else if (typeof fields.templateId === "string") {
	        if (fields.templateId.startsWith('temporary')) {
	          result.templateId = fields.templateId;
	        } else {
	          result.templateId = parseInt(fields.templateId);
	        }
	      }

	      if (typeof fields.chatId === "number" || typeof fields.chatId === "string") {
	        result.chatId = parseInt(fields.chatId);
	      }

	      if (typeof fields.date !== "undefined") {
	        result.date = im_lib_utils.Utils.date.cast(fields.date);
	      }

	      if (typeof fields.type === "string") {
	        result.type = fields.type;
	      }

	      if (typeof fields.extension === "string") {
	        result.extension = fields.extension.toString();

	        if (result.type === 'image') {
	          result.icon = 'img';
	        } else if (result.type === 'video') {
	          result.icon = 'mov';
	        } else {
	          result.icon = FilesModel.getIconType(result.extension);
	        }
	      }

	      if (typeof fields.name === "string" || typeof fields.name === "number") {
	        result.name = fields.name.toString();
	      }

	      if (typeof fields.size === "number" || typeof fields.size === "string") {
	        result.size = parseInt(fields.size);
	      }

	      if (typeof fields.image === 'boolean') {
	        result.image = false;
	      } else if (babelHelpers["typeof"](fields.image) === 'object' && fields.image) {
	        result.image = {
	          width: 0,
	          height: 0
	        };

	        if (typeof fields.image.width === "string" || typeof fields.image.width === "number") {
	          result.image.width = parseInt(fields.image.width);
	        }

	        if (typeof fields.image.height === "string" || typeof fields.image.height === "number") {
	          result.image.height = parseInt(fields.image.height);
	        }

	        if (result.image.width <= 0 || result.image.height <= 0) {
	          result.image = false;
	        }
	      }

	      if (typeof fields.status === "string" && typeof im_const.FileStatus[fields.status] !== 'undefined') {
	        result.status = fields.status;
	      }

	      if (typeof fields.progress === "number" || typeof fields.progress === "string") {
	        result.progress = parseInt(fields.progress);
	      }

	      if (typeof fields.authorId === "number" || typeof fields.authorId === "string") {
	        result.authorId = parseInt(fields.authorId);
	      }

	      if (typeof fields.authorName === "string" || typeof fields.authorName === "number") {
	        result.authorName = fields.authorName.toString();
	      }

	      if (typeof fields.urlPreview === 'string') {
	        if (!fields.urlPreview || fields.urlPreview.startsWith('http') || fields.urlPreview.startsWith('bx') || fields.urlPreview.startsWith('file') || fields.urlPreview.startsWith('blob')) {
	          result.urlPreview = fields.urlPreview;
	        } else {
	          result.urlPreview = options.host + fields.urlPreview;
	        }
	      }

	      if (typeof fields.urlDownload === 'string') {
	        if (!fields.urlDownload || fields.urlDownload.startsWith('http') || fields.urlDownload.startsWith('bx') || fields.urlPreview.startsWith('file')) {
	          result.urlDownload = fields.urlDownload;
	        } else {
	          result.urlDownload = options.host + fields.urlDownload;
	        }
	      }

	      if (typeof fields.urlShow === 'string') {
	        if (!fields.urlShow || fields.urlShow.startsWith('http') || fields.urlShow.startsWith('bx') || fields.urlShow.startsWith('file')) {
	          result.urlShow = fields.urlShow;
	        } else {
	          result.urlShow = options.host + fields.urlShow;
	        }
	      }

	      if (babelHelpers["typeof"](fields.viewerAttrs) === 'object') {
	        if (result.type === 'image' && !im_lib_utils.Utils.platform.isBitrixMobile()) {
	          result.viewerAttrs = fields.viewerAttrs;
	        }

	        if (result.type === 'video' && !im_lib_utils.Utils.platform.isBitrixMobile() && result.size > FilesModel.maxDiskFileSize) {
	          result.viewerAttrs = fields.viewerAttrs;
	        }
	      }

	      return result;
	    }
	  }], [{
	    key: "getType",
	    value: function getType(type) {
	      type = type.toString().toLowerCase().split('.').splice(-1)[0];

	      switch (type) {
	        case 'png':
	        case 'jpe':
	        case 'jpg':
	        case 'jpeg':
	        case 'gif':
	        case 'heic':
	        case 'bmp':
	        case 'webp':
	          return im_const.FileType.image;

	        case 'mp4':
	        case 'mkv':
	        case 'webm':
	        case 'mpeg':
	        case 'hevc':
	        case 'avi':
	        case '3gp':
	        case 'flv':
	        case 'm4v':
	        case 'ogg':
	        case 'wmv':
	        case 'mov':
	          return im_const.FileType.video;

	        case 'mp3':
	          return im_const.FileType.audio;
	      }

	      return im_const.FileType.file;
	    }
	  }, {
	    key: "getIconType",
	    value: function getIconType(extension) {
	      var icon = 'empty';

	      switch (extension.toString()) {
	        case 'png':
	        case 'jpe':
	        case 'jpg':
	        case 'jpeg':
	        case 'gif':
	        case 'heic':
	        case 'bmp':
	        case 'webp':
	          icon = 'img';
	          break;

	        case 'mp4':
	        case 'mkv':
	        case 'webm':
	        case 'mpeg':
	        case 'hevc':
	        case 'avi':
	        case '3gp':
	        case 'flv':
	        case 'm4v':
	        case 'ogg':
	        case 'wmv':
	        case 'mov':
	          icon = 'mov';
	          break;

	        case 'txt':
	          icon = 'txt';
	          break;

	        case 'doc':
	        case 'docx':
	          icon = 'doc';
	          break;

	        case 'xls':
	        case 'xlsx':
	          icon = 'xls';
	          break;

	        case 'php':
	          icon = 'php';
	          break;

	        case 'pdf':
	          icon = 'pdf';
	          break;

	        case 'ppt':
	        case 'pptx':
	          icon = 'ppt';
	          break;

	        case 'rar':
	          icon = 'rar';
	          break;

	        case 'zip':
	        case '7z':
	        case 'tar':
	        case 'gz':
	        case 'gzip':
	          icon = 'zip';
	          break;

	        case 'set':
	          icon = 'set';
	          break;

	        case 'conf':
	        case 'ini':
	        case 'plist':
	          icon = 'set';
	          break;
	      }

	      return icon;
	    }
	  }]);
	  return FilesModel;
	}(ui_vue_vuex.WidgetVuexBuilderModel);
	babelHelpers.defineProperty(FilesModel, "maxDiskFileSize", 5242880);

	/**
	 * Bitrix Messenger
	 * Recent model (Vuex Builder model)
	 *
	 * @package bitrix
	 * @subpackage im
	 * @copyright 2001-2020 Bitrix
	 */
	var RecentModel = /*#__PURE__*/function (_VuexBuilderModel) {
	  babelHelpers.inherits(RecentModel, _VuexBuilderModel);

	  function RecentModel() {
	    babelHelpers.classCallCheck(this, RecentModel);
	    return babelHelpers.possibleConstructorReturn(this, babelHelpers.getPrototypeOf(RecentModel).apply(this, arguments));
	  }

	  babelHelpers.createClass(RecentModel, [{
	    key: "getName",
	    value: function getName() {
	      return 'recent';
	    }
	  }, {
	    key: "getState",
	    value: function getState() {
	      return {
	        host: this.getVariable('host', location.protocol + '//' + location.host),
	        collection: []
	      };
	    }
	  }, {
	    key: "getElementState",
	    value: function getElementState() {
	      return {
	        id: 0,
	        templateId: '',
	        template: im_const.TemplateTypes.item,
	        chatType: im_const.ChatTypes.chat,
	        sectionCode: im_const.RecentSection.general,
	        avatar: '',
	        color: '#048bd0',
	        title: '',
	        lines: {
	          id: 0,
	          status: 0
	        },
	        message: {
	          id: 0,
	          text: '',
	          date: new Date(),
	          senderId: 0,
	          status: im_const.MessageStatus.received
	        },
	        counter: 0,
	        pinned: false,
	        chatId: 0,
	        userId: 0
	      };
	    }
	  }, {
	    key: "getGetters",
	    value: function getGetters() {
	      var _this = this;

	      return {
	        get: function get(state) {
	          return function (dialogId) {
	            if (main_core.Type.isNumber(dialogId)) {
	              dialogId = dialogId.toString();
	            }

	            var currentItem = _this.findItem(dialogId);

	            if (currentItem) {
	              return currentItem;
	            }

	            return false;
	          };
	        }
	      };
	    }
	  }, {
	    key: "getActions",
	    value: function getActions() {
	      var _this2 = this;

	      return {
	        set: function set(store, payload) {
	          var result = [];

	          if (payload instanceof Array) {
	            result = payload.map(function (recentItem) {
	              return _this2.prepareItem(recentItem, {
	                host: store.state.host
	              });
	            });
	          }

	          if (result.length === 0) {
	            return false;
	          }

	          result.forEach(function (element) {
	            var existingItem = _this2.findItem(element.id);

	            if (existingItem) {
	              store.commit('update', {
	                index: existingItem.index,
	                fields: element
	              });
	            } else {
	              store.commit('add', {
	                fields: element
	              });
	            }
	          });
	          store.state.collection.sort(_this2.sortListByMessageDate);
	        },
	        addPlaceholders: function addPlaceholders(store, payload) {
	          payload.forEach(function (element) {
	            store.commit('addPlaceholder', {
	              fields: element
	            });
	          });
	        },
	        updatePlaceholders: function updatePlaceholders(store, payload) {
	          payload.items = payload.items.map(function (element) {
	            return _this2.prepareItem(element);
	          });
	          payload.items.forEach(function (element, index) {
	            var placeholderId = 'placeholder' + (payload.firstMessage + index);

	            var existingPlaceholder = _this2.findItem(placeholderId, 'templateId');

	            var existingItem = _this2.findItem(element.id);

	            if (existingItem) {
	              store.commit('update', {
	                index: existingItem.index,
	                fields: element
	              });
	              store.commit('delete', {
	                index: existingPlaceholder.index
	              });
	            } else {
	              store.commit('update', {
	                index: existingPlaceholder.index,
	                fields: element
	              });
	            }
	          });
	        },
	        update: function update(store, payload) {
	          if (typeof payload.id === 'string' && !payload.id.startsWith('chat') && payload.id !== 'notify') {
	            payload.id = parseInt(payload.id);
	          }

	          var existingItem = _this2.findItem(payload.id);

	          if (!existingItem) {
	            return false;
	          }

	          payload.fields = _this2.validate(Object.assign({}, payload.fields));
	          store.commit('update', {
	            index: existingItem.index,
	            fields: payload.fields
	          });
	          store.state.collection.sort(_this2.sortListByMessageDate);
	        },
	        pin: function pin(store, payload) {
	          if (typeof payload.id === 'string' && !payload.id.startsWith('chat') && payload.id !== 'notify') {
	            payload.id = parseInt(payload.id);
	          }

	          var existingItem = _this2.findItem(payload.id);

	          if (!existingItem) {
	            return false;
	          }

	          store.commit('update', {
	            index: existingItem.index,
	            fields: Object.assign({}, existingItem.element, {
	              pinned: payload.action
	            })
	          });
	          store.state.collection.sort(_this2.sortListByMessageDate);
	        },
	        clearPlaceholders: function clearPlaceholders(store) {
	          store.commit('clearPlaceholders');
	        },
	        "delete": function _delete(store, payload) {
	          if (typeof payload.id === 'string' && !payload.id.startsWith('chat') && payload.id !== 'notify') {
	            payload.id = parseInt(payload.id);
	          }

	          var existingItem = _this2.findItem(payload.id);

	          if (!existingItem) {
	            return false;
	          }

	          store.commit('delete', {
	            index: existingItem.index
	          });
	          store.state.collection.sort(_this2.sortListByMessageDate);
	        }
	      };
	    }
	  }, {
	    key: "getMutations",
	    value: function getMutations() {
	      var _this3 = this;

	      return {
	        add: function add(state, payload) {
	          state.collection.push(Object.assign({}, _this3.getElementState(), payload.fields));
	        },
	        update: function update(state, payload) {
	          state.collection.splice(payload.index, 1, Object.assign({}, state.collection[payload.index], payload.fields));
	        },
	        "delete": function _delete(state, payload) {
	          state.collection.splice(payload.index, 1);
	        },
	        addPlaceholder: function addPlaceholder(state, payload) {
	          state.collection.push(Object.assign({}, _this3.getElementState(), payload.fields));
	        },
	        clearPlaceholders: function clearPlaceholders(state) {
	          state.collection = state.collection.filter(function (element) {
	            return !element.id.toString().startsWith('placeholder');
	          });
	        }
	      };
	    }
	  }, {
	    key: "validate",
	    value: function validate(fields) {
	      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	      var result = {};

	      if (main_core.Type.isNumber(fields.id)) {
	        result.id = fields.id.toString();
	      }

	      if (main_core.Type.isStringFilled(fields.id)) {
	        result.id = fields.id;
	      }

	      if (main_core.Type.isString(fields.templateId)) {
	        result.templateId = fields.templateId;
	      }

	      if (main_core.Type.isString(fields.template)) {
	        result.template = fields.template;
	      }

	      if (main_core.Type.isString(fields.type)) {
	        if (fields.type === im_const.ChatTypes.chat) {
	          if (fields.chat.type === im_const.ChatTypes.open) {
	            result.chatType = im_const.ChatTypes.open;
	          } else if (fields.chat.type === im_const.ChatTypes.chat) {
	            result.chatType = im_const.ChatTypes.chat;
	          }
	        } else if (fields.type === im_const.ChatTypes.user) {
	          result.chatType = im_const.ChatTypes.user;
	        } else if (fields.type === im_const.ChatTypes.notification) {
	          result.chatType = im_const.ChatTypes.notification;
	          fields.title = 'Notifications';
	        } else {
	          result.chatType = im_const.ChatTypes.chat;
	        }
	      }

	      if (main_core.Type.isString(fields.avatar)) {
	        var avatar;

	        if (!fields.avatar || fields.avatar.endsWith('/js/im/images/blank.gif')) {
	          avatar = '';
	        } else if (fields.avatar.startsWith('http')) {
	          avatar = fields.avatar;
	        } else {
	          avatar = options.host + fields.avatar;
	        }

	        if (avatar) {
	          result.avatar = encodeURI(avatar);
	        }
	      }

	      if (main_core.Type.isString(fields.color)) {
	        result.color = fields.color;
	      }

	      if (main_core.Type.isString(fields.title)) {
	        result.title = fields.title;
	      }

	      if (main_core.Type.isPlainObject(fields.message)) {
	        var message = {};

	        if (main_core.Type.isNumber(fields.message.id)) {
	          message.id = fields.message.id;
	        }

	        if (main_core.Type.isString(fields.message.text)) {
	          var _options = {};

	          if (fields.message.withAttach) {
	            _options.WITH_ATTACH = true;
	          } else if (fields.message.withFile) {
	            _options.WITH_FILE = true;
	          }

	          message.text = im_lib_utils.Utils.text.purify(fields.message.text, _options);
	        }

	        if (main_core.Type.isDate(fields.message.date) || main_core.Type.isString(fields.message.date)) {
	          message.date = fields.message.date;
	        }

	        if (main_core.Type.isNumber(fields.message.author_id)) {
	          message.senderId = fields.message.author_id;
	        }

	        if (main_core.Type.isNumber(fields.message.senderId)) {
	          message.senderId = fields.message.senderId;
	        }

	        if (main_core.Type.isStringFilled(fields.message.status)) {
	          message.status = fields.message.status;
	        }

	        result.message = message;
	      }

	      if (main_core.Type.isNumber(fields.counter)) {
	        result.counter = fields.counter;
	      }

	      if (main_core.Type.isBoolean(fields.pinned)) {
	        result.pinned = fields.pinned;
	      }

	      if (main_core.Type.isNumber(fields.chatId)) {
	        result.chatId = fields.chatId;
	      }

	      if (main_core.Type.isNumber(fields.userId)) {
	        result.userId = fields.userId;
	      }

	      return result;
	    }
	  }, {
	    key: "sortListByMessageDate",
	    value: function sortListByMessageDate(a, b) {
	      if (a.message && b.message) {
	        var timestampA = new Date(a.message.date).getTime();
	        var timestampB = new Date(b.message.date).getTime();
	        return timestampB - timestampA;
	      }
	    }
	  }, {
	    key: "prepareItem",
	    value: function prepareItem(item) {
	      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	      var result = this.validate(Object.assign({}, item));
	      return Object.assign({}, this.getElementState(), result, options);
	    }
	  }, {
	    key: "findItem",
	    value: function findItem(value) {
	      var key = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'id';
	      var result = {};

	      if (key === 'id' && main_core.Type.isNumber(value)) {
	        value = value.toString();
	      }

	      var elementIndex = this.store.state.recent.collection.findIndex(function (element, index) {
	        return element[key] === value;
	      });

	      if (elementIndex !== -1) {
	        result.index = elementIndex;
	        result.element = this.store.state.recent.collection[elementIndex];
	        return result;
	      }

	      return false;
	    }
	  }]);
	  return RecentModel;
	}(ui_vue_vuex.WidgetVuexBuilderModel); //raw input object for validation

	function _createForOfIteratorHelper$4(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$4(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

	function _unsupportedIterableToArray$4(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$4(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$4(o, minLen); }

	function _arrayLikeToArray$4(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

	var NotificationsModel = /*#__PURE__*/function (_VuexBuilderModel) {
	  babelHelpers.inherits(NotificationsModel, _VuexBuilderModel);

	  function NotificationsModel() {
	    babelHelpers.classCallCheck(this, NotificationsModel);
	    return babelHelpers.possibleConstructorReturn(this, babelHelpers.getPrototypeOf(NotificationsModel).apply(this, arguments));
	  }

	  babelHelpers.createClass(NotificationsModel, [{
	    key: "getName",
	    value: function getName() {
	      return 'notifications';
	    }
	  }, {
	    key: "getState",
	    value: function getState() {
	      return {
	        collection: [],
	        searchCollection: [],
	        chat_id: 0,
	        total: 0,
	        host: this.getVariable('host', location.protocol + '//' + location.host),
	        unreadCounter: 0,
	        schema: {}
	      };
	    }
	  }, {
	    key: "getElementState",
	    value: function getElementState() {
	      return {
	        id: 0,
	        authorId: 0,
	        date: new Date(),
	        text: '',
	        sectionCode: im_const.NotificationTypesCodes.simple,
	        textConverted: '',
	        unread: false,
	        display: true,
	        settingName: 'im|default'
	      };
	    }
	  }, {
	    key: "getGetters",
	    value: function getGetters() {
	      var _this = this;

	      return {
	        get: function get(state) {
	          return function () {
	            return state.collection;
	          };
	        },
	        getById: function getById(state) {
	          return function (notificationId) {
	            if (main_core.Type.isString(notificationId)) {
	              notificationId = parseInt(notificationId);
	            }

	            var existingItem = _this.findItemInArr(state.collection, notificationId);

	            if (!existingItem.element) {
	              return false;
	            }

	            return existingItem.element;
	          };
	        },
	        getSearchItemById: function getSearchItemById(state) {
	          return function (notificationId) {
	            if (main_core.Type.isString(notificationId)) {
	              notificationId = parseInt(notificationId);
	            }

	            var existingItem = _this.findItemInArr(state.searchCollection, notificationId);

	            if (!existingItem.element) {
	              return false;
	            }

	            return existingItem.element;
	          };
	        },
	        getBlank: function getBlank(state) {
	          return function (params) {
	            return _this.getElementState();
	          };
	        }
	      };
	    }
	  }, {
	    key: "getActions",
	    value: function getActions() {
	      var _this2 = this;

	      return {
	        set: function set(store, payload) {
	          var result = {
	            notification: []
	          };

	          if (payload.notification instanceof Array) {
	            result.notification = payload.notification.map(function (notification) {
	              return _this2.prepareNotification(notification, {
	                host: store.state.host
	              });
	            });
	          }

	          if (main_core.Type.isNumber(payload.total) || main_core.Type.isString(payload.total)) {
	            result.total = parseInt(payload.total);
	          }

	          store.commit('set', result);
	        },
	        setSearchResults: function setSearchResults(store, payload) {
	          var result = {
	            notification: []
	          };

	          if (!(payload.notification instanceof Array)) {
	            return false;
	          } // we don't need validation for the local results


	          if (payload.type === 'local') {
	            result.notification = payload.notification;
	          } else {
	            result.notification = payload.notification.map(function (notification) {
	              return _this2.prepareNotification(notification, {
	                host: store.state.host
	              });
	            });
	          }

	          store.commit('setSearchResults', {
	            data: result
	          });
	        },
	        deleteSearchResults: function deleteSearchResults(store, payload) {
	          store.commit('deleteSearchResults');
	        },
	        setCounter: function setCounter(store, payload) {
	          if (main_core.Type.isNumber(payload.unreadTotal) || main_core.Type.isString(payload.unreadTotal)) {
	            var unreadCounter = parseInt(payload.unreadTotal);
	            store.commit('setCounter', unreadCounter);
	          }
	        },
	        setTotal: function setTotal(store, payload) {
	          if (main_core.Type.isNumber(payload.total) || main_core.Type.isString(payload.total)) {
	            store.commit('setTotal', payload.total);
	          }
	        },
	        add: function add(store, payload) {
	          var addItem = _this2.prepareNotification(payload.data, {
	            host: store.state.host
	          });

	          addItem.unread = true;

	          var existingItem = _this2.findItemInArr(store.state.collection, addItem.id);

	          if (!existingItem.element) {
	            store.commit('add', {
	              data: addItem
	            });
	            store.commit('setTotal', store.state.total + 1);
	          } else {
	            store.commit('update', {
	              index: existingItem.index,
	              fields: Object.assign({}, payload.fields)
	            });
	          }
	        },
	        updatePlaceholders: function updatePlaceholders(store, payload) {
	          if (payload.items instanceof Array) {
	            payload.items = payload.items.map(function (notification) {
	              return _this2.prepareNotification(notification);
	            });
	          } else {
	            return false;
	          }

	          store.commit('updatePlaceholders', payload);
	          return true;
	        },
	        clearPlaceholders: function clearPlaceholders(store, payload) {
	          store.commit('clearPlaceholders', payload);
	        },
	        update: function update(store, payload) {
	          var existingItem = _this2.findItemInArr(store.state.collection, payload.id);

	          if (existingItem.element) {
	            store.commit('update', {
	              index: existingItem.index,
	              fields: Object.assign({}, payload.fields)
	            });
	          }

	          if (payload.searchMode) {
	            var existingItemInSearchCollection = _this2.findItemInArr(store.state.searchCollection, payload.id);

	            if (existingItemInSearchCollection.element) {
	              store.commit('update', {
	                searchCollection: true,
	                index: existingItemInSearchCollection.index,
	                fields: Object.assign({}, payload.fields)
	              });
	            }
	          }
	        },
	        read: function read(store, payload) {
	          var _iterator = _createForOfIteratorHelper$4(payload.ids),
	              _step;

	          try {
	            for (_iterator.s(); !(_step = _iterator.n()).done;) {
	              var notificationId = _step.value;

	              var existingItem = _this2.findItemInArr(store.state.collection, notificationId);

	              if (!existingItem.element) {
	                return false;
	              }

	              store.commit('read', {
	                index: existingItem.index,
	                action: !payload.action
	              });
	            }
	          } catch (err) {
	            _iterator.e(err);
	          } finally {
	            _iterator.f();
	          }
	        },
	        readAll: function readAll(store, payload) {
	          store.commit('readAll');
	        },
	        "delete": function _delete(store, payload) {
	          var existingItem = _this2.findItemInArr(store.state.collection, payload.id);

	          if (existingItem.element) {
	            store.commit('delete', {
	              searchCollection: false,
	              index: existingItem.index
	            });
	            store.commit('setTotal', store.state.total - 1);
	          }

	          if (payload.searchMode) {
	            var existingItemInSearchCollection = _this2.findItemInArr(store.state.searchCollection, payload.id);

	            if (existingItemInSearchCollection.element) {
	              store.commit('delete', {
	                searchCollection: true,
	                index: existingItemInSearchCollection.index
	              });
	            }
	          }
	        },
	        deleteAll: function deleteAll(store, payload) {
	          store.commit('deleteAll');
	        },
	        setSchema: function setSchema(store, payload) {
	          store.commit('setSchema', {
	            data: payload.data
	          });
	        }
	      };
	    }
	  }, {
	    key: "getMutations",
	    value: function getMutations() {
	      var _this3 = this;

	      return {
	        set: function set(state, payload) {
	          state.total = payload.hasOwnProperty('total') ? payload.total : state.total;

	          if (!payload.hasOwnProperty('notification') || !main_core.Type.isArray(payload.notification)) {
	            return;
	          }

	          var _iterator2 = _createForOfIteratorHelper$4(payload.notification),
	              _step2;

	          try {
	            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
	              var element = _step2.value;

	              var existingItem = _this3.findItemInArr(state.collection, element.id);

	              if (!existingItem.element) {
	                state.collection.push(element);
	              } else {
	                // we trust unread status of existing item to prevent notifications blinking while init loading.
	                if (element.unread !== state.collection[existingItem.index].unread) {
	                  element.unread = state.collection[existingItem.index].unread;
	                  state.unreadCounter = element.unread === true ? state.unreadCounter + 1 : state.unreadCounter - 1;
	                }

	                state.collection[existingItem.index] = Object.assign(state.collection[existingItem.index], element);
	              }
	            }
	          } catch (err) {
	            _iterator2.e(err);
	          } finally {
	            _iterator2.f();
	          }

	          state.collection.sort(_this3.sortByType);
	        },
	        setSearchResults: function setSearchResults(state, payload) {
	          var _iterator3 = _createForOfIteratorHelper$4(payload.data.notification),
	              _step3;

	          try {
	            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
	              var element = _step3.value;

	              var existingItem = _this3.findItemInArr(state.searchCollection, element.id);

	              if (!existingItem.element) {
	                state.searchCollection.push(element);
	              } else {
	                state.searchCollection[existingItem.index] = Object.assign(state.searchCollection[existingItem.index], element);
	              }
	            }
	          } catch (err) {
	            _iterator3.e(err);
	          } finally {
	            _iterator3.f();
	          }
	        },
	        deleteAll: function deleteAll(state, payload) {
	          state.collection = [];
	        },
	        deleteSearchResults: function deleteSearchResults(state, payload) {
	          state.searchCollection = [];
	        },
	        add: function add(state, payload) {
	          var firstNotificationIndex = null;

	          if (payload.data.sectionCode === im_const.NotificationTypesCodes.confirm) {
	            //new confirms should always add to the beginning of the collection
	            state.collection.unshift(payload.data);
	          } else //if (payload.data.sectionCode === NotificationTypesCodes.simple)
	            {
	              for (var index = 0; state.collection.length > index; index++) {
	                if (state.collection[index].sectionCode === im_const.NotificationTypesCodes.simple) {
	                  firstNotificationIndex = index;
	                  break;
	                }
	              } //if we didn't find any simple notification and its index, then add new one to the end.


	              if (firstNotificationIndex === null) {
	                state.collection.push(payload.data);
	              } else //otherwise, put it right before first simple notification.
	                {
	                  state.collection.splice(firstNotificationIndex, 0, payload.data);
	                }
	            }

	          state.collection.sort(_this3.sortByType);
	        },
	        update: function update(state, payload) {
	          var collectionName = payload.searchCollection ? 'searchCollection' : 'collection';
	          ui_vue.WidgetVue.set(state[collectionName], payload.index, Object.assign({}, state[collectionName][payload.index], payload.fields));
	        },
	        "delete": function _delete(state, payload) {
	          var collectionName = payload.searchCollection ? 'searchCollection' : 'collection';
	          state[collectionName].splice(payload.index, 1);
	        },
	        read: function read(state, payload) {
	          state.collection[payload.index].unread = payload.action;
	        },
	        readAll: function readAll(state, payload) {
	          for (var index = 0; state.collection.length > index; index++) {
	            if (state.collection[index].sectionCode === im_const.NotificationTypesCodes.simple) {
	              state.collection[index].unread = false;
	            }
	          }
	        },
	        updatePlaceholders: function updatePlaceholders(state, payload) {
	          var collectionName = payload.searchCollection ? 'searchCollection' : 'collection';
	          payload.items.forEach(function (element, index) {
	            var placeholderId = "placeholder".concat(payload.firstItem + index);
	            var existingPlaceholderIndex = state[collectionName].findIndex(function (notification) {
	              return notification.id === placeholderId;
	            });
	            var existingMessageIndex = state[collectionName].findIndex(function (notification) {
	              return notification.id === element.id;
	            });

	            if (existingMessageIndex >= 0) {
	              state[collectionName][existingMessageIndex] = Object.assign(state[collectionName][existingMessageIndex], element);
	              state[collectionName].splice(existingPlaceholderIndex, 1);
	            } else {
	              state[collectionName].splice(existingPlaceholderIndex, 1, Object.assign({}, element));
	            }
	          });
	          state[collectionName].sort(_this3.sortByType);
	        },
	        clearPlaceholders: function clearPlaceholders(state, payload) {
	          state.collection = state.collection.filter(function (element) {
	            return !element.id.toString().startsWith('placeholder');
	          });
	          state.searchCollection = state.searchCollection.filter(function (element) {
	            return !element.id.toString().startsWith('placeholder');
	          });
	        },
	        setCounter: function setCounter(state, payload) {
	          state.unreadCounter = payload;
	        },
	        setTotal: function setTotal(state, payload) {
	          state.total = payload;
	        },
	        setSchema: function setSchema(state, payload) {
	          state.schema = payload.data;
	        }
	      };
	    }
	    /* region Validation */

	  }, {
	    key: "validate",
	    value: function validate(fields, options) {
	      var result = {};

	      if (main_core.Type.isString(fields.id) || main_core.Type.isNumber(fields.id)) {
	        result.id = fields.id;
	      }

	      if (!main_core.Type.isNil(fields.date)) {
	        result.date = im_lib_utils.Utils.date.cast(fields.date);
	      } // previous P&P format


	      if (main_core.Type.isString(fields.textOriginal) || main_core.Type.isNumber(fields.textOriginal)) {
	        result.text = fields.textOriginal.toString();

	        if (main_core.Type.isString(fields.text) || main_core.Type.isNumber(fields.text)) {
	          result.textConverted = this.convertToHtml({
	            text: fields.text.toString()
	          });
	        }
	      } else // modern format
	        {
	          if (!main_core.Type.isNil(fields.text_converted)) {
	            fields.textConverted = fields.text_converted;
	          }

	          if (main_core.Type.isString(fields.textConverted) || main_core.Type.isNumber(fields.textConverted)) {
	            result.textConverted = fields.textConverted.toString();
	          }

	          if (main_core.Type.isString(fields.text) || main_core.Type.isNumber(fields.text)) {
	            result.text = fields.text.toString();
	            var isConverted = !main_core.Type.isNil(result.textConverted);
	            result.textConverted = this.convertToHtml({
	              text: isConverted ? result.textConverted : result.text
	            });
	          }
	        }

	      if (main_core.Type.isNumber(fields.author_id)) {
	        if (fields.system === true || fields.system === 'Y') {
	          result.authorId = 0;
	        } else {
	          result.authorId = fields.author_id;
	        }
	      }

	      if (main_core.Type.isNumber(fields.userId)) {
	        result.authorId = fields.userId;
	      }

	      if (main_core.Type.isObjectLike(fields.params)) {
	        var params = this.validateParams(fields.params);

	        if (params) {
	          result.params = params;
	        }
	      }

	      if (!main_core.Type.isNil(fields.notify_buttons)) {
	        result.notifyButtons = JSON.parse(fields.notify_buttons);
	      } //p&p format


	      if (!main_core.Type.isNil(fields.buttons)) {
	        result.notifyButtons = fields.buttons.map(function (button) {
	          return {
	            COMMAND: 'notifyConfirm',
	            COMMAND_PARAMS: "".concat(result.id, "|").concat(button.VALUE),
	            TEXT: "".concat(button.TITLE),
	            TYPE: 'BUTTON',
	            DISPLAY: 'LINE',
	            BG_COLOR: button.VALUE === 'Y' ? '#8bc84b' : '#ef4b57',
	            TEXT_COLOR: '#fff'
	          };
	        });
	      }

	      if (fields.notify_type === im_const.NotificationTypesCodes.confirm || fields.type === im_const.NotificationTypesCodes.confirm) {
	        result.sectionCode = im_const.NotificationTypesCodes.confirm;
	      } else if (fields.type === im_const.NotificationTypesCodes.placeholder) {
	        result.sectionCode = im_const.NotificationTypesCodes.placeholder;
	      }

	      if (!main_core.Type.isNil(fields.notify_read)) {
	        result.unread = fields.notify_read === 'N';
	      } //p&p format


	      if (!main_core.Type.isNil(fields.read)) {
	        result.unread = fields.read === 'N'; //?
	      }

	      if (main_core.Type.isString(fields.setting_name)) {
	        result.settingName = fields.setting_name;
	      }

	      return result;
	    }
	  }, {
	    key: "validateParams",
	    value: function validateParams(params) {
	      var result = {};

	      try {
	        for (var field in params) {
	          if (!params.hasOwnProperty(field)) {
	            continue;
	          }

	          if (field === 'COMPONENT_ID') {
	            if (main_core.Type.isString(params[field]) && BX.WidgetVue.isComponent(params[field])) {
	              result[field] = params[field];
	            }
	          } else if (field === 'LIKE') {
	            if (params[field] instanceof Array) {
	              result['REACTION'] = {
	                like: params[field].map(function (element) {
	                  return parseInt(element);
	                })
	              };
	            }
	          } else if (field === 'CHAT_LAST_DATE') {
	            result[field] = im_lib_utils.Utils.date.cast(params[field]);
	          } else if (field === 'AVATAR') {
	            if (params[field]) {
	              result[field] = params[field].startsWith('http') ? params[field] : options.host + params[field];
	            }
	          } else if (field === 'NAME') {
	            if (params[field]) {
	              result[field] = params[field];
	            }
	          } else {
	            result[field] = params[field];
	          }
	        }
	      } catch (e) {}

	      var hasResultElements = false;

	      for (var _field in result) {
	        if (!result.hasOwnProperty(_field)) {
	          continue;
	        }

	        hasResultElements = true;
	        break;
	      }

	      return hasResultElements ? result : null;
	    }
	    /* endregion Validation */

	    /* region Internal helpers */

	  }, {
	    key: "prepareNotification",
	    value: function prepareNotification(notification) {
	      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	      var result = this.validate(Object.assign({}, notification));
	      return Object.assign({}, this.getElementState(), result, options);
	    }
	  }, {
	    key: "findItemInArr",
	    value: function findItemInArr(arr, value) {
	      var key = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'id';
	      var result = {};
	      var elementIndex = arr.findIndex(function (element, index) {
	        return element[key] === value;
	      });

	      if (elementIndex !== -1) {
	        result.index = elementIndex;
	        result.element = arr[elementIndex];
	      }

	      return result;
	    }
	  }, {
	    key: "sortByType",
	    value: function sortByType(a, b) {
	      if (a.sectionCode === im_const.NotificationTypesCodes.confirm && b.sectionCode !== im_const.NotificationTypesCodes.confirm) {
	        return -1;
	      } else if (a.sectionCode !== im_const.NotificationTypesCodes.confirm && b.sectionCode === im_const.NotificationTypesCodes.confirm) {
	        return 1;
	      } else {
	        return b.id - a.id;
	      }
	    }
	    /* endregion Internal helpers */

	    /* region Text utils */

	  }, {
	    key: "convertToHtml",
	    value: function convertToHtml() {
	      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	      var _params$text = params.text,
	          text = _params$text === void 0 ? '' : _params$text;
	      text = text.trim();
	      text = text.replace(/\n/gi, '<br />');
	      text = text.replace(/\t/gi, '&nbsp;&nbsp;&nbsp;&nbsp;');
	      text = NotificationsModel.decodeBbCode({
	        text: text
	      });

	      if (im_lib_utils.Utils.platform.isBitrixDesktop()) {
	        text = text.replace(/<a(.*?)>(.*?)<\/a>/ig, function (whole, anchor, text) {
	          return '<a' + anchor.replace('target="_self"', 'target="_blank"') + ' class="bx-im-notifications-item-link">' + text + '</a>';
	        });
	      }

	      return text;
	    }
	  }], [{
	    key: "decodeBbCode",
	    value: function decodeBbCode() {
	      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	      var text = params.text;
	      text = text.replace(/\[url=([^\]]+)\](.*?)\[\/url\]/ig, function (whole, link, text) {
	        var tag = document.createElement('a');
	        tag.href = im_lib_utils.Utils.text.htmlspecialcharsback(link);
	        tag.target = '_blank';
	        tag.text = im_lib_utils.Utils.text.htmlspecialcharsback(text);
	        var allowList = ['http:', 'https:', 'ftp:', 'file:', 'tel:', 'callto:', 'mailto:', 'skype:', 'viber:'];

	        if (allowList.indexOf(tag.protocol) <= -1) {
	          return whole;
	        }

	        return tag.outerHTML;
	      });
	      text = text.replace(/\[LIKE\]/ig, '<span class="bx-smile bx-im-smile-like"></span>');
	      text = text.replace(/\[DISLIKE\]/ig, '<span class="bx-smile bx-im-smile-dislike"></span>');
	      text = text.replace(/\[RATING\=([1-5]{1})\]/ig, function (whole, rating) {
	        // todo: refactor legacy call
	        return BX.MessengerCommon.linesVoteHeadNodes(0, rating, false).outerHTML;
	      });
	      text = text.replace(/\[BR\]/ig, '<br/>');
	      text = text.replace(/\[([buis])\](.*?)\[(\/[buis])\]/ig, function (whole, open, inner, close) {
	        return '<' + open + '>' + inner + '<' + close + '>';
	      });
	      text = text.replace(/\[CHAT=(imol\|)?([0-9]{1,})\](.*?)\[\/CHAT\]/ig, function (whole, openlines, chatId, inner) {
	        chatId = parseInt(chatId);

	        if (chatId <= 0) {
	          return inner;
	        }

	        if (openlines) {
	          return '<span class="bx-im-mention" data-type="OPENLINES" data-value="' + chatId + '">' + inner + '</span>';
	        } else {
	          return '<span class="bx-im-mention" data-type="CHAT" data-value="' + chatId + '">' + inner + '</span>';
	        }
	      });
	      text = text.replace(/\[USER=([0-9]{1,})\](.*?)\[\/USER\]/ig, function (whole, userId, text) {
	        var html = '';
	        userId = parseInt(userId);

	        if (userId > 0 && typeof BXIM != 'undefined') {
	          html = "<span class=\"bx-im-mention ".concat(userId === +BXIM.userId ? 'bx-messenger-ajax-self' : '', "\" data-type=\"USER\" data-value=\"").concat(userId, "\">").concat(text, "</span>");
	        } else {
	          html = text;
	        }

	        return html;
	      });
	      text = text.replace(/\[PCH=([0-9]{1,})\](.*?)\[\/PCH\]/ig, function (whole, historyId, text) {
	        return text;
	      });
	      return text;
	    }
	    /* endregion Text utils */

	  }]);
	  return NotificationsModel;
	}(ui_vue_vuex.WidgetVuexBuilderModel);

	/**
	 * Bitrix Messenger
	 * Call Application model (Vuex Builder model)
	 *
	 * @package bitrix
	 * @subpackage im
	 * @copyright 2001-2020 Bitrix
	 */
	var CallModel = /*#__PURE__*/function (_VuexBuilderModel) {
	  babelHelpers.inherits(CallModel, _VuexBuilderModel);

	  function CallModel() {
	    babelHelpers.classCallCheck(this, CallModel);
	    return babelHelpers.possibleConstructorReturn(this, babelHelpers.getPrototypeOf(CallModel).apply(this, arguments));
	  }

	  babelHelpers.createClass(CallModel, [{
	    key: "getName",
	    value: function getName() {
	      return 'call';
	    }
	  }, {
	    key: "getState",
	    value: function getState() {
	      return {
	        users: {}
	      };
	    }
	  }, {
	    key: "getElementState",
	    value: function getElementState() {
	      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	      return {
	        id: params.id ? params.id : 0,
	        state: im_const.ConferenceUserState.Idle,
	        talking: false,
	        pinned: false,
	        cameraState: false,
	        microphoneState: false,
	        screenState: false,
	        floorRequestState: false
	      };
	    }
	  }, {
	    key: "getGetters",
	    value: function getGetters() {
	      var _this = this;

	      return {
	        getUser: function getUser(state) {
	          return function (userId) {
	            userId = parseInt(userId, 10);

	            if (!state.users[userId]) {
	              return _this.getElementState({
	                id: userId
	              });
	            }

	            return state.users[userId];
	          };
	        },
	        getBlankUser: function getBlankUser(state) {
	          return function (userId) {
	            userId = parseInt(userId, 10);
	            return _this.getElementState({
	              id: userId
	            });
	          };
	        }
	      };
	    }
	  }, {
	    key: "getActions",
	    value: function getActions() {
	      var _this2 = this;

	      return {
	        updateUser: function updateUser(store, payload) {
	          payload.id = parseInt(payload.id, 10);
	          payload.fields = Object.assign({}, _this2.validate(payload.fields));
	          store.commit('updateUser', payload);
	        },
	        unpinUser: function unpinUser(store, payload) {
	          store.commit('unpinUser');
	        }
	      };
	    }
	  }, {
	    key: "getMutations",
	    value: function getMutations() {
	      var _this3 = this;

	      return {
	        updateUser: function updateUser(state, payload) {
	          if (!state.users[payload.id]) {
	            ui_vue.WidgetVue.set(state.users, payload.id, Object.assign(_this3.getElementState(), payload.fields, {
	              id: payload.id
	            }));
	          } else {
	            state.users[payload.id] = Object.assign(state.users[payload.id], payload.fields);
	          }
	        },
	        unpinUser: function unpinUser(state, payload) {
	          var pinnedUser = Object.values(state.users).find(function (user) {
	            return user.pinned === true;
	          });

	          if (pinnedUser) {
	            state.users[pinnedUser.id].pinned = false;
	          }
	        }
	      };
	    }
	  }, {
	    key: "validate",
	    value: function validate(payload) {
	      var result = {};

	      if (main_core.Type.isNumber(payload.id) || main_core.Type.isString(payload.id)) {
	        result.id = parseInt(payload.id, 10);
	      }

	      if (im_const.ConferenceUserState[payload.state]) {
	        result.state = payload.state;
	      }

	      if (main_core.Type.isBoolean(payload.talking)) {
	        result.talking = payload.talking;
	      }

	      if (main_core.Type.isBoolean(payload.pinned)) {
	        result.pinned = payload.pinned;
	      }

	      if (main_core.Type.isBoolean(payload.cameraState)) {
	        result.cameraState = payload.cameraState;
	      }

	      if (main_core.Type.isBoolean(payload.microphoneState)) {
	        result.microphoneState = payload.microphoneState;
	      }

	      if (main_core.Type.isBoolean(payload.screenState)) {
	        result.screenState = payload.screenState;
	      }

	      if (main_core.Type.isBoolean(payload.floorRequestState)) {
	        result.floorRequestState = payload.floorRequestState;
	      }

	      return result;
	    }
	  }, {
	    key: "getStateSaveException",
	    value: function getStateSaveException() {
	      return {
	        users: false
	      };
	    }
	  }]);
	  return CallModel;
	}(ui_vue_vuex.WidgetVuexBuilderModel);

	exports.ApplicationModel = ApplicationModel;
	exports.ConferenceModel = ConferenceModel;
	exports.MessagesModel = MessagesModel;
	exports.DialoguesModel = DialoguesModel;
	exports.UsersModel = UsersModel;
	exports.FilesModel = FilesModel;
	exports.RecentModel = RecentModel;
	exports.NotificationsModel = NotificationsModel;
	exports.CallModel = CallModel;

}((this.BX.Messenger.Model = this.BX.Messenger.Model || {}),BX.Messenger.Lib,BX.Event,BX.Messenger.Lib,BX,BX,BX,BX.Messenger.Const));
 




// file: /bitrix/js/ui/vue/components/audioplayer/dist/audioplayer.bundle.js
(function (exports,main_polyfill_intersectionobserver,ui_vue,main_core_events) {
	'use strict';

	/**
	 * Bitrix UI
	 * Audio player Vue component
	 *
	 * @package bitrix
	 * @subpackage ui
	 * @copyright 2001-2021 Bitrix
	 */

	var _State = Object.freeze({
	  play: 'play',
	  pause: 'pause',
	  stop: 'stop',
	  none: 'none'
	});

	ui_vue.WidgetBitrixVue.component('bx-audioplayer', {
	  props: {
	    id: {
	      "default": 0
	    },
	    src: {
	      "default": ''
	    },
	    autoPlayNext: {
	      "default": true
	    },
	    background: {
	      "default": 'light'
	    }
	  },
	  data: function data() {
	    return {
	      isDark: false,
	      preload: "none",
	      loaded: false,
	      loading: false,
	      playAfterLoad: false,
	      state: _State.none,
	      progress: 0,
	      progressInPixel: 0,
	      seek: 0,
	      timeCurrent: 0,
	      timeTotal: 0
	    };
	  },
	  created: function created() {
	    this.preloadRequestSent = false;
	    this.registeredId = 0;
	    this.registerPlayer(this.id);
	    this.$Bitrix.eventEmitter.subscribe('ui:audioplayer:play', this.onPlay);
	    this.$Bitrix.eventEmitter.subscribe('ui:audioplayer:stop', this.onStop);
	    this.$Bitrix.eventEmitter.subscribe('ui:audioplayer:pause', this.onPause);
	    this.$Bitrix.eventEmitter.subscribe('ui:audioplayer:preload', this.onPreload);
	    this.isDark = this.background === 'dark';
	  },
	  mounted: function mounted() {
	    this.getObserver().observe(this.$refs.body);
	  },
	  beforeDestroy: function beforeDestroy() {
	    this.unregisterPlayer();
	    this.$Bitrix.eventEmitter.unsubscribe('ui:audioplayer:play', this.onPlay);
	    this.$Bitrix.eventEmitter.unsubscribe('ui:audioplayer:stop', this.onStop);
	    this.$Bitrix.eventEmitter.unsubscribe('ui:audioplayer:pause', this.onPause);
	    this.$Bitrix.eventEmitter.unsubscribe('ui:audioplayer:preload', this.onPreload);
	    this.getObserver().unobserve(this.$refs.body);
	  },
	  watch: {
	    id: function id(value) {
	      this.registerPlayer(value);
	    },
	    progress: function progress(value) {
	      if (value > 70) {
	        this.preloadNext();
	      }
	    }
	  },
	  methods: {
	    loadFile: function loadFile() {
	      var play = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

	      if (this.loaded) {
	        return true;
	      }

	      if (this.loading && !play) {
	        return true;
	      }

	      this.preload = 'auto';

	      if (play) {
	        this.loading = true;

	        if (this.source()) {
	          this.source().play();
	        }
	      }

	      return true;
	    },
	    clickToButton: function clickToButton() {
	      if (!this.src) {
	        return false;
	      }

	      if (this.state === _State.play) {
	        this.pause();
	      } else {
	        this.play();
	      }
	    },
	    play: function play() {
	      if (!this.loaded) {
	        this.loadFile(true);
	        return false;
	      }

	      this.source().play();
	    },
	    pause: function pause() {
	      this.source().pause();
	    },
	    stop: function stop() {
	      this.state = _State.stop;
	      this.source().pause();
	    },
	    setPosition: function setPosition(event) {
	      if (!this.loaded) {
	        this.loadFile(true);
	        return false;
	      }

	      var pixelPerPercent = this.$refs.track.offsetWidth / 100;
	      this.setProgress(this.seek / pixelPerPercent, this.seek);

	      if (this.state !== _State.play) {
	        this.state = _State.pause;
	      }

	      this.play();
	      this.source().currentTime = this.timeTotal / 100 * this.progress;
	    },
	    seeking: function seeking(event) {
	      if (!this.loaded) {
	        return false;
	      }

	      this.seek = event.offsetX > 0 ? event.offsetX : 0;
	      return true;
	    },
	    setProgress: function setProgress(percent) {
	      var pixel = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;
	      this.progress = percent;
	      this.progressInPixel = pixel > 0 ? pixel : Math.round(this.$refs.track.offsetWidth / 100 * percent);
	    },
	    formatTime: function formatTime(second) {
	      second = Math.floor(second);
	      var hour = Math.floor(second / 60 / 60);

	      if (hour > 0) {
	        second -= hour * 60 * 60;
	      }

	      var minute = Math.floor(second / 60);

	      if (minute > 0) {
	        second -= minute * 60;
	      }

	      return (hour > 0 ? hour + ':' : '') + (hour > 0 ? minute.toString().padStart(2, "0") + ':' : minute + ':') + second.toString().padStart(2, "0");
	    },
	    registerPlayer: function registerPlayer(id) {
	      var _this = this;

	      if (id <= 0) {
	        return false;
	      }

	      var registry = this.$Bitrix.Data.get('ui-audioplayer-id', []);
	      registry = babelHelpers.toConsumableArray(new Set([].concat(babelHelpers.toConsumableArray(registry), [id]))).filter(function (id) {
	        return id !== _this.registeredId;
	      }).sort(function (a, b) {
	        return a - b;
	      });
	      this.$Bitrix.Data.set('ui-audioplayer-id', registry);
	      this.registeredId = id;
	      return true;
	    },
	    unregisterPlayer: function unregisterPlayer() {
	      var _this2 = this;

	      if (!this.registeredId) {
	        return true;
	      }

	      var registry = this.$Bitrix.Data.get('ui-audioplayer-id', []).filter(function (id) {
	        return id !== _this2.registeredId;
	      });
	      this.$Bitrix.Data.set('ui-audioplayer-id', registry);
	      this.registeredId = 0;
	      return true;
	    },
	    playNext: function playNext() {
	      var _this3 = this;

	      if (!this.registeredId || !this.autoPlayNext) {
	        return false;
	      }

	      var nextId = this.$Bitrix.Data.get('ui-audioplayer-id', []).filter(function (id) {
	        return id > _this3.registeredId;
	      }).slice(0, 1)[0];

	      if (nextId) {
	        this.$Bitrix.eventEmitter.emit('ui:audioplayer:play', {
	          id: nextId,
	          start: true
	        });
	      }

	      return true;
	    },
	    preloadNext: function preloadNext() {
	      var _this4 = this;

	      if (this.preloadRequestSent) {
	        return true;
	      }

	      if (!this.registeredId || !this.autoPlayNext) {
	        return false;
	      }

	      this.preloadRequestSent = true;
	      var nextId = this.$Bitrix.Data.get('ui-audioplayer-id', []).filter(function (id) {
	        return id > _this4.registeredId;
	      }).slice(0, 1)[0];

	      if (nextId) {
	        this.$Bitrix.eventEmitter.emit('ui:audioplayer:preload', {
	          id: nextId
	        });
	      }

	      return true;
	    },
	    onPlay: function onPlay(event) {
	      var data = event.getData();

	      if (data.id !== this.id) {
	        return false;
	      }

	      if (data.start) {
	        this.stop();
	      }

	      this.play();
	    },
	    onStop: function onStop(event) {
	      var data = event.getData();

	      if (data.initiator === this.id) {
	        return false;
	      }

	      this.stop();
	    },
	    onPause: function onPause(event) {
	      var data = event.getData();

	      if (data.initiator === this.id) {
	        return false;
	      }

	      this.pause();
	    },
	    onPreload: function onPreload(event) {
	      var data = event.getData();

	      if (data.id !== this.id) {
	        return false;
	      }

	      this.loadFile();
	    },
	    source: function source() {
	      return this.$refs.source;
	    },
	    audioEventRouter: function audioEventRouter(eventName, event) {
	      if (eventName === 'durationchange' || eventName === 'loadeddata' || eventName === 'loadedmetadata') {
	        this.timeTotal = this.source().duration;
	      } else if (eventName === 'abort' || eventName === 'error') {
	        console.error('BxAudioPlayer: load failed', this.id, event);
	        this.loading = false;
	        this.state = _State.none;
	        this.timeTotal = 0;
	        this.preload = 'none';
	      } else if (eventName === 'canplaythrough') {
	        this.loading = false;
	        this.loaded = true;
	      } else if (eventName === 'timeupdate') {
	        if (!this.source()) {
	          return;
	        }

	        this.timeCurrent = this.source().currentTime;
	        this.setProgress(Math.round(100 / this.timeTotal * this.timeCurrent));

	        if (this.state === _State.play && this.timeCurrent >= this.timeTotal) {
	          this.playNext();
	        }
	      } else if (eventName === 'pause') {
	        if (this.state !== _State.stop) {
	          this.state = _State.pause;
	        }
	      } else if (eventName === 'play') {
	        this.state = _State.play;

	        if (this.state === _State.stop) {
	          this.progress = 0;
	          this.timeCurrent = 0;
	        }

	        if (this.id > 0) {
	          this.$Bitrix.eventEmitter.emit('ui:audioplayer:pause', {
	            initiator: this.id
	          });
	        }
	      }
	    },
	    getObserver: function getObserver() {
	      var _this5 = this;

	      if (this.observer) {
	        return this.observer;
	      }

	      this.observer = new IntersectionObserver(function (entries, observer) {
	        entries.forEach(function (entry) {
	          if (entry.isIntersecting) {
	            if (_this5.preload === "none") {
	              _this5.preload = "metadata";

	              _this5.observer.unobserve(entry.target);
	            }
	          }
	        });
	      }, {
	        threshold: [0, 1]
	      });
	      return this.observer;
	    }
	  },
	  computed: {
	    State: function State() {
	      return _State;
	    },
	    seekPosition: function seekPosition() {
	      if (!this.loaded && !this.seek || this.isMobile) {
	        return 'display: none';
	      }

	      return "left: ".concat(this.seek, "px;");
	    },
	    progressPosition: function progressPosition() {
	      if (!this.loaded || this.state === _State.none) {
	        return "width: 100%;";
	      }

	      return "width: ".concat(this.progressInPixel, "px;");
	    },
	    labelTime: function labelTime() {
	      if (!this.loaded && !this.timeTotal) {
	        return '--:--';
	      }

	      var time;

	      if (this.state === _State.play) {
	        time = this.timeTotal - this.timeCurrent;
	      } else {
	        time = this.timeTotal;
	      }

	      return this.formatTime(time);
	    },
	    isMobile: function isMobile() {
	      var UA = navigator.userAgent.toLowerCase();
	      return UA.includes('android') || UA.includes('iphone') || UA.includes('ipad') || UA.includes('bitrixmobile');
	    }
	  },
	  template: "\n\t\t<div :class=\"['ui-vue-audioplayer-container', {\n\t\t\t\t'ui-vue-audioplayer-container-dark': isDark,\n\t\t\t\t'ui-vue-audioplayer-container-mobile': isMobile,\n\t\t\t}]\" ref=\"body\">\n\t\t\t<div class=\"ui-vue-audioplayer-controls-container\">\n\t\t\t\t<button :class=\"['ui-vue-audioplayer-control', {\n\t\t\t\t\t'ui-vue-audioplayer-control-loader': loading,\n\t\t\t\t\t'ui-vue-audioplayer-control-play': !loading && state !== State.play,\n\t\t\t\t\t'ui-vue-audioplayer-control-pause': !loading && state === State.play,\n\t\t\t\t}]\" @click=\"clickToButton\"></button>\n\t\t\t</div>\n\t\t\t<div class=\"ui-vue-audioplayer-timeline-container\">\n\t\t\t\t<div class=\"ui-vue-audioplayer-track-container\" @click=\"setPosition\" ref=\"track\">\n\t\t\t\t\t<div class=\"ui-vue-audioplayer-track-mask\"></div>\n\t\t\t\t\t<div class=\"ui-vue-audioplayer-track\" :style=\"progressPosition\"></div>\n\t\t\t\t\t<div class=\"ui-vue-audioplayer-track-seek\" :style=\"seekPosition\"></div>\n\t\t\t\t\t<div class=\"ui-vue-audioplayer-track-event\" @mousemove=\"seeking\"></div>\n\t\t\t\t</div>\n\t\t\t\t<div class=\"ui-vue-audioplayer-timers-container\">\n\t\t\t\t\t<div class=\"ui-vue-audioplayer-time-current\">{{labelTime}}</div>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t\t<audio v-if=\"src\" :src=\"src\" class=\"ui-vue-audioplayer-source\" ref=\"source\" :preload=\"preload\"\n\t\t\t\t@abort=\"audioEventRouter('abort', $event)\"\n\t\t\t\t@error=\"audioEventRouter('error', $event)\"\n\t\t\t\t@suspend=\"audioEventRouter('suspend', $event)\"\n\t\t\t\t@canplay=\"audioEventRouter('canplay', $event)\"\n\t\t\t\t@canplaythrough=\"audioEventRouter('canplaythrough', $event)\"\n\t\t\t\t@durationchange=\"audioEventRouter('durationchange', $event)\"\n\t\t\t\t@loadeddata=\"audioEventRouter('loadeddata', $event)\"\n\t\t\t\t@loadedmetadata=\"audioEventRouter('loadedmetadata', $event)\"\n\t\t\t\t@timeupdate=\"audioEventRouter('timeupdate', $event)\"\n\t\t\t\t@play=\"audioEventRouter('play', $event)\"\n\t\t\t\t@playing=\"audioEventRouter('playing', $event)\"\n\t\t\t\t@pause=\"audioEventRouter('pause', $event)\"\n\t\t\t></audio>\n\t\t</div>\n\t"
	});

}((this.window = this.window || {}),BX,BX,BX.Event));
 




// file: /bitrix/js/ui/vue/components/socialvideo/dist/socialvideo.bundle.js
(function (exports,ui_vue_directives_lazyload,main_polyfill_intersectionobserver,ui_vue,main_core_events) {
	'use strict';

	/**
	 * Bitrix UI
	 * Social Video Vue component
	 *
	 * @package bitrix
	 * @subpackage ui
	 * @copyright 2001-2021 Bitrix
	 */

	var _State = Object.freeze({
	  play: 'play',
	  pause: 'pause',
	  stop: 'stop',
	  none: 'none'
	});

	ui_vue.WidgetBitrixVue.component('bx-socialvideo', {
	  props: {
	    id: {
	      "default": 0
	    },
	    src: {
	      "default": ''
	    },
	    preview: {
	      "default": ''
	    },
	    autoplay: {
	      "default": true
	    },
	    containerClass: {
	      "default": null
	    },
	    containerStyle: {
	      "default": null
	    },
	    elementStyle: {
	      "default": null
	    },
	    showControls: {
	      "default": true
	    }
	  },
	  data: function data() {
	    return {
	      preload: "none",
	      previewLoaded: false,
	      loaded: false,
	      loading: false,
	      playAfterLoad: false,
	      enterFullscreen: false,
	      playBeforeMute: 2,
	      state: _State.none,
	      progress: 0,
	      timeCurrent: 0,
	      timeTotal: 0,
	      muteFlag: true
	    };
	  },
	  created: function created() {
	    if (!this.preview) {
	      this.previewLoaded = true;
	      this.preload = 'metadata';
	    }

	    this.$Bitrix.eventEmitter.subscribe('ui:socialvideo:unmute', this.onUnmute);
	  },
	  mounted: function mounted() {
	    this.getObserver().observe(this.$refs.body);
	  },
	  beforeDestroy: function beforeDestroy() {
	    this.$Bitrix.eventEmitter.unsubscribe('ui:socialvideo:unmute', this.onUnmute);
	    this.getObserver().unobserve(this.$refs.body);
	  },
	  watch: {
	    id: function id(value) {
	      this.registeredId = value;
	    }
	  },
	  methods: {
	    loadFile: function loadFile() {
	      var play = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

	      if (this.loaded) {
	        return true;
	      }

	      if (this.loading) {
	        return true;
	      }

	      this.preload = 'auto';
	      this.loading = true;
	      this.playAfterLoad = play;
	      return true;
	    },
	    clickToButton: function clickToButton(event) {
	      if (!this.src) {
	        return false;
	      }

	      if (this.state === _State.play) {
	        this.getObserver().unobserve(this.$refs.body);
	        this.pause();
	      } else {
	        this.play();
	      }

	      event.stopPropagation();
	    },
	    clickToMute: function clickToMute() {
	      if (!this.src) {
	        return false;
	      }

	      if (!this.muteFlag) {
	        this.mute();
	      } else {
	        this.unmute();
	      }

	      event.stopPropagation();
	    },
	    click: function click(event) {
	      if (this.autoPlayDisabled) {
	        this.play();
	        event.stopPropagation();
	        return false;
	      }

	      if (this.isMobile) {
	        if (this.source().webkitEnterFullscreen) {
	          this.unmute();
	          this.enterFullscreen = true;
	          this.source().webkitEnterFullscreen();
	        } else if (this.source().requestFullscreen) {
	          this.unmute();
	          this.enterFullscreen = true;
	          this.source().requestFullscreen();
	        } else {
	          this.$emit('click', event);
	        }
	      } else {
	        this.$emit('click', event);
	      }

	      event.stopPropagation();
	    },
	    play: function play(event) {
	      if (!this.loaded) {
	        this.loadFile(true);
	        return false;
	      }

	      if (!this.source()) {
	        return false;
	      }

	      this.source().play();
	    },
	    pause: function pause() {
	      if (!this.source()) {
	        return false;
	      }

	      this.playAfterLoad = false;
	      this.source().pause();
	    },
	    stop: function stop() {
	      if (!this.source()) {
	        return false;
	      }

	      this.state = _State.stop;
	      this.source().pause();
	    },
	    mute: function mute() {
	      if (!this.source()) {
	        return false;
	      }

	      this.muteFlag = true;
	      this.playBeforeMute = 2;
	      this.source().muted = true;
	    },
	    unmute: function unmute() {
	      if (!this.source()) {
	        return false;
	      }

	      this.muteFlag = false;
	      this.source().muted = false;

	      if (this.id > 0) {
	        this.$Bitrix.eventEmitter.emit('ui:socialvideo:unmute', {
	          initiator: this.id
	        });
	      }
	    },
	    setProgress: function setProgress(percent) {
	      this.progress = percent;
	    },
	    formatTime: function formatTime(second) {
	      second = Math.floor(second);
	      var hour = Math.floor(second / 60 / 60);

	      if (hour > 0) {
	        second -= hour * 60 * 60;
	      }

	      var minute = Math.floor(second / 60);

	      if (minute > 0) {
	        second -= minute * 60;
	      }

	      return (hour > 0 ? hour + ':' : '') + (hour > 0 ? minute.toString().padStart(2, "0") + ':' : minute + ':') + second.toString().padStart(2, "0");
	    },
	    onUnmute: function onUnmute(event) {
	      event = event.getData();

	      if (event.initiator === this.id) {
	        return false;
	      }

	      this.mute();
	    },
	    source: function source() {
	      return this.$refs.source;
	    },
	    videoEventRouter: function videoEventRouter(eventName, event) {
	      if (eventName === 'durationchange' || eventName === 'loadeddata') {
	        if (!this.source()) {
	          return false;
	        }

	        this.timeTotal = this.source().duration;
	      } else if (eventName === 'loadedmetadata') {
	        if (!this.source()) {
	          return false;
	        }

	        this.timeTotal = this.source().duration;
	        this.loaded = true;

	        if (this.playAfterLoad) {
	          this.play();
	        }
	      } else if (eventName === 'abort' || eventName === 'error') {
	        console.error('BxSocialVideo: load failed', this.id, event);
	        this.loading = false;
	        this.state = _State.none;
	        this.timeTotal = 0;
	        this.preload = 'none';
	      } else if (eventName === 'canplaythrough') {
	        this.loading = false;
	        this.loaded = true;

	        if (this.playAfterLoad) {
	          this.play();
	        }
	      } else if (eventName === 'volumechange') {
	        if (!this.source()) {
	          return false;
	        }

	        if (this.source().muted) {
	          this.mute();
	        } else {
	          this.unmute();
	        }
	      } else if (eventName === 'timeupdate') {
	        if (!this.source()) {
	          return false;
	        }

	        this.timeCurrent = this.source().currentTime;

	        if (!this.muteFlag && !this.enterFullscreen && this.timeCurrent === 0) {
	          if (this.playBeforeMute <= 0) {
	            this.mute();
	          }

	          this.playBeforeMute -= 1;
	        }

	        this.setProgress(Math.round(100 / this.timeTotal * this.timeCurrent));
	      } else if (eventName === 'pause') {
	        if (this.state !== _State.stop) {
	          this.state = _State.pause;
	        }

	        if (this.enterFullscreen) {
	          this.enterFullscreen = false;
	          this.mute();
	          this.play();
	        }
	      } else if (eventName === 'play') {
	        this.state = _State.play;

	        if (this.state === _State.stop) {
	          this.progress = 0;
	          this.timeCurrent = 0;
	        }

	        if (this.enterFullscreen) {
	          this.enterFullscreen = false;
	        }
	      }
	    },
	    getObserver: function getObserver() {
	      var _this = this;

	      if (this.observer) {
	        return this.observer;
	      }

	      this.observer = new IntersectionObserver(function (entries, observer) {
	        if (_this.autoPlayDisabled) {
	          return false;
	        }

	        entries.forEach(function (entry) {
	          if (entry.isIntersecting) {
	            _this.play();
	          } else {
	            _this.pause();
	          }
	        });
	      }, {
	        threshold: [0, 1]
	      });
	      return this.observer;
	    },
	    lazyLoadCallback: function lazyLoadCallback(element) {
	      this.previewLoaded = element.state === 'success';
	    }
	  },
	  computed: {
	    State: function State() {
	      return _State;
	    },
	    autoPlayDisabled: function autoPlayDisabled() {
	      return !this.autoplay && this.state === _State.none;
	    },
	    showStartButton: function showStartButton() {
	      return this.autoPlayDisabled && this.previewLoaded;
	    },
	    showInterface: function showInterface() {
	      return this.previewLoaded && !this.showStartButton;
	    },
	    labelTime: function labelTime() {
	      if (!this.loaded && !this.timeTotal) {
	        return '--:--';
	      }

	      var time;

	      if (this.state === _State.play) {
	        time = this.timeTotal - this.timeCurrent;
	      } else {
	        time = this.timeTotal;
	      }

	      return this.formatTime(time);
	    },
	    isMobile: function isMobile() {
	      var UA = navigator.userAgent.toLowerCase();
	      return UA.includes('android') || UA.includes('iphone') || UA.includes('ipad') || UA.includes('bitrixmobile');
	    }
	  },
	  template: "\n\t\t<div :class=\"['ui-vue-socialvideo', containerClass, {\n\t\t\t\t'ui-vue-socialvideo-mobile': isMobile,\n\t\t\t}]\" :style=\"containerStyle\" @click=\"click\">\n\t\t\t<transition name=\"ui-vue-socialvideo-animation-fade\">\n\t\t\t\t<div v-if=\"showStartButton && showControls\" class=\"ui-vue-socialvideo-button-start\">\n\t\t\t\t\t<span class=\"ui-vue-socialvideo-button-start-icon\"></span>\n\t\t\t\t</div>\n\t\t\t</transition>\n\t\t\t<transition name=\"ui-vue-socialvideo-animation-fade\">\n\t\t\t\t<div v-if=\"showInterface && showControls\" class=\"ui-vue-socialvideo-overlay-container\">\n\t\t\t\t\t<div class=\"ui-vue-socialvideo-controls-container\" @click=\"clickToButton\">\n\t\t\t\t\t\t<button :class=\"['ui-vue-socialvideo-control', {\n\t\t\t\t\t\t\t'ui-vue-socialvideo-control-loader': loading,\n\t\t\t\t\t\t\t'ui-vue-socialvideo-control-play': !loading && state !== State.play,\n\t\t\t\t\t\t\t'ui-vue-socialvideo-control-pause': !loading && state === State.play,\n\t\t\t\t\t\t}]\"></button>\n\t\t\t\t\t</div>\n\t\t\t\t\t<div class=\"ui-vue-socialvideo-info-container\" @click=\"clickToMute\">\n\t\t\t\t\t\t<span class=\"ui-vue-socialvideo-time-current\">{{labelTime}}</span>\n\t\t\t\t\t\t<span :class=\"['ui-vue-socialvideo-sound', {\n\t\t\t\t\t\t\t'ui-vue-socialvideo-sound-on': state !== State.none && !muteFlag,\n\t\t\t\t\t\t\t'ui-vue-socialvideo-sound-off': state !== State.none && muteFlag\n\t\t\t\t\t\t}]\"></span>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t</transition>\n\t\t\t<div v-if=\"!preview\" class=\"ui-vue-socialvideo-background\" :style=\"{position: (src? 'absolute': 'relative')}\"></div>\n\t\t\t<div class=\"ui-vue-socialvideo-container\" ref=\"body\">\n\t\t\t\t<img \n\t\t\t\t\tv-bx-lazyload=\"{callback: lazyLoadCallback}\"\n\t\t\t\t\tdata-lazyload-dont-hide\n\t\t\t\t\tv-if=\"preview\"\n\t\t\t\t\tclass=\"ui-vue-socialvideo-image-source\"\n\t\t\t\t\t:data-lazyload-src=\"preview\"\n\t\t\t\t\t:style=\"{position: (src? 'absolute': 'relative'), ...elementStyle}\"\n\t\t\t\t/>\n\t\t\t\t<video \n\t\t\t\t\tv-if=\"src\" :src=\"src\" \n\t\t\t\t\tclass=\"ui-vue-socialvideo-source\" \n\t\t\t\t\tref=\"source\"\n\t\t\t\t\t:preload=\"preload\" \n\t\t\t\t\tplaysinline\n\t\t\t\t\tloop \n\t\t\t\t\tmuted\n\t\t\t\t\t:style=\"{opacity: (loaded? 1: 0), ...elementStyle}\"\n\t\t\t\t\t@abort=\"videoEventRouter('abort', $event)\"\n\t\t\t\t\t@error=\"videoEventRouter('error', $event)\"\n\t\t\t\t\t@suspend=\"videoEventRouter('suspend', $event)\"\n\t\t\t\t\t@canplay=\"videoEventRouter('canplay', $event)\"\n\t\t\t\t\t@canplaythrough=\"videoEventRouter('canplaythrough', $event)\"\n\t\t\t\t\t@durationchange=\"videoEventRouter('durationchange', $event)\"\n\t\t\t\t\t@loadeddata=\"videoEventRouter('loadeddata', $event)\"\n\t\t\t\t\t@loadedmetadata=\"videoEventRouter('loadedmetadata', $event)\"\n\t\t\t\t\t@volumechange=\"videoEventRouter('volumechange', $event)\"\n\t\t\t\t\t@timeupdate=\"videoEventRouter('timeupdate', $event)\"\n\t\t\t\t\t@play=\"videoEventRouter('play', $event)\"\n\t\t\t\t\t@playing=\"videoEventRouter('playing', $event)\"\n\t\t\t\t\t@pause=\"videoEventRouter('pause', $event)\"\n\t\t\t\t></video>\n\t\t\t</div>\n\t\t</div>\t\n\t"
	});

}((this.window = this.window || {}),window,BX,BX,BX.Event));
 




// file: /bitrix/js/im/view/element/media/dist/media.bundle.js
(function (exports,ui_progressbarjs_uploader,ui_vue_vuex,im_model,im_const,ui_vue_components_audioplayer,ui_vue_directives_lazyload,ui_icons,ui_vue_components_socialvideo,im_lib_utils,ui_vue) {
	'use strict';

	function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { babelHelpers.defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
	ui_vue.WidgetBitrixVue.component('bx-im-view-element-file', {
	  /*
	   * @emits 'uploadCancel' {file: object, event: MouseEvent}
	   */
	  mounted: function mounted() {
	    this.createProgressbar();
	  },
	  beforeDestroy: function beforeDestroy() {
	    this.removeProgressbar();
	  },
	  props: {
	    userId: {
	      "default": 0
	    },
	    messageType: {
	      "default": im_const.MessageType.self
	    },
	    file: {
	      type: Object,
	      "default": im_model.FilesModel.create().getElementState
	    }
	  },
	  methods: {
	    download: function download(file) {
	      if (file.progress !== 100) {
	        return false;
	      }

	      if (BX.UI && BX.UI.Viewer && Object.keys(file.viewerAttrs).length > 0) {
	        return false;
	      }

	      if (file.type === im_const.FileType.image && file.urlShow) {
	        if (im_lib_utils.Utils.platform.isBitrixMobile()) {
	          BXMobileApp.UI.Photo.show({
	            photos: this.files.collection[this.application.dialog.chatId].filter(function (file) {
	              return file.type === 'image';
	            }).map(function (file) {
	              return {
	                url: file.urlShow.replace('bxhttp', 'http')
	              };
	            }).reverse(),
	            default_photo: file.urlShow.replace('bxhttp', 'http')
	          });
	        } else {
	          window.open(file.urlShow, '_blank');
	        }
	      } else if (file.type === im_const.FileType.video && file.urlShow) {
	        if (im_lib_utils.Utils.platform.isBitrixMobile()) {
	          app.openDocument({
	            url: file.urlShow,
	            name: file.name
	          });
	        } else {
	          window.open(file.urlShow, '_blank');
	        }
	      } else if (file.urlDownload) {
	        if (im_lib_utils.Utils.platform.isBitrixMobile()) {
	          app.openDocument({
	            url: file.urlDownload,
	            name: file.name
	          });
	        } else {
	          window.open(file.urlDownload, '_blank');
	        }
	      } else {
	        if (im_lib_utils.Utils.platform.isBitrixMobile()) {
	          app.openDocument({
	            url: file.urlShow,
	            name: file.name
	          });
	        } else {
	          window.open(file.urlShow, '_blank');
	        }
	      }
	    },
	    createProgressbar: function createProgressbar() {
	      var _this = this;

	      if (this.uploader) {
	        return true;
	      }

	      if (this.file.progress === 100) {
	        return false;
	      }

	      var blurElement = undefined;

	      if (this.file.progress < 0 || this.file.type !== im_const.FileType.image && this.file.type !== im_const.FileType.video) {
	        blurElement = false;
	      }

	      this.uploader = new ui_progressbarjs_uploader.Uploader({
	        container: this.$refs.container,
	        blurElement: blurElement,
	        direction: this.$refs.container.offsetHeight > 54 ? ui_progressbarjs_uploader.Uploader.direction.vertical : ui_progressbarjs_uploader.Uploader.direction.horizontal,
	        icon: this.file.progress < 0 ? ui_progressbarjs_uploader.Uploader.icon.cloud : ui_progressbarjs_uploader.Uploader.icon.cancel,
	        sizes: {
	          circle: this.$refs.container.offsetHeight > 54 ? 54 : 38,
	          progress: this.$refs.container.offsetHeight > 54 ? 4 : 8
	        },
	        labels: {
	          loading: this.localize['IM_MESSENGER_ELEMENT_FILE_UPLOAD_LOADING'],
	          completed: this.localize['IM_MESSENGER_ELEMENT_FILE_UPLOAD_COMPLETED'],
	          canceled: this.localize['IM_MESSENGER_ELEMENT_FILE_UPLOAD_CANCELED'],
	          cancelTitle: this.localize['IM_MESSENGER_ELEMENT_FILE_UPLOAD_CANCEL_TITLE'],
	          megabyte: this.localize['IM_MESSENGER_ELEMENT_FILE_SIZE_MB']
	        },
	        cancelCallback: this.file.progress < 0 ? null : function (event) {
	          _this.$emit('uploadCancel', {
	            file: _this.file,
	            event: event
	          });
	        },
	        destroyCallback: function destroyCallback() {
	          if (_this.uploader) {
	            _this.uploader = null;
	          }
	        }
	      });
	      this.uploader.start();

	      if (this.file.size && this.file.size / 1024 / 1024 <= 2 || this.$refs.container.offsetHeight <= 54 && this.$refs.container.offsetWidth < 240) {
	        this.uploader.setProgressTitleVisibility(false);
	      }

	      this.updateProgressbar();
	      return true;
	    },
	    updateProgressbar: function updateProgressbar() {
	      if (!this.uploader) {
	        var result = this.createProgressbar();

	        if (!result) {
	          return false;
	        }
	      }

	      if (this.file.status === im_const.FileStatus.error) {
	        this.uploader.setProgress(0);
	        this.uploader.setCancelDisable(false);
	        this.uploader.setIcon(ui_progressbarjs_uploader.Uploader.icon.error);
	        this.uploader.setProgressTitle(this.localize['IM_MESSENGER_ELEMENT_FILE_UPLOAD_ERROR']);
	      } else if (this.file.status === im_const.FileStatus.wait) {
	        this.uploader.setProgress(this.file.progress > 5 ? this.file.progress : 5);
	        this.uploader.setCancelDisable(true);
	        this.uploader.setIcon(ui_progressbarjs_uploader.Uploader.icon.cloud);
	        this.uploader.setProgressTitle(this.localize['IM_MESSENGER_ELEMENT_FILE_UPLOAD_SAVING']);
	      } else if (this.file.progress === 100) {
	        this.uploader.setProgress(100);
	      } else if (this.file.progress === -1) {
	        this.uploader.setProgress(10);
	        this.uploader.setProgressTitle(this.localize['IM_MESSENGER_ELEMENT_FILE_UPLOAD_WAITING']);
	      } else {
	        if (this.file.progress === 0) {
	          this.uploader.setIcon(ui_progressbarjs_uploader.Uploader.icon.cancel);
	        }

	        var progress = this.file.progress > 5 ? this.file.progress : 5;
	        this.uploader.setProgress(progress);

	        if (this.file.size / 1024 / 1024 <= 2) {
	          this.uploader.setProgressTitle(this.localize['IM_MESSENGER_ELEMENT_FILE_UPLOAD_LOADING']);
	        } else {
	          this.uploader.setByteSent(this.file.size / 100 * this.file.progress, this.file.size);
	        }
	      }
	    },
	    removeProgressbar: function removeProgressbar() {
	      if (!this.uploader) {
	        return true;
	      }

	      this.uploader.destroy(false);
	      return true;
	    }
	  },
	  computed: _objectSpread({
	    FileStatus: function FileStatus() {
	      return im_const.FileStatus;
	    },
	    localize: function localize() {
	      return ui_vue.WidgetBitrixVue.getFilteredPhrases('IM_MESSENGER_ELEMENT_FILE_', this);
	    },
	    fileName: function fileName() {
	      var maxLength = 70;

	      if (this.file.name.length < maxLength) {
	        return this.file.name;
	      }

	      var endWordLength = 10;
	      var secondPart = this.file.name.substring(this.file.name.length - 1 - (this.file.extension.length + 1 + endWordLength));
	      var firstPart = this.file.name.substring(0, maxLength - secondPart.length - 3);
	      return firstPart.trim() + '...' + secondPart.trim();
	    },
	    fileSize: function fileSize() {
	      var size = this.file.size;

	      if (size <= 0) {
	        return '&nbsp;';
	      }

	      var sizes = ["BYTE", "KB", "MB", "GB", "TB"];
	      var position = 0;

	      while (size >= 1024 && position < 4) {
	        size /= 1024;
	        position++;
	      }

	      return Math.round(size) + " " + this.localize['IM_MESSENGER_ELEMENT_FILE_SIZE_' + sizes[position]];
	    },
	    uploadProgress: function uploadProgress() {
	      return this.file.status + ' ' + this.file.progress;
	    }
	  }, ui_vue_vuex.WidgetVuex.mapState({
	    application: function application(state) {
	      return state.application;
	    },
	    files: function files(state) {
	      return state.files;
	    }
	  })),
	  watch: {
	    uploadProgress: function uploadProgress() {
	      this.updateProgressbar();
	    }
	  },
	  template: "\n\t\t<div class=\"bx-im-element-file\" @click=\"download(file, $event)\" ref=\"container\">\n\t\t\t<div class=\"bx-im-element-file-icon\">\n\t\t\t\t<div :class=\"['ui-icon', 'ui-icon-file-'+file.icon]\"><i></i></div>\n\t\t\t</div>\n\t\t\t<div class=\"bx-im-element-file-block\">\n\t\t\t\t<div class=\"bx-im-element-file-name\" :title=\"file.name\">\n\t\t\t\t\t{{fileName}}\n\t\t\t\t</div>\n\t\t\t\t<div class=\"bx-im-element-file-size\" v-html=\"fileSize\"></div>\n\t\t\t</div>\n\t\t</div>\n\t"
	});

	/**
	 * Bitrix Messenger
	 * File element Vue component
	 *
	 * @package bitrix
	 * @subpackage im
	 * @copyright 2001-2019 Bitrix
	 */
	ui_vue.WidgetVue.cloneComponent('bx-im-view-element-file-audio', 'bx-im-view-element-file', {
	  computed: {
	    background: function background() {
	      return this.messageType === im_const.MessageType.self ? 'dark' : 'light';
	    }
	  },
	  template: "\n\t\t<div :class=\"['bx-im-element-file-audio', 'bx-im-element-file-audio-'+messageType]\" ref=\"container\">\n\t\t\t<bx-audioplayer :id=\"file.id\" :src=\"file.urlShow\" :background=\"background\"/>\n\t\t</div>\t\n\t"
	});

	/**
	 * Bitrix Messenger
	 * File element Vue component
	 *
	 * @package bitrix
	 * @subpackage im
	 * @copyright 2001-2019 Bitrix
	 */
	ui_vue.WidgetVue.cloneComponent('bx-im-view-element-file-image', 'bx-im-view-element-file', {
	  methods: {
	    getImageSize: function getImageSize(width, height, maxWidth) {
	      var aspectRatio;

	      if (width > maxWidth) {
	        aspectRatio = maxWidth / width;
	      } else {
	        aspectRatio = 1;
	      }

	      return {
	        width: width * aspectRatio,
	        height: height * aspectRatio
	      };
	    }
	  },
	  computed: {
	    styleFileSizes: function styleFileSizes() {
	      var sizes = this.getImageSize(this.file.image.width, this.file.image.height, 280);
	      return {
	        width: sizes.width + 'px',
	        height: sizes.height + 'px',
	        backgroundSize: sizes.width < 100 || sizes.height < 100 ? 'contain' : 'initial'
	      };
	    },
	    styleBoxSizes: function styleBoxSizes() {
	      if (parseInt(this.styleFileSizes.height) <= 280) {
	        return {};
	      }

	      return {
	        height: '280px'
	      };
	    },
	    fileSource: function fileSource() {
	      return this.file.urlPreview;
	    }
	  },
	  template: "\n\t\t<div class=\"bx-im-element-file-image\" @click=\"download(file, $event)\" :style=\"styleBoxSizes\" ref=\"container\">\n\t\t\t<img v-bx-lazyload\n\t\t\t\tclass=\"bx-im-element-file-image-source\"\n\t\t\t\t:data-lazyload-src=\"fileSource\"\n\t\t\t\t:title=\"$Bitrix.Loc.getMessage('IM_MESSENGER_ELEMENT_FILE_SHOW_TITLE').replace('#NAME#', file.name).replace('#SIZE#', fileSize)\"\n\t\t\t\t:style=\"styleFileSizes\"\n\t\t\t\t:data-viewer=\"file.viewerAttrs.viewer === null\"\n\t\t\t\t:data-viewer-type=\"file.viewerAttrs.viewerType? file.viewerAttrs.viewerType: false\"\n\t\t\t\t:data-src=\"file.viewerAttrs.src? file.viewerAttrs.src: false\"\n\t\t\t\t:data-viewer-group-by=\"file.viewerAttrs.viewerGroupBy? file.viewerAttrs.viewerGroupBy: false\"\n\t\t\t\t:data-title=\"file.viewerAttrs.title? file.viewerAttrs.title: false\"\n\t\t\t\t:data-actions=\"file.viewerAttrs.actions? file.viewerAttrs.actions: false\"\n\t\t\t/>\n\t\t</div>\n\t"
	});

	/**
	 * Bitrix Messenger
	 * File element Vue component
	 *
	 * @package bitrix
	 * @subpackage im
	 * @copyright 2001-2019 Bitrix
	 */
	ui_vue.WidgetVue.cloneComponent('bx-im-view-element-file-video', 'bx-im-view-element-file', {
	  methods: {
	    getImageSize: function getImageSize(width, height, maxWidth) {
	      var aspectRatio;

	      if (width > maxWidth) {
	        aspectRatio = maxWidth / width;
	      } else {
	        aspectRatio = 1;
	      }

	      return {
	        width: width * aspectRatio,
	        height: height * aspectRatio
	      };
	    }
	  },
	  computed: {
	    isSafari: function isSafari() {
	      return im_lib_utils.Utils.browser.isSafari() || im_lib_utils.Utils.platform.isBitrixMobile();
	    },
	    styleBoxSizes: function styleBoxSizes() {
	      if (parseInt(this.styleVideoSizes.height) <= 280) {
	        return {};
	      }

	      return {
	        height: '280px'
	      };
	    },
	    styleVideoSizes: function styleVideoSizes() {
	      if (!this.file.image) {
	        return {};
	      }

	      var sizes = this.getImageSize(this.file.image.width, this.file.image.height, 280);
	      return {
	        width: sizes.width + 'px',
	        height: sizes.height + 'px',
	        backgroundSize: sizes.width < 100 || sizes.height < 100 ? 'contain' : 'initial'
	      };
	    },
	    autoplay: function autoplay() {
	      return this.file.size < 5000000 && this.application.options.autoplayVideo;
	    }
	  },
	  template: "\n\t\t<div :class=\"['bx-im-element-file-video', {'bx-im-element-file-video-safari': isSafari}]\" :style=\"styleBoxSizes\" ref=\"container\">\n\t\t\t<bx-socialvideo \n\t\t\t\t:id=\"file.id\" \n\t\t\t\t:src=\"file.urlShow\" \n\t\t\t\t:preview=\"file.urlPreview\" \n\t\t\t\t:containerStyle=\"styleBoxSizes\"\n\t\t\t\t:elementStyle=\"styleVideoSizes\"\n\t\t\t\t:autoplay=\"autoplay\"\n\t\t\t\t:showControls=\"!file.viewerAttrs.viewerType\"\n\t\t\t\t:data-viewer=\"file.viewerAttrs.viewer === null\"\n\t\t\t\t:data-viewer-type=\"file.viewerAttrs.viewerType? file.viewerAttrs.viewerType: false\"\n\t\t\t\t:data-src=\"file.viewerAttrs.src? file.viewerAttrs.src: false\"\n\t\t\t\t:data-viewer-group-by=\"file.viewerAttrs.viewerGroupBy? file.viewerAttrs.viewerGroupBy: false\"\n\t\t\t\t:data-title=\"file.viewerAttrs.title? file.viewerAttrs.title: false\"\n\t\t\t\t:data-actions=\"file.viewerAttrs.action? file.viewerAttrs.actions: false\"\n\t\t\t\t@click=\"download(file, $event)\"\n\t\t\t/>\n\t\t</div>\n\t"
	});

}((this.window = this.window || {}),BX.ProgressBarJs,BX,BX.Messenger.Model,BX.Messenger.Const,window,window,BX,window,BX.Messenger.Lib,BX));
 




// file: /bitrix/js/im/view/element/attach/dist/attach.bundle.js
(function (exports,ui_icons_disk,ui_vue_directives_lazyload,im_model,im_lib_utils,ui_vue) {
	'use strict';

	/**
	 * Bitrix Messenger
	 * Vue component
	 *
	 * Delimiter (attach type)
	 *
	 * @package bitrix
	 * @subpackage im
	 * @copyright 2001-2019 Bitrix
	 */
	var AttachTypeDelimiter = {
	  property: 'DELIMITER',
	  name: 'bx-im-view-element-attach-delimiter',
	  component: {
	    props: {
	      config: {
	        type: Object,
	        "default": {}
	      },
	      color: {
	        type: String,
	        "default": 'transparent'
	      }
	    },
	    computed: {
	      styles: function styles() {
	        return {
	          width: this.config.DELIMITER.SIZE ? this.config.DELIMITER.SIZE + 'px' : '',
	          backgroundColor: this.config.DELIMITER.COLOR ? this.config.DELIMITER.COLOR : this.color
	        };
	      }
	    },
	    template: "<div class=\"bx-im-element-attach-type-delimiter\" :style=\"styles\"></div>"
	  }
	};

	/**
	 * Bitrix Messenger
	 * Vue component
	 *
	 * File (attach type)
	 *
	 * @package bitrix
	 * @subpackage im
	 * @copyright 2001-2019 Bitrix
	 */
	var AttachTypeFile = {
	  property: 'FILE',
	  name: 'bx-im-element-attach-file',
	  component: {
	    props: {
	      config: {
	        type: Object,
	        "default": {}
	      },
	      color: {
	        type: String,
	        "default": 'transparent'
	      }
	    },
	    methods: {
	      openLink: function openLink(element) {
	        im_lib_utils.Utils.platform.openNewPage(element.LINK);
	      },
	      file: function file() {
	        return {
	          name: this.config.FILE.NAME,
	          extension: this.config.FILE.NAME.split('.').splice(-1)[0],
	          size: this.config.FILE.SIZE
	        };
	      },
	      fileName: function fileName(element) {
	        var maxLength = 70;

	        if (!element.NAME || element.NAME.length < maxLength) {
	          return element.NAME;
	        }

	        var endWordLength = 10;
	        var extension = element.NAME.split('.').splice(-1)[0];
	        var secondPart = element.NAME.substring(element.NAME.length - 1 - (extension.length + 1 + endWordLength));
	        var firstPart = element.NAME.substring(0, maxLength - secondPart.length - 3);
	        return firstPart.trim() + '...' + secondPart.trim();
	      },
	      fileNameFull: function fileNameFull(element) {
	        return element.NAME;
	      },
	      fileSize: function fileSize(element) {
	        var size = element.SIZE;

	        if (size <= 0) {
	          return '';
	        }

	        var sizes = ["BYTE", "KB", "MB", "GB", "TB"];
	        var position = 0;

	        while (size >= 1024 && position < 4) {
	          size /= 1024;
	          position++;
	        }

	        return Math.round(size) + " " + this.$Bitrix.Loc.getMessage('IM_MESSENGER_ATTACH_FILE_SIZE_' + sizes[position]);
	      },
	      fileIcon: function fileIcon(element) {
	        return im_model.FilesModel.getIconType(element.NAME.split('.').splice(-1)[0]);
	      }
	    },
	    template: "\n\t\t\t<div class=\"bx-im-element-attach-type-file-element\">\n\t\t\t\t<template v-for=\"(element, index) in config.FILE\">\n\t\t\t\t\t<div class=\"bx-im-element-attach-type-file\" @click=\"openLink(element)\">\n\t\t\t\t\t\t<div class=\"bx-im-element-attach-type-file-icon\">\n\t\t\t\t\t\t\t<div :class=\"['ui-icon', 'ui-icon-file-'+fileIcon(element)]\"><i></i></div>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t<div class=\"bx-im-element-attach-type-file-block\">\n\t\t\t\t\t\t\t<div class=\"bx-im-element-attach-type-file-name\" :title=\"fileNameFull(element)\">\n\t\t\t\t\t\t\t\t{{fileName(element)}}\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t<div class=\"bx-im-element-attach-type-file-size\">{{fileSize(element)}}</div>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>\n\t\t\t\t</template>\n\t\t\t</div>\n\t\t"
	  }
	};

	var AttachLinks = {
	  methods: {
	    openLink: function openLink(event) {
	      var element = event.element;
	      var eventData = event.event;

	      if (!im_lib_utils.Utils.platform.isBitrixMobile() && element.LINK) {
	        return;
	      }

	      if (element.LINK && eventData.target.tagName !== 'A') {
	        im_lib_utils.Utils.platform.openNewPage(element.LINK);
	      } else if (!element.LINK) {
	        var entity = {
	          id: null,
	          type: null
	        };

	        if (element.hasOwnProperty('USER_ID') && element.USER_ID > 0) {
	          entity.id = element.USER_ID;
	          entity.type = 'user';
	        }

	        if (element.hasOwnProperty('CHAT_ID') && element.CHAT_ID > 0) {
	          entity.id = element.CHAT_ID;
	          entity.type = 'chat';
	        }

	        if (entity.id && entity.type && window.top['BXIM']) {
	          var popupAngle = !BX.MessengerTheme.isDark();
	          window.top['BXIM'].messenger.openPopupExternalData(eventData.target, entity.type, popupAngle, {
	            'ID': entity.id
	          });
	        } else if (navigator.userAgent.toLowerCase().includes('bitrixmobile')) {
	          var dialogId = '';

	          if (entity.type === 'chat') {
	            dialogId = "chat".concat(entity.id);
	          } else {
	            dialogId = entity.id;
	          }

	          if (dialogId !== '') {
	            BXMobileApp.Events.postToComponent("onOpenDialog", [{
	              dialogId: dialogId
	            }, true], 'im.recent');
	          }
	        }
	      }
	    }
	  }
	};

	/**
	 * Bitrix Messenger
	 * Vue component
	 *
	 * Grid (attach type)
	 *
	 * @package bitrix
	 * @subpackage im
	 * @copyright 2001-2019 Bitrix
	 */
	var AttachTypeGrid = {
	  property: 'GRID',
	  name: 'bx-im-view-element-attach-grid',
	  component: {
	    mixins: [AttachLinks],
	    props: {
	      config: {
	        type: Object,
	        "default": {}
	      },
	      color: {
	        type: String,
	        "default": 'transparent'
	      }
	    },
	    created: function created() {
	      if (im_lib_utils.Utils.platform.isBitrixMobile()) {
	        this.maxCellWith = Math.floor(Math.min(screen.availWidth, screen.availHeight) / 4);
	      } else {
	        this.maxCellWith = null;
	      }
	    },
	    methods: {
	      getWidth: function getWidth(element) {
	        if (element.DISPLAY !== 'row') {
	          return element.WIDTH ? element.WIDTH + 'px' : '';
	        }

	        if (!element.VALUE) {
	          return false;
	        }

	        if (this.maxCellWith && element.WIDTH > this.maxCellWith) {
	          return this.maxCellWith + 'px';
	        }

	        return element.WIDTH ? element.WIDTH + 'px' : '';
	      },
	      getValue: function getValue(element) {
	        var _this = this;

	        if (!element.VALUE) {
	          return '';
	        }

	        var text = im_lib_utils.Utils.text.htmlspecialchars(element.VALUE);
	        text = text.replace(/\[USER=([0-9]{1,})\](.*?)\[\/USER\]/ig, function (whole, userId, userName) {
	          var user = _this.$store.getters['users/get'](userId);

	          userName = user ? im_lib_utils.Utils.text.htmlspecialchars(user.name) : userName;
	          return '<span class="bx-im-mention" data-type="USER" data-value="' + userId + '">' + userName + '</span>';
	        });
	        return im_model.MessagesModel.decodeBbCode({
	          text: text
	        });
	      }
	    },
	    //language=Vue
	    template: "\n\t\t\t<div class=\"bx-im-element-attach-type-grid\">\n\t\t\t\t<template v-for=\"(element, index) in config.GRID\">\n\t\t\t\t\t<template v-if=\"element.DISPLAY.toLowerCase() === 'block'\">\n\t\t\t\t\t\t<div class=\"bx-im-element-attach-type-grid-display bx-im-element-attach-type-display-block\" :style=\"{width: getWidth(element)}\">\n\t\t\t\t\t\t\t<div class=\"bx-im-element-attach-type-grid-element-name\">{{element.NAME}}</div>\n\t\t\t\t\t\t\t<template v-if=\"element.LINK\">\n\t\t\t\t\t\t\t\t<div\n\t\t\t\t\t\t\t\t\tclass=\"bx-im-element-attach-type-grid-element-value bx-im-element-attach-type-grid-element-value-link\"\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t<a :href=\"element.LINK\" target=\"_blank\" @click=\"openLink({element: element, event: $event})\" v-html=\"getValue(element)\"></a>\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t</template>\n\t\t\t\t\t\t\t<template v-else>\n\t\t\t\t\t\t\t\t<div class=\"bx-im-element-attach-type-grid-element-value\" v-html=\"getValue(element)\"></div>\n\t\t\t\t\t\t\t</template>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</template>\n\t\t\t\t\t<template v-else-if=\"element.DISPLAY.toLowerCase() === 'line'\">\n\t\t\t\t\t\t<div class=\"bx-im-element-attach-type-grid-display bx-im-element-attach-type-display-card\" :style=\"{width: getWidth(element)}\">\n\t\t\t\t\t\t\t<div class=\"bx-im-element-attach-type-grid-element-name\">{{element.NAME}}</div>\n\t\t\t\t\t\t\t<template v-if=\"element.LINK\">\n\t\t\t\t\t\t\t\t<div\n\t\t\t\t\t\t\t\t\tclass=\"bx-im-element-attach-type-grid-element-value bx-im-element-attach-type-grid-element-value-link\"\n\t\t\t\t\t\t\t\t\t:style=\"{color: element.COLOR? element.COLOR: ''}\"\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t<a :href=\"element.LINK\" target=\"_blank\" @click=\"openLink({element: element, event: $event})\" v-html=\"getValue(element)\"></a>\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t</template>\n\t\t\t\t\t\t\t<template v-else>\n\t\t\t\t\t\t\t\t<div class=\"bx-im-element-attach-type-grid-element-value\" :style=\"{color: element.COLOR? element.COLOR: ''}\" v-html=\"getValue(element)\"></div>\n\t\t\t\t\t\t\t</template>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</template>\n\t\t\t\t\t<template v-else-if=\"element.DISPLAY.toLowerCase() === 'row'\">\n\t\t\t\t\t\t<div class=\"bx-im-element-attach-type-grid-display bx-im-element-attach-type-display-column\">\n\t\t\t\t\t\t\t<table class=\"bx-im-element-attach-type-display-column-table\">\n\t\t\t\t\t\t\t\t<tbody>\n\t\t\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t\t\t<template v-if=\"element.NAME\">\n\t\t\t\t\t\t\t\t\t\t\t<td class=\"bx-im-element-attach-type-grid-element-name\" :colspan=\"element.VALUE? 1: 2\" :style=\"{width: getWidth(element)}\">{{element.NAME}}</td>\n\t\t\t\t\t\t\t\t\t\t</template>\n\t\t\t\t\t\t\t\t\t\t<template v-if=\"element.VALUE\">\n\t\t\t\t\t\t\t\t\t\t\t<template v-if=\"element.LINK\">\n\t\t\t\t\t\t\t\t\t\t\t\t<td\n\t\t\t\t\t\t\t\t\t\t\t\t\tclass=\"bx-im-element-attach-type-grid-element-value bx-im-element-attach-type-grid-element-value-link\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t:colspan=\"element.NAME? 1: 2\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t:style=\"{color: element.COLOR? element.COLOR: ''}\"\n\t\t\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t\t\t\t<a :href=\"element.LINK\" target=\"_blank\" @click=\"openLink({element: element, event: $event})\" v-html=\"getValue(element)\"></a>\n\t\t\t\t\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t\t\t\t</template>\n\t\t\t\t\t\t\t\t\t\t\t<template v-else>\n\t\t\t\t\t\t\t\t\t\t\t\t<td class=\"bx-im-element-attach-type-grid-element-value\" :colspan=\"element.NAME? 1: 2\" :style=\"{color: element.COLOR? element.COLOR: ''}\" v-html=\"getValue(element)\"></td>\n\t\t\t\t\t\t\t\t\t\t\t</template>\n\t\t\t\t\t\t\t\t\t\t</template>\n\t\t\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t\t</tbody>\n\t\t\t\t\t\t\t</table>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</template>\n\t\t\t\t</template>\n\t\t\t</div>\n\t\t"
	  }
	};

	/**
	 * Bitrix Messenger
	 * Vue component
	 *
	 * Rich Attach type
	 *
	 * @package bitrix
	 * @subpackage im
	 * @copyright 2001-2019 Bitrix
	 */
	var AttachTypeHtml = {
	  property: 'HTML',
	  name: 'bx-im-view-element-attach-html',
	  component: {
	    props: {
	      config: {
	        type: Object,
	        "default": {}
	      },
	      color: {
	        type: String,
	        "default": 'transparent'
	      }
	    },
	    template: "<div class=\"bx-im-element-attach-type-html\" v-html=\"config.HTML\"></div>"
	  }
	};

	/**
	 * Bitrix Messenger
	 * Vue component
	 *
	 * Image (attach type)
	 *
	 * @package bitrix
	 * @subpackage im
	 * @copyright 2001-2019 Bitrix
	 */
	var AttachTypeImage = {
	  property: 'IMAGE',
	  name: 'bx-im-view-element-attach-image',
	  component: {
	    props: {
	      config: {
	        type: Object,
	        "default": {}
	      },
	      color: {
	        type: String,
	        "default": 'transparent'
	      }
	    },
	    methods: {
	      open: function open(file) {
	        if (!file) {
	          return false;
	        }

	        if (im_lib_utils.Utils.platform.isBitrixMobile()) {
	          // TODO add multiply
	          BXMobileApp.UI.Photo.show({
	            photos: [{
	              url: file
	            }],
	            default_photo: file
	          });
	        } else {
	          window.open(file, '_blank');
	        }
	      },
	      getImageSize: function getImageSize(width, height, maxWidth) {
	        var aspectRatio;

	        if (width > maxWidth) {
	          aspectRatio = maxWidth / width;
	        } else {
	          aspectRatio = 1;
	        }

	        return {
	          width: width * aspectRatio,
	          height: height * aspectRatio
	        };
	      },
	      getElementSource: function getElementSource(element) {
	        return element.PREVIEW ? element.PREVIEW : element.LINK;
	      },
	      getElementTitle: function getElementTitle(element) {
	        return im_lib_utils.Utils.text.htmlspecialcharsback(element.NAME);
	      },
	      lazyLoadCallback: function lazyLoadCallback(event) {
	        if (!event.element.style.width) {
	          event.element.style.width = event.element.offsetWidth + 'px';
	        }

	        if (!event.element.style.height) {
	          event.element.style.height = event.element.offsetHeight + 'px';
	        }
	      },
	      styleFileSizes: function styleFileSizes(image) {
	        if (!(image.WIDTH && image.HEIGHT)) {
	          return {
	            maxHeight: '100%',
	            backgroundSize: 'contain'
	          };
	        }

	        var sizes = this.getImageSize(image.WIDTH, image.HEIGHT, 250);
	        return {
	          width: sizes.width + 'px',
	          height: sizes.height + 'px',
	          backgroundSize: sizes.width < 100 || sizes.height < 100 ? 'contain' : 'initial'
	        };
	      },
	      styleBoxSizes: function styleBoxSizes(image) {
	        if (!(image.WIDTH && image.HEIGHT)) {
	          return {
	            height: '150px'
	          };
	        }

	        if (parseInt(this.styleFileSizes(image).height) <= 250) {
	          return {};
	        }

	        return {
	          height: '280px'
	        };
	      }
	    },
	    template: "\n\t\t\t<div class=\"bx-im-element-attach-type-image\">\n\t\t\t\t<template v-for=\"(image, index) in config.IMAGE\">\n\t\t\t\t\t<div class=\"bx-im-element-attach-type-image-block\" @click=\"open(image.LINK)\" :style=\"styleBoxSizes(image)\" :key=\"index\">\n\t\t\t\t\t\t<img v-bx-lazyload=\"{callback: lazyLoadCallback}\"\n\t\t\t\t\t\t\tclass=\"bx-im-element-attach-type-image-source\"\n\t\t\t\t\t\t\t:data-lazyload-src=\"getElementSource(image)\"\n\t\t\t\t\t\t\t:style=\"styleFileSizes(image)\"\n\t\t\t\t\t\t\t:title=\"getElementTitle(image)\"\n\t\t\t\t\t\t/>\n\t\t\t\t\t</div>\n\t\t\t\t</template>\n\t\t\t</div>\n\t\t"
	  }
	};

	/**
	 * Bitrix Messenger
	 * Vue component
	 *
	 * Link (attach type)
	 *
	 * @package bitrix
	 * @subpackage im
	 * @copyright 2001-2019 Bitrix
	 */
	var AttachTypeLink = {
	  property: 'LINK',
	  name: 'bx-im-view-element-attach-link',
	  component: {
	    mixins: [AttachLinks],
	    props: {
	      config: {
	        type: Object,
	        "default": {}
	      },
	      color: {
	        type: String,
	        "default": 'transparent'
	      }
	    },
	    methods: {
	      getImageConfig: function getImageConfig(element) {
	        return {
	          IMAGE: [{
	            NAME: element.NAME,
	            PREVIEW: element.PREVIEW,
	            WIDTH: element.WIDTH,
	            HEIGHT: element.HEIGHT
	          }]
	        };
	      },
	      getLinkName: function getLinkName(element) {
	        return element.NAME ? element.NAME : element.LINK;
	      }
	    },
	    computed: {
	      imageComponentName: function imageComponentName() {
	        return AttachTypeImage.name;
	      }
	    },
	    components: babelHelpers.defineProperty({}, AttachTypeImage.name, AttachTypeImage.component),
	    //language=Vue
	    template: "\n\t\t\t<div class=\"bx-im-element-attach-type-link\">\n\t\t\t\t<template v-for=\"(element, index) in config.LINK\">\n\t\t\t\t\t<div class=\"bx-im-element-attach-type-link-element\" :key=\"index\">\n\t\t\t\t\t\t<a \n\t\t\t\t\t\t\tv-if=\"element.LINK\"\n\t\t\t\t\t\t\t:href=\"element.LINK\"\n\t\t\t\t\t\t\ttarget=\"_blank\"\n\t\t\t\t\t\t\tclass=\"bx-im-element-attach-type-link-name\" \n\t\t\t\t\t\t\t@click=\"openLink({element: element, event: $event})\"\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\t{{getLinkName(element)}}\n\t\t\t\t\t\t</a>\n\t\t\t\t\t\t<span \n\t\t\t\t\t\t\tv-else\n\t\t\t\t\t\t\tclass=\"bx-im-element-attach-type-ajax-link\"\n\t\t\t\t\t\t\t@click=\"openLink({element: element, event: $event})\"\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\t{{getLinkName(element)}}\n\t\t\t\t\t\t</span>\n\t\t\t\t\t\t<div v-if=\"element.DESC\" class=\"bx-im-element-attach-type-link-desc\">{{element.DESC}}</div>\n\t\t\t\t\t\t<div \n\t\t\t\t\t\t\tv-if=\"element.PREVIEW\" \n\t\t\t\t\t\t\tclass=\"bx-im-element-attach-type-link-image\"\n\t\t\t\t\t\t\t@click=\"openLink({element: element, event: $event})\"\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\t<component :is=\"imageComponentName\" :config=\"getImageConfig(element)\" :color=\"color\"/>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>\n\t\t\t\t</template>\n\t\t\t</div>\n\t\t"
	  }
	};

	/**
	 * Bitrix Messenger
	 * Vue component
	 *
	 * Message (attach type)
	 *
	 * @package bitrix
	 * @subpackage im
	 * @copyright 2001-2019 Bitrix
	 */
	var AttachTypeMessage = {
	  property: 'MESSAGE',
	  name: 'bx-im-view-element-attach-message',
	  component: {
	    props: {
	      config: {
	        type: Object,
	        "default": {}
	      },
	      color: {
	        type: String,
	        "default": 'transparent'
	      }
	    },
	    computed: {
	      message: function message() {
	        var _this = this;

	        var text = im_lib_utils.Utils.text.htmlspecialchars(this.config.MESSAGE);
	        text = text.replace(/\[USER=([0-9]{1,})\](.*?)\[\/USER\]/ig, function (whole, userId, userName) {
	          var user = _this.$store.getters['users/get'](userId);

	          userName = user ? im_lib_utils.Utils.text.htmlspecialchars(user.name) : userName;
	          return '<span class="bx-im-mention" data-type="USER" data-value="' + userId + '">' + userName + '</span>';
	        });
	        return im_model.MessagesModel.decodeBbCode({
	          text: text
	        });
	      }
	    },
	    template: "<div class=\"bx-im-element-attach-type-message\" v-html=\"message\"></div>"
	  }
	};

	/**
	 * Bitrix Messenger
	 * Vue component
	 *
	 * Rich (attach type)
	 *
	 * @package bitrix
	 * @subpackage im
	 * @copyright 2001-2019 Bitrix
	 */
	var AttachTypeRich = {
	  property: 'RICH_LINK',
	  name: 'bx-im-view-element-attach-rich',
	  component: {
	    mixins: [AttachLinks],
	    props: {
	      config: {
	        type: Object,
	        "default": {}
	      },
	      color: {
	        type: String,
	        "default": 'transparent'
	      }
	    },
	    methods: {
	      getImageConfig: function getImageConfig(element) {
	        return {
	          IMAGE: [{
	            NAME: element.NAME,
	            PREVIEW: element.PREVIEW,
	            WIDTH: element.WIDTH,
	            HEIGHT: element.HEIGHT
	          }]
	        };
	      }
	    },
	    computed: {
	      imageComponentName: function imageComponentName() {
	        return AttachTypeImage.name;
	      }
	    },
	    components: babelHelpers.defineProperty({}, AttachTypeImage.name, AttachTypeImage.component),
	    //language=Vue
	    template: "\n\t\t\t<div class=\"bx-im-element-attach-type-rich\">\n\t\t\t\t<template v-for=\"(element, index) in config.RICH_LINK\">\n\t\t\t\t\t<div class=\"bx-im-element-attach-type-rich-element\" :key=\"index\">\n\t\t\t\t\t\t<div v-if=\"element.PREVIEW\" class=\"bx-im-element-attach-type-rich-image\" @click=\"openLink({element: element, event: $event})\">\n\t\t\t\t\t\t\t<component :is=\"imageComponentName\" :config=\"getImageConfig(element)\" :color=\"color\"/>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t<div class=\"bx-im-element-attach-type-rich-name\" @click=\"openLink({element: element, event: $event})\">{{element.NAME}}</div>\n\t\t\t\t\t\t<div v-if=\"element.DESC\" class=\"bx-im-element-attach-type-rich-desc\">{{element.DESC}}</div>\n\t\t\t\t\t</div>\n\t\t\t\t</template>\n\t\t\t</div>\n\t\t"
	  }
	};

	/**
	 * Bitrix Messenger
	 * Vue component
	 *
	 * User (Attach type)
	 *
	 * @package bitrix
	 * @subpackage im
	 * @copyright 2001-2019 Bitrix
	 */
	var AttachTypeUser = {
	  property: 'USER',
	  name: 'bx-im-view-element-attach-user',
	  component: {
	    mixins: [AttachLinks],
	    props: {
	      config: {
	        type: Object,
	        "default": {}
	      },
	      color: {
	        type: String,
	        "default": 'transparent'
	      }
	    },
	    methods: {
	      getAvatarType: function getAvatarType(element) {
	        if (element.AVATAR) {
	          return '';
	        }

	        var avatarType = 'user';

	        if (element.AVATAR_TYPE === 'CHAT') {
	          avatarType = 'chat';
	        } else if (element.AVATAR_TYPE === 'BOT') {
	          avatarType = 'bot';
	        }

	        return 'bx-im-element-attach-type-user-avatar-type-' + avatarType;
	      }
	    },
	    //language=Vue
	    template: "\n\t\t\t<div class=\"bx-im-element-attach-type-user\">\n\t\t\t\t<template v-for=\"(element, index) in config.USER\">\n\t\t\t\t\t<div class=\"bx-im-element-attach-type-user-body\">\n\t\t\t\t\t\t<div class=\"bx-im-element-attach-type-user-avatar\">\n\t\t\t\t\t\t\t<div :class=\"['bx-im-element-attach-type-user-avatar-type', getAvatarType(element)]\" :style=\"{backgroundColor: element.AVATAR? '': color}\">\n\t\t\t\t\t\t\t\t<img v-if=\"element.AVATAR\" \n\t\t\t\t\t\t\t\t\tv-bx-lazyload\n\t\t\t\t\t\t\t\t\tclass=\"bx-im-element-attach-type-user-avatar-source\"\n\t\t\t\t\t\t\t\t\t:data-lazyload-src=\"element.AVATAR\"\n\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t<a\n\t\t\t\t\t\t\tv-if=\"element.LINK\"\n\t\t\t\t\t\t\t:href=\"element.LINK\" \n\t\t\t\t\t\t\tclass=\"bx-im-element-attach-type-user-name\"\n\t\t\t\t\t\t\ttarget=\"_blank\"\n\t\t\t\t\t\t\t@click=\"openLink({element: element, event: $event})\"\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\t{{element.NAME}}\n\t\t\t\t\t\t</a>\n\t\t\t\t\t\t<span v-else @click.prevent=\"openLink({element: element, event: $event})\">\n\t\t\t\t\t\t\t{{element.NAME}}\n\t\t\t\t\t\t</span>\n\t\t\t\t\t</div>\n\t\t\t\t</template>\n\t\t\t</div>\n\t\t"
	  }
	};

	function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

	function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

	function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
	var AttachTypes = [AttachTypeDelimiter, AttachTypeFile, AttachTypeGrid, AttachTypeHtml, AttachTypeImage, AttachTypeLink, AttachTypeMessage, AttachTypeRich, AttachTypeUser];
	var AttachComponents = {};
	AttachTypes.forEach(function (attachType) {
	  AttachComponents[attachType.name] = attachType.component;
	});
	ui_vue.WidgetBitrixVue.component('bx-im-view-element-attach', {
	  props: {
	    config: {
	      type: Object,
	      "default": {}
	    },
	    baseColor: {
	      type: String,
	      "default": '#17a3ea'
	    }
	  },
	  methods: {
	    getComponentForBlock: function getComponentForBlock(block) {
	      var _iterator = _createForOfIteratorHelper(AttachTypes),
	          _step;

	      try {
	        for (_iterator.s(); !(_step = _iterator.n()).done;) {
	          var attachType = _step.value;

	          if (typeof block[attachType.property] !== 'undefined') {
	            return attachType.name;
	          }
	        }
	      } catch (err) {
	        _iterator.e(err);
	      } finally {
	        _iterator.f();
	      }

	      return '';
	    }
	  },
	  computed: {
	    color: function color() {
	      if (typeof this.config.COLOR === 'undefined' || !this.config.COLOR) {
	        return this.baseColor;
	      }

	      if (this.config.COLOR === 'transparent') {
	        return '';
	      }

	      return this.config.COLOR;
	    }
	  },
	  components: AttachComponents,
	  template: "\n\t\t<div class=\"bx-im-element-attach\">\n\t\t\t<div v-if=\"color\" class=\"bx-im-element-attach-border\" :style=\"{borderColor: color}\"></div>\n\t\t\t<div class=\"bx-im-element-attach-content\">\n\t\t\t\t<template v-for=\"(block, index) in config.BLOCKS\">\n\t\t\t\t\t<component :is=\"getComponentForBlock(block)\" :config=\"block\" :color=\"color\" :key=\"index\" />\n\t\t\t\t</template>\n\t\t\t</div>\n\t\t</div>\n\t"
	});

}((this.window = this.window || {}),BX,window,BX.Messenger.Model,BX.Messenger.Lib,BX));
 




// file: /bitrix/js/im/view/element/keyboard/dist/keyboard.bundle.js
(function (exports,ui_vue,im_lib_utils,im_lib_logger) {
	'use strict';

	/**
	 * Bitrix Messenger
	 * Attach element Vue component
	 *
	 * @package bitrix
	 * @subpackage im
	 * @copyright 2001-2019 Bitrix
	 */

	var _ButtonType = Object.freeze({
	  newline: 'NEWLINE',
	  button: 'BUTTON'
	});

	ui_vue.WidgetBitrixVue.component('bx-im-view-element-keyboard', {
	  /*
	   * @emits 'click' {action: string, params: Object}
	   */
	  props: {
	    buttons: {
	      type: Array,
	      "default": function _default() {
	        return [];
	      }
	    },
	    messageId: {
	      "default": 0
	    },
	    userId: {
	      "default": 0
	    },
	    dialogId: {
	      "default": 0
	    }
	  },
	  data: function data() {
	    return {
	      isMobile: im_lib_utils.Utils.platform.isMobile(),
	      isBlocked: false,
	      localButtons: []
	    };
	  },
	  created: function created() {
	    this.localButtons = this.prepareButtons(this.buttons);
	  },
	  watch: {
	    buttons: function buttons() {
	      clearTimeout(this.recoverStateButton);
	      this.isBlocked = false;
	      this.localButtons = this.prepareButtons(this.buttons);
	    }
	  },
	  methods: {
	    click: function click(button) {
	      var _this = this;

	      if (this.isBlocked) {
	        return false;
	      }

	      if (button.DISABLED && button.DISABLED === 'Y') {
	        return false;
	      }

	      if (button.ACTION && button.ACTION_VALUE.toString()) {
	        this.$emit('click', {
	          action: 'ACTION',
	          params: {
	            dialogId: this.dialogId,
	            messageId: this.messageId,
	            botId: button.BOT_ID,
	            action: button.ACTION,
	            value: button.ACTION_VALUE
	          }
	        });
	      } else if (button.FUNCTION) {
	        var execFunction = button.FUNCTION.toString().replace('#MESSAGE_ID#', this.messageId).replace('#DIALOG_ID#', this.dialogId).replace('#USER_ID#', this.userId);
	        eval(execFunction);
	      } else if (button.APP_ID) {
	        im_lib_logger.Logger.warn('Messenger keyboard: open app is not implemented.');
	      } else if (button.LINK) {
	        if (im_lib_utils.Utils.platform.isBitrixMobile()) {
	          app.openNewPage(button.LINK);
	        } else {
	          window.open(button.LINK, '_blank');
	        }
	      } else if (button.WAIT !== 'Y') {
	        if (button.BLOCK === 'Y') {
	          this.isBlocked = true;
	        }

	        button.WAIT = 'Y';
	        this.$emit('click', {
	          action: 'COMMAND',
	          params: {
	            dialogId: this.dialogId,
	            messageId: this.messageId,
	            botId: button.BOT_ID,
	            command: button.COMMAND,
	            params: button.COMMAND_PARAMS
	          }
	        });
	        this.recoverStateButton = setTimeout(function () {
	          _this.isBlocked = false;
	          button.WAIT = 'N';
	        }, 10000);
	      }

	      return true;
	    },
	    getStyles: function getStyles(button) {
	      var styles = {};

	      if (button.WIDTH) {
	        styles['width'] = button.WIDTH + 'px';
	      } else if (button.DISPLAY === 'BLOCK') {
	        styles['width'] = '225px';
	      }

	      if (button.BG_COLOR) {
	        styles['backgroundColor'] = button.BG_COLOR;
	      }

	      if (button.TEXT_COLOR) {
	        styles['color'] = button.TEXT_COLOR;
	      }

	      return styles;
	    },
	    prepareButtons: function prepareButtons(buttons) {
	      return buttons.filter(function (button) {
	        if (!button.CONTEXT) {
	          return true;
	        }

	        if (im_lib_utils.Utils.platform.isBitrixMobile() && button.CONTEXT === 'DESKTOP') {
	          return false;
	        }

	        if (!im_lib_utils.Utils.platform.isBitrixMobile() && button.CONTEXT === 'MOBILE') {
	          return false;
	        } // TODO activate this buttons


	        if (!im_lib_utils.Utils.platform.isBitrixMobile() && (button.ACTION === 'DIALOG' || button.ACTION === 'CALL')) {
	          return false;
	        }

	        return true;
	      });
	    }
	  },
	  computed: {
	    ButtonType: function ButtonType() {
	      return _ButtonType;
	    }
	  },
	  template: "\n\t\t<div :class=\"['bx-im-element-keyboard', {'bx-im-element-keyboard-mobile': isMobile}]\">\n\t\t\t<template v-for=\"(button, index) in localButtons\">\n\t\t\t\t<div v-if=\"button.TYPE === ButtonType.newline\" class=\"bx-im-element-keyboard-button-separator\"></div>\n\t\t\t\t<span v-else-if=\"button.TYPE === ButtonType.button\" :class=\"[\n\t\t\t\t\t'bx-im-element-keyboard-button', \n\t\t\t\t\t'bx-im-element-keyboard-button-'+button.DISPLAY.toLowerCase(), \n\t\t\t\t\t{\n\t\t\t\t\t\t'bx-im-element-keyboard-button-disabled': isBlocked || button.DISABLED === 'Y',\n\t\t\t\t\t\t'bx-im-element-keyboard-button-progress': button.WAIT === 'Y',\n\t\t\t\t\t}\n\t\t\t\t]\" @click=\"click(button)\">\n\t\t\t\t\t<span class=\"bx-im-element-keyboard-button-text\" :style=\"getStyles(button)\">{{button.TEXT}}</span>\n\t\t\t\t</span>\n\t\t\t</template>\n\t\t</div>\n\t"
	});

}((this.window = this.window || {}),BX,BX.Messenger.Lib,BX.Messenger.Lib));
 




// file: /bitrix/js/im/view/element/chatteaser/dist/chatteaser.bundle.js
(function (exports,ui_vue,im_lib_utils) {
	'use strict';

	/**
	 * Bitrix Messenger
	 * ChatTeaser element Vue component
	 *
	 * @package bitrix
	 * @subpackage im
	 * @copyright 2001-2019 Bitrix
	 */
	ui_vue.WidgetBitrixVue.component('bx-im-view-element-chat-teaser', {
	  /*
	   * @emits 'click' {}
	   */
	  props: {
	    messageCounter: {
	      "default": 0
	    },
	    messageLastDate: {
	      "default": 0
	    },
	    languageId: {
	      "default": 'en'
	    }
	  },
	  computed: {
	    formattedDate: function formattedDate() {
	      return im_lib_utils.Utils.date.format(this.messageLastDate, null, this.$Bitrix.Loc.getMessages());
	    },
	    formattedCounter: function formattedCounter() {
	      return this.messageCounter + ' ' + im_lib_utils.Utils.text.getLocalizeForNumber('IM_MESSENGER_COMMENT', this.messageCounter, this.languageId, this.$Bitrix.Loc.getMessages());
	    }
	  },
	  template: "\n\t\t<div class=\"bx-im-element-chat-teaser\" @click=\"$emit('click', $event)\">\n\t\t\t<span class=\"bx-im-element-chat-teaser-join\">{{$Bitrix.Loc.getMessage('IM_MESSENGER_COMMENT_OPEN')}}</span>\n\t\t\t<span class=\"bx-im-element-chat-teaser-comment\">\n\t\t\t\t<span class=\"bx-im-element-chat-teaser-counter\">{{formattedCounter}}</span>, {{formattedDate}}\n\t\t\t</span>\n\t\t</div>\n\t"
	});

}((this.window = this.window || {}),BX,BX.Messenger.Lib));
 




// file: /bitrix/js/ui/vue/components/reaction/dist/reaction.bundle.js
(function (exports,ui_vue) {
	'use strict';

	/**
	 * Bitrix UI
	 * Reaction picker Vue component
	 *
	 * @package bitrix
	 * @subpackage ui
	 * @copyright 2001-2019 Bitrix
	 */
	var ReactionType = Object.freeze({
	  none: 'none',
	  like: 'like',
	  kiss: 'kiss',
	  laugh: 'laugh',
	  wonder: 'wonder',
	  cry: 'cry',
	  angry: 'angry'
	});
	var ReactionOrder = ['like', 'kiss', 'laugh', 'wonder', 'cry', 'angry'];
	ui_vue.WidgetBitrixVue.component('bx-reaction', {
	  /**
	   * @emits 'set' {values: object}
	   * @emits 'list' {action: string, type: string}
	   */
	  props: {
	    values: {
	      "default": {}
	    },
	    userId: {
	      "default": 0
	    },
	    openList: {
	      "default": true
	    }
	  },
	  data: function data() {
	    return {
	      localValues: {},
	      userReaction: ReactionType.none,
	      buttonAnimate: false
	    };
	  },
	  created: function created() {
	    this.localValues = Object.assign({}, this.values);
	  },
	  watch: {
	    values: function values(_values) {
	      this.localValues = Object.assign({}, _values);
	    }
	  },
	  methods: {
	    list: function list() {
	      if (this.openList) ;

	      this.$emit('list', {
	        values: this.localValues
	      });
	    },
	    likeIt: function likeIt(event) {
	      var _this = this;

	      var emotion = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ReactionType.like;

	      if (this.userReaction === ReactionType.none) {
	        emotion = ReactionType.like;

	        if (!this.localValues[emotion]) {
	          this.localValues = Object.assign({}, this.localValues, babelHelpers.defineProperty({}, emotion, []));
	        }

	        this.localValues[emotion].push(this.userId);
	        this.buttonAnimate = true;
	        setTimeout(function () {
	          return _this.buttonAnimate = false;
	        }, 400);
	        this.$emit('set', {
	          action: 'set',
	          type: emotion
	        });
	      } else {
	        if (this.localValues[this.userReaction]) {
	          this.localValues[this.userReaction] = this.localValues[this.userReaction].filter(function (element) {
	            return element !== _this.userId;
	          });
	        }

	        this.$emit('set', {
	          action: 'remove',
	          type: this.userReaction
	        });
	      }

	      event.preventDefault();
	    },
	    preventDefault: function preventDefault(event) {
	      event.preventDefault();
	    }
	  },
	  computed: {
	    types: function types() {
	      var _this2 = this;

	      this.userReaction = ReactionType.none;
	      return ReactionOrder.filter(function (type) {
	        if (typeof _this2.localValues[type] === 'undefined' || !(_this2.localValues[type] instanceof Array) || _this2.localValues[type].length <= 0) {
	          return false;
	        }

	        if (_this2.userId > 0 && _this2.userReaction === ReactionType.none && _this2.localValues[type].includes(_this2.userId)) {
	          _this2.userReaction = type;
	        }

	        return true;
	      }).map(function (type) {
	        return {
	          type: type,
	          count: _this2.localValues[type].length
	        };
	      });
	    },
	    counter: function counter() {
	      return this.types.map(function (element) {
	        return element.count;
	      }).reduce(function (result, value) {
	        return result + value;
	      }, 0);
	    },
	    isTypesShowed: function isTypesShowed() {
	      if (this.counter <= 0) {
	        return false;
	      }

	      if (this.userReaction !== ReactionType.none && this.counter === 1) {
	        return false;
	      }

	      return true;
	    },
	    isMobile: function isMobile() {
	      var UA = navigator.userAgent.toLowerCase();
	      return UA.includes('android') || UA.includes('iphone') || UA.includes('ipad') || UA.includes('bitrixmobile');
	    }
	  },
	  template: "\n\t\t<div :class=\"['ui-vue-reaction', {'ui-vue-reaction-mobile': isMobile}]\">\n\t\t\t<transition name=\"ui-vue-reaction-result-animation\">\n\t\t\t\t<div v-if=\"isTypesShowed\" class=\"ui-vue-reaction-result\" @click=\"list\">\n\t\t\t\t\t<transition-group tag=\"div\" class=\"ui-vue-reaction-result-types\" name=\"ui-vue-reaction-result-type-animation\" >\n\t\t\t\t\t\t<span v-for=\"element in types\" :class=\"['ui-vue-reaction-result-type', 'ui-vue-reaction-icon-'+element.type]\" :key=\"element.type\"></span>\n\t\t\t\t\t</transition-group>\t\n\t\t\t\t\t<div class=\"ui-vue-reaction-result-counter\">{{counter}}</div>\n\t\t\t\t</div>\n\t\t\t</transition>\n\t\t\t<div v-if=\"userId > 0\"  class=\"ui-vue-reaction-button\" @click=\"likeIt\">\n\t\t\t\t<div class=\"ui-vue-reaction-button-container\">\n\t\t\t\t\t<div :class=\"['ui-vue-reaction-button-icon', 'ui-vue-reaction-icon-'+userReaction, {'ui-vue-reaction-button-pressed': buttonAnimate}]\"></div>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t</div>\n\t"
	});

}((this.window = this.window || {}),BX));
 




// file: /bitrix/js/im/view/message/body/dist/body.bundle.js
(function (exports,im_view_element_media,im_view_element_attach,im_view_element_keyboard,im_view_element_chatteaser,ui_vue_components_reaction,ui_vue,ui_vue_vuex,im_model,im_const,im_lib_utils,main_core) {
	'use strict';

	function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

	function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

	function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

	function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { babelHelpers.defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
	var BX = window.BX;

	var _ContentType = Object.freeze({
	  "default": 'default',
	  progress: 'progress',
	  image: 'image',
	  audio: 'audio',
	  video: 'video',
	  richLink: 'richLink'
	});

	ui_vue.WidgetBitrixVue.component('bx-im-view-message-body', {
	  /**
	   * @emits 'clickByUserName' {user: object, event: MouseEvent}
	   * @emits 'clickByUploadCancel' {file: object, event: MouseEvent}
	   * @emits 'clickByChatTeaser' {params: object, event: MouseEvent}
	   * @emits 'clickByKeyboardButton' {message: object, action: string, params: Object}
	   * @emits 'setReaction' {message: object, reaction: object}
	   * @emits 'openReactionList' {message: object, values: object}
	   */
	  props: {
	    userId: {
	      "default": 0
	    },
	    dialogId: {
	      "default": '0'
	    },
	    chatId: {
	      "default": 0
	    },
	    messageType: {
	      "default": im_const.MessageType.self
	    },
	    message: {
	      type: Object,
	      "default": im_model.MessagesModel.create().getElementState
	    },
	    enableReactions: {
	      "default": true
	    },
	    showName: {
	      "default": true
	    },
	    showAvatar: {
	      "default": true
	    },
	    referenceContentBodyClassName: {
	      "default": ''
	    },
	    referenceContentNameClassName: {
	      "default": ''
	    }
	  },
	  created: function created() {
	    this.dateFormatFunction = null;
	    this.cacheFormatDate = {};
	  },
	  methods: {
	    clickByUserName: function clickByUserName(event) {
	      this.$emit('clickByUserName', event);
	    },
	    clickByUploadCancel: function clickByUploadCancel(event) {
	      this.$emit('clickByUploadCancel', event);
	    },
	    clickByChatTeaser: function clickByChatTeaser(event) {
	      this.$emit('clickByChatTeaser', {
	        message: event.message,
	        event: event
	      });
	    },
	    clickByKeyboardButton: function clickByKeyboardButton(event) {
	      this.$emit('clickByKeyboardButton', _objectSpread({
	        message: event.message
	      }, event.event));
	    },
	    setReaction: function setReaction(event) {
	      this.$emit('setReaction', event);
	    },
	    openReactionList: function openReactionList(event) {
	      this.$emit('openReactionList', event);
	    },
	    formatDate: function formatDate(date) {
	      var id = date.toJSON().slice(0, 10);

	      if (this.cacheFormatDate[id]) {
	        return this.cacheFormatDate[id];
	      }

	      var dateFormat = im_lib_utils.Utils.date.getFormatType(BX.Messenger.Const.DateFormat.message, this.$Bitrix.Loc.getMessages());
	      this.cacheFormatDate[id] = this._getDateFormat().format(dateFormat, date);
	      return this.cacheFormatDate[id];
	    },
	    _getDateFormat: function _getDateFormat() {
	      var _this = this;

	      if (this.dateFormatFunction) {
	        return this.dateFormatFunction;
	      }

	      this.dateFormatFunction = Object.create(BX.Main.Date);

	      this.dateFormatFunction._getMessage = function (phrase) {
	        return _this.$Bitrix.Loc.getMessage(phrase);
	      };

	      return this.dateFormatFunction;
	    },
	    isDesktop: function isDesktop() {
	      return im_lib_utils.Utils.platform.isBitrixDesktop();
	    },
	    getDesktopVersion: function getDesktopVersion() {
	      return im_lib_utils.Utils.platform.getDesktopVersion();
	    },
	    isMobile: function isMobile() {
	      return im_lib_utils.Utils.platform.isBitrixMobile();
	    }
	  },
	  computed: _objectSpread({
	    MessageType: function MessageType() {
	      return im_const.MessageType;
	    },
	    ContentType: function ContentType() {
	      return _ContentType;
	    },
	    contentType: function contentType() {
	      if (this.filesData.length > 0) {
	        var onlyImage = false;
	        var onlyVideo = false;
	        var onlyAudio = false;
	        var inProgress = false;

	        var _iterator = _createForOfIteratorHelper(this.filesData),
	            _step;

	        try {
	          for (_iterator.s(); !(_step = _iterator.n()).done;) {
	            var file = _step.value;

	            if (file.progress < 0) {
	              inProgress = true;
	              break;
	            } else if (file.type === 'audio') {
	              if (onlyVideo || onlyImage) {
	                onlyImage = false;
	                onlyVideo = false;
	                break;
	              }

	              onlyAudio = true;
	            } else if (file.type === 'image' && file.image) {
	              if (onlyVideo || onlyAudio) {
	                onlyAudio = false;
	                onlyVideo = false;
	                break;
	              }

	              onlyImage = true;
	            } else if (file.type === 'video') {
	              if (onlyImage || onlyAudio) {
	                onlyAudio = false;
	                onlyImage = false;
	                break;
	              }

	              onlyVideo = true;
	            } else {
	              onlyAudio = false;
	              onlyImage = false;
	              onlyVideo = false;
	              break;
	            }
	          }
	        } catch (err) {
	          _iterator.e(err);
	        } finally {
	          _iterator.f();
	        }

	        if (inProgress) {
	          return _ContentType.progress;
	        } else if (onlyImage) {
	          return _ContentType.image;
	        } else if (onlyAudio) {
	          return _ContentType.audio;
	        } else if (onlyVideo) {
	          return _ContentType.video;
	        }
	      }

	      return _ContentType["default"];
	    },
	    formattedDate: function formattedDate() {
	      return this.formatDate(this.message.date);
	    },
	    messageText: function messageText() {
	      var _this2 = this;

	      if (this.isDeleted) {
	        return this.$Bitrix.Loc.getMessage('IM_MESSENGER_MESSAGE_DELETED');
	      }

	      var message = this.message.textConverted;
	      var messageParams = this.message.params;
	      var replacement = [];
	      message = message.replace(/<!--IM_COMMAND_START-->([\0-\uFFFF]+?)<!--IM_COMMAND_END-->/ig, function (whole, text) {
	        var id = replacement.length;
	        replacement.push(text);
	        return '####REPLACEMENT_' + id + '####';
	      });
	      message = message.replace(/\[USER=([0-9]{1,})\](.*?)\[\/USER\]/ig, function (whole, userId, userName) {
	        if (!userName) {
	          var user = _this2.$store.getters['users/get'](userId);

	          userName = user ? im_lib_utils.Utils.text.htmlspecialchars(user.name) : 'User ' + userId;
	        }

	        return '<span class="bx-im-mention" data-type="USER" data-value="' + userId + '">' + userName + '</span>';
	      });
	      replacement.forEach(function (value, index) {
	        message = message.replace('####REPLACEMENT_' + index + '####', value);
	      });

	      if (typeof messageParams.LINK_ACTIVE !== 'undefined' && messageParams.LINK_ACTIVE.length > 0 && !messageParams.LINK_ACTIVE.includes(this.userId)) {
	        message = message.replace(/<a.*?href="([^"]*)".*?>(.*?)<\/a>/ig, '$2');
	      }

	      return message;
	    },
	    messageAttach: function messageAttach() {
	      return this.message.params.ATTACH;
	    },
	    messageReactions: function messageReactions() {
	      return this.message.params.REACTION || {};
	    },
	    isEdited: function isEdited() {
	      return this.message.params.IS_EDITED === 'Y';
	    },
	    isDeleted: function isDeleted() {
	      return this.message.params.IS_DELETED === 'Y';
	    },
	    chatColor: function chatColor() {
	      return this.dialog.type !== im_const.DialogType["private"] ? this.dialog.color : this.user.color;
	    },
	    dialog: function dialog() {
	      var dialog = this.$store.getters['dialogues/get'](this.dialogId);
	      return dialog ? dialog : this.$store.getters['dialogues/getBlank']();
	    },
	    user: function user() {
	      return this.$store.getters['users/get'](this.message.authorId, true);
	    },
	    filesData: function filesData() {
	      var _this3 = this;

	      var files = [];

	      if (!this.message.params.FILE_ID || this.message.params.FILE_ID.length <= 0) {
	        return files;
	      }

	      this.message.params.FILE_ID.forEach(function (fileId) {
	        if (!fileId) {
	          return false;
	        }

	        var file = _this3.$store.getters['files/get'](_this3.chatId, fileId, true);

	        if (!file) {
	          _this3.$store.commit('files/set', {
	            data: [_this3.$store.getters['files/getBlank']({
	              id: fileId,
	              chatId: _this3.chatId
	            })]
	          });

	          file = _this3.$store.getters['files/get'](_this3.chatId, fileId, true);
	        }

	        if (file) {
	          files.push(file);
	        }
	      });
	      return files;
	    },
	    keyboardButtons: function keyboardButtons() {
	      var result = false;

	      if (!this.message.params.KEYBOARD || this.message.params.KEYBOARD === 'N') {
	        return result;
	      }

	      return this.message.params.KEYBOARD;
	    },
	    chatTeaser: function chatTeaser() {
	      if (typeof this.message.params.CHAT_ID === 'undefined' || typeof this.message.params.CHAT_LAST_DATE === 'undefined' || typeof this.message.params.CHAT_MESSAGE === 'undefined') {
	        return false;
	      }

	      return {
	        messageCounter: this.message.params.CHAT_MESSAGE,
	        messageLastDate: this.message.params.CHAT_LAST_DATE,
	        languageId: this.application.common.languageId
	      };
	    },
	    userName: function userName() {
	      if (this.message.params.NAME) {
	        return main_core.Text.decode(this.message.params.NAME);
	      }

	      if (!this.showAvatar) {
	        return this.user.name;
	      } else {
	        return this.user.firstName ? this.user.firstName : this.user.name;
	      }
	    },
	    userColor: function userColor() {
	      if (this.user.extranet) {
	        return "#CA7B00";
	      }

	      return this.user.color;
	    }
	  }, ui_vue_vuex.WidgetVuex.mapState({
	    application: function application(state) {
	      return state.application;
	    }
	  })),
	  template: "\n\t\t<div class=\"bx-im-message-content-wrap\">\n\t\t\t<template v-if=\"contentType == ContentType.default || contentType == ContentType.audio || contentType == ContentType.progress || (contentType !== ContentType.image && isDesktop() && getDesktopVersion() < 47)\">\n\t\t\t\t<div class=\"bx-im-message-content\">\n\t\t\t\t\t<span class=\"bx-im-message-content-box\">\n\t\t\t\t\t\t<div class=\"bx-im-message-content-name-wrap\">\n\t\t\t\t\t\t\t<template v-if=\"showName && user.extranet && messageType == MessageType.opponent\">\n\t\t\t\t\t\t\t\t<div class=\"bx-im-message-extranet-icon\"></div>\n\t\t\t\t\t\t\t</template>\n\t\t\t\t\t\t\t<template v-if=\"showName && messageType == MessageType.opponent\">\n\t\t\t\t\t\t\t\t<div :class=\"['bx-im-message-content-name', referenceContentNameClassName]\" :style=\"{color: userColor}\" @click=\"clickByUserName({user: user, event: $event})\">{{userName}}</div>\n\t\t\t\t\t\t\t</template>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t<div :class=\"['bx-im-message-content-body', referenceContentBodyClassName]\">\n\t\t\t\t\t\t\t<template v-if=\"(contentType == ContentType.audio) && (!isDesktop() || (isDesktop() && getDesktopVersion() > 43))\">\n\t\t\t\t\t\t\t\t<bx-im-view-element-file-audio v-for=\"file in filesData\" :messageType=\"messageType\" :file=\"file\" :key=\"file.templateId\" @uploadCancel=\"clickByUploadCancel\"/>\n\t\t\t\t\t\t\t</template>\n\t\t\t\t\t\t\t<template v-else>\n\t\t\t\t\t\t\t\t<bx-im-view-element-file v-for=\"file in filesData\" :messageType=\"messageType\" :file=\"file\" :key=\"file.templateId\" @uploadCancel=\"clickByUploadCancel\"/>\n\t\t\t\t\t\t\t</template>\n\t\t\t\t\t\t\t<div :class=\"['bx-im-message-content-body-wrap', {\n\t\t\t\t\t\t\t\t'bx-im-message-content-body-with-text': messageText.length > 0,\n\t\t\t\t\t\t\t\t'bx-im-message-content-body-without-text': messageText.length <= 0,\n\t\t\t\t\t\t\t}]\">\n\t\t\t\t\t\t\t\t<template v-if=\"messageText\">\n\t\t\t\t\t\t\t\t\t<span class=\"bx-im-message-content-text\" v-html=\"messageText\"></span>\n\t\t\t\t\t\t\t\t</template>\n\t\t\t\t\t\t\t\t<template v-for=\"(config, id) in messageAttach\">\n\t\t\t\t\t\t\t\t\t<bx-im-view-element-attach :baseColor=\"chatColor\" :config=\"config\" :key=\"id\"/>\n\t\t\t\t\t\t\t\t</template>\n\t\t\t\t\t\t\t\t<span class=\"bx-im-message-content-params\">\n\t\t\t\t\t\t\t\t\t<span class=\"bx-im-message-content-date\">{{formattedDate}}</span>\n\t\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</span>\n\t\t\t\t\t<div v-if=\"!message.push && enableReactions && message.authorId\" class=\"bx-im-message-content-reaction\">\n\t\t\t\t\t\t<bx-reaction :values=\"messageReactions\" :userId=\"userId\" :openList=\"false\" @set=\"setReaction({message: message, reaction: $event})\" @list=\"openReactionList({message: message, values: $event.values})\"/>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t</template>\n\t\t\t<template v-else-if=\"contentType == ContentType.richLink\">\n\t\t\t\t<!-- richLink type markup -->\n\t\t\t</template>\n\t\t\t<template v-else-if=\"contentType == ContentType.image || contentType == ContentType.video\">\n\t\t\t\t<div class=\"bx-im-message-content bx-im-message-content-fit\">\n\t\t\t\t\t<span class=\"bx-im-message-content-box\">\n\t\t\t\t\t\t<template v-if=\"showName && messageType == MessageType.opponent\">\n\t\t\t\t\t\t\t<div :class=\"['bx-im-message-content-name', referenceContentNameClassName]\" :style=\"{color: user.color}\" @click=\"clickByUserName({user: user, event: $event})\">{{!showAvatar? user.name: (user.firstName? user.firstName: user.name)}}</div>\n\t\t\t\t\t\t</template>\n\t\t\t\t\t\t<div :class=\"['bx-im-message-content-body', referenceContentBodyClassName]\">\n\t\t\t\t\t\t\t<template v-if=\"contentType == ContentType.image\">\n\t\t\t\t\t\t\t\t<bx-im-view-element-file-image v-for=\"file in filesData\" :messageType=\"messageType\" :file=\"file\" :key=\"file.templateId\" @uploadCancel=\"clickByUploadCancel\"/>\n\t\t\t\t\t\t\t</template>\n\t\t\t\t\t\t\t<template v-else-if=\"contentType == ContentType.video\">\n\t\t\t\t\t\t\t\t<bx-im-view-element-file-video v-for=\"file in filesData\" :messageType=\"messageType\" :file=\"file\" :key=\"file.templateId\" @uploadCancel=\"clickByUploadCancel\"/>\n\t\t\t\t\t\t\t</template>\n\t\t\t\t\t\t\t<div :class=\"['bx-im-message-content-body-wrap', {\n\t\t\t\t\t\t\t\t'bx-im-message-content-body-with-text': messageText.length > 0,\n\t\t\t\t\t\t\t\t'bx-im-message-content-body-without-text': messageText.length <= 0,\n\t\t\t\t\t\t\t}]\">\n\t\t\t\t\t\t\t\t<template v-if=\"messageText\">\n\t\t\t\t\t\t\t\t\t<span class=\"bx-im-message-content-text\" v-html=\"messageText\"></span>\n\t\t\t\t\t\t\t\t</template>\n\t\t\t\t\t\t\t\t<span class=\"bx-im-message-content-params\">\n\t\t\t\t\t\t\t\t\t<span class=\"bx-im-message-content-date\">{{formattedDate}}</span>\n\t\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</span>\n\t\t\t\t\t<div v-if=\"!message.push && enableReactions && message.authorId\" class=\"bx-im-message-content-reaction\">\n\t\t\t\t\t\t<bx-reaction :values=\"messageReactions\" :userId=\"userId\" :openList=\"false\" @set=\"setReaction({message: message, reaction: $event})\" @list=\"openReactionList({message: message, values: $event.values})\"/>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t</template>\n\t\t\t<template v-if=\"keyboardButtons\">\n\t\t\t\t<bx-im-view-element-keyboard :buttons=\"keyboardButtons\" :messageId=\"message.id\" :userId=\"userId\" :dialogId=\"dialogId\" @click=\"clickByKeyboardButton({message: message, event: $event})\"/>\n\t\t\t</template>\n\t\t\t<template v-if=\"chatTeaser\">\n\t\t\t\t<bx-im-view-element-chat-teaser :messageCounter=\"chatTeaser.messageCounter\" :messageLastDate=\"chatTeaser.messageLastDate\" :languageId=\"chatTeaser.languageId\" @click=\"clickByChatTeaser({message: message, event: $event})\"/>\n\t\t\t</template>\n\t\t</div>\n\t"
	});

}((this.window = this.window || {}),window,window,window,window,window,BX,BX,BX.Messenger.Model,BX.Messenger.Const,BX.Messenger.Lib,BX));
 




// file: /bitrix/js/im/lib/animation/dist/animation.bundle.js
this.BX = this.BX || {};
this.BX.Messenger = this.BX.Messenger || {};
(function (exports) {
	'use strict';

	/**
	 * Bitrix Messenger
	 * Animation manager
	 *
	 * @package bitrix
	 * @subpackage im
	 * @copyright 2001-2019 Bitrix
	 */
	var Animation = /*#__PURE__*/function () {
	  function Animation() {
	    babelHelpers.classCallCheck(this, Animation);
	  }

	  babelHelpers.createClass(Animation, null, [{
	    key: "start",
	    value: function start(params) {
	      var _params$start = params.start,
	          start = _params$start === void 0 ? 0 : _params$start,
	          _params$end = params.end,
	          end = _params$end === void 0 ? 0 : _params$end,
	          _params$increment = params.increment,
	          increment = _params$increment === void 0 ? 20 : _params$increment,
	          _params$callback = params.callback,
	          callback = _params$callback === void 0 ? function () {} : _params$callback,
	          _params$duration = params.duration,
	          duration = _params$duration === void 0 ? 500 : _params$duration,
	          element = params.element,
	          elementProperty = params.elementProperty;
	      var diff = end - start;
	      var currentPosition = 0;

	      var easeInOutQuad = function easeInOutQuad(current, start, diff, duration) {
	        current /= duration / 2;

	        if (current < 1) {
	          return diff / 2 * current * current + start;
	        }

	        current--;
	        return -diff / 2 * (current * (current - 2) - 1) + start;
	      };

	      var requestFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || function (callback) {
	        return window.setTimeout(callback, 1000 / 60);
	      };

	      var frameId = null;

	      var animateScroll = function animateScroll() {
	        currentPosition += increment;
	        element[elementProperty] = easeInOutQuad(currentPosition, start, diff, duration);

	        if (currentPosition < duration) {
	          frameId = requestFrame(animateScroll);
	        } else {
	          if (callback && typeof callback === 'function') {
	            callback();
	          }
	        }

	        return frameId;
	      };

	      return animateScroll();
	    }
	  }, {
	    key: "cancel",
	    value: function cancel(id) {
	      var cancelFrame = window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || function (id) {
	        clearTimeout(id);
	      };

	      cancelFrame(id);
	    }
	  }]);
	  return Animation;
	}();

	Animation.frameIds = {};

	exports.Animation = Animation;

}((this.BX.Messenger.Lib = this.BX.Messenger.Lib || {})));
 




// file: /bitrix/js/im/view/message/dist/message.bundle.js
(function (exports,im_view_message_body,im_model,ui_vue,im_const,im_lib_utils,im_lib_animation) {
	'use strict';

	/**
	 * Bitrix Messenger
	 * Message Vue component
	 *
	 * @package bitrix
	 * @subpackage im
	 * @copyright 2001-2019 Bitrix
	 */
	ui_vue.WidgetBitrixVue.component('bx-im-view-message', {
	  /**
	   * @emits 'clickByUserName' {user: object, event: MouseEvent}
	   * @emits 'clickByUploadCancel' {file: object, event: MouseEvent}
	   * @emits 'clickByKeyboardButton' {message: object, action: string, params: Object}
	   * @emits 'clickByChatTeaser' {message: object, event: MouseEvent}
	   * @emits 'clickByMessageMenu' {message: object, event: MouseEvent}
	   * @emits 'clickByMessageRetry' {message: object, event: MouseEvent}
	   * @emits 'setMessageReaction' {message: object, reaction: object}
	   * @emits 'openMessageReactionList' {message: object, values: object}
	   * @emits 'dragMessage' {result: boolean, event: MouseEvent}
	   * @emits 'quoteMessage' {message: object}
	   */
	  props: {
	    userId: {
	      "default": 0
	    },
	    dialogId: {
	      "default": 0
	    },
	    chatId: {
	      "default": 0
	    },
	    enableReactions: {
	      "default": true
	    },
	    enableDateActions: {
	      "default": true
	    },
	    enableCreateContent: {
	      "default": true
	    },
	    enableGestureQuote: {
	      "default": true
	    },
	    enableGestureQuoteFromRight: {
	      "default": true
	    },
	    enableGestureMenu: {
	      "default": false
	    },
	    showAvatar: {
	      "default": true
	    },
	    showMenu: {
	      "default": true
	    },
	    showName: {
	      "default": true
	    },
	    showLargeFont: {
	      "default": true
	    },
	    capturedMoveEvent: {
	      "default": null
	    },
	    referenceContentClassName: {
	      "default": ''
	    },
	    referenceContentBodyClassName: {
	      "default": ''
	    },
	    referenceContentNameClassName: {
	      "default": ''
	    },
	    message: {
	      type: Object,
	      "default": im_model.MessagesModel.create().getElementState
	    }
	  },
	  data: function data() {
	    return {
	      componentBodyId: 'bx-im-view-message-body',
	      drag: false,
	      dragWidth: 0,
	      dragPosition: 0,
	      dragIconShowLeft: false,
	      dragIconShowRight: false
	    };
	  },
	  created: function created() {
	    this.dragStartPositionX = 0;
	    this.dragStartPositionY = 0;
	    this.dragMovePositionX = 0;
	    this.dragMovePositionY = 0;
	  },
	  beforeDestroy: function beforeDestroy() {
	    clearTimeout(this.dragStartTimeout1);
	    clearTimeout(this.dragStartTimeout2);

	    if (this.dragBackAnimation) {
	      im_lib_animation.Animation.cancel(this.dragBackAnimation);
	    }
	  },
	  methods: {
	    clickByAvatar: function clickByAvatar(event) {
	      this.$emit('clickByUserName', event);
	    },
	    clickByUserName: function clickByUserName(event) {
	      if (this.showAvatar && im_lib_utils.Utils.platform.isMobile()) {
	        return false;
	      }

	      this.$emit('clickByUserName', event);
	    },
	    clickByUploadCancel: function clickByUploadCancel(event) {
	      this.$emit('clickByUploadCancel', event);
	    },
	    clickByKeyboardButton: function clickByKeyboardButton(event) {
	      this.$emit('clickByKeyboardButton', event);
	    },
	    clickByChatTeaser: function clickByChatTeaser(event) {
	      this.$emit('clickByChatTeaser', event);
	    },
	    clickByMessageMenu: function clickByMessageMenu(event) {
	      this.$emit('clickByMessageMenu', event);
	    },
	    clickByMessageRetry: function clickByMessageRetry(event) {
	      this.$emit('clickByMessageRetry', event);
	    },
	    setMessageReaction: function setMessageReaction(event) {
	      this.$emit('setMessageReaction', event);
	    },
	    openMessageReactionList: function openMessageReactionList(event) {
	      this.$emit('openMessageReactionList', event);
	    },
	    gestureRouter: function gestureRouter(eventName, event) {
	      this.gestureQuote(eventName, event);
	      this.gestureMenu(eventName, event);
	    },
	    gestureMenu: function gestureMenu(eventName, event) {
	      var _this = this;

	      if (!this.enableGestureMenu) {
	        return;
	      }

	      if (eventName === 'touchstart') {
	        this.gestureMenuStarted = true;
	        this.gestureMenuPreventTouchEnd = false;

	        if (event.target.tagName === "A") {
	          return false;
	        }

	        this.gestureMenuStartPosition = {
	          x: event.changedTouches[0].clientX,
	          y: event.changedTouches[0].clientY
	        };
	        this.gestureMenuTimeout = setTimeout(function () {
	          _this.gestureMenuPreventTouchEnd = true;

	          _this.$emit('clickByMessageMenu', {
	            message: _this.message,
	            event: event
	          });
	        }, 500);
	      } else if (eventName === 'touchmove') {
	        if (!this.gestureMenuStarted) {
	          return false;
	        }

	        if (Math.abs(this.gestureMenuStartPosition.x - event.changedTouches[0].clientX) >= 10 || Math.abs(this.gestureMenuStartPosition.y - event.changedTouches[0].clientY) >= 10) {
	          this.gestureMenuStarted = false;
	          clearTimeout(this.gestureMenuTimeout);
	        }
	      } else if (eventName === 'touchend') {
	        if (!this.gestureMenuStarted) {
	          return false;
	        }

	        this.gestureMenuStarted = false;
	        clearTimeout(this.gestureMenuTimeout);

	        if (this.gestureMenuPreventTouchEnd) {
	          event.preventDefault();
	        }
	      }
	    },
	    gestureQuote: function gestureQuote(eventName, event) {
	      var _this2 = this;

	      var target = im_lib_utils.Utils.browser.findParent(event.target, 'bx-im-message') || event.target;

	      if (!this.enableGestureQuote || im_lib_utils.Utils.platform.isAndroid()) {
	        return;
	      }

	      var fromRight = this.enableGestureQuoteFromRight;
	      var layerX = target.getBoundingClientRect().left + event.layerX;
	      var layerY = target.getBoundingClientRect().top + event.layerY;

	      if (eventName === 'touchstart') {
	        this.dragCheck = true;
	        this.dragStartInitialX = target.getBoundingClientRect().left;
	        this.dragStartInitialY = target.getBoundingClientRect().top;
	        this.dragStartPositionX = layerX;
	        this.dragStartPositionY = layerY;
	        this.dragMovePositionX = null;
	        this.dragMovePositionY = null;
	        clearTimeout(this.dragStartTimeout1);
	        clearTimeout(this.dragStartTimeout2);
	        this.dragStartTimeout1 = setTimeout(function () {
	          if (_this2.dragMovePositionX !== null) {
	            if (Math.abs(_this2.dragStartPositionY - _this2.dragMovePositionY) >= 10) {
	              _this2.dragCheck = false;
	            }
	          }
	        }, 29);
	        this.dragStartTimeout2 = setTimeout(function () {
	          _this2.dragCheck = false;

	          if (Math.abs(_this2.dragStartPositionY - _this2.dragMovePositionY) >= 10) {
	            return;
	          }

	          if (_this2.dragMovePositionX === null) {
	            return;
	          } else if (fromRight && _this2.dragStartPositionX - _this2.dragMovePositionX < 9) {
	            return;
	          } else if (!fromRight && _this2.dragStartPositionX - _this2.dragMovePositionX > 9) {
	            return;
	          }

	          im_lib_animation.Animation.cancel(_this2.dragBackAnimation);
	          _this2.drag = true;

	          _this2.$emit('dragMessage', {
	            result: _this2.drag,
	            event: event
	          });

	          _this2.dragWidth = _this2.$refs.body.offsetWidth;
	        }, 80);
	      } else if (eventName === 'touchmove') {
	        if (this.drag || !this.dragCheck) {
	          return false;
	        }

	        this.dragMovePositionX = layerX;
	        this.dragMovePositionY = layerY;
	      } else if (eventName === 'touchend') {
	        clearTimeout(this.dragStartTimeout1);
	        clearTimeout(this.dragStartTimeout2);
	        this.dragCheck = false;

	        if (!this.drag) {
	          this.dragIconShowLeft = false;
	          this.dragIconShowRight = false;
	          return;
	        }

	        im_lib_animation.Animation.cancel(this.dragBackAnimation);
	        this.drag = false;
	        this.$emit('dragMessage', {
	          result: this.drag,
	          event: event
	        });

	        if (this.enableGestureQuoteFromRight && this.dragIconShowRight && this.dragPosition !== 0 || !this.enableGestureQuoteFromRight && this.dragIconShowLeft && this.dragPosition !== this.dragStartInitialX) {
	          if (im_lib_utils.Utils.platform.isBitrixMobile()) {
	            setTimeout(function () {
	              return app.exec("callVibration");
	            }, 200);
	          }

	          this.$emit('quoteMessage', {
	            message: this.message
	          });
	        }

	        this.dragIconShowLeft = false;
	        this.dragIconShowRight = false;
	        this.dragBackAnimation = im_lib_animation.Animation.start({
	          start: this.dragPosition,
	          end: this.dragStartInitialX,
	          increment: 20,
	          duration: 300,
	          element: this,
	          elementProperty: 'dragPosition',
	          callback: function callback() {
	            _this2.dragLayerPosition = undefined;
	            _this2.dragWidth = 0;
	            _this2.dragPosition = 0;
	          }
	        });
	      }
	    }
	  },
	  watch: {
	    capturedMoveEvent: function capturedMoveEvent(event) {
	      if (!this.drag || !event) {
	        return;
	      }

	      var target = im_lib_utils.Utils.browser.findParent(event.target, 'bx-im-message') || event.target;
	      var layerX = target.getBoundingClientRect().left + event.layerX;

	      if (typeof this.dragLayerPosition === 'undefined') {
	        this.dragLayerPosition = layerX;
	      }

	      var movementX = this.dragLayerPosition - layerX;
	      this.dragLayerPosition = layerX;
	      this.dragPosition = this.dragPosition - movementX;

	      if (this.enableGestureQuoteFromRight) {
	        var dragPositionMax = (this.showAvatar ? 30 : 0) + 45;
	        var dragPositionIcon = this.showAvatar ? 30 : 30;

	        if (this.dragPosition < -dragPositionMax) {
	          this.dragPosition = -dragPositionMax;
	        } else if (this.dragPosition < -dragPositionIcon) {
	          if (!this.dragIconShowRight) {
	            this.dragIconShowRight = true;
	          }
	        } else if (this.dragPosition >= 0) {
	          this.dragPosition = 0;
	        }
	      } else {
	        var _dragPositionMax = 60;
	        var _dragPositionIcon = 40;

	        if (this.dragPosition <= this.dragStartInitialX) {
	          this.dragPosition = this.dragStartInitialX;
	        } else if (this.dragPosition >= _dragPositionMax) {
	          this.dragPosition = _dragPositionMax;
	        } else if (this.dragPosition >= _dragPositionIcon) {
	          if (!this.dragIconShowLeft) {
	            this.dragIconShowLeft = true;
	          }
	        }
	      }
	    }
	  },
	  computed: {
	    MessageType: function MessageType() {
	      return im_const.MessageType;
	    },
	    dialog: function dialog() {
	      var dialog = this.$store.getters['dialogues/get'](this.dialogId);
	      return dialog ? dialog : this.$store.getters['dialogues/getBlank']();
	    },
	    type: function type() {
	      if (this.message.system || this.message.authorId == 0) {
	        return im_const.MessageType.system;
	      } else if (this.message.authorId === -1 || this.message.authorId == this.userId) {
	        return im_const.MessageType.self;
	      } else {
	        return im_const.MessageType.opponent;
	      }
	    },
	    userData: function userData() {
	      return this.$store.getters['users/get'](this.message.authorId, true);
	    },
	    userAvatar: function userAvatar() {
	      if (this.message.params.AVATAR) {
	        return "url('".concat(this.message.params.AVATAR, "')");
	      }

	      if (this.userData.avatar) {
	        return "url('".concat(this.userData.avatar, "')");
	      }

	      return '';
	    },
	    filesData: function filesData() {
	      var files = this.$store.getters['files/getList'](this.chatId);
	      return files ? files : {};
	    },
	    isEdited: function isEdited() {
	      return this.message.params.IS_EDITED === 'Y';
	    },
	    isDeleted: function isDeleted() {
	      return this.message.params.IS_DELETED === 'Y';
	    },
	    isLargeFont: function isLargeFont() {
	      return this.showLargeFont && this.message.params.LARGE_FONT === 'Y';
	    }
	  },
	  template: "\n\t\t<div :class=\"['bx-im-message', {\n\t\t\t\t'bx-im-message-without-menu': !showMenu,\n\t\t\t\t'bx-im-message-without-avatar': !showAvatar,\n\t\t\t\t'bx-im-message-type-system': type === MessageType.system,\n\t\t\t\t'bx-im-message-type-self': type === MessageType.self,\n\t\t\t\t'bx-im-message-type-other': type !== MessageType.self,\n\t\t\t\t'bx-im-message-type-opponent': type === MessageType.opponent,\n\t\t\t\t'bx-im-message-status-error': message.error,\n\t\t\t\t'bx-im-message-status-unread': message.unread,\n\t\t\t\t'bx-im-message-status-blink': message.blink,\n\t\t\t\t'bx-im-message-status-edited': isEdited,\n\t\t\t\t'bx-im-message-status-deleted': isDeleted,\n\t\t\t\t'bx-im-message-large-font': isLargeFont,\n\t\t\t}]\" \n\t\t\t@touchstart=\"gestureRouter('touchstart', $event)\"\n\t\t\t@touchmove=\"gestureRouter('touchmove', $event)\"\n\t\t\t@touchend=\"gestureRouter('touchend', $event)\"\n\t\t\tref=\"body\"\n\t\t\t:style=\"{\n\t\t\t\twidth: dragWidth > 0? dragWidth+'px': '', \n\t\t\t\tmarginLeft: (enableGestureQuoteFromRight && dragPosition < 0) || (!enableGestureQuoteFromRight && dragPosition > 0)? dragPosition+'px': '',\n\t\t\t}\"\n\t\t>\n\t\t\t<template v-if=\"type === MessageType.self\">\n\t\t\t\t<template v-if=\"dragIconShowRight\">\n\t\t\t\t\t<div class=\"bx-im-message-reply bx-im-message-reply-right\">\n\t\t\t\t\t\t<div class=\"bx-im-message-reply-icon\"></div>\n\t\t\t\t\t</div>\n\t\t\t\t</template> \n\t\t\t\t<div class=\"bx-im-message-box\">\n\t\t\t\t\t<component :is=\"componentBodyId\"\n\t\t\t\t\t\t:userId=\"userId\" \n\t\t\t\t\t\t:message=\"message\"\n\t\t\t\t\t\t:dialogId=\"dialogId\"\n\t\t\t\t\t\t:chatId=\"chatId\"\n\t\t\t\t\t\t:messageType=\"type\"\n\t\t\t\t\t\t:showAvatar=\"showAvatar\"\n\t\t\t\t\t\t:showName=\"showName\"\n\t\t\t\t\t\t:enableReactions=\"enableReactions\"\n\t\t\t\t\t\t:referenceContentBodyClassName=\"referenceContentBodyClassName\"\n\t\t\t\t\t\t:referenceContentNameClassName=\"referenceContentNameClassName\"\n\t\t\t\t\t\t@clickByUserName=\"clickByUserName\"\n\t\t\t\t\t\t@clickByUploadCancel=\"clickByUploadCancel\"\n\t\t\t\t\t\t@clickByKeyboardButton=\"clickByKeyboardButton\"\n\t\t\t\t\t\t@clickByChatTeaser=\"clickByChatTeaser\"\n\t\t\t\t\t\t@setReaction=\"setMessageReaction\"\n\t\t\t\t\t\t@openReactionList=\"openMessageReactionList\"\t\n\t\t\t\t\t\t\n\t\t\t\t\t/>\n\t\t\t\t</div>\n\t\t\t\t<div class=\"bx-im-message-box-status\">\n\t\t\t\t\t<template v-if=\"message.sending\">\n\t\t\t\t\t\t<div class=\"bx-im-message-sending\"></div>\n\t\t\t\t\t</template>\n\t\t\t\t\t<transition name=\"bx-im-message-status-retry\">\n\t\t\t\t\t\t<template v-if=\"!message.sending && message.error && message.retry\">\n\t\t\t\t\t\t\t<div class=\"bx-im-message-status-retry\" :title=\"$Bitrix.Loc.getMessage('IM_MESSENGER_MESSAGE_RETRY_TITLE')\" @click=\"clickByMessageRetry({message: message, event: $event})\">\n\t\t\t\t\t\t\t\t<span class=\"bx-im-message-retry-icon\"></span>\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t</template>\n\t\t\t\t\t</transition>\n\t\t\t\t\t<template v-if=\"showMenu && !message.sending && !message.error\">\n\t\t\t\t\t\t<div class=\"bx-im-message-status-menu\" :title=\"$Bitrix.Loc.getMessage('IM_MESSENGER_MESSAGE_MENU_TITLE')\" @click=\"clickByMessageMenu({message: message, event: $event})\">\n\t\t\t\t\t\t\t<span class=\"bx-im-message-menu-icon\"></span>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</template> \n\t\t\t\t</div>\n\t\t\t\t<template v-if=\"dragIconShowLeft\">\n\t\t\t\t\t<div class=\"bx-im-message-reply bx-im-message-reply-left\">\n\t\t\t\t\t\t<div class=\"bx-im-message-reply-icon\"></div>\n\t\t\t\t\t</div>\n\t\t\t\t</template> \n\t\t\t</template>\n\t\t\t<template v-else-if=\"type !== MessageType.self\">\n\t\t\t\t<template v-if=\"dragIconShowLeft\">\n\t\t\t\t\t<div class=\"bx-im-message-reply bx-im-message-reply-left\">\n\t\t\t\t\t\t<div class=\"bx-im-message-reply-icon\"></div>\n\t\t\t\t\t</div>\n\t\t\t\t</template> \n\t\t\t\t<template v-if=\"type === MessageType.opponent\">\n\t\t\t\t\t<div v-if=\"showAvatar\" class=\"bx-im-message-avatar\" @click=\"clickByAvatar({user: userData, event: $event})\">\n\t\t\t\t\t\t<div :class=\"['bx-im-message-avatar-image', {\n\t\t\t\t\t\t\t\t'bx-im-message-avatar-image-default': !userData.avatar\n\t\t\t\t\t\t\t}]\"\n\t\t\t\t\t\t\t:style=\"{\n\t\t\t\t\t\t\t\tbackgroundColor: !userData.avatar? userData.color: '', \n\t\t\t\t\t\t\t\tbackgroundImage: userAvatar\n\t\t\t\t\t\t\t}\" \n\t\t\t\t\t\t\t:title=\"userData.name\"\n\t\t\t\t\t\t></div>\t\n\t\t\t\t\t</div>\n\t\t\t\t</template>\n\t\t\t\t<div class=\"bx-im-message-box\">\n\t\t\t\t\t<component :is=\"componentBodyId\"\n\t\t\t\t\t\t:message=\"message\"\n\t\t\t\t\t\t:userId=\"userId\" \n\t\t\t\t\t\t:dialogId=\"dialogId\"\n\t\t\t\t\t\t:chatId=\"chatId\"\n\t\t\t\t\t\t:messageType=\"type\"\n\t\t\t\t\t\t:files=\"filesData\"\n\t\t\t\t\t\t:showAvatar=\"showAvatar\"\n\t\t\t\t\t\t:showName=\"showName\"\n\t\t\t\t\t\t:enableReactions=\"enableReactions\"\n\t\t\t\t\t\t:referenceContentBodyClassName=\"referenceContentBodyClassName\"\n\t\t\t\t\t\t:referenceContentNameClassName=\"referenceContentNameClassName\"\n\t\t\t\t\t\t@clickByUserName=\"clickByUserName\"\n\t\t\t\t\t\t@clickByUploadCancel=\"clickByUploadCancel\"\n\t\t\t\t\t\t@clickByKeyboardButton=\"clickByKeyboardButton\"\n\t\t\t\t\t\t@clickByChatTeaser=\"clickByChatTeaser\"\n\t\t\t\t\t\t@setReaction=\"setMessageReaction\"\n\t\t\t\t\t\t@openReactionList=\"openMessageReactionList\"\n\t\t\t\t\t/>\t\n\t\t\t\t</div>\n\t\t\t\t<div v-if=\"showMenu\"  class=\"bx-im-message-menu\" :title=\"$Bitrix.Loc.getMessage('IM_MESSENGER_MESSAGE_MENU_TITLE')\" @click=\"clickByMessageMenu({message: message, event: $event})\">\n\t\t\t\t\t<span class=\"bx-im-message-menu-icon\"></span>\n\t\t\t\t</div>\t\n\t\t\t\t<template v-if=\"dragIconShowRight\">\n\t\t\t\t\t<div class=\"bx-im-message-reply bx-im-message-reply-right\">\n\t\t\t\t\t\t<div class=\"bx-im-message-reply-icon\"></div>\n\t\t\t\t\t</div>\n\t\t\t\t</template> \n\t\t\t</template>\n\t\t</div>\n\t"
	});

}((this.window = this.window || {}),window,BX.Messenger.Model,BX,BX.Messenger.Const,BX.Messenger.Lib,BX.Messenger.Lib));
 




// file: /bitrix/js/im/lib/timer/dist/timer.bundle.js
this.BX = this.BX || {};
this.BX.Messenger = this.BX.Messenger || {};
(function (exports) {
	'use strict';

	/**
	 * Bitrix Messenger
	 * Timer manager
	 *
	 * @package bitrix
	 * @subpackage im
	 * @copyright 2001-2019 Bitrix
	 */
	var Timer = /*#__PURE__*/function () {
	  function Timer() {
	    babelHelpers.classCallCheck(this, Timer);
	    this.list = {};
	    this.updateInterval = 1000;
	    clearInterval(this.updateIntervalId);
	    this.updateIntervalId = setInterval(this.worker.bind(this), this.updateInterval);
	  }

	  babelHelpers.createClass(Timer, [{
	    key: "start",
	    value: function start(name) {
	      var id = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'default';
	      var time = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
	      var callback = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
	      var callbackParams = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};
	      id = id == null ? 'default' : id;
	      time = parseFloat(time);

	      if (isNaN(time) || time <= 0) {
	        return false;
	      }

	      time = time * 1000;

	      if (typeof this.list[name] === 'undefined') {
	        this.list[name] = {};
	      }

	      this.list[name][id] = {
	        'dateStop': new Date().getTime() + time,
	        'callback': typeof callback === 'function' ? callback : function () {},
	        'callbackParams': callbackParams
	      };
	      return true;
	    }
	  }, {
	    key: "has",
	    value: function has(name) {
	      var id = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'default';
	      id = id == null ? 'default' : id;

	      if (id.toString().length <= 0 || typeof this.list[name] === 'undefined') {
	        return false;
	      }

	      return !!this.list[name][id];
	    }
	  }, {
	    key: "stop",
	    value: function stop(name) {
	      var id = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'default';
	      var skipCallback = arguments.length > 2 ? arguments[2] : undefined;
	      id = id == null ? 'default' : id;

	      if (id.toString().length <= 0 || typeof this.list[name] === 'undefined') {
	        return false;
	      }

	      if (!this.list[name][id]) {
	        return true;
	      }

	      if (skipCallback !== true) {
	        this.list[name][id]['callback'](id, this.list[name][id]['callbackParams']);
	      }

	      delete this.list[name][id];
	      return true;
	    }
	  }, {
	    key: "stopAll",
	    value: function stopAll(skipCallback) {
	      for (var name in this.list) {
	        if (this.list.hasOwnProperty(name)) {
	          for (var id in this.list[name]) {
	            if (this.list[name].hasOwnProperty(id)) {
	              this.stop(name, id, skipCallback);
	            }
	          }
	        }
	      }

	      return true;
	    }
	  }, {
	    key: "worker",
	    value: function worker() {
	      for (var name in this.list) {
	        if (!this.list.hasOwnProperty(name)) {
	          continue;
	        }

	        for (var id in this.list[name]) {
	          if (!this.list[name].hasOwnProperty(id) || this.list[name][id]['dateStop'] > new Date()) {
	            continue;
	          }

	          this.stop(name, id);
	        }
	      }

	      return true;
	    }
	  }, {
	    key: "clean",
	    value: function clean() {
	      clearInterval(this.updateIntervalId);
	      this.stopAll(true);
	      return true;
	    }
	  }]);
	  return Timer;
	}();

	exports.Timer = Timer;

}((this.BX.Messenger.Lib = this.BX.Messenger.Lib || {})));
 




// file: /bitrix/js/im/lib/clipboard/dist/clipboard.bundle.js
this.BX = this.BX || {};
this.BX.Messenger = this.BX.Messenger || {};
(function (exports) {
	'use strict';

	/**
	 * Bitrix Messenger
	 * Clipboard manager
	 *
	 * @package bitrix
	 * @subpackage im
	 * @copyright 2001-2020 Bitrix
	 */
	var Clipboard = /*#__PURE__*/function () {
	  function Clipboard() {
	    babelHelpers.classCallCheck(this, Clipboard);
	  }

	  babelHelpers.createClass(Clipboard, null, [{
	    key: "copy",
	    value: function copy() {
	      var text = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
	      var store = Clipboard.getStore();

	      if (text) {
	        store.focus();
	        store.value = text;
	        store.selectionStart = 0;
	        document.execCommand("copy");
	      } else {
	        document.execCommand("copy");
	        store.focus();
	        document.execCommand("paste");
	        text = store.value;
	      }

	      Clipboard.removeStore();
	      return text;
	    }
	  }, {
	    key: "getStore",
	    value: function getStore() {
	      if (Clipboard.store) {
	        return Clipboard.store;
	      }

	      Clipboard.store = document.createElement('textarea');
	      Clipboard.store.style = "position: absolute; opacity: 0; top: -1000px; left: -1000px;";
	      document.body.insertBefore(Clipboard.store, document.body.firstChild);
	      return Clipboard.store;
	    }
	  }, {
	    key: "removeStore",
	    value: function removeStore() {
	      if (!Clipboard.store) {
	        return true;
	      }

	      document.body.removeChild(Clipboard.store);
	      Clipboard.store = null;
	      return true;
	    }
	  }]);
	  return Clipboard;
	}();
	Clipboard.store = null;

	exports.Clipboard = Clipboard;

}((this.BX.Messenger.Lib = this.BX.Messenger.Lib || {})));
 




// file: /bitrix/js/im/lib/uploader/dist/uploader.bundle.js
this.BX = this.BX || {};
this.BX.Messenger = this.BX.Messenger || {};
(function (exports,main_core_events) {
	'use strict';

	var FileSender = /*#__PURE__*/function () {
	  function FileSender(task) {
	    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	    babelHelpers.classCallCheck(this, FileSender);
	    babelHelpers.defineProperty(this, "token", null);
	    babelHelpers.defineProperty(this, "nextDataChunkToSend", null);
	    babelHelpers.defineProperty(this, "readOffset", 0);
	    this.diskFolderId = task.diskFolderId;
	    this.listener = task.listener;
	    this.status = task.status;
	    this.taskId = task.taskId;
	    this.fileData = task.fileData;
	    this.fileName = task.fileName || this.fileData.name;
	    this.generateUniqueName = task.generateUniqueName;
	    this.chunkSizeInBytes = task.chunkSize;
	    this.previewBlob = task.previewBlob || null;
	    this.requestToDelete = false;
	    this.listener('onStartUpload', {
	      id: this.taskId,
	      file: this.fileData,
	      previewData: this.previewBlob
	    });
	    this.host = options.host || null;
	    this.actionUploadChunk = options.actionUploadChunk || 'disk.api.content.upload';
	    this.actionCommitFile = options.actionCommitFile || 'disk.api.file.createByContent';
	    this.actionRollbackUpload = options.actionRollbackUpload || 'disk.api.content.rollbackUpload';
	    this.customHeaders = options.customHeaders || null;
	  }

	  babelHelpers.createClass(FileSender, [{
	    key: "uploadContent",
	    value: function uploadContent() {
	      var _this = this;

	      if (this.status === Uploader.STATUSES.CANCELLED) {
	        return;
	      }

	      this.status = Uploader.STATUSES.PROGRESS;
	      this.readNext();
	      var url = "".concat(this.host ? this.host : "", "\n\t\t\t/bitrix/services/main/ajax.php?action=").concat(this.actionUploadChunk, "\n\t\t\t&filename=").concat(this.fileName, "\n\t\t\t").concat(this.token ? "&token=" + this.token : "");
	      var contentRangeHeader = "bytes " + this.readOffset + "-" + (this.readOffset + this.chunkSizeInBytes - 1) + "/" + this.fileData.size;
	      this.calculateProgress();
	      var headers = {
	        "Content-Type": this.fileData.type,
	        "Content-Range": contentRangeHeader
	      };

	      if (!this.customHeaders) {
	        headers['X-Bitrix-Csrf-Token'] = BX.bitrix_sessid();
	      } else //if (this.customHeaders)
	        {
	          for (var customHeader in this.customHeaders) {
	            if (this.customHeaders.hasOwnProperty(customHeader)) {
	              headers[customHeader] = this.customHeaders[customHeader];
	            }
	          }
	        }

	      fetch(url, {
	        method: 'POST',
	        headers: headers,
	        credentials: "include",
	        body: this.nextDataChunkToSend
	      }).then(function (response) {
	        return response.json();
	      }).then(function (result) {
	        if (result.errors.length > 0) {
	          _this.status = Uploader.STATUSES.FAILED;

	          _this.listener('onUploadFileError', {
	            id: _this.taskId,
	            result: result
	          });

	          console.error(result.errors[0].message);
	        } else if (result.data.token) {
	          _this.token = result.data.token;
	          _this.readOffset = _this.readOffset + _this.chunkSizeInBytes;

	          if (!_this.isEndOfFile()) {
	            _this.uploadContent();
	          } else {
	            _this.createFileFromUploadedChunks();
	          }
	        }
	      })["catch"](function (err) {
	        _this.status = Uploader.STATUSES.FAILED;

	        _this.listener('onUploadFileError', {
	          id: _this.taskId,
	          result: err
	        });
	      });
	    }
	  }, {
	    key: "deleteContent",
	    value: function deleteContent() {
	      this.status = Uploader.STATUSES.CANCELLED;
	      this.requestToDelete = true;

	      if (!this.token) {
	        console.error('Empty token.');
	        return;
	      }

	      var url = "".concat(this.host ? this.host : "", "/bitrix/services/main/ajax.php?\n\t\taction=").concat(this.actionRollbackUpload, "&token=").concat(this.token);
	      var headers = {};

	      if (!this.customHeaders) {
	        headers['X-Bitrix-Csrf-Token'] = BX.bitrix_sessid();
	      } else //if (this.customHeaders)
	        {
	          for (var customHeader in this.customHeaders) {
	            if (this.customHeaders.hasOwnProperty(customHeader)) {
	              headers[customHeader] = this.customHeaders[customHeader];
	            }
	          }
	        }

	      fetch(url, {
	        method: 'POST',
	        credentials: "include",
	        headers: headers
	      }).then(function (response) {
	        return response.json();
	      }).then(function (result) {
	        return console.log(result);
	      })["catch"](function (err) {
	        return console.error(err);
	      });
	    }
	  }, {
	    key: "createFileFromUploadedChunks",
	    value: function createFileFromUploadedChunks() {
	      var _this2 = this;

	      if (!this.token) {
	        console.error('Empty token.');
	        return;
	      }

	      if (this.requestToDelete) {
	        return;
	      }

	      var url = "".concat(this.host ? this.host : "", "/bitrix/services/main/ajax.php?action=").concat(this.actionCommitFile, "&filename=").concat(this.fileName) + "&folderId=" + this.diskFolderId + "&contentId=" + this.token + (this.generateUniqueName ? "&generateUniqueName=true" : "");
	      var headers = {
	        "X-Upload-Content-Type": this.fileData.type
	      };

	      if (!this.customHeaders) {
	        headers['X-Bitrix-Csrf-Token'] = BX.bitrix_sessid();
	      } else //if (this.customHeaders)
	        {
	          for (var customHeader in this.customHeaders) {
	            if (this.customHeaders.hasOwnProperty(customHeader)) {
	              headers[customHeader] = this.customHeaders[customHeader];
	            }
	          }
	        }

	      var formData = new FormData();

	      if (this.previewBlob) {
	        formData.append("previewFile", this.previewBlob, "preview_" + this.fileName + ".jpg");
	      }

	      fetch(url, {
	        method: 'POST',
	        headers: headers,
	        credentials: "include",
	        body: formData
	      }).then(function (response) {
	        return response.json();
	      }).then(function (result) {
	        _this2.uploadResult = result;

	        if (result.errors.length > 0) {
	          _this2.status = Uploader.STATUSES.FAILED;

	          _this2.listener('onCreateFileError', {
	            id: _this2.taskId,
	            result: result
	          });

	          console.error(result.errors[0].message);
	        } else {
	          _this2.calculateProgress();

	          _this2.status = Uploader.STATUSES.DONE;

	          _this2.listener('onComplete', {
	            id: _this2.taskId,
	            result: result
	          });
	        }
	      })["catch"](function (err) {
	        _this2.status = Uploader.STATUSES.FAILED;

	        _this2.listener('onCreateFileError', {
	          id: _this2.taskId,
	          result: err
	        });
	      });
	    }
	  }, {
	    key: "calculateProgress",
	    value: function calculateProgress() {
	      this.progress = Math.round(this.readOffset * 100 / this.fileData.size);
	      this.listener('onProgress', {
	        id: this.taskId,
	        progress: this.progress,
	        readOffset: this.readOffset,
	        fileSize: this.fileData.size
	      });
	    }
	  }, {
	    key: "readNext",
	    value: function readNext() {
	      if (this.readOffset + this.chunkSizeInBytes > this.fileData.size) {
	        this.chunkSizeInBytes = this.fileData.size - this.readOffset;
	      }

	      this.nextDataChunkToSend = this.fileData.slice(this.readOffset, this.readOffset + this.chunkSizeInBytes);
	    }
	  }, {
	    key: "isEndOfFile",
	    value: function isEndOfFile() {
	      return this.readOffset >= this.fileData.size;
	    }
	  }]);
	  return FileSender;
	}();

	var Uploader = /*#__PURE__*/function (_EventEmitter) {
	  babelHelpers.inherits(Uploader, _EventEmitter);

	  //1Mb
	  //5Mb
	  //100Mb
	  function Uploader(options) {
	    var _this;

	    babelHelpers.classCallCheck(this, Uploader);
	    _this = babelHelpers.possibleConstructorReturn(this, babelHelpers.getPrototypeOf(Uploader).call(this));
	    babelHelpers.defineProperty(babelHelpers.assertThisInitialized(_this), "queue", []);
	    babelHelpers.defineProperty(babelHelpers.assertThisInitialized(_this), "isCloud", BX.message.isCloud);
	    babelHelpers.defineProperty(babelHelpers.assertThisInitialized(_this), "phpUploadMaxFilesize", BX.message.phpUploadMaxFilesize);
	    babelHelpers.defineProperty(babelHelpers.assertThisInitialized(_this), "phpPostMaxSize", BX.message.phpPostMaxSize);

	    _this.setEventNamespace('BX.Messenger.Lib.Uploader');

	    _this.generatePreview = options.generatePreview || false;

	    if (options) {
	      _this.inputNode = options.inputNode || null;
	      _this.dropNode = options.dropNode || null;
	      _this.fileMaxSize = options.fileMaxSize || null;
	      _this.fileMaxWidth = options.fileMaxWidth || null;
	      _this.fileMaxHeight = options.fileMaxHeight || null;

	      if (options.sender) {
	        _this.senderOptions = {
	          host: options.sender.host,
	          actionUploadChunk: options.sender.actionUploadChunk,
	          actionCommitFile: options.sender.actionCommitFile,
	          actionRollbackUpload: options.sender.actionRollbackUpload,
	          customHeaders: options.sender.customHeaders || null
	        };
	      }

	      _this.assignInput();

	      _this.assignDrop();
	    }

	    return _this;
	  }

	  babelHelpers.createClass(Uploader, [{
	    key: "setInputNode",
	    value: function setInputNode(node) {
	      if (node instanceof HTMLInputElement || Array.isArray(node)) {
	        this.inputNode = node;
	        this.assignInput();
	      }
	    }
	  }, {
	    key: "addFilesFromEvent",
	    value: function addFilesFromEvent(event) {
	      var _this2 = this;

	      Array.from(event.target.files).forEach(function (file) {
	        _this2.emitSelectedFile(file);
	      });
	    }
	  }, {
	    key: "getPreview",
	    value: function getPreview(file) {
	      var _this3 = this;

	      return new Promise(function (resolve, reject) {
	        if (!_this3.generatePreview) {
	          resolve();
	        }

	        if (file instanceof File) {
	          if (file.type.startsWith('video')) {
	            Uploader.getVideoPreviewBlob(file, 10).then(function (blob) {
	              return _this3.getImageDimensions(blob);
	            }).then(function (result) {
	              return resolve(result);
	            })["catch"](function (reason) {
	              return reject(reason);
	            });
	          } else if (file.type.startsWith('image')) {
	            var blob = new Blob([file], {
	              type: file.type
	            });

	            _this3.getImageDimensions(blob).then(function (result) {
	              return resolve(result);
	            });
	          } else {
	            resolve();
	          }
	        } else {
	          reject("Parameter 'file' is not instance of 'File'");
	        }
	      });
	    }
	  }, {
	    key: "addTask",
	    value: function addTask(task) {
	      var _this4 = this;

	      if (!this.isModernBrowser()) {
	        console.warn('Unsupported browser!');
	        return;
	      }

	      if (!this.checkTaskParams(task)) {
	        return;
	      }

	      task.chunkSize = this.calculateChunkSize(task.chunkSize);

	      task.listener = function (event, data) {
	        return _this4.onUploadEvent(event, data);
	      };

	      task.status = Uploader.STATUSES.PENDING;
	      var fileSender = new FileSender(task, this.senderOptions);
	      this.queue.push(fileSender);
	      this.checkUploadQueue();
	    }
	  }, {
	    key: "deleteTask",
	    value: function deleteTask(taskId) {
	      if (!taskId) {
	        return;
	      }

	      this.queue = this.queue.filter(function (queueItem) {
	        if (queueItem.taskId === taskId) {
	          queueItem.deleteContent();
	          return false;
	        }

	        return true;
	      });
	    }
	  }, {
	    key: "getTask",
	    value: function getTask(taskId) {
	      var task = this.queue.find(function (queueItem) {
	        return queueItem.taskId === taskId;
	      });

	      if (task) {
	        return {
	          id: task.id,
	          diskFolderId: task.diskFolderId,
	          fileData: task.fileData,
	          fileName: task.fileName,
	          progress: task.progress,
	          readOffset: task.readOffset,
	          status: task.status,
	          token: task.token,
	          uploadResult: task.uploadResult
	        };
	      }

	      return null;
	    }
	  }, {
	    key: "checkUploadQueue",
	    value: function checkUploadQueue() {
	      if (this.queue.length > 0) {
	        var inProgressTasks = this.queue.filter(function (queueTask) {
	          return queueTask.status === Uploader.STATUSES.PENDING;
	        });

	        if (inProgressTasks.length > 0) {
	          inProgressTasks[0].uploadContent();
	        }
	      }
	    }
	  }, {
	    key: "onUploadEvent",
	    value: function onUploadEvent(event, data) {
	      this.emit(event, data);
	      this.checkUploadQueue();
	    }
	  }, {
	    key: "checkTaskParams",
	    value: function checkTaskParams(task) {
	      if (!task.taskId) {
	        console.error('Empty Task ID.');
	        return false;
	      }

	      if (!task.fileData) {
	        console.error('Empty file data.');
	        return false;
	      }

	      if (!task.diskFolderId) {
	        console.error('Empty disk folder ID.');
	        return false;
	      }

	      if (this.fileMaxSize && this.fileMaxSize < task.fileData.size) {
	        var data = {
	          maxFileSizeLimit: this.fileMaxSize,
	          file: task.fileData
	        };
	        this.emit('onFileMaxSizeExceeded', data);
	        return false;
	      }

	      return true;
	    }
	  }, {
	    key: "calculateChunkSize",
	    value: function calculateChunkSize(taskChunkSize) {
	      var chunk = 0;

	      if (taskChunkSize) {
	        chunk = taskChunkSize;
	      }

	      if (this.isCloud === 'Y') {
	        chunk = chunk < Uploader.CLOUD_MIN_CHUNK_SIZE ? Uploader.CLOUD_MIN_CHUNK_SIZE : chunk;
	        chunk = chunk > Uploader.CLOUD_MAX_CHUNK_SIZE ? Uploader.CLOUD_MAX_CHUNK_SIZE : chunk;
	      } else //if(this.isCloud === 'N')
	        {
	          var maxBoxChunkSize = Math.min(this.phpPostMaxSize, this.phpUploadMaxFilesize);
	          chunk = chunk < Uploader.BOX_MIN_CHUNK_SIZE ? Uploader.BOX_MIN_CHUNK_SIZE : chunk;
	          chunk = chunk > maxBoxChunkSize ? maxBoxChunkSize : chunk;
	        }

	      return chunk;
	    }
	  }, {
	    key: "isModernBrowser",
	    value: function isModernBrowser() {
	      return typeof fetch !== 'undefined';
	    }
	  }, {
	    key: "assignInput",
	    value: function assignInput() {
	      var _this5 = this;

	      if (this.inputNode instanceof HTMLInputElement) {
	        this.setOnChangeEventListener(this.inputNode);
	      } else if (Array.isArray(this.inputNode)) {
	        this.inputNode.forEach(function (node) {
	          if (node instanceof HTMLInputElement) {
	            _this5.setOnChangeEventListener(node);
	          }
	        });
	      }
	    }
	  }, {
	    key: "setOnChangeEventListener",
	    value: function setOnChangeEventListener(inputNode) {
	      var _this6 = this;

	      inputNode.addEventListener('change', function (event) {
	        _this6.addFilesFromEvent(event);
	      }, false);
	    }
	  }, {
	    key: "assignDrop",
	    value: function assignDrop() {
	      var _this7 = this;

	      if (this.dropNode instanceof HTMLElement) {
	        this.setDropEventListener(this.dropNode);
	      } else if (Array.isArray(this.dropNode)) {
	        this.dropNode.forEach(function (node) {
	          if (node instanceof HTMLElement) {
	            _this7.setDropEventListener(node);
	          }
	        });
	      }
	    }
	  }, {
	    key: "setDropEventListener",
	    value: function setDropEventListener(dropNode) {
	      var _this8 = this;

	      dropNode.addEventListener('drop', function (event) {
	        event.preventDefault();
	        event.stopPropagation();
	        Array.from(event.dataTransfer.files).forEach(function (file) {
	          _this8.emitSelectedFile(file);
	        });
	      }, false);
	    }
	  }, {
	    key: "emitSelectedFile",
	    value: function emitSelectedFile(file) {
	      var _this9 = this;

	      var data = {
	        file: file
	      };
	      this.getPreview(file).then(function (previewData) {
	        if (previewData) {
	          data['previewData'] = previewData.blob;
	          data['previewDataWidth'] = previewData.width;
	          data['previewDataHeight'] = previewData.height;

	          if (_this9.fileMaxWidth || _this9.fileMaxHeight) {
	            var isMaxWidthExceeded = _this9.fileMaxWidth === null ? false : _this9.fileMaxWidth < data['previewDataWidth'];
	            var isMaxHeightExceeded = _this9.fileMaxHeight === null ? false : _this9.fileMaxHeight < data['previewDataHeight'];

	            if (isMaxWidthExceeded || isMaxHeightExceeded) {
	              var eventData = {
	                maxWidth: _this9.fileMaxWidth,
	                maxHeight: _this9.fileMaxHeight,
	                fileWidth: data['previewDataWidth'],
	                fileHeight: data['previewDataHeight']
	              };

	              _this9.emit('onFileMaxResolutionExceeded', eventData);

	              return false;
	            }
	          }
	        }

	        _this9.emit('onSelectFile', data);
	      })["catch"](function (err) {
	        console.warn("Couldn't get preview for file ".concat(file.name, ". Error: ").concat(err));

	        _this9.emit('onSelectFile', data);
	      });
	    }
	  }, {
	    key: "getImageDimensions",
	    value: function getImageDimensions(fileBlob) {
	      return new Promise(function (resolved, rejected) {
	        if (!fileBlob) {
	          rejected('getImageDimensions: fileBlob can\'t be empty');
	        }

	        var img = new Image();

	        img.onload = function () {
	          resolved({
	            blob: fileBlob,
	            width: img.width,
	            height: img.height
	          });
	        };

	        img.onerror = function () {
	          rejected();
	        };

	        img.src = URL.createObjectURL(fileBlob);
	      });
	    }
	  }], [{
	    key: "getVideoPreviewBlob",
	    value: function getVideoPreviewBlob(file) {
	      var seekTime = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
	      return new Promise(function (resolve, reject) {
	        var videoPlayer = document.createElement('video');
	        videoPlayer.setAttribute('src', URL.createObjectURL(file));
	        videoPlayer.load();
	        videoPlayer.addEventListener('error', function (error) {
	          reject("Error while loading video file", error);
	        });
	        videoPlayer.addEventListener('loadedmetadata', function () {
	          if (videoPlayer.duration < seekTime) {
	            seekTime = 0; // reject("Too big seekTime for the video.");
	            // return;
	          }

	          videoPlayer.currentTime = seekTime;
	          videoPlayer.addEventListener('seeked', function () {
	            var canvas = document.createElement("canvas");
	            canvas.width = videoPlayer.videoWidth;
	            canvas.height = videoPlayer.videoHeight;
	            var context = canvas.getContext("2d");
	            context.drawImage(videoPlayer, 0, 0, canvas.width, canvas.height);
	            context.canvas.toBlob(function (blob) {
	              return resolve(blob);
	            }, "image/jpeg", 1);
	          });
	        });
	      });
	    }
	  }]);
	  return Uploader;
	}(main_core_events.EventEmitter);
	babelHelpers.defineProperty(Uploader, "STATUSES", {
	  PENDING: 0,
	  PROGRESS: 1,
	  DONE: 2,
	  CANCELLED: 3,
	  FAILED: 4
	});
	babelHelpers.defineProperty(Uploader, "BOX_MIN_CHUNK_SIZE", 1024 * 1024);
	babelHelpers.defineProperty(Uploader, "CLOUD_MIN_CHUNK_SIZE", 1024 * 1024 * 5);
	babelHelpers.defineProperty(Uploader, "CLOUD_MAX_CHUNK_SIZE", 1024 * 1024 * 100);

	exports.Uploader = Uploader;

}((this.BX.Messenger.Lib = this.BX.Messenger.Lib || {}),BX.Event));
 




// file: /bitrix/js/im/mixin/dist/registry.bundle.js
this.BX = this.BX || {};
this.BX.Messenger = this.BX.Messenger || {};
(function (exports,ui_vue_vuex,ui_vue,im_lib_timer,im_lib_clipboard,im_lib_utils,main_core_events,im_const,im_lib_uploader,im_lib_logger) {
	'use strict';

	function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { babelHelpers.defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
	/**
	 * @notice you need to provide this.userId and this.dialogId
	 */

	var DialogCore = {
	  data: function data() {
	    return {
	      dialogState: im_const.DialogState.loading
	    };
	  },
	  created: function created() {
	    this.timer = new im_lib_timer.Timer();
	  },
	  methods: {
	    getController: function getController() {
	      return this.$Bitrix.Data.get('controller');
	    },
	    getApplicationController: function getApplicationController() {
	      return this.getController().application;
	    },
	    getApplication: function getApplication() {
	      return this.$Bitrix.Application.get();
	    },
	    getRestClient: function getRestClient() {
	      return this.$Bitrix.RestClient.get();
	    },
	    getCurrentUser: function getCurrentUser() {
	      return this.$store.getters['users/get'](this.application.common.userId, true);
	    },
	    executeRestAnswer: function executeRestAnswer(method, queryResult, extra) {
	      this.getController().executeRestAnswer(method, queryResult, extra);
	    },
	    isUnreadMessagesLoaded: function isUnreadMessagesLoaded() {
	      if (!this.dialog) {
	        return true;
	      }

	      if (this.dialog.lastMessageId <= 0) {
	        return true;
	      }

	      if (!this.messageCollection || this.messageCollection.length <= 0) {
	        return true;
	      }

	      var lastElementId = 0;

	      for (var index = this.messageCollection.length - 1; index >= 0; index--) {
	        var lastElement = this.messageCollection[index];

	        if (typeof lastElement.id === "number") {
	          lastElementId = lastElement.id;
	          break;
	        }
	      }

	      return lastElementId >= this.dialog.lastMessageId;
	    },
	    //methods used in several mixins
	    openDialog: function openDialog() {//TODO
	    }
	  },
	  computed: _objectSpread(_objectSpread({
	    dialog: function dialog() {
	      var dialog = this.$store.getters['dialogues/get'](this.application.dialog.dialogId);
	      return dialog ? dialog : this.$store.getters['dialogues/getBlank']();
	    },
	    chatId: function chatId() {
	      // if (this.dialog)
	      // {
	      // 	return this.dialog.chatId;
	      // }
	      if (this.application) {
	        return this.application.dialog.chatId;
	      }
	    },
	    // userId()
	    // {
	    // 	return this.application.common.userId;
	    // },
	    diskFolderId: function diskFolderId() {
	      return this.application.dialog.diskFolderId;
	    },
	    messageCollection: function messageCollection() {
	      return this.$store.getters['messages/get'](this.application.dialog.chatId);
	    },
	    isDialogShowingMessages: function isDialogShowingMessages() {
	      var messagesNotEmpty = this.messageCollection && this.messageCollection.length > 0;

	      if (messagesNotEmpty) {
	        this.dialogState = im_const.DialogState.show;
	      } else if (this.dialog && this.dialog.init) {
	        this.dialogState = im_const.DialogState.empty;
	      } else {
	        this.dialogState = im_const.DialogState.loading;
	      }

	      return messagesNotEmpty;
	    },
	    isDarkBackground: function isDarkBackground() {
	      return this.application.options.darkBackground;
	    }
	  }, ui_vue_vuex.WidgetVuex.mapState({
	    application: function application(state) {
	      return state.application;
	    }
	  })), {}, {
	    localize: function localize() {
	      return ui_vue.WidgetBitrixVue.getFilteredPhrases(['IM_DIALOG_', 'IM_UTILS_', 'IM_MESSENGER_DIALOG_', 'IM_QUOTE_'], this);
	    }
	  })
	};

	function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

	function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

	function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
	var DialogReadMessages = {
	  data: function data() {
	    return {
	      lastMessageToRead: null,
	      messagesToRead: []
	    };
	  },
	  created: function created() {
	    main_core_events.EventEmitter.subscribe(im_const.EventType.dialog.readMessage, this.onReadMessage);
	  },
	  beforeDestroy: function beforeDestroy() {
	    main_core_events.EventEmitter.unsubscribe(im_const.EventType.dialog.readMessage, this.onReadMessage);
	  },
	  methods: {
	    onReadMessage: function onReadMessage(_ref) {
	      var event = _ref.data;
	      this.readMessage(event.id).then(function () {
	        return im_lib_logger.Logger.log('Read message complete');
	      })["catch"](function () {
	        return im_lib_logger.Logger.error('Read message failed');
	      });
	    },
	    readMessage: function readMessage() {
	      var _this = this;

	      var messageId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
	      var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
	      var skipAjax = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

	      if (messageId) {
	        this.messagesToRead.push(parseInt(messageId));
	      }

	      this.timer.stop('readMessage', this.chatId, true);
	      this.timer.stop('readMessageServer', this.chatId, true);

	      if (force) {
	        return this.readMessageRequest(skipAjax);
	      }

	      return new Promise(function (resolve, reject) {
	        _this.timer.start('readMessage', _this.chatId, .1, function () {
	          _this.readMessageRequest(skipAjax).then(function (result) {
	            return resolve(result);
	          })["catch"](reject);
	        });
	      });
	    },
	    readMessageRequest: function readMessageRequest() {
	      var _this2 = this;

	      var skipAjax = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
	      return new Promise(function (resolve, reject) {
	        //get max message id from queue
	        var _iterator = _createForOfIteratorHelper(_this2.messagesToRead),
	            _step;

	        try {
	          for (_iterator.s(); !(_step = _iterator.n()).done;) {
	            var messageId = _step.value;

	            if (!_this2.lastMessageToRead) {
	              _this2.lastMessageToRead = messageId;
	            } else if (_this2.lastMessageToRead < messageId) {
	              _this2.lastMessageToRead = messageId;
	            }
	          }
	        } catch (err) {
	          _iterator.e(err);
	        } finally {
	          _iterator.f();
	        }

	        _this2.messagesToRead = [];
	        var lastId = _this2.lastMessageToRead || 0;

	        if (lastId <= 0) {
	          return resolve({
	            lastId: 0
	          });
	        } //read messages on front


	        _this2.$store.dispatch('messages/readMessages', {
	          chatId: _this2.chatId,
	          readId: lastId
	        }).then(function (result) {
	          //decrease counter
	          return _this2.$store.dispatch('dialogues/decreaseCounter', {
	            dialogId: _this2.dialogId,
	            count: result.count
	          });
	        }).then(function () {
	          if (skipAjax) {
	            return resolve({
	              lastId: lastId
	            });
	          } //read messages on server in .5s


	          _this2.timer.start('readMessageServer', _this2.chatId, .5, function () {
	            _this2.getRestClient().callMethod(im_const.RestMethod.imDialogRead, {
	              'DIALOG_ID': _this2.dialogId,
	              'MESSAGE_ID': lastId
	            }).then(function () {
	              return resolve({
	                lastId: lastId
	              });
	            })["catch"](reject);
	          });
	        })["catch"](reject);
	      });
	    }
	  }
	};

	var DialogQuoteMessage = {
	  created: function created() {
	    main_core_events.EventEmitter.subscribe(im_const.EventType.dialog.quoteMessage, this.onQuoteMessage);
	    main_core_events.EventEmitter.subscribe(im_const.EventType.dialog.quotePanelClose, this.onQuotePanelClose);
	  },
	  beforeDestroy: function beforeDestroy() {
	    main_core_events.EventEmitter.unsubscribe(im_const.EventType.dialog.quoteMessage, this.onQuoteMessage);
	    main_core_events.EventEmitter.unsubscribe(im_const.EventType.dialog.quotePanelClose, this.onQuotePanelClose);
	  },
	  methods: {
	    onQuoteMessage: function onQuoteMessage(_ref) {
	      var event = _ref.data;
	      this.quoteMessage({
	        id: event.message.id
	      });
	    },
	    onQuotePanelClose: function onQuotePanelClose() {
	      this.quoteMessageClear();
	    },
	    quoteMessage: function quoteMessage(_ref2) {
	      var id = _ref2.id;
	      this.$store.dispatch('dialogues/update', {
	        dialogId: this.dialogId,
	        fields: {
	          quoteId: id
	        }
	      });
	    },
	    quoteMessageClear: function quoteMessageClear() {
	      this.$store.dispatch('dialogues/update', {
	        dialogId: this.dialogId,
	        fields: {
	          quoteId: 0
	        }
	      });
	    }
	  }
	};

	/**
	 * @notice needs TextareaCore mixin
	 */

	var DialogClickOnCommand = {
	  created: function created() {
	    main_core_events.EventEmitter.subscribe(im_const.EventType.dialog.clickOnCommand, this.onClickOnCommand);
	  },
	  beforeDestroy: function beforeDestroy() {
	    main_core_events.EventEmitter.unsubscribe(im_const.EventType.dialog.clickOnCommand, this.onClickOnCommand);
	  },
	  methods: {
	    onClickOnCommand: function onClickOnCommand(_ref) {
	      var event = _ref.data;

	      if (event.type === 'put') {
	        this.insertText({
	          text: event.value + ' '
	        });
	      } else if (event.type === 'send') {
	        this.addMessageOnClient(event.value);
	      } else {
	        im_lib_logger.Logger.warn('Unprocessed command', event);
	      }
	    }
	  }
	};

	var DialogClickOnMention = {
	  created: function created() {
	    main_core_events.EventEmitter.subscribe(im_const.EventType.dialog.clickOnMention, this.onClickOnMention);
	  },
	  beforeDestroy: function beforeDestroy() {
	    main_core_events.EventEmitter.unsubscribe(im_const.EventType.dialog.clickOnMention, this.onClickOnMention);
	  },
	  methods: {
	    onClickOnMention: function onClickOnMention(_ref) {
	      var event = _ref.data;

	      if (event.type === 'USER') {
	        this.openProfile(event.value);
	      } else if (event.type === 'CHAT') {
	        this.openDialog(event.value);
	      } else if (event.type === 'CALL') {
	        this.openPhoneMenu(event.value);
	      }
	    },
	    openProfile: function openProfile() {//TODO
	    },
	    openPhoneMenu: function openPhoneMenu() {//TODO
	    }
	  }
	};

	var DialogClickOnUserName = {
	  created: function created() {
	    main_core_events.EventEmitter.subscribe(im_const.EventType.dialog.clickOnUserName, this.onClickOnUserName);
	  },
	  beforeDestroy: function beforeDestroy() {
	    main_core_events.EventEmitter.unsubscribe(im_const.EventType.dialog.clickOnUserName, this.onClickOnUserName);
	  },
	  methods: {
	    onClickOnUserName: function onClickOnUserName(_ref) {
	      var event = _ref.data;
	      this.replyToUser(event.user.id, event.user);
	    },
	    replyToUser: function replyToUser() {//TODO
	    }
	  }
	};

	var DialogClickOnMessageMenu = {
	  created: function created() {
	    main_core_events.EventEmitter.subscribe(im_const.EventType.dialog.clickOnMessageMenu, this.onClickOnMessageMenu);
	  },
	  beforeDestroy: function beforeDestroy() {
	    main_core_events.EventEmitter.unsubscribe(im_const.EventType.dialog.clickOnMessageMenu, this.onClickOnMessageMenu);
	  },
	  methods: {
	    onClickOnMessageMenu: function onClickOnMessageMenu(_ref) {
	      var event = _ref.data;
	      this.openMessageMenu(event.message);
	    },
	    openMessageMenu: function openMessageMenu() {//TODO
	    }
	  }
	};

	var DialogClickOnMessageRetry = {
	  created: function created() {
	    main_core_events.EventEmitter.subscribe(im_const.EventType.dialog.clickOnMessageRetry, this.onClickOnMessageRetry);
	  },
	  beforeDestroy: function beforeDestroy() {
	    main_core_events.EventEmitter.unsubscribe(im_const.EventType.dialog.clickOnMessageRetry, this.onClickOnMessageRetry);
	  },
	  methods: {
	    onClickOnMessageRetry: function onClickOnMessageRetry(_ref) {
	      var event = _ref.data;
	      this.retrySendMessage(event.message);
	    },
	    retrySendMessage: function retrySendMessage() {//TODO
	    }
	  }
	};

	var DialogClickOnUploadCancel = {
	  created: function created() {
	    main_core_events.EventEmitter.subscribe(im_const.EventType.dialog.clickOnUploadCancel, this.onClickOnUploadCancel);
	  },
	  beforeDestroy: function beforeDestroy() {
	    main_core_events.EventEmitter.unsubscribe(im_const.EventType.dialog.clickOnUploadCancel, this.onClickOnUploadCancel);
	  },
	  methods: {
	    onClickOnUploadCancel: function onClickOnUploadCancel(_ref) {
	      var event = _ref.data;
	      this.cancelUploadFile(event.file.id);
	    },
	    cancelUploadFile: function cancelUploadFile() {//TODO
	    }
	  }
	};

	var DialogClickOnReadList = {
	  created: function created() {
	    main_core_events.EventEmitter.subscribe(im_const.EventType.dialog.clickOnReadList, this.onClickOnReadList);
	  },
	  beforeDestroy: function beforeDestroy() {
	    main_core_events.EventEmitter.unsubscribe(im_const.EventType.dialog.clickOnReadList, this.onClickOnReadList);
	  },
	  methods: {
	    onClickOnReadList: function onClickOnReadList(_ref) {
	      var event = _ref.data;
	      this.openReadList(event.list);
	    },
	    openReadList: function openReadList() {//TODO
	    }
	  }
	};

	var DialogSetMessageReaction = {
	  created: function created() {
	    main_core_events.EventEmitter.subscribe(im_const.EventType.dialog.setMessageReaction, this.onSetMessageReaction);
	  },
	  beforeDestroy: function beforeDestroy() {
	    main_core_events.EventEmitter.unsubscribe(im_const.EventType.dialog.setMessageReaction, this.onSetMessageReaction);
	  },
	  methods: {
	    onSetMessageReaction: function onSetMessageReaction(_ref) {
	      var event = _ref.data;
	      this.reactMessage(event.message.id, event.reaction);
	    },
	    reactMessage: function reactMessage(messageId) {
	      var action = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'auto';
	      this.getRestClient().callMethod(im_const.RestMethod.imMessageLike, {
	        'MESSAGE_ID': messageId,
	        'ACTION': action === 'auto' ? 'auto' : action === 'set' ? 'plus' : 'minus'
	      });
	    }
	  }
	};

	var DialogOpenMessageReactionList = {
	  created: function created() {
	    main_core_events.EventEmitter.subscribe(im_const.EventType.dialog.openMessageReactionList, this.onOpenMessageReactionList);
	  },
	  beforeDestroy: function beforeDestroy() {
	    main_core_events.EventEmitter.unsubscribe(im_const.EventType.dialog.openMessageReactionList, this.onOpenMessageReactionList);
	  },
	  methods: {
	    onOpenMessageReactionList: function onOpenMessageReactionList(_ref) {
	      var event = _ref.data;
	      this.openMessageReactionList(event.message.id, event.values);
	    },
	    openMessageReactionList: function openMessageReactionList() {//TODO
	    }
	  }
	};

	/**
	 * @notice needs TextareaCore mixin
	 */

	var DialogClickOnKeyboardButton = {
	  created: function created() {
	    main_core_events.EventEmitter.subscribe(im_const.EventType.dialog.clickOnKeyboardButton, this.onClickOnKeyboardButton);
	  },
	  beforeDestroy: function beforeDestroy() {
	    main_core_events.EventEmitter.unsubscribe(im_const.EventType.dialog.clickOnKeyboardButton, this.onClickOnKeyboardButton);
	  },
	  methods: {
	    onClickOnKeyboardButton: function onClickOnKeyboardButton(_ref) {
	      var _this = this;

	      var event = _ref.data;

	      if (event.action === 'ACTION') {
	        var _event$params = event.params,
	            dialogId = _event$params.dialogId,
	            messageId = _event$params.messageId,
	            botId = _event$params.botId,
	            action = _event$params.action,
	            value = _event$params.value;

	        if (action === 'SEND') {
	          this.addMessageOnClient(value);
	          setTimeout(function () {
	            main_core_events.EventEmitter.emit(im_const.EventType.dialog.scrollToBottom, {
	              chatId: _this.chatId,
	              duration: 300,
	              cancelIfScrollChange: false
	            });
	          }, 300);
	        } else if (action === 'PUT') {
	          this.insertText({
	            text: value + ' '
	          });
	        } else if (action === 'CALL') ; else if (action === 'COPY') {
	          im_lib_clipboard.Clipboard.copy(value);
	          BX.UI.Notification.Center.notify({
	            content: this.localize['IM_DIALOG_CLIPBOARD_COPY_SUCCESS'],
	            autoHideDelay: 4000
	          });
	        }

	        return true;
	      }

	      if (event.action === 'COMMAND') {
	        var _event$params2 = event.params,
	            _dialogId = _event$params2.dialogId,
	            _messageId = _event$params2.messageId,
	            _botId = _event$params2.botId,
	            command = _event$params2.command,
	            params = _event$params2.params;
	        this.getRestClient().callMethod(im_const.RestMethod.imMessageCommand, {
	          'MESSAGE_ID': _messageId,
	          'DIALOG_ID': _dialogId,
	          'BOT_ID': _botId,
	          'COMMAND': command,
	          'COMMAND_PARAMS': params
	        });
	        return true;
	      }

	      return false;
	    }
	  }
	};

	var DialogClickOnChatTeaser = {
	  created: function created() {
	    main_core_events.EventEmitter.subscribe(im_const.EventType.dialog.clickOnChatTeaser, this.onClickOnChatTeaser);
	  },
	  beforeDestroy: function beforeDestroy() {
	    main_core_events.EventEmitter.unsubscribe(im_const.EventType.dialog.clickOnChatTeaser, this.onClickOnChatTeaser);
	  },
	  methods: {
	    onClickOnChatTeaser: function onClickOnChatTeaser(_ref) {
	      var _this = this;

	      var event = _ref.data;
	      this.joinParentChat(event.message.id, 'chat' + event.message.params.CHAT_ID).then(function (dialogId) {
	        _this.openDialog(dialogId);
	      })["catch"](function () {});
	      return true;
	    },
	    joinParentChat: function joinParentChat(messageId, dialogId) {
	      var _this2 = this;

	      return new Promise(function (resolve, reject) {
	        if (!messageId || !dialogId) {
	          return reject();
	        }

	        if (typeof _this2.tempJoinChat === 'undefined') {
	          _this2.tempJoinChat = {};
	        } else if (_this2.tempJoinChat['wait']) {
	          return reject();
	        }

	        _this2.tempJoinChat['wait'] = true;

	        _this2.getRestClient().callMethod(im_const.RestMethod.imChatParentJoin, {
	          'DIALOG_ID': dialogId,
	          'MESSAGE_ID': messageId
	        }).then(function () {
	          _this2.tempJoinChat['wait'] = false;
	          _this2.tempJoinChat[dialogId] = true;
	          return resolve(dialogId);
	        })["catch"](function () {
	          _this2.tempJoinChat['wait'] = false;
	          return reject();
	        });
	      });
	    }
	  }
	};

	var DialogClickOnDialog = {
	  created: function created() {
	    main_core_events.EventEmitter.subscribe(im_const.EventType.dialog.clickOnDialog, this.onClickOnDialog);
	  },
	  beforeDestroy: function beforeDestroy() {
	    main_core_events.EventEmitter.unsubscribe(im_const.EventType.dialog.clickOnDialog, this.onClickOnDialog);
	  },
	  methods: {
	    onClickOnDialog: function onClickOnDialog(_ref) {
	      var event = _ref.data;
	      return true;
	    }
	  }
	};

	/**
	 * @notice needs DialogCore mixin
	 */

	var TextareaCore = {
	  data: function data() {
	    return {
	      messagesToSend: []
	    };
	  },
	  created: function created() {
	    main_core_events.EventEmitter.subscribe(im_const.EventType.textarea.sendMessage, this.onSendMessage);
	    main_core_events.EventEmitter.subscribe(im_const.EventType.textarea.startWriting, this.onTextareaStartWriting);
	    main_core_events.EventEmitter.subscribe(im_const.EventType.textarea.appButtonClick, this.onTextareaAppButtonClick);
	    main_core_events.EventEmitter.subscribe(im_const.EventType.textarea.focus, this.onTextareaFocus);
	    main_core_events.EventEmitter.subscribe(im_const.EventType.textarea.blur, this.onTextareaBlur);
	    main_core_events.EventEmitter.subscribe(im_const.EventType.textarea.keyUp, this.onTextareaKeyUp);
	    main_core_events.EventEmitter.subscribe(im_const.EventType.textarea.edit, this.onTextareaEdit);
	  },
	  beforeDestroy: function beforeDestroy() {
	    main_core_events.EventEmitter.unsubscribe(im_const.EventType.textarea.sendMessage, this.onSendMessage);
	    main_core_events.EventEmitter.unsubscribe(im_const.EventType.textarea.startWriting, this.onTextareaStartWriting);
	    main_core_events.EventEmitter.unsubscribe(im_const.EventType.textarea.appButtonClick, this.onTextareaAppButtonClick);
	    main_core_events.EventEmitter.unsubscribe(im_const.EventType.textarea.focus, this.onTextareaFocus);
	    main_core_events.EventEmitter.unsubscribe(im_const.EventType.textarea.blur, this.onTextareaBlur);
	    main_core_events.EventEmitter.unsubscribe(im_const.EventType.textarea.keyUp, this.onTextareaKeyUp);
	    main_core_events.EventEmitter.unsubscribe(im_const.EventType.textarea.edit, this.onTextareaEdit);
	  },
	  methods: {
	    //handlers
	    onSendMessage: function onSendMessage(_ref) {
	      var event = _ref.data;

	      if (!event.text) {
	        return false;
	      }

	      this.addMessageOnClient(event.text);
	    },
	    onTextareaStartWriting: function onTextareaStartWriting(_ref2) {
	      var event = _ref2.data;
	      this.startWriting();
	    },
	    onTextareaAppButtonClick: function onTextareaAppButtonClick(_ref3) {//TODO

	      var event = _ref3.data;
	    },
	    onTextareaFocus: function onTextareaFocus(_ref4) {//TODO

	      var event = _ref4.data;
	    },
	    onTextareaBlur: function onTextareaBlur(_ref5) {//TODO

	      var event = _ref5.data;
	    },
	    onTextareaKeyUp: function onTextareaKeyUp(_ref6) {//TODO

	      var event = _ref6.data;
	    },
	    onTextareaEdit: function onTextareaEdit(_ref7) {//TODO

	      var event = _ref7.data;
	    },
	    //actions
	    addMessageOnClient: function addMessageOnClient() {
	      var _this = this;

	      var text = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
	      var file = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

	      if (!text && !file) {
	        return false;
	      }

	      var quoteId = this.$store.getters['dialogues/getQuoteId'](this.dialogId);

	      if (quoteId) {
	        var quoteMessage = this.$store.getters['messages/getMessage'](this.chatId, quoteId);

	        if (quoteMessage) {
	          var user = null;

	          if (quoteMessage.authorId) {
	            user = this.$store.getters['users/get'](quoteMessage.authorId);
	          }

	          var files = this.$store.getters['files/getList'](this.chatId);
	          var message = [];
	          message.push('-'.repeat(54));
	          message.push((user && user.name ? user.name : this.localize['IM_QUOTE_PANEL_DEFAULT_TITLE']) + ' [' + im_lib_utils.Utils.date.format(quoteMessage.date, null, this.localize) + ']');
	          message.push(im_lib_utils.Utils.text.quote(quoteMessage.text, quoteMessage.params, files, this.localize));
	          message.push('-'.repeat(54));
	          message.push(text);
	          text = message.join("\n");
	          this.quoteMessageClear();
	        }
	      }

	      if (!this.isUnreadMessagesLoaded()) {
	        this.addMessageOnServer({
	          id: 0,
	          chatId: this.chatId,
	          dialogId: this.dialogId,
	          text: text,
	          file: file
	        });
	        this.processMessagesToSendQueue();
	        return true;
	      }

	      var params = {};

	      if (file) {
	        params.FILE_ID = [file.id];
	      }

	      this.$store.dispatch('messages/add', {
	        chatId: this.chatId,
	        authorId: this.userId,
	        text: text,
	        params: params,
	        sending: !file
	      }).then(function (messageId) {
	        main_core_events.EventEmitter.emit(im_const.EventType.dialog.scrollToBottom, {
	          chatId: _this.chatId,
	          cancelIfScrollChange: true
	        });

	        _this.messagesToSend.push({
	          id: messageId,
	          chatId: _this.chatId,
	          dialogId: _this.dialogId,
	          text: text,
	          file: file,
	          sending: false
	        });

	        _this.processMessagesToSendQueue();
	      });
	      return true;
	    },
	    processMessagesToSendQueue: function processMessagesToSendQueue() {
	      var _this2 = this;

	      if (!this.diskFolderId) {
	        this.requestDiskFolderId().then(function () {
	          _this2.processMessagesToSendQueue();
	        })["catch"](function (error) {
	          im_lib_logger.Logger.warn('processMessagesToSendQueue error', error);
	          return false;
	        });
	        return false;
	      }

	      this.messagesToSend.filter(function (element) {
	        return !element.sending;
	      }).forEach(function (element) {
	        element.sending = true;

	        if (element.file) {
	          _this2.addMessageWithFile(element);
	        } else {
	          _this2.addMessageOnServer(element);
	        }
	      });
	      return true;
	    },
	    addMessageOnServer: function addMessageOnServer(element) {
	      var _this3 = this;

	      this.stopWriting();
	      var quoteId = this.$store.getters['dialogues/getQuoteId'](this.dialogId);

	      if (quoteId) {
	        var quoteMessage = this.$store.getters['messages/getMessage'](this.chatId, quoteId);

	        if (quoteMessage) {
	          var user = this.$store.getters['users/get'](quoteMessage.authorId);
	          var newMessage = [];
	          newMessage.push("------------------------------------------------------");
	          newMessage.push(user.name ? user.name : this.localize['IM_QUOTE_PANEL_DEFAULT_TITLE']);
	          newMessage.push(quoteMessage.text);
	          newMessage.push('------------------------------------------------------');
	          newMessage.push(element.text);
	          element.text = newMessage.join("\n");
	          this.quoteMessageClear();
	        }
	      }

	      this.getRestClient().callMethod(im_const.RestMethod.imMessageAdd, {
	        'TEMPLATE_ID': element.id,
	        'DIALOG_ID': element.dialogId,
	        'MESSAGE': element.text
	      }, null, null).then(function (response) {
	        _this3.$store.dispatch('messages/update', {
	          id: element.id,
	          chatId: element.chatId,
	          fields: {
	            id: response.data(),
	            sending: false,
	            error: false
	          }
	        }).then(function () {
	          _this3.$store.dispatch('messages/actionFinish', {
	            id: response.data(),
	            chatId: element.chatId
	          });
	        });
	      })["catch"](function (error) {
	        im_lib_logger.Logger.warn('Error during adding message');
	      });
	      return true;
	    },
	    //writing
	    stopWriting: function stopWriting() {
	      var dialogId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.dialogId;
	      this.timer.stop('writes', dialogId, true);
	      this.timer.stop('writesSend', dialogId, true);
	    },
	    startWriting: function startWriting() {
	      var _this4 = this;

	      var dialogId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.dialogId;

	      if (im_lib_utils.Utils.dialog.isEmptyDialogId(dialogId) || this.timer.has('writes', dialogId)) {
	        return false;
	      }

	      this.timer.start('writes', dialogId, 28);
	      this.timer.start('writesSend', dialogId, 5, function () {
	        _this4.getRestClient().callMethod(im_const.RestMethod.imDialogWriting, {
	          'DIALOG_ID': dialogId
	        })["catch"](function () {
	          _this4.timer.stop('writes', dialogId);
	        });
	      });
	    },
	    insertText: function insertText(event) {
	      main_core_events.EventEmitter.emit(im_const.EventType.textarea.insertText, event);
	    },
	    requestDiskFolderId: function requestDiskFolderId() {
	      var _this5 = this;

	      if (this.requestDiskFolderPromise) {
	        return this.requestDiskFolderPromise;
	      }

	      this.requestDiskFolderPromise = new Promise(function (resolve, reject) {
	        if (_this5.flagRequestDiskFolderIdSended || _this5.diskFolderId) {
	          _this5.flagRequestDiskFolderIdSended = false;
	          resolve();
	          return true;
	        }

	        _this5.flagRequestDiskFolderIdSended = true;

	        _this5.getRestClient().callMethod(im_const.RestMethod.imDiskFolderGet, {
	          chat_id: _this5.chatId
	        }).then(function (response) {
	          _this5.flagRequestDiskFolderIdSended = false;

	          _this5.executeRestAnswer(im_const.RestMethodHandler.imDiskFolderGet, response);

	          resolve();
	        })["catch"](function (error) {
	          _this5.flagRequestDiskFolderIdSended = false;

	          _this5.executeRestAnswer(im_const.RestMethodHandler.imDiskFolderGet, error);

	          reject();
	        });
	      });
	      return this.requestDiskFolderPromise;
	    }
	  }
	};

	/**
	 * @notice creates uploader instance when dialog is inited (dialog.init in model)
	 * @notice define actionUploadChunk and actionCommitFile fields for custom upload methods (e.g. videoconference)
	 * @notice redefine addMessageWithFile for custom headers (e.g. videoconference)
	 */

	var TextareaUploadFile = {
	  created: function created() {
	    main_core_events.EventEmitter.subscribe(im_const.EventType.textarea.fileSelected, this.onTextareaFileSelected);
	  },
	  beforeDestroy: function beforeDestroy() {
	    if (this.uploader) {
	      this.uploader.unsubscribeAll();
	    }

	    main_core_events.EventEmitter.unsubscribe(im_const.EventType.textarea.fileSelected, this.onTextareaFileSelected);
	  },
	  computed: {
	    dialogInited: function dialogInited() {
	      if (!this.dialog) {
	        return false;
	      }

	      return this.dialog.init;
	    }
	  },
	  watch: {
	    dialogInited: function dialogInited(newValue) {
	      if (newValue === true) {
	        this.initUploader();
	      }
	    }
	  },
	  methods: {
	    onTextareaFileSelected: function onTextareaFileSelected(_ref) {
	      var event = _ref.data;
	      var fileInput = event && event.fileChangeEvent && event.fileChangeEvent.target.files.length > 0 ? event.fileChangeEvent : '';

	      if (!fileInput) {
	        return false;
	      }

	      this.uploadFile(fileInput);
	    },
	    addMessageWithFile: function addMessageWithFile(message) {
	      this.stopWriting();
	      this.uploader.addTask({
	        taskId: message.file.id,
	        fileData: message.file.source.file,
	        fileName: message.file.source.file.name,
	        generateUniqueName: true,
	        diskFolderId: this.diskFolderId,
	        previewBlob: message.file.previewBlob
	      });
	    },
	    //uploader
	    uploadFile: function uploadFile(event) {
	      if (!event) {
	        return false;
	      }

	      this.uploader.addFilesFromEvent(event);
	    },
	    initUploader: function initUploader() {
	      var _this = this;

	      this.uploader = new im_lib_uploader.Uploader({
	        generatePreview: true,
	        sender: {
	          actionUploadChunk: this.actionUploadChunk,
	          actionCommitFile: this.actionCommitFile
	        }
	      });
	      this.uploader.subscribe('onStartUpload', function (event) {
	        var eventData = event.getData();
	        im_lib_logger.Logger.log('Uploader: onStartUpload', eventData);

	        _this.$store.dispatch('files/update', {
	          chatId: _this.chatId,
	          id: eventData.id,
	          fields: {
	            status: im_const.FileStatus.upload,
	            progress: 0
	          }
	        });
	      });
	      this.uploader.subscribe('onProgress', function (event) {
	        var eventData = event.getData();
	        im_lib_logger.Logger.log('Uploader: onProgress', eventData);

	        _this.$store.dispatch('files/update', {
	          chatId: _this.chatId,
	          id: eventData.id,
	          fields: {
	            status: im_const.FileStatus.upload,
	            progress: eventData.progress === 100 ? 99 : eventData.progress
	          }
	        });
	      });
	      this.uploader.subscribe('onSelectFile', function (event) {
	        var eventData = event.getData();
	        var file = eventData.file;
	        im_lib_logger.Logger.log('Uploader: onSelectFile', eventData);
	        var fileType = 'file';

	        if (file.type.toString().startsWith('image')) {
	          fileType = 'image';
	        } else if (file.type.toString().startsWith('video')) {
	          fileType = 'video';
	        }

	        _this.$store.dispatch('files/add', {
	          chatId: _this.chatId,
	          authorId: _this.userId,
	          name: file.name,
	          type: fileType,
	          extension: file.name.split('.').splice(-1)[0],
	          size: file.size,
	          image: !eventData.previewData ? false : {
	            width: eventData.previewDataWidth,
	            height: eventData.previewDataHeight
	          },
	          status: im_const.FileStatus.wait,
	          progress: 0,
	          authorName: _this.getCurrentUser().name,
	          urlPreview: eventData.previewData ? URL.createObjectURL(eventData.previewData) : ""
	        }).then(function (fileId) {
	          _this.addMessageOnClient('', {
	            id: fileId,
	            source: eventData,
	            previewBlob: eventData.previewData
	          });
	        });
	      });
	      this.uploader.subscribe('onComplete', function (event) {
	        var eventData = event.getData();
	        im_lib_logger.Logger.log('Uploader: onComplete', eventData);

	        _this.$store.dispatch('files/update', {
	          chatId: _this.chatId,
	          id: eventData.id,
	          fields: {
	            status: im_const.FileStatus.wait,
	            progress: 100
	          }
	        });

	        var message = _this.messagesToSend.find(function (message) {
	          if (message.file) {
	            return message.file.id === eventData.id;
	          }

	          return false;
	        });

	        var fileType = _this.$store.getters['files/get'](_this.chatId, message.file.id, true).type;

	        _this.fileCommit({
	          chatId: _this.chatId,
	          uploadId: eventData.result.data.file.id,
	          messageText: message.text,
	          messageId: message.id,
	          fileId: message.file.id,
	          fileType: fileType
	        }, message);
	      });
	      this.uploader.subscribe('onUploadFileError', function (event) {
	        var eventData = event.getData();
	        im_lib_logger.Logger.log('Uploader: onUploadFileError', eventData);

	        var message = _this.messagesToSend.find(function (message) {
	          if (message.file) {
	            return message.file.id === eventData.id;
	          }

	          return false;
	        });

	        _this.fileError(_this.chatId, message.file.id, message.id);
	      });
	      this.uploader.subscribe('onCreateFileError', function (event) {
	        var eventData = event.getData();
	        im_lib_logger.Logger.log('Uploader: onCreateFileError', eventData);

	        var message = _this.messagesToSend.find(function (message) {
	          if (message.file) {
	            return message.file.id === eventData.id;
	          }

	          return false;
	        });

	        _this.fileError(_this.chatId, message.file.id, message.id);
	      });
	      return new Promise(function (resolve, reject) {
	        return resolve();
	      });
	    },
	    fileCommit: function fileCommit(params, message) {
	      var _this2 = this;

	      this.getRestClient().callMethod(im_const.RestMethod.imDiskFileCommit, {
	        chat_id: params.chatId,
	        upload_id: params.uploadId,
	        message: params.messageText,
	        template_id: params.messageId,
	        file_template_id: params.fileId
	      }, null, null).then(function (response) {
	        _this2.executeRestAnswer(im_const.RestMethodHandler.imDiskFileCommit, response, message);
	      })["catch"](function (error) {
	        _this2.executeRestAnswer(im_const.RestMethodHandler.imDiskFileCommit, error, message);
	      });
	      return true;
	    },
	    fileError: function fileError(chatId, fileId) {
	      var messageId = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
	      this.$store.dispatch('files/update', {
	        chatId: chatId,
	        id: fileId,
	        fields: {
	          status: im_const.FileStatus.error,
	          progress: 0
	        }
	      });

	      if (messageId) {
	        this.$store.dispatch('messages/actionError', {
	          chatId: chatId,
	          id: messageId,
	          retry: false
	        });
	      }
	    }
	  }
	};

	exports.DialogCore = DialogCore;
	exports.DialogReadMessages = DialogReadMessages;
	exports.DialogQuoteMessage = DialogQuoteMessage;
	exports.DialogClickOnCommand = DialogClickOnCommand;
	exports.DialogClickOnMention = DialogClickOnMention;
	exports.DialogClickOnUserName = DialogClickOnUserName;
	exports.DialogClickOnMessageMenu = DialogClickOnMessageMenu;
	exports.DialogClickOnMessageRetry = DialogClickOnMessageRetry;
	exports.DialogClickOnUploadCancel = DialogClickOnUploadCancel;
	exports.DialogClickOnReadList = DialogClickOnReadList;
	exports.DialogSetMessageReaction = DialogSetMessageReaction;
	exports.DialogOpenMessageReactionList = DialogOpenMessageReactionList;
	exports.DialogClickOnKeyboardButton = DialogClickOnKeyboardButton;
	exports.DialogClickOnChatTeaser = DialogClickOnChatTeaser;
	exports.DialogClickOnDialog = DialogClickOnDialog;
	exports.TextareaCore = TextareaCore;
	exports.TextareaUploadFile = TextareaUploadFile;

}((this.BX.Messenger.Mixin = this.BX.Messenger.Mixin || {}),BX,BX,BX.Messenger.Lib,BX.Messenger.Lib,BX.Messenger.Lib,BX.Event,BX.Messenger.Const,BX.Messenger.Lib,BX.Messenger.Lib));
 




// file: /bitrix/js/im/component/dialog/dist/dialog.bundle.js
this.BX = this.BX || {};
(function (exports,im_view_message,im_mixin,im_lib_utils,im_lib_animation,im_lib_logger,main_polyfill_intersectionobserver,ui_vue_vuex,ui_vue,im_const,main_core,main_core_events) {
	'use strict';

	var ObserverType = Object.freeze({
	  read: 'read',
	  none: 'none'
	});
	var RequestMode = Object.freeze({
	  history: 'history',
	  unread: 'unread'
	});
	var DateFormat = Object.freeze({
	  groupTitle: 'groupTitle',
	  readedTitle: 'readedTitle'
	});

	var Placeholder1 = {
	  props: ['element'],
	  created: function created() {
	    var modes = ['self', 'opponent'];
	    var randomIndex = Math.floor(Math.random() * modes.length);
	    this.mode = modes[randomIndex];
	  },
	  computed: {
	    itemClasses: function itemClasses() {
	      var itemClasses = ['im-skeleton-item', 'im-skeleton-item--sm', "".concat(im_const.DialogReferenceClassName.listItem, "-").concat(this.element.id)];

	      if (this.mode === 'self') {
	        itemClasses.push('im-skeleton-item-self');
	      } else {
	        itemClasses.push('im-skeleton-item-opponent');
	      }

	      return itemClasses;
	    }
	  },
	  template: "\n\t\t<div :class=\"itemClasses\" :key=\"element.templateId\">\n\t\t\t<div v-if=\"mode === 'opponent'\" class=\"im-skeleton-logo\"></div>\n\t\t\t<div class=\"im-skeleton-content\">\n\t\t\t\t<div class=\"im-skeleton-line-row\">\n\t\t\t\t\t<div style=\"max-width: 70%\" class=\"im-skeleton-line\"></div>\n\t\t\t\t</div>\n\t\t\t\t<div class=\"im-skeleton-line-row\">\n\t\t\t\t\t<div style=\"max-width: 100%\" class=\"im-skeleton-line\"></div>\n\t\t\t\t\t<div style=\"max-width: 26px; margin-left: auto;\" class=\"im-skeleton-line\"></div>\n\t\t\t\t</div>\n\t\t\t\t<div class=\"im-skeleton-like\"></div>\n\t\t\t</div>\n\t\t</div>\n\t"
	};

	var Placeholder2 = {
	  props: ['element'],
	  created: function created() {
	    var modes = ['self', 'opponent'];
	    var randomIndex = Math.floor(Math.random() * modes.length);
	    this.mode = modes[randomIndex];
	  },
	  computed: {
	    itemClasses: function itemClasses() {
	      var itemClasses = ['im-skeleton-item', 'im-skeleton-item--md', "".concat(im_const.DialogReferenceClassName.listItem, "-").concat(this.element.id)];

	      if (this.mode === 'self') {
	        itemClasses.push('im-skeleton-item-self');
	      } else {
	        itemClasses.push('im-skeleton-item-opponent');
	      }

	      return itemClasses;
	    }
	  },
	  template: "\n\t\t<div :class=\"itemClasses\" :key=\"element.templateId\">\n\t\t\t<div v-if=\"mode === 'opponent'\" class=\"im-skeleton-logo\"></div>\n\t\t\t<div class=\"im-skeleton-content\">\n\t\t\t\t<div class=\"im-skeleton-line-row\">\n\t\t\t\t\t<div style=\"max-width: 35%\" class=\"im-skeleton-line\"></div>\n\t\t\t\t</div>\n\t\t\t\t<div class=\"im-skeleton-line-row\">\n\t\t\t\t\t<div style=\"max-width: 100%\" class=\"im-skeleton-line\"></div>\n\t\t\t\t</div>\n\t\t\t\t<div class=\"im-skeleton-line-row\">\n\t\t\t\t\t<div style=\"max-width: 55%\" class=\"im-skeleton-line\"></div>\n\t\t\t\t\t<div style=\"max-width: 26px; margin-left: auto;\" class=\"im-skeleton-line\"></div>\n\t\t\t\t</div>\n\t\t\t\t<div class=\"im-skeleton-like\"></div>\n\t\t\t</div>\n\t\t</div>\n\t"
	};

	var Placeholder3 = {
	  props: ['element'],
	  created: function created() {
	    var modes = ['self', 'opponent'];
	    var randomIndex = Math.floor(Math.random() * modes.length);
	    this.mode = modes[randomIndex];
	  },
	  computed: {
	    itemClasses: function itemClasses() {
	      var itemClasses = ['im-skeleton-item', 'im-skeleton-item--md', "".concat(im_const.DialogReferenceClassName.listItem, "-").concat(this.element.id)];

	      if (this.mode === 'self') {
	        itemClasses.push('im-skeleton-item-self');
	      } else {
	        itemClasses.push('im-skeleton-item-opponent');
	      }

	      return itemClasses;
	    }
	  },
	  template: "\n\t\t<div :class=\"itemClasses\" :key=\"element.templateId\">\n\t\t\t<div v-if=\"mode === 'opponent'\" class=\"im-skeleton-logo\"></div>\n\t\t\t<div class=\"im-skeleton-content\">\n\t\t\t\t<div class=\"im-skeleton-line-row\">\n\t\t\t\t\t<div style=\"max-width: 35%\" class=\"im-skeleton-line\"></div>\n\t\t\t\t</div>\n\t\t\t\t<div class=\"im-skeleton-line-row\">\n\t\t\t\t\t<div style=\"max-width: 100%\" class=\"im-skeleton-line\"></div>\n\t\t\t\t</div>\n\t\t\t\t<div class=\"im-skeleton-line-row\">\n\t\t\t\t\t<div style=\"max-width: 55%\" class=\"im-skeleton-line\"></div>\n\t\t\t\t</div>\n\t\t\t\t<div class=\"im-skeleton-line-row\">\n\t\t\t\t\t<div style=\"max-width: 26px; margin-left: auto;\" class=\"im-skeleton-line\"></div>\n\t\t\t\t</div>\n\t\t\t\t<div class=\"im-skeleton-like\"></div>\n\t\t\t</div>\n\t\t</div>\n\t"
	};

	function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { babelHelpers.defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
	var MessageList = {
	  /**
	   * @emits EventType.dialog.readMessage
	   * @emits EventType.dialog.quoteMessage
	   * @emits EventType.dialog.clickOnDialog
	   * @emits EventType.dialog.clickOnUserName
	   * @emits EventType.dialog.clickOnUploadCancel
	   * @emits EventType.dialog.clickOnKeyboardButton
	   * @emits EventType.dialog.clickOnChatTeaser
	   * @emits EventType.dialog.clickOnMessageMenu
	   * @emits EventType.dialog.clickOnCommand
	   * @emits EventType.dialog.clickOnMention
	   * @emits EventType.dialog.clickOnMessageRetry
	   * @emits EventType.dialog.clickOnReadList
	   * @emits EventType.dialog.setMessageReaction
	   * @emits EventType.dialog.openMessageReactionList
	   */
	  props: {
	    userId: {
	      type: Number,
	      "default": 0
	    },
	    dialogId: {
	      type: String,
	      "default": "0"
	    },
	    messageLimit: {
	      type: Number,
	      "default": 50
	    },
	    enableReadMessages: {
	      type: Boolean,
	      "default": true
	    },
	    enableReactions: {
	      type: Boolean,
	      "default": true
	    },
	    enableDateActions: {
	      type: Boolean,
	      "default": true
	    },
	    enableCreateContent: {
	      type: Boolean,
	      "default": true
	    },
	    enableGestureQuote: {
	      type: Boolean,
	      "default": true
	    },
	    enableGestureQuoteFromRight: {
	      type: Boolean,
	      "default": true
	    },
	    enableGestureMenu: {
	      type: Boolean,
	      "default": false
	    },
	    showMessageUserName: {
	      type: Boolean,
	      "default": true
	    },
	    showMessageAvatar: {
	      type: Boolean,
	      "default": true
	    },
	    showMessageMenu: {
	      type: Boolean,
	      "default": true
	    }
	  },
	  components: {
	    Placeholder1: Placeholder1,
	    Placeholder2: Placeholder2,
	    Placeholder3: Placeholder3
	  },
	  mixins: [im_mixin.DialogCore, im_mixin.DialogReadMessages],
	  data: function data() {
	    return {
	      messagesSet: false,
	      scrollAnimating: false,
	      showScrollButton: false,
	      captureMove: false,
	      capturedMoveEvent: null,
	      lastMessageId: null,
	      isRequestingHistory: false,
	      historyPagesRequested: 0,
	      stopHistoryLoading: false,
	      isRequestingUnread: false,
	      unreadPagesRequested: 0,
	      placeholderCount: 0,
	      pagesLoaded: 0
	    };
	  },
	  created: function created() {
	    im_lib_logger.Logger.warn('MessageList component is created');
	    this.initParams();
	    this.initEvents();
	  },
	  beforeDestroy: function beforeDestroy() {
	    this.observers = {};
	    clearTimeout(this.scrollButtonShowTimeout);
	    this.clearEvents();
	  },
	  mounted: function mounted() {
	    this.windowFocused = im_lib_utils.Utils.platform.isBitrixMobile() ? true : document.hasFocus();
	    this.getMessageIdsForPagination();
	    this.scrollOnStart();
	  },
	  watch: {
	    // after each dialog switch (without switching to loading state)
	    // we reset messagesSet flag and run scroll on start routine
	    dialogId: function dialogId(newValue, oldValue) {
	      var _this = this;

	      im_lib_logger.Logger.warn('new dialogId in message-list', newValue);
	      this.messagesSet = false;
	      this.$nextTick(function () {
	        _this.scrollOnStart();
	      });
	    }
	  },
	  computed: _objectSpread({
	    TemplateType: function TemplateType() {
	      return im_const.DialogTemplateType;
	    },
	    ObserverType: function ObserverType$$1() {
	      return ObserverType;
	    },
	    DialogReferenceClassName: function DialogReferenceClassName() {
	      return im_const.DialogReferenceClassName;
	    },
	    localize: function localize() {
	      return ui_vue.WidgetBitrixVue.getFilteredPhrases('IM_MESSENGER_DIALOG_', this);
	    },
	    dialog: function dialog() {
	      var dialog = this.$store.getters['dialogues/get'](this.dialogId);
	      return dialog ? dialog : this.$store.getters['dialogues/getBlank']();
	    },
	    collection: function collection() {
	      return this.$store.getters['messages/get'](this.chatId);
	    },
	    formattedCollection: function formattedCollection() {
	      var _this2 = this;

	      this.lastMessageId = 0; //used in readed status

	      this.lastMessageAuthorId = 0; //used in readed status

	      this.firstUnreadMessageId = 0;
	      var lastAuthorId = 0; //used for delimeters

	      var dateGroups = {}; //date grouping nodes

	      var collection = []; //array to return

	      this.collection.forEach(function (element) {
	        if (_this2.messagesSet && (_this2.lastHistoryMessageId === null || _this2.lastHistoryMessageId > element.id)) {
	          im_lib_logger.Logger.warn('setting new lastHistoryMessageId', element.id);
	          _this2.lastHistoryMessageId = element.id;
	        }

	        _this2.lastMessageId = element.id;

	        var group = _this2.getDateGroup(element.date);

	        if (!dateGroups[group.title]) {
	          dateGroups[group.title] = group.id;
	          collection.push(_this2.getDateGroupBlock(group.id, group.title));
	        } else if (lastAuthorId !== element.authorId) {
	          collection.push(_this2.getDelimiterBlock(element.id));
	        }

	        if (element.unread && !_this2.firstUnreadMessageId) {
	          _this2.firstUnreadMessageId = element.id;
	        }

	        collection.push(element);
	        lastAuthorId = element.authorId;
	      }); //remembering author of last message - used in readed status

	      this.lastMessageAuthorId = lastAuthorId;
	      return collection;
	    },
	    writingStatusText: function writingStatusText() {
	      var _this3 = this;

	      clearTimeout(this.scrollToTimeout);

	      if (this.dialog.writingList.length === 0) {
	        return '';
	      } //scroll to bottom


	      if (!this.scrollChangedByUser && !this.showScrollButton) {
	        this.scrollToTimeout = setTimeout(function () {
	          return _this3.animatedScrollToPosition({
	            duration: 500
	          });
	        }, 300);
	      }

	      var text = this.dialog.writingList.map(function (element) {
	        return element.userName;
	      }).join(', ');
	      return this.localize['IM_MESSENGER_DIALOG_WRITES_MESSAGE'].replace('#USER#', text);
	    },
	    statusReaded: function statusReaded() {
	      var _this4 = this;

	      clearTimeout(this.scrollToTimeout);

	      if (this.dialog.readedList.length === 0) {
	        return '';
	      }

	      var text = '';

	      if (this.dialog.type === im_const.DialogType["private"]) {
	        var record = this.dialog.readedList[0];

	        if (record.messageId === this.lastMessageId && record.userId !== this.lastMessageAuthorId) {
	          var dateFormat = this.getDateFormat(DateFormat.readedTitle);
	          var formattedDate = this.getDateObject().format(dateFormat, record.date);
	          text = this.localize['IM_MESSENGER_DIALOG_MESSAGES_READED_USER'].replace('#DATE#', formattedDate);
	        }
	      } else {
	        var readedList = this.dialog.readedList.filter(function (record) {
	          return record.messageId === _this4.lastMessageId && record.userId !== _this4.lastMessageAuthorId;
	        });

	        if (readedList.length === 1) {
	          text = this.localize['IM_MESSENGER_DIALOG_MESSAGES_READED_CHAT'].replace('#USERS#', readedList[0].userName);
	        } else if (readedList.length > 1) {
	          text = this.localize['IM_MESSENGER_DIALOG_MESSAGES_READED_CHAT'].replace('#USERS#', this.localize['IM_MESSENGER_DIALOG_MESSAGES_READED_CHAT_PLURAL'].replace('#USER#', readedList[0].userName).replace('#COUNT#', readedList.length - 1).replace('[LINK]', '').replace('[/LINK]', ''));
	        }
	      }

	      if (!text) {
	        return '';
	      } //scroll to bottom


	      if (!this.scrollChangedByUser && !this.showScrollButton) {
	        this.scrollToTimeout = setTimeout(function () {
	          return _this4.animatedScrollToPosition({
	            duration: 500
	          });
	        }, 300);
	      }

	      return text;
	    },
	    unreadCounter: function unreadCounter() {
	      return this.dialog.counter > 99 ? 999 : this.dialog.counter;
	    },
	    formattedUnreadCounter: function formattedUnreadCounter() {
	      return this.unreadCounter > 99 ? '99+' : this.unreadCounter;
	    },
	    scrollBlocked: function scrollBlocked() {
	      if (this.application.device.type !== im_const.DeviceType.mobile) {
	        return false;
	      }

	      return this.scrollAnimating || this.captureMove;
	    },
	    isDarkBackground: function isDarkBackground() {
	      return this.application.options.darkBackground;
	    },
	    isMobile: function isMobile() {
	      return this.application.device.type === im_const.DeviceType.mobile;
	    },
	    //new
	    isRequestingData: function isRequestingData() {
	      return this.isRequestingHistory || this.isRequestingUnread;
	    },
	    remainingHistoryPages: function remainingHistoryPages() {
	      return Math.ceil((this.dialog.messageCount - this.collection.length) / this.historyMessageLimit);
	    },
	    remainingUnreadPages: function remainingUnreadPages() {
	      // we dont use unread counter now - we reverted unread counter to be max at 99, so we dont know actual counter
	      if (this.isLastIdInCollection) {
	        return 0;
	      }

	      return Math.ceil((this.dialog.messageCount - this.collection.length) / this.unreadMessageLimit);
	    },
	    unreadInCollection: function unreadInCollection() {
	      return this.collection.filter(function (item) {
	        return item.unread === true;
	      });
	    },
	    isLastIdInCollection: function isLastIdInCollection() {
	      return this.collection.map(function (message) {
	        return message.id;
	      }).includes(this.dialog.lastMessageId);
	    },
	    showStatusPlaceholder: function showStatusPlaceholder() {
	      return !this.writingStatusText && !this.statusReaded;
	    },
	    bodyClasses: function bodyClasses() {
	      return [im_const.DialogReferenceClassName.listBody, {
	        'bx-im-dialog-list-scroll-blocked': this.scrollBlocked,
	        'bx-im-dialog-dark-background': this.isDarkBackground,
	        'bx-im-dialog-mobile': this.isMobile
	      }];
	    }
	  }, ui_vue_vuex.WidgetVuex.mapState({
	    application: function application(state) {
	      return state.application;
	    }
	  })),
	  methods: {
	    /* region 01. Init and destroy */
	    initParams: function initParams() {
	      this.placeholdersComposition = this.getPlaceholdersComposition();
	      this.historyMessageLimit = 50;
	      this.unreadMessageLimit = 50;
	      this.showScrollButton = this.unreadCounter > 0;
	      this.scrollingDownThreshold = 1000;
	      this.scrollingUpThreshold = 1000;
	      this.messageScrollOffset = 20;
	      this.lastScroll = 0;
	      this.scrollChangedByUser = false;
	      this.scrollButtonDiff = 100;
	      this.scrollButtonShowTimeout = null;
	      this.scrollPositionChangeTime = new Date().getTime();
	      this.lastRequestTime = new Date().getTime();
	      this.observers = {};
	      this.lastAuthorId = 0;
	      this.lastHistoryMessageId = null;
	      this.firstUnreadMessageId = null;
	      this.lastUnreadMessageId = null;
	      this.dateFormatFunction = null;
	      this.cachedDateGroups = {};
	      this.readMessageQueue = [];
	      this.readMessageTarget = {};
	      this.readVisibleMessagesDelayed = im_lib_utils.Utils.debounce(this.readVisibleMessages, 50, this);
	      this.requestHistoryDelayed = im_lib_utils.Utils.debounce(this.requestHistory, 50, this);
	    },
	    initEvents: function initEvents() {
	      main_core_events.EventEmitter.subscribe(im_const.EventType.dialog.scrollOnStart, this.onScrollOnStart);
	      main_core_events.EventEmitter.subscribe(im_const.EventType.dialog.scrollToBottom, this.onScrollToBottom);
	      main_core_events.EventEmitter.subscribe(im_const.EventType.dialog.readVisibleMessages, this.onReadVisibleMessages);
	      main_core_events.EventEmitter.subscribe(im_const.EventType.dialog.newMessage, this.onNewMessage);
	      main_core_events.EventEmitter.subscribe(im_const.EventType.dialog.requestUnread, this.onExternalUnreadRequest);
	      main_core_events.EventEmitter.subscribe(im_const.EventType.dialog.messagesSet, this.onMessagesSet);
	      main_core_events.EventEmitter.subscribe(im_const.EventType.dialog.beforeMobileKeyboard, this.onBeforeMobileKeyboard);
	      window.addEventListener("orientationchange", this.onOrientationChange);
	      window.addEventListener('focus', this.onWindowFocus);
	      window.addEventListener('blur', this.onWindowBlur);
	      ui_vue.WidgetBitrixVue.event.$on('bitrixmobile:controller:focus', this.onWindowFocus);
	      ui_vue.WidgetBitrixVue.event.$on('bitrixmobile:controller:blur', this.onWindowBlur);
	    },
	    clearEvents: function clearEvents() {
	      main_core_events.EventEmitter.unsubscribe(im_const.EventType.dialog.scrollOnStart, this.onScrollOnStart);
	      main_core_events.EventEmitter.unsubscribe(im_const.EventType.dialog.scrollToBottom, this.onScrollToBottom);
	      main_core_events.EventEmitter.unsubscribe(im_const.EventType.dialog.readVisibleMessages, this.onReadVisibleMessages);
	      main_core_events.EventEmitter.unsubscribe(im_const.EventType.dialog.newMessage, this.onNewMessage);
	      main_core_events.EventEmitter.unsubscribe(im_const.EventType.dialog.requestUnread, this.onExternalUnreadRequest);
	      main_core_events.EventEmitter.unsubscribe(im_const.EventType.dialog.messagesSet, this.onMessagesSet);
	      main_core_events.EventEmitter.unsubscribe(im_const.EventType.dialog.beforeMobileKeyboard, this.onBeforeMobileKeyboard);
	      window.removeEventListener("orientationchange", this.onOrientationChange);
	      window.removeEventListener('focus', this.onWindowFocus);
	      window.removeEventListener('blur', this.onWindowBlur);
	      ui_vue.WidgetBitrixVue.event.$off('bitrixmobile:controller:focus', this.onWindowFocus);
	      ui_vue.WidgetBitrixVue.event.$off('bitrixmobile:controller:blur', this.onWindowBlur);
	    },

	    /* endregion 01. Init and destroy */

	    /* region 02. Event handlers */
	    onReadMessage: function onReadMessage() {//redeclare method to ignore handler from ReadMessages mixin
	    },
	    onDialogClick: function onDialogClick(event) {
	      if (ui_vue.WidgetBitrixVue.testNode(event.target, {
	        className: 'bx-im-message-command'
	      })) {
	        this.onCommandClick(event);
	      } else if (ui_vue.WidgetBitrixVue.testNode(event.target, {
	        className: 'bx-im-mention'
	      })) {
	        this.onMentionClick(event);
	      }

	      this.windowFocused = true;
	      main_core_events.EventEmitter.emit(im_const.EventType.dialog.clickOnDialog, {
	        event: event
	      });
	    },
	    onDialogMove: function onDialogMove(event) {
	      if (!this.captureMove) {
	        return;
	      }

	      this.capturedMoveEvent = event;
	    },
	    onCommandClick: function onCommandClick(event) {
	      var value = '';

	      if (event.target.dataset.entity === 'send' || event.target.dataset.entity === 'put') {
	        value = event.target.nextSibling.innerHTML;
	      } else if (event.target.dataset.entity === 'call') {
	        value = event.target.dataset.command;
	      }

	      main_core_events.EventEmitter.emit(im_const.EventType.dialog.clickOnCommand, {
	        type: event.target.dataset.entity,
	        value: value,
	        event: event
	      });
	    },
	    onMentionClick: function onMentionClick(event) {
	      main_core_events.EventEmitter.emit(im_const.EventType.dialog.clickOnMention, {
	        type: event.target.dataset.type,
	        value: event.target.dataset.value,
	        event: event
	      });
	    },
	    onOrientationChange: function onOrientationChange() {
	      var _this5 = this;

	      clearTimeout(this.scrollToTimeout);

	      if (this.application.device.type !== im_const.DeviceType.mobile) {
	        return false;
	      }

	      im_lib_logger.Logger.log('Orientation changed');

	      if (!this.scrollChangedByUser) {
	        this.scrollToTimeout = setTimeout(function () {
	          return _this5.scrollToBottom({
	            force: true
	          });
	        }, 300);
	      }
	    },
	    onWindowFocus: function onWindowFocus() {
	      this.windowFocused = true;
	      this.readVisibleMessages();
	      return true;
	    },
	    onWindowBlur: function onWindowBlur() {
	      this.windowFocused = false;
	    },
	    onScrollToBottom: function onScrollToBottom() {
	      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	          _ref$data = _ref.data,
	          event = _ref$data === void 0 ? {
	        chatId: 0,
	        force: false,
	        cancelIfScrollChange: false,
	        duration: null
	      } : _ref$data;

	      if (event.chatId !== this.chatId) {
	        return false;
	      }

	      im_lib_logger.Logger.warn('onScrollToBottom', event);
	      event.force = event.force === true;
	      event.cancelIfScrollChange = event.cancelIfScrollChange === true;

	      if (this.firstUnreadMessageId) {
	        im_lib_logger.Logger.warn('Dialog.onScrollToBottom: canceled - unread messages');
	        return false;
	      }

	      if (event.cancelIfScrollChange && this.scrollChangedByUser && this.scrollBeforeMobileKeyboard) {
	        var body = this.$refs.body;
	        this.scrollAfterMobileKeyboard = body.scrollHeight - body.scrollTop - body.clientHeight;
	        var scrollDiff = this.scrollAfterMobileKeyboard - this.scrollBeforeMobileKeyboard;
	        this.animatedScrollToPosition({
	          start: body.scrollTop,
	          end: body.scrollTop + scrollDiff
	        });
	        return true;
	      }

	      this.scrollToBottom(event);
	      return true;
	    },
	    onReadVisibleMessages: function onReadVisibleMessages() {
	      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	          _ref2$data = _ref2.data,
	          event = _ref2$data === void 0 ? {
	        chatId: 0
	      } : _ref2$data;

	      if (event.chatId !== this.chatId) {
	        return false;
	      }

	      im_lib_logger.Logger.warn('onReadVisibleMessages');
	      this.readVisibleMessagesDelayed();
	      return true;
	    },
	    onClickOnUserName: function onClickOnUserName(event) {
	      if (!this.windowFocused) {
	        return false;
	      }

	      main_core_events.EventEmitter.emit(im_const.EventType.dialog.clickOnUserName, event);
	    },
	    onClickOnUploadCancel: function onClickOnUploadCancel(event) {
	      if (!this.windowFocused) {
	        return false;
	      }

	      main_core_events.EventEmitter.emit(im_const.EventType.dialog.clickOnUploadCancel, event);
	    },
	    onClickOnKeyboardButton: function onClickOnKeyboardButton(event) {
	      if (!this.windowFocused) {
	        return false;
	      }

	      main_core_events.EventEmitter.emit(im_const.EventType.dialog.clickOnKeyboardButton, event);
	    },
	    onClickOnChatTeaser: function onClickOnChatTeaser(event) {
	      main_core_events.EventEmitter.emit(im_const.EventType.dialog.clickOnChatTeaser, event);
	    },
	    onClickOnMessageMenu: function onClickOnMessageMenu(event) {
	      if (!this.windowFocused) {
	        return false;
	      }

	      main_core_events.EventEmitter.emit(im_const.EventType.dialog.clickOnMessageMenu, event);
	    },
	    onClickOnMessageRetry: function onClickOnMessageRetry(event) {
	      if (!this.windowFocused) {
	        return false;
	      }

	      main_core_events.EventEmitter.emit(im_const.EventType.dialog.clickOnMessageRetry, event);
	    },
	    onClickOnReadList: function onClickOnReadList(event) {
	      var _this6 = this;

	      var readedList = this.dialog.readedList.filter(function (record) {
	        return record.messageId === _this6.lastMessageId && record.userId !== _this6.lastMessageAuthorId;
	      });
	      main_core_events.EventEmitter.emit(im_const.EventType.dialog.clickOnReadList, {
	        list: readedList,
	        event: event
	      });
	    },
	    onMessageReactionSet: function onMessageReactionSet(event) {
	      main_core_events.EventEmitter.emit(im_const.EventType.dialog.setMessageReaction, event);
	    },
	    onMessageReactionListOpen: function onMessageReactionListOpen(event) {
	      main_core_events.EventEmitter.emit(im_const.EventType.dialog.openMessageReactionList, event);
	    },
	    onDragMessage: function onDragMessage(event) {
	      if (!this.windowFocused) {
	        return false;
	      }

	      this.captureMove = event.result;

	      if (!event.result) {
	        this.capturedMoveEvent = null;
	      }
	    },
	    onQuoteMessage: function onQuoteMessage(event) {
	      if (!this.windowFocused) {
	        return false;
	      }

	      main_core_events.EventEmitter.emit(im_const.EventType.dialog.quoteMessage, event);
	    },
	    onScroll: function onScroll(event) {
	      if (this.isScrolling) {
	        return false;
	      }

	      clearTimeout(this.scrollToTimeout);
	      this.currentScroll = event.target.scrollTop;
	      var isScrollingDown = this.lastScroll < this.currentScroll;
	      var isScrollingUp = !isScrollingDown;

	      if (isScrollingUp && this.scrollButtonClicked) {
	        im_lib_logger.Logger.warn('scrollUp - reset scroll button clicks');
	        this.scrollButtonClicked = false;
	      }

	      var leftSpaceBottom = event.target.scrollHeight - event.target.scrollTop - event.target.clientHeight;

	      if (this.currentScroll > 0 && isScrollingDown && leftSpaceBottom < this.scrollingDownThreshold) {
	        this.onScrollDown();
	      } else if (isScrollingUp && this.currentScroll <= this.scrollingUpThreshold) {
	        this.onScrollUp();
	      } //remember current scroll to compare with new ones


	      this.lastScroll = this.currentScroll;
	      this.scrollPositionChangeTime = new Date().getTime(); //show or hide scroll button

	      this.manageScrollButton(event);
	    },
	    onScrollDown: function onScrollDown() {
	      var _this7 = this;

	      if (!this.messagesSet || this.isLastIdInCollection) {
	        return false;
	      } // Logger.warn('---');
	      // Logger.warn('Want to load unread');
	      // Logger.warn('this.isRequestingData', this.isRequestingData);
	      // Logger.warn('this.unreadPagesRequested', this.unreadPagesRequested);
	      // Logger.warn('this.remainingUnreadPages', this.remainingUnreadPages);


	      if (this.isRequestingData && this.remainingUnreadPages > 0) {
	        this.drawPlaceholders(RequestMode.unread).then(function () {
	          _this7.unreadPagesRequested += 1;
	          im_lib_logger.Logger.warn('Already loading! Draw placeholders and add request, total - ', _this7.unreadPagesRequested);
	        });
	      } else if (!this.isRequestingData && this.remainingUnreadPages > 0) {
	        im_lib_logger.Logger.warn('Starting new unread request');
	        this.isRequestingUnread = true;
	        this.drawPlaceholders(RequestMode.unread).then(function () {
	          _this7.requestUnread();
	        });
	      }
	    },
	    onScrollUp: function onScrollUp() {
	      var _this8 = this;

	      if (!this.messagesSet || this.stopHistoryLoading) {
	        return false;
	      }

	      this.projectedPagesToLoad = 1; //draw 3 sets of placeholders if we are close to top of container

	      if (!this.isMobile && this.$refs.body.scrollTop < this.$refs.body.scrollHeight / 4) {
	        this.projectedPagesToLoad = 3;
	      } // Logger.warn('---');
	      // Logger.warn('Want to load history');
	      // Logger.warn('this.isRequestingData', this.isRequestingData);
	      // Logger.warn('this.historyPagesRequested', this.historyPagesRequested);
	      // Logger.warn('this.remainingHistoryPages', this.remainingHistoryPages);


	      if (this.isRequestingData && this.remainingHistoryPages > 0) {
	        var currentBodyHeight = this.$refs.body.scrollHeight;
	        this.drawPlaceholders(RequestMode.history, this.projectedPagesToLoad).then(function () {
	          if (!_this8.isOverflowAnchorSupported()) {
	            _this8.enableUserScroll();
	          }

	          _this8.historyPagesRequested += _this8.projectedPagesToLoad;
	          im_lib_logger.Logger.warn('Already loading! Draw placeholders and add request, total - ', _this8.historyPagesRequested);
	        });

	        if (!this.isOverflowAnchorSupported()) {
	          im_lib_logger.Logger.warn('Disabling user scroll');
	          this.$nextTick(function () {
	            var heightDifference = _this8.$refs.body.scrollHeight - currentBodyHeight;

	            _this8.disableUserScroll();

	            _this8.forceScrollToPosition(_this8.$refs.body.scrollTop + heightDifference);
	          });
	        }
	      } else if (!this.isRequestingData && this.remainingHistoryPages > 0) {
	        im_lib_logger.Logger.warn('Starting new history request');
	        this.isRequestingHistory = true;
	        var _currentBodyHeight = this.$refs.body.scrollHeight;
	        this.drawPlaceholders(RequestMode.history, this.projectedPagesToLoad).then(function () {
	          _this8.historyPagesRequested = _this8.projectedPagesToLoad - 1;

	          if (!_this8.isOverflowAnchorSupported()) {
	            _this8.enableUserScroll();
	          }

	          _this8.requestHistory();
	        }); //will run right after drawing placeholders, before .then()

	        if (!this.isOverflowAnchorSupported()) {
	          im_lib_logger.Logger.warn('Disabling user scroll');
	          this.$nextTick(function () {
	            var heightDifference = _this8.$refs.body.scrollHeight - _currentBodyHeight;

	            _this8.disableUserScroll();

	            _this8.forceScrollToPosition(_this8.$refs.body.scrollTop + heightDifference);
	          });
	        }
	      }
	    },
	    //TODO: move
	    isOverflowAnchorSupported: function isOverflowAnchorSupported() {
	      return !im_lib_utils.Utils.platform.isBitrixMobile() && !im_lib_utils.Utils.browser.isIe() && !im_lib_utils.Utils.browser.isSafari() && !im_lib_utils.Utils.browser.isSafariBased();
	    },
	    disableUserScroll: function disableUserScroll() {
	      this.$refs.body.classList.add('bx-im-dialog-list-scroll-blocked');
	    },
	    enableUserScroll: function enableUserScroll() {
	      this.$refs.body.classList.remove('bx-im-dialog-list-scroll-blocked');
	    },
	    onScrollButtonClick: function onScrollButtonClick() {
	      im_lib_logger.Logger.warn('Scroll button click', this.scrollButtonClicked); // TODO: now we just do nothing if button was clicked during data request (history or unread)

	      if (this.isRequestingData) {
	        return false;
	      } //we dont have unread - just scroll to bottom


	      if (this.unreadCounter === 0) {
	        this.scrollToBottom();
	        return true;
	      } //it's a second click on button - scroll to last page if we have one


	      if (this.scrollButtonClicked && this.remainingUnreadPages > 0) {
	        im_lib_logger.Logger.warn('Second click on scroll button');
	        this.scrollToLastPage();
	        return true;
	      } //it's a first click - just set the flag and move on


	      this.scrollButtonClicked = true;
	      this.scrollToBottom();
	    },
	    onNewMessage: function onNewMessage(_ref3) {
	      var _this9 = this;

	      var _ref3$data = _ref3.data,
	          chatId = _ref3$data.chatId,
	          messageId = _ref3$data.messageId;

	      if (chatId !== this.chatId) {
	        return false;
	      }

	      im_lib_logger.Logger.warn('Received new message from pull', messageId);

	      if (this.showScrollButton) {
	        return false;
	      }

	      this.$nextTick(function () {
	        //non-focus handling
	        if (!_this9.windowFocused) {
	          var availableScrollHeight = _this9.$refs['body'].scrollHeight - _this9.$refs['body'].clientHeight;

	          if (_this9.currentScroll < availableScrollHeight) {
	            //show scroll button when out of focus and all visible space is filled with unread messaages already
	            _this9.showScrollButton = true;
	          }

	          _this9.scrollToFirstUnreadMessage();

	          return true;
	        } //big message handling


	        var messageElement = _this9.getElementById(messageId);

	        if (!messageElement) {
	          return false;
	        } //if big message - scroll to top of it


	        var body = _this9.$refs.body;

	        if (messageElement.clientHeight > body.clientHeight) {
	          _this9.scrollToMessage({
	            messageId: messageId
	          });

	          return true;
	        } //else - scroll to bottom


	        _this9.animatedScrollToPosition();
	      });
	    },
	    onMessagesSet: function onMessagesSet(_ref4) {
	      var event = _ref4.data;

	      if (event.chatId !== this.chatId) {
	        return false;
	      }

	      if (this.messagesSet === true) {
	        im_lib_logger.Logger.warn('messages are already set');
	        return false;
	      }

	      im_lib_logger.Logger.warn('onMessagesSet', event.chatId);
	      this.messagesSet = true;
	      var force = false; //if we are in top half of container - force scroll to first unread, else - animated scroll

	      if (this.$refs.body.scrollTop < this.$refs.body.scrollHeight / 2) {
	        force = true;
	      }

	      this.scrollToBottom({
	        force: force,
	        cancelIfScrollChange: false
	      });
	    },
	    onBeforeMobileKeyboard: function onBeforeMobileKeyboard(_ref5) {
	      var event = _ref5.data;
	      var body = this.$refs.body;
	      this.scrollBeforeMobileKeyboard = body.scrollHeight - body.scrollTop - body.clientHeight;
	    },
	    onExternalUnreadRequest: function onExternalUnreadRequest() {
	      var _this10 = this;

	      var _ref6 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	          _ref6$data = _ref6.data,
	          event = _ref6$data === void 0 ? {
	        chatId: 0
	      } : _ref6$data;

	      if (event.chatId !== this.chatId) {
	        return false;
	      }

	      im_lib_logger.Logger.warn('onExternalUnreadRequest');
	      this.isRequestingUnread = true;
	      this.drawPlaceholders(RequestMode.unread).then(function () {
	        return _this10.requestUnread();
	      });
	      this.externalUnreadRequestResolve = null;
	      return new Promise(function (resolve, reject) {
	        _this10.externalUnreadRequestResolve = resolve;
	      });
	    },
	    onScrollOnStart: function onScrollOnStart(_ref7) {
	      var event = _ref7.data;

	      if (event.chatId !== this.chatId) {
	        return false;
	      }

	      this.scrollOnStart({
	        force: false
	      });
	    },

	    /* endregion 02. Event handlers */

	    /* region 03. Scrolling */
	    scrollOnStart: function scrollOnStart() {
	      var _ref8 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	          _ref8$force = _ref8.force,
	          force = _ref8$force === void 0 ? true : _ref8$force;

	      im_lib_logger.Logger.warn('scrolling on start of dialog');
	      var unreadId = this.getFirstUnreadMessage();

	      if (unreadId) {
	        this.scrollToFirstUnreadMessage(unreadId, force);
	      } else {
	        var body = this.$refs.body;
	        this.forceScrollToPosition(body.scrollHeight - body.clientHeight);
	      }
	    },
	    //scroll to first unread if counter > 0, else scroll to bottom
	    scrollToBottom: function scrollToBottom() {
	      var _ref9 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	          _ref9$force = _ref9.force,
	          force = _ref9$force === void 0 ? false : _ref9$force,
	          _ref9$cancelIfScrollC = _ref9.cancelIfScrollChange,
	          cancelIfScrollChange = _ref9$cancelIfScrollC === void 0 ? false : _ref9$cancelIfScrollC,
	          _ref9$duration = _ref9.duration,
	          duration = _ref9$duration === void 0 ? null : _ref9$duration;

	      im_lib_logger.Logger.warn('scroll to bottom', force, cancelIfScrollChange, duration);

	      if (cancelIfScrollChange && this.scrollChangedByUser) {
	        return false;
	      }

	      var body = this.$refs.body; //scroll to first unread message if there are unread messages

	      if (this.dialog.counter > 0) {
	        var scrollToMessageId = this.dialog.counter > 1 && this.firstUnreadMessageId ? this.firstUnreadMessageId : this.lastMessageId;
	        this.scrollToFirstUnreadMessage(scrollToMessageId, force);
	        return true;
	      } //hide scroll button because we will scroll to bottom


	      this.showScrollButton = false; //without animation

	      if (force) {
	        this.forceScrollToPosition(body.scrollHeight - body.clientHeight);
	      } //with animation
	      else {
	        var scrollParams = {};

	        if (duration) {
	          scrollParams.duration = duration;
	        }

	        this.animatedScrollToPosition(_objectSpread({}, scrollParams));
	      }
	    },
	    scrollToFirstUnreadMessage: function scrollToFirstUnreadMessage() {
	      var unreadId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
	      var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
	      im_lib_logger.Logger.warn('scroll to first unread');
	      var element = false;

	      if (unreadId !== null) {
	        element = this.getElementById(unreadId);
	      }

	      if (!element) {
	        unreadId = this.getFirstUnreadMessage();
	      }

	      this.scrollToMessage({
	        messageId: unreadId,
	        force: force
	      });
	    },
	    //scroll to message - can be set at the top or at the bottom of screen
	    scrollToMessage: function scrollToMessage(_ref10) {
	      var _ref10$messageId = _ref10.messageId,
	          messageId = _ref10$messageId === void 0 ? 0 : _ref10$messageId,
	          _ref10$force = _ref10.force,
	          force = _ref10$force === void 0 ? false : _ref10$force,
	          _ref10$stickToTop = _ref10.stickToTop,
	          stickToTop = _ref10$stickToTop === void 0 ? true : _ref10$stickToTop;
	      im_lib_logger.Logger.warn('scroll to message');
	      var body = this.$refs.body;
	      var element = this.getElementById(messageId);
	      var end = 0;

	      if (!element) {
	        //if no element found in DOM - scroll to top
	        if (stickToTop) {
	          end = 10;
	        } //if no element and stickToTop = false - scroll to bottom
	        else {
	          end = body.scrollHeight - body.clientHeight;
	        }
	      } else if (stickToTop) {
	        //message will be at the top of screen (+little offset)
	        end = element.offsetTop - this.messageScrollOffset / 2;
	      } else {
	        //message will be at the bottom of screen (+little offset)
	        end = element.offsetTop + element.offsetHeight - body.clientHeight + this.messageScrollOffset / 2;
	      }

	      if (force) {
	        this.forceScrollToPosition(end);
	      } else {
	        this.animatedScrollToPosition({
	          end: end
	        });
	      }

	      return true;
	    },
	    forceScrollToPosition: function forceScrollToPosition(position) {
	      im_lib_logger.Logger.warn('Force scroll to position - ', position);
	      var body = this.$refs.body;

	      if (!body) {
	        return false;
	      }

	      if (this.animateScrollId) {
	        im_lib_animation.Animation.cancel(this.animateScrollId);
	        this.scrollAnimating = false;
	        this.animateScrollId = null;
	      }

	      body.scrollTop = position;
	    },
	    //scroll to provided position with animation, by default - to the bottom
	    animatedScrollToPosition: function animatedScrollToPosition() {
	      var _this11 = this;

	      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	      im_lib_logger.Logger.warn('Animated scroll to - ', params);

	      if (this.animateScrollId) {
	        im_lib_animation.Animation.cancel(this.animateScrollId);
	        this.scrollAnimating = false;
	      }

	      if (typeof params === 'function') {
	        params = {
	          callback: params
	        };
	      }

	      var body = this.$refs.body;

	      if (!body) {
	        if (params.callback && typeof params.callback === 'function') {
	          params.callback();
	        }

	        this.animateScrollId = null;
	        this.scrollAnimating = false;
	        return true;
	      }

	      if (im_lib_utils.Utils.platform.isIos() && im_lib_utils.Utils.platform.getIosVersion() > 12 && im_lib_utils.Utils.platform.getIosVersion() < 13.2) {
	        body.scrollTop = body.scrollHeight - body.clientHeight;
	        return true;
	      }

	      var _params = params,
	          _params$start = _params.start,
	          start = _params$start === void 0 ? body.scrollTop : _params$start,
	          _params$end = _params.end,
	          end = _params$end === void 0 ? body.scrollHeight - body.clientHeight : _params$end,
	          _params$increment = _params.increment,
	          increment = _params$increment === void 0 ? 20 : _params$increment,
	          _callback = _params.callback,
	          _params$duration = _params.duration,
	          duration = _params$duration === void 0 ? 500 : _params$duration;
	      var container = this.$refs.container;

	      if (container && end - start > container.offsetHeight * 3) {
	        start = end - container.offsetHeight * 3;
	        im_lib_logger.Logger.warn('Dialog.animatedScroll: Scroll trajectory has been reduced');
	      }

	      this.scrollAnimating = true;
	      im_lib_logger.Logger.warn('Dialog.animatedScroll: User scroll blocked while scrolling');
	      this.animateScrollId = im_lib_animation.Animation.start({
	        start: start,
	        end: end,
	        increment: increment,
	        duration: duration,
	        element: body,
	        elementProperty: 'scrollTop',
	        callback: function callback() {
	          _this11.animateScrollId = null;
	          _this11.scrollAnimating = false;

	          if (_callback && typeof _callback === 'function') {
	            _callback();
	          }
	        }
	      });
	    },

	    /* endregion 03. Scrolling */

	    /* region 04. Placeholders */
	    drawPlaceholders: function drawPlaceholders(requestMode) {
	      var pagesCount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
	      var limit = requestMode === RequestMode.history ? this.historyMessageLimit : this.unreadMessageLimit;
	      var placeholders = this.generatePlaceholders(limit, pagesCount);
	      return this.$store.dispatch('messages/addPlaceholders', {
	        placeholders: placeholders,
	        requestMode: requestMode
	      });
	    },
	    generatePlaceholders: function generatePlaceholders(amount, pagesCount) {
	      var placeholders = [];

	      for (var i = 0; i < pagesCount; i++) {
	        for (var j = 0; j < this.placeholdersComposition.length; j++) {
	          placeholders.push({
	            id: "placeholder".concat(this.placeholderCount),
	            chatId: this.chatId,
	            templateType: im_const.DialogTemplateType.placeholder,
	            placeholderType: this.placeholdersComposition[j],
	            unread: false
	          });
	          this.placeholderCount++;
	        }
	      }

	      return placeholders;
	    },
	    getPlaceholdersComposition: function getPlaceholdersComposition() {
	      //randomize set of placeholder types (sums up to ~2400px height)
	      //placeholder1 x8, placeholder2 x6, placeholder3 x8
	      return [1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3].sort(function () {
	        return 0.5 - Math.random();
	      });
	    },

	    /* endregion 04. Placeholders */

	    /* region 05. History request */
	    requestHistory: function requestHistory() {
	      var _this12 = this;

	      return this.$Bitrix.RestClient.get().callMethod(im_const.RestMethod.imDialogMessagesGet, {
	        chat_id: this.chatId,
	        last_id: this.lastHistoryMessageId,
	        limit: this.historyMessageLimit,
	        convert_text: 'Y'
	      }).then(function (result) {
	        var newMessages = result.data().messages;

	        if (newMessages.length > 0) {
	          _this12.lastHistoryMessageId = newMessages[newMessages.length - 1].id;
	        }

	        if (newMessages.length < _this12.historyMessageLimit) {
	          _this12.stopHistoryLoading = true;
	        } //files and users


	        _this12.$Bitrix.Data.get('controller').executeRestAnswer(im_const.RestMethodHandler.imDialogMessagesGet, result);

	        return new Promise(function (resolve, reject) {
	          var currentBodyHeight = _this12.$refs.body.scrollHeight;

	          _this12.$store.dispatch('messages/updatePlaceholders', {
	            chatId: _this12.chatId,
	            data: newMessages,
	            firstMessage: _this12.pagesLoaded * _this12.placeholdersComposition.length,
	            amount: _this12.placeholdersComposition.length
	          }).then(function () {
	            if (!_this12.isOverflowAnchorSupported()) {
	              _this12.enableUserScroll();
	            }

	            resolve();
	          });

	          if (!_this12.isOverflowAnchorSupported()) {
	            im_lib_logger.Logger.warn('Disabling user scroll in updating placeholders');

	            _this12.$nextTick(function () {
	              var heightDifference = _this12.$refs.body.scrollHeight - currentBodyHeight;

	              _this12.disableUserScroll();

	              _this12.forceScrollToPosition(_this12.$refs.body.scrollTop + heightDifference);
	            });
	          }
	        });
	      }).then(function () {
	        _this12.pagesLoaded += 1;
	        im_lib_logger.Logger.warn('History page loaded. Total loaded - ', _this12.pagesLoaded);
	        return _this12.onAfterHistoryRequest();
	      })["catch"](function (result) {
	        im_lib_logger.Logger.warn('Request history error', result);
	      });
	    },
	    onAfterHistoryRequest: function onAfterHistoryRequest() {
	      var _this13 = this;

	      im_lib_logger.Logger.warn('onAfterHistoryRequest');

	      if (this.stopHistoryLoading) {
	        im_lib_logger.Logger.warn('stopHistoryLoading, deleting all delayed requests');
	        this.historyPagesRequested = 0;
	      }

	      if (this.historyPagesRequested > 0) {
	        im_lib_logger.Logger.warn('We have delayed requests -', this.historyPagesRequested);
	        this.historyPagesRequested--;
	        return this.requestHistory();
	      } else if (this.$refs.body.scrollTop <= this.scrollingUpThreshold && this.remainingHistoryPages > 0) {
	        im_lib_logger.Logger.warn('currentScroll <= scrollingUpThreshold, requesting next page and scrolling');
	        return this.drawPlaceholders(RequestMode.history).then(function (firstPlaceholderId) {
	          _this13.scrollToMessage({
	            messageId: firstPlaceholderId,
	            force: true,
	            stickToTop: false
	          });

	          return _this13.requestHistory();
	        });
	      } else {
	        im_lib_logger.Logger.warn('No more delayed requests, clearing placeholders');
	        this.$store.dispatch('messages/clearPlaceholders', {
	          chatId: this.chatId
	        });
	        this.isRequestingHistory = false;
	        return true;
	      }
	    },

	    /* endregion 05. History request */

	    /* region 06. Unread request */
	    prepareUnreadRequestParams: function prepareUnreadRequestParams() {
	      var _ref11;

	      return _ref11 = {}, babelHelpers.defineProperty(_ref11, im_const.RestMethodHandler.imDialogRead, [im_const.RestMethod.imDialogRead, {
	        dialog_id: this.dialogId,
	        message_id: this.lastUnreadMessageId
	      }]), babelHelpers.defineProperty(_ref11, im_const.RestMethodHandler.imChatGet, [im_const.RestMethod.imChatGet, {
	        dialog_id: this.dialogId
	      }]), babelHelpers.defineProperty(_ref11, im_const.RestMethodHandler.imDialogMessagesGetUnread, [im_const.RestMethod.imDialogMessagesGet, {
	        chat_id: this.chatId,
	        first_id: this.lastUnreadMessageId,
	        limit: this.unreadMessageLimit,
	        convert_text: 'Y'
	      }]), _ref11;
	    },
	    requestUnread: function requestUnread() {
	      var _this14 = this;

	      if (!this.lastUnreadMessageId) {
	        this.lastUnreadMessageId = this.$store.getters['messages/getLastId'](this.chatId);
	      }

	      if (!this.lastUnreadMessageId) {
	        return false;
	      }

	      this.readMessage(this.lastUnreadMessageId, true, true).then(function () {
	        _this14.$Bitrix.RestClient.get().callBatch(_this14.prepareUnreadRequestParams(), function (response) {
	          return _this14.onUnreadRequest(response);
	        });
	      });
	    },
	    onUnreadRequest: function onUnreadRequest(response) {
	      var _this15 = this;

	      if (!response) {
	        im_lib_logger.Logger.warn('Unread request: callBatch error');
	        return false;
	      }

	      var chatGetResult = response[im_const.RestMethodHandler.imChatGet];

	      if (chatGetResult.error()) {
	        im_lib_logger.Logger.warn('Unread request: imChatGet error', chatGetResult.error());
	        return false;
	      }

	      this.$Bitrix.Data.get('controller').executeRestAnswer(im_const.RestMethodHandler.imChatGet, chatGetResult);
	      var dialogMessageUnread = response[im_const.RestMethodHandler.imDialogMessagesGetUnread];

	      if (dialogMessageUnread.error()) {
	        im_lib_logger.Logger.warn('Unread request: imDialogMessagesGetUnread error', dialogMessageUnread.error());
	        return false;
	      }

	      var newMessages = dialogMessageUnread.data().messages;

	      if (newMessages.length > 0) {
	        this.lastUnreadMessageId = newMessages[newMessages.length - 1].id;
	      }

	      this.$Bitrix.Data.get('controller').executeRestAnswer(im_const.RestMethodHandler.imDialogMessagesGetUnread, dialogMessageUnread);
	      this.$store.dispatch('messages/updatePlaceholders', {
	        chatId: this.chatId,
	        data: newMessages,
	        firstMessage: this.pagesLoaded * this.placeholdersComposition.length,
	        amount: this.placeholdersComposition.length
	      }).then(function () {
	        _this15.pagesLoaded += 1;
	        im_lib_logger.Logger.warn('Unread page loaded. Total loaded - ', _this15.pagesLoaded);
	        return _this15.onAfterUnreadRequest();
	      })["catch"](function (result) {
	        im_lib_logger.Logger.warn('Unread history error', result);
	      });
	    },
	    onAfterUnreadRequest: function onAfterUnreadRequest() {
	      if (this.unreadPagesRequested > 0) {
	        im_lib_logger.Logger.warn('We have delayed requests -', this.unreadPagesRequested);
	        this.unreadPagesRequested--;
	        return this.requestUnread();
	      } else {
	        im_lib_logger.Logger.warn('No more delayed requests, clearing placeholders');
	        this.$store.dispatch('messages/clearPlaceholders', {
	          chatId: this.chatId
	        });
	        this.isRequestingUnread = false;

	        if (this.externalUnreadRequestResolve) {
	          this.externalUnreadRequestResolve();
	        }

	        return true;
	      }
	    },

	    /* endregion 06. Unread request */

	    /* region 07. Last page request */
	    scrollToLastPage: function scrollToLastPage() {
	      var _this16 = this;

	      im_lib_logger.Logger.warn('Load last page'); //draw placeholders at the bottom

	      this.drawPlaceholders(RequestMode.unread).then(function () {
	        //block unread and history requests
	        _this16.isScrolling = true;

	        _this16.animatedScrollToPosition({
	          callback: function callback() {
	            return _this16.onScrollToLastPage();
	          }
	        });
	      });
	    },
	    onScrollToLastPage: function onScrollToLastPage() {
	      var _this17 = this;

	      //hide scroll button
	      this.showScrollButton = false; //set counter to 0

	      this.$store.dispatch('dialogues/update', {
	        dialogId: this.dialogId,
	        fields: {
	          counter: 0
	        }
	      }); //clear all messages except placeholders

	      this.$store.dispatch('messages/clear', {
	        chatId: this.chatId,
	        keepPlaceholders: true
	      }); //call batch - imDialogRead, imChatGet, imDialogMessagesGet

	      this.$Bitrix.RestClient.get().callBatch(this.prepareLastPageRequestParams(), function (response) {
	        return _this17.onLastPageRequest(response);
	      });
	    },
	    prepareLastPageRequestParams: function prepareLastPageRequestParams() {
	      var _ref12;

	      return _ref12 = {}, babelHelpers.defineProperty(_ref12, im_const.RestMethodHandler.imDialogRead, [im_const.RestMethod.imDialogRead, {
	        dialog_id: this.dialogId
	      }]), babelHelpers.defineProperty(_ref12, im_const.RestMethodHandler.imChatGet, [im_const.RestMethod.imChatGet, {
	        dialog_id: this.dialogId
	      }]), babelHelpers.defineProperty(_ref12, im_const.RestMethodHandler.imDialogMessagesGet, [im_const.RestMethod.imDialogMessagesGet, {
	        chat_id: this.chatId,
	        limit: this.unreadMessageLimit,
	        convert_text: 'Y'
	      }]), _ref12;
	    },
	    onLastPageRequest: function onLastPageRequest(response) {
	      var _this18 = this;

	      if (!response) {
	        im_lib_logger.Logger.warn('Last page request: callBatch error');
	        return false;
	      } //imChatGet handle


	      var chatGetResult = response[im_const.RestMethodHandler.imChatGet];

	      if (chatGetResult.error()) {
	        im_lib_logger.Logger.warn('Last page request: imChatGet error', chatGetResult.error());
	        return false;
	      }

	      this.$Bitrix.Data.get('controller').executeRestAnswer(im_const.RestMethodHandler.imChatGet, chatGetResult); //imDialogMessagesGet handle

	      var lastPageMessages = response[im_const.RestMethodHandler.imDialogMessagesGet];

	      if (lastPageMessages.error()) {
	        im_lib_logger.Logger.warn('Last page request: imDialogMessagesGet error', lastPageMessages.error());
	        return false;
	      }

	      var newMessages = lastPageMessages.data().messages.reverse(); //handle files and users

	      this.$Bitrix.Data.get('controller').executeRestAnswer(im_const.RestMethodHandler.imDialogMessagesGet, lastPageMessages); //update placeholders to real messages

	      this.$store.dispatch('messages/updatePlaceholders', {
	        chatId: this.chatId,
	        data: newMessages,
	        firstMessage: this.pagesLoaded * this.placeholdersComposition.length,
	        amount: this.placeholdersComposition.length
	      }).then(function () {
	        //get id for history requests and increase pages counter to count placeholders on next requests
	        _this18.lastHistoryMessageId = _this18.collection[0].id;
	        _this18.pagesLoaded += 1; //clear remaining placeholders

	        return _this18.$store.dispatch('messages/clearPlaceholders', {
	          chatId: _this18.chatId
	        });
	      }).then(function () {
	        _this18.scrollToBottom({
	          force: true
	        }); //enable history requests on scroll up


	        _this18.stopHistoryLoading = false;
	        _this18.isScrolling = false;
	      })["catch"](function (result) {
	        im_lib_logger.Logger.warn('Unread history error', result);
	      });
	    },

	    /* endregion 07. Last page request */

	    /* region 08. Read messages */
	    readVisibleMessages: function readVisibleMessages() {
	      var _this19 = this;

	      if (!this.windowFocused || !this.messagesSet) {
	        im_lib_logger.Logger.warn('reading is disabled!');
	        return false;
	      } //need to filter that way to empty array after async method on every element was completed


	      this.readMessageQueue = this.readMessageQueue.filter(function (messageId) {
	        if (_this19.readMessageTarget[messageId]) {
	          if (_this19.observers[ObserverType.read]) {
	            _this19.observers[ObserverType.read].unobserve(_this19.readMessageTarget[messageId]);
	          }

	          delete _this19.readMessageTarget[messageId];
	        }

	        _this19.requestReadVisibleMessages(messageId);

	        return false;
	      });
	    },
	    requestReadVisibleMessages: function requestReadVisibleMessages(messageId) {
	      main_core_events.EventEmitter.emit(im_const.EventType.dialog.readMessage, {
	        id: messageId
	      });
	    },

	    /* endregion 08. Read messages */

	    /* region 09. Helpers */
	    getMessageIdsForPagination: function getMessageIdsForPagination() {
	      // console.warn('this.collection.length', this.collection.length);
	      // if (this.collection.length > 0)
	      // {
	      // 	console.warn('this.collection.length', this.collection[0].id);
	      // 	this.lastHistoryMessageId = this.collection[0].id;
	      // }
	      //
	      if (this.unreadInCollection.length > 0) {
	        this.lastUnreadMessageId = this.unreadInCollection[this.unreadInCollection.length - 1].id;
	      }
	    },
	    getFirstUnreadMessage: function getFirstUnreadMessage() {
	      var unreadId = null;

	      for (var index = this.collection.length - 1; index >= 0; index--) {
	        if (!this.collection[index].unread) {
	          break;
	        }

	        unreadId = this.collection[index].id;
	      }

	      return unreadId;
	    },
	    manageScrollButton: function manageScrollButton(event) {
	      var _this20 = this;

	      var availableScrollHeight = event.target.scrollHeight - event.target.clientHeight;
	      this.scrollChangedByUser = this.currentScroll + this.scrollButtonDiff < availableScrollHeight;
	      clearTimeout(this.scrollButtonShowTimeout);
	      this.scrollButtonShowTimeout = setTimeout(function () {
	        if (_this20.scrollChangedByUser) {
	          //if user scroll and there is no scroll button - show it
	          if (!_this20.showScrollButton) {
	            _this20.showScrollButton = true;
	          }
	        } else {
	          //if not user scroll, there was scroll button and no more unread to load - hide it
	          if (_this20.showScrollButton && _this20.remainingUnreadPages === 0) {
	            _this20.showScrollButton = false;
	          }
	        }
	      }, 200); //if we are at the bottom

	      if (event.target.scrollTop === event.target.scrollHeight - event.target.offsetHeight) {
	        clearTimeout(this.scrollButtonShowTimeout);

	        if (this.showScrollButton && this.remainingUnreadPages === 0) {
	          this.showScrollButton = false;
	        }
	      }
	    },
	    getDateObject: function getDateObject() {
	      var _this21 = this;

	      if (this.dateFormatFunction) {
	        return this.dateFormatFunction;
	      }

	      this.dateFormatFunction = Object.create(BX.Main.Date);

	      this.dateFormatFunction._getMessage = function (phrase) {
	        return _this21.$Bitrix.Loc.getMessage(phrase);
	      };

	      return this.dateFormatFunction;
	    },
	    getDateGroup: function getDateGroup(date) {
	      var id = date.toJSON().slice(0, 10);

	      if (this.cachedDateGroups[id]) {
	        return this.cachedDateGroups[id];
	      }

	      var dateFormat = this.getDateFormat(DateFormat.groupTitle);
	      this.cachedDateGroups[id] = {
	        id: id,
	        title: this.getDateObject().format(dateFormat, date)
	      };
	      return this.cachedDateGroups[id];
	    },
	    getDateFormat: function getDateFormat(type) {
	      return im_lib_utils.Utils.date.getFormatType(BX.Messenger.Const.DateFormat[type], this.$Bitrix.Loc.getMessages());
	    },
	    getDateGroupBlock: function getDateGroupBlock() {
	      var id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
	      var text = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
	      return {
	        templateId: 'group' + id,
	        templateType: im_const.DialogTemplateType.group,
	        text: text
	      };
	    },
	    getDelimiterBlock: function getDelimiterBlock() {
	      var id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
	      return {
	        templateId: 'delimiter' + id,
	        templateType: im_const.DialogTemplateType.delimiter
	      };
	    },
	    getObserver: function getObserver(config) {
	      var _this22 = this;

	      if (typeof window.IntersectionObserver === 'undefined' || config.type === ObserverType.none) {
	        return {
	          observe: function observe() {},
	          unobserve: function unobserve() {}
	        };
	      }

	      var observerCallback, observerOptions;

	      observerCallback = function observerCallback(entries) {
	        entries.forEach(function (entry) {
	          var sendReadEvent = false;

	          if (entry.isIntersecting) {
	            //on windows with interface scaling intersectionRatio will never be 1
	            if (entry.intersectionRatio >= 0.99) {
	              sendReadEvent = true;
	            } else if (entry.intersectionRatio > 0 && entry.rootBounds.height < entry.boundingClientRect.height + 20 && entry.intersectionRect.height > entry.rootBounds.height / 2) {
	              sendReadEvent = true;
	            }
	          }

	          if (sendReadEvent) {
	            _this22.readMessageQueue.push(entry.target.dataset.messageId);

	            _this22.readMessageTarget[entry.target.dataset.messageId] = entry.target;
	          } else {
	            _this22.readMessageQueue = _this22.readMessageQueue.filter(function (messageId) {
	              return messageId !== entry.target.dataset.messageId;
	            });
	            delete _this22.readMessageTarget[entry.target.dataset.messageId];
	          }

	          if (_this22.enableReadMessages) {
	            _this22.readVisibleMessagesDelayed();
	          }
	        });
	      };

	      observerOptions = {
	        root: this.$refs.body,
	        threshold: new Array(101).fill(0).map(function (zero, index) {
	          return index * 0.01;
	        })
	      };
	      return new IntersectionObserver(observerCallback, observerOptions);
	    },
	    getElementClass: function getElementClass(elementId) {
	      var classWithId = im_const.DialogReferenceClassName.listItem + '-' + elementId;
	      return ['bx-im-dialog-list-item', im_const.DialogReferenceClassName.listItem, classWithId];
	    },
	    getElementById: function getElementById(elementId) {
	      var body = this.$refs.body;
	      var className = im_const.DialogReferenceClassName.listItem + '-' + elementId;
	      return body.getElementsByClassName(className)[0];
	    },
	    getPlaceholderClass: function getPlaceholderClass(elementId) {
	      var classWithId = im_const.DialogReferenceClassName.listItem + '-' + elementId;
	      return ['im-skeleton-item', 'im-skeleton-item-1', 'im-skeleton-item--sm', classWithId];
	    }
	    /* endregion 09. Helpers */

	  },
	  directives: {
	    'bx-im-directive-dialog-observer': {
	      inserted: function inserted(element, bindings, vnode) {
	        if (bindings.value === ObserverType.none) {
	          return false;
	        }

	        if (!vnode.context.observers[bindings.value]) {
	          vnode.context.observers[bindings.value] = vnode.context.getObserver({
	            type: bindings.value
	          });
	        }

	        vnode.context.observers[bindings.value].observe(element);
	        return true;
	      },
	      unbind: function unbind(element, bindings, vnode) {
	        if (bindings.value === ObserverType.none) {
	          return true;
	        }

	        if (vnode.context.observers[bindings.value]) {
	          vnode.context.observers[bindings.value].unobserve(element);
	        }

	        return true;
	      }
	    }
	  },
	  // language=Vue
	  template: "\n\t<div class=\"bx-im-dialog\" @click=\"onDialogClick\" @touchmove=\"onDialogMove\" ref=\"container\">\n\t\t<div :class=\"bodyClasses\" @scroll.passive=\"onScroll\" ref=\"body\">\n\t\t\t<!-- Main elements loop -->\n\t\t\t<template v-for=\"(element, index) in formattedCollection\">\n\t\t\t\t<!-- Message -->\n\t\t\t\t<template v-if=\"element.templateType === TemplateType.message\">\n\t\t\t\t\t<div\n\t\t\t\t\t\t:class=\"getElementClass(element.id)\"\n\t\t\t\t\t\t:data-message-id=\"element.id\"\n\t\t\t\t\t\t:data-template-id=\"element.templateId\"\n\t\t\t\t\t\t:data-type=\"element.templateType\" \n\t\t\t\t\t\t:key=\"element.templateId\"\n\t\t\t\t\t\tv-bx-im-directive-dialog-observer=\"element.unread? ObserverType.read: ObserverType.none\"\n\t\t\t\t\t>\t\t\t\t\n<!--\t\t\t\t\t  <div style=\"width: 200px; height: 50px; margin-top: 5px; background: #000; color: #fff;\">{{ element.textConverted }}</div>-->\n\t\t\t\t\t\t<component :is=\"element.params.COMPONENT_ID\"\n\t\t\t\t\t\t\t:userId=\"userId\" \n\t\t\t\t\t\t\t:dialogId=\"dialogId\"\n\t\t\t\t\t\t\t:chatId=\"chatId\"\n\t\t\t\t\t\t\t:message=\"element\"\n\t\t\t\t\t\t\t:enableReactions=\"enableReactions\"\n\t\t\t\t\t\t\t:enableDateActions=\"enableDateActions\"\n\t\t\t\t\t\t\t:enableCreateContent=\"showMessageMenu\"\n\t\t\t\t\t\t\t:enableGestureQuote=\"enableGestureQuote\"\n\t\t\t\t\t\t\t:enableGestureQuoteFromRight=\"enableGestureQuoteFromRight\"\n\t\t\t\t\t\t\t:enableGestureMenu=\"enableGestureMenu\"\n\t\t\t\t\t\t\t:showName=\"showMessageUserName\"\n\t\t\t\t\t\t\t:showAvatar=\"showMessageAvatar\"\n\t\t\t\t\t\t\t:showMenu=\"showMessageMenu\"\n\t\t\t\t\t\t\t:capturedMoveEvent=\"capturedMoveEvent\"\n\t\t\t\t\t\t\t:referenceContentClassName=\"DialogReferenceClassName.listItem\"\n\t\t\t\t\t\t\t:referenceContentBodyClassName=\"DialogReferenceClassName.listItemBody\"\n\t\t\t\t\t\t\t:referenceContentNameClassName=\"DialogReferenceClassName.listItemName\"\n\t\t\t\t\t\t\t@clickByUserName=\"onClickOnUserName\"\n\t\t\t\t\t\t\t@clickByUploadCancel=\"onClickOnUploadCancel\"\n\t\t\t\t\t\t\t@clickByKeyboardButton=\"onClickOnKeyboardButton\"\n\t\t\t\t\t\t\t@clickByChatTeaser=\"onClickOnChatTeaser\"\n\t\t\t\t\t\t\t@clickByMessageMenu=\"onClickOnMessageMenu\"\n\t\t\t\t\t\t\t@clickByMessageRetry=\"onClickOnMessageRetry\"\n\t\t\t\t\t\t\t@setMessageReaction=\"onMessageReactionSet\"\n\t\t\t\t\t\t\t@openMessageReactionList=\"onMessageReactionListOpen\"\n\t\t\t\t\t\t\t@dragMessage=\"onDragMessage\"\n\t\t\t\t\t\t\t@quoteMessage=\"onQuoteMessage\"\n\t\t\t\t\t\t/>\n\t\t\t\t\t</div>\n\t\t\t\t</template>\n\t\t\t\t<!-- Date groups -->\n\t\t\t\t<template v-else-if=\"element.templateType === TemplateType.group\">\n\t\t\t\t\t<div class=\"bx-im-dialog-group\" :data-template-id=\"element.templateId\" :data-type=\"element.templateType\" :key=\"element.templateId\">\n\t\t\t\t\t\t<div class=\"bx-im-dialog-group-date\">{{ element.text }}</div>\n\t\t\t\t\t</div>\n\t\t\t\t</template>\n\t\t\t\t<!-- Delimiters -->\n\t\t\t\t<template v-else-if=\"element.templateType === TemplateType.delimiter\">\n\t\t\t\t\t<div class=\"bx-im-dialog-delimiter\" :data-template-id=\"element.templateId\" :data-type=\"element.templateType\" :key=\"element.templateId\"></div>\n\t\t\t\t</template>\n\t\t\t\t<!-- Placeholders -->\n\t\t\t\t<template v-else-if=\"element.templateType === TemplateType.placeholder\">\n\t\t\t\t\t<component :is=\"'Placeholder'+element.placeholderType\" :element=\"element\"/>\n\t\t\t\t</template>\n\t\t\t</template>\n\t\t\t<!-- Writing and readed statuses -->\n\t\t\t<transition name=\"bx-im-dialog-status\">\n\t\t\t\t<template v-if=\"writingStatusText\">\n\t\t\t\t\t<div class=\"bx-im-dialog-status\">\n\t\t\t\t\t\t<span class=\"bx-im-dialog-status-writing\"></span>\n\t\t\t\t\t\t{{ writingStatusText }}\n\t\t\t\t\t</div>\n\t\t\t\t</template>\n\t\t\t\t<template v-else-if=\"statusReaded\">\n\t\t\t\t\t<div class=\"bx-im-dialog-status\" @click=\"onClickOnReadList\">\n\t\t\t\t\t\t{{ statusReaded }}\n\t\t\t\t\t</div>\n\t\t\t\t</template>\n\t\t\t</transition>\n\t\t\t<div v-if=\"showStatusPlaceholder\" class=\"bx-im-dialog-status-placeholder\"></div>\n\t\t</div>\n\t\t<!-- Scroll button -->\n\t\t<transition name=\"bx-im-dialog-scroll-button\">\n\t\t\t<div v-show=\"showScrollButton || (unreadCounter > 0 && !isLastIdInCollection)\" class=\"bx-im-dialog-scroll-button-box\" @click=\"onScrollButtonClick\">\n\t\t\t\t<div class=\"bx-im-dialog-scroll-button\">\n\t\t\t\t\t<div v-show=\"unreadCounter\" class=\"bx-im-dialog-scroll-button-counter\">\n\t\t\t\t\t\t<div class=\"bx-im-dialog-scroll-button-counter-digit\">{{ formattedUnreadCounter }}</div>\n\t\t\t\t\t</div>\n\t\t\t\t\t<div class=\"bx-im-dialog-scroll-button-arrow\"></div>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t</transition>\n\t</div>\n"
	};

	function ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$1(Object(source), !0).forEach(function (key) { babelHelpers.defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
	var ErrorState = {
	  computed: _objectSpread$1({}, ui_vue_vuex.WidgetVuex.mapState({
	    application: function application(state) {
	      return state.application;
	    }
	  })),
	  // language=Vue
	  template: "\n\t\t<div class=\"bx-mobilechat-body\">\n\t\t\t<div class=\"bx-mobilechat-warning-window\">\n\t\t\t\t<div class=\"bx-mobilechat-warning-icon\"></div>\n\t\t\t\t<template v-if=\"application.error.description\">\n\t\t\t\t\t<div class=\"bx-mobilechat-help-title bx-mobilechat-help-title-sm bx-mobilechat-warning-msg\" v-html=\"application.error.description\"></div>\n\t\t\t\t</template>\n\t\t\t\t<template v-else>\n\t\t\t\t\t<div class=\"bx-mobilechat-help-title bx-mobilechat-help-title-md bx-mobilechat-warning-msg\">{{$Bitrix.Loc.getMessage('IM_DIALOG_ERROR_TITLE')}}</div>\n\t\t\t\t\t<div class=\"bx-mobilechat-help-title bx-mobilechat-help-title-sm bx-mobilechat-warning-msg\">{{$Bitrix.Loc.getMessage('IM_DIALOG_ERROR_DESC')}}</div>\n\t\t\t\t</template>\n\t\t\t</div>\n\t\t</div>\n\t"
	};

	var LoadingState = {
	  data: function data() {
	    return {
	      placeholdersComposition: [],
	      placeholderTypes: [0, 1],
	      placeholderModes: ['self', 'opponent'],
	      placeholdersCount: 20
	    };
	  },
	  created: function created() {
	    for (var i = 0; i < this.placeholdersCount; i++) {
	      var randomType = Math.floor(Math.random() * this.placeholderTypes.length);
	      var randomMode = Math.floor(Math.random() * this.placeholderModes.length);
	      this.placeholdersComposition.push({
	        index: i,
	        type: randomType,
	        mode: this.placeholderModes[randomMode],
	        classes: this.getItemClasses(randomType, randomMode)
	      });
	    }
	  },
	  methods: {
	    getItemClasses: function getItemClasses(type, modeIndex) {
	      var itemClasses = ['im-skeleton-item'];

	      if (this.placeholderModes[modeIndex] === 'self') {
	        itemClasses.push('im-skeleton-item-self');
	      } else {
	        itemClasses.push('im-skeleton-item-opponent');
	      }

	      if (type === 0) {
	        itemClasses.push('im-skeleton-item--sm');
	      } else {
	        itemClasses.push('im-skeleton-item--md');
	      }

	      return itemClasses;
	    }
	  },
	  // language=Vue
	  template: "\n\t\t<div class=\"bx-mobilechat-placeholder-wrap\">\n\t\t\t<div class=\"bx-mobilechat-placeholder-wrap-visible\">\n\t\t\t\t<template v-for=\"item in placeholdersComposition\">\n\t\t\t\t\t<div :class=\"item.classes\" :key=\"item.index\">\n\t\t\t\t\t\t<div v-if=\"item.mode === 'opponent'\" class=\"im-skeleton-logo\"></div>\n\t\t\t\t\t\t<div class=\"im-skeleton-content\">\n\t\t\t\t\t\t\t<template v-if=\"item.type === 0\">\n\t\t\t\t\t\t\t\t<div class=\"im-skeleton-line-row\">\n\t\t\t\t\t\t\t\t\t<div style=\"max-width: 70%\" class=\"im-skeleton-line\"></div>\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t<div class=\"im-skeleton-line-row\">\n\t\t\t\t\t\t\t\t\t<div style=\"max-width: 100%\" class=\"im-skeleton-line\"></div>\n\t\t\t\t\t\t\t\t\t<div style=\"max-width: 26px; margin-left: auto;\" class=\"im-skeleton-line\"></div>\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t</template>\n\t\t\t\t\t\t\t<template v-else>\n\t\t\t\t\t\t\t\t<div class=\"im-skeleton-line-row\">\n\t\t\t\t\t\t\t\t\t<div style=\"max-width: 35%\" class=\"im-skeleton-line\"></div>\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t<div class=\"im-skeleton-line-row\">\n\t\t\t\t\t\t\t\t\t<div style=\"max-width: 100%\" class=\"im-skeleton-line\"></div>\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t<div class=\"im-skeleton-line-row\">\n\t\t\t\t\t\t\t\t\t<div style=\"max-width: 55%\" class=\"im-skeleton-line\"></div>\n\t\t\t\t\t\t\t\t\t<div style=\"max-width: 26px; margin-left: auto;\" class=\"im-skeleton-line\"></div>\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t</template>\n\t\t\t\t\t\t\t<div class=\"im-skeleton-like\"></div>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>\n\t\t\t\t</template>\n\t\t\t</div>\n\t\t</div>\n\t"
	};

	var EmptyState = {
	  // language=Vue
	  template: "\n\t\t<div class=\"bx-mobilechat-loading-window\">\n\t\t\t<h3 class=\"bx-mobilechat-help-title bx-mobilechat-help-title-md bx-mobilechat-loading-msg\">\n\t\t  \t\t{{ $Bitrix.Loc.getMessage('IM_DIALOG_EMPTY') }}\n\t\t\t</h3>\n\t\t</div>\n\t"
	};

	var QuotePanel = {
	  /**
	   * @emits EventType.dialog.quotePanelClose
	   */
	  props: {
	    quotePanelData: {
	      type: Object,
	      "default": function _default() {
	        return {
	          id: 0,
	          title: '',
	          description: '',
	          color: ''
	        };
	      }
	    },
	    canClose: {
	      "default": true
	    }
	  },
	  methods: {
	    close: function close(event) {
	      main_core_events.EventEmitter.emit(im_const.EventType.dialog.quotePanelClose, event);
	    }
	  },
	  computed: {
	    formattedTittle: function formattedTittle() {
	      return this.quotePanelData.title ? this.quotePanelData.title.substr(0, 255) : this.$Bitrix.Loc.getMessage('IM_QUOTE_PANEL_DEFAULT_TITLE');
	    },
	    formattedDescription: function formattedDescription() {
	      return this.quotePanelData.description ? this.quotePanelData.description.substr(0, 255) : '';
	    }
	  },
	  template: "\n\t<transition enter-active-class=\"bx-im-quote-panel-animation-show\" leave-active-class=\"bx-im-quote-panel-animation-close\">\t\t\t\t\n\t\t<div v-if=\"quotePanelData.id > 0\" class=\"bx-im-quote-panel\">\n\t\t\t<div class=\"bx-im-quote-panel-wrap\">\n\t\t\t\t<div class=\"bx-im-quote-panel-box\" :style=\"{borderLeftColor: quotePanelData.color}\">\n\t\t\t\t\t<div class=\"bx-im-quote-panel-box-title\" :style=\"{color: quotePanelData.color}\">{{formattedTittle}}</div>\n\t\t\t\t\t<div class=\"bx-im-quote-panel-box-desc\">{{formattedDescription}}</div>\n\t\t\t\t</div>\n\t\t\t\t<div v-if=\"canClose\" class=\"bx-im-quote-panel-close\" @click=\"close\"></div>\n\t\t\t</div>\n\t\t</div>\n\t</transition>\n"
	};

	/**
	 * Bitrix im
	 * Dialog vue component
	 *
	 * @package bitrix
	 * @subpackage im
	 * @copyright 2001-2021 Bitrix
	 */
	ui_vue.WidgetBitrixVue.component('bx-im-component-dialog', {
	  mixins: [im_mixin.DialogCore, im_mixin.DialogQuoteMessage],
	  components: {
	    MessageList: MessageList,
	    ErrorState: ErrorState,
	    LoadingState: LoadingState,
	    EmptyState: EmptyState,
	    QuotePanel: QuotePanel
	  },
	  props: {
	    userId: {
	      "default": 0
	    },
	    dialogId: {
	      "default": 0
	    },
	    skipDataRequest: {
	      "default": false
	    },
	    showLoadingState: {
	      "default": true
	    },
	    showEmptyState: {
	      "default": true
	    },
	    enableGestureQuote: {
	      "default": true
	    },
	    enableGestureQuoteFromRight: {
	      "default": true
	    },
	    enableGestureMenu: {
	      "default": false
	    },
	    showMessageUserName: {
	      "default": true
	    },
	    showMessageAvatar: {
	      "default": true
	    }
	  },
	  data: function data() {
	    return {
	      messagesSet: false
	    };
	  },
	  created: function created() {
	    main_core_events.EventEmitter.subscribe(im_const.EventType.dialog.messagesSet, this.onMessagesSet);
	    this.onDialogOpen();
	  },
	  beforeDestroy: function beforeDestroy() {
	    main_core_events.EventEmitter.unsubscribe(im_const.EventType.dialog.messagesSet, this.onMessagesSet);
	  },
	  watch: {
	    dialogId: function dialogId(newValue, oldValue) {
	      im_lib_logger.Logger.warn('Switching dialogId from ', oldValue, ' to ', newValue);
	      this.messagesSet = false;
	      this.onDialogOpen();
	    }
	  },
	  computed: {
	    EventType: function EventType() {
	      return im_const.EventType;
	    },
	    DialogState: function DialogState() {
	      return im_const.DialogState;
	    },
	    dialogWrapClasses: function dialogWrapClasses() {
	      return ['bx-mobilechat-wrapper', {
	        'bx-mobilechat-chat-start': this.isDialogShowingMessages
	      }];
	    },
	    dialogBoxClasses: function dialogBoxClasses() {
	      return ['bx-mobilechat-box', {
	        'bx-mobilechat-box-dark-background': this.isDarkBackground
	      }];
	    },
	    dialogBodyClasses: function dialogBodyClasses() {
	      return ['bx-mobilechat-body', {
	        'bx-mobilechat-body-with-message': this.dialogState === im_const.DialogState.show
	      }];
	    },
	    quotePanelData: function quotePanelData() {
	      var result = {
	        id: 0,
	        title: '',
	        description: '',
	        color: ''
	      };

	      if (!this.isDialogShowingMessages || !this.dialog.quoteId) {
	        return result;
	      }

	      var message = this.$store.getters['messages/getMessage'](this.dialog.chatId, this.dialog.quoteId);

	      if (!message) {
	        return result;
	      }

	      var user = this.$store.getters['users/get'](message.authorId);
	      var files = this.$store.getters['files/getList'](this.dialog.chatId);
	      return {
	        id: this.dialog.quoteId,
	        title: message.params.NAME ? main_core.Text.decode(message.params.NAME) : user ? user.name : '',
	        color: user ? user.color : '',
	        description: im_lib_utils.Utils.text.purify(message.text, message.params, files, this.localize)
	      };
	    },
	    isLoading: function isLoading() {
	      if (!this.showLoadingState) {
	        return false;
	      } // show placeholders if we don't have chatId for current dialogId
	      // or we have chatId, but there is no messages collection for this chatId and messages are not set yet
	      // (because if chat is empty - there will be no messages collection, but we should not show loading state)


	      return !this.isChatIdInModel || this.isChatIdInModel && !this.isMessagesModelInited && !this.messagesSet;
	    },
	    isEmpty: function isEmpty() {
	      return this.showEmptyState && this.messagesSet && this.messageCollection.length === 0;
	    },
	    isChatIdInModel: function isChatIdInModel() {
	      var dialogues = this.$store.state.dialogues.collection;
	      return dialogues[this.dialogId] && dialogues[this.dialogId].chatId > 0;
	    },
	    isMessagesModelInited: function isMessagesModelInited() {
	      var messages = this.$store.state.messages.collection;
	      return messages[this.chatId];
	    }
	  },
	  methods: {
	    prepareRequestDataQuery: function prepareRequestDataQuery() {
	      var _query;

	      var query = (_query = {}, babelHelpers.defineProperty(_query, im_const.RestMethodHandler.mobileBrowserConstGet, [im_const.RestMethod.mobileBrowserConstGet, {}]), babelHelpers.defineProperty(_query, im_const.RestMethodHandler.imChatGet, [im_const.RestMethod.imChatGet, {
	        dialog_id: this.dialogId
	      }]), babelHelpers.defineProperty(_query, im_const.RestMethodHandler.imDialogMessagesGetInit, [im_const.RestMethod.imDialogMessagesGet, {
	        dialog_id: this.dialogId,
	        limit: this.getApplicationController().getRequestMessageLimit(),
	        convert_text: 'Y'
	      }]), _query);

	      if (im_lib_utils.Utils.dialog.isChatId(this.dialogId)) {
	        query[im_const.RestMethodHandler.imUserGet] = [im_const.RestMethod.imUserGet, {}];
	      } else {
	        query[im_const.RestMethodHandler.imUserListGet] = [im_const.RestMethod.imUserListGet, {
	          id: [this.userId, this.dialogId]
	        }];
	      }

	      return query;
	    },
	    requestData: function requestData() {
	      var _this = this;

	      im_lib_logger.Logger.log('requesting dialog data');
	      var query = this.prepareRequestDataQuery();
	      this.getRestClient().callBatch(query, function (response) {
	        if (!response) {
	          return false;
	        } //const.get


	        var constGetResult = response[im_const.RestMethodHandler.mobileBrowserConstGet];

	        if (!constGetResult.error()) {
	          _this.executeRestAnswer(im_const.RestMethodHandler.mobileBrowserConstGet, constGetResult);
	        } //user.get


	        var userGetResult = response[im_const.RestMethodHandler.imUserGet];

	        if (userGetResult && !userGetResult.error()) {
	          _this.executeRestAnswer(im_const.RestMethodHandler.imUserGet, userGetResult);
	        } //user.list.get


	        var userListGetResult = response[im_const.RestMethodHandler.imUserListGet];

	        if (userListGetResult && !userListGetResult.error()) {
	          _this.executeRestAnswer(im_const.RestMethodHandler.imUserListGet, userListGetResult);
	        } //chat.get


	        var chatGetResult = response[im_const.RestMethodHandler.imChatGet];

	        if (!chatGetResult.error()) {
	          _this.executeRestAnswer(im_const.RestMethodHandler.imChatGet, chatGetResult);
	        } //dialog.messages.get


	        var dialogMessagesGetResult = response[im_const.RestMethodHandler.imDialogMessagesGetInit];

	        if (!dialogMessagesGetResult.error()) {
	          _this.$store.dispatch('application/set', {
	            dialog: {
	              enableReadMessages: true
	            }
	          }).then(function () {
	            _this.executeRestAnswer(im_const.RestMethodHandler.imDialogMessagesGetInit, dialogMessagesGetResult); // this.messagesSet = true;

	          });
	        }
	      }, false, false, im_lib_utils.Utils.getLogTrackingParams({
	        name: 'im.dialog',
	        dialog: this.getApplicationController().getDialogData()
	      }));
	      return new Promise(function (resolve, reject) {
	        return resolve();
	      });
	    },
	    onDialogOpen: function onDialogOpen() {
	      if (this.isChatIdInModel) {
	        var dialogues = this.$store.state.dialogues.collection;
	        this.$store.commit('application/set', {
	          dialog: {
	            chatId: dialogues[this.dialogId].chatId,
	            dialogId: this.dialogId
	          }
	        });
	      }

	      if (!this.skipDataRequest) {
	        this.requestData();
	      }
	    },
	    onMessagesSet: function onMessagesSet(_ref) {
	      var event = _ref.data;

	      if (event.chatId !== this.chatId) {
	        return false;
	      }

	      if (this.messagesSet === true) {
	        return false;
	      }

	      this.messagesSet = true;
	    }
	  },
	  // language=Vue
	  template: "\n\t\t<div :class=\"dialogWrapClasses\">\n\t\t\t<div :class=\"dialogBoxClasses\" ref=\"chatBox\">\n\t\t\t\t<!-- Error state -->\n\t\t\t\t<ErrorState v-if=\"application.error.active\" />\n\t\t\t\t<template v-else>\n\t\t\t\t\t<div :class=\"dialogBodyClasses\" key=\"with-message\">\n\t\t\t\t\t\t<!-- Loading state -->\n\t\t\t\t\t  \t<LoadingState v-if=\"isLoading\" />\n\t\t\t\t\t\t<!-- Empty state -->\n\t\t\t\t\t  \t<EmptyState v-else-if=\"isEmpty\" />\n\t\t\t\t\t\t<!-- Message list state -->\n\t\t\t\t\t\t<template v-else>\n\t\t\t\t\t\t\t<div class=\"bx-mobilechat-dialog\">\n\t\t\t\t\t\t\t\t<MessageList\n\t\t\t\t\t\t\t\t\t:userId=\"userId\" \n\t\t\t\t\t\t\t\t\t:dialogId=\"dialogId\"\n\t\t\t\t\t\t\t\t\t:messageLimit=\"application.dialog.messageLimit\"\n\t\t\t\t\t\t\t\t\t:enableReadMessages=\"application.dialog.enableReadMessages\"\n\t\t\t\t\t\t\t\t\t:enableReactions=\"true\"\n\t\t\t\t\t\t\t\t\t:enableDateActions=\"false\"\n\t\t\t\t\t\t\t\t\t:enableCreateContent=\"false\"\n\t\t\t\t\t\t\t\t\t:enableGestureQuote=\"enableGestureQuote\"\n\t\t\t\t\t\t\t\t\t:enableGestureQuoteFromRight=\"enableGestureQuoteFromRight\"\n\t\t\t\t\t\t\t\t\t:enableGestureMenu=\"enableGestureMenu\"\n\t\t\t\t\t\t\t\t\t:showMessageUserName=\"showMessageUserName\"\n\t\t\t\t\t\t\t\t\t:showMessageAvatar=\"showMessageAvatar\"\n\t\t\t\t\t\t\t\t\t:showMessageMenu=\"false\"\n\t\t\t\t\t\t\t\t />\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t<!-- Quote panel -->\n\t\t\t\t\t\t\t<QuotePanel :quotePanelData=\"quotePanelData\" />\n\t\t\t\t\t\t</template>\n\t\t\t\t\t</div>\n\t\t\t\t</template>\n\t\t\t</div>\n\t\t</div>\n\t"
	});

}((this.BX.Messenger = this.BX.Messenger || {}),window,BX.Messenger.Mixin,BX.Messenger.Lib,BX.Messenger.Lib,BX.Messenger.Lib,BX,BX,BX,BX.Messenger.Const,BX,BX.Event));
 




// file: /bitrix/js/im/lib/localstorage/dist/localstorage.bundle.js
this.BX = this.BX || {};
this.BX.Messenger = this.BX.Messenger || {};
(function (exports) {
	'use strict';

	/**
	 * Bitrix Messenger
	 * LocalStorage manager
	 *
	 * @package bitrix
	 * @subpackage im
	 * @copyright 2001-2019 Bitrix
	 */
	var LocalStorage = /*#__PURE__*/function () {
	  function LocalStorage() {
	    babelHelpers.classCallCheck(this, LocalStorage);
	    this.enabled = null;
	    this.expireList = null;
	    this.expireInterval = null;
	  }

	  babelHelpers.createClass(LocalStorage, [{
	    key: "isEnabled",
	    value: function isEnabled() {
	      if (this.enabled !== null) {
	        return this.enabled;
	      }

	      this.enabled = false;

	      if (typeof window.localStorage !== 'undefined') {
	        try {
	          window.localStorage.setItem('__bx_test_ls_feature__', 'ok');

	          if (window.localStorage.getItem('__bx_test_ls_feature__') === 'ok') {
	            window.localStorage.removeItem('__bx_test_ls_feature__');
	            this.enabled = true;
	          }
	        } catch (e) {}
	      }

	      if (this.enabled && !this.expireInterval) {
	        try {
	          var expireList = window.localStorage.getItem('bx-messenger-localstorage-expire');

	          if (expireList) {
	            this.expireList = JSON.parse(expireList);
	          }
	        } catch (e) {}

	        clearInterval(this.expireInterval);
	        this.expireInterval = setInterval(this._checkExpireInterval.bind(this), 60000);
	      }

	      return this.enabled;
	    }
	  }, {
	    key: "set",
	    value: function set(siteId, userId, name, value) {
	      var ttl = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;

	      if (!this.isEnabled()) {
	        return false;
	      }

	      var expire = null;

	      if (ttl) {
	        expire = new Date(new Date().getTime() + ttl * 1000);
	      }

	      var storeValue = JSON.stringify({
	        value: value,
	        expire: expire
	      });

	      if (window.localStorage.getItem(this._getKey(siteId, userId, name)) !== storeValue) {
	        window.localStorage.setItem(this._getKey(siteId, userId, name), storeValue);
	      }

	      if (ttl) {
	        if (!this.expireList) {
	          this.expireList = {};
	        }

	        this.expireList[this._getKey(siteId, userId, name)] = expire;
	        window.localStorage.setItem('bx-messenger-localstorage-expire', JSON.stringify(this.expireList));
	      }

	      return true;
	    }
	  }, {
	    key: "get",
	    value: function get(siteId, userId, name, defaultValue) {
	      if (!this.isEnabled()) {
	        return typeof defaultValue !== 'undefined' ? defaultValue : null;
	      }

	      var result = window.localStorage.getItem(this._getKey(siteId, userId, name));

	      if (result === null) {
	        return typeof defaultValue !== 'undefined' ? defaultValue : null;
	      }

	      try {
	        result = JSON.parse(result);

	        if (result && typeof result.value !== 'undefined') {
	          if (!result.expire || new Date(result.expire) > new Date()) {
	            result = result.value;
	          } else {
	            window.localStorage.removeItem(this._getKey(siteId, userId, name));

	            if (this.expireList) {
	              delete this.expireList[this._getKey(siteId, userId, name)];
	            }

	            return typeof defaultValue !== 'undefined' ? defaultValue : null;
	          }
	        } else {
	          return typeof defaultValue !== 'undefined' ? defaultValue : null;
	        }
	      } catch (e) {
	        return typeof defaultValue !== 'undefined' ? defaultValue : null;
	      }

	      return result;
	    }
	  }, {
	    key: "remove",
	    value: function remove(siteId, userId, name) {
	      if (!this.isEnabled()) {
	        return false;
	      }

	      if (this.expireList) {
	        delete this.expireList[this._getKey(siteId, userId, name)];
	      }

	      return window.localStorage.removeItem(this._getKey(siteId, userId, name));
	    }
	  }, {
	    key: "_getKey",
	    value: function _getKey(siteId, userId, name) {
	      return 'bx-messenger-' + siteId + '-' + userId + '-' + name;
	    }
	  }, {
	    key: "_checkExpireInterval",
	    value: function _checkExpireInterval() {
	      if (!this.expireList) return true;
	      var currentTime = new Date();
	      var count = 0;

	      for (var name in this.expireList) {
	        if (!this.expireList.hasOwnProperty(name)) {
	          continue;
	        }

	        if (new Date(this.expireList[name]) <= currentTime) {
	          window.localStorage.removeItem(name);
	          delete this.expireList[name];
	        } else {
	          count++;
	        }
	      }

	      if (count) {
	        window.localStorage.setItem('bx-messenger-localstorage-expire', JSON.stringify(this.expireList));
	      } else {
	        this.expireList = null;
	        window.localStorage.removeItem('bx-messenger-localstorage-expire');
	      }

	      return true;
	    }
	  }]);
	  return LocalStorage;
	}();

	var localStorage = new LocalStorage();

	exports.LocalStorage = localStorage;

}((this.BX.Messenger.Lib = this.BX.Messenger.Lib || {})));
 




// file: /bitrix/js/im/component/textarea/dist/textarea.bundle.js
(function (exports,ui_vue,im_lib_localstorage,im_lib_utils,main_core,ui_vue_vuex,main_core_events,im_const) {
	'use strict';

	function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { babelHelpers.defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
	ui_vue.WidgetBitrixVue.component('bx-im-component-textarea', {
	  /**
	   * @emits 'send' {text: string}
	   * @emits 'edit' {}
	   * @emits 'writes' {text: string}
	   * @emits 'focus' {event: object} -- 'event' - focus event
	   * @emits 'blur' {event: object} -- 'event' - blur event
	   * @emits 'keyup' {event: object} -- 'event' - keyup event
	   * @emits 'keydown' {event: object} -- 'event' - keydown event
	   * @emits 'appButtonClick' {appId: string, event: object} -- 'appId' - application name, 'event' - event click
	   * @emits 'fileSelected' {fileInput: domNode} -- 'fileInput' - dom node element
	   */
	  props: {
	    siteId: {
	      "default": 'default'
	    },
	    userId: {
	      "default": 0
	    },
	    dialogId: {
	      "default": 0
	    },
	    enableCommand: {
	      "default": true
	    },
	    enableMention: {
	      "default": true
	    },
	    desktopMode: {
	      "default": false
	    },
	    enableEdit: {
	      "default": false
	    },
	    enableFile: {
	      "default": false
	    },
	    sendByEnter: {
	      "default": true
	    },
	    autoFocus: {
	      "default": null
	    },
	    writesEventLetter: {
	      "default": 0
	    },
	    styles: {
	      type: Object,
	      "default": function _default() {
	        return {};
	      }
	    }
	  },
	  data: function data() {
	    return {
	      placeholderMessage: '',
	      currentMessage: '',
	      previousMessage: '',
	      commandListen: false,
	      mentionListen: false,
	      stylesDefault: Object.freeze({
	        button: {
	          backgroundColor: null,
	          iconColor: null
	        }
	      })
	    };
	  },
	  created: function created() {
	    main_core_events.EventEmitter.subscribe(im_const.EventType.textarea.insertText, this.onInsertText);
	    main_core_events.EventEmitter.subscribe(im_const.EventType.textarea.setFocus, this.onFocusSet);
	    main_core_events.EventEmitter.subscribe(im_const.EventType.textarea.setBlur, this.onFocusClear);
	    this.localStorage = im_lib_localstorage.LocalStorage;
	    this.textareaHistory = this.localStorage.get(this.siteId, this.userId, 'textarea-history', {});
	    this.currentMessage = this.textareaHistory[this.dialogId] || '';
	    this.placeholderMessage = this.currentMessage;
	  },
	  beforeDestroy: function beforeDestroy() {
	    main_core_events.EventEmitter.unsubscribe(im_const.EventType.textarea.insertText, this.onInsertText);
	    main_core_events.EventEmitter.unsubscribe(im_const.EventType.textarea.setFocus, this.onFocusSet);
	    main_core_events.EventEmitter.unsubscribe(im_const.EventType.textarea.setBlur, this.onFocusClear);
	    clearTimeout(this.messageStoreTimeout);
	    this.localStorage.set(this.siteId, this.userId, 'textarea-history', this.textareaHistory);
	    this.localStorage = null;
	  },
	  computed: _objectSpread({
	    textareaClassName: function textareaClassName() {
	      return ['bx-im-textarea', {
	        'bx-im-textarea-dark-background': this.isDarkBackground,
	        'bx-im-textarea-mobile': this.isMobile
	      }];
	    },
	    buttonStyle: function buttonStyle() {
	      var styles = Object.assign({}, this.stylesDefault, this.styles);
	      var isIconDark = false;

	      if (styles.button.iconColor) {
	        isIconDark = im_lib_utils.Utils.isDarkColor(styles.button.iconColor);
	      } else {
	        isIconDark = !im_lib_utils.Utils.isDarkColor(styles.button.backgroundColor);
	      }

	      styles.button.className = isIconDark ? 'bx-im-textarea-send-button' : 'bx-im-textarea-send-button bx-im-textarea-send-button-bright-arrow';
	      styles.button.style = styles.button.backgroundColor ? 'background-color: ' + styles.button.backgroundColor + ';' : '';
	      return styles;
	    },
	    isDarkBackground: function isDarkBackground() {
	      return this.application.options.darkBackground;
	    },
	    isMobile: function isMobile() {
	      return this.application.device.type === im_const.DeviceType.mobile;
	    },
	    localize: function localize() {
	      return ui_vue.WidgetBitrixVue.getFilteredPhrases('BX_MESSENGER_TEXTAREA_', this);
	    },
	    isIE11: function isIE11() {
	      return main_core.Browser.isIE11();
	    }
	  }, ui_vue_vuex.WidgetVuex.mapState({
	    application: function application(state) {
	      return state.application;
	    }
	  })),
	  directives: {
	    'bx-im-focus': {
	      inserted: function inserted(element, params) {
	        if (params.value === true || params.value === null && !this.isMobile) {
	          element.focus();
	        }
	      }
	    }
	  },
	  methods: {
	    /**
	     *
	     * @param text
	     * @param breakline - true/false (default)
	     * @param position - start, current (default), end
	     * @param cursor - start, before, after (default), end
	     * @param focus - set focus on textarea
	     */
	    insertText: function insertText(text) {
	      var breakline = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
	      var position = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'current';
	      var cursor = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'after';
	      var focus = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;
	      var textarea = this.$refs.textarea;
	      var selectionStart = textarea.selectionStart;
	      var selectionEnd = textarea.selectionEnd;

	      if (position == 'start') {
	        if (breakline) {
	          text = text + "\n";
	        }

	        textarea.value = text + textarea.value;

	        if (focus) {
	          if (cursor == 'after') {
	            textarea.selectionStart = text.length;
	            textarea.selectionEnd = textarea.selectionStart;
	          } else if (cursor == 'before') {
	            textarea.selectionStart = 0;
	            textarea.selectionEnd = textarea.selectionStart;
	          }
	        }
	      } else if (position == 'current') {
	        if (breakline) {
	          if (textarea.value.substring(0, selectionStart).trim().length > 0) {
	            text = "\n" + text;
	          }

	          text = text + "\n";
	        } else {
	          if (textarea.value && !textarea.value.endsWith(' ')) {
	            text = ' ' + text;
	          }
	        }

	        textarea.value = textarea.value.substring(0, selectionStart) + text + textarea.value.substring(selectionEnd, textarea.value.length);

	        if (focus) {
	          if (cursor == 'after') {
	            textarea.selectionStart = selectionStart + text.length;
	            textarea.selectionEnd = textarea.selectionStart;
	          } else if (cursor == 'before') {
	            textarea.selectionStart = selectionStart;
	            textarea.selectionEnd = textarea.selectionStart;
	          }
	        }
	      } else if (position == 'end') {
	        if (breakline) {
	          if (textarea.value.substring(0, selectionStart).trim().length > 0) {
	            text = "\n" + text;
	          }

	          text = text + "\n";
	        } else {
	          if (textarea.value && !textarea.value.endsWith(' ')) {
	            text = ' ' + text;
	          }
	        }

	        textarea.value = textarea.value + text;

	        if (focus) {
	          if (cursor == 'after') {
	            textarea.selectionStart = textarea.value.length;
	            textarea.selectionEnd = textarea.selectionStart;
	          } else if (cursor == 'before') {
	            textarea.selectionStart = textarea.value.length - text.length;
	            textarea.selectionEnd = textarea.selectionStart;
	          }
	        }
	      }

	      if (focus) {
	        if (cursor == 'start') {
	          textarea.selectionStart = 0;
	          textarea.selectionEnd = 0;
	        } else if (cursor == 'end') {
	          textarea.selectionStart = textarea.value.length;
	          textarea.selectionEnd = textarea.selectionStart;
	        }

	        textarea.focus();
	      }

	      this.textChangeEvent();
	    },
	    sendMessage: function sendMessage(event) {
	      event.preventDefault();
	      main_core_events.EventEmitter.emit(im_const.EventType.textarea.sendMessage, {
	        text: this.currentMessage.trim()
	      });
	      var textarea = this.$refs.textarea;

	      if (textarea) {
	        textarea.value = '';
	      }

	      if (this.autoFocus === null || this.autoFocus) {
	        textarea.focus();
	      }

	      this.textChangeEvent();
	    },
	    textChangeEvent: function textChangeEvent() {
	      var _this = this;

	      var textarea = this.$refs.textarea;

	      if (!textarea) {
	        return;
	      }

	      var text = textarea.value.trim();

	      if (this.currentMessage === text) {
	        return;
	      }

	      if (this.writesEventLetter <= text.length) {
	        main_core_events.EventEmitter.emit(im_const.EventType.textarea.startWriting, {
	          text: text
	        });
	      }

	      this.previousMessage = this.currentMessage;
	      this.previousSelectionStart = textarea.selectionStart;
	      this.previousSelectionEnd = this.previousSelectionStart;
	      this.currentMessage = text;

	      if (text.toString().length > 0) {
	        this.textareaHistory[this.dialogId] = text;
	      } else {
	        delete this.textareaHistory[this.dialogId];
	      }

	      clearTimeout(this.messageStoreTimeout);
	      this.messageStoreTimeout = setTimeout(function () {
	        _this.localStorage.set(_this.siteId, _this.userId, 'textarea-history', _this.textareaHistory, _this.userId ? 0 : 10);
	      }, 500);
	    },
	    onKeyDown: function onKeyDown(event) {
	      this.$emit('keydown', event);
	      var textarea = event.target;
	      var text = textarea.value.trim();
	      var isMac = im_lib_utils.Utils.platform.isMac();
	      var isCtrlTEnable = im_lib_utils.Utils.platform.isBitrixDesktop() || !im_lib_utils.Utils.browser.isChrome(); // TODO see more im/install/js/im/im.js:12324

	      if (this.commandListen) ; else if (this.mentionListen) ; else if (!(event.altKey && event.ctrlKey)) {
	        if (this.enableMention && event.shiftKey && (event.keyCode == 61 || event.keyCode == 50 || event.keyCode == 187 || event.keyCode == 187) || event.keyCode == 107) ; else if (this.enableCommand && (event.keyCode == 191 || event.keyCode == 111 || event.keyCode == 220)) ;
	      }

	      if (event.keyCode == 27) {
	        if (textarea.value != '' && textarea === document.activeElement) {
	          event.preventDefault();
	          event.stopPropagation();
	        }

	        if (event.shiftKey) {
	          textarea.value = '';
	        }
	      } else if (event.metaKey || event.ctrlKey) {
	        // TODO translit messages
	        if (isCtrlTEnable && event.key === 't' || !isCtrlTEnable && event.key === 'e') {
	          // translit case
	          event.preventDefault();
	        } else if (['b', 's', 'i', 'u'].includes(event.key)) {
	          var selectionStart = textarea.selectionStart;
	          var selectionEnd = textarea.selectionEnd;
	          var tagStart = '[' + event.key.toLowerCase() + ']';
	          var tagEnd = '[/' + event.key.toLowerCase() + ']';
	          var selected = textarea.value.substring(selectionStart, selectionEnd);

	          if (selected.startsWith(tagStart) && selected.endsWith(tagEnd)) {
	            selected = selected.substring(tagStart.length, selected.indexOf(tagEnd));
	          } else {
	            selected = tagStart + selected + tagEnd;
	          }

	          textarea.value = textarea.value.substring(0, selectionStart) + selected + textarea.value.substring(selectionEnd, textarea.value.length);
	          textarea.selectionStart = selectionStart;
	          textarea.selectionEnd = selectionStart + selected.length;
	          event.preventDefault();
	        }
	      }

	      if (event.keyCode == 9) {
	        this.insertText("\t");
	        event.preventDefault();
	      } else if (this.enableEdit && event.keyCode == 38 && text.length <= 0) {
	        main_core_events.EventEmitter.emit(im_const.EventType.textarea.edit, {});
	      } else if (event.keyCode == 13) {
	        if (this.isMobile) ; else if (this.sendByEnter == true) {
	          if (event.ctrlKey || event.altKey || event.shiftKey) {
	            if (!event.shiftKey) {
	              this.insertText("\n");
	            }
	          } else if (text.length <= 0) {
	            event.preventDefault();
	          } else {
	            this.sendMessage(event);
	          }
	        } else {
	          if (event.ctrlKey == true) {
	            this.sendMessage(event);
	          } else if (isMac && (event.metaKey == true || event.altKey == true)) {
	            this.sendMessage(event);
	          }
	        }
	      } else if ((event.ctrlKey || event.metaKey) && event.key == 'z') {
	        if (this.previousMessage) {
	          textarea.value = this.previousMessage;
	          textarea.selectionStart = this.previousSelectionStart;
	          textarea.selectionEnd = this.previousSelectionEnd;
	          this.previousMessage = '';
	          event.preventDefault();
	        }
	      }
	    },
	    onKeyUp: function onKeyUp(event) {
	      main_core_events.EventEmitter.emit(im_const.EventType.textarea.keyUp, {
	        event: event,
	        text: this.currentMessage
	      });
	      this.textChangeEvent();
	    },
	    onPaste: function onPaste(event) {
	      this.$nextTick(this.textChangeEvent);
	    },
	    onInput: function onInput(event) {
	      this.textChangeEvent();
	    },
	    onFocus: function onFocus(event) {
	      main_core_events.EventEmitter.emit(im_const.EventType.textarea.focus, event);
	    },
	    onBlur: function onBlur(event) {
	      main_core_events.EventEmitter.emit(im_const.EventType.textarea.blur, event);
	    },
	    onAppButtonClick: function onAppButtonClick(appId, event) {
	      main_core_events.EventEmitter.emit(im_const.EventType.textarea.appButtonClick, {
	        appId: appId,
	        event: event
	      });
	    },
	    onInsertText: function onInsertText(_ref) {
	      var _ref$data = _ref.data,
	          event = _ref$data === void 0 ? {} : _ref$data;

	      if (!event.text) {
	        return false;
	      }

	      this.insertText(event.text, event.breakline, event.position, event.cursor, event.focus);
	      main_core_events.EventEmitter.emit(im_const.EventType.textarea.keyUp, {
	        event: event,
	        text: this.currentMessage
	      });
	      return true;
	    },
	    onFocusSet: function onFocusSet() {
	      this.$refs.textarea.focus();
	      return true;
	    },
	    onFocusClear: function onFocusClear() {
	      this.$refs.textarea.blur();
	      return true;
	    },
	    onFileClick: function onFileClick(event) {
	      event.target.value = "";
	    },
	    onFileSelect: function onFileSelect(event) {
	      main_core_events.EventEmitter.emit(im_const.EventType.textarea.fileSelected, {
	        fileChangeEvent: event,
	        fileInput: event.target
	      });
	    },
	    log: function log(text, skip, event) {
	      console.warn(text);

	      if (skip == 1) {
	        event.preventDefault();
	      }
	    },
	    preventDefault: function preventDefault(event) {
	      event.preventDefault();
	    }
	  },
	  // language=Vue
	  template: "\n\t\t<div :class=\"textareaClassName\">\n\t\t\t<div class=\"bx-im-textarea-box\">\n\t\t\t\t<textarea ref=\"textarea\" class=\"bx-im-textarea-input\" @keydown=\"onKeyDown\" @keyup=\"onKeyUp\" @paste=\"onPaste\" @input=\"onInput\" @focus=\"onFocus\" @blur=\"onBlur\" v-bx-im-focus=\"autoFocus\" :placeholder=\"localize.BX_MESSENGER_TEXTAREA_PLACEHOLDER\">{{placeholderMessage}}</textarea>\n\t\t\t\t<transition enter-active-class=\"bx-im-textarea-send-button-show\" leave-active-class=\"bx-im-textarea-send-button-hide\">\n\t\t\t\t\t<button \n\t\t\t\t\t\tv-if=\"currentMessage\" \n\t\t\t\t\t\t:class=\"buttonStyle.button.className\" \n\t\t\t\t\t\t:style=\"buttonStyle.button.style\" \n\t\t\t\t\t\t:title=\"localize.BX_MESSENGER_TEXTAREA_BUTTON_SEND\"\n\t\t\t\t\t\t@click=\"sendMessage\" \n\t\t\t\t\t\t@touchend=\"sendMessage\" \n\t\t\t\t\t\t@mousedown=\"preventDefault\" \n\t\t\t\t\t\t@touchstart=\"preventDefault\" \n\t\t\t\t\t/>\n\t\t\t\t</transition>\n\t\t\t</div>\n\t\t\t<div class=\"bx-im-textarea-app-box\">\n\t\t\t\t<label v-if=\"enableFile && !isIE11\" class=\"bx-im-textarea-app-button bx-im-textarea-app-file\" :title=\"localize.BX_MESSENGER_TEXTAREA_FILE\">\n\t\t\t\t\t<input type=\"file\" @click=\"onFileClick($event)\" @change=\"onFileSelect($event)\" multiple>\n\t\t\t\t</label>\n\t\t\t\t<button class=\"bx-im-textarea-app-button bx-im-textarea-app-smile\" :title=\"localize.BX_MESSENGER_TEXTAREA_SMILE\" @click=\"onAppButtonClick('smile', $event)\"></button>\n\t\t\t\t<button v-if=\"false\" class=\"bx-im-textarea-app-button bx-im-textarea-app-gif\" :title=\"localize.BX_MESSENGER_TEXTAREA_GIPHY\" @click=\"onAppButtonClick('giphy', $event)\"></button>\n\t\t\t</div>\n\t\t</div>\n\t"
	});

}((this.window = this.window || {}),BX,BX.Messenger.Lib,BX.Messenger.Lib,BX,BX,BX.Event,BX.Messenger.Const));
 




// file: /bitrix/js/imopenlines/component/message/dist/message.bundle.js
(function (exports,ui_vue,ui_vue_vuex,im_view_message,main_core_events) {
	'use strict';

	/**
	 * Bitrix OpenLines widget
	 * Widget constants
	 *
	 * @package bitrix
	 * @subpackage imopenlines
	 * @copyright 2001-2019 Bitrix
	 */
	function GetObjectValues(source) {
	  var destination = [];

	  for (var value in source) {
	    if (source.hasOwnProperty(value)) {
	      destination.push(source[value]);
	    }
	  }

	  return destination;
	}
	/* region 01. Constants */


	var VoteType = Object.freeze({
	  none: 'none',
	  like: 'like',
	  dislike: 'dislike'
	});
	var LanguageType = Object.freeze({
	  russian: 'ru',
	  ukraine: 'ua',
	  world: 'en'
	});
	var FormType = Object.freeze({
	  none: 'none',
	  like: 'like',
	  smile: 'smile',
	  consent: 'consent',
	  welcome: 'welcome',
	  offline: 'offline',
	  history: 'history'
	});
	var LocationType = Object.freeze({
	  topLeft: 1,
	  topMiddle: 2,
	  topBottom: 3,
	  bottomLeft: 6,
	  bottomMiddle: 5,
	  bottomRight: 4
	});
	var LocationStyle = Object.freeze({
	  1: 'top-left',
	  2: 'top-center',
	  3: 'top-right',
	  6: 'bottom-left',
	  5: 'bottom-center',
	  4: 'bottom-right'
	});
	var SubscriptionType = Object.freeze({
	  configLoaded: 'configLoaded',
	  widgetOpen: 'widgetOpen',
	  widgetClose: 'widgetClose',
	  sessionStart: 'sessionStart',
	  sessionOperatorChange: 'sessionOperatorChange',
	  sessionFinish: 'sessionFinish',
	  operatorMessage: 'operatorMessage',
	  userForm: 'userForm',
	  userMessage: 'userMessage',
	  userFile: 'userFile',
	  userVote: 'userVote',
	  every: 'every'
	});
	var SubscriptionTypeCheck = GetObjectValues(SubscriptionType);
	var RestMethod = Object.freeze({
	  widgetUserRegister: 'imopenlines.widget.user.register',
	  widgetConfigGet: 'imopenlines.widget.config.get',
	  widgetDialogGet: 'imopenlines.widget.dialog.get',
	  widgetUserGet: 'imopenlines.widget.user.get',
	  widgetUserConsentApply: 'imopenlines.widget.user.consent.apply',
	  widgetVoteSend: 'imopenlines.widget.vote.send',
	  widgetActionSend: 'imopenlines.widget.action.send',
	  pullServerTime: 'server.time',
	  pullConfigGet: 'pull.config.get'
	});
	var RestMethodCheck = GetObjectValues(RestMethod);
	var RestAuth = Object.freeze({
	  guest: 'guest'
	});
	var SessionStatus = Object.freeze({
	  "new": 0,
	  skip: 5,
	  answer: 10,
	  client: 20,
	  clientAfterOperator: 25,
	  operator: 40,
	  waitClient: 50,
	  close: 60,
	  spam: 65,
	  duplicate: 69,
	  silentlyClose: 75
	});
	var EventType = Object.freeze({
	  requestShowForm: 'IMOL.Widget:requestShowForm'
	});

	function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { babelHelpers.defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
	var FormType$1 = Object.freeze({
	  none: 'none',
	  like: 'like',
	  welcome: 'welcome',
	  offline: 'offline',
	  history: 'history'
	});
	var VoteType$1 = Object.freeze({
	  none: 'none',
	  like: 'like',
	  dislike: 'dislike'
	});
	ui_vue.WidgetBitrixVue.cloneComponent('bx-imopenlines-message', 'bx-im-view-message', {
	  methods: {
	    checkMessageParamsForForm: function checkMessageParamsForForm() {
	      if (!this.message.params || !this.message.params.IMOL_FORM) {
	        return true;
	      }

	      if (this.message.params.IMOL_FORM === FormType$1.like) {
	        if (parseInt(this.message.params.IMOL_VOTE) === this.widget.dialog.sessionId && this.widget.dialog.userVote === VoteType$1.none) {
	          main_core_events.EventEmitter.emit(EventType.requestShowForm, {
	            type: FormType$1.like,
	            delayed: true
	          });
	        }
	      }
	    }
	  },
	  created: function created() {
	    this.checkMessageParamsForForm();
	  },
	  computed: _objectSpread({
	    dialogNumber: function dialogNumber() {
	      if (!this.message.params) {
	        return false;
	      }

	      if (!this.message.params.IMOL_SID) {
	        return false;
	      }

	      return this.$Bitrix.Loc.getMessage('IMOL_MESSAGE_DIALOG_ID').replace('#ID#', this.message.params.IMOL_SID);
	    },
	    showMessage: function showMessage() {
	      if (!this.message.params) {
	        return true;
	      }

	      if (this.message.params.IMOL_FORM && this.message.params.IMOL_FORM === 'like') {
	        return false;
	      }

	      return true;
	    }
	  }, ui_vue_vuex.WidgetVuex.mapState({
	    widget: function widget(state) {
	      return state.widget;
	    }
	  })),
	  template: "\n\t\t<div v-if=\"showMessage\" class=\"bx-imopenlines-message\">\n\t\t\t<div v-if=\"dialogNumber\" class=\"bx-imopenlines-message-dialog-number\">{{dialogNumber}}</div>\n\t\t\t#PARENT_TEMPLATE#\n\t\t</div>\n\t"
	});

}((this.window = this.window || {}),BX,BX,window,BX.Event));
 




// file: /bitrix/js/imopenlines/component/form/dist/form.bundle.js
(function (exports,ui_vue,ui_vue_vuex) {
    'use strict';

    function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

    function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { babelHelpers.defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
    var EVENT_POSTFIX = 'Openlines';
    var LIVECHAT_PREFIX = 'livechat';
    ui_vue.WidgetBitrixVue.component('bx-imopenlines-form', {
      props: {
        message: {
          type: Object,
          required: false
        }
      },
      data: function data() {
        return {
          formSuccess: false,
          formError: false
        };
      },
      mounted: function mounted() {
        if (this.filledFormFlag) {
          this.formSuccess = true;
        }
      },
      computed: _objectSpread({
        chatId: function chatId() {
          return this.application.dialog.chatId;
        },
        formId: function formId() {
          if (this.message) {
            return String(this.message.params.CRM_FORM_ID);
          }

          if (this.widget.common.crmFormsSettings.welcomeFormId) {
            return this.widget.common.crmFormsSettings.welcomeFormId;
          }

          return '';
        },
        formSec: function formSec() {
          if (this.message) {
            return this.message.params.CRM_FORM_SEC;
          }

          if (this.widget.common.crmFormsSettings.welcomeFormSec) {
            return this.widget.common.crmFormsSettings.welcomeFormSec;
          }

          return '';
        },
        showForm: function showForm() {
          return this.formId && this.formSec && !this.formSuccess && !this.formError;
        },
        filledFormFlag: function filledFormFlag() {
          if (this.message) {
            return this.message.params.CRM_FORM_FILLED === 'Y';
          }

          return false;
        },
        messageCount: function messageCount() {
          return this.dialog.messageCount;
        }
      }, ui_vue_vuex.WidgetVuex.mapState({
        widget: function widget(state) {
          return state.widget;
        },
        application: function application(state) {
          return state.application;
        },
        dialog: function dialog(state) {
          return state.dialogues.collection[state.application.dialog.dialogId];
        }
      })),
      watch: {
        filledFormFlag: function filledFormFlag(newValue) {
          if (newValue === true && !this.formSuccess) {
            this.formSuccess = true;
          }
        },
        chatId: function chatId(newValue) {
          // chatId > 0 means chat and user were initialized
          if (newValue !== 0 && this.widgetInitPromiseResolve) {
            this.widgetInitPromiseResolve();
          }
        }
      },
      methods: {
        getCrmBindings: function getCrmBindings() {
          var _this = this;

          return new Promise(function (resolve, reject) {
            _this.$Bitrix.RestClient.get().callMethod('imopenlines.widget.crm.bindings.get', {
              'OPENLINES_CODE': _this.buildOpenlinesCode()
            }).then(resolve)["catch"](reject);
          });
        },
        onBeforeFormSubmit: function onBeforeFormSubmit(eventData) {
          if (this.signedEntities && this.signedEntities !== '') {
            eventData.sign = this.signedEntities;
          }
        },
        onFormSubmit: function onFormSubmit(eventData) {
          var _this2 = this;

          this.eventData = eventData; // redefine form promise so we can send form manually later

          this.eventData.promise = this.eventData.promise.then(function () {
            return new Promise(function (resolve) {
              if (_this2.chatId === 0) {
                // promise we resolve after user and chat are inited, resolve method is saved to use in chatId watcher
                new Promise(function (widgetResolve, widgetReject) {
                  _this2.widgetInitPromiseResolve = widgetResolve;
                }).then(function () {
                  _this2.setFormProperties();

                  return resolve();
                });

                _this2.getApplication().requestData();
              } // we have user and chat so we can just resolve form promise instantly
              else {
                // request current crm bindings and attach them to form
                if (_this2.widget.common.crmFormsSettings.welcomeFormDelay) {
                  _this2.getCrmBindings().then(function (result) {
                    _this2.signedEntities = result.data();

                    _this2.setFormProperties();

                    return resolve();
                  })["catch"](function (error) {
                    console.error('Error getting CRM bindings', error);
                  });
                } else {
                  _this2.setFormProperties();

                  return resolve();
                }
              }
            });
          });
        },
        setFormProperties: function setFormProperties() {
          if (!this.eventData) {
            return false;
          }

          this.eventData.form.setProperty('eventNamePostfix', EVENT_POSTFIX);
          this.eventData.form.setProperty('openlinesCode', this.buildOpenlinesCode());

          if (this.message) {
            var _this$message$params$;

            this.eventData.form.setProperty('messageId', this.message.id);
            this.eventData.form.setProperty('isWelcomeForm', (_this$message$params$ = this.message.params.IS_WELCOME_FORM) !== null && _this$message$params$ !== void 0 ? _this$message$params$ : 'N');
          } else {
            this.eventData.form.setProperty('isWelcomeForm', 'Y');
          }
        },
        buildOpenlinesCode: function buildOpenlinesCode() {
          var configId = 0;

          if (this.dialog.entityId !== '') {
            configId = this.dialog.entityId.split('|')[0];
          }

          var chatId = this.dialog.chatId || 0;
          var userId = this.application.common.userId || 0;
          return "".concat(LIVECHAT_PREFIX, "|").concat(configId, "|").concat(chatId, "|").concat(userId);
        },
        onFormSendSuccess: function onFormSendSuccess() {
          if (!this.message) {
            this.$store.commit('widget/common', {
              dialogStart: true
            });
          }

          this.$emit('formSendSuccess');
          this.formSuccess = true;
        },
        onFormSendError: function onFormSendError(error) {
          this.formError = true;
          this.$emit('formSendError', {
            error: error
          });
        },
        getSuccessText: function getSuccessText() {
          return this.widget.common.crmFormsSettings.successText;
        },
        getErrorText: function getErrorText() {
          return this.widget.common.crmFormsSettings.errorText;
        },
        getApplication: function getApplication() {
          return this.$Bitrix.Application.get();
        }
      },
      template: "\n\t\t<div class=\"bx-im-message bx-im-message-without-menu bx-im-message-without-avatar bx-imopenlines-form-wrapper\">\n\t\t\t<div v-show=\"showForm\" class=\"bx-imopenlines-form-content\">\n\t\t\t\t<bx-crm-form\n\t\t\t\t\t:id=\"formId\"\n\t\t\t\t\t:sec=\"formSec\"\n\t\t\t\t\t:address=\"widget.common.host\"\n\t\t\t\t\t:lang=\"application.common.languageId\"\n\t\t\t\t\t@form:submit:post:before=\"onBeforeFormSubmit\"\n\t\t\t\t\t@form:submit=\"onFormSubmit\"\n\t\t\t\t\t@form:send:success=\"onFormSendSuccess\"\n\t\t\t\t\t@form:send:error=\"onFormSendError\"\n\t\t\t\t/>\n\t\t\t</div>\n\t\t\t<div v-show=\"formSuccess\" class=\"bx-imopenlines-form-result-container bx-imopenlines-form-success\">\n\t\t\t\t<div class=\"bx-imopenlines-form-result-icon\"></div>\n\t\t\t\t<div class=\"bx-imopenlines-form-result-title\">\n\t\t\t\t\t{{ getSuccessText() }}\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t\t<div v-show=\"formError\" class=\"bx-imopenlines-form-result-container bx-imopenlines-form-error\">\n\t\t\t\t<div class=\"bx-imopenlines-form-result-icon\"></div>\n\t\t\t\t<div class=\"bx-imopenlines-form-result-title\">\n\t\t\t\t\t{{ getErrorText() }}\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t</div>\n\t"
    });

}((this.window = this.window || {}),BX,BX));
 




// file: /bitrix/js/im/provider/rest/dist/registry.bundle.js
this.BX = this.BX || {};
this.BX.Messenger = this.BX.Messenger || {};
this.BX.Messenger.Provider = this.BX.Messenger.Provider || {};
(function (exports,ui_vue_vuex,im_const,im_lib_logger,main_core_events) {
	'use strict';

	/**
	 * Bitrix Messenger
	 * Base Rest Answer Handler
	 *
	 * @package bitrix
	 * @subpackage im
	 * @copyright 2001-2019 Bitrix
	 */
	var BaseRestHandler = /*#__PURE__*/function () {
	  babelHelpers.createClass(BaseRestHandler, null, [{
	    key: "create",
	    value: function create() {
	      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	      return new this(params);
	    }
	  }]);

	  function BaseRestHandler() {
	    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	    babelHelpers.classCallCheck(this, BaseRestHandler);

	    if (babelHelpers["typeof"](params.controller) === 'object' && params.controller) {
	      this.controller = params.controller;
	    }

	    if (babelHelpers["typeof"](params.store) === 'object' && params.store) {
	      this.store = params.store;
	    }
	  }

	  babelHelpers.createClass(BaseRestHandler, [{
	    key: "execute",
	    value: function execute(command, result) {
	      var extra = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
	      command = 'handle' + command.split('.').map(function (element) {
	        return element.charAt(0).toUpperCase() + element.slice(1);
	      }).join('');

	      if (result.error()) {
	        if (typeof this[command + 'Error'] === 'function') {
	          return this[command + 'Error'](result.error(), extra);
	        }
	      } else {
	        if (typeof this[command + 'Success'] === 'function') {
	          return this[command + 'Success'](result.data(), extra);
	        }
	      }

	      return typeof this[command] === 'function' ? this[command](result, extra) : null;
	    }
	  }]);
	  return BaseRestHandler;
	}();

	function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { babelHelpers.defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

	var CoreRestHandler = /*#__PURE__*/function (_BaseRestHandler) {
	  babelHelpers.inherits(CoreRestHandler, _BaseRestHandler);

	  function CoreRestHandler() {
	    babelHelpers.classCallCheck(this, CoreRestHandler);
	    return babelHelpers.possibleConstructorReturn(this, babelHelpers.getPrototypeOf(CoreRestHandler).apply(this, arguments));
	  }

	  babelHelpers.createClass(CoreRestHandler, [{
	    key: "handleImUserListGetSuccess",
	    value: function handleImUserListGetSuccess(data) {
	      this.store.dispatch('users/set', ui_vue_vuex.WidgetVuexBuilderModel.convertToArray(data));
	    }
	  }, {
	    key: "handleImUserGetSuccess",
	    value: function handleImUserGetSuccess(data) {
	      this.store.dispatch('users/set', [data]);
	    }
	  }, {
	    key: "handleImChatGetSuccess",
	    value: function handleImChatGetSuccess(data) {
	      this.store.dispatch('dialogues/set', data);
	    }
	  }, {
	    key: "handleImDialogMessagesGetSuccess",
	    value: function handleImDialogMessagesGetSuccess(data) {
	      this.store.dispatch('users/set', data.users);
	      this.store.dispatch('files/setBefore', this.controller.application.prepareFilesBeforeSave(data.files)); // this.store.dispatch('messages/setBefore', data.messages);
	    }
	  }, {
	    key: "handleImDialogMessagesGetInitSuccess",
	    value: function handleImDialogMessagesGetInitSuccess(data) {
	      this.store.dispatch('users/set', data.users);
	      this.store.dispatch('files/set', this.controller.application.prepareFilesBeforeSave(data.files)); //handling messagesSet for empty chat

	      if (data.messages.length === 0 && data.chat_id) {
	        im_lib_logger.Logger.warn('setting messagesSet for empty chat', data.chat_id);
	        setTimeout(function () {
	          main_core_events.EventEmitter.emit(im_const.EventType.dialog.messagesSet, {
	            chatId: data.chat_id
	          });
	        }, 100);
	      } else {
	        this.store.dispatch('messages/set', data.messages.reverse());
	      }
	    }
	  }, {
	    key: "handleImDialogMessagesGetUnreadSuccess",
	    value: function handleImDialogMessagesGetUnreadSuccess(data) {
	      this.store.dispatch('users/set', data.users);
	      this.store.dispatch('files/set', this.controller.application.prepareFilesBeforeSave(data.files)); // this.store.dispatch('messages/setAfter', data.messages);
	    }
	  }, {
	    key: "handleImDiskFolderGetSuccess",
	    value: function handleImDiskFolderGetSuccess(data) {
	      this.store.commit('application/set', {
	        dialog: {
	          diskFolderId: data.ID
	        }
	      });
	    }
	  }, {
	    key: "handleImMessageAddSuccess",
	    value: function handleImMessageAddSuccess(messageId, message) {
	      var _this = this;

	      this.store.dispatch('messages/update', {
	        id: message.id,
	        chatId: message.chatId,
	        fields: {
	          id: messageId,
	          sending: false,
	          error: false
	        }
	      }).then(function () {
	        _this.store.dispatch('messages/actionFinish', {
	          id: messageId,
	          chatId: message.chatId
	        });
	      });
	    }
	  }, {
	    key: "handleImMessageAddError",
	    value: function handleImMessageAddError(error, message) {
	      this.store.dispatch('messages/actionError', {
	        id: message.id,
	        chatId: message.chatId
	      });
	    }
	  }, {
	    key: "handleImDiskFileCommitSuccess",
	    value: function handleImDiskFileCommitSuccess(result, message) {
	      var _this2 = this;

	      this.store.dispatch('messages/update', {
	        id: message.id,
	        chatId: message.chatId,
	        fields: {
	          id: result['MESSAGE_ID'],
	          sending: false,
	          error: false
	        }
	      }).then(function () {
	        _this2.store.dispatch('messages/actionFinish', {
	          id: result['MESSAGE_ID'],
	          chatId: message.chatId
	        });
	      });
	    }
	  }, {
	    key: "handleImDiskFileCommitError",
	    value: function handleImDiskFileCommitError(error, message) {
	      this.store.dispatch('files/update', {
	        chatId: message.chatId,
	        id: message.file.id,
	        fields: {
	          status: im_const.FileStatus.error,
	          progress: 0
	        }
	      });
	      this.store.dispatch('messages/actionError', {
	        id: message.id,
	        chatId: message.chatId,
	        retry: false
	      });
	    }
	  }, {
	    key: "handleImRecentListSuccess",
	    value: function handleImRecentListSuccess(result, message) {
	      im_lib_logger.Logger.warn('Provider.Rest.handleImRecentGetSuccess', result);
	      var users = [];
	      var dialogues = [];
	      var recent = [];
	      result.items.forEach(function (item) {
	        var userId = 0;
	        var chatId = 0;

	        if (item.user && item.user.id > 0) {
	          userId = item.user.id;
	          users.push(item.user);
	        }

	        if (item.chat) {
	          chatId = item.chat.id;
	          dialogues.push(Object.assign(item.chat, {
	            dialogId: item.id
	          }));
	        } else {
	          dialogues.push(Object.assign({}, {
	            dialogId: item.id
	          }));
	        }

	        recent.push(_objectSpread(_objectSpread({}, item), {}, {
	          avatar: item.avatar.url,
	          color: item.avatar.color,
	          userId: userId,
	          chatId: chatId
	        }));
	      });
	      this.store.dispatch('users/set', users);
	      this.store.dispatch('dialogues/set', dialogues);
	      this.store.dispatch('recent/set', recent);
	    }
	  }]);
	  return CoreRestHandler;
	}(BaseRestHandler);

	/**
	 * Bitrix Im
	 * Dialog Rest answers (Rest Answer Handler)
	 *
	 * @package bitrix
	 * @subpackage im
	 * @copyright 2001-2023 Bitrix
	 */
	var DialogRestHandler = /*#__PURE__*/function (_BaseRestHandler) {
	  babelHelpers.inherits(DialogRestHandler, _BaseRestHandler);

	  function DialogRestHandler(params) {
	    var _this;

	    babelHelpers.classCallCheck(this, DialogRestHandler);
	    _this = babelHelpers.possibleConstructorReturn(this, babelHelpers.getPrototypeOf(DialogRestHandler).call(this, params));
	    _this.application = params.application;
	    return _this;
	  }

	  babelHelpers.createClass(DialogRestHandler, [{
	    key: "handleImChatGetSuccess",
	    value: function handleImChatGetSuccess(data) {
	      this.store.commit('application/set', {
	        dialog: {
	          chatId: data.id,
	          dialogId: data.dialog_id,
	          diskFolderId: data.disk_folder_id
	        }
	      });
	    }
	  }, {
	    key: "handleImCallGetCallLimitsSuccess",
	    value: function handleImCallGetCallLimitsSuccess(data) {
	      this.store.commit('application/set', {
	        call: {
	          serverEnabled: data.callServerEnabled,
	          maxParticipants: data.maxParticipants
	        }
	      });
	    }
	  }, {
	    key: "handleImChatGetError",
	    value: function handleImChatGetError(error) {
	      if (error.ex.error === 'ACCESS_ERROR') {
	        im_lib_logger.Logger.error('MobileRestAnswerHandler.handleImChatGetError: ACCESS_ERROR'); //	app.closeController();
	      }
	    }
	  }, {
	    key: "handleImDialogMessagesGetInitSuccess",
	    value: function handleImDialogMessagesGetInitSuccess(data) {// EventEmitter.emit(EventType.dialog.readVisibleMessages, {chatId: this.controller.application.getChatId()});
	    }
	  }, {
	    key: "handleImMessageAddSuccess",
	    value: function handleImMessageAddSuccess(messageId, message) {
	      console.warn('im.message.add success in dialog handler'); // this.application.messagesQueue = this.context.messagesQueue.filter(el => el.id !== message.id);
	    }
	  }, {
	    key: "handleImMessageAddError",
	    value: function handleImMessageAddError(error, message) {// this.application.messagesQueue = this.context.messagesQueue.filter(el => el.id !== message.id);
	    }
	  }, {
	    key: "handleImDiskFileCommitSuccess",
	    value: function handleImDiskFileCommitSuccess(result, message) {// this.application.messagesQueue = this.context.messagesQueue.filter(el => el.id !== message.id);
	    }
	  }]);
	  return DialogRestHandler;
	}(BaseRestHandler);

	/**
	 * Bitrix Messenger
	 * Bundle rest answer handlers
	 *
	 * @package bitrix
	 * @subpackage im
	 * @copyright 2001-2019 Bitrix
	 */

	exports.BaseRestHandler = BaseRestHandler;
	exports.CoreRestHandler = CoreRestHandler;
	exports.DialogRestHandler = DialogRestHandler;

}((this.BX.Messenger.Provider.Rest = this.BX.Messenger.Provider.Rest || {}),BX,BX.Messenger.Const,BX.Messenger.Lib,BX.Event));
 




// file: /bitrix/js/main/polyfill/promise/js/promise.js
;(function(window) {
	'use strict';

	if (typeof window.Promise === 'undefined' ||
		window.Promise.toString().indexOf('[native code]') === -1)
	{
		var PROMISE_STATUS = '[[PromiseStatus]]';
		var PROMISE_VALUE = '[[PromiseValue]]';
		var STATUS_PENDING = 'pending';
		var STATUS_INTERNAL_PENDING = 'internal pending';
		var STATUS_RESOLVED = 'resolved';
		var STATUS_REJECTED = 'rejected';


		/**
		 * Handles promise done
		 * @param {Promise} promise
		 * @param {Handler} deferred
		 */
		var handle = function(promise, deferred)
		{
			if (promise[PROMISE_STATUS] === STATUS_INTERNAL_PENDING)
			{
				promise = promise[PROMISE_VALUE];
			}

			if (promise[PROMISE_STATUS] === STATUS_PENDING)
			{
				promise.deferreds.push(deferred);
			}
			else
			{
				promise.handled = true;

				setTimeout(function() {
					var callback = promise[PROMISE_STATUS] === STATUS_RESOLVED ?
						deferred.onFulfilled : deferred.onRejected;

					if (callback)
					{
						try {
							resolve(deferred.promise, callback(promise[PROMISE_VALUE]));
						} catch (err) {
							reject(deferred.promise, err);
						}
					}
					else
					{
						if (promise[PROMISE_STATUS] === STATUS_RESOLVED)
						{
							resolve(deferred.promise, promise[PROMISE_VALUE]);
						}
						else
						{
							reject(deferred.promise, promise[PROMISE_VALUE]);
						}
					}
				}, 0);
			}
		};


		/**
		 * Resolves promise with value
		 * @param {Promise} promise
		 * @param {*} value
		 */
		var resolve = function(promise, value) {
			if (value === promise)
			{
				throw new TypeError('A promise cannot be resolved with it promise.');
			}

			try {
				if (value && (typeof value === 'object' || typeof value === 'function'))
				{
					if (value instanceof Promise)
					{
						promise[PROMISE_STATUS] = STATUS_INTERNAL_PENDING;
						promise[PROMISE_VALUE] = value;
						finale(promise);
						return;
					}
					else if (typeof value.then === 'function')
					{
						executePromise(value.then.bind(value), promise);
						return;
					}
				}

				promise[PROMISE_STATUS] = STATUS_RESOLVED;
				promise[PROMISE_VALUE] = value;
				finale(promise);
			} catch (err) {
				reject(promise, err);
			}
		};


		/**
		 * Rejects promise with reason
		 * @param promise
		 * @param reason
		 */
		var reject = function(promise, reason)
		{
			promise[PROMISE_STATUS] = STATUS_REJECTED;
			promise[PROMISE_VALUE] = reason;
			finale(promise);
		};


		/**
		 * Calls async callback
		 * @param {Promise} promise
		 */
		var finale = function(promise)
		{
			if (promise[PROMISE_STATUS] === STATUS_REJECTED && promise.deferreds.length === 0)
			{
				setTimeout(function() {
					if (!promise.handled)
					{
						console.error('Unhandled Promise Rejection: ' + promise[PROMISE_VALUE]);
					}
				}, 0);
			}

			promise.deferreds.forEach(function(deferred) {
				handle(promise, deferred);
			});

			promise.deferreds = null;
		};


		/**
		 * Executes promise
		 * @param {function} resolver - Resolver
		 * @param {Promise} promise
		 */
		var executePromise = function(resolver, promise)
		{
			var done = false;

			try {
				resolver(resolveWrapper, rejectWrapper);
			} catch (err) {
				if (!done)
				{
					done = true;
					reject(promise, err);
				}
			}

			// Resolve function
			function resolveWrapper(value)
			{
				if (!done)
				{
					done = true;
					resolve(promise, value);
				}
			}

			// Reject function
			function rejectWrapper(reason)
			{
				if (!done)
				{
					done = true;
					reject(promise, reason);
				}
			}
		};


		/**
		 * Implements interface for works with promise handlers
		 * @param {?function} [onFulfilled]
		 * @param {?function} [onRejected]
		 * @param {Promise} promise
		 *
		 * @constructor
		 */
		var Handler = function(onFulfilled, onRejected, promise)
		{
			this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;
			this.onRejected = typeof onRejected === 'function' ? onRejected : null;
			this.promise = promise;
		};


		/**
		 * Implements Promise polyfill
		 * @param {function} resolver
		 *
		 * @constructor
		 */
		var Promise = function(resolver)
		{
			this[PROMISE_STATUS] = STATUS_PENDING;
			this[PROMISE_VALUE] = null;
			this.handled = false;
			this.deferreds = [];

			// Try execute promise resolver
			executePromise(resolver, this);
		};


		/**
		 * Appends a rejection handler callback to the promise,
		 * and returns a new promise resolving to the return value of the callback if it is called,
		 * or to its original fulfillment value if the promise is instead fulfilled.
		 *
		 * @param {function} onRejected
		 */
		Promise.prototype['catch'] = function(onRejected) {
			return this.then(null, onRejected);
		};


		/**
		 * Appends fulfillment and rejection handlers to the promise,
		 * and returns a new promise resolving to the return value of the called handler,
		 * or to its original settled value if the promise was not handled
		 * (i.e. if the relevant handler onFulfilled or onRejected is not a function).
		 *
		 * @param {function} onFulfilled
		 * @param {function} [onRejected]
		 * @returns {Promise}
		 */
		Promise.prototype.then = function(onFulfilled, onRejected)
		{
			var promise = new Promise(function() {});
			handle(this, new Handler(onFulfilled, onRejected, promise));
			return promise;
		};


		/**
		 * The method returns a single Promise that resolves when all of the promises
		 * in the iterable argument have resolved or when the iterable argument contains no promises.
		 * It rejects with the reason of the first promise that rejects.
		 *
		 * @static
		 * @param iterable - An iterable object such as an Array or String
		 * @return {Promise}
		 */
		Promise.all = function(iterable)
		{
			var args = [].slice.call(iterable);

			return new Promise(function(resolve, reject) {
				if (args.length === 0)
				{
					resolve(args);
				}
				else
				{
					var remaining = args.length;

					var res = function(i, val)
					{
						try {
							if (val && (typeof val === 'object' || typeof val === 'function'))
							{
								if (typeof val.then === 'function')
								{
									val.then.call(val, function(val) {
										res(i, val);
									}, reject);
									return;
								}
							}

							args[i] = val;

							if (--remaining === 0)
							{
								resolve(args);
							}
						} catch (ex) {
							reject(ex);
						}
					};

					for (var i = 0; i < args.length; i++)
					{
						res(i, args[i]);
					}
				}
			});
		};


		/**
		 * The method returns a Promise object that is resolved with the given value.
		 * If the value is a thenable (i.e. has a 'then' method),
		 * the returned promise will 'follow' that thenable, adopting its eventual state;
		 * if the value was a promise, that object becomes the result of the call to Promise.resolve;
		 * otherwise the returned promise will be fulfilled with the value.
		 *
		 * @param {*|Promise} value - Argument to be resolved by this Promise. Can also be a Promise or a thenable to resolve.
		 * @returns {Promise}
		 */
		Promise.resolve = function(value)
		{
			if (value && typeof value === 'object' && value.constructor === Promise)
			{
				return value;
			}

			return new Promise(function(resolve) {
				resolve(value);
			});
		};


		/**
		 * The method returns a Promise object that is rejected with the given reason.
		 *
		 * @param {*} reason - Reason why this Promise rejected.
		 * @returns {Promise}
		 */
		Promise.reject = function(reason)
		{
			return new Promise(function(resolve, reject) {
				reject(reason);
			});
		};


		/**
		 * The Promise.race(iterable) method returns a promise that resolves or rejects
		 * as soon as one of the promises in the iterable resolves or rejects,
		 * with the value or reason from that promise.
		 *
		 * @static
		 * @param iterable - An iterable object, such as an Array.
		 * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols
		 * @returns {Promise}
		 */
		Promise.race = function(iterable)
		{
			return new Promise(function(resolve, reject) {
				for (var i = 0, len = iterable.length; i < len; i++)
				{
					iterable[i].then(resolve, reject);
				}
			});
		};

		window.Promise = Promise;
	}
})(window);



// file: /bitrix/js/ui/vue/components/crm/form/dist/crm.form.bundle.js
this.BX = this.BX || {};
this.BX.Ui = this.BX.Ui || {};
this.BX.Ui.Vue = this.BX.Ui.Vue || {};
this.BX.Ui.Vue.Components = this.BX.Ui.Vue.Components || {};
(function (exports,ui_vue) {
    'use strict';

    function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

    function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { babelHelpers.defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
    var loadAppPromise = null;
    ui_vue.WidgetVue.component('bx-crm-form', {
      props: {
        id: {
          type: String,
          required: true
        },
        sec: {
          type: String,
          required: true
        },
        lang: {
          type: String,
          required: true,
          "default": 'en'
        },
        address: {
          type: String,
          required: true,
          "default": function _default() {
            return window.location.origin;
          }
        },
        design: {
          type: Object,
          required: false,
          "default": function _default() {
            return {
              compact: true
            };
          }
        }
      },
      data: function data() {
        return {
          message: '',
          isLoading: false,
          obj: {}
        };
      },
      beforeDestroy: function beforeDestroy() {
        if (this.obj.instance) {
          this.obj.instance.destroy();
        }
      },
      mounted: function mounted() {
        var _this = this;

        var loadForm = function loadForm() {
          _this.isLoading = false;
          _this.message = '';
          _this.obj.config.data.node = _this.$el;
          _this.obj.config.data.design = _objectSpread(_objectSpread({}, _this.obj.config.data.design), _this.design);
          _this.obj.instance = window.b24form.App.createForm24(_this.obj.config, _this.obj.config.data);

          _this.obj.instance.subscribeAll(function (data, instance, type) {
            data = data || {};
            data.form = instance;

            _this.$emit('form:' + type, data);
          });
        };

        this.isLoading = true;
        var promise = null;

        if (window.fetch) {
          var formData = new FormData();
          formData.append('id', this.id);
          formData.append('sec', this.sec);
          promise = fetch(this.address + "/bitrix/services/main/ajax.php?action=crm.site.form.get", {
            method: 'POST',
            body: formData,
            mode: "cors"
          });
        } else {
          this.message = 'error';
          return;
        }

        promise.then(function (response) {
          return response.json();
        }).then(function (data) {
          if (data.error) {
            throw new Error(data.error_description);
          }

          _this.obj.config = data.result.config;

          if (window.b24form && window.b24form.App) {
            loadForm();
            return;
          }

          if (!loadAppPromise) {
            loadAppPromise = new Promise(function (resolve, reject) {
              var checker = function checker() {
                if (!window.b24form || !window.b24form || !window.b24form.App) {
                  setTimeout(checker, 200);
                } else {
                  resolve();
                }
              };

              var node = document.createElement('script');
              node.src = data.result.loader.app.link;
              node.onload = checker;
              node.onerror = reject;
              document.head.appendChild(node);
            });
          }

          loadAppPromise.then(loadForm)["catch"](function (e) {
            _this.message = 'App load failed:' + e;
          });
        })["catch"](function (error) {
          _this.isLoading = false;
          _this.message = error;
        });
      },
      template: "\n\t\t<div>\n\t\t\t<div v-if=\"isLoading\" class=\"ui-vue-crm-form-loading-container\"></div>\n\t\t\t<div v-else-if=\"message\">{{ message }}</div>\n\t\t</div>\n\t"
    });

}((this.BX.Ui.Vue.Components.Crm = this.BX.Ui.Vue.Components.Crm || {}),BX));
 




// file: /bitrix/js/im/provider/pull/dist/registry.bundle.js
this.BX = this.BX || {};
this.BX.Messenger = this.BX.Messenger || {};
this.BX.Messenger.Provider = this.BX.Messenger.Provider || {};
(function (exports,ui_vue_vuex,im_const,im_lib_logger,main_core_events,pull_client) {
	'use strict';

	function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { babelHelpers.defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
	var ImBasePullHandler = /*#__PURE__*/function () {
	  babelHelpers.createClass(ImBasePullHandler, null, [{
	    key: "create",
	    value: function create() {
	      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	      return new this(params);
	    }
	  }]);

	  function ImBasePullHandler() {
	    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	    babelHelpers.classCallCheck(this, ImBasePullHandler);

	    if (babelHelpers["typeof"](params.controller) === 'object' && params.controller) {
	      this.controller = params.controller;
	    }

	    if (babelHelpers["typeof"](params.store) === 'object' && params.store) {
	      this.store = params.store;
	    }

	    this.option = babelHelpers["typeof"](params.store) === 'object' && params.store ? params.store : {};

	    if (!(babelHelpers["typeof"](this.option.handlingDialog) === 'object' && this.option.handlingDialog && this.option.handlingDialog.chatId && this.option.handlingDialog.dialogId)) {
	      this.option.handlingDialog = false;
	    }
	  }

	  babelHelpers.createClass(ImBasePullHandler, [{
	    key: "getModuleId",
	    value: function getModuleId() {
	      return 'im';
	    }
	  }, {
	    key: "getSubscriptionType",
	    value: function getSubscriptionType() {
	      return pull_client.PullClient.SubscriptionType.Server;
	    }
	  }, {
	    key: "skipExecute",
	    value: function skipExecute(params) {
	      var extra = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

	      if (!extra.optionImportant) {
	        if (this.option.skip) {
	          im_lib_logger.Logger.info('Pull: command skipped while loading messages', params);
	          return true;
	        }

	        if (!this.option.handlingDialog) {
	          return false;
	        }
	      }

	      if (typeof params.chatId !== 'undefined' || typeof params.dialogId !== 'undefined') {
	        if (typeof params.chatId !== 'undefined' && parseInt(params.chatId) === parseInt(this.option.handlingDialog.chatId)) {
	          return false;
	        }

	        if (typeof params.dialogId !== 'undefined' && params.dialogId.toString() === this.option.handlingDialog.dialogId.toString()) {
	          return false;
	        }

	        return true;
	      }

	      return false;
	    }
	  }, {
	    key: "handleMessage",
	    value: function handleMessage(params, extra) {
	      this.handleMessageAdd(params, extra);
	    }
	  }, {
	    key: "handleMessageChat",
	    value: function handleMessageChat(params, extra) {
	      this.handleMessageAdd(params, extra);
	    }
	  }, {
	    key: "handleMessageAdd",
	    value: function handleMessageAdd(params, extra) {
	      var _this = this;

	      im_lib_logger.Logger.warn('handleMessageAdd', params);

	      if (this.skipExecute(params, extra)) {
	        return false;
	      }

	      var collection = this.store.state.messages.collection[params.chatId];

	      if (!collection) {
	        collection = [];
	      } //search for message with message id from params


	      var message = collection.find(function (element) {
	        if (params.message.templateId && element.id === params.message.templateId) {
	          return true;
	        }

	        return element.id === params.message.id;
	      }); //stop if it's message with 'push' (pseudo push message in mobile)

	      if (message && params.message.push) {
	        return false;
	      }

	      if (params.chat && params.chat[params.chatId]) {
	        var existingChat = this.store.getters['dialogues/getByChatId'](params.chatId); //add new chat if there is no one

	        if (!existingChat) {
	          var chatToAdd = Object.assign({}, params.chat[params.chatId], {
	            dialogId: params.dialogId
	          });
	          this.store.dispatch('dialogues/set', chatToAdd);
	        } //otherwise - update it
	        else {
	          this.store.dispatch('dialogues/update', {
	            dialogId: params.dialogId,
	            fields: params.chat[params.chatId]
	          });
	        }
	      }

	      var recentItem = this.store.getters['recent/get'](params.dialogId); //add recent item if there is no one

	      if (!recentItem) {
	        var newRecentItem = this.prepareRecentItem(params);
	        this.store.dispatch('recent/set', [newRecentItem]);
	      } //otherwise - update it
	      else {
	        this.store.dispatch('recent/update', {
	          id: params.dialogId,
	          fields: {
	            lines: params.lines || {
	              id: 0
	            },
	            message: {
	              id: params.message.id,
	              text: params.message.textOriginal,
	              date: params.message.date,
	              senderId: params.message.senderId,
	              withFile: typeof params.message.params['FILE_ID'] !== 'undefined',
	              withAttach: typeof params.message.params['ATTACH'] !== 'undefined'
	            },
	            counter: params.counter
	          }
	        });
	      } //set users


	      if (params.users) {
	        this.store.dispatch('users/set', ui_vue_vuex.WidgetVuexBuilderModel.convertToArray(params.users));
	      } //set files


	      if (params.files) {
	        var files = this.controller.application.prepareFilesBeforeSave(ui_vue_vuex.WidgetVuexBuilderModel.convertToArray(params.files));
	        files.forEach(function (file) {
	          if (files.length === 1 && params.message.templateFileId && _this.store.state.files.index[params.chatId] && _this.store.state.files.index[params.chatId][params.message.templateFileId]) {
	            _this.store.dispatch('files/update', {
	              id: params.message.templateFileId,
	              chatId: params.chatId,
	              fields: file
	            }).then(function () {
	              main_core_events.EventEmitter.emit(im_const.EventType.dialog.scrollToBottom, {
	                chatId: params.chatId,
	                cancelIfScrollChange: true
	              });
	            });
	          } else {
	            _this.store.dispatch('files/set', file);
	          }
	        });
	      } //if we already have message - update it and scrollToBottom


	      if (message) {
	        im_lib_logger.Logger.warn('New message pull handler: we already have this message', params.message);
	        this.store.dispatch('messages/update', {
	          id: message.id,
	          chatId: message.chatId,
	          fields: _objectSpread(_objectSpread({}, params.message), {}, {
	            sending: false,
	            error: false
	          })
	        }).then(function () {
	          if (!params.message.push) {
	            main_core_events.EventEmitter.emit(im_const.EventType.dialog.scrollToBottom, {
	              chatId: message.chatId,
	              cancelIfScrollChange: params.message.senderId !== _this.controller.application.getUserId()
	            });
	          }
	        });
	      } //if we dont have message and we have all pages - add new message and send newMessage event (handles scroll stuff)
	      //we dont do anything if we dont have message and there are unloaded messages
	      else if (this.controller.application.isUnreadMessagesLoaded()) {
	        im_lib_logger.Logger.warn('New message pull handler: we dont have this message', params.message);
	        this.store.dispatch('messages/setAfter', _objectSpread(_objectSpread({}, params.message), {}, {
	          unread: true
	        })).then(function () {
	          if (!params.message.push) {
	            main_core_events.EventEmitter.emit(im_const.EventType.dialog.newMessage, {
	              chatId: params.message.chatId,
	              messageId: params.message.id
	            });
	          }
	        });
	      } //stop writing event


	      this.controller.application.stopOpponentWriting({
	        dialogId: params.dialogId,
	        userId: params.message.senderId
	      }); //if we sent message and there are no unloaded unread pages - read all messages on server and client, set counter to 0
	      //TODO: to think about it during new chat development

	      if (params.message.senderId === this.controller.application.getUserId() && this.controller.application.isUnreadMessagesLoaded()) {
	        if (this.store.state.dialogues.collection[params.dialogId] && this.store.state.dialogues.collection[params.dialogId].counter !== 0) {
	          this.controller.restClient.callMethod('im.dialog.read', {
	            dialog_id: params.dialogId
	          }).then(function () {
	            _this.store.dispatch('messages/readMessages', {
	              chatId: params.chatId
	            }).then(function (result) {
	              main_core_events.EventEmitter.emit(im_const.EventType.dialog.scrollToBottom, {
	                chatId: params.chatId,
	                cancelIfScrollChange: false
	              });

	              _this.store.dispatch('dialogues/update', {
	                dialogId: params.dialogId,
	                fields: {
	                  counter: 0
	                }
	              });
	            });
	          });
	        }
	      } //increase the counter if message is not ours
	      else if (params.message.senderId !== this.controller.application.getUserId()) {
	        this.store.dispatch('dialogues/increaseCounter', {
	          dialogId: params.dialogId,
	          count: 1
	        });
	      } //set new lastMessageId (used for pagination)


	      this.store.dispatch('dialogues/update', {
	        dialogId: params.dialogId,
	        fields: {
	          lastMessageId: params.message.id
	        }
	      }); //increase total message count

	      this.store.dispatch('dialogues/increaseMessageCounter', {
	        dialogId: params.dialogId,
	        count: 1
	      });
	    }
	  }, {
	    key: "handleMessageUpdate",
	    value: function handleMessageUpdate(params, extra, command) {
	      this.execMessageUpdateOrDelete(params, extra, command);
	    }
	  }, {
	    key: "handleMessageDelete",
	    value: function handleMessageDelete(params, extra, command) {
	      this.execMessageUpdateOrDelete(params, extra, command);
	    }
	  }, {
	    key: "execMessageUpdateOrDelete",
	    value: function execMessageUpdateOrDelete(params, extra, command) {
	      if (this.skipExecute(params, extra)) {
	        return false;
	      }

	      this.controller.application.stopOpponentWriting({
	        dialogId: params.dialogId,
	        userId: params.senderId
	      });
	      this.store.dispatch('messages/update', {
	        id: params.id,
	        chatId: params.chatId,
	        fields: {
	          text: command === "messageUpdate" ? params.text : '',
	          textOriginal: command === "messageUpdate" ? params.textOriginal : '',
	          params: params.params,
	          blink: true
	        }
	      }).then(function () {
	        main_core_events.EventEmitter.emit(im_const.EventType.dialog.scrollToBottom, {
	          chatId: params.chatId,
	          cancelIfScrollChange: true
	        });
	      });
	      var recentItem = this.store.getters['recent/get'](params.dialogId);

	      if (command === 'messageUpdate' && recentItem.element && recentItem.element.message.id === params.id) {
	        this.store.dispatch('recent/update', {
	          id: params.dialogId,
	          fields: {
	            message: {
	              id: params.id,
	              text: params.text,
	              date: recentItem.element.message.date
	            }
	          }
	        });
	      }

	      if (command === 'messageDelete' && recentItem.element && recentItem.element.message.id === params.id) {
	        this.store.dispatch('recent/update', {
	          id: params.dialogId,
	          fields: {
	            message: {
	              id: params.id,
	              text: 'Message deleted',
	              date: recentItem.element.message.date
	            }
	          }
	        });
	      }
	    }
	  }, {
	    key: "handleMessageDeleteComplete",
	    value: function handleMessageDeleteComplete(params, extra) {
	      if (this.skipExecute(params, extra)) {
	        return false;
	      }

	      this.store.dispatch('messages/delete', {
	        id: params.id,
	        chatId: params.chatId
	      });
	      this.controller.application.stopOpponentWriting({
	        dialogId: params.dialogId,
	        userId: params.senderId,
	        action: false
	      });
	    }
	  }, {
	    key: "handleMessageLike",
	    value: function handleMessageLike(params, extra) {
	      if (this.skipExecute(params, extra)) {
	        return false;
	      }

	      this.store.dispatch('messages/update', {
	        id: params.id,
	        chatId: params.chatId,
	        fields: {
	          params: {
	            LIKE: params.users
	          }
	        }
	      });
	    }
	  }, {
	    key: "handleChatOwner",
	    value: function handleChatOwner(params, extra) {
	      if (this.skipExecute(params, extra)) {
	        return false;
	      }

	      this.store.dispatch('dialogues/update', {
	        dialogId: params.dialogId,
	        fields: {
	          ownerId: params.userId
	        }
	      });
	    }
	  }, {
	    key: "handleChatManagers",
	    value: function handleChatManagers(params, extra) {
	      if (this.skipExecute(params, extra)) {
	        return false;
	      }

	      this.store.dispatch('dialogues/update', {
	        dialogId: params.dialogId,
	        fields: {
	          managerList: params.list
	        }
	      });
	    }
	  }, {
	    key: "handleChatUpdateParams",
	    value: function handleChatUpdateParams(params, extra) {
	      if (this.skipExecute(params, extra)) {
	        return false;
	      }

	      this.store.dispatch('dialogues/update', {
	        dialogId: params.dialogId,
	        fields: params.params
	      });
	    }
	  }, {
	    key: "handleChatUserAdd",
	    value: function handleChatUserAdd(params, extra) {
	      if (this.skipExecute(params, extra)) {
	        return false;
	      }

	      this.store.dispatch('dialogues/update', {
	        dialogId: params.dialogId,
	        fields: {
	          userCounter: params.userCount
	        }
	      });
	    }
	  }, {
	    key: "handleChatUserLeave",
	    value: function handleChatUserLeave(params, extra) {
	      if (this.skipExecute(params, extra)) {
	        return false;
	      }

	      this.store.dispatch('dialogues/update', {
	        dialogId: params.dialogId,
	        fields: {
	          userCounter: params.userCount
	        }
	      });
	    }
	  }, {
	    key: "handleMessageParamsUpdate",
	    value: function handleMessageParamsUpdate(params, extra) {
	      if (this.skipExecute(params, extra)) {
	        return false;
	      }

	      this.store.dispatch('messages/update', {
	        id: params.id,
	        chatId: params.chatId,
	        fields: {
	          params: params.params
	        }
	      }).then(function () {
	        main_core_events.EventEmitter.emit(im_const.EventType.dialog.scrollToBottom, {
	          chatId: params.chatId,
	          cancelIfScrollChange: true
	        });
	      });
	    }
	  }, {
	    key: "handleStartWriting",
	    value: function handleStartWriting(params, extra) {
	      if (this.skipExecute(params, extra)) {
	        return false;
	      }

	      this.controller.application.startOpponentWriting(params);
	    }
	  }, {
	    key: "handleReadMessage",
	    value: function handleReadMessage(params, extra) {
	      var _this2 = this;

	      if (this.skipExecute(params, extra)) {
	        return false;
	      }

	      this.store.dispatch('messages/readMessages', {
	        chatId: params.chatId,
	        readId: params.lastId
	      }).then(function (result) {
	        _this2.store.dispatch('dialogues/update', {
	          dialogId: params.dialogId,
	          fields: {
	            counter: params.counter
	          }
	        });
	      });
	      this.store.dispatch('recent/update', {
	        id: params.dialogId,
	        fields: {
	          counter: params.counter
	        }
	      });
	    }
	  }, {
	    key: "handleReadMessageChat",
	    value: function handleReadMessageChat(params, extra) {
	      this.handleReadMessage(params, extra);
	    }
	  }, {
	    key: "handleReadMessageOpponent",
	    value: function handleReadMessageOpponent(params, extra) {
	      this.execReadMessageOpponent(params, extra);
	    }
	  }, {
	    key: "handleReadMessageChatOpponent",
	    value: function handleReadMessageChatOpponent(params, extra) {
	      this.execReadMessageOpponent(params, extra);
	    }
	  }, {
	    key: "execReadMessageOpponent",
	    value: function execReadMessageOpponent(params, extra) {
	      if (this.skipExecute(params, extra)) {
	        return false;
	      }

	      this.store.dispatch('dialogues/updateReaded', {
	        dialogId: params.dialogId,
	        userId: params.userId,
	        userName: params.userName,
	        messageId: params.lastId,
	        date: params.date,
	        action: true
	      });
	      var recentItem = this.store.getters['recent/get'](params.dialogId);

	      if (recentItem) {
	        var message = recentItem.element.message;
	        this.store.dispatch('recent/update', {
	          id: params.dialogId,
	          fields: {
	            counter: params.counter,
	            message: _objectSpread(_objectSpread({}, message), {}, {
	              status: 'delivered'
	            })
	          }
	        });
	      }
	    }
	  }, {
	    key: "handleUnreadMessageOpponent",
	    value: function handleUnreadMessageOpponent(params, extra) {
	      this.execUnreadMessageOpponent(params, extra);
	    }
	  }, {
	    key: "handleUnreadMessageChatOpponent",
	    value: function handleUnreadMessageChatOpponent(params, extra) {
	      this.execUnreadMessageOpponent(params, extra);
	    }
	  }, {
	    key: "execUnreadMessageOpponent",
	    value: function execUnreadMessageOpponent(params, extra) {
	      if (this.skipExecute(params, extra)) {
	        return false;
	      }

	      this.store.dispatch('dialogues/updateReaded', {
	        dialogId: params.dialogId,
	        userId: params.userId,
	        action: false
	      });
	    }
	  }, {
	    key: "handleFileUpload",
	    value: function handleFileUpload(params, extra) {
	      if (this.skipExecute(params, extra)) {
	        return false;
	      }

	      this.store.dispatch('files/set', this.controller.application.prepareFilesBeforeSave(ui_vue_vuex.WidgetVuexBuilderModel.convertToArray({
	        file: params.fileParams
	      }))).then(function () {
	        main_core_events.EventEmitter.emit(im_const.EventType.dialog.scrollToBottom, {
	          cancelIfScrollChange: true
	        });
	      });
	    }
	  }, {
	    key: "handleChatPin",
	    value: function handleChatPin(params, extra) {
	      this.store.dispatch('recent/pin', {
	        id: params.dialogId,
	        action: params.active
	      });
	    }
	  }, {
	    key: "handleChatHide",
	    value: function handleChatHide(params, extra) {
	      this.store.dispatch('recent/delete', {
	        id: params.dialogId
	      });
	    }
	  }, {
	    key: "handleChatMuteNotify",
	    value: function handleChatMuteNotify(params, extra) {
	      var existingChat = this.store.getters['dialogues/get'](params.dialogId);

	      if (!existingChat) {
	        return false;
	      }

	      var existingMuteList = existingChat.muteList;
	      var newMuteList = [];
	      var currentUser = this.store.state.application.common.userId;

	      if (params.mute) {
	        newMuteList = [].concat(babelHelpers.toConsumableArray(existingMuteList), [currentUser]);
	      } else {
	        newMuteList = existingMuteList.filter(function (element) {
	          return element !== currentUser;
	        });
	      }

	      this.store.dispatch('dialogues/update', {
	        dialogId: params.dialogId,
	        fields: {
	          muteList: newMuteList
	        }
	      });
	    }
	  }, {
	    key: "handleReadNotifyList",
	    value: function handleReadNotifyList(params, extra) {
	      this.store.dispatch('recent/update', {
	        id: 'notify',
	        fields: {
	          counter: params.counter
	        }
	      });
	    }
	  }, {
	    key: "handleUserInvite",
	    value: function handleUserInvite(params, extra) {
	      if (!params.invited) {
	        this.store.dispatch('users/update', {
	          id: params.userId,
	          fields: params.user
	        });
	      }
	    }
	  }, {
	    key: "prepareRecentItem",
	    value: function prepareRecentItem(params) {
	      var type = 'user';

	      if (params.dialogId.toString().startsWith('chat')) {
	        type = 'chat';
	      }

	      params.dialogId.toString().startsWith('chat');
	      var title = type === 'chat' ? params.chat[params.chatId].name : params.users[params.dialogId].name;
	      var chat = params.chat[params.chatId] ? params.chat[params.chatId] : {};

	      if (!params.users) {
	        params.users = {};
	      }

	      var user = params.users[params.dialogId] ? params.users[params.dialogId] : {};
	      var userId = type === 'user' ? params.dialogId : 0;
	      return {
	        id: params.dialogId,
	        type: type,
	        title: title,
	        counter: params.counter,
	        chatId: params.chatId,
	        chat: chat,
	        user: user,
	        userId: userId,
	        message: {
	          id: params.message.id,
	          text: params.message.textOriginal,
	          date: params.message.date,
	          senderId: params.message.senderId,
	          withFile: typeof params.message.params['FILE_ID'] !== 'undefined',
	          withAttach: typeof params.message.params['ATTACH'] !== 'undefined'
	        }
	      };
	    }
	  }]);
	  return ImBasePullHandler;
	}();

	function ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$1(Object(source), !0).forEach(function (key) { babelHelpers.defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
	var ImCallPullHandler = /*#__PURE__*/function () {
	  babelHelpers.createClass(ImCallPullHandler, null, [{
	    key: "create",
	    value: function create() {
	      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	      return new this(params);
	    }
	  }]);

	  function ImCallPullHandler() {
	    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	    babelHelpers.classCallCheck(this, ImCallPullHandler);

	    if (babelHelpers["typeof"](params.application) === 'object' && params.application) {
	      this.application = params.application;
	    }

	    if (babelHelpers["typeof"](params.controller) === 'object' && params.controller) {
	      this.controller = params.controller;
	    }

	    if (babelHelpers["typeof"](params.store) === 'object' && params.store) {
	      this.store = params.store;
	    }

	    this.option = babelHelpers["typeof"](params.store) === 'object' && params.store ? params.store : {};
	  }

	  babelHelpers.createClass(ImCallPullHandler, [{
	    key: "getModuleId",
	    value: function getModuleId() {
	      return 'im';
	    }
	  }, {
	    key: "getSubscriptionType",
	    value: function getSubscriptionType() {
	      return pull_client.PullClient.SubscriptionType.Server;
	    }
	  }, {
	    key: "handleChatUserAdd",
	    value: function handleChatUserAdd(params) {
	      if (params.dialogId !== this.store.state.application.dialog.dialogId) {
	        return false;
	      }

	      var users = Object.values(params.users).map(function (user) {
	        return _objectSpread$1(_objectSpread$1({}, user), {}, {
	          lastActivityDate: new Date()
	        });
	      });
	      this.store.commit('conference/common', {
	        userCount: params.userCount
	      });
	      this.store.dispatch('users/set', users);
	      this.store.dispatch('conference/setUsers', {
	        users: users.map(function (user) {
	          return user.id;
	        })
	      });
	    }
	  }, {
	    key: "handleChatUserLeave",
	    value: function handleChatUserLeave(params) {
	      if (params.dialogId !== this.store.state.application.dialog.dialogId) {
	        return false;
	      }

	      if (params.userId === this.controller.getUserId()) {
	        this.application.kickFromCall();
	      }

	      this.store.commit('conference/common', {
	        userCount: params.userCount
	      });
	      this.store.dispatch('conference/removeUsers', {
	        users: [params.userId]
	      });
	    }
	  }, {
	    key: "handleCallUserNameUpdate",
	    value: function handleCallUserNameUpdate(params) {
	      var currentUser = this.store.getters['users/get'](params.userId);

	      if (!currentUser) {
	        this.store.dispatch('users/set', {
	          id: params.userId,
	          lastActivityDate: new Date()
	        });
	      }

	      this.store.dispatch('users/update', {
	        id: params.userId,
	        fields: {
	          name: params.name,
	          lastActivityDate: new Date()
	        }
	      });
	    }
	  }, {
	    key: "handleVideoconfShareUpdate",
	    value: function handleVideoconfShareUpdate(params) {
	      if (params.dialogId === this.store.state.application.dialog.dialogId) {
	        this.store.dispatch('dialogues/update', {
	          dialogId: params.dialogId,
	          fields: {
	            "public": {
	              code: params.newCode,
	              link: params.newLink
	            }
	          }
	        });
	        this.application.changeVideoconfUrl(params.newLink);
	      }
	    }
	  }, {
	    key: "handleMessageChat",
	    value: function handleMessageChat(params) {
	      this.application.sendNewMessageNotify(params);
	    }
	  }, {
	    key: "handleChatRename",
	    value: function handleChatRename(params) {
	      if (params.chatId !== this.application.getChatId()) {
	        return false;
	      }

	      this.store.dispatch('conference/setConferenceTitle', {
	        conferenceTitle: params.name
	      });
	    }
	  }, {
	    key: "handleConferenceUpdate",
	    value: function handleConferenceUpdate(params) {
	      if (params.chatId !== this.application.getChatId()) {
	        return false;
	      }

	      if (params.isBroadcast !== '') {
	        this.store.dispatch('conference/setBroadcastMode', {
	          broadcastMode: params.isBroadcast
	        });
	      }

	      if (params.presenters.length > 0) {
	        this.store.dispatch('conference/setPresenters', {
	          presenters: params.presenters,
	          replace: true
	        });
	      }
	    }
	  }]);
	  return ImCallPullHandler;
	}();

	function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

	function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

	function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
	var ImNotificationsPullHandler = /*#__PURE__*/function () {
	  babelHelpers.createClass(ImNotificationsPullHandler, null, [{
	    key: "create",
	    value: function create() {
	      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	      return new this(params);
	    }
	  }]);

	  function ImNotificationsPullHandler() {
	    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	    babelHelpers.classCallCheck(this, ImNotificationsPullHandler);

	    if (babelHelpers["typeof"](params.application) === 'object' && params.application) {
	      this.application = params.application;
	    }

	    if (babelHelpers["typeof"](params.controller) === 'object' && params.controller) {
	      this.controller = params.controller;
	    }

	    if (babelHelpers["typeof"](params.store) === 'object' && params.store) {
	      this.store = params.store;
	    }

	    this.option = babelHelpers["typeof"](params.store) === 'object' && params.store ? params.store : {};
	  }

	  babelHelpers.createClass(ImNotificationsPullHandler, [{
	    key: "getModuleId",
	    value: function getModuleId() {
	      return 'im';
	    }
	  }, {
	    key: "getSubscriptionType",
	    value: function getSubscriptionType() {
	      return pull_client.PullClient.SubscriptionType.Server;
	    }
	  }, {
	    key: "handleNotifyAdd",
	    value: function handleNotifyAdd(params, extra) {
	      if (extra.server_time_ago > 30 || params.onlyFlash === true) {
	        return false;
	      }

	      var user = this.store.getters['users/get'](params.userId);

	      if (!user) {
	        var users = [];
	        users.push({
	          id: params.userId,
	          avatar: params.userAvatar,
	          color: params.userColor,
	          name: params.userName
	        });
	        this.store.dispatch('users/set', users);
	      }

	      this.store.dispatch('notifications/add', {
	        data: params
	      });
	      this.store.dispatch('notifications/setCounter', {
	        unreadTotal: params.counter
	      });
	      this.store.dispatch('recent/update', {
	        id: "notify",
	        fields: {
	          message: {
	            id: params.id,
	            text: params.text,
	            date: params.date
	          },
	          counter: params.counter
	        }
	      });
	    }
	  }, {
	    key: "handleNotifyConfirm",
	    value: function handleNotifyConfirm(params, extra) {
	      if (extra.server_time_ago > 30) {
	        return false;
	      }

	      this.store.dispatch('notifications/delete', {
	        id: params.id
	      });
	      this.store.dispatch('notifications/setCounter', {
	        unreadTotal: params.counter
	      });
	      this.updateRecentListOnDelete(params.counter);
	    }
	  }, {
	    key: "handleNotifyRead",
	    value: function handleNotifyRead(params, extra) {
	      var _this = this;

	      if (extra.server_time_ago > 30) {
	        return false;
	      }

	      params.list.forEach(function (id) {
	        _this.store.dispatch('notifications/read', {
	          ids: [id],
	          action: true
	        });
	      });
	      this.store.dispatch('notifications/setCounter', {
	        unreadTotal: params.counter
	      });
	      this.store.dispatch('recent/update', {
	        id: "notify",
	        fields: {
	          counter: params.counter
	        }
	      });
	    }
	  }, {
	    key: "handleNotifyUnread",
	    value: function handleNotifyUnread(params, extra) {
	      var _this2 = this;

	      if (extra.server_time_ago > 30) {
	        return false;
	      }

	      params.list.forEach(function (id) {
	        _this2.store.dispatch('notifications/read', {
	          ids: [id],
	          action: false
	        });
	      });
	      this.store.dispatch('notifications/setCounter', {
	        unreadTotal: params.counter
	      });
	      this.store.dispatch('recent/update', {
	        id: "notify",
	        fields: {
	          counter: params.counter
	        }
	      });
	    }
	  }, {
	    key: "handleNotifyDelete",
	    value: function handleNotifyDelete(params, extra) {
	      var _this3 = this;

	      if (extra.server_time_ago > 30) {
	        return false;
	      }

	      var idsToDelete = Object.keys(params.id).map(function (id) {
	        return parseInt(id, 10);
	      });
	      idsToDelete.forEach(function (id) {
	        _this3.store.dispatch('notifications/delete', {
	          id: id
	        });
	      });
	      this.updateRecentListOnDelete(params.counter);
	      this.store.dispatch('notifications/setCounter', {
	        unreadTotal: params.counter
	      });
	    }
	  }, {
	    key: "updateRecentListOnDelete",
	    value: function updateRecentListOnDelete(counterValue) {
	      var message;
	      var latestNotification = this.getLatest();

	      if (latestNotification !== null) {
	        message = {
	          id: latestNotification.id,
	          text: latestNotification.text,
	          date: latestNotification.date
	        };
	      } else {
	        var notificationChat = this.store.getters['recent/get']('notify');

	        if (notificationChat === false) {
	          return;
	        }

	        message = notificationChat.element.message;
	        message.text = this.controller.localize['IM_NOTIFICATIONS_DELETED_ITEM_STUB'];
	      }

	      this.store.dispatch('recent/update', {
	        id: "notify",
	        fields: {
	          message: message,
	          counter: counterValue
	        }
	      });
	    }
	  }, {
	    key: "getLatest",
	    value: function getLatest() {
	      var latestNotification = {
	        id: 0
	      };

	      var _iterator = _createForOfIteratorHelper(this.store.state.notifications.collection),
	          _step;

	      try {
	        for (_iterator.s(); !(_step = _iterator.n()).done;) {
	          var notification = _step.value;

	          if (notification.id > latestNotification.id) {
	            latestNotification = notification;
	          }
	        }
	      } catch (err) {
	        _iterator.e(err);
	      } finally {
	        _iterator.f();
	      }

	      if (latestNotification.id === 0) {
	        return null;
	      }

	      return latestNotification;
	    }
	  }]);
	  return ImNotificationsPullHandler;
	}();

	/**
	 * Bitrix Messenger
	 * Bundle pull command handlers
	 *
	 * @package bitrix
	 * @subpackage im
	 * @copyright 2001-2019 Bitrix
	 */

	exports.ImBasePullHandler = ImBasePullHandler;
	exports.ImCallPullHandler = ImCallPullHandler;
	exports.ImNotificationsPullHandler = ImNotificationsPullHandler;

}((this.BX.Messenger.Provider.Pull = this.BX.Messenger.Provider.Pull || {}),BX,BX.Messenger.Const,BX.Messenger.Lib,BX.Event,BX));
 




// file: /bitrix/js/im/controller/dist/controller.bundle.js
this.BX = this.BX || {};
(function (exports,pull_client,rest_client,ui_vue_vuex,im_model,im_provider_pull,im_provider_rest,im_lib_timer,im_const,im_lib_utils,ui_vue,im_lib_logger) {
	'use strict';

	/**
	 * Bitrix Messenger
	 * Application controller
	 *
	 * @package bitrix
	 * @subpackage im
	 * @copyright 2001-2020 Bitrix
	 */
	var ApplicationController = /*#__PURE__*/function () {
	  function ApplicationController() {
	    babelHelpers.classCallCheck(this, ApplicationController);
	    this.controller = null;
	    this.timer = new im_lib_timer.Timer();

	    this._prepareFilesBeforeSave = function (params) {
	      return params;
	    };

	    this.defaultMessageLimit = 50;
	    this.requestMessageLimit = this.getDefaultMessageLimit();
	    this.messageLastReadId = {};
	    this.messageReadQueue = {};
	  }

	  babelHelpers.createClass(ApplicationController, [{
	    key: "setCoreController",
	    value: function setCoreController(controller) {
	      this.controller = controller;
	    }
	  }, {
	    key: "getSiteId",
	    value: function getSiteId() {
	      return this.controller.getStore().state.application.common.siteId;
	    }
	  }, {
	    key: "getUserId",
	    value: function getUserId() {
	      return this.controller.getStore().state.application.common.userId;
	    }
	  }, {
	    key: "getLanguageId",
	    value: function getLanguageId() {
	      return this.controller.getStore().state.application.common.languageId;
	    }
	  }, {
	    key: "getCurrentUser",
	    value: function getCurrentUser() {
	      return this.controller.getStore().getters['users/get'](this.controller.getStore().state.application.common.userId, true);
	    }
	  }, {
	    key: "getChatId",
	    value: function getChatId() {
	      return this.controller.getStore().state.application.dialog.chatId;
	    }
	  }, {
	    key: "getDialogId",
	    value: function getDialogId() {
	      return this.controller.getStore().state.application.dialog.dialogId;
	    }
	  }, {
	    key: "getData",
	    value: function getData() {
	      return this.controller.getStore().state.application;
	    }
	  }, {
	    key: "getDialogData",
	    value: function getDialogData() {
	      var dialogId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getDialogId();

	      if (this.controller.getStore().state.dialogues.collection[dialogId]) {
	        return this.controller.getStore().state.dialogues.collection[dialogId];
	      }

	      return this.controller.getStore().getters['dialogues/getBlank']();
	    }
	  }, {
	    key: "getDialogCrmData",
	    value: function getDialogCrmData() {
	      var dialogId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getDialogId();
	      var result = {
	        enabled: false,
	        entityType: im_const.DialogCrmType.none,
	        entityId: 0
	      };
	      var dialogData = this.getDialogData(dialogId);

	      if (dialogData.type === im_const.DialogType.call) {
	        if (dialogData.entityData1 && typeof dialogData.entityData1 === 'string') {
	          var _dialogData$entityDat = dialogData.entityData1.split('|'),
	              _dialogData$entityDat2 = babelHelpers.slicedToArray(_dialogData$entityDat, 3),
	              enabled = _dialogData$entityDat2[0],
	              entityType = _dialogData$entityDat2[1],
	              entityId = _dialogData$entityDat2[2];

	          if (enabled) {
	            entityType = entityType ? entityType.toString().toLowerCase() : im_const.DialogCrmType.none;
	            result = {
	              enabled: enabled,
	              entityType: entityType,
	              entityId: entityId
	            };
	          }
	        }
	      } else if (dialogData.type === im_const.DialogType.crm) {
	        var _dialogData$entityId$ = dialogData.entityId.split('|'),
	            _dialogData$entityId$2 = babelHelpers.slicedToArray(_dialogData$entityId$, 2),
	            _entityType = _dialogData$entityId$2[0],
	            _entityId = _dialogData$entityId$2[1];

	        _entityType = _entityType ? _entityType.toString().toLowerCase() : im_const.DialogCrmType.none;
	        result = {
	          enabled: true,
	          entityType: _entityType,
	          entityId: _entityId
	        };
	      }

	      return result;
	    }
	  }, {
	    key: "getDialogIdByChatId",
	    value: function getDialogIdByChatId(chatId) {
	      if (this.getDialogId() === 'chat' + chatId) {
	        return this.getDialogId();
	      }

	      var dialog = this.controller.getStore().getters['dialogues/getByChatId'](chatId);

	      if (!dialog) {
	        return 0;
	      }

	      return dialog.dialogId;
	    }
	  }, {
	    key: "getDiskFolderId",
	    value: function getDiskFolderId() {
	      return this.controller.getStore().state.application.dialog.diskFolderId;
	    }
	  }, {
	    key: "getDefaultMessageLimit",
	    value: function getDefaultMessageLimit() {
	      return this.defaultMessageLimit;
	    }
	  }, {
	    key: "getRequestMessageLimit",
	    value: function getRequestMessageLimit() {
	      return this.requestMessageLimit;
	    }
	  }, {
	    key: "muteDialog",
	    value: function muteDialog() {
	      var _this = this;

	      var action = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
	      var dialogId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.getDialogId();

	      if (im_lib_utils.Utils.dialog.isEmptyDialogId(dialogId)) {
	        return false;
	      }

	      if (action === null) {
	        action = !this.isDialogMuted();
	      }

	      this.timer.start('muteDialog', dialogId, .3, function (id) {
	        _this.controller.restClient.callMethod(im_const.RestMethod.imChatMute, {
	          'DIALOG_ID': dialogId,
	          'ACTION': action ? 'Y' : 'N'
	        });
	      });
	      var muteList = [];

	      if (action) {
	        muteList = this.getDialogData().muteList;
	        muteList.push(this.getUserId());
	      } else {
	        muteList = this.getDialogData().muteList.filter(function (userId) {
	          return userId !== _this.getUserId();
	        });
	      }

	      this.controller.getStore().dispatch('dialogues/update', {
	        dialogId: dialogId,
	        fields: {
	          muteList: muteList
	        }
	      });
	      return true;
	    }
	  }, {
	    key: "isDialogMuted",
	    value: function isDialogMuted() {
	      var dialogId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getDialogId();
	      return this.getDialogData().muteList.includes(this.getUserId());
	    }
	  }, {
	    key: "isUnreadMessagesLoaded",
	    value: function isUnreadMessagesLoaded() {
	      var dialog = this.controller.getStore().state.dialogues.collection[this.getDialogId()];

	      if (!dialog) {
	        return true;
	      }

	      if (dialog.lastMessageId <= 0) {
	        return true;
	      }

	      var collection = this.controller.getStore().state.messages.collection[this.getChatId()];

	      if (!collection || collection.length <= 0) {
	        return true;
	      }

	      var lastElementId = 0;

	      for (var index = collection.length - 1; index >= 0; index--) {
	        var lastElement = collection[index];

	        if (typeof lastElement.id === "number") {
	          lastElementId = lastElement.id;
	          break;
	        }
	      }

	      return lastElementId >= dialog.lastMessageId;
	    }
	  }, {
	    key: "prepareFilesBeforeSave",
	    value: function prepareFilesBeforeSave(files) {
	      return this._prepareFilesBeforeSave(files);
	    }
	  }, {
	    key: "setPrepareFilesBeforeSaveFunction",
	    value: function setPrepareFilesBeforeSaveFunction(func) {
	      this._prepareFilesBeforeSave = func.bind(this);
	    }
	  }, {
	    key: "showSmiles",
	    value: function showSmiles() {
	      this.store.dispatch('application/showSmiles');
	    }
	  }, {
	    key: "hideSmiles",
	    value: function hideSmiles() {
	      this.store.dispatch('application/hideSmiles');
	    }
	  }, {
	    key: "startOpponentWriting",
	    value: function startOpponentWriting(params) {
	      var _this2 = this;

	      var dialogId = params.dialogId,
	          userId = params.userId,
	          userName = params.userName;
	      this.controller.getStore().dispatch('dialogues/updateWriting', {
	        dialogId: dialogId,
	        userId: userId,
	        userName: userName,
	        action: true
	      });
	      this.timer.start('writingEnd', dialogId + '|' + userId, 35, function (id, params) {
	        var dialogId = params.dialogId,
	            userId = params.userId;

	        _this2.controller.getStore().dispatch('dialogues/updateWriting', {
	          dialogId: dialogId,
	          userId: userId,
	          action: false
	        });
	      }, {
	        dialogId: dialogId,
	        userId: userId
	      });
	      return true;
	    }
	  }, {
	    key: "stopOpponentWriting",
	    value: function stopOpponentWriting() {
	      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	      var dialogId = params.dialogId,
	          userId = params.userId,
	          userName = params.userName;
	      this.timer.stop('writingStart', dialogId + '|' + userId, true);
	      this.timer.stop('writingEnd', dialogId + '|' + userId);
	      return true;
	    }
	  }, {
	    key: "startWriting",
	    value: function startWriting() {
	      var _this3 = this;

	      var dialogId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getDialogId();

	      if (im_lib_utils.Utils.dialog.isEmptyDialogId(dialogId) || this.timer.has('writes', dialogId)) {
	        return false;
	      }

	      this.timer.start('writes', dialogId, 28);
	      this.timer.start('writesSend', dialogId, 5, function (id) {
	        _this3.controller.restClient.callMethod(im_const.RestMethod.imDialogWriting, {
	          'DIALOG_ID': dialogId
	        })["catch"](function () {
	          _this3.timer.stop('writes', dialogId);
	        });
	      });
	    }
	  }, {
	    key: "stopWriting",
	    value: function stopWriting() {
	      var dialogId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getDialogId();
	      this.timer.stop('writes', dialogId, true);
	      this.timer.stop('writesSend', dialogId, true);
	    }
	  }, {
	    key: "joinParentChat",
	    value: function joinParentChat(messageId, dialogId) {
	      var _this4 = this;

	      return new Promise(function (resolve, reject) {
	        if (!messageId || !dialogId) {
	          return reject();
	        }

	        if (typeof _this4.tempJoinChat === 'undefined') {
	          _this4.tempJoinChat = {};
	        } else if (_this4.tempJoinChat['wait']) {
	          return reject();
	        }

	        _this4.tempJoinChat['wait'] = true;

	        _this4.controller.restClient.callMethod(im_const.RestMethod.imChatParentJoin, {
	          'DIALOG_ID': dialogId,
	          'MESSAGE_ID': messageId
	        }).then(function () {
	          _this4.tempJoinChat['wait'] = false;
	          _this4.tempJoinChat[dialogId] = true;
	          return resolve(dialogId);
	        })["catch"](function () {
	          _this4.tempJoinChat['wait'] = false;
	          return reject();
	        });
	      });
	    }
	  }, {
	    key: "setTextareaMessage",
	    value: function setTextareaMessage(params) {
	      var _params$message = params.message,
	          message = _params$message === void 0 ? '' : _params$message,
	          _params$dialogId = params.dialogId,
	          dialogId = _params$dialogId === void 0 ? this.getDialogId() : _params$dialogId;
	      this.controller.getStore().dispatch('dialogues/update', {
	        dialogId: dialogId,
	        fields: {
	          textareaMessage: message
	        }
	      });
	    }
	  }, {
	    key: "setSendingMessageFlag",
	    value: function setSendingMessageFlag(messageId) {
	      this.controller.getStore().dispatch('messages/actionStart', {
	        id: messageId,
	        chatId: this.getChatId()
	      });
	    }
	  }, {
	    key: "reactMessage",
	    value: function reactMessage(messageId) {
	      var action = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'auto';
	      this.controller.restClient.callMethod(im_const.RestMethod.imMessageLike, {
	        'MESSAGE_ID': messageId,
	        'ACTION': action === 'auto' ? 'auto' : action === 'set' ? 'plus' : 'minus'
	      });
	    }
	  }, {
	    key: "readMessage",
	    value: function readMessage() {
	      var _this5 = this;

	      var messageId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
	      var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
	      var skipAjax = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
	      var chatId = this.getChatId();

	      if (typeof this.messageLastReadId[chatId] === 'undefined') {
	        this.messageLastReadId[chatId] = null;
	      }

	      if (typeof this.messageReadQueue[chatId] === 'undefined') {
	        this.messageReadQueue[chatId] = [];
	      }

	      if (messageId) {
	        this.messageReadQueue[chatId].push(parseInt(messageId));
	      }

	      this.timer.stop('readMessage', chatId, true);
	      this.timer.stop('readMessageServer', chatId, true);

	      if (force) {
	        return this.readMessageExecute(chatId, skipAjax);
	      }

	      return new Promise(function (resolve, reject) {
	        _this5.timer.start('readMessage', chatId, .1, function (chatId, params) {
	          return _this5.readMessageExecute(chatId, skipAjax).then(function (result) {
	            return resolve(result);
	          });
	        });
	      });
	    }
	  }, {
	    key: "readMessageExecute",
	    value: function readMessageExecute(chatId) {
	      var _this6 = this;

	      var skipAjax = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
	      return new Promise(function (resolve, reject) {
	        if (_this6.messageReadQueue[chatId]) {
	          _this6.messageReadQueue[chatId] = _this6.messageReadQueue[chatId].filter(function (elementId) {
	            if (!_this6.messageLastReadId[chatId]) {
	              _this6.messageLastReadId[chatId] = elementId;
	            } else if (_this6.messageLastReadId[chatId] < elementId) {
	              _this6.messageLastReadId[chatId] = elementId;
	            }
	          });
	        }

	        var dialogId = _this6.getDialogIdByChatId(chatId);

	        var lastId = _this6.messageLastReadId[chatId] || 0;

	        if (lastId <= 0) {
	          resolve({
	            dialogId: dialogId,
	            lastId: 0
	          });
	          return true;
	        }

	        _this6.controller.getStore().dispatch('messages/readMessages', {
	          chatId: chatId,
	          readId: lastId
	        }).then(function (result) {
	          _this6.controller.getStore().dispatch('dialogues/decreaseCounter', {
	            dialogId: dialogId,
	            count: result.count
	          });

	          if (_this6.getChatId() === chatId && _this6.controller.getStore().getters['dialogues/canSaveChat']) {
	            var dialog = _this6.controller.getStore().getters['dialogues/get'](dialogId);

	            if (dialog.counter <= 0) {
	              _this6.controller.getStore().commit('application/clearDialogExtraCount');
	            }
	          }

	          if (skipAjax) {
	            resolve({
	              dialogId: dialogId,
	              lastId: lastId
	            });
	          } else {
	            _this6.timer.start('readMessageServer', chatId, .5, function () {
	              _this6.controller.restClient.callMethod(im_const.RestMethod.imDialogRead, {
	                'DIALOG_ID': dialogId,
	                'MESSAGE_ID': lastId
	              }).then(function () {
	                return resolve({
	                  dialogId: dialogId,
	                  lastId: lastId
	                });
	              })["catch"](function () {
	                return resolve({
	                  dialogId: dialogId,
	                  lastId: lastId
	                });
	              });
	            });
	          }
	        })["catch"](function () {
	          resolve();
	        });
	      });
	    }
	  }, {
	    key: "unreadMessage",
	    value: function unreadMessage() {
	      var _this7 = this;

	      var messageId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
	      var skipAjax = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
	      var chatId = this.getChatId();

	      if (typeof this.messageLastReadId[chatId] === 'undefined') {
	        this.messageLastReadId[chatId] = null;
	      }

	      if (typeof this.messageReadQueue[chatId] === 'undefined') {
	        this.messageReadQueue[chatId] = [];
	      }

	      if (messageId) {
	        this.messageReadQueue[chatId] = this.messageReadQueue[chatId].filter(function (id) {
	          return id < messageId;
	        });
	      }

	      this.timer.stop('readMessage', chatId, true);
	      this.timer.stop('readMessageServer', chatId, true);
	      this.messageLastReadId[chatId] = messageId;
	      this.controller.getStore().dispatch('messages/unreadMessages', {
	        chatId: chatId,
	        unreadId: this.messageLastReadId[chatId]
	      }).then(function (result) {
	        var dialogId = _this7.getDialogIdByChatId(chatId);

	        _this7.controller.getStore().dispatch('dialogues/update', {
	          dialogId: dialogId,
	          fields: {
	            unreadId: messageId
	          }
	        });

	        _this7.controller.getStore().dispatch('dialogues/increaseCounter', {
	          dialogId: dialogId,
	          count: result.count
	        });

	        if (!skipAjax) {
	          _this7.controller.restClient.callMethod(im_const.RestMethod.imDialogUnread, {
	            'DIALOG_ID': dialogId,
	            'MESSAGE_ID': _this7.messageLastReadId[chatId]
	          });
	        }
	      })["catch"](function () {});
	    }
	  }, {
	    key: "shareMessage",
	    value: function shareMessage(messageId, type) {
	      this.controller.restClient.callMethod(im_const.RestMethod.imMessageShare, {
	        'DIALOG_ID': this.getDialogId(),
	        'MESSAGE_ID': messageId,
	        'TYPE': type
	      });
	      return true;
	    }
	  }, {
	    key: "replyToUser",
	    value: function replyToUser(userId, user) {
	      return true;
	    }
	  }, {
	    key: "openMessageReactionList",
	    value: function openMessageReactionList(messageId, values) {
	      return true;
	    }
	  }, {
	    key: "emit",
	    value: function emit(eventName) {
	      var _Vue$event;

	      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	        args[_key - 1] = arguments[_key];
	      }

	      (_Vue$event = ui_vue.WidgetVue.event).$emit.apply(_Vue$event, [eventName].concat(args));
	    }
	  }, {
	    key: "listen",
	    value: function listen(event, callback) {
	      ui_vue.WidgetVue.event.$on(event, callback);
	    }
	  }]);
	  return ApplicationController;
	}();

	function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { babelHelpers.defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
	var Controller = /*#__PURE__*/function () {
	  /* region 01. Initialize and store data */
	  function Controller() {
	    var _this = this;

	    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	    babelHelpers.classCallCheck(this, Controller);
	    this.inited = false;
	    this.initPromise = new Promise(function (resolve, reject) {
	      _this.initPromiseResolver = resolve;
	    });
	    this.offline = false;
	    this.restAnswerHandler = [];
	    this.vuexAdditionalModel = [];
	    this.store = null;
	    this.storeBuilder = null;
	    this.init().then(function () {
	      return _this.prepareParams(params);
	    }).then(function () {
	      return _this.initController();
	    }).then(function () {
	      return _this.initLocalStorage();
	    }).then(function () {
	      return _this.initStorage();
	    }).then(function () {
	      return _this.initRestClient();
	    }).then(function () {
	      return _this.initPullClient();
	    }).then(function () {
	      return _this.initEnvironment();
	    }).then(function () {
	      return _this.initComplete();
	    })["catch"](function (error) {
	      im_lib_logger.Logger.error('error initializing core controller', error);
	    });
	  }

	  babelHelpers.createClass(Controller, [{
	    key: "init",
	    value: function init() {
	      return Promise.resolve();
	    }
	  }, {
	    key: "prepareParams",
	    value: function prepareParams(params) {
	      var _this2 = this;

	      if (typeof params.localize !== 'undefined') {
	        this.localize = params.localize;
	      } else {
	        if (typeof BX !== 'undefined') {
	          this.localize = _objectSpread({}, BX.message);
	        } else {
	          this.localize = {};
	        }
	      }

	      if (typeof params.host !== 'undefined') {
	        this.host = params.host;
	      } else {
	        this.host = location.origin;
	      }

	      if (typeof params.userId !== 'undefined') {
	        var parsedUserId = parseInt(params.userId);

	        if (!isNaN(parsedUserId)) {
	          this.userId = parsedUserId;
	        } else {
	          this.userId = 0;
	        }
	      } else {
	        var userId = this.getLocalize('USER_ID');
	        this.userId = userId ? parseInt(userId) : 0;
	      }

	      if (typeof params.siteId !== 'undefined') {
	        if (typeof params.siteId === 'string' && params.siteId !== '') {
	          this.siteId = params.siteId;
	        } else {
	          this.siteId = 's1';
	        }
	      } else {
	        this.siteId = this.getLocalize('SITE_ID') || 's1';
	      }

	      if (typeof params.siteDir !== 'undefined') {
	        if (typeof params.siteDir === 'string' && params.siteDir !== '') {
	          this.siteDir = params.siteDir;
	        } else {
	          this.siteDir = 's1';
	        }
	      } else {
	        this.siteDir = this.getLocalize('SITE_DIR') || 's1';
	      }

	      if (typeof params.languageId !== 'undefined') {
	        if (typeof params.languageId === 'string' && params.languageId !== '') {
	          this.languageId = params.languageId;
	        } else {
	          this.languageId = 'en';
	        }
	      } else {
	        this.languageId = this.getLocalize('LANGUAGE_ID') || 'en';
	      }

	      this.pullInstance = pull_client.PullClient;
	      this.pullClient = pull_client.PULL;

	      if (typeof params.pull !== 'undefined') {
	        if (typeof params.pull.instance !== 'undefined') {
	          this.pullInstance = params.pull.instance;
	        }

	        if (typeof params.pull.client !== 'undefined') {
	          this.pullClient = params.pull.client;
	        }
	      }

	      this.restInstance = rest_client.RestClient;
	      this.restClient = rest_client.rest;

	      if (typeof params.rest !== 'undefined') {
	        if (typeof params.rest.instance !== 'undefined') {
	          this.restInstance = params.rest.instance;
	        }

	        if (typeof params.rest.client !== 'undefined') {
	          this.restClient = params.rest.client;
	        }
	      }

	      this.vuexBuilder = {
	        database: false,
	        databaseName: 'desktop/im',
	        databaseType: ui_vue_vuex.WidgetVuexBuilder.DatabaseType.indexedDb
	      };

	      if (typeof params.vuexBuilder !== 'undefined') {
	        if (typeof params.vuexBuilder.database !== 'undefined') {
	          this.vuexBuilder.database = params.vuexBuilder.database;
	        }

	        if (typeof params.vuexBuilder.databaseName !== 'undefined') {
	          this.vuexBuilder.databaseName = params.vuexBuilder.databaseName;
	        }

	        if (typeof params.vuexBuilder.databaseType !== 'undefined') {
	          this.vuexBuilder.databaseType = params.vuexBuilder.databaseType;
	        }

	        if (typeof params.vuexBuilder.models !== 'undefined') {
	          params.vuexBuilder.models.forEach(function (model) {
	            _this2.addVuexModel(model);
	          });
	        }
	      }

	      return Promise.resolve();
	    }
	  }, {
	    key: "initController",
	    value: function initController() {
	      this.application = new ApplicationController();
	      this.application.setCoreController(this);
	      return new Promise(function (resolve, reject) {
	        return resolve();
	      });
	    }
	  }, {
	    key: "initLocalStorage",
	    value: function initLocalStorage() {
	      return new Promise(function (resolve, reject) {
	        return resolve();
	      });
	    }
	  }, {
	    key: "initStorage",
	    value: function initStorage() {
	      var _this3 = this;

	      var applicationVariables = {
	        common: {
	          host: this.getHost(),
	          userId: this.getUserId(),
	          siteId: this.getSiteId(),
	          languageId: this.getLanguageId()
	        },
	        dialog: {
	          messageLimit: this.application.getDefaultMessageLimit(),
	          enableReadMessages: true
	        },
	        device: {
	          type: im_lib_utils.Utils.device.isMobile() ? im_const.DeviceType.mobile : im_const.DeviceType.desktop,
	          orientation: im_lib_utils.Utils.device.getOrientation()
	        }
	      };
	      var builder = new ui_vue_vuex.WidgetVuexBuilder().addModel(im_model.ApplicationModel.create().useDatabase(false).setVariables(applicationVariables)).addModel(im_model.MessagesModel.create().useDatabase(this.vuexBuilder.database).setVariables({
	        host: this.getHost()
	      })).addModel(im_model.DialoguesModel.create().useDatabase(this.vuexBuilder.database).setVariables({
	        host: this.getHost()
	      })).addModel(im_model.FilesModel.create().useDatabase(this.vuexBuilder.database).setVariables({
	        host: this.getHost(),
	        "default": {
	          name: 'File is deleted'
	        }
	      })).addModel(im_model.UsersModel.create().useDatabase(this.vuexBuilder.database).setVariables({
	        host: this.getHost(),
	        "default": {
	          name: 'Anonymous'
	        }
	      })).addModel(im_model.RecentModel.create().useDatabase(false).setVariables({
	        host: this.getHost()
	      })).addModel(im_model.NotificationsModel.create().useDatabase(false).setVariables({
	        host: this.getHost()
	      }));
	      this.vuexAdditionalModel.forEach(function (model) {
	        builder.addModel(model);
	      });
	      builder.setDatabaseConfig({
	        name: this.vuexBuilder.databaseName,
	        type: this.vuexBuilder.databaseType,
	        siteId: this.getSiteId(),
	        userId: this.getUserId()
	      });
	      return builder.build().then(function (result) {
	        _this3.store = result.store;
	        _this3.storeBuilder = result.builder;
	        return new Promise(function (resolve, reject) {
	          return resolve();
	        });
	      });
	    }
	  }, {
	    key: "initRestClient",
	    value: function initRestClient(result) {
	      this.addRestAnswerHandler(im_provider_rest.CoreRestHandler.create({
	        store: this.store,
	        controller: this
	      }));
	      return new Promise(function (resolve, reject) {
	        return resolve();
	      });
	    }
	  }, {
	    key: "initPullClient",
	    value: function initPullClient() {
	      if (!this.pullClient) {
	        return false;
	      }

	      this.pullClient.subscribe(this.pullBaseHandler = new im_provider_pull.ImBasePullHandler({
	        store: this.store,
	        controller: this
	      }));
	      this.pullClient.subscribe({
	        type: this.pullInstance.SubscriptionType.Status,
	        callback: this.eventStatusInteraction.bind(this)
	      });
	      this.pullClient.subscribe({
	        type: this.pullInstance.SubscriptionType.Online,
	        callback: this.eventOnlineInteraction.bind(this)
	      });
	      return new Promise(function (resolve, reject) {
	        return resolve();
	      });
	    }
	  }, {
	    key: "initEnvironment",
	    value: function initEnvironment(result) {
	      var _this4 = this;

	      window.addEventListener('orientationchange', function () {
	        if (!_this4.store) {
	          return;
	        }

	        _this4.store.commit('application/set', {
	          device: {
	            orientation: im_lib_utils.Utils.device.getOrientation()
	          }
	        });

	        if (_this4.store.state.application.device.type === im_const.DeviceType.mobile && _this4.store.state.application.device.orientation === im_const.DeviceOrientation.horizontal) {
	          document.activeElement.blur();
	        }
	      });
	      return new Promise(function (resolve, reject) {
	        return resolve();
	      });
	    }
	  }, {
	    key: "initComplete",
	    value: function initComplete() {
	      this.inited = true;
	      this.initPromiseResolver(this);
	    }
	    /* endregion 01. Initialize and store data */

	    /* region 02. Push & Pull */

	  }, {
	    key: "eventStatusInteraction",
	    value: function eventStatusInteraction(data) {
	      if (data.status === this.pullInstance.PullStatus.Online) {
	        this.offline = false; //this.pullBaseHandler.option.skip = true;
	        // this.getDialogUnread().then(() => {
	        // 	this.pullBaseHandler.option.skip = false;
	        // 	this.processSendMessages();
	        // 	this.emit(EventType.dialog.sendReadMessages);
	        // }).catch(() => {
	        // 	this.pullBaseHandler.option.skip = false;
	        // 	this.processSendMessages();
	        // });
	      } else if (data.status === this.pullInstance.PullStatus.Offline) {
	        this.offline = true;
	      }
	    }
	  }, {
	    key: "eventOnlineInteraction",
	    value: function eventOnlineInteraction(data) {
	      if (data.command === 'list' || data.command === 'userStatus') {
	        for (var userId in data.params.users) {
	          if (!data.params.users.hasOwnProperty(userId)) {
	            continue;
	          }

	          this.store.dispatch('users/update', {
	            id: data.params.users[userId].id,
	            fields: data.params.users[userId]
	          });
	        }
	      }
	    }
	    /* endregion 02. Push & Pull */

	    /* region 03. Rest */

	  }, {
	    key: "executeRestAnswer",
	    value: function executeRestAnswer(command, result, extra) {
	      im_lib_logger.Logger.warn('Core.controller.executeRestAnswer', command, result, extra);
	      this.restAnswerHandler.forEach(function (handler) {
	        handler.execute(command, result, extra);
	      });
	    }
	    /* endregion 03. Rest */

	    /* region 04. Template engine */

	  }, {
	    key: "createVue",
	    value: function createVue(application) {
	      var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	      var controller = this;

	      var beforeCreateFunction = function beforeCreateFunction() {};

	      if (config.beforeCreate) {
	        beforeCreateFunction = config.beforeCreate;
	      }

	      var destroyedFunction = function destroyedFunction() {};

	      if (config.destroyed) {
	        destroyedFunction = config.destroyed;
	      }

	      var createdFunction = function createdFunction() {};

	      if (config.created) {
	        createdFunction = config.created;
	      }

	      var initConfig = {
	        store: this.store,
	        beforeCreate: function beforeCreate() {
	          this.$bitrix.Data.set('controller', controller);
	          this.$bitrix.Application.set(application);
	          this.$bitrix.Loc.setMessage(controller.localize);

	          if (controller.restClient) {
	            this.$bitrix.RestClient.set(controller.restClient);
	          }

	          if (controller.pullClient) {
	            this.$bitrix.PullClient.set(controller.pullClient);
	          }

	          beforeCreateFunction.bind(this)();
	        },
	        created: function created() {
	          createdFunction.bind(this)();
	        },
	        destroyed: function destroyed() {
	          destroyedFunction.bind(this)();
	        }
	      };

	      if (config.el) {
	        initConfig.el = config.el;
	      }

	      if (config.template) {
	        initConfig.template = config.template;
	      }

	      if (config.computed) {
	        initConfig.computed = config.computed;
	      }

	      if (config.data) {
	        initConfig.data = config.data;
	      }

	      var initConfigCreatedFunction = initConfig.created;
	      return new Promise(function (resolve, reject) {
	        initConfig.created = function () {
	          initConfigCreatedFunction.bind(this)();
	          resolve(this);
	        };

	        ui_vue.WidgetBitrixVue.createApp(initConfig);
	      });
	    }
	    /* endregion 04. Template engine */

	    /* region 05. Core methods */

	  }, {
	    key: "getHost",
	    value: function getHost() {
	      return this.host;
	    }
	  }, {
	    key: "setHost",
	    value: function setHost(host) {
	      this.host = host;
	      this.store.commit('application/set', {
	        common: {
	          host: host
	        }
	      });
	    }
	  }, {
	    key: "getUserId",
	    value: function getUserId() {
	      return this.userId;
	    }
	  }, {
	    key: "setUserId",
	    value: function setUserId(userId) {
	      var parsedUserId = parseInt(userId);

	      if (!isNaN(parsedUserId)) {
	        this.userId = parsedUserId;
	      } else {
	        this.userId = 0;
	      }

	      this.store.commit('application/set', {
	        common: {
	          userId: userId
	        }
	      });
	    }
	  }, {
	    key: "getSiteId",
	    value: function getSiteId() {
	      return this.siteId;
	    }
	  }, {
	    key: "setSiteId",
	    value: function setSiteId(siteId) {
	      if (typeof siteId === 'string' && siteId !== '') {
	        this.siteId = siteId;
	      } else {
	        this.siteId = 's1';
	      }

	      this.store.commit('application/set', {
	        common: {
	          siteId: this.siteId
	        }
	      });
	    }
	  }, {
	    key: "getLanguageId",
	    value: function getLanguageId() {
	      return this.languageId;
	    }
	  }, {
	    key: "setLanguageId",
	    value: function setLanguageId(languageId) {
	      if (typeof languageId === 'string' && languageId !== '') {
	        this.languageId = languageId;
	      } else {
	        this.languageId = 'en';
	      }

	      this.store.commit('application/set', {
	        common: {
	          languageId: this.languageId
	        }
	      });
	    }
	  }, {
	    key: "getStore",
	    value: function getStore() {
	      return this.store;
	    }
	  }, {
	    key: "getStoreBuilder",
	    value: function getStoreBuilder() {
	      return this.storeBuilder;
	    }
	  }, {
	    key: "addRestAnswerHandler",
	    value: function addRestAnswerHandler(handler) {
	      this.restAnswerHandler.push(handler);
	    }
	  }, {
	    key: "addVuexModel",
	    value: function addVuexModel(model) {
	      this.vuexAdditionalModel.push(model);
	    }
	  }, {
	    key: "isOnline",
	    value: function isOnline() {
	      return !this.offline;
	    }
	  }, {
	    key: "ready",
	    value: function ready() {
	      if (this.inited) {
	        return Promise.resolve(this);
	      }

	      return this.initPromise;
	    }
	    /* endregion 05. Methods */

	    /* region 06. Interaction and utils */

	  }, {
	    key: "setError",
	    value: function setError() {
	      var code = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
	      var description = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
	      im_lib_logger.Logger.error("Messenger.Application.error: ".concat(code, " (").concat(description, ")"));
	      var localizeDescription = '';

	      if (code.endsWith('LOCALIZED')) {
	        localizeDescription = description;
	      }

	      this.store.commit('application/set', {
	        error: {
	          active: true,
	          code: code,
	          description: localizeDescription
	        }
	      });
	    }
	  }, {
	    key: "clearError",
	    value: function clearError() {
	      this.store.commit('application/set', {
	        error: {
	          active: false,
	          code: '',
	          description: ''
	        }
	      });
	    }
	  }, {
	    key: "addLocalize",
	    value: function addLocalize(phrases) {
	      if (babelHelpers["typeof"](phrases) !== "object" || !phrases) {
	        return false;
	      }

	      for (var name in phrases) {
	        if (phrases.hasOwnProperty(name)) {
	          this.localize[name] = phrases[name];
	        }
	      }

	      return true;
	    }
	  }, {
	    key: "getLocalize",
	    value: function getLocalize(name) {
	      var phrase = '';

	      if (typeof name === 'undefined') {
	        return this.localize;
	      } else if (typeof this.localize[name.toString()] === 'undefined') {
	        im_lib_logger.Logger.warn("Controller.Core.getLocalize: message with code '".concat(name.toString(), "' is undefined.")); //Logger.trace();
	      } else {
	        phrase = this.localize[name];
	      }

	      return phrase;
	    }
	    /* endregion 06. Interaction and utils */

	  }]);
	  return Controller;
	}();

	exports.Controller = Controller;

}((this.BX.Messenger = this.BX.Messenger || {}),BX,BX,BX,BX.Messenger.Model,BX.Messenger.Provider.Pull,BX.Messenger.Provider.Rest,BX.Messenger.Lib,BX.Messenger.Const,BX.Messenger.Lib,BX,BX.Messenger.Lib));
 




// file: /bitrix/js/im/lib/cookie/dist/cookie.bundle.js
this.BX = this.BX || {};
this.BX.Messenger = this.BX.Messenger || {};
(function (exports,im_lib_localstorage) {
	'use strict';

	/**
	 * Bitrix Im
	 * Cookie manager
	 *
	 * @package bitrix
	 * @subpackage im
	 * @copyright 2001-2020 Bitrix
	 */
	var Cookie = {
	  get: function get(siteId, name) {
	    var cookieName = siteId ? siteId + '_' + name : name;

	    if (navigator.cookieEnabled) {
	      var result = document.cookie.match(new RegExp("(?:^|; )" + cookieName.replace(/([.$?*|{}()\[\]\\\/+^])/g, '\\$1') + "=([^;]*)"));

	      if (result) {
	        return decodeURIComponent(result[1]);
	      }
	    }

	    if (im_lib_localstorage.LocalStorage.isEnabled()) {
	      var _result = im_lib_localstorage.LocalStorage.get(siteId, 0, name, undefined);

	      if (typeof _result !== 'undefined') {
	        return _result;
	      }
	    }

	    if (typeof window.BX.GuestUserCookie === 'undefined') {
	      window.BX.GuestUserCookie = {};
	    }

	    return window.BX.GuestUserCookie[cookieName];
	  },
	  set: function set(siteId, name, value, options) {
	    options = options || {};
	    var expires = options.expires;

	    if (typeof expires == "number" && expires) {
	      var currentDate = new Date();
	      currentDate.setTime(currentDate.getTime() + expires * 1000);
	      expires = options.expires = currentDate;
	    }

	    if (expires && expires.toUTCString) {
	      options.expires = expires.toUTCString();
	    }

	    value = encodeURIComponent(value);
	    var cookieName = siteId ? siteId + '_' + name : name;
	    var updatedCookie = cookieName + "=" + value;

	    for (var propertyName in options) {
	      if (!options.hasOwnProperty(propertyName)) {
	        continue;
	      }

	      updatedCookie += "; " + propertyName;
	      var propertyValue = options[propertyName];

	      if (propertyValue !== true) {
	        updatedCookie += "=" + propertyValue;
	      }
	    }

	    document.cookie = updatedCookie;

	    if (typeof window.BX.GuestUserCookie === 'undefined') {
	      BX.GuestUserCookie = {};
	    }

	    window.BX.GuestUserCookie[cookieName] = value;
	    im_lib_localstorage.LocalStorage.set(siteId, 0, name, value);
	    return true;
	  }
	};

	exports.Cookie = Cookie;

}((this.BX.Messenger.Lib = this.BX.Messenger.Lib || {}),BX.Messenger.Lib));
 




// file: /bitrix/js/imopenlines/component/widget/dist/widget.bundle.js
(function (exports,main_polyfill_customevent,pull_component_status,ui_vue_components_smiles,im_component_dialog,im_component_textarea,im_view_quotepanel,imopenlines_component_message,imopenlines_component_form,rest_client,im_provider_rest,main_date,pull_client,ui_vue_components_crm_form,im_controller,im_lib_cookie,im_lib_localstorage,im_lib_uploader,im_lib_utils,im_lib_logger,im_mixin,main_md5,main_core_events,im_const,main_core_minimal,ui_vue_vuex,ui_vue) {
	'use strict';

	/**
	 * Bitrix OpenLines widget
	 * Widget constants
	 *
	 * @package bitrix
	 * @subpackage imopenlines
	 * @copyright 2001-2019 Bitrix
	 */
	function GetObjectValues(source) {
	  var destination = [];

	  for (var value in source) {
	    if (source.hasOwnProperty(value)) {
	      destination.push(source[value]);
	    }
	  }

	  return destination;
	}
	/* region 01. Constants */


	var VoteType = Object.freeze({
	  none: 'none',
	  like: 'like',
	  dislike: 'dislike'
	});
	var LanguageType = Object.freeze({
	  russian: 'ru',
	  ukraine: 'ua',
	  world: 'en'
	});
	var FormType = Object.freeze({
	  none: 'none',
	  like: 'like',
	  smile: 'smile',
	  consent: 'consent',
	  welcome: 'welcome',
	  offline: 'offline',
	  history: 'history'
	});
	var LocationType = Object.freeze({
	  topLeft: 1,
	  topMiddle: 2,
	  topBottom: 3,
	  bottomLeft: 6,
	  bottomMiddle: 5,
	  bottomRight: 4
	});
	var LocationStyle = Object.freeze({
	  1: 'top-left',
	  2: 'top-center',
	  3: 'top-right',
	  6: 'bottom-left',
	  5: 'bottom-center',
	  4: 'bottom-right'
	});
	var SubscriptionType = Object.freeze({
	  configLoaded: 'configLoaded',
	  widgetOpen: 'widgetOpen',
	  widgetClose: 'widgetClose',
	  sessionStart: 'sessionStart',
	  sessionOperatorChange: 'sessionOperatorChange',
	  sessionFinish: 'sessionFinish',
	  operatorMessage: 'operatorMessage',
	  userForm: 'userForm',
	  userMessage: 'userMessage',
	  userFile: 'userFile',
	  userVote: 'userVote',
	  every: 'every'
	});
	var SubscriptionTypeCheck = GetObjectValues(SubscriptionType);
	var RestMethod = Object.freeze({
	  widgetUserRegister: 'imopenlines.widget.user.register',
	  widgetConfigGet: 'imopenlines.widget.config.get',
	  widgetDialogGet: 'imopenlines.widget.dialog.get',
	  widgetUserGet: 'imopenlines.widget.user.get',
	  widgetUserConsentApply: 'imopenlines.widget.user.consent.apply',
	  widgetVoteSend: 'imopenlines.widget.vote.send',
	  widgetActionSend: 'imopenlines.widget.action.send',
	  pullServerTime: 'server.time',
	  pullConfigGet: 'pull.config.get'
	});
	var RestMethodCheck = GetObjectValues(RestMethod);
	var RestAuth = Object.freeze({
	  guest: 'guest'
	});
	var SessionStatus = Object.freeze({
	  "new": 0,
	  skip: 5,
	  answer: 10,
	  client: 20,
	  clientAfterOperator: 25,
	  operator: 40,
	  waitClient: 50,
	  close: 60,
	  spam: 65,
	  duplicate: 69,
	  silentlyClose: 75
	});
	var EventType = Object.freeze({
	  requestShowForm: 'IMOL.Widget:requestShowForm'
	});

	/**
	 * Bitrix OpenLines widget
	 * Widget model (Vuex Builder model)
	 *
	 * @package bitrix
	 * @subpackage imopenlines
	 * @copyright 2001-2019 Bitrix
	 */
	var WidgetModel = /*#__PURE__*/function (_VuexBuilderModel) {
	  babelHelpers.inherits(WidgetModel, _VuexBuilderModel);

	  function WidgetModel() {
	    babelHelpers.classCallCheck(this, WidgetModel);
	    return babelHelpers.possibleConstructorReturn(this, babelHelpers.getPrototypeOf(WidgetModel).apply(this, arguments));
	  }

	  babelHelpers.createClass(WidgetModel, [{
	    key: "getName",

	    /**
	     * @inheritDoc
	     */
	    value: function getName() {
	      return 'widget';
	    }
	  }, {
	    key: "getState",
	    value: function getState() {
	      return {
	        common: {
	          configId: 0,
	          configName: '',
	          host: this.getVariable('common.host', location.protocol + '//' + location.host),
	          pageMode: this.getVariable('common.pageMode', false),
	          copyright: this.getVariable('common.copyright', true),
	          copyrightUrl: this.getVariable('common.copyrightUrl', 'https://bitrix24.com'),
	          location: this.getVariable('common.location', LocationType.bottomRight),
	          styles: {
	            backgroundColor: this.getVariable('styles.backgroundColor', '#17a3ea'),
	            iconColor: this.getVariable('styles.iconColor', '#ffffff')
	          },
	          vote: {
	            enable: false,
	            beforeFinish: true,
	            messageText: this.getVariable('vote.messageText', ''),
	            messageLike: this.getVariable('vote.messageLike', ''),
	            messageDislike: this.getVariable('vote.messageDislike', '')
	          },
	          textMessages: {
	            bxLivechatOnlineLine1: this.getVariable('textMessages.bxLivechatOnlineLine1', ''),
	            bxLivechatOnlineLine2: this.getVariable('textMessages.bxLivechatOnlineLine2', ''),
	            bxLivechatOffline: this.getVariable('textMessages.bxLivechatOffline', ''),
	            bxLivechatTitle: ''
	          },
	          online: false,
	          operators: [],
	          connectors: [],
	          showForm: FormType.none,
	          showed: false,
	          reopen: false,
	          dragged: false,
	          textareaHeight: 0,
	          widgetHeight: 0,
	          widgetWidth: 0,
	          showConsent: false,
	          consentUrl: '',
	          dialogStart: false,
	          watchTyping: false,
	          showSessionId: false,
	          crmFormsSettings: {
	            useWelcomeForm: false,
	            welcomeFormId: 0,
	            welcomeFormSec: '',
	            welcomeFormDelay: false,
	            welcomeFormFilled: false,
	            successText: '',
	            errorText: ''
	          }
	        },
	        dialog: {
	          sessionId: 0,
	          sessionClose: true,
	          sessionStatus: 0,
	          userVote: VoteType.none,
	          closeVote: false,
	          userConsent: false,
	          operatorChatId: 0,
	          operator: {
	            id: 0,
	            name: '',
	            firstName: '',
	            lastName: '',
	            workPosition: '',
	            avatar: '',
	            online: false
	          }
	        },
	        user: {
	          id: -1,
	          hash: '',
	          name: '',
	          firstName: '',
	          lastName: '',
	          avatar: '',
	          email: '',
	          phone: '',
	          www: '',
	          gender: 'M',
	          position: ''
	        }
	      };
	    }
	  }, {
	    key: "getStateSaveException",
	    value: function getStateSaveException() {
	      return {
	        common: {
	          host: null,
	          pageMode: null,
	          copyright: null,
	          copyrightUrl: null,
	          styles: null,
	          dragged: null,
	          showed: null,
	          showConsent: null,
	          showForm: null
	        }
	      };
	    }
	  }, {
	    key: "getMutations",
	    value: function getMutations() {
	      var _this = this;

	      return {
	        common: function common(state, payload) {
	          if (typeof payload.configId === 'number') {
	            state.common.configId = payload.configId;
	          }

	          if (typeof payload.configName === 'string') {
	            state.common.configName = payload.configName;
	          }

	          if (typeof payload.online === 'boolean') {
	            state.common.online = payload.online;
	          }

	          if (im_lib_utils.Utils.types.isPlainObject(payload.vote)) {
	            if (typeof payload.vote.enable === 'boolean') {
	              state.common.vote.enable = payload.vote.enable;
	            }

	            if (typeof payload.vote.beforeFinish === 'boolean') {
	              state.common.vote.beforeFinish = payload.vote.beforeFinish;
	            }

	            if (typeof payload.vote.messageText === 'string') {
	              state.common.vote.messageText = payload.vote.messageText;
	            }

	            if (typeof payload.vote.messageLike === 'string') {
	              state.common.vote.messageLike = payload.vote.messageLike;
	            }

	            if (typeof payload.vote.messageDislike === 'string') {
	              state.common.vote.messageDislike = payload.vote.messageDislike;
	            }
	          }

	          if (im_lib_utils.Utils.types.isPlainObject(payload.textMessages)) {
	            if (typeof payload.textMessages.bxLivechatOnlineLine1 === 'string' && payload.textMessages.bxLivechatOnlineLine1 !== '') {
	              state.common.textMessages.bxLivechatOnlineLine1 = payload.textMessages.bxLivechatOnlineLine1;
	            }

	            if (typeof payload.textMessages.bxLivechatOnlineLine2 === 'string' && payload.textMessages.bxLivechatOnlineLine2 !== '') {
	              state.common.textMessages.bxLivechatOnlineLine2 = payload.textMessages.bxLivechatOnlineLine2;
	            }

	            if (typeof payload.textMessages.bxLivechatOffline === 'string' && payload.textMessages.bxLivechatOffline !== '') {
	              state.common.textMessages.bxLivechatOffline = payload.textMessages.bxLivechatOffline;
	            }

	            if (typeof payload.textMessages.bxLivechatTitle === 'string' && payload.textMessages.bxLivechatTitle !== '') {
	              state.common.textMessages.bxLivechatTitle = payload.textMessages.bxLivechatTitle;
	            }
	          }

	          if (typeof payload.dragged === 'boolean') {
	            state.common.dragged = payload.dragged;
	          }

	          if (typeof payload.textareaHeight === 'number') {
	            state.common.textareaHeight = payload.textareaHeight;
	          }

	          if (typeof payload.widgetHeight === 'number') {
	            state.common.widgetHeight = payload.widgetHeight;
	          }

	          if (typeof payload.widgetWidth === 'number') {
	            state.common.widgetWidth = payload.widgetWidth;
	          }

	          if (typeof payload.showConsent === 'boolean') {
	            state.common.showConsent = payload.showConsent;
	          }

	          if (typeof payload.consentUrl === 'string') {
	            state.common.consentUrl = payload.consentUrl;
	          }

	          if (typeof payload.showed === 'boolean') {
	            state.common.showed = payload.showed;
	            payload.reopen = im_lib_utils.Utils.device.isMobile() ? false : payload.showed;
	          }

	          if (typeof payload.reopen === 'boolean') {
	            state.common.reopen = payload.reopen;
	          }

	          if (typeof payload.copyright === 'boolean') {
	            state.common.copyright = payload.copyright;
	          }

	          if (typeof payload.dialogStart === 'boolean') {
	            state.common.dialogStart = payload.dialogStart;
	          }

	          if (typeof payload.watchTyping === 'boolean') {
	            state.common.watchTyping = payload.watchTyping;
	          }

	          if (typeof payload.showSessionId === 'boolean') {
	            state.common.showSessionId = payload.showSessionId;
	          }

	          if (payload.operators instanceof Array) {
	            state.common.operators = payload.operators;
	          }

	          if (payload.connectors instanceof Array) {
	            state.common.connectors = payload.connectors;
	          }

	          if (typeof payload.showForm === 'string' && typeof FormType[payload.showForm] !== 'undefined') {
	            if (payload.showForm === FormType.like && !!state.dialog.closeVote) {
	              payload.showForm = FormType.none;
	            }

	            state.common.showForm = payload.showForm;
	          }

	          if (typeof payload.location === 'number' && typeof LocationStyle[payload.location] !== 'undefined') {
	            if (state.common.location !== payload.location) {
	              state.common.widgetHeight = 0;
	              state.common.widgetWidth = 0;
	              state.common.location = payload.location;
	            }
	          }

	          if (im_lib_utils.Utils.types.isPlainObject(payload.crmFormsSettings)) {
	            if (typeof payload.crmFormsSettings.useWelcomeForm === 'string') {
	              state.common.crmFormsSettings.useWelcomeForm = payload.crmFormsSettings.useWelcomeForm === 'Y';
	            }

	            if (typeof payload.crmFormsSettings.welcomeFormId === 'string') {
	              state.common.crmFormsSettings.welcomeFormId = payload.crmFormsSettings.welcomeFormId;
	            }

	            if (typeof payload.crmFormsSettings.welcomeFormSec === 'string') {
	              state.common.crmFormsSettings.welcomeFormSec = payload.crmFormsSettings.welcomeFormSec;
	            }

	            if (typeof payload.crmFormsSettings.welcomeFormDelay === 'string') {
	              state.common.crmFormsSettings.welcomeFormDelay = payload.crmFormsSettings.welcomeFormDelay === 'Y';
	            }

	            if (typeof payload.crmFormsSettings.successText === 'string' && payload.crmFormsSettings.successText !== '') {
	              state.common.crmFormsSettings.successText = payload.crmFormsSettings.successText;
	            }

	            if (typeof payload.crmFormsSettings.errorText === 'string' && payload.crmFormsSettings.errorText !== '') {
	              state.common.crmFormsSettings.errorText = payload.crmFormsSettings.errorText;
	            }
	          }

	          if (_this.isSaveNeeded({
	            common: payload
	          })) {
	            _this.saveState(state);
	          }
	        },
	        dialog: function dialog(state, payload) {
	          if (typeof payload.sessionId === 'number') {
	            state.dialog.sessionId = payload.sessionId;
	          }

	          if (typeof payload.sessionClose === 'boolean') {
	            state.dialog.sessionClose = payload.sessionClose;
	          }

	          if (typeof payload.sessionStatus === 'number') {
	            state.dialog.sessionStatus = payload.sessionStatus;
	          }

	          if (typeof payload.userConsent === 'boolean') {
	            state.dialog.userConsent = payload.userConsent;
	          }

	          if (typeof payload.userVote === 'string' && typeof payload.userVote !== 'undefined') {
	            state.dialog.userVote = payload.userVote;
	          }

	          if (typeof payload.closeVote === 'boolean') {
	            state.dialog.closeVote = payload.closeVote;

	            if (!!payload.closeVote && state.common.showForm === FormType.like) {
	              state.common.showForm = FormType.none;
	            }
	          }

	          if (typeof payload.operatorChatId === 'number') {
	            state.dialog.operatorChatId = payload.operatorChatId;
	          }

	          if (im_lib_utils.Utils.types.isPlainObject(payload.operator)) {
	            if (typeof payload.operator.id === 'number') {
	              state.dialog.operator.id = payload.operator.id;
	            }

	            if (typeof payload.operator.name === 'string' || typeof payload.operator.name === 'number') {
	              state.dialog.operator.name = payload.operator.name.toString();
	            }

	            if (typeof payload.operator.lastName === 'string' || typeof payload.operator.lastName === 'number') {
	              state.dialog.operator.lastName = payload.operator.lastName.toString();
	            }

	            if (typeof payload.operator.firstName === 'string' || typeof payload.operator.firstName === 'number') {
	              state.dialog.operator.firstName = payload.operator.firstName.toString();
	            }

	            if (typeof payload.operator.workPosition === 'string' || typeof payload.operator.workPosition === 'number') {
	              state.dialog.operator.workPosition = payload.operator.workPosition.toString();
	            }

	            if (typeof payload.operator.avatar === 'string') {
	              if (!payload.operator.avatar || payload.operator.avatar.startsWith('http')) {
	                state.dialog.operator.avatar = payload.operator.avatar;
	              } else {
	                state.dialog.operator.avatar = state.common.host + payload.operator.avatar;
	              }
	            }

	            if (typeof payload.operator.online === 'boolean') {
	              state.dialog.operator.online = payload.operator.online;
	            }
	          }

	          if (_this.isSaveNeeded({
	            dialog: payload
	          })) {
	            _this.saveState(state);
	          }
	        },
	        user: function user(state, payload) {
	          if (typeof payload.id === 'number') {
	            state.user.id = payload.id;
	          }

	          if (typeof payload.hash === 'string' && payload.hash !== state.user.hash) {
	            state.user.hash = payload.hash;
	            im_lib_cookie.Cookie.set(null, 'LIVECHAT_HASH', payload.hash, {
	              expires: 365 * 86400,
	              path: '/'
	            });
	          }

	          if (typeof payload.name === 'string' || typeof payload.name === 'number') {
	            state.user.name = payload.name.toString();
	          }

	          if (typeof payload.firstName === 'string' || typeof payload.firstName === 'number') {
	            state.user.firstName = payload.firstName.toString();
	          }

	          if (typeof payload.lastName === 'string' || typeof payload.lastName === 'number') {
	            state.user.lastName = payload.lastName.toString();
	          }

	          if (typeof payload.avatar === 'string') {
	            state.user.avatar = payload.avatar;
	          }

	          if (typeof payload.email === 'string') {
	            state.user.email = payload.email;
	          }

	          if (typeof payload.phone === 'string' || typeof payload.phone === 'number') {
	            state.user.phone = payload.phone.toString();
	          }

	          if (typeof payload.www === 'string') {
	            state.user.www = payload.www;
	          }

	          if (typeof payload.gender === 'string') {
	            state.user.gender = payload.gender;
	          }

	          if (typeof payload.position === 'string') {
	            state.user.position = payload.position;
	          }

	          if (_this.isSaveNeeded({
	            user: payload
	          })) {
	            _this.saveState(state);
	          }
	        }
	      };
	    }
	  }, {
	    key: "getActions",
	    value: function getActions() {
	      var _this2 = this;

	      return {
	        show: function show(_ref) {
	          var commit = _ref.commit;
	          commit('common', {
	            showed: true
	          });
	        },
	        setVoteDateFinish: function setVoteDateFinish(_ref2, payload) {
	          var commit = _ref2.commit,
	              dispatch = _ref2.dispatch,
	              state = _ref2.state;

	          if (!payload) {
	            clearTimeout(_this2.setVoteDateTimeout);
	            commit('dialog', {
	              closeVote: false
	            });
	            return true;
	          }

	          var totalDelay = new Date(payload).getTime() - new Date().getTime();
	          var dayTimestamp = 10000;
	          clearTimeout(_this2.setVoteDateTimeout);

	          if (payload) {
	            if (totalDelay && !state.dialog.closeVote) {
	              commit('dialog', {
	                closeVote: false
	              });
	            }

	            var delay = totalDelay;

	            if (totalDelay > dayTimestamp) {
	              delay = dayTimestamp;
	            }

	            _this2.setVoteDateTimeout = setTimeout(function requestCloseVote() {
	              delay = new Date(payload).getTime() - new Date().getTime();

	              if (delay > 0) {
	                if (delay > dayTimestamp) {
	                  delay = dayTimestamp;
	                }

	                setTimeout(requestCloseVote, delay);
	              } else {
	                commit('dialog', {
	                  closeVote: true
	                });
	              }
	            }, delay);
	          }
	        }
	      };
	    }
	  }]);
	  return WidgetModel;
	}(ui_vue_vuex.WidgetVuexBuilderModel);

	/**
	 * Bitrix OpenLines widget
	 * Rest client (base on BX.RestClient)
	 *
	 * @package bitrix
	 * @subpackage imopenlines
	 * @copyright 2001-2019 Bitrix
	 */
	var WidgetRestClient = /*#__PURE__*/function () {
	  function WidgetRestClient(params) {
	    babelHelpers.classCallCheck(this, WidgetRestClient);
	    this.queryAuthRestore = false;
	    this.setAuthId(RestAuth.guest);
	    this.restClient = new rest_client.RestClient({
	      endpoint: params.endpoint,
	      queryParams: this.queryParams,
	      cors: true
	    });
	  }

	  babelHelpers.createClass(WidgetRestClient, [{
	    key: "setAuthId",
	    value: function setAuthId(authId) {
	      var customAuthId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';

	      if (babelHelpers["typeof"](this.queryParams) !== 'object') {
	        this.queryParams = {};
	      }

	      if (authId == RestAuth.guest || typeof authId === 'string' && authId.match(/^[a-f0-9]{32}$/)) {
	        this.queryParams.livechat_auth_id = authId;
	      } else {
	        console.error("%LiveChatRestClient.setAuthId: auth is not correct (%c".concat(authId, "%c)"), "color: black;", "font-weight: bold; color: red", "color: black");
	        return false;
	      }

	      if (authId == RestAuth.guest && typeof customAuthId === 'string' && customAuthId.match(/^[a-f0-9]{32}$/)) {
	        this.queryParams.livechat_custom_auth_id = customAuthId;
	      }

	      return true;
	    }
	  }, {
	    key: "getAuthId",
	    value: function getAuthId() {
	      if (babelHelpers["typeof"](this.queryParams) !== 'object') {
	        this.queryParams = {};
	      }

	      return this.queryParams.livechat_auth_id || null;
	    }
	  }, {
	    key: "callMethod",
	    value: function callMethod(method, params, callback, sendCallback) {
	      var _this = this;

	      var logTag = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;

	      if (!logTag) {
	        logTag = im_lib_utils.Utils.getLogTrackingParams({
	          name: method
	        });
	      }

	      var promise = new BX.Promise(); // TODO: Callbacks methods will not work!

	      this.restClient.callMethod(method, params, null, sendCallback, logTag).then(function (result) {
	        _this.queryAuthRestore = false;
	        promise.fulfill(result);
	      })["catch"](function (result) {
	        var error = result.error();

	        if (error.ex.error == 'LIVECHAT_AUTH_WIDGET_USER') {
	          _this.setAuthId(error.ex.hash);

	          if (method === RestMethod.widgetUserRegister) {
	            console.warn("BX.LiveChatRestClient: ".concat(error.ex.error_description, " (").concat(error.ex.error, ")"));
	            _this.queryAuthRestore = false;
	            promise.reject(result);
	            return false;
	          }

	          if (!_this.queryAuthRestore) {
	            console.warn('BX.LiveChatRestClient: your auth-token has expired, send query with a new token');
	            _this.queryAuthRestore = true;

	            _this.restClient.callMethod(method, params, null, sendCallback, logTag).then(function (result) {
	              _this.queryAuthRestore = false;
	              promise.fulfill(result);
	            })["catch"](function (result) {
	              _this.queryAuthRestore = false;
	              promise.reject(result);
	            });

	            return false;
	          }
	        }

	        _this.queryAuthRestore = false;
	        promise.reject(result);
	      });
	      return promise;
	    }
	  }, {
	    key: "callBatch",
	    value: function callBatch(calls, callback, bHaltOnError, sendCallback, logTag) {
	      var _this2 = this;

	      var resultCallback = function resultCallback(result) {

	        for (var method in calls) {
	          if (!calls.hasOwnProperty(method)) {
	            continue;
	          }

	          var _error = result[method].error();

	          if (_error && _error.ex.error == 'LIVECHAT_AUTH_WIDGET_USER') {
	            _this2.setAuthId(_error.ex.hash);

	            if (method === RestMethod.widgetUserRegister) {
	              console.warn("BX.LiveChatRestClient: ".concat(_error.ex.error_description, " (").concat(_error.ex.error, ")"));
	              _this2.queryAuthRestore = false;
	              callback(result);
	              return false;
	            }

	            if (!_this2.queryAuthRestore) {
	              console.warn('BX.LiveChatRestClient: your auth-token has expired, send query with a new token');
	              _this2.queryAuthRestore = true;

	              _this2.restClient.callBatch(calls, callback, bHaltOnError, sendCallback, logTag);

	              return false;
	            }
	          }
	        }

	        _this2.queryAuthRestore = false;
	        callback(result);
	        return true;
	      };

	      return this.restClient.callBatch(calls, resultCallback, bHaltOnError, sendCallback, logTag);
	    }
	  }]);
	  return WidgetRestClient;
	}();

	/**
	 * Bitrix OpenLines widget
	 * Widget Rest answers (Rest Answer Handler)
	 *
	 * @package bitrix
	 * @subpackage imopenlines
	 * @copyright 2001-2019 Bitrix
	 */

	var WidgetRestAnswerHandler = /*#__PURE__*/function (_BaseRestHandler) {
	  babelHelpers.inherits(WidgetRestAnswerHandler, _BaseRestHandler);

	  function WidgetRestAnswerHandler() {
	    var _this;

	    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	    babelHelpers.classCallCheck(this, WidgetRestAnswerHandler);
	    _this = babelHelpers.possibleConstructorReturn(this, babelHelpers.getPrototypeOf(WidgetRestAnswerHandler).call(this, props));
	    _this.widget = props.widget;
	    return _this;
	  }

	  babelHelpers.createClass(WidgetRestAnswerHandler, [{
	    key: "handleImopenlinesWidgetConfigGetSuccess",
	    value: function handleImopenlinesWidgetConfigGetSuccess(data) {
	      this.store.commit('widget/common', {
	        configId: data.configId,
	        configName: data.configName,
	        vote: data.vote,
	        textMessages: data.textMessages,
	        operators: data.operators || [],
	        online: data.online,
	        consentUrl: data.consentUrl,
	        connectors: data.connectors || [],
	        watchTyping: data.watchTyping,
	        showSessionId: data.showSessionId,
	        crmFormsSettings: data.crmFormsSettings
	      });
	      this.store.commit('application/set', {
	        disk: data.disk
	      });
	      this.widget.addLocalize(data.serverVariables);
	      im_lib_localstorage.LocalStorage.set(this.widget.getSiteId(), 0, 'serverVariables', data.serverVariables || {});
	    }
	  }, {
	    key: "handleImopenlinesWidgetUserRegisterSuccess",
	    value: function handleImopenlinesWidgetUserRegisterSuccess(data) {
	      this.widget.restClient.setAuthId(data.hash);
	      var previousData = [];

	      if (typeof this.store.state.messages.collection[this.controller.application.getChatId()] !== 'undefined') {
	        previousData = this.store.state.messages.collection[this.controller.application.getChatId()];
	      }

	      this.store.commit('messages/initCollection', {
	        chatId: data.chatId,
	        messages: previousData
	      });
	      this.store.commit('dialogues/initCollection', {
	        dialogId: data.dialogId,
	        fields: {
	          entityType: 'LIVECHAT',
	          type: 'livechat'
	        }
	      });
	      this.store.commit('application/set', {
	        dialog: {
	          chatId: data.chatId,
	          dialogId: 'chat' + data.chatId
	        }
	      });
	    }
	  }, {
	    key: "handleImopenlinesWidgetUserGetSuccess",
	    value: function handleImopenlinesWidgetUserGetSuccess(data) {
	      this.store.commit('widget/user', {
	        id: data.id,
	        hash: data.hash,
	        name: data.name,
	        firstName: data.firstName,
	        lastName: data.lastName,
	        phone: data.phone,
	        avatar: data.avatar,
	        email: data.email,
	        www: data.www,
	        gender: data.gender,
	        position: data.position
	      });
	      this.store.dispatch('users/set', [{
	        id: data.id,
	        name: data.name,
	        firstName: data.firstName,
	        lastName: data.lastName,
	        avatar: data.avatar,
	        gender: data.gender,
	        workPosition: data.position
	      }]);
	      this.store.commit('application/set', {
	        common: {
	          userId: data.id
	        }
	      });
	    }
	  }, {
	    key: "handleImopenlinesWidgetDialogGetSuccess",
	    value: function handleImopenlinesWidgetDialogGetSuccess(data) {
	      this.store.commit('messages/initCollection', {
	        chatId: data.chatId
	      });
	      this.store.commit('widget/dialog', data);
	      this.store.commit('application/set', {
	        dialog: {
	          chatId: data.chatId,
	          dialogId: 'chat' + data.chatId,
	          diskFolderId: data.diskFolderId
	        }
	      });
	      this.store.dispatch('widget/setVoteDateFinish', data.dateCloseVote);
	    }
	  }, {
	    key: "handleImDialogMessagesGetInitSuccess",
	    value: function handleImDialogMessagesGetInitSuccess(data) {
	      this.handleImDialogMessagesGetSuccess(data);
	    }
	  }, {
	    key: "handleImDialogMessagesGetSuccess",
	    value: function handleImDialogMessagesGetSuccess(data) {
	      if (data.messages && data.messages.length > 0 && !this.widget.isDialogStart()) {
	        this.store.commit('widget/common', {
	          dialogStart: true
	        });
	        this.store.commit('widget/dialog', {
	          userConsent: true
	        });
	      }
	    }
	  }, {
	    key: "handleImMessageAddSuccess",
	    value: function handleImMessageAddSuccess(messageId, message) {
	      this.widget.messagesQueue = this.widget.messagesQueue.filter(function (el) {
	        return el.id != message.id;
	      });
	      this.widget.sendEvent({
	        type: SubscriptionType.userMessage,
	        data: {
	          id: messageId,
	          text: message.text
	        }
	      });
	    }
	  }, {
	    key: "handleImMessageAddError",
	    value: function handleImMessageAddError(error, message) {
	      this.widget.messagesQueue = this.widget.messagesQueue.filter(function (el) {
	        return el.id != message.id;
	      });
	    }
	  }, {
	    key: "handleImDiskFileCommitSuccess",
	    value: function handleImDiskFileCommitSuccess(result, message) {
	      this.widget.messagesQueue = this.widget.messagesQueue.filter(function (el) {
	        return el.id != message.id;
	      });
	      this.widget.sendEvent({
	        type: SubscriptionType.userFile,
	        data: {}
	      });
	    }
	  }]);
	  return WidgetRestAnswerHandler;
	}(im_provider_rest.BaseRestHandler);

	/**
	 * Bitrix OpenLines widget
	 * Widget pull commands (Pull Command Handler)
	 *
	 * @package bitrix
	 * @subpackage imopenlines
	 * @copyright 2001-2019 Bitrix
	 */

	var WidgetImPullCommandHandler = /*#__PURE__*/function () {
	  babelHelpers.createClass(WidgetImPullCommandHandler, [{
	    key: "getModuleId",
	    value: function getModuleId() {
	      return 'im';
	    }
	  }], [{
	    key: "create",
	    value: function create() {
	      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	      return new this(params);
	    }
	  }]);

	  function WidgetImPullCommandHandler(params) {
	    babelHelpers.classCallCheck(this, WidgetImPullCommandHandler);
	    this.controller = params.controller;
	    this.store = params.store;
	    this.widget = params.widget;
	  }

	  babelHelpers.createClass(WidgetImPullCommandHandler, [{
	    key: "handleMessageChat",
	    value: function handleMessageChat(params, extra, command) {
	      if (params.message.senderId != this.controller.application.getUserId()) {
	        this.widget.sendEvent({
	          type: SubscriptionType.operatorMessage,
	          data: params
	        });

	        if (!this.store.state.widget.common.showed && !this.widget.onceShowed) {
	          this.widget.onceShowed = true;
	          this.widget.open();
	        }
	      }
	    }
	  }]);
	  return WidgetImPullCommandHandler;
	}();

	var WidgetImopenlinesPullCommandHandler = /*#__PURE__*/function () {
	  babelHelpers.createClass(WidgetImopenlinesPullCommandHandler, null, [{
	    key: "create",
	    value: function create() {
	      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	      return new this(params);
	    }
	  }]);

	  function WidgetImopenlinesPullCommandHandler() {
	    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	    babelHelpers.classCallCheck(this, WidgetImopenlinesPullCommandHandler);
	    this.controller = params.controller;
	    this.store = params.store;
	    this.widget = params.widget;
	  }

	  babelHelpers.createClass(WidgetImopenlinesPullCommandHandler, [{
	    key: "getModuleId",
	    value: function getModuleId() {
	      return 'imopenlines';
	    }
	  }, {
	    key: "handleSessionStart",
	    value: function handleSessionStart(params, extra, command) {
	      this.store.commit('widget/dialog', {
	        sessionId: params.sessionId,
	        sessionClose: false,
	        sessionStatus: 0,
	        userVote: VoteType.none
	      });
	      this.store.dispatch('widget/setVoteDateFinish', '');
	      this.widget.sendEvent({
	        type: SubscriptionType.sessionStart,
	        data: {
	          sessionId: params.sessionId
	        }
	      });
	    }
	  }, {
	    key: "handleSessionOperatorChange",
	    value: function handleSessionOperatorChange(params, extra, command) {
	      this.store.commit('widget/dialog', {
	        operator: params.operator,
	        operatorChatId: params.operatorChatId
	      });
	      this.widget.sendEvent({
	        type: SubscriptionType.sessionOperatorChange,
	        data: {
	          operator: params.operator
	        }
	      });
	    }
	  }, {
	    key: "handleSessionStatus",
	    value: function handleSessionStatus(params, extra, command) {
	      this.store.commit('widget/dialog', {
	        sessionId: params.sessionId,
	        sessionStatus: params.sessionStatus,
	        sessionClose: params.sessionClose
	      });
	      this.widget.sendEvent({
	        type: SubscriptionType.sessionStatus,
	        data: {
	          sessionId: params.sessionId,
	          sessionStatus: params.sessionStatus
	        }
	      });

	      if (params.sessionClose) {
	        this.widget.sendEvent({
	          type: SubscriptionType.sessionFinish,
	          data: {
	            sessionId: params.sessionId,
	            sessionStatus: params.sessionStatus
	          }
	        });

	        if (!params.spam) {
	          this.store.commit('widget/dialog', {
	            operator: {
	              name: '',
	              firstName: '',
	              lastName: '',
	              workPosition: '',
	              avatar: '',
	              online: false
	            }
	          });
	        }
	      }
	    }
	  }, {
	    key: "handleSessionDateCloseVote",
	    value: function handleSessionDateCloseVote(params, extra, command) {
	      this.store.dispatch('widget/setVoteDateFinish', params.dateCloseVote);
	    }
	  }]);
	  return WidgetImopenlinesPullCommandHandler;
	}();

	function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { babelHelpers.defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

	var Widget = /*#__PURE__*/function () {
	  /* region 01. Initialize and store data */
	  function Widget() {
	    var _this = this;

	    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	    babelHelpers.classCallCheck(this, Widget);
	    this.params = params;
	    this.template = null;
	    this.rootNode = this.params.node || document.createElement('div');
	    this.messagesQueue = [];
	    this.ready = true;
	    this.widgetDataRequested = false;
	    this.offline = false;
	    this.inited = false;
	    this.initEventFired = false;
	    this.restClient = null;
	    this.userRegisterData = {};
	    this.customData = [];
	    this.options = {
	      checkSameDomain: true
	    };
	    this.subscribers = {};
	    this.configRequestXhr = null;
	    this.initParams().then(function () {
	      return _this.initRestClient();
	    }).then(function () {
	      return _this.initPullClient();
	    }).then(function () {
	      return _this.initCore();
	    }).then(function () {
	      return _this.initWidget();
	    }).then(function () {
	      return _this.initUploader();
	    }).then(function () {
	      return _this.initComplete();
	    });
	  }

	  babelHelpers.createClass(Widget, [{
	    key: "initParams",
	    value: function initParams() {
	      this.code = this.params.code || '';
	      this.host = this.params.host || '';
	      this.language = this.params.language || 'en';
	      this.copyright = this.params.copyright !== false;
	      this.copyrightUrl = this.copyright && this.params.copyrightUrl ? this.params.copyrightUrl : '';
	      this.buttonInstance = babelHelpers["typeof"](this.params.buttonInstance) === 'object' && this.params.buttonInstance !== null ? this.params.buttonInstance : null;
	      this.pageMode = babelHelpers["typeof"](this.params.pageMode) === 'object' && this.params.pageMode;

	      if (this.pageMode) {
	        this.pageMode.useBitrixLocalize = this.params.pageMode.useBitrixLocalize === true;
	        this.pageMode.placeholder = document.getElementById(this.params.pageMode.placeholder);
	      }

	      if (typeof this.code === 'string') {
	        if (this.code.length <= 0) {
	          console.warn("%cLiveChatWidget.constructor: code is not correct (%c".concat(this.code, "%c)"), "color: black;", "font-weight: bold; color: red", "color: black");
	          this.ready = false;
	        }
	      }

	      if (typeof this.host === 'string') {
	        if (this.host.length <= 0 || !this.host.startsWith('http')) {
	          console.warn("%cLiveChatWidget.constructor: host is not correct (%c".concat(this.host, "%c)"), "color: black;", "font-weight: bold; color: red", "color: black");
	          this.ready = false;
	        }
	      }

	      if (this.pageMode && this.pageMode.placeholder) {
	        this.rootNode = this.pageMode.placeholder;
	      } else {
	        if (document.body.firstChild) {
	          document.body.insertBefore(this.rootNode, document.body.firstChild);
	        } else {
	          document.body.appendChild(this.rootNode);
	        }
	      }

	      this.localize = this.pageMode && this.pageMode.useBitrixLocalize ? window.BX.message : {};

	      if (babelHelpers["typeof"](this.params.localize) === 'object') {
	        this.addLocalize(this.params.localize);
	      }

	      var serverVariables = im_lib_localstorage.LocalStorage.get(this.getSiteId(), 0, 'serverVariables', false);

	      if (serverVariables) {
	        this.addLocalize(serverVariables);
	      }

	      return new Promise(function (resolve, reject) {
	        return resolve();
	      });
	    }
	  }, {
	    key: "initRestClient",
	    value: function initRestClient() {
	      this.restClient = new WidgetRestClient({
	        endpoint: this.host + '/rest'
	      });
	      return new Promise(function (resolve, reject) {
	        return resolve();
	      });
	    }
	  }, {
	    key: "initPullClient",
	    value: function initPullClient() {
	      this.pullClient = new pull_client.PullClient({
	        serverEnabled: true,
	        userId: 0,
	        siteId: this.getSiteId(),
	        restClient: this.restClient,
	        skipStorageInit: true,
	        configTimestamp: 0,
	        skipCheckRevision: true,
	        getPublicListMethod: 'imopenlines.widget.operator.get'
	      });
	      this.pullClientInited = false;
	      return new Promise(function (resolve, reject) {
	        return resolve();
	      });
	    }
	  }, {
	    key: "initCore",
	    value: function initCore() {
	      var _this2 = this;

	      var widgetVariables = {
	        common: {
	          host: this.getHost(),
	          pageMode: this.pageMode !== false,
	          copyright: this.copyright,
	          copyrightUrl: this.copyrightUrl
	        },
	        vote: {
	          messageText: this.getLocalize('BX_LIVECHAT_VOTE_TITLE'),
	          messageLike: this.getLocalize('BX_LIVECHAT_VOTE_PLUS_TITLE'),
	          messageDislike: this.getLocalize('BX_LIVECHAT_VOTE_MINUS_TITLE')
	        },
	        textMessages: {
	          bxLivechatOnlineLine1: this.getLocalize('BX_LIVECHAT_ONLINE_LINE_1'),
	          bxLivechatOnlineLine2: this.getLocalize('BX_LIVECHAT_ONLINE_LINE_2'),
	          bxLivechatOffline: this.getLocalize('BX_LIVECHAT_OFFLINE')
	        }
	      };

	      if (im_lib_utils.Utils.types.isPlainObject(this.params.styles) && (this.params.styles.backgroundColor || this.params.styles.iconColor)) {
	        widgetVariables.styles = {};

	        if (this.params.styles.backgroundColor) {
	          widgetVariables.styles.backgroundColor = this.params.styles.backgroundColor;
	        }

	        if (this.params.styles.iconColor) {
	          widgetVariables.styles.iconColor = this.params.styles.iconColor;
	        }
	      }

	      this.controller = new im_controller.Controller({
	        host: this.getHost(),
	        siteId: this.getSiteId(),
	        userId: 0,
	        languageId: this.language,
	        pull: {
	          client: this.pullClient
	        },
	        rest: {
	          client: this.restClient
	        },
	        localize: this.localize,
	        vuexBuilder: {
	          database: !im_lib_utils.Utils.browser.isIe(),
	          databaseName: 'imol/widget',
	          databaseType: ui_vue_vuex.WidgetVuexBuilder.DatabaseType.localStorage,
	          models: [WidgetModel.create().setVariables(widgetVariables)]
	        }
	      });
	      return new Promise(function (resolve, reject) {
	        _this2.controller.ready().then(function () {
	          return resolve();
	        });
	      });
	    }
	  }, {
	    key: "initWidget",
	    value: function initWidget() {
	      if (this.isUserRegistered()) {
	        this.restClient.setAuthId(this.getUserHash());
	      } else {
	        this.restClient.setAuthId(RestAuth.guest);
	      }

	      if (this.params.location && typeof LocationStyle[this.params.location] !== 'undefined') {
	        this.controller.getStore().commit('widget/common', {
	          location: this.params.location
	        });
	      }

	      this.controller.application.setPrepareFilesBeforeSaveFunction(this.prepareFileData.bind(this));
	      this.controller.addRestAnswerHandler(WidgetRestAnswerHandler.create({
	        widget: this,
	        store: this.controller.getStore(),
	        controller: this.controller
	      }));
	      return new Promise(function (resolve, reject) {
	        return resolve();
	      });
	    }
	  }, {
	    key: "initUploader",
	    value: function initUploader() {
	      var _this3 = this;

	      this.uploader = new im_lib_uploader.Uploader({
	        generatePreview: true,
	        sender: {
	          host: this.host,
	          customHeaders: {
	            'Livechat-Auth-Id': this.getUserHash()
	          },
	          actionUploadChunk: 'imopenlines.widget.disk.upload',
	          actionCommitFile: 'imopenlines.widget.disk.commit',
	          actionRollbackUpload: 'imopenlines.widget.disk.rollbackUpload'
	        }
	      });
	      this.uploader.subscribe('onStartUpload', function (event) {
	        var eventData = event.getData();
	        im_lib_logger.Logger.log('Uploader: onStartUpload', eventData);

	        _this3.controller.getStore().dispatch('files/update', {
	          chatId: _this3.getChatId(),
	          id: eventData.id,
	          fields: {
	            status: im_const.FileStatus.upload,
	            progress: 0
	          }
	        });
	      });
	      this.uploader.subscribe('onProgress', function (event) {
	        var eventData = event.getData();
	        im_lib_logger.Logger.log('Uploader: onProgress', eventData);

	        _this3.controller.getStore().dispatch('files/update', {
	          chatId: _this3.getChatId(),
	          id: eventData.id,
	          fields: {
	            status: im_const.FileStatus.upload,
	            progress: eventData.progress === 100 ? 99 : eventData.progress
	          }
	        });
	      });
	      this.uploader.subscribe('onSelectFile', function (event) {
	        var eventData = event.getData();
	        var file = eventData.file;
	        im_lib_logger.Logger.log('Uploader: onSelectFile', eventData);
	        var fileType = 'file';

	        if (file.type.toString().startsWith('image')) {
	          fileType = 'image';
	        } else if (file.type.toString().startsWith('video')) {
	          fileType = 'video';
	        }

	        _this3.controller.getStore().dispatch('files/add', {
	          chatId: _this3.getChatId(),
	          authorId: _this3.getUserId(),
	          name: eventData.file.name,
	          type: fileType,
	          extension: file.name.split('.').splice(-1)[0],
	          size: eventData.file.size,
	          image: !eventData.previewData ? false : {
	            width: eventData.previewDataWidth,
	            height: eventData.previewDataHeight
	          },
	          status: im_const.FileStatus.upload,
	          progress: 0,
	          authorName: _this3.controller.application.getCurrentUser().name,
	          urlPreview: eventData.previewData ? URL.createObjectURL(eventData.previewData) : ""
	        }).then(function (fileId) {
	          _this3.addMessage('', {
	            id: fileId,
	            source: eventData,
	            previewBlob: eventData.previewData
	          });
	        });
	      });
	      this.uploader.subscribe('onComplete', function (event) {
	        var eventData = event.getData();
	        im_lib_logger.Logger.log('Uploader: onComplete', eventData);

	        _this3.controller.getStore().dispatch('files/update', {
	          chatId: _this3.getChatId(),
	          id: eventData.id,
	          fields: {
	            status: im_const.FileStatus.wait,
	            progress: 100
	          }
	        });

	        var message = _this3.messagesQueue.find(function (message) {
	          return message.file.id === eventData.id;
	        });

	        var fileType = _this3.controller.getStore().getters['files/get'](_this3.getChatId(), message.file.id, true).type;

	        _this3.fileCommit({
	          chatId: _this3.getChatId(),
	          uploadId: eventData.result.data.file.id,
	          messageText: message.text,
	          messageId: message.id,
	          fileId: message.file.id,
	          fileType: fileType
	        }, message);
	      });
	      this.uploader.subscribe('onUploadFileError', function (event) {
	        var eventData = event.getData();
	        im_lib_logger.Logger.log('Uploader: onUploadFileError', eventData);

	        var message = _this3.messagesQueue.find(function (message) {
	          return message.file.id === eventData.id;
	        });

	        if (typeof message === 'undefined') {
	          return;
	        }

	        _this3.fileError(_this3.getChatId(), message.file.id, message.id);
	      });
	      this.uploader.subscribe('onCreateFileError', function (event) {
	        var eventData = event.getData();
	        im_lib_logger.Logger.log('Uploader: onCreateFileError', eventData);

	        var message = _this3.messagesQueue.find(function (message) {
	          return message.file.id === eventData.id;
	        });

	        _this3.fileError(_this3.getChatId(), message.file.id, message.id);
	      });
	      return new Promise(function (resolve, reject) {
	        return resolve();
	      });
	    }
	  }, {
	    key: "initComplete",
	    value: function initComplete() {
	      window.dispatchEvent(new CustomEvent('onBitrixLiveChat', {
	        detail: {
	          widget: this,
	          widgetCode: this.code,
	          widgetHost: this.host
	        }
	      }));

	      if (this.callStartFlag) {
	        this.start();
	      }

	      if (this.pageMode || this.callOpenFlag) {
	        this.open();
	      }

	      return new Promise(function (resolve, reject) {
	        return resolve();
	      });
	    }
	  }, {
	    key: "requestWidgetData",
	    value: function requestWidgetData() {
	      var _this4 = this;

	      if (!this.isReady()) {
	        console.error('LiveChatWidget.start: widget code or host is not specified');
	        return false;
	      }

	      this.widgetDataRequested = true;

	      if (!this.isUserRegistered() && (this.userRegisterData.hash || this.getUserHashCookie())) {
	        this.requestData();
	        this.inited = true;
	        this.fireInitEvent();
	      } else if (this.isConfigDataLoaded() && this.isUserRegistered()) {
	        this.requestData();
	        this.inited = true;
	        this.fireInitEvent();
	      } else {
	        this.controller.restClient.callMethod(RestMethod.widgetConfigGet, {
	          code: this.code
	        }, function (xhr) {
	          _this4.configRequestXhr = xhr;
	        }).then(function (result) {
	          _this4.configRequestXhr = null;

	          _this4.clearError();

	          _this4.controller.executeRestAnswer(RestMethod.widgetConfigGet, result);

	          if (!_this4.inited) {
	            _this4.inited = true;

	            _this4.fireInitEvent();
	          }
	        })["catch"](function (result) {
	          _this4.configRequestXhr = null;

	          _this4.setError(result.error().ex.error, result.error().ex.error_description);
	        });

	        if (this.isConfigDataLoaded()) {
	          this.inited = true;
	          this.fireInitEvent();
	        }
	      }
	    }
	  }, {
	    key: "requestData",
	    value: function requestData() {
	      var _this5 = this;

	      im_lib_logger.Logger.log('requesting data from widget');

	      if (this.requestDataSend) {
	        return true;
	      }

	      this.requestDataSend = true;

	      if (this.configRequestXhr) {
	        this.configRequestXhr.abort();
	      }

	      var query = babelHelpers.defineProperty({}, RestMethod.widgetConfigGet, [RestMethod.widgetConfigGet, {
	        code: this.code
	      }]);

	      if (this.isUserRegistered()) {
	        query[RestMethod.widgetDialogGet] = [RestMethod.widgetDialogGet, {
	          config_id: this.getConfigId(),
	          trace_data: this.getCrmTraceData(),
	          custom_data: this.getCustomData()
	        }];
	        query[im_const.RestMethodHandler.imChatGet] = [im_const.RestMethod.imChatGet, {
	          dialog_id: '$result[' + RestMethod.widgetDialogGet + '][dialogId]'
	        }];
	        query[im_const.RestMethodHandler.imDialogMessagesGetInit] = [im_const.RestMethod.imDialogMessagesGet, {
	          chat_id: '$result[' + RestMethod.widgetDialogGet + '][chatId]',
	          limit: this.controller.application.getRequestMessageLimit(),
	          convert_text: 'Y'
	        }];
	      } else {
	        query[RestMethod.widgetUserRegister] = [RestMethod.widgetUserRegister, _objectSpread({
	          config_id: '$result[' + RestMethod.widgetConfigGet + '][configId]'
	        }, this.getUserRegisterFields())];
	        query[im_const.RestMethodHandler.imChatGet] = [im_const.RestMethod.imChatGet, {
	          dialog_id: '$result[' + RestMethod.widgetUserRegister + '][dialogId]'
	        }];

	        if (this.userRegisterData.hash || this.getUserHashCookie()) {
	          query[RestMethod.widgetDialogGet] = [RestMethod.widgetDialogGet, {
	            config_id: '$result[' + RestMethod.widgetConfigGet + '][configId]',
	            trace_data: this.getCrmTraceData(),
	            custom_data: this.getCustomData()
	          }];
	          query[im_const.RestMethodHandler.imDialogMessagesGetInit] = [im_const.RestMethod.imDialogMessagesGet, {
	            chat_id: '$result[' + RestMethod.widgetDialogGet + '][chatId]',
	            limit: this.controller.application.getRequestMessageLimit(),
	            convert_text: 'Y'
	          }];
	        }

	        if (this.isUserAgreeConsent()) {
	          query[RestMethod.widgetUserConsentApply] = [RestMethod.widgetUserConsentApply, {
	            config_id: '$result[' + RestMethod.widgetConfigGet + '][configId]',
	            consent_url: location.href
	          }];
	        }
	      }

	      query[RestMethod.pullServerTime] = [RestMethod.pullServerTime, {}];
	      query[RestMethod.pullConfigGet] = [RestMethod.pullConfigGet, {
	        'CACHE': 'N'
	      }];
	      query[RestMethod.widgetUserGet] = [RestMethod.widgetUserGet, {}];
	      this.controller.restClient.callBatch(query, function (response) {
	        if (!response) {
	          _this5.requestDataSend = false;

	          _this5.setError('EMPTY_RESPONSE', 'Server returned an empty response.');

	          return false;
	        }

	        var configGet = response[RestMethod.widgetConfigGet];

	        if (configGet && configGet.error()) {
	          _this5.requestDataSend = false;

	          _this5.setError(configGet.error().ex.error, configGet.error().ex.error_description);

	          return false;
	        }

	        _this5.controller.executeRestAnswer(RestMethod.widgetConfigGet, configGet);

	        var userGetResult = response[RestMethod.widgetUserGet];

	        if (userGetResult.error()) {
	          _this5.requestDataSend = false;

	          _this5.setError(userGetResult.error().ex.error, userGetResult.error().ex.error_description);

	          return false;
	        }

	        _this5.controller.executeRestAnswer(RestMethod.widgetUserGet, userGetResult);

	        var chatGetResult = response[im_const.RestMethodHandler.imChatGet];

	        if (chatGetResult.error()) {
	          _this5.requestDataSend = false;

	          _this5.setError(chatGetResult.error().ex.error, chatGetResult.error().ex.error_description);

	          return false;
	        }

	        _this5.controller.executeRestAnswer(im_const.RestMethodHandler.imChatGet, chatGetResult);

	        var dialogGetResult = response[RestMethod.widgetDialogGet];

	        if (dialogGetResult) {
	          if (dialogGetResult.error()) {
	            _this5.requestDataSend = false;

	            _this5.setError(dialogGetResult.error().ex.error, dialogGetResult.error().ex.error_description);

	            return false;
	          }

	          _this5.controller.executeRestAnswer(RestMethod.widgetDialogGet, dialogGetResult);
	        }

	        var dialogMessagesGetResult = response[im_const.RestMethodHandler.imDialogMessagesGetInit];

	        if (dialogMessagesGetResult) {
	          if (dialogMessagesGetResult.error()) {
	            _this5.requestDataSend = false;

	            _this5.setError(dialogMessagesGetResult.error().ex.error, dialogMessagesGetResult.error().ex.error_description);

	            return false;
	          }

	          _this5.controller.getStore().dispatch('dialogues/saveDialog', {
	            dialogId: _this5.controller.application.getDialogId(),
	            chatId: _this5.controller.application.getChatId()
	          });

	          _this5.controller.executeRestAnswer(im_const.RestMethodHandler.imDialogMessagesGetInit, dialogMessagesGetResult);
	        }

	        var userRegisterResult = response[RestMethod.widgetUserRegister];

	        if (userRegisterResult) {
	          if (userRegisterResult.error()) {
	            _this5.requestDataSend = false;

	            _this5.setError(userRegisterResult.error().ex.error, userRegisterResult.error().ex.error_description);

	            return false;
	          }

	          _this5.controller.executeRestAnswer(RestMethod.widgetUserRegister, userRegisterResult);
	        }

	        var timeShift = 0;
	        var serverTimeResult = response[RestMethod.pullServerTime];

	        if (serverTimeResult && !serverTimeResult.error()) {
	          timeShift = Math.floor((new Date().getTime() - new Date(serverTimeResult.data()).getTime()) / 1000);
	        }

	        var config = null;
	        var pullConfigResult = response[RestMethod.pullConfigGet];

	        if (pullConfigResult && !pullConfigResult.error()) {
	          config = pullConfigResult.data();
	          config.server.timeShift = timeShift;
	        }

	        _this5.startPullClient(config).then(function () {
	          _this5.processSendMessages();
	        })["catch"](function (error) {
	          _this5.setError(error.ex.error, error.ex.error_description);
	        });

	        _this5.requestDataSend = false;
	      }, false, false, im_lib_utils.Utils.getLogTrackingParams({
	        name: 'widget.init.config',
	        dialog: this.controller.application.getDialogData()
	      }));
	    }
	  }, {
	    key: "prepareFileData",
	    value: function prepareFileData(files) {
	      var _this6 = this;

	      if (!im_lib_utils.Utils.types.isArray(files)) {
	        return files;
	      }

	      return files.map(function (file) {
	        var hash = (window.md5 || main_md5.md5)(_this6.getUserId() + '|' + file.id + '|' + _this6.getUserHash());

	        var urlParam = 'livechat_auth_id=' + hash + '&livechat_user_id=' + _this6.getUserId();

	        if (file.urlPreview) {
	          file.urlPreview = file.urlPreview + '&' + urlParam;
	        }

	        if (file.urlShow) {
	          file.urlShow = file.urlShow + '&' + urlParam;
	        }

	        if (file.urlDownload) {
	          file.urlDownload = file.urlDownload + '&' + urlParam;
	        }

	        return file;
	      });
	    }
	  }, {
	    key: "checkBrowserVersion",
	    value: function checkBrowserVersion() {
	      if (im_lib_utils.Utils.platform.isIos()) {
	        var version = im_lib_utils.Utils.platform.getIosVersion();

	        if (version && version <= 10) {
	          return false;
	        }
	      }

	      return true;
	    }
	  }, {
	    key: "isSameDomain",
	    value: function isSameDomain() {
	      if (typeof BX === 'undefined' || !BX.isReady) {
	        return false;
	      }

	      if (!this.options.checkSameDomain) {
	        return false;
	      }

	      return this.host.lastIndexOf('.' + location.hostname) > -1;
	    }
	    /* endregion 01. Initialize and store data */

	    /* region 02. Push & Pull */

	  }, {
	    key: "startPullClient",
	    value: function startPullClient(config) {
	      var _this7 = this;

	      var promise = new BX.Promise();

	      if (!this.getUserId() || !this.getSiteId() || !this.restClient) {
	        promise.reject({
	          ex: {
	            error: 'WIDGET_NOT_LOADED',
	            error_description: 'Widget is not loaded.'
	          }
	        });
	        return promise;
	      }

	      if (this.pullClientInited) {
	        if (!this.pullClient.isConnected()) {
	          this.pullClient.scheduleReconnect();
	        }

	        promise.resolve(true);
	        return promise;
	      }

	      this.controller.userId = this.getUserId();
	      this.pullClient.userId = this.getUserId();
	      this.pullClient.configTimestamp = config ? config.server.config_timestamp : 0;
	      this.pullClient.skipStorageInit = false;
	      this.pullClient.storage = pull_client.PullClient.StorageManager({
	        userId: this.getUserId(),
	        siteId: this.getSiteId()
	      });
	      this.pullClient.subscribe(new WidgetImPullCommandHandler({
	        store: this.controller.getStore(),
	        controller: this.controller,
	        widget: this
	      }));
	      this.pullClient.subscribe(new WidgetImopenlinesPullCommandHandler({
	        store: this.controller.getStore(),
	        controller: this.controller,
	        widget: this
	      }));
	      this.pullClient.subscribe({
	        type: pull_client.PullClient.SubscriptionType.Status,
	        callback: this.eventStatusInteraction.bind(this)
	      });
	      this.pullConnectedFirstTime = this.pullClient.subscribe({
	        type: pull_client.PullClient.SubscriptionType.Status,
	        callback: function callback(result) {
	          if (result.status === pull_client.PullClient.PullStatus.Online) {
	            promise.resolve(true);

	            _this7.pullConnectedFirstTime();
	          }
	        }
	      });

	      if (this.template) {
	        this.template.$Bitrix.PullClient.set(this.pullClient);
	      }

	      this.pullClient.start(_objectSpread(_objectSpread({}, config), {}, {
	        skipReconnectToLastSession: true
	      }))["catch"](function () {
	        promise.reject({
	          ex: {
	            error: 'PULL_CONNECTION_ERROR',
	            error_description: 'Pull is not connected.'
	          }
	        });
	      });
	      this.pullClientInited = true;
	      return promise;
	    }
	  }, {
	    key: "stopPullClient",
	    value: function stopPullClient() {
	      if (this.pullClient) {
	        this.pullClient.stop(pull_client.PullClient.CloseReasons.MANUAL, 'Closed manually');
	      }
	    }
	  }, {
	    key: "recoverPullConnection",
	    value: function recoverPullConnection() {
	      // this.pullClient.session.mid = 0; // TODO specially for disable pull history, remove after recode im
	      this.pullClient.restart(pull_client.PullClient.CloseReasons.MANUAL, 'Restart after click by connection status button.');
	    }
	  }, {
	    key: "eventStatusInteraction",
	    value: function eventStatusInteraction(data) {
	      var _this8 = this;

	      if (data.status === pull_client.PullClient.PullStatus.Online) {
	        this.offline = false;

	        if (this.pullRequestMessage) {
	          this.controller.pullBaseHandler.option.skip = true;
	          im_lib_logger.Logger.warn('Requesting getDialogUnread after going online');
	          main_core_events.EventEmitter.emitAsync(im_const.EventType.dialog.requestUnread, {
	            chatId: this.controller.application.getChatId()
	          }).then(function () {
	            main_core_events.EventEmitter.emit(im_const.EventType.dialog.scrollOnStart, {
	              chatId: _this8.controller.application.getChatId()
	            });
	            _this8.controller.pullBaseHandler.option.skip = false;

	            _this8.processSendMessages();
	          })["catch"](function () {
	            _this8.controller.pullBaseHandler.option.skip = false;
	          });
	          this.pullRequestMessage = false;
	        } else {
	          this.readMessage();
	          this.processSendMessages();
	        }
	      } else if (data.status === pull_client.PullClient.PullStatus.Offline) {
	        this.pullRequestMessage = true;
	        this.offline = true;
	      }
	    }
	    /* endregion 02. Push & Pull */

	    /* region 03. Template engine */

	  }, {
	    key: "attachTemplate",
	    value: function attachTemplate() {
	      if (this.template) {
	        this.controller.getStore().commit('widget/common', {
	          showed: true
	        });
	        return true;
	      }

	      this.rootNode.innerHTML = '';
	      this.rootNode.appendChild(document.createElement('div'));
	      var application = this;
	      return this.controller.createVue(application, {
	        el: this.rootNode.firstChild,
	        template: '<bx-livechat/>',
	        beforeCreate: function beforeCreate() {
	          application.sendEvent({
	            type: SubscriptionType.widgetOpen,
	            data: {}
	          });
	          application.template = this;

	          if (main_core_minimal.ZIndexManager !== undefined) {
	            var stack = main_core_minimal.ZIndexManager.getOrAddStack(document.body);
	            stack.setBaseIndex(1000000); // some big value

	            this.$bitrix.Data.set('zIndexStack', stack);
	          }
	        },
	        destroyed: function destroyed() {
	          application.sendEvent({
	            type: SubscriptionType.widgetClose,
	            data: {}
	          });
	          application.template = null;
	          application.templateAttached = false;
	          application.rootNode.innerHTML = '';
	        }
	      }).then(function () {
	        return new Promise(function (resolve, reject) {
	          return resolve();
	        });
	      });
	    }
	  }, {
	    key: "detachTemplate",
	    value: function detachTemplate() {
	      if (!this.template) {
	        return true;
	      }

	      this.template.$destroy();
	      return true;
	    }
	  }, {
	    key: "mutateTemplateComponent",
	    value: function mutateTemplateComponent(id, params) {
	      return ui_vue.WidgetVue.mutateComponent(id, params);
	    }
	    /* endregion 03. Template engine */

	    /* region 04. Rest methods */

	  }, {
	    key: "addMessage",
	    value: function addMessage() {
	      var _this9 = this;

	      var text = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
	      var file = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

	      if (!text && !file) {
	        return false;
	      }

	      var quoteId = this.controller.getStore().getters['dialogues/getQuoteId'](this.controller.application.getDialogId());

	      if (quoteId) {
	        var quoteMessage = this.controller.getStore().getters['messages/getMessage'](this.controller.application.getChatId(), quoteId);

	        if (quoteMessage) {
	          var user = null;

	          if (quoteMessage.authorId) {
	            user = this.controller.getStore().getters['users/get'](quoteMessage.authorId);
	          }

	          var files = this.controller.getStore().getters['files/getList'](this.controller.application.getChatId());
	          var message = [];
	          message.push('-'.repeat(54));
	          message.push((user && user.name ? user.name : this.getLocalize('BX_LIVECHAT_SYSTEM_MESSAGE')) + ' [' + im_lib_utils.Utils.date.format(quoteMessage.date, null, this.getLocalize()) + ']');
	          message.push(im_lib_utils.Utils.text.quote(quoteMessage.text, quoteMessage.params, files, this.getLocalize()));
	          message.push('-'.repeat(54));
	          message.push(text);
	          text = message.join("\n");
	          this.quoteMessageClear();
	        }
	      }

	      im_lib_logger.Logger.warn('addMessage', text, file);

	      if (!this.controller.application.isUnreadMessagesLoaded()) {
	        this.sendMessage({
	          id: 0,
	          text: text,
	          file: file
	        });
	        this.processSendMessages();
	        return true;
	      }

	      var params = {};

	      if (file) {
	        params.FILE_ID = [file.id];
	      }

	      this.controller.getStore().dispatch('messages/add', {
	        chatId: this.getChatId(),
	        authorId: this.getUserId(),
	        text: text,
	        params: params,
	        sending: !file
	      }).then(function (messageId) {
	        if (!_this9.isDialogStart()) {
	          _this9.controller.getStore().commit('widget/common', {
	            dialogStart: true
	          });
	        }

	        main_core_events.EventEmitter.emit(im_const.EventType.dialog.scrollToBottom, {
	          chatId: _this9.getChatId(),
	          cancelIfScrollChange: true
	        });

	        _this9.messagesQueue.push({
	          id: messageId,
	          text: text,
	          file: file,
	          sending: false
	        });

	        if (_this9.getChatId()) {
	          _this9.processSendMessages();
	        } else {
	          _this9.requestData();
	        }
	      });
	      return true;
	    }
	  }, {
	    key: "uploadFile",
	    value: function uploadFile(event) {
	      if (!event) {
	        return false;
	      }

	      if (!this.getChatId()) {
	        this.requestData();
	      }

	      this.uploader.addFilesFromEvent(event);
	    }
	  }, {
	    key: "cancelUploadFile",
	    value: function cancelUploadFile(fileId) {
	      var _this10 = this;

	      var element = this.messagesQueue.find(function (element) {
	        return element.file && element.file.id === fileId;
	      });

	      if (element) {
	        this.uploader.deleteTask(fileId);

	        if (element.xhr) {
	          element.xhr.abort();
	        }

	        this.controller.getStore().dispatch('messages/delete', {
	          chatId: this.getChatId(),
	          id: element.id
	        }).then(function () {
	          _this10.controller.getStore().dispatch('files/delete', {
	            chatId: _this10.getChatId(),
	            id: element.file.id
	          });

	          _this10.messagesQueue = _this10.messagesQueue.filter(function (el) {
	            return el.id !== element.id;
	          });
	        });
	      }
	    }
	  }, {
	    key: "processSendMessages",
	    value: function processSendMessages() {
	      var _this11 = this;

	      if (!this.getDiskFolderId()) {
	        this.requestDiskFolderId().then(function () {
	          _this11.processSendMessages();
	        })["catch"](function () {
	          im_lib_logger.Logger.warn('uploadFile', 'Error get disk folder id');
	          return false;
	        });
	        return false;
	      }

	      if (this.offline) {
	        return false;
	      }

	      this.messagesQueue.filter(function (element) {
	        return !element.sending;
	      }).forEach(function (element) {
	        element.sending = true;

	        if (element.file) {
	          _this11.sendMessageWithFile(element);
	        } else {
	          _this11.sendMessage(element);
	        }
	      });
	      return true;
	    }
	  }, {
	    key: "sendMessage",
	    value: function sendMessage(message) {
	      var _this12 = this;

	      this.controller.application.stopWriting();
	      var quiteId = this.controller.getStore().getters['dialogues/getQuoteId'](this.getDialogId());

	      if (quiteId) {
	        var quoteMessage = this.controller.getStore().getters['messages/getMessage'](this.getChatId(), quiteId);

	        if (quoteMessage) {
	          var user = this.controller.getStore().getters['users/get'](quoteMessage.authorId);
	          var newMessage = [];
	          newMessage.push("------------------------------------------------------");
	          newMessage.push(user.name ? user.name : this.getLocalize('BX_LIVECHAT_SYSTEM_MESSAGE'));
	          newMessage.push(quoteMessage.text);
	          newMessage.push('------------------------------------------------------');
	          newMessage.push(message.text);
	          message.text = newMessage.join("\n");
	          this.quoteMessageClear();
	        }
	      }

	      message.chatId = this.getChatId();
	      this.controller.restClient.callMethod(im_const.RestMethod.imMessageAdd, {
	        'TEMPLATE_ID': message.id,
	        'CHAT_ID': message.chatId,
	        'MESSAGE': message.text
	      }, null, null, im_lib_utils.Utils.getLogTrackingParams({
	        name: im_const.RestMethod.imMessageAdd,
	        data: {
	          timMessageType: 'text'
	        },
	        dialog: this.getDialogData()
	      })).then(function (response) {
	        _this12.controller.executeRestAnswer(im_const.RestMethodHandler.imMessageAdd, response, message);
	      })["catch"](function (error) {
	        _this12.controller.executeRestAnswer(im_const.RestMethodHandler.imMessageAdd, error, message);
	      });
	      return true;
	    }
	  }, {
	    key: "sendMessageWithFile",
	    value: function sendMessageWithFile(message) {
	      this.controller.application.stopWriting();
	      var diskFolderId = this.getDiskFolderId();
	      message.chatId = this.getChatId();
	      this.uploader.senderOptions.customHeaders['Livechat-Dialog-Id'] = this.getDialogId();
	      this.uploader.senderOptions.customHeaders['Livechat-Auth-Id'] = this.getUserHash();
	      this.uploader.addTask({
	        taskId: message.file.id,
	        fileData: message.file.source.file,
	        fileName: message.file.source.file.name,
	        generateUniqueName: true,
	        diskFolderId: diskFolderId,
	        previewBlob: message.file.previewBlob,
	        chunkSize: this.localize.isCloud ? im_lib_uploader.Uploader.CLOUD_MAX_CHUNK_SIZE : im_lib_uploader.Uploader.BOX_MIN_CHUNK_SIZE
	      });
	    }
	  }, {
	    key: "fileError",
	    value: function fileError(chatId, fileId) {
	      var messageId = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
	      this.controller.getStore().dispatch('files/update', {
	        chatId: chatId,
	        id: fileId,
	        fields: {
	          status: im_const.FileStatus.error,
	          progress: 0
	        }
	      });

	      if (messageId) {
	        this.controller.getStore().dispatch('messages/actionError', {
	          chatId: chatId,
	          id: messageId,
	          retry: false
	        });
	      }
	    }
	  }, {
	    key: "requestDiskFolderId",
	    value: function requestDiskFolderId() {
	      var _this13 = this;

	      if (this.requestDiskFolderPromise) {
	        return this.requestDiskFolderPromise;
	      }

	      this.requestDiskFolderPromise = new Promise(function (resolve, reject) {
	        if (_this13.flagRequestDiskFolderIdSended || _this13.getDiskFolderId()) {
	          _this13.flagRequestDiskFolderIdSended = false;
	          resolve();
	          return true;
	        }

	        _this13.flagRequestDiskFolderIdSended = true;

	        _this13.controller.restClient.callMethod(im_const.RestMethod.imDiskFolderGet, {
	          chat_id: _this13.controller.application.getChatId()
	        }).then(function (response) {
	          _this13.controller.executeRestAnswer(im_const.RestMethodHandler.imDiskFolderGet, response);

	          _this13.flagRequestDiskFolderIdSended = false;
	          resolve();
	        })["catch"](function (error) {
	          _this13.flagRequestDiskFolderIdSended = false;

	          _this13.controller.executeRestAnswer(im_const.RestMethodHandler.imDiskFolderGet, error);

	          reject();
	        });
	      });
	      return this.requestDiskFolderPromise;
	    }
	  }, {
	    key: "fileCommit",
	    value: function fileCommit(params, message) {
	      var _this14 = this;

	      this.controller.restClient.callMethod(im_const.RestMethod.imDiskFileCommit, {
	        chat_id: params.chatId,
	        upload_id: params.uploadId,
	        message: params.messageText,
	        template_id: params.messageId,
	        file_template_id: params.fileId
	      }, null, null, im_lib_utils.Utils.getLogTrackingParams({
	        name: im_const.RestMethod.imDiskFileCommit,
	        data: {
	          timMessageType: params.fileType
	        },
	        dialog: this.getDialogData()
	      })).then(function (response) {
	        _this14.controller.executeRestAnswer(im_const.RestMethodHandler.imDiskFileCommit, response, message);
	      })["catch"](function (error) {
	        _this14.controller.executeRestAnswer(im_const.RestMethodHandler.imDiskFileCommit, error, message);
	      });
	      return true;
	    }
	  }, {
	    key: "getDialogHistory",
	    value: function getDialogHistory(lastId) {
	      var _this15 = this;

	      var limit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.controller.application.getRequestMessageLimit();
	      this.controller.restClient.callMethod(im_const.RestMethod.imDialogMessagesGet, {
	        'CHAT_ID': this.getChatId(),
	        'LAST_ID': lastId,
	        'LIMIT': limit,
	        'CONVERT_TEXT': 'Y'
	      }).then(function (result) {
	        _this15.controller.executeRestAnswer(im_const.RestMethodHandler.imDialogMessagesGet, result);

	        _this15.template.$emit(im_const.EventType.dialog.requestHistoryResult, {
	          count: result.data().messages.length
	        });
	      })["catch"](function (result) {
	        _this15.template.$emit(im_const.EventType.dialog.requestHistoryResult, {
	          error: result.error().ex
	        });
	      });
	    }
	  }, {
	    key: "getDialogUnread",
	    value: function getDialogUnread(lastId) {
	      var _this16 = this;

	      var limit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.controller.application.getRequestMessageLimit();
	      var promise = new BX.Promise();

	      if (!lastId) {
	        lastId = this.controller.getStore().getters['messages/getLastId'](this.controller.application.getChatId());
	      }

	      if (!lastId) {
	        this.template.$emit(im_const.EventType.dialog.requestUnreadResult, {
	          error: {
	            error: 'LAST_ID_EMPTY',
	            error_description: 'LastId is empty.'
	          }
	        });
	        promise.reject();
	        return promise;
	      }

	      this.controller.application.readMessage(lastId, true, true).then(function () {
	        var _query2;

	        var query = (_query2 = {}, babelHelpers.defineProperty(_query2, im_const.RestMethodHandler.imDialogRead, [im_const.RestMethod.imDialogRead, {
	          dialog_id: _this16.getDialogId(),
	          message_id: lastId
	        }]), babelHelpers.defineProperty(_query2, im_const.RestMethodHandler.imChatGet, [im_const.RestMethod.imChatGet, {
	          dialog_id: _this16.getDialogId()
	        }]), babelHelpers.defineProperty(_query2, im_const.RestMethodHandler.imDialogMessagesGetUnread, [im_const.RestMethod.imDialogMessagesGet, {
	          chat_id: _this16.getChatId(),
	          first_id: lastId,
	          limit: limit,
	          convert_text: 'Y'
	        }]), _query2);

	        _this16.controller.restClient.callBatch(query, function (response) {
	          if (!response) {
	            _this16.template.$emit(im_const.EventType.dialog.requestUnreadResult, {
	              error: {
	                error: 'EMPTY_RESPONSE',
	                error_description: 'Server returned an empty response.'
	              }
	            });

	            promise.reject();
	            return false;
	          }

	          var chatGetResult = response[im_const.RestMethodHandler.imChatGet];

	          if (!chatGetResult.error()) {
	            _this16.controller.executeRestAnswer(im_const.RestMethodHandler.imChatGet, chatGetResult);
	          }

	          var dialogMessageUnread = response[im_const.RestMethodHandler.imDialogMessagesGetUnread];

	          if (dialogMessageUnread.error()) {
	            _this16.template.$emit(im_const.EventType.dialog.requestUnreadResult, {
	              error: dialogMessageUnread.error().ex
	            });
	          } else {
	            _this16.controller.executeRestAnswer(im_const.RestMethodHandler.imDialogMessagesGetUnread, dialogMessageUnread);

	            _this16.template.$emit(im_const.EventType.dialog.requestUnreadResult, {
	              firstMessageId: dialogMessageUnread.data().messages.length > 0 ? dialogMessageUnread.data().messages[0].id : 0,
	              count: dialogMessageUnread.data().messages.length
	            });
	          }

	          promise.fulfill(response);
	        }, false, false, im_lib_utils.Utils.getLogTrackingParams({
	          name: im_const.RestMethodHandler.imDialogMessagesGetUnread,
	          dialog: _this16.getDialogData()
	        }));
	      });
	      return promise;
	    }
	  }, {
	    key: "retrySendMessage",
	    value: function retrySendMessage(message) {
	      if (this.messagesQueue.find(function (el) {
	        return el.id === message.id;
	      })) {
	        return false;
	      }

	      this.messagesQueue.push({
	        id: message.id,
	        text: message.text,
	        sending: false
	      });
	      this.controller.application.setSendingMessageFlag(message.id);
	      this.processSendMessages();
	    }
	  }, {
	    key: "readMessage",
	    value: function readMessage(messageId) {
	      if (this.offline) {
	        return false;
	      }

	      return this.controller.application.readMessage(messageId);
	    }
	  }, {
	    key: "reactMessage",
	    value: function reactMessage(id, reaction) {
	      this.controller.application.reactMessage(id, reaction.type, reaction.action);
	    }
	  }, {
	    key: "execMessageKeyboardCommand",
	    value: function execMessageKeyboardCommand(data) {
	      if (data.action === 'ACTION' && data.params.action === 'LIVECHAT') {
	        var _data$params = data.params,
	            _dialogId = _data$params.dialogId,
	            _messageId = _data$params.messageId;
	        var values = JSON.parse(data.params.value);
	        var sessionId = parseInt(values.SESSION_ID);

	        if (sessionId !== this.getSessionId() || this.isSessionClose()) {
	          alert(this.localize.BX_LIVECHAT_ACTION_EXPIRED);
	          return false;
	        }

	        this.controller.restClient.callMethod(RestMethod.widgetActionSend, {
	          'MESSAGE_ID': _messageId,
	          'DIALOG_ID': _dialogId,
	          'ACTION_VALUE': data.params.value
	        });
	        return true;
	      }

	      if (data.action !== 'COMMAND') {
	        return false;
	      }

	      var _data$params2 = data.params,
	          dialogId = _data$params2.dialogId,
	          messageId = _data$params2.messageId,
	          botId = _data$params2.botId,
	          command = _data$params2.command,
	          params = _data$params2.params;
	      this.controller.restClient.callMethod(im_const.RestMethod.imMessageCommand, {
	        'MESSAGE_ID': messageId,
	        'DIALOG_ID': dialogId,
	        'BOT_ID': botId,
	        'COMMAND': command,
	        'COMMAND_PARAMS': params
	      });
	      return true;
	    }
	  }, {
	    key: "quoteMessageClear",
	    value: function quoteMessageClear() {
	      this.controller.getStore().dispatch('dialogues/update', {
	        dialogId: this.controller.application.getDialogId(),
	        fields: {
	          quoteId: 0
	        }
	      });
	    }
	  }, {
	    key: "sendDialogVote",
	    value: function sendDialogVote(result) {
	      var _this17 = this;

	      if (!this.getSessionId()) {
	        return false;
	      }

	      this.controller.restClient.callMethod(RestMethod.widgetVoteSend, {
	        'SESSION_ID': this.getSessionId(),
	        'ACTION': result
	      })["catch"](function (result) {
	        _this17.controller.getStore().commit('widget/dialog', {
	          userVote: VoteType.none
	        });
	      });
	      this.sendEvent({
	        type: SubscriptionType.userVote,
	        data: {
	          vote: result
	        }
	      });
	    }
	  }, {
	    key: "getHtmlHistory",
	    value: function getHtmlHistory() {
	      var chatId = this.getChatId();

	      if (chatId <= 0) {
	        console.error('Incorrect chatId value');
	      }

	      var config = {
	        chatId: this.getChatId()
	      };
	      this.requestControllerAction('imopenlines.widget.history.download', config).then(function (response) {
	        var contentType = response.headers.get('Content-Type');

	        if (contentType.startsWith('application/json')) {
	          return response.json();
	        }

	        return response.blob();
	      }).then(function (result) {
	        if (result instanceof Blob) {
	          var url = window.URL.createObjectURL(result);
	          var a = document.createElement('a');
	          a.href = url;
	          a.download = chatId + '.html';
	          document.body.appendChild(a);
	          a.click();
	          a.remove();
	        } else if (result.hasOwnProperty('errors')) {
	          console.error(result.errors[0]);
	        } else {
	          console.error('Unknown error.');
	        }
	      })["catch"](function () {
	        return console.error('Fetch error.');
	      });
	    }
	    /**
	     * Basic method to run actions.
	     * If you need to extend it, check BX.ajax.runAction to extend this method.
	     */

	  }, {
	    key: "requestControllerAction",
	    value: function requestControllerAction(action, config) {
	      var host = this.host ? this.host : '';
	      var ajaxEndpoint = '/bitrix/services/main/ajax.php';
	      var url = new URL(ajaxEndpoint, host);
	      url.searchParams.set('action', action);
	      var formData = new FormData();

	      for (var key in config) {
	        if (config.hasOwnProperty(key)) {
	          formData.append(key, config[key]);
	        }
	      }

	      return fetch(url, {
	        method: 'POST',
	        headers: {
	          'Livechat-Auth-Id': this.getUserHash()
	        },
	        body: formData
	      });
	    }
	  }, {
	    key: "sendConsentDecision",
	    value: function sendConsentDecision(result) {
	      result = result === true;
	      this.controller.getStore().commit('widget/dialog', {
	        userConsent: result
	      });

	      if (result && this.isUserRegistered()) {
	        this.controller.restClient.callMethod(RestMethod.widgetUserConsentApply, {
	          config_id: this.getConfigId(),
	          consent_url: location.href
	        });
	      }
	    }
	    /* endregion 05. Templates and template interaction */

	    /* region 05. Widget interaction and utils */

	  }, {
	    key: "start",
	    value: function start() {
	      if (!this.controller || !this.controller.getStore()) {
	        this.callStartFlag = true;
	        return true;
	      }

	      if (this.isSessionActive()) {
	        this.requestWidgetData();
	      }

	      return true;
	    }
	  }, {
	    key: "open",
	    value: function open() {
	      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	      clearTimeout(this.openTimeout);

	      if (!this.controller.getStore()) {
	        this.callOpenFlag = true;
	        return true;
	      }

	      if (!params.openFromButton && this.buttonInstance) {
	        this.buttonInstance.wm.showById('openline_livechat');
	      }

	      if (!this.checkBrowserVersion()) {
	        this.setError('OLD_BROWSER_LOCALIZED', this.localize.BX_LIVECHAT_OLD_BROWSER);
	      } else if (im_lib_utils.Utils.versionCompare(ui_vue.WidgetVue.version(), '2.1') < 0) {
	        alert(this.localize.BX_LIVECHAT_OLD_VUE);
	        console.error("LiveChatWidget.error: OLD_VUE_VERSION (".concat(this.localize.BX_LIVECHAT_OLD_VUE_DEV.replace('#CURRENT_VERSION#', ui_vue.WidgetVue.version()), ")"));
	        return false;
	      } else if (this.isSameDomain()) {
	        this.setError('LIVECHAT_SAME_DOMAIN', this.localize.BX_LIVECHAT_SAME_DOMAIN);
	      } else if (!this.isWidgetDataRequested()) {
	        this.requestWidgetData();
	      }

	      this.attachTemplate();
	    }
	  }, {
	    key: "close",
	    value: function close() {
	      if (this.pageMode) {
	        return false;
	      }

	      if (this.buttonInstance) {
	        this.buttonInstance.onWidgetClose();
	      }

	      this.detachTemplate();
	    }
	  }, {
	    key: "showNotification",
	    value: function showNotification(params) {
	      if (!this.controller || !this.controller.getStore()) {
	        console.error('LiveChatWidget.showNotification: method can be called after fired event - onBitrixLiveChat');
	        return false;
	      } // TODO show popup notification and set badge on button
	      // operatorName
	      // notificationText
	      // counter

	    }
	  }, {
	    key: "fireInitEvent",
	    value: function fireInitEvent() {
	      if (this.initEventFired) {
	        return true;
	      }

	      this.sendEvent({
	        type: SubscriptionType.configLoaded,
	        data: {}
	      });

	      if (this.controller.getStore().state.widget.common.reopen) {
	        this.open();
	      }

	      this.initEventFired = true;
	      return true;
	    }
	  }, {
	    key: "isReady",
	    value: function isReady() {
	      return this.ready;
	    }
	  }, {
	    key: "isInited",
	    value: function isInited() {
	      return this.inited;
	    }
	  }, {
	    key: "isUserRegistered",
	    value: function isUserRegistered() {
	      return !!this.getUserHash();
	    }
	  }, {
	    key: "isConfigDataLoaded",
	    value: function isConfigDataLoaded() {
	      return this.controller.getStore().state.widget.common.configId;
	    }
	  }, {
	    key: "isWidgetDataRequested",
	    value: function isWidgetDataRequested() {
	      return this.widgetDataRequested;
	    }
	  }, {
	    key: "isChatLoaded",
	    value: function isChatLoaded() {
	      return this.controller.getStore().state.application.dialog.chatId > 0;
	    }
	  }, {
	    key: "isSessionActive",
	    value: function isSessionActive() {
	      return !this.controller.getStore().state.widget.dialog.sessionClose;
	    }
	  }, {
	    key: "isUserAgreeConsent",
	    value: function isUserAgreeConsent() {
	      return this.controller.getStore().state.widget.dialog.userConsent;
	    }
	  }, {
	    key: "getCrmTraceData",
	    value: function getCrmTraceData() {
	      var traceData = '';

	      if (!this.buttonInstance) {
	        return traceData;
	      }

	      if (typeof this.buttonInstance.getTrace !== 'function') {
	        traceData = this.buttonInstance.getTrace();
	      } else if (typeof this.buttonInstance.b24Tracker !== 'undefined' && typeof this.buttonInstance.b24Tracker.guest !== 'undefined') {
	        traceData = this.buttonInstance.b24Tracker.guest.getTrace();
	      }

	      return traceData;
	    }
	  }, {
	    key: "getCustomData",
	    value: function getCustomData() {
	      var customData = [];

	      if (this.customData.length > 0) {
	        customData = this.customData;
	      } else {
	        customData = [{
	          MESSAGE: this.localize.BX_LIVECHAT_EXTRA_SITE + ': [URL]' + location.href + '[/URL]'
	        }];
	      }

	      return JSON.stringify(customData);
	    }
	  }, {
	    key: "isUserLoaded",
	    value: function isUserLoaded() {
	      return this.controller.getStore().state.widget.user.id > 0;
	    }
	  }, {
	    key: "getSiteId",
	    value: function getSiteId() {
	      return this.host.replace(/(http.?:\/\/)|([:.\\\/])/mg, "") + this.code;
	    }
	  }, {
	    key: "getHost",
	    value: function getHost() {
	      return this.host;
	    }
	  }, {
	    key: "getConfigId",
	    value: function getConfigId() {
	      return this.controller.getStore().state.widget.common.configId;
	    }
	  }, {
	    key: "isDialogStart",
	    value: function isDialogStart() {
	      return this.controller.getStore().state.widget.common.dialogStart;
	    }
	  }, {
	    key: "getChatId",
	    value: function getChatId() {
	      return this.controller.getStore().state.application.dialog.chatId;
	    }
	  }, {
	    key: "getDialogId",
	    value: function getDialogId() {
	      return this.controller.getStore().state.application.dialog.dialogId;
	    }
	  }, {
	    key: "getDiskFolderId",
	    value: function getDiskFolderId() {
	      return this.controller.getStore().state.application.dialog.diskFolderId;
	    }
	  }, {
	    key: "getDialogData",
	    value: function getDialogData() {
	      var dialogId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getDialogId();
	      return this.controller.getStore().state.dialogues.collection[dialogId];
	    }
	  }, {
	    key: "getSessionId",
	    value: function getSessionId() {
	      return this.controller.getStore().state.widget.dialog.sessionId;
	    }
	  }, {
	    key: "isSessionClose",
	    value: function isSessionClose() {
	      return this.controller.getStore().state.widget.dialog.sessionClose;
	    }
	  }, {
	    key: "getUserHash",
	    value: function getUserHash() {
	      return this.controller.getStore().state.widget.user.hash;
	    }
	  }, {
	    key: "getUserHashCookie",
	    value: function getUserHashCookie() {
	      var userHash = '';
	      var cookie = im_lib_cookie.Cookie.get(null, 'LIVECHAT_HASH');

	      if (typeof cookie === 'string' && cookie.match(/^[a-f0-9]{32}$/)) {
	        userHash = cookie;
	      } else {
	        var _cookie = im_lib_cookie.Cookie.get(this.getSiteId(), 'LIVECHAT_HASH');

	        if (typeof _cookie === 'string' && _cookie.match(/^[a-f0-9]{32}$/)) {
	          userHash = _cookie;
	        }
	      }

	      return userHash;
	    }
	  }, {
	    key: "getUserId",
	    value: function getUserId() {
	      return this.controller.getStore().state.widget.user.id;
	    }
	  }, {
	    key: "getUserData",
	    value: function getUserData() {
	      if (!this.controller || !this.controller.getStore()) {
	        console.error('LiveChatWidget.getUserData: method can be called after fired event - onBitrixLiveChat');
	        return false;
	      }

	      return this.controller.getStore().state.widget.user;
	    }
	  }, {
	    key: "getUserRegisterFields",
	    value: function getUserRegisterFields() {
	      return {
	        'name': this.userRegisterData.name || '',
	        'last_name': this.userRegisterData.lastName || '',
	        'avatar': this.userRegisterData.avatar || '',
	        'email': this.userRegisterData.email || '',
	        'www': this.userRegisterData.www || '',
	        'gender': this.userRegisterData.gender || '',
	        'position': this.userRegisterData.position || '',
	        'user_hash': this.userRegisterData.hash || this.getUserHashCookie() || '',
	        'consent_url': this.controller.getStore().state.widget.common.consentUrl ? location.href : '',
	        'trace_data': this.getCrmTraceData(),
	        'custom_data': this.getCustomData()
	      };
	    }
	  }, {
	    key: "getWidgetLocationCode",
	    value: function getWidgetLocationCode() {
	      return LocationStyle[this.controller.getStore().state.widget.common.location];
	    }
	  }, {
	    key: "setUserRegisterData",
	    value: function setUserRegisterData(params) {
	      if (!this.controller || !this.controller.getStore()) {
	        console.error('LiveChatWidget.getUserData: method can be called after fired event - onBitrixLiveChat');
	        return false;
	      }

	      var validUserFields = ['hash', 'name', 'lastName', 'avatar', 'email', 'www', 'gender', 'position'];

	      if (!im_lib_utils.Utils.types.isPlainObject(params)) {
	        console.error("%cLiveChatWidget.setUserData: params is not a object", "color: black;");
	        return false;
	      }

	      for (var field in this.userRegisterData) {
	        if (!this.userRegisterData.hasOwnProperty(field)) {
	          continue;
	        }

	        if (!params[field]) {
	          delete this.userRegisterData[field];
	        }
	      }

	      for (var _field in params) {
	        if (!params.hasOwnProperty(_field)) {
	          continue;
	        }

	        if (validUserFields.indexOf(_field) === -1) {
	          console.warn("%cLiveChatWidget.setUserData: user field is not set, because you are trying to set an unknown field (%c".concat(_field, "%c)"), "color: black;", "font-weight: bold; color: red", "color: black");
	          continue;
	        }

	        this.userRegisterData[_field] = params[_field];
	      }

	      if (this.userRegisterData.hash && this.getUserHash() && this.userRegisterData.hash !== this.getUserHash()) {
	        this.setNewAuthToken(this.userRegisterData.hash);
	      }
	    }
	  }, {
	    key: "setNewAuthToken",
	    value: function setNewAuthToken() {
	      var authToken = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
	      this.controller.getStoreBuilder().clearModelState();
	      im_lib_cookie.Cookie.set(null, 'LIVECHAT_HASH', '', {
	        expires: 365 * 86400,
	        path: '/'
	      });
	      this.controller.restClient.setAuthId(RestAuth.guest, authToken);
	    }
	  }, {
	    key: "setOption",
	    value: function setOption(name, value) {
	      this.options[name] = value;
	      return true;
	    }
	  }, {
	    key: "setCustomData",
	    value: function setCustomData(params) {
	      if (!this.controller || !this.controller.getStore()) {
	        console.error('LiveChatWidget.getUserData: method can be called after fired event - onBitrixLiveChat');
	        return false;
	      }

	      var result = [];

	      if (params instanceof Array) {
	        params.forEach(function (element) {
	          if (element && babelHelpers["typeof"](element) === 'object') {
	            result.push(element);
	          }
	        });

	        if (result.length <= 0) {
	          console.error('LiveChatWidget.setCustomData: params is empty');
	          return false;
	        }
	      } else {
	        if (!params) {
	          return false;
	        }

	        result = [{
	          'MESSAGE': params
	        }];
	      }

	      this.customData = this.customData.concat(result);
	      return true;
	    }
	  }, {
	    key: "setError",
	    value: function setError() {
	      var code = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
	      var description = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
	      console.error("LiveChatWidget.error: ".concat(code, " (").concat(description, ")"));
	      var localizeDescription = '';

	      if (code === 'LIVECHAT_AUTH_FAILED') {
	        localizeDescription = this.getLocalize('BX_LIVECHAT_AUTH_FAILED').replace('#LINK_START#', '<a href="javascript:void();" onclick="location.reload()">').replace('#LINK_END#', '</a>');
	        this.setNewAuthToken();
	      } else if (code === 'LIVECHAT_AUTH_PORTAL_USER') {
	        localizeDescription = this.getLocalize('BX_LIVECHAT_PORTAL_USER_NEW').replace('#LINK_START#', '<a href="' + this.host + '">').replace('#LINK_END#', '</a>');
	      } else if (code === 'LIVECHAT_SAME_DOMAIN') {
	        localizeDescription = this.getLocalize('BX_LIVECHAT_SAME_DOMAIN');
	        var link = this.getLocalize('BX_LIVECHAT_SAME_DOMAIN_LINK');

	        if (link) {
	          localizeDescription += '<br><br><a href="' + link + '">' + this.getLocalize('BX_LIVECHAT_SAME_DOMAIN_MORE') + '</a>';
	        }
	      } else if (code.endsWith('LOCALIZED')) {
	        localizeDescription = description;
	      }

	      this.controller.getStore().commit('application/set', {
	        error: {
	          active: true,
	          code: code,
	          description: localizeDescription
	        }
	      });
	    }
	  }, {
	    key: "clearError",
	    value: function clearError() {
	      this.controller.getStore().commit('application/set', {
	        error: {
	          active: false,
	          code: '',
	          description: ''
	        }
	      });
	    }
	    /**
	     *
	     * @param params {Object}
	     * @returns {Function|Boolean} - Unsubscribe callback function or False
	     */

	  }, {
	    key: "subscribe",
	    value: function subscribe(params) {
	      if (!im_lib_utils.Utils.types.isPlainObject(params)) {
	        console.error("%cLiveChatWidget.subscribe: params is not a object", "color: black;");
	        return false;
	      }

	      if (!SubscriptionTypeCheck.includes(params.type)) {
	        console.error("%cLiveChatWidget.subscribe: subscription type is not correct (%c".concat(params.type, "%c)"), "color: black;", "font-weight: bold; color: red", "color: black");
	        return false;
	      }

	      if (typeof params.callback !== 'function') {
	        console.error("%cLiveChatWidget.subscribe: callback is not a function (%c".concat(babelHelpers["typeof"](params.callback), "%c)"), "color: black;", "font-weight: bold; color: red", "color: black");
	        return false;
	      }

	      if (typeof this.subscribers[params.type] === 'undefined') {
	        this.subscribers[params.type] = [];
	      }

	      this.subscribers[params.type].push(params.callback);
	      return function () {
	        this.subscribers[params.type] = this.subscribers[params.type].filter(function (element) {
	          return element !== params.callback;
	        });
	      }.bind(this);
	    }
	    /**
	     *
	     * @param params {Object}
	     * @returns {boolean}
	     */

	  }, {
	    key: "sendEvent",
	    value: function sendEvent(params) {
	      params = params || {};

	      if (!params.type) {
	        return false;
	      }

	      if (babelHelpers["typeof"](params.data) !== 'object' || !params.data) {
	        params.data = {};
	      }

	      if (this.subscribers[params.type] instanceof Array && this.subscribers[params.type].length > 0) {
	        this.subscribers[params.type].forEach(function (callback) {
	          return callback(params.data);
	        });
	      }

	      if (this.subscribers[SubscriptionType.every] instanceof Array && this.subscribers[SubscriptionType.every].length > 0) {
	        this.subscribers[SubscriptionType.every].forEach(function (callback) {
	          return callback({
	            type: params.type,
	            data: params.data
	          });
	        });
	      }

	      return true;
	    }
	  }, {
	    key: "addLocalize",
	    value: function addLocalize(phrases) {
	      if (babelHelpers["typeof"](phrases) !== "object" || !phrases) {
	        return false;
	      }

	      for (var name in phrases) {
	        if (phrases.hasOwnProperty(name)) {
	          this.localize[name] = phrases[name];
	        }
	      }

	      return true;
	    }
	  }, {
	    key: "getLocalize",
	    value: function getLocalize(name) {
	      var phrase = '';

	      if (typeof name === 'undefined') {
	        return this.localize;
	      } else if (typeof this.localize[name.toString()] === 'undefined') {
	        console.warn("LiveChatWidget.getLocalize: message with code '".concat(name.toString(), "' is undefined."));
	      } else {
	        phrase = this.localize[name];
	      }

	      return phrase;
	    }
	    /* endregion 05. Widget interaction and utils */

	  }]);
	  return Widget;
	}();

	/**
	 * Bitrix OpenLines widget
	 * Widget public interface
	 *
	 * @package bitrix
	 * @subpackage imopenlines
	 * @copyright 2001-2019 Bitrix
	 */
	var WidgetPublicManager = /*#__PURE__*/function () {
	  function WidgetPublicManager(config) {
	    babelHelpers.classCallCheck(this, WidgetPublicManager);
	    this.developerInfo = 'Do not use private methods.';
	    this.__privateMethods__ = new Widget(config);

	    this.__createLegacyMethods();
	  }

	  babelHelpers.createClass(WidgetPublicManager, [{
	    key: "open",
	    value: function open(params) {
	      return this.__privateMethods__.open(params);
	    }
	  }, {
	    key: "close",
	    value: function close() {
	      return this.__privateMethods__.close();
	    }
	  }, {
	    key: "showNotification",
	    value: function showNotification(params) {
	      return this.__privateMethods__.showNotification(params);
	    }
	  }, {
	    key: "getUserData",
	    value: function getUserData() {
	      return this.__privateMethods__.getUserData();
	    }
	  }, {
	    key: "setUserRegisterData",
	    value: function setUserRegisterData(params) {
	      return this.__privateMethods__.setUserRegisterData(params);
	    }
	  }, {
	    key: "setCustomData",
	    value: function setCustomData(params) {
	      return this.__privateMethods__.setCustomData(params);
	    }
	  }, {
	    key: "mutateTemplateComponent",
	    value: function mutateTemplateComponent(id, params) {
	      return this.__privateMethods__.mutateTemplateComponent(id, params);
	    }
	  }, {
	    key: "addLocalize",
	    value: function addLocalize(phrases) {
	      return this.__privateMethods__.addLocalize(phrases);
	    }
	    /**
	     *
	     * @param params {Object}
	     * @returns {Function|Boolean} - Unsubscribe callback function or False
	     */

	  }, {
	    key: "subscribe",
	    value: function subscribe(params) {
	      return this.__privateMethods__.subscribe(params);
	    }
	  }, {
	    key: "start",
	    value: function start() {
	      return this.__privateMethods__.start();
	    }
	  }, {
	    key: "__createLegacyMethods",
	    value: function __createLegacyMethods() {
	      var _this = this;

	      if (typeof window.BX.LiveChat === 'undefined') {
	        var sourceHref = document.createElement('a');
	        sourceHref.href = this.__privateMethods__.host;
	        var sourceDomain = sourceHref.protocol + '//' + sourceHref.hostname + (sourceHref.port && sourceHref.port != '80' && sourceHref.port != '443' ? ":" + sourceHref.port : "");
	        window.BX.LiveChat = {
	          openLiveChat: function openLiveChat() {
	            _this.open({
	              openFromButton: true
	            });
	          },
	          closeLiveChat: function closeLiveChat() {
	            _this.close();
	          },
	          addEventListener: function addEventListener(el, eventName, handler) {
	            if (eventName === 'message') {
	              _this.subscribe({
	                type: SubscriptionType.userMessage,
	                callback: function callback(event) {
	                  handler({
	                    origin: sourceDomain,
	                    data: JSON.stringify({
	                      action: 'sendMessage'
	                    }),
	                    event: event
	                  });
	                }
	              });
	            } else {
	              console.warn('Method BX.LiveChat.addEventListener is not supported, user new format for subscribe.');
	            }
	          },
	          setCookie: function setCookie() {},
	          getCookie: function getCookie() {},
	          sourceDomain: sourceDomain
	        };
	      }

	      if (typeof window.BxLiveChatInit === 'function') {
	        var config = window.BxLiveChatInit();

	        if (config.user) {
	          this.__privateMethods__.setUserRegisterData(config.user);
	        }

	        if (config.firstMessage) {
	          this.__privateMethods__.setCustomData(config.firstMessage);
	        }
	      }

	      if (window.BxLiveChatLoader instanceof Array) {
	        window.BxLiveChatLoader.forEach(function (callback) {
	          return callback();
	        });
	      }

	      return true;
	    }
	  }]);
	  return WidgetPublicManager;
	}();

	function ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$1(Object(source), !0).forEach(function (key) { babelHelpers.defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
	/**
	 * @notice Do not mutate or clone this component! It is under development.
	 */

	ui_vue.WidgetBitrixVue.component('bx-livechat', {
	  mixins: [im_mixin.DialogCore, im_mixin.TextareaCore, im_mixin.TextareaUploadFile, im_mixin.DialogReadMessages, im_mixin.DialogClickOnCommand, im_mixin.DialogClickOnUserName, im_mixin.DialogClickOnKeyboardButton, im_mixin.DialogClickOnMessageMenu, im_mixin.DialogClickOnMessageRetry, im_mixin.DialogSetMessageReaction, im_mixin.DialogClickOnUploadCancel],
	  data: function data() {
	    return {
	      viewPortMetaSiteNode: null,
	      viewPortMetaWidgetNode: null,
	      storedMessage: '',
	      storedFile: null,
	      widgetMinimumHeight: 435,
	      widgetMinimumWidth: 340,
	      widgetBaseHeight: 557,
	      widgetBaseWidth: 435,
	      widgetMargin: 50,
	      widgetAvailableHeight: 0,
	      widgetAvailableWidth: 0,
	      widgetCurrentHeight: 0,
	      widgetCurrentWidth: 0,
	      widgetDrag: false,
	      textareaFocused: false,
	      textareaDrag: false,
	      textareaHeight: 100,
	      textareaMinimumHeight: 100,
	      textareaMaximumHeight: im_lib_utils.Utils.device.isMobile() ? 200 : 300,
	      zIndexStackInstance: null,
	      welcomeFormFilled: false
	    };
	  },
	  created: function created() {
	    im_lib_logger.Logger.warn('bx-livechat created');
	    this.onCreated();
	    document.addEventListener('keydown', this.onWindowKeyDown);

	    if (!im_lib_utils.Utils.device.isMobile() && !this.widget.common.pageMode) {
	      window.addEventListener('resize', this.getAvailableSpaceFunc = im_lib_utils.Utils.throttle(this.getAvailableSpace, 50));
	    }

	    main_core_events.EventEmitter.subscribe(EventType.requestShowForm, this.onRequestShowForm);
	  },
	  mounted: function mounted() {
	    if (this.widget.user.id > 0) {
	      this.welcomeFormFilled = true;
	    }

	    this.zIndexStackInstance = this.$Bitrix.Data.get('zIndexStack');

	    if (this.zIndexStackInstance && !!this.$refs.widgetWrapper) {
	      this.zIndexStackInstance.register(this.$refs.widgetWrapper);
	    }
	  },
	  beforeDestroy: function beforeDestroy() {
	    if (this.zIndexStackInstance) {
	      this.zIndexStackInstance.unregister(this.$refs.widgetWrapper);
	    }

	    document.removeEventListener('keydown', this.onWindowKeyDown);

	    if (!im_lib_utils.Utils.device.isMobile() && !this.widget.common.pageMode) {
	      window.removeEventListener('resize', this.getAvailableSpaceFunc);
	    }

	    main_core_events.EventEmitter.unsubscribe(EventType.requestShowForm, this.onRequestShowForm);
	    this.onTextareaDragEventRemove();
	  },
	  computed: _objectSpread$1({
	    FormType: function FormType$$1() {
	      return FormType;
	    },
	    VoteType: function VoteType$$1() {
	      return VoteType;
	    },
	    DeviceType: function DeviceType() {
	      return im_const.DeviceType;
	    },
	    EventType: function EventType$$1() {
	      return im_const.EventType;
	    },
	    showTextarea: function showTextarea() {
	      var crmFormsSettings = this.widget.common.crmFormsSettings; // show if we dont use welcome form

	      if (!crmFormsSettings.useWelcomeForm || !crmFormsSettings.welcomeFormId) {
	        return true;
	      } else {
	        // show if we use welcome form with delay
	        if (crmFormsSettings.welcomeFormDelay) {
	          return true;
	        } else {
	          return this.welcomeFormFilled;
	        }
	      }
	    },
	    showWelcomeForm: function showWelcomeForm() {
	      //we are using welcome form, it has delay and it was not already filled
	      return this.widget.common.crmFormsSettings.useWelcomeForm && !this.widget.common.crmFormsSettings.welcomeFormDelay && this.widget.common.crmFormsSettings.welcomeFormId && !this.welcomeFormFilled;
	    },
	    textareaHeightStyle: function textareaHeightStyle() {
	      return {
	        flex: '0 0 ' + this.textareaHeight + 'px'
	      };
	    },
	    textareaBottomMargin: function textareaBottomMargin() {
	      if (!this.widget.common.copyright && !this.isBottomLocation) {
	        return {
	          marginBottom: '5px'
	        };
	      }

	      return '';
	    },
	    widgetBaseSizes: function widgetBaseSizes() {
	      return {
	        width: this.widgetBaseWidth,
	        height: this.widgetBaseHeight
	      };
	    },
	    widgetHeightStyle: function widgetHeightStyle() {
	      if (im_lib_utils.Utils.device.isMobile() || this.widget.common.pageMode) {
	        return;
	      }

	      if (this.widgetAvailableHeight < this.widgetBaseSizes.height || this.widgetAvailableHeight < this.widgetCurrentHeight) {
	        this.widgetCurrentHeight = Math.max(this.widgetAvailableHeight, this.widgetMinimumHeight);
	      }

	      return this.widgetCurrentHeight + 'px';
	    },
	    widgetWidthStyle: function widgetWidthStyle() {
	      if (im_lib_utils.Utils.device.isMobile() || this.widget.common.pageMode) {
	        return;
	      }

	      if (this.widgetAvailableWidth < this.widgetBaseSizes.width || this.widgetAvailableWidth < this.widgetCurrentWidth) {
	        this.widgetCurrentWidth = Math.max(this.widgetAvailableWidth, this.widgetMinimumWidth);
	      }

	      return this.widgetCurrentWidth + 'px';
	    },
	    userSelectStyle: function userSelectStyle() {
	      return this.widgetDrag ? 'none' : 'auto';
	    },
	    isBottomLocation: function isBottomLocation() {
	      return [LocationType.bottomLeft, LocationType.bottomMiddle, LocationType.bottomRight].includes(this.widget.common.location);
	    },
	    isLeftLocation: function isLeftLocation() {
	      return [LocationType.bottomLeft, LocationType.topLeft, LocationType.topMiddle].includes(this.widget.common.location);
	    },
	    localize: function localize() {
	      return ui_vue.WidgetBitrixVue.getFilteredPhrases('BX_LIVECHAT_', this);
	    },
	    widgetMobileDisabled: function widgetMobileDisabled(state) {
	      if (state.application.device.type === im_const.DeviceType.mobile) {
	        if (navigator.userAgent.toString().includes('iPad')) ; else if (state.application.device.orientation === im_const.DeviceOrientation.horizontal) {
	          if (navigator.userAgent.toString().includes('iPhone')) {
	            return true;
	          } else {
	            return !(babelHelpers["typeof"](window.screen) === 'object' && window.screen.availHeight >= 800);
	          }
	        }
	      }

	      return false;
	    },
	    widgetClassName: function widgetClassName(state) {
	      var className = ['bx-livechat-wrapper'];
	      className.push('bx-livechat-show');

	      if (state.widget.common.pageMode) {
	        className.push('bx-livechat-page-mode');
	      } else {
	        className.push('bx-livechat-position-' + LocationStyle[state.widget.common.location]);
	      }

	      if (state.application.common.languageId === LanguageType.russian) {
	        className.push('bx-livechat-logo-ru');
	      } else if (state.application.common.languageId === LanguageType.ukraine) {
	        className.push('bx-livechat-logo-ua');
	      } else {
	        className.push('bx-livechat-logo-en');
	      }

	      if (!state.widget.common.online) {
	        className.push('bx-livechat-offline-state');
	      }

	      if (state.widget.common.dragged) {
	        className.push('bx-livechat-drag-n-drop');
	      }

	      if (state.widget.common.dialogStart) {
	        className.push('bx-livechat-chat-start');
	      }

	      if (state.widget.dialog.operator.name && !(state.application.device.type === im_const.DeviceType.mobile && state.application.device.orientation === im_const.DeviceOrientation.horizontal)) {
	        className.push('bx-livechat-has-operator');
	      }

	      if (im_lib_utils.Utils.device.isMobile()) {
	        className.push('bx-livechat-mobile');
	      } else if (im_lib_utils.Utils.browser.isSafari()) {
	        className.push('bx-livechat-browser-safari');
	      } else if (im_lib_utils.Utils.browser.isIe()) {
	        className.push('bx-livechat-browser-ie');
	      }

	      if (im_lib_utils.Utils.platform.isMac()) {
	        className.push('bx-livechat-mac');
	      } else {
	        className.push('bx-livechat-custom-scroll');
	      }

	      if (state.widget.common.styles.backgroundColor && im_lib_utils.Utils.isDarkColor(state.widget.common.styles.iconColor)) {
	        className.push('bx-livechat-bright-header');
	      }

	      return className.join(' ');
	    },
	    showMessageDialog: function showMessageDialog() {
	      return this.messageCollection.length > 0;
	    }
	  }, ui_vue_vuex.WidgetVuex.mapState({
	    widget: function widget(state) {
	      return state.widget;
	    },
	    application: function application(state) {
	      return state.application;
	    },
	    dialog: function dialog(state) {
	      return state.dialogues.collection[state.application.dialog.dialogId];
	    },
	    messageCollection: function messageCollection(state) {
	      return state.messages.collection[state.application.dialog.chatId];
	    }
	  })),
	  watch: {
	    sessionClose: function sessionClose(value) {
	      im_lib_logger.Logger.log('sessionClose change', value);
	    },
	    //Redefined for uploadFile mixin
	    dialogInited: function dialogInited(newValue) {
	      return false;
	    }
	  },
	  methods: {
	    getRestClient: function getRestClient() {
	      return this.$Bitrix.RestClient.get();
	    },
	    getApplication: function getApplication() {
	      return this.$Bitrix.Application.get();
	    },
	    onSendMessage: function onSendMessage(_ref) {
	      var event = _ref.data;
	      event.focus = event.focus !== false;

	      if (this.widget.common.showForm === FormType.smile) {
	        this.$store.commit('widget/common', {
	          showForm: FormType.none
	        });
	      } //show consent window if needed


	      if (!this.widget.dialog.userConsent && this.widget.common.consentUrl) {
	        if (event.text) {
	          this.storedMessage = event.text;
	        }

	        this.showConsentWidow();
	        return false;
	      }

	      event.text = event.text ? event.text : this.storedMessage;

	      if (!event.text) {
	        return false;
	      }

	      this.hideForm();
	      this.getApplication().addMessage(event.text);

	      if (event.focus) {
	        main_core_events.EventEmitter.emit(im_const.EventType.textarea.setFocus);
	      }

	      return true;
	    },
	    close: function close(event) {
	      if (this.widget.common.pageMode) {
	        return false;
	      }

	      this.onBeforeClose();
	      this.$store.commit('widget/common', {
	        showed: false
	      });
	    },
	    getAvailableSpace: function getAvailableSpace() {
	      if (this.isBottomLocation) {
	        var bottomPosition = this.$refs.widgetWrapper.getBoundingClientRect().bottom;
	        var widgetBottomMargin = window.innerHeight - bottomPosition;
	        this.widgetAvailableHeight = window.innerHeight - this.widgetMargin - widgetBottomMargin;
	      } else {
	        var topPosition = this.$refs.widgetWrapper.getBoundingClientRect().top;
	        this.widgetAvailableHeight = window.innerHeight - this.widgetMargin - topPosition;
	      }

	      this.widgetAvailableWidth = window.innerWidth - this.widgetMargin * 2;
	    },
	    showLikeForm: function showLikeForm() {
	      if (this.offline) {
	        return false;
	      }

	      clearTimeout(this.showFormTimeout);

	      if (!this.widget.common.vote.enable) {
	        return false;
	      }

	      if (this.widget.dialog.sessionClose && this.widget.dialog.userVote !== VoteType.none) {
	        return false;
	      }

	      this.$store.commit('widget/common', {
	        showForm: FormType.like
	      });
	    },
	    onOpenMenu: function onOpenMenu(event) {
	      this.getApplication().getHtmlHistory();
	    },
	    hideForm: function hideForm() {
	      clearTimeout(this.showFormTimeout);

	      if (this.widget.common.showForm !== FormType.none) {
	        this.$store.commit('widget/common', {
	          showForm: FormType.none
	        });
	      }
	    },
	    showConsentWidow: function showConsentWidow() {
	      this.$store.commit('widget/common', {
	        showConsent: true
	      });
	    },
	    agreeConsentWidow: function agreeConsentWidow() {
	      this.$store.commit('widget/common', {
	        showConsent: false
	      });
	      this.getApplication().sendConsentDecision(true);

	      if (this.storedMessage || this.storedFile) {
	        if (this.storedMessage) {
	          this.onSendMessage({
	            data: {
	              focus: this.application.device.type !== im_const.DeviceType.mobile
	            }
	          });
	          this.storedMessage = '';
	        }

	        if (this.storedFile) {
	          this.onTextareaFileSelected();
	          this.storedFile = '';
	        }
	      } else if (this.widget.common.showForm === FormType.none) {
	        main_core_events.EventEmitter.emit(im_const.EventType.textarea.setFocus);
	      }
	    },
	    disagreeConsentWidow: function disagreeConsentWidow() {
	      this.$store.commit('widget/common', {
	        showForm: FormType.none
	      });
	      this.$store.commit('widget/common', {
	        showConsent: false
	      });
	      this.getApplication().sendConsentDecision(false);

	      if (this.storedMessage) {
	        main_core_events.EventEmitter.emit(im_const.EventType.textarea.insertText, {
	          text: this.storedMessage,
	          focus: this.application.device.type !== im_const.DeviceType.mobile
	        });
	        this.storedMessage = '';
	      }

	      if (this.storedFile) {
	        this.storedFile = '';
	      }

	      if (this.application.device.type !== im_const.DeviceType.mobile) {
	        main_core_events.EventEmitter.emit(im_const.EventType.textarea.setFocus);
	      }
	    },
	    logEvent: function logEvent(name) {
	      for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	        params[_key - 1] = arguments[_key];
	      }

	      im_lib_logger.Logger.info.apply(im_lib_logger.Logger, [name].concat(params));
	    },
	    onCreated: function onCreated() {
	      var _this = this;

	      if (im_lib_utils.Utils.device.isMobile()) {
	        var viewPortMetaSiteNode = Array.from(document.head.getElementsByTagName('meta')).filter(function (element) {
	          return element.name === 'viewport';
	        })[0];

	        if (viewPortMetaSiteNode) {
	          this.viewPortMetaSiteNode = viewPortMetaSiteNode;
	          document.head.removeChild(this.viewPortMetaSiteNode);
	        } else {
	          var contentWidth = document.body.offsetWidth;

	          if (contentWidth < window.innerWidth) {
	            contentWidth = window.innerWidth;
	          }

	          if (contentWidth < 1024) {
	            contentWidth = 1024;
	          }

	          this.viewPortMetaSiteNode = document.createElement('meta');
	          this.viewPortMetaSiteNode.setAttribute('name', 'viewport');
	          this.viewPortMetaSiteNode.setAttribute('content', "width=".concat(contentWidth, ", initial-scale=1.0, user-scalable=1"));
	        }

	        if (!this.viewPortMetaWidgetNode) {
	          this.viewPortMetaWidgetNode = document.createElement('meta');
	          this.viewPortMetaWidgetNode.setAttribute('name', 'viewport');
	          this.viewPortMetaWidgetNode.setAttribute('content', 'width=device-width, initial-scale=1.0, user-scalable=0');
	          document.head.appendChild(this.viewPortMetaWidgetNode);
	        }

	        document.body.classList.add('bx-livechat-mobile-state');

	        if (im_lib_utils.Utils.browser.isSafariBased()) {
	          document.body.classList.add('bx-livechat-mobile-safari-based');
	        }

	        setTimeout(function () {
	          _this.$store.dispatch('widget/show');
	        }, 50);
	      } else {
	        this.$store.dispatch('widget/show').then(function () {
	          _this.widgetCurrentHeight = _this.widgetBaseSizes.height;
	          _this.widgetCurrentWidth = _this.widgetBaseSizes.width;

	          _this.getAvailableSpace();

	          _this.widgetCurrentHeight = _this.widget.common.widgetHeight || _this.widgetCurrentHeight;
	          _this.widgetCurrentWidth = _this.widget.common.widgetWidth || _this.widgetCurrentWidth;
	        });
	      }

	      this.textareaHeight = this.widget.common.textareaHeight || this.textareaHeight;
	      this.$store.commit('files/initCollection', {
	        chatId: this.getApplication().getChatId()
	      });
	      this.$store.commit('messages/initCollection', {
	        chatId: this.getApplication().getChatId()
	      });
	      this.$store.commit('dialogues/initCollection', {
	        dialogId: this.getApplication().getDialogId(),
	        fields: {
	          entityType: 'LIVECHAT',
	          type: 'livechat'
	        }
	      });
	    },
	    onBeforeClose: function onBeforeClose() {
	      if (im_lib_utils.Utils.device.isMobile()) {
	        document.body.classList.remove('bx-livechat-mobile-state');

	        if (im_lib_utils.Utils.browser.isSafariBased()) {
	          document.body.classList.remove('bx-livechat-mobile-safari-based');
	        }

	        if (this.viewPortMetaWidgetNode) {
	          document.head.removeChild(this.viewPortMetaWidgetNode);
	          this.viewPortMetaWidgetNode = null;
	        }

	        if (this.viewPortMetaSiteNode) {
	          document.head.appendChild(this.viewPortMetaSiteNode);
	          this.viewPortMetaSiteNode = null;
	        }
	      }
	    },
	    onAfterClose: function onAfterClose() {
	      this.getApplication().close();
	    },
	    onRequestShowForm: function onRequestShowForm(_ref2) {
	      var _this2 = this;

	      var event = _ref2.data;
	      clearTimeout(this.showFormTimeout);

	      if (event.type === FormType.like) {
	        if (event.delayed) {
	          this.showFormTimeout = setTimeout(function () {
	            _this2.showLikeForm();
	          }, 5000);
	        } else {
	          this.showLikeForm();
	        }
	      }
	    },
	    onDialogRequestHistory: function onDialogRequestHistory(event) {
	      this.getApplication().getDialogHistory(event.lastId);
	    },
	    onDialogRequestUnread: function onDialogRequestUnread(event) {
	      this.getApplication().getDialogUnread(event.lastId);
	    },
	    onClickOnUserName: function onClickOnUserName(_ref3) {
	      var event = _ref3.data;
	      // TODO name push to auto-replace mention holder - User Name -> [USER=274]User Name[/USER]
	      main_core_events.EventEmitter.emit(im_const.EventType.textarea.insertText, {
	        text: event.user.name + ', '
	      });
	    },
	    onClickOnUploadCancel: function onClickOnUploadCancel(_ref4) {
	      var event = _ref4.data;
	      this.getApplication().cancelUploadFile(event.file.id);
	    },
	    onClickOnKeyboardButton: function onClickOnKeyboardButton(_ref5) {
	      var event = _ref5.data;
	      this.getApplication().execMessageKeyboardCommand(event);
	    },
	    onClickOnCommand: function onClickOnCommand(_ref6) {
	      var event = _ref6.data;

	      if (event.type === 'put') {
	        main_core_events.EventEmitter.emit(im_const.EventType.textarea.insertText, {
	          text: event.value + ' '
	        });
	      } else if (event.type === 'send') {
	        this.getApplication().addMessage(event.value);
	      } else {
	        im_lib_logger.Logger.warn('Unprocessed command', event);
	      }
	    },
	    onClickOnMessageMenu: function onClickOnMessageMenu(_ref7) {
	      var event = _ref7.data;
	      im_lib_logger.Logger.warn('Message menu:', event);
	    },
	    onClickOnMessageRetry: function onClickOnMessageRetry(_ref8) {
	      var event = _ref8.data;
	      im_lib_logger.Logger.warn('Message retry:', event);
	      this.getApplication().retrySendMessage(event.message);
	    },
	    onReadMessage: function onReadMessage(_ref9) {
	      var event = _ref9.data;
	      this.getApplication().readMessage(event.id);
	    },
	    onSetMessageReaction: function onSetMessageReaction(_ref10) {
	      var event = _ref10.data;
	      this.getApplication().reactMessage(event.message.id, event.reaction);
	    },
	    onClickOnDialog: function onClickOnDialog(_ref11) {
	      var event = _ref11.data;

	      if (this.widget.common.showForm !== FormType.none) {
	        this.$store.commit('widget/common', {
	          showForm: FormType.none
	        });
	      }
	    },
	    onTextareaKeyUp: function onTextareaKeyUp(_ref12) {
	      var event = _ref12.data;

	      if (this.widget.common.watchTyping && this.widget.dialog.sessionId && !this.widget.dialog.sessionClose && this.widget.dialog.operator.id && this.widget.dialog.operatorChatId && this.$Bitrix.PullClient.get().isPublishingEnabled()) {
	        var infoString = main_md5.md5(this.widget.dialog.sessionId + '/' + this.application.dialog.chatId + '/' + this.widget.user.id);
	        this.$Bitrix.PullClient.get().sendMessage([this.widget.dialog.operator.id], 'imopenlines', 'linesMessageWrite', {
	          text: event.text,
	          infoString: infoString,
	          operatorChatId: this.widget.dialog.operatorChatId
	        });
	      }
	    },
	    onTextareaFocus: function onTextareaFocus(_ref13) {
	      var _this3 = this;

	      var event = _ref13.data;

	      if (this.widget.common.copyright && this.application.device.type === im_const.DeviceType.mobile) {
	        this.widget.common.copyright = false;
	      }

	      if (im_lib_utils.Utils.device.isMobile()) {
	        clearTimeout(this.onTextareaFocusScrollTimeout);
	        this.onTextareaFocusScrollTimeout = setTimeout(function () {
	          document.addEventListener('scroll', _this3.onWindowScroll);
	        }, 1000);
	      }

	      this.textareaFocused = true;
	    },
	    onTextareaBlur: function onTextareaBlur(_ref14) {
	      var _this4 = this;

	      var event = _ref14.data;

	      if (!this.widget.common.copyright && this.widget.common.copyright !== this.getApplication().copyright) {
	        this.widget.common.copyright = this.getApplication().copyright;
	        this.$nextTick(function () {
	          main_core_events.EventEmitter.emit(im_const.EventType.dialog.scrollToBottom, {
	            chatId: _this4.chatId,
	            force: true
	          });
	        });
	      }

	      if (im_lib_utils.Utils.device.isMobile()) {
	        clearTimeout(this.onTextareaFocusScrollTimeout);
	        document.removeEventListener('scroll', this.onWindowScroll);
	      }

	      this.textareaFocused = false;
	    },
	    onTextareaStartDrag: function onTextareaStartDrag(event) {
	      if (this.textareaDrag) {
	        return;
	      }

	      im_lib_logger.Logger.log('Livechat: textarea drag started');
	      this.textareaDrag = true;
	      event = event.changedTouches ? event.changedTouches[0] : event;
	      this.textareaDragCursorStartPoint = event.clientY;
	      this.textareaDragHeightStartPoint = this.textareaHeight;
	      this.onTextareaDragEventAdd();
	      main_core_events.EventEmitter.emit(im_const.EventType.textarea.setBlur, true);
	    },
	    onTextareaContinueDrag: function onTextareaContinueDrag(event) {
	      if (!this.textareaDrag) {
	        return;
	      }

	      event = event.changedTouches ? event.changedTouches[0] : event;
	      this.textareaDragCursorControlPoint = event.clientY;
	      var textareaHeight = Math.max(Math.min(this.textareaDragHeightStartPoint + this.textareaDragCursorStartPoint - this.textareaDragCursorControlPoint, this.textareaMaximumHeight), this.textareaMinimumHeight);
	      im_lib_logger.Logger.log('Livechat: textarea drag', 'new: ' + textareaHeight, 'curr: ' + this.textareaHeight);

	      if (this.textareaHeight !== textareaHeight) {
	        this.textareaHeight = textareaHeight;
	      }
	    },
	    onTextareaStopDrag: function onTextareaStopDrag() {
	      if (!this.textareaDrag) {
	        return;
	      }

	      im_lib_logger.Logger.log('Livechat: textarea drag ended');
	      this.textareaDrag = false;
	      this.onTextareaDragEventRemove();
	      this.$store.commit('widget/common', {
	        textareaHeight: this.textareaHeight
	      });
	      main_core_events.EventEmitter.emit(im_const.EventType.dialog.scrollToBottom, {
	        chatId: this.chatId,
	        force: true
	      });
	    },
	    onTextareaDragEventAdd: function onTextareaDragEventAdd() {
	      document.addEventListener('mousemove', this.onTextareaContinueDrag);
	      document.addEventListener('touchmove', this.onTextareaContinueDrag);
	      document.addEventListener('touchend', this.onTextareaStopDrag);
	      document.addEventListener('mouseup', this.onTextareaStopDrag);
	      document.addEventListener('mouseleave', this.onTextareaStopDrag);
	    },
	    onTextareaDragEventRemove: function onTextareaDragEventRemove() {
	      document.removeEventListener('mousemove', this.onTextareaContinueDrag);
	      document.removeEventListener('touchmove', this.onTextareaContinueDrag);
	      document.removeEventListener('touchend', this.onTextareaStopDrag);
	      document.removeEventListener('mouseup', this.onTextareaStopDrag);
	      document.removeEventListener('mouseleave', this.onTextareaStopDrag);
	    },
	    onTextareaFileSelected: function onTextareaFileSelected() {
	      var _ref15 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	          event = _ref15.data;

	      var fileInputEvent = null;

	      if (event && event.fileChangeEvent && event.fileChangeEvent.target.files.length > 0) {
	        fileInputEvent = event.fileChangeEvent;
	      } else {
	        fileInputEvent = this.storedFile;
	      }

	      if (!fileInputEvent) {
	        return false;
	      }

	      if (!this.widget.dialog.userConsent && this.widget.common.consentUrl) {
	        this.storedFile = event.fileChangeEvent;
	        this.showConsentWidow();
	        return false;
	      }

	      this.getApplication().uploadFile(fileInputEvent);
	    },
	    onTextareaAppButtonClick: function onTextareaAppButtonClick(_ref16) {
	      var event = _ref16.data;

	      if (event.appId === FormType.smile) {
	        if (this.widget.common.showForm === FormType.smile) {
	          this.$store.commit('widget/common', {
	            showForm: FormType.none
	          });
	        } else {
	          this.$store.commit('widget/common', {
	            showForm: FormType.smile
	          });
	        }
	      } else {
	        main_core_events.EventEmitter.emit(im_const.EventType.textarea.setFocus);
	      }
	    },
	    onTextareaEdit: function onTextareaEdit(_ref17) {
	      var event = _ref17.data;
	      this.logEvent('edit message', event);
	    },
	    onPullRequestConfig: function onPullRequestConfig(event) {
	      this.getApplication().recoverPullConnection();
	    },
	    onSmilesSelectSmile: function onSmilesSelectSmile(event) {
	      main_core_events.EventEmitter.emit(im_const.EventType.textarea.insertText, {
	        text: event.text
	      });
	    },
	    onSmilesSelectSet: function onSmilesSelectSet() {
	      main_core_events.EventEmitter.emit(im_const.EventType.textarea.setFocus);
	    },
	    onWidgetStartDrag: function onWidgetStartDrag(event) {
	      if (this.widgetDrag) {
	        return;
	      }

	      this.widgetDrag = true;
	      event = event.changedTouches ? event.changedTouches[0] : event;
	      this.widgetDragCursorStartPointY = event.clientY;
	      this.widgetDragCursorStartPointX = event.clientX;
	      this.widgetDragHeightStartPoint = this.widgetCurrentHeight;
	      this.widgetDragWidthStartPoint = this.widgetCurrentWidth;
	      this.onWidgetDragEventAdd();
	    },
	    onWidgetContinueDrag: function onWidgetContinueDrag(event) {
	      if (!this.widgetDrag) {
	        return;
	      }

	      event = event.changedTouches ? event.changedTouches[0] : event;
	      this.widgetDragCursorControlPointY = event.clientY;
	      this.widgetDragCursorControlPointX = event.clientX;
	      var widgetHeight = 0;

	      if (this.isBottomLocation) {
	        widgetHeight = Math.max(Math.min(this.widgetDragHeightStartPoint + this.widgetDragCursorStartPointY - this.widgetDragCursorControlPointY, this.widgetAvailableHeight), this.widgetMinimumHeight);
	      } else {
	        widgetHeight = Math.max(Math.min(this.widgetDragHeightStartPoint - this.widgetDragCursorStartPointY + this.widgetDragCursorControlPointY, this.widgetAvailableHeight), this.widgetMinimumHeight);
	      }

	      var widgetWidth = 0;

	      if (this.isLeftLocation) {
	        widgetWidth = Math.max(Math.min(this.widgetDragWidthStartPoint - this.widgetDragCursorStartPointX + this.widgetDragCursorControlPointX, this.widgetAvailableWidth), this.widgetMinimumWidth);
	      } else {
	        widgetWidth = Math.max(Math.min(this.widgetDragWidthStartPoint + this.widgetDragCursorStartPointX - this.widgetDragCursorControlPointX, this.widgetAvailableWidth), this.widgetMinimumWidth);
	      }

	      if (this.widgetCurrentHeight !== widgetHeight) {
	        this.widgetCurrentHeight = widgetHeight;
	      }

	      if (this.widgetCurrentWidth !== widgetWidth) {
	        this.widgetCurrentWidth = widgetWidth;
	      }
	    },
	    onWidgetStopDrag: function onWidgetStopDrag() {
	      if (!this.widgetDrag) {
	        return;
	      }

	      this.widgetDrag = false;
	      this.onWidgetDragEventRemove();
	      this.$store.commit('widget/common', {
	        widgetHeight: this.widgetCurrentHeight,
	        widgetWidth: this.widgetCurrentWidth
	      });
	    },
	    onWidgetDragEventAdd: function onWidgetDragEventAdd() {
	      document.addEventListener('mousemove', this.onWidgetContinueDrag);
	      document.addEventListener('mouseup', this.onWidgetStopDrag);
	      document.addEventListener('mouseleave', this.onWidgetStopDrag);
	    },
	    onWidgetDragEventRemove: function onWidgetDragEventRemove() {
	      document.removeEventListener('mousemove', this.onWidgetContinueDrag);
	      document.removeEventListener('mouseup', this.onWidgetStopDrag);
	      document.removeEventListener('mouseleave', this.onWidgetStopDrag);
	    },
	    onWindowKeyDown: function onWindowKeyDown(event) {
	      if (event.keyCode === 27) {
	        if (this.widget.common.showForm !== FormType.none) {
	          this.$store.commit('widget/common', {
	            showForm: FormType.none
	          });
	        } else if (this.widget.common.showConsent) {
	          this.disagreeConsentWidow();
	        } else {
	          this.close();
	        }

	        event.preventDefault();
	        event.stopPropagation();
	        main_core_events.EventEmitter.emit(im_const.EventType.textarea.setFocus);
	      }
	    },
	    onWindowScroll: function onWindowScroll(event) {
	      clearTimeout(this.onWindowScrollTimeout);
	      this.onWindowScrollTimeout = setTimeout(function () {
	        main_core_events.EventEmitter.emit(im_const.EventType.textarea.setBlur, true);
	      }, 50);
	    },
	    onWelcomeFormSendSuccess: function onWelcomeFormSendSuccess() {
	      this.welcomeFormFilled = true;
	    },
	    onWelcomeFormSendError: function onWelcomeFormSendError(error) {
	      console.error('onWelcomeFormSendError', error);
	      this.welcomeFormFilled = true;
	    }
	  },
	  // language=Vue
	  template: "\n\t\t<transition enter-active-class=\"bx-livechat-show\" leave-active-class=\"bx-livechat-close\" @after-leave=\"onAfterClose\">\n\t\t\t<div :class=\"widgetClassName\" v-if=\"widget.common.showed\" :style=\"{height: widgetHeightStyle, width: widgetWidthStyle, userSelect: userSelectStyle}\" ref=\"widgetWrapper\">\n\t\t\t\t<div class=\"bx-livechat-box\">\n\t\t\t\t\t<div v-if=\"isBottomLocation\" class=\"bx-livechat-widget-resize-handle\" @mousedown=\"onWidgetStartDrag\"></div>\n\t\t\t\t\t<bx-livechat-head :isWidgetDisabled=\"widgetMobileDisabled\" @like=\"showLikeForm\" @openMenu=\"onOpenMenu\" @close=\"close\"/>\n\t\t\t\t\t<template v-if=\"widgetMobileDisabled\">\n\t\t\t\t\t\t<bx-livechat-body-orientation-disabled/>\n\t\t\t\t\t</template>\n\t\t\t\t\t<template v-else-if=\"application.error.active\">\n\t\t\t\t\t\t<bx-livechat-body-error/>\n\t\t\t\t\t</template>\n\t\t\t\t\t<template v-else-if=\"!widget.common.configId\">\n\t\t\t\t\t\t<div class=\"bx-livechat-body\" key=\"loading-body\">\n\t\t\t\t\t\t\t<bx-livechat-body-loading/>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</template>\n\t\t\t\t\t<template v-else>\n\t\t\t\t\t\t<div v-show=\"!widget.common.dialogStart\" class=\"bx-livechat-body\" :class=\"{'bx-livechat-body-with-scroll': showWelcomeForm}\" key=\"welcome-body\">\n\t\t\t\t\t\t\t<bx-imopenlines-form\n\t\t\t\t\t\t\t  v-show=\"showWelcomeForm\"\n\t\t\t\t\t\t\t  @formSendSuccess=\"onWelcomeFormSendSuccess\"\n\t\t\t\t\t\t\t  @formSendError=\"onWelcomeFormSendError\"\n\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t<template v-if=\"!showWelcomeForm\">\n\t\t\t\t\t\t\t\t<bx-livechat-body-operators/>\n\t\t\t\t\t\t\t\t<keep-alive include=\"bx-livechat-smiles\">\n\t\t\t\t\t\t\t\t\t<template v-if=\"widget.common.showForm === FormType.smile\">\n\t\t\t\t\t\t\t\t\t\t<bx-livechat-smiles @selectSmile=\"onSmilesSelectSmile\" @selectSet=\"onSmilesSelectSet\"/>\n\t\t\t\t\t\t\t\t\t</template>\n\t\t\t\t\t\t\t\t</keep-alive>\n\t\t\t\t\t\t\t</template>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t<template v-if=\"widget.common.dialogStart\">\n\t\t\t\t\t\t\t<bx-pull-component-status :canReconnect=\"true\" @reconnect=\"onPullRequestConfig\"/>\n\t\t\t\t\t\t\t<div :class=\"['bx-livechat-body', {'bx-livechat-body-with-message': showMessageDialog}]\" key=\"with-message\">\n\t\t\t\t\t\t\t\t<template v-if=\"showMessageDialog\">\n\t\t\t\t\t\t\t\t\t<div class=\"bx-livechat-dialog\">\n\t\t\t\t\t\t\t\t\t\t<bx-im-component-dialog\n\t\t\t\t\t\t\t\t\t\t\t:userId=\"application.common.userId\"\n\t\t\t\t\t\t\t\t\t\t\t:dialogId=\"application.dialog.dialogId\"\n\t\t\t\t\t\t\t\t\t\t\t:messageLimit=\"application.dialog.messageLimit\"\n\t\t\t\t\t\t\t\t\t\t\t:enableReactions=\"true\"\n\t\t\t\t\t\t\t\t\t\t\t:enableDateActions=\"false\"\n\t\t\t\t\t\t\t\t\t\t\t:enableCreateContent=\"false\"\n\t\t\t\t\t\t\t\t\t\t\t:enableGestureQuote=\"true\"\n\t\t\t\t\t\t\t\t\t\t\t:enableGestureMenu=\"true\"\n\t\t\t\t\t\t\t\t\t\t\t:showMessageAvatar=\"false\"\n\t\t\t\t\t\t\t\t\t\t\t:showMessageMenu=\"false\"\n\t\t\t\t\t\t\t\t\t\t\t:skipDataRequest=\"true\"\n\t\t\t\t\t\t\t\t\t\t\t:showLoadingState=\"false\"\n\t\t\t\t\t\t\t\t\t\t\t:showEmptyState=\"false\"\n\t\t\t\t\t\t\t\t\t\t />\n\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t</template>\n\t\t\t\t\t\t\t\t<template v-else>\n\t\t\t\t\t\t\t\t\t<bx-livechat-body-loading/>\n\t\t\t\t\t\t\t\t</template>\n\n\t\t\t\t\t\t\t\t<keep-alive include=\"bx-livechat-smiles\">\n\t\t\t\t\t\t\t\t\t<template v-if=\"widget.common.showForm === FormType.like && widget.common.vote.enable\">\n\t\t\t\t\t\t\t\t\t\t<bx-livechat-form-vote/>\n\t\t\t\t\t\t\t\t\t</template>\n\t\t\t\t\t\t\t\t\t<template v-else-if=\"widget.common.showForm === FormType.welcome\">\n\t\t\t\t\t\t\t\t\t\t<bx-livechat-form-welcome/>\n\t\t\t\t\t\t\t\t\t</template>\n\t\t\t\t\t\t\t\t\t<template v-else-if=\"widget.common.showForm === FormType.offline\">\n\t\t\t\t\t\t\t\t\t\t<bx-livechat-form-offline/>\n\t\t\t\t\t\t\t\t\t</template>\n\t\t\t\t\t\t\t\t\t<template v-else-if=\"widget.common.showForm === FormType.history\">\n\t\t\t\t\t\t\t\t\t\t<bx-livechat-form-history/>\n\t\t\t\t\t\t\t\t\t</template>\n\t\t\t\t\t\t\t\t\t<template v-else-if=\"widget.common.showForm === FormType.smile\">\n\t\t\t\t\t\t\t\t\t\t<bx-livechat-smiles @selectSmile=\"onSmilesSelectSmile\" @selectSet=\"onSmilesSelectSet\"/>\n\t\t\t\t\t\t\t\t\t</template>\n\t\t\t\t\t\t\t\t</keep-alive>\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t</template>\n\t\t\t\t\t\t<div v-if=\"showTextarea\" class=\"bx-livechat-textarea\" :style=\"[textareaHeightStyle, textareaBottomMargin]\" ref=\"textarea\">\n\t\t\t\t\t\t\t<div class=\"bx-livechat-textarea-resize-handle\" @mousedown=\"onTextareaStartDrag\" @touchstart=\"onTextareaStartDrag\"></div>\n\t\t\t\t\t\t\t<bx-im-component-textarea\n\t\t\t\t\t\t\t\t:siteId=\"application.common.siteId\"\n\t\t\t\t\t\t\t\t:userId=\"application.common.userId\"\n\t\t\t\t\t\t\t\t:dialogId=\"application.dialog.dialogId\"\n\t\t\t\t\t\t\t\t:writesEventLetter=\"3\"\n\t\t\t\t\t\t\t\t:enableEdit=\"true\"\n\t\t\t\t\t\t\t\t:enableCommand=\"false\"\n\t\t\t\t\t\t\t\t:enableMention=\"false\"\n\t\t\t\t\t\t\t\t:enableFile=\"application.disk.enabled\"\n\t\t\t\t\t\t\t\t:autoFocus=\"application.device.type !== DeviceType.mobile\"\n\t\t\t\t\t\t\t\t:styles=\"{button: {backgroundColor: widget.common.styles.backgroundColor, iconColor: widget.common.styles.iconColor}}\"\n\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t<div v-if=\"!widget.common.copyright && !isBottomLocation\" class=\"bx-livechat-nocopyright-resize-wrap\" style=\"position: relative;\">\n\t\t\t\t\t\t\t<div class=\"bx-livechat-widget-resize-handle\" @mousedown=\"onWidgetStartDrag\"></div>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t<bx-livechat-form-consent @agree=\"agreeConsentWidow\" @disagree=\"disagreeConsentWidow\"/>\n\t\t\t\t\t\t<template v-if=\"widget.common.copyright\">\n\t\t\t\t\t\t\t<div class=\"bx-livechat-copyright\">\n\t\t\t\t\t\t\t\t<template v-if=\"widget.common.copyrightUrl\">\n\t\t\t\t\t\t\t\t\t<a class=\"bx-livechat-copyright-link\" :href=\"widget.common.copyrightUrl\" target=\"_blank\">\n\t\t\t\t\t\t\t\t\t\t<span class=\"bx-livechat-logo-name\">{{localize.BX_LIVECHAT_COPYRIGHT_TEXT}}</span>\n\t\t\t\t\t\t\t\t\t\t<span class=\"bx-livechat-logo-icon\"></span>\n\t\t\t\t\t\t\t\t\t</a>\n\t\t\t\t\t\t\t\t</template>\n\t\t\t\t\t\t\t\t<template v-else>\n\t\t\t\t\t\t\t\t\t<span class=\"bx-livechat-logo-name\">{{localize.BX_LIVECHAT_COPYRIGHT_TEXT}}</span>\n\t\t\t\t\t\t\t\t\t<span class=\"bx-livechat-logo-icon\"></span>\n\t\t\t\t\t\t\t\t</template>\n\t\t\t\t\t\t\t\t<div v-if=\"!isBottomLocation\" class=\"bx-livechat-widget-resize-handle\" @mousedown=\"onWidgetStartDrag\"></div>\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t</template>\n\t\t\t\t\t</template>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t</transition>\n\t"
	});

	function ownKeys$2(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread$2(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$2(Object(source), !0).forEach(function (key) { babelHelpers.defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$2(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
	ui_vue.WidgetBitrixVue.component('bx-livechat-body-error', {
	  computed: _objectSpread$2({}, ui_vue_vuex.WidgetVuex.mapState({
	    application: function application(state) {
	      return state.application;
	    }
	  })),
	  template: "\n\t\t<div class=\"bx-livechat-body\" key=\"error-body\">\n\t\t\t<div class=\"bx-livechat-warning-window\">\n\t\t\t\t<div class=\"bx-livechat-warning-icon\"></div>\n\t\t\t\t<template v-if=\"application.error.description\"> \n\t\t\t\t\t<div class=\"bx-livechat-help-title bx-livechat-help-title-sm bx-livechat-warning-msg\" v-html=\"application.error.description\"></div>\n\t\t\t\t</template> \n\t\t\t\t<template v-else>\n\t\t\t\t\t<div class=\"bx-livechat-help-title bx-livechat-help-title-md bx-livechat-warning-msg\">{{$Bitrix.Loc.getMessage('BX_LIVECHAT_ERROR_TITLE')}}</div>\n\t\t\t\t\t<div class=\"bx-livechat-help-title bx-livechat-help-title-sm bx-livechat-warning-msg\">{{$Bitrix.Loc.getMessage('BX_LIVECHAT_ERROR_DESC')}}</div>\n\t\t\t\t</template> \n\t\t\t</div>\n\t\t</div>\n\t"
	});

	function ownKeys$3(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread$3(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$3(Object(source), !0).forEach(function (key) { babelHelpers.defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$3(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
	ui_vue.WidgetBitrixVue.component('bx-livechat-head', {
	  /**
	   * @emits 'close'
	   * @emits 'like'
	   * @emits 'history'
	   */
	  props: {
	    isWidgetDisabled: {
	      "default": false
	    }
	  },
	  methods: {
	    close: function close(event) {
	      this.$emit('close');
	    },
	    like: function like(event) {
	      this.$emit('like');
	    },
	    openMenu: function openMenu(event) {
	      this.$emit('openMenu', event);
	    }
	  },
	  computed: _objectSpread$3({
	    VoteType: function VoteType$$1() {
	      return VoteType;
	    },
	    chatId: function chatId() {
	      if (this.application) {
	        return this.application.dialog.chatId;
	      }
	    },
	    customBackgroundStyle: function customBackgroundStyle(state) {
	      return state.widget.common.styles.backgroundColor ? 'background-color: ' + state.widget.common.styles.backgroundColor + '!important;' : '';
	    },
	    customBackgroundOnlineStyle: function customBackgroundOnlineStyle(state) {
	      return state.widget.common.styles.backgroundColor ? 'border-color: ' + state.widget.common.styles.backgroundColor + '!important;' : '';
	    },
	    showName: function showName(state) {
	      return state.widget.dialog.operator.firstName || state.widget.dialog.operator.lastName;
	    },
	    voteActive: function voteActive(state) {
	      if (!!state.widget.dialog.closeVote) {
	        return false;
	      }

	      if (!state.widget.common.vote.beforeFinish && state.widget.dialog.sessionStatus < SessionStatus.waitClient) {
	        return false;
	      }

	      if (!state.widget.dialog.sessionClose || state.widget.dialog.sessionClose && state.widget.dialog.userVote === VoteType.none) {
	        return true;
	      }

	      if (state.widget.dialog.sessionClose && state.widget.dialog.userVote !== VoteType.none) {
	        return true;
	      }

	      return false;
	    },
	    chatTitle: function chatTitle(state) {
	      return state.widget.common.textMessages.bxLivechatTitle || state.widget.common.configName || this.localize.BX_LIVECHAT_TITLE;
	    },
	    operatorName: function operatorName(state) {
	      if (!this.showName) return '';
	      return state.widget.dialog.operator.firstName ? state.widget.dialog.operator.firstName : state.widget.dialog.operator.name;
	    },
	    operatorDescription: function operatorDescription(state) {
	      if (!this.showName) {
	        return '';
	      }

	      var operatorPosition = state.widget.dialog.operator.workPosition ? state.widget.dialog.operator.workPosition : this.localize.BX_LIVECHAT_USER;

	      if (state.widget.common.showSessionId && state.widget.dialog.sessionId >= 0) {
	        return this.localize.BX_LIVECHAT_OPERATOR_POSITION_AND_SESSION_ID.replace("#POSITION#", operatorPosition).replace("#ID#", state.widget.dialog.sessionId);
	      }

	      return this.localize.BX_LIVECHAT_OPERATOR_POSITION_ONLY.replace("#POSITION#", operatorPosition);
	    },
	    localize: function localize() {
	      return ui_vue.WidgetBitrixVue.getFilteredPhrases('BX_LIVECHAT_', this);
	    },
	    ie11: function ie11() {
	      return main_core_minimal.Browser.isIE11();
	    }
	  }, ui_vue_vuex.WidgetVuex.mapState({
	    widget: function widget(state) {
	      return state.widget;
	    },
	    application: function application(state) {
	      return state.application;
	    }
	  })),
	  watch: {
	    showName: function showName(value) {
	      var _this = this;

	      if (value) {
	        setTimeout(function () {
	          _this.$root.$emit(im_const.EventType.dialog.scrollToBottom, {
	            chatId: _this.chatId
	          });
	        }, 300);
	      }
	    }
	  },
	  //language=Vue
	  template: "\n\t\t<div class=\"bx-livechat-head-wrap\">\n\t\t\t<template v-if=\"isWidgetDisabled\">\n\t\t\t\t<div class=\"bx-livechat-head\" :style=\"customBackgroundStyle\">\n\t\t\t\t\t<div class=\"bx-livechat-title\">{{chatTitle}}</div>\n\t\t\t\t\t<div class=\"bx-livechat-control-box\">\n\t\t\t\t\t\t<button v-if=\"!widget.common.pageMode\" class=\"bx-livechat-control-btn bx-livechat-control-btn-close\" :title=\"localize.BX_LIVECHAT_CLOSE_BUTTON\" @click=\"close\"></button>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\t\n\t\t\t</template>\n\t\t\t<template v-else-if=\"application.error.active\">\n\t\t\t\t<div class=\"bx-livechat-head\" :style=\"customBackgroundStyle\">\n\t\t\t\t\t<div class=\"bx-livechat-title\">{{chatTitle}}</div>\n\t\t\t\t\t<div class=\"bx-livechat-control-box\">\n\t\t\t\t\t\t<button v-if=\"!widget.common.pageMode\" class=\"bx-livechat-control-btn bx-livechat-control-btn-close\" :title=\"localize.BX_LIVECHAT_CLOSE_BUTTON\" @click=\"close\"></button>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t</template>\n\t\t\t<template v-else-if=\"!widget.common.configId\">\n\t\t\t\t<div class=\"bx-livechat-head\" :style=\"customBackgroundStyle\">\n\t\t\t\t\t<div class=\"bx-livechat-title\">{{chatTitle}}</div>\n\t\t\t\t\t<div class=\"bx-livechat-control-box\">\n\t\t\t\t\t\t<button v-if=\"!widget.common.pageMode\" class=\"bx-livechat-control-btn bx-livechat-control-btn-close\" :title=\"localize.BX_LIVECHAT_CLOSE_BUTTON\" @click=\"close\"></button>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t</template>\t\t\t\n\t\t\t<template v-else>\n\t\t\t\t<div class=\"bx-livechat-head\" :style=\"customBackgroundStyle\">\n\t\t\t\t\t<template v-if=\"!showName\">\n\t\t\t\t\t\t<div class=\"bx-livechat-title\">{{chatTitle}}</div>\n\t\t\t\t\t</template>\n\t\t\t\t\t<template v-else>\n\t\t\t\t\t\t<div class=\"bx-livechat-user bx-livechat-status-online\">\n\t\t\t\t\t\t\t<template v-if=\"widget.dialog.operator.avatar\">\n\t\t\t\t\t\t\t\t<div class=\"bx-livechat-user-icon\" :style=\"'background-image: url('+encodeURI(widget.dialog.operator.avatar)+')'\">\n\t\t\t\t\t\t\t\t\t<div v-if=\"widget.dialog.operator.online\" class=\"bx-livechat-user-status\" :style=\"customBackgroundOnlineStyle\"></div>\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t</template>\n\t\t\t\t\t\t\t<template v-else>\n\t\t\t\t\t\t\t\t<div class=\"bx-livechat-user-icon\">\n\t\t\t\t\t\t\t\t\t<div v-if=\"widget.dialog.operator.online\" class=\"bx-livechat-user-status\" :style=\"customBackgroundOnlineStyle\"></div>\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t</template>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t<div class=\"bx-livechat-user-info\">\n\t\t\t\t\t\t\t<div class=\"bx-livechat-user-name\">{{operatorName}}</div>\n\t\t\t\t\t\t\t<div class=\"bx-livechat-user-position\">{{operatorDescription}}</div>\t\t\t\t\t\t\t\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</template>\n\t\t\t\t\t<div class=\"bx-livechat-control-box\">\n\t\t\t\t\t\t<span class=\"bx-livechat-control-box-active\" v-if=\"widget.common.dialogStart && widget.dialog.sessionId\">\n\t\t\t\t\t\t\t<button v-if=\"widget.common.vote.enable && voteActive\" :class=\"'bx-livechat-control-btn bx-livechat-control-btn-like bx-livechat-dialog-vote-'+(widget.dialog.userVote)\" :title=\"localize.BX_LIVECHAT_VOTE_BUTTON\" @click=\"like\"></button>\n\t\t\t\t\t\t\t<button\n\t\t\t\t\t\t\t\tv-if=\"!ie11 && application.dialog.chatId > 0\"\n\t\t\t\t\t\t\t\tclass=\"bx-livechat-control-btn bx-livechat-control-btn-menu\"\n\t\t\t\t\t\t\t\t@click=\"openMenu\"\n\t\t\t\t\t\t\t\t:title=\"localize.BX_LIVECHAT_DOWNLOAD_HISTORY\"\n\t\t\t\t\t\t\t></button>\n\t\t\t\t\t\t</span>\t\n\t\t\t\t\t\t<button v-if=\"!widget.common.pageMode\" class=\"bx-livechat-control-btn bx-livechat-control-btn-close\" :title=\"localize.BX_LIVECHAT_CLOSE_BUTTON\" @click=\"close\"></button>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t</template>\n\t\t</div>\n\t"
	});

	/**
	 * Bitrix OpenLines widget
	 * Body loading component (Vue component)
	 *
	 * @package bitrix
	 * @subpackage imopenlines
	 * @copyright 2001-2019 Bitrix
	 */
	ui_vue.WidgetBitrixVue.component('bx-livechat-body-loading', {
	  template: "\n\t\t<div class=\"bx-livechat-loading-window\">\n\t\t\t<svg class=\"bx-livechat-loading-circular\" viewBox=\"25 25 50 50\">\n\t\t\t\t<circle class=\"bx-livechat-loading-path\" cx=\"50\" cy=\"50\" r=\"20\" fill=\"none\" stroke-miterlimit=\"10\"/>\n\t\t\t\t<circle class=\"bx-livechat-loading-inner-path\" cx=\"50\" cy=\"50\" r=\"20\" fill=\"none\" stroke-miterlimit=\"10\"/>\n\t\t\t</svg>\n\t\t\t<h3 class=\"bx-livechat-help-title bx-livechat-help-title-md bx-livechat-loading-msg\">{{$Bitrix.Loc.getMessage('BX_LIVECHAT_LOADING')}}</h3>\n\t\t</div>\n\t"
	});

	function ownKeys$4(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread$4(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$4(Object(source), !0).forEach(function (key) { babelHelpers.defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$4(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
	ui_vue.WidgetBitrixVue.component('bx-livechat-body-operators', {
	  computed: _objectSpread$4({}, ui_vue_vuex.WidgetVuex.mapState({
	    widget: function widget(state) {
	      return state.widget;
	    }
	  })),
	  template: "\n\t\t<div class=\"bx-livechat-help-container\">\n\t\t\t<transition name=\"bx-livechat-animation-fade\">\n\t\t\t\t<h2 v-if=\"widget.common.online\" key=\"online\" class=\"bx-livechat-help-title bx-livechat-help-title-lg\">{{widget.common.textMessages.bxLivechatOnlineLine1}}<div class=\"bx-livechat-help-subtitle\">{{widget.common.textMessages.bxLivechatOnlineLine2}}</div></h2>\n\t\t\t\t<h2 v-else key=\"offline\" class=\"bx-livechat-help-title bx-livechat-help-title-sm\">{{widget.common.textMessages.bxLivechatOffline}}</h2>\n\t\t\t</transition>\t\n\t\t\t<div class=\"bx-livechat-help-user\">\n\t\t\t\t<template v-for=\"operator in widget.common.operators\">\n\t\t\t\t\t<div class=\"bx-livechat-user\" :key=\"operator.id\">\n\t\t\t\t\t\t<template v-if=\"operator.avatar\">\n\t\t\t\t\t\t\t<div class=\"bx-livechat-user-icon\" :style=\"'background-image: url('+encodeURI(operator.avatar)+')'\"></div>\n\t\t\t\t\t\t</template>\n\t\t\t\t\t\t<template v-else>\n\t\t\t\t\t\t\t<div class=\"bx-livechat-user-icon\"></div>\n\t\t\t\t\t\t</template>\t\n\t\t\t\t\t\t<div class=\"bx-livechat-user-info\">\n\t\t\t\t\t\t\t<div class=\"bx-livechat-user-name\">{{operator.firstName? operator.firstName: operator.name}}</div>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>\n\t\t\t\t</template>\t\n\t\t\t</div>\n\t\t</div>\n\t"
	});

	/**
	 * Bitrix OpenLines widget
	 * Body orientation disabled component (Vue component)
	 *
	 * @package bitrix
	 * @subpackage imopenlines
	 * @copyright 2001-2019 Bitrix
	 */
	ui_vue.WidgetBitrixVue.component('bx-livechat-body-orientation-disabled', {
	  template: "\n\t\t<div class=\"bx-livechat-body\" key=\"orientation-head\">\n\t\t\t<div class=\"bx-livechat-mobile-orientation-box\">\n\t\t\t\t<div class=\"bx-livechat-mobile-orientation-icon\"></div>\n\t\t\t\t<div class=\"bx-livechat-mobile-orientation-text\">{{$Bitrix.Loc.getMessage('BX_LIVECHAT_MOBILE_ROTATE')}}</div>\n\t\t\t</div>\n\t\t</div>\n\t"
	});

	function ownKeys$5(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread$5(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$5(Object(source), !0).forEach(function (key) { babelHelpers.defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$5(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
	ui_vue.WidgetBitrixVue.component('bx-livechat-form-consent', {
	  /**
	   * @emits 'agree' {event: object} -- 'event' - click event
	   * @emits 'disagree' {event: object} -- 'event' - click event
	   */
	  computed: _objectSpread$5({}, ui_vue_vuex.WidgetVuex.mapState({
	    widget: function widget(state) {
	      return state.widget;
	    }
	  })),
	  methods: {
	    agree: function agree(event) {
	      this.$emit('agree', {
	        event: event
	      });
	    },
	    disagree: function disagree(event) {
	      this.$emit('disagree', {
	        event: event
	      });
	    },
	    onShow: function onShow(element, done) {
	      element.classList.add('bx-livechat-consent-window-show');
	      done();
	    },
	    onHide: function onHide(element, done) {
	      element.classList.remove('bx-livechat-consent-window-show');
	      element.classList.add('bx-livechat-consent-window-close');
	      setTimeout(function () {
	        done();
	      }, 400);
	    },
	    onKeyDown: function onKeyDown(event) {
	      if (event.keyCode == 9) {
	        if (event.target === this.$refs.iframe) {
	          if (event.shiftKey) {
	            this.$refs.cancel.focus();
	          } else {
	            this.$refs.success.focus();
	          }
	        } else if (event.target === this.$refs.success) {
	          if (event.shiftKey) {
	            this.$refs.iframe.focus();
	          } else {
	            this.$refs.cancel.focus();
	          }
	        } else if (event.target === this.$refs.cancel) {
	          if (event.shiftKey) {
	            this.$refs.success.focus();
	          } else {
	            this.$refs.iframe.focus();
	          }
	        }

	        event.preventDefault();
	      } else if (event.keyCode == 39 || event.keyCode == 37) {
	        if (event.target.nextElementSibling) {
	          event.target.nextElementSibling.focus();
	        } else if (event.target.previousElementSibling) {
	          event.target.previousElementSibling.focus();
	        }

	        event.preventDefault();
	      }
	    }
	  },
	  directives: {
	    focus: {
	      inserted: function inserted(element, params) {
	        element.focus();
	      }
	    }
	  },
	  template: "\n\t\t<transition @enter=\"onShow\" @leave=\"onHide\">\n\t\t\t<template v-if=\"widget.common.showConsent && widget.common.consentUrl\">\n\t\t\t\t<div class=\"bx-livechat-consent-window\">\n\t\t\t\t\t<div class=\"bx-livechat-consent-window-title\">{{$Bitrix.Loc.getMessage('BX_LIVECHAT_CONSENT_TITLE')}}</div>\n\t\t\t\t\t<div class=\"bx-livechat-consent-window-content\">\n\t\t\t\t\t\t<iframe class=\"bx-livechat-consent-window-content-iframe\" ref=\"iframe\" frameborder=\"0\" marginheight=\"0\"  marginwidth=\"0\" allowtransparency=\"allow-same-origin\" seamless=\"true\" :src=\"widget.common.consentUrl\" @keydown=\"onKeyDown\"></iframe>\n\t\t\t\t\t</div>\t\t\t\t\t\t\t\t\n\t\t\t\t\t<div class=\"bx-livechat-consent-window-btn-box\">\n\t\t\t\t\t\t<button class=\"bx-livechat-btn bx-livechat-btn-success\" ref=\"success\" @click=\"agree\" @keydown=\"onKeyDown\" v-focus>{{$Bitrix.Loc.getMessage('BX_LIVECHAT_CONSENT_AGREE')}}</button>\n\t\t\t\t\t\t<button class=\"bx-livechat-btn bx-livechat-btn-cancel\" ref=\"cancel\" @click=\"disagree\" @keydown=\"onKeyDown\">{{$Bitrix.Loc.getMessage('BX_LIVECHAT_CONSENT_DISAGREE')}}</button>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t</template>\n\t\t</transition>\n\t"
	});

	function ownKeys$6(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread$6(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$6(Object(source), !0).forEach(function (key) { babelHelpers.defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$6(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
	ui_vue.WidgetBitrixVue.component('bx-livechat-form-vote', {
	  computed: _objectSpread$6({
	    VoteType: function VoteType$$1() {
	      return VoteType;
	    }
	  }, ui_vue_vuex.WidgetVuex.mapState({
	    widget: function widget(state) {
	      return state.widget;
	    }
	  })),
	  methods: {
	    userVote: function userVote(vote) {
	      this.$store.commit('widget/common', {
	        showForm: FormType.none
	      });
	      this.$store.commit('widget/dialog', {
	        userVote: vote
	      });
	      this.$Bitrix.Application.get().sendDialogVote(vote);
	    },
	    hideForm: function hideForm(event) {
	      this.$parent.hideForm();
	    }
	  },
	  template: "\n\t\t<transition enter-active-class=\"bx-livechat-consent-window-show\" leave-active-class=\"bx-livechat-form-close\">\n\t\t\t<div class=\"bx-livechat-alert-box bx-livechat-form-rate-show\" key=\"vote\">\n\t\t\t\t<div class=\"bx-livechat-alert-close\" @click=\"hideForm\"></div>\n\t\t\t\t<div class=\"bx-livechat-alert-rate-box\">\n\t\t\t\t\t<h4 class=\"bx-livechat-alert-title bx-livechat-alert-title-mdl\">{{widget.common.vote.messageText}}</h4>\n\t\t\t\t\t<div class=\"bx-livechat-btn-box\">\n\t\t\t\t\t\t<button class=\"bx-livechat-btn bx-livechat-btn-like\" @click=\"userVote(VoteType.like)\" :title=\"widget.common.vote.messageLike\"></button>\n\t\t\t\t\t\t<button class=\"bx-livechat-btn bx-livechat-btn-dislike\" @click=\"userVote(VoteType.dislike)\" :title=\"widget.common.vote.messageDislike\"></button>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t</transition>\t\n\t"
	});

	/**
	 * Bitrix OpenLines widget
	 * Smiles component (Vue component)
	 *
	 * @package bitrix
	 * @subpackage imopenlines
	 * @copyright 2001-2019 Bitrix
	 */
	ui_vue.WidgetVue.cloneComponent('bx-livechat-smiles', 'bx-smiles', {
	  methods: {
	    hideForm: function hideForm(event) {
	      this.$parent.hideForm();
	    }
	  },
	  template: "\n\t\t<transition enter-active-class=\"bx-livechat-consent-window-show\" leave-active-class=\"bx-livechat-form-close\">\n\t\t\t<div class=\"bx-livechat-alert-box bx-livechat-alert-box-zero-padding bx-livechat-form-show\" key=\"vote\">\n\t\t\t\t<div class=\"bx-livechat-alert-close\" @click=\"hideForm\"></div>\n\t\t\t\t<div class=\"bx-livechat-alert-smiles-box\">\n\t\t\t\t\t#PARENT_TEMPLATE#\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t</transition>\n\t"
	});

	/**
	 * Bitrix OpenLines widget
	 * Widget component & controller
	 *
	 * @package bitrix
	 * @subpackage imopenlines
	 * @copyright 2001-2019 Bitrix
	 */
	BX.LiveChatWidget = WidgetPublicManager;
	BX.LiveChatWidget.VoteType = VoteType;
	BX.LiveChatWidget.SubscriptionType = SubscriptionType;
	BX.LiveChatWidget.LocationStyle = LocationStyle;
	BX.LiveChatWidget.Cookie = im_lib_cookie.Cookie;
	window.dispatchEvent(new CustomEvent('onBitrixLiveChatSourceLoaded', {
	  detail: {}
	}));

}((this.window = this.window || {}),BX,window,window,BX.Messenger,window,BX,window,window,BX,BX.Messenger.Provider.Rest,BX,BX,BX.Ui.Vue.Components.Crm,BX.Messenger,BX.Messenger.Lib,BX.Messenger.Lib,BX.Messenger.Lib,BX.Messenger.Lib,BX.Messenger.Lib,BX.Messenger.Mixin,BX,BX.Event,BX.Messenger.Const,BX,BX,BX));
 


