// widget bundle

// file: /bitrix/js/main/core/minimal/dist/main.core.minimal.bundle.js
;(function() {

	if (typeof window.BX === 'function')
	{
		return;
	}

/**
 * Babel external helpers
 * (c) 2018 Babel
 * @license MIT
 */
(function (global) {
  var babelHelpers = global.babelHelpers = {};

  function _typeof(obj) {
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      babelHelpers.typeof = _typeof = function (obj) {
        return typeof obj;
      };
    } else {
      babelHelpers.typeof = _typeof = function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof(obj);
  }

  babelHelpers.typeof = _typeof;
  var REACT_ELEMENT_TYPE;

  function _createRawReactElement(type, props, key, children) {
    if (!REACT_ELEMENT_TYPE) {
      REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7;
    }

    var defaultProps = type && type.defaultProps;
    var childrenLength = arguments.length - 3;

    if (!props && childrenLength !== 0) {
      props = {
        children: void 0
      };
    }

    if (props && defaultProps) {
      for (var propName in defaultProps) {
        if (props[propName] === void 0) {
          props[propName] = defaultProps[propName];
        }
      }
    } else if (!props) {
      props = defaultProps || {};
    }

    if (childrenLength === 1) {
      props.children = children;
    } else if (childrenLength > 1) {
      var childArray = new Array(childrenLength);

      for (var i = 0; i < childrenLength; i++) {
        childArray[i] = arguments[i + 3];
      }

      props.children = childArray;
    }

    return {
      $$typeof: REACT_ELEMENT_TYPE,
      type: type,
      key: key === undefined ? null : '' + key,
      ref: null,
      props: props,
      _owner: null
    };
  }

  babelHelpers.jsx = _createRawReactElement;

  function _asyncIterator(iterable) {
    var method;

    if (typeof Symbol === "function") {
      if (Symbol.asyncIterator) {
        method = iterable[Symbol.asyncIterator];
        if (method != null) return method.call(iterable);
      }

      if (Symbol.iterator) {
        method = iterable[Symbol.iterator];
        if (method != null) return method.call(iterable);
      }
    }

    throw new TypeError("Object is not async iterable");
  }

  babelHelpers.asyncIterator = _asyncIterator;

  function _AwaitValue(value) {
    this.wrapped = value;
  }

  babelHelpers.AwaitValue = _AwaitValue;

  function AsyncGenerator(gen) {
    var front, back;

    function send(key, arg) {
      return new Promise(function (resolve, reject) {
        var request = {
          key: key,
          arg: arg,
          resolve: resolve,
          reject: reject,
          next: null
        };

        if (back) {
          back = back.next = request;
        } else {
          front = back = request;
          resume(key, arg);
        }
      });
    }

    function resume(key, arg) {
      try {
        var result = gen[key](arg);
        var value = result.value;
        var wrappedAwait = value instanceof babelHelpers.AwaitValue;
        Promise.resolve(wrappedAwait ? value.wrapped : value).then(function (arg) {
          if (wrappedAwait) {
            resume("next", arg);
            return;
          }

          settle(result.done ? "return" : "normal", arg);
        }, function (err) {
          resume("throw", err);
        });
      } catch (err) {
        settle("throw", err);
      }
    }

    function settle(type, value) {
      switch (type) {
        case "return":
          front.resolve({
            value: value,
            done: true
          });
          break;

        case "throw":
          front.reject(value);
          break;

        default:
          front.resolve({
            value: value,
            done: false
          });
          break;
      }

      front = front.next;

      if (front) {
        resume(front.key, front.arg);
      } else {
        back = null;
      }
    }

    this._invoke = send;

    if (typeof gen.return !== "function") {
      this.return = undefined;
    }
  }

  if (typeof Symbol === "function" && Symbol.asyncIterator) {
    AsyncGenerator.prototype[Symbol.asyncIterator] = function () {
      return this;
    };
  }

  AsyncGenerator.prototype.next = function (arg) {
    return this._invoke("next", arg);
  };

  AsyncGenerator.prototype.throw = function (arg) {
    return this._invoke("throw", arg);
  };

  AsyncGenerator.prototype.return = function (arg) {
    return this._invoke("return", arg);
  };

  babelHelpers.AsyncGenerator = AsyncGenerator;

  function _wrapAsyncGenerator(fn) {
    return function () {
      return new babelHelpers.AsyncGenerator(fn.apply(this, arguments));
    };
  }

  babelHelpers.wrapAsyncGenerator = _wrapAsyncGenerator;

  function _awaitAsyncGenerator(value) {
    return new babelHelpers.AwaitValue(value);
  }

  babelHelpers.awaitAsyncGenerator = _awaitAsyncGenerator;

  function _asyncGeneratorDelegate(inner, awaitWrap) {
    var iter = {},
        waiting = false;

    function pump(key, value) {
      waiting = true;
      value = new Promise(function (resolve) {
        resolve(inner[key](value));
      });
      return {
        done: false,
        value: awaitWrap(value)
      };
    }

    ;

    if (typeof Symbol === "function" && Symbol.iterator) {
      iter[Symbol.iterator] = function () {
        return this;
      };
    }

    iter.next = function (value) {
      if (waiting) {
        waiting = false;
        return value;
      }

      return pump("next", value);
    };

    if (typeof inner.throw === "function") {
      iter.throw = function (value) {
        if (waiting) {
          waiting = false;
          throw value;
        }

        return pump("throw", value);
      };
    }

    if (typeof inner.return === "function") {
      iter.return = function (value) {
        return pump("return", value);
      };
    }

    return iter;
  }

  babelHelpers.asyncGeneratorDelegate = _asyncGeneratorDelegate;

  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }

    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }

  function _asyncToGenerator(fn) {
    return function () {
      var self = this,
          args = arguments;
      return new Promise(function (resolve, reject) {
        var gen = fn.apply(self, args);

        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }

        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }

        _next(undefined);
      });
    };
  }

  babelHelpers.asyncToGenerator = _asyncToGenerator;

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  babelHelpers.classCallCheck = _classCallCheck;

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  babelHelpers.createClass = _createClass;

  function _defineEnumerableProperties(obj, descs) {
    for (var key in descs) {
      var desc = descs[key];
      desc.configurable = desc.enumerable = true;
      if ("value" in desc) desc.writable = true;
      Object.defineProperty(obj, key, desc);
    }

    if (Object.getOwnPropertySymbols) {
      var objectSymbols = Object.getOwnPropertySymbols(descs);

      for (var i = 0; i < objectSymbols.length; i++) {
        var sym = objectSymbols[i];
        var desc = descs[sym];
        desc.configurable = desc.enumerable = true;
        if ("value" in desc) desc.writable = true;
        Object.defineProperty(obj, sym, desc);
      }
    }

    return obj;
  }

  babelHelpers.defineEnumerableProperties = _defineEnumerableProperties;

  function _defaults(obj, defaults) {
    var keys = Object.getOwnPropertyNames(defaults);

    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      var value = Object.getOwnPropertyDescriptor(defaults, key);

      if (value && value.configurable && obj[key] === undefined) {
        Object.defineProperty(obj, key, value);
      }
    }

    return obj;
  }

  babelHelpers.defaults = _defaults;

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  babelHelpers.defineProperty = _defineProperty;

  function _extends() {
    babelHelpers.extends = _extends = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    };

    return _extends.apply(this, arguments);
  }

  babelHelpers.extends = _extends;

  function _objectSpread(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      var ownKeys = Object.keys(source);

      if (typeof Object.getOwnPropertySymbols === 'function') {
        ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }));
      }

      ownKeys.forEach(function (key) {
        babelHelpers.defineProperty(target, key, source[key]);
      });
    }

    return target;
  }

  babelHelpers.objectSpread = _objectSpread;

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) babelHelpers.setPrototypeOf(subClass, superClass);
  }

  babelHelpers.inherits = _inherits;

  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    subClass.__proto__ = superClass;
  }

  babelHelpers.inheritsLoose = _inheritsLoose;

  function _getPrototypeOf(o) {
    babelHelpers.getPrototypeOf = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }

  babelHelpers.getPrototypeOf = _getPrototypeOf;

  function _setPrototypeOf(o, p) {
    babelHelpers.setPrototypeOf = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }

  babelHelpers.setPrototypeOf = _setPrototypeOf;

  function isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  function _construct(Parent, args, Class) {
    if (isNativeReflectConstruct()) {
      babelHelpers.construct = _construct = Reflect.construct;
    } else {
      babelHelpers.construct = _construct = function _construct(Parent, args, Class) {
        var a = [null];
        a.push.apply(a, args);
        var Constructor = Function.bind.apply(Parent, a);
        var instance = new Constructor();
        if (Class) babelHelpers.setPrototypeOf(instance, Class.prototype);
        return instance;
      };
    }

    return _construct.apply(null, arguments);
  }

  babelHelpers.construct = _construct;

  function _isNativeFunction(fn) {
    return Function.toString.call(fn).indexOf("[native code]") !== -1;
  }

  babelHelpers.isNativeFunction = _isNativeFunction;

  function _wrapNativeSuper(Class) {
    var _cache = typeof Map === "function" ? new Map() : undefined;

    babelHelpers.wrapNativeSuper = _wrapNativeSuper = function _wrapNativeSuper(Class) {
      if (Class === null || !babelHelpers.isNativeFunction(Class)) return Class;

      if (typeof Class !== "function") {
        throw new TypeError("Super expression must either be null or a function");
      }

      if (typeof _cache !== "undefined") {
        if (_cache.has(Class)) return _cache.get(Class);

        _cache.set(Class, Wrapper);
      }

      function Wrapper() {
        return babelHelpers.construct(Class, arguments, babelHelpers.getPrototypeOf(this).constructor);
      }

      Wrapper.prototype = Object.create(Class.prototype, {
        constructor: {
          value: Wrapper,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
      return babelHelpers.setPrototypeOf(Wrapper, Class);
    };

    return _wrapNativeSuper(Class);
  }

  babelHelpers.wrapNativeSuper = _wrapNativeSuper;

  function _instanceof(left, right) {
    if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) {
      return right[Symbol.hasInstance](left);
    } else {
      return left instanceof right;
    }
  }

  babelHelpers.instanceof = _instanceof;

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }

  babelHelpers.interopRequireDefault = _interopRequireDefault;

  function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
      return obj;
    } else {
      var newObj = {};

      if (obj != null) {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};

            if (desc.get || desc.set) {
              Object.defineProperty(newObj, key, desc);
            } else {
              newObj[key] = obj[key];
            }
          }
        }
      }

      newObj.default = obj;
      return newObj;
    }
  }

  babelHelpers.interopRequireWildcard = _interopRequireWildcard;

  function _newArrowCheck(innerThis, boundThis) {
    if (innerThis !== boundThis) {
      throw new TypeError("Cannot instantiate an arrow function");
    }
  }

  babelHelpers.newArrowCheck = _newArrowCheck;

  function _objectDestructuringEmpty(obj) {
    if (obj == null) throw new TypeError("Cannot destructure undefined");
  }

  babelHelpers.objectDestructuringEmpty = _objectDestructuringEmpty;

  function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;

    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }

    return target;
  }

  babelHelpers.objectWithoutPropertiesLoose = _objectWithoutPropertiesLoose;

  function _objectWithoutProperties(source, excluded) {
    if (source == null) return {};
    var target = babelHelpers.objectWithoutPropertiesLoose(source, excluded);
    var key, i;

    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

      for (i = 0; i < sourceSymbolKeys.length; i++) {
        key = sourceSymbolKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
        target[key] = source[key];
      }
    }

    return target;
  }

  babelHelpers.objectWithoutProperties = _objectWithoutProperties;

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  babelHelpers.assertThisInitialized = _assertThisInitialized;

  function _possibleConstructorReturn(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
      return call;
    }

    return babelHelpers.assertThisInitialized(self);
  }

  babelHelpers.possibleConstructorReturn = _possibleConstructorReturn;

  function _superPropBase(object, property) {
    while (!Object.prototype.hasOwnProperty.call(object, property)) {
      object = babelHelpers.getPrototypeOf(object);
      if (object === null) break;
    }

    return object;
  }

  babelHelpers.superPropBase = _superPropBase;

  function _get(target, property, receiver) {
    if (typeof Reflect !== "undefined" && Reflect.get) {
      babelHelpers.get = _get = Reflect.get;
    } else {
      babelHelpers.get = _get = function _get(target, property, receiver) {
        var base = babelHelpers.superPropBase(target, property);
        if (!base) return;
        var desc = Object.getOwnPropertyDescriptor(base, property);

        if (desc.get) {
          return desc.get.call(receiver);
        }

        return desc.value;
      };
    }

    return _get(target, property, receiver || target);
  }

  babelHelpers.get = _get;

  function set(target, property, value, receiver) {
    if (typeof Reflect !== "undefined" && Reflect.set) {
      set = Reflect.set;
    } else {
      set = function set(target, property, value, receiver) {
        var base = babelHelpers.superPropBase(target, property);
        var desc;

        if (base) {
          desc = Object.getOwnPropertyDescriptor(base, property);

          if (desc.set) {
            desc.set.call(receiver, value);
            return true;
          } else if (!desc.writable) {
            return false;
          }
        }

        desc = Object.getOwnPropertyDescriptor(receiver, property);

        if (desc) {
          if (!desc.writable) {
            return false;
          }

          desc.value = value;
          Object.defineProperty(receiver, property, desc);
        } else {
          babelHelpers.defineProperty(receiver, property, value);
        }

        return true;
      };
    }

    return set(target, property, value, receiver);
  }

  function _set(target, property, value, receiver, isStrict) {
    var s = set(target, property, value, receiver || target);

    if (!s && isStrict) {
      throw new Error('failed to set property');
    }

    return value;
  }

  babelHelpers.set = _set;

  function _taggedTemplateLiteral(strings, raw) {
    if (!raw) {
      raw = strings.slice(0);
    }

    return Object.freeze(Object.defineProperties(strings, {
      raw: {
        value: Object.freeze(raw)
      }
    }));
  }

  babelHelpers.taggedTemplateLiteral = _taggedTemplateLiteral;

  function _taggedTemplateLiteralLoose(strings, raw) {
    if (!raw) {
      raw = strings.slice(0);
    }

    strings.raw = raw;
    return strings;
  }

  babelHelpers.taggedTemplateLiteralLoose = _taggedTemplateLiteralLoose;

  function _temporalRef(val, name) {
    if (val === babelHelpers.temporalUndefined) {
      throw new ReferenceError(name + " is not defined - temporal dead zone");
    } else {
      return val;
    }
  }

  babelHelpers.temporalRef = _temporalRef;

  function _readOnlyError(name) {
    throw new Error("\"" + name + "\" is read-only");
  }

  babelHelpers.readOnlyError = _readOnlyError;

  function _classNameTDZError(name) {
    throw new Error("Class \"" + name + "\" cannot be referenced in computed property keys.");
  }

  babelHelpers.classNameTDZError = _classNameTDZError;
  babelHelpers.temporalUndefined = {};

  function _slicedToArray(arr, i) {
    return babelHelpers.arrayWithHoles(arr) || babelHelpers.iterableToArrayLimit(arr, i) || babelHelpers.nonIterableRest();
  }

  babelHelpers.slicedToArray = _slicedToArray;

  function _slicedToArrayLoose(arr, i) {
    return babelHelpers.arrayWithHoles(arr) || babelHelpers.iterableToArrayLimitLoose(arr, i) || babelHelpers.nonIterableRest();
  }

  babelHelpers.slicedToArrayLoose = _slicedToArrayLoose;

  function _toArray(arr) {
    return babelHelpers.arrayWithHoles(arr) || babelHelpers.iterableToArray(arr) || babelHelpers.nonIterableRest();
  }

  babelHelpers.toArray = _toArray;

  function _toConsumableArray(arr) {
    return babelHelpers.arrayWithoutHoles(arr) || babelHelpers.iterableToArray(arr) || babelHelpers.nonIterableSpread();
  }

  babelHelpers.toConsumableArray = _toConsumableArray;

  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

      return arr2;
    }
  }

  babelHelpers.arrayWithoutHoles = _arrayWithoutHoles;

  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }

  babelHelpers.arrayWithHoles = _arrayWithHoles;

  function _iterableToArray(iter) {
    if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
  }

  babelHelpers.iterableToArray = _iterableToArray;

  function _iterableToArrayLimit(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  babelHelpers.iterableToArrayLimit = _iterableToArrayLimit;

  function _iterableToArrayLimitLoose(arr, i) {
    var _arr = [];

    for (var _iterator = arr[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) {
      _arr.push(_step.value);

      if (i && _arr.length === i) break;
    }

    return _arr;
  }

  babelHelpers.iterableToArrayLimitLoose = _iterableToArrayLimitLoose;

  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance");
  }

  babelHelpers.nonIterableSpread = _nonIterableSpread;

  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance");
  }

  babelHelpers.nonIterableRest = _nonIterableRest;

  function _skipFirstGeneratorNext(fn) {
    return function () {
      var it = fn.apply(this, arguments);
      it.next();
      return it;
    };
  }

  babelHelpers.skipFirstGeneratorNext = _skipFirstGeneratorNext;

  function _toPropertyKey(key) {
    if (typeof key === "symbol") {
      return key;
    } else {
      return String(key);
    }
  }

  babelHelpers.toPropertyKey = _toPropertyKey;

  function _initializerWarningHelper(descriptor, context) {
    throw new Error('Decorating class property failed. Please ensure that ' + 'proposal-class-properties is enabled and set to use loose mode. ' + 'To use proposal-class-properties in spec mode with decorators, wait for ' + 'the next major version of decorators in stage 2.');
  }

  babelHelpers.initializerWarningHelper = _initializerWarningHelper;

  function _initializerDefineProperty(target, property, descriptor, context) {
    if (!descriptor) return;
    Object.defineProperty(target, property, {
      enumerable: descriptor.enumerable,
      configurable: descriptor.configurable,
      writable: descriptor.writable,
      value: descriptor.initializer ? descriptor.initializer.call(context) : void 0
    });
  }

  babelHelpers.initializerDefineProperty = _initializerDefineProperty;

  function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
    var desc = {};
    Object['ke' + 'ys'](descriptor).forEach(function (key) {
      desc[key] = descriptor[key];
    });
    desc.enumerable = !!desc.enumerable;
    desc.configurable = !!desc.configurable;

    if ('value' in desc || desc.initializer) {
      desc.writable = true;
    }

    desc = decorators.slice().reverse().reduce(function (desc, decorator) {
      return decorator(target, property, desc) || desc;
    }, desc);

    if (context && desc.initializer !== void 0) {
      desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
      desc.initializer = undefined;
    }

    if (desc.initializer === void 0) {
      Object['define' + 'Property'](target, property, desc);
      desc = null;
    }

    return desc;
  }

  babelHelpers.applyDecoratedDescriptor = _applyDecoratedDescriptor;
  var id = 0;

  function _classPrivateFieldKey(name) {
    return "__private_" + id++ + "_" + name;
  }

  babelHelpers.classPrivateFieldLooseKey = _classPrivateFieldKey;

  function _classPrivateFieldBase(receiver, privateKey) {
    if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {
      throw new TypeError("attempted to use private field on non-instance");
    }

    return receiver;
  }

  babelHelpers.classPrivateFieldLooseBase = _classPrivateFieldBase;

  function _classPrivateFieldGet(receiver, privateMap) {
    if (!privateMap.has(receiver)) {
      throw new TypeError("attempted to get private field on non-instance");
    }

    return privateMap.get(receiver).value;
  }

  babelHelpers.classPrivateFieldGet = _classPrivateFieldGet;

  function _classPrivateFieldSet(receiver, privateMap, value) {
    if (!privateMap.has(receiver)) {
      throw new TypeError("attempted to set private field on non-instance");
    }

    var descriptor = privateMap.get(receiver);

    if (!descriptor.writable) {
      throw new TypeError("attempted to set read only private field");
    }

    descriptor.value = value;
    return value;
  }

  babelHelpers.classPrivateFieldSet = _classPrivateFieldSet;
})(typeof global === "undefined" ? window : global);

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

!(function(global) {
	"use strict";

	var Op = Object.prototype;
	var hasOwn = Op.hasOwnProperty;
	var undefined; // More compressible than void 0.
	var $Symbol = typeof Symbol === "function" ? Symbol : {};
	var iteratorSymbol = $Symbol.iterator || "@@iterator";
	var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
	var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

	// Define the runtime globally (as expected by generated code) as either
	// module.exports (if we're in a module) or a new, empty object.
	var runtime = global.regeneratorRuntime = {};

	function wrap(innerFn, outerFn, self, tryLocsList) {
		// If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
		var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
		var generator = Object.create(protoGenerator.prototype);
		var context = new Context(tryLocsList || []);

		// The ._invoke method unifies the implementations of the .next,
		// .throw, and .return methods.
		generator._invoke = makeInvokeMethod(innerFn, self, context);

		return generator;
	}
	runtime.wrap = wrap;

	// Try/catch helper to minimize deoptimizations. Returns a completion
	// record like context.tryEntries[i].completion. This interface could
	// have been (and was previously) designed to take a closure to be
	// invoked without arguments, but in all the cases we care about we
	// already have an existing method we want to call, so there's no need
	// to create a new function object. We can even get away with assuming
	// the method takes exactly one argument, since that happens to be true
	// in every case, so we don't have to touch the arguments object. The
	// only additional allocation required is the completion record, which
	// has a stable shape and so hopefully should be cheap to allocate.
	function tryCatch(fn, obj, arg) {
		try {
			return { type: "normal", arg: fn.call(obj, arg) };
		} catch (err) {
			return { type: "throw", arg: err };
		}
	}

	var GenStateSuspendedStart = "suspendedStart";
	var GenStateSuspendedYield = "suspendedYield";
	var GenStateExecuting = "executing";
	var GenStateCompleted = "completed";

	// Returning this object from the innerFn has the same effect as
	// breaking out of the dispatch switch statement.
	var ContinueSentinel = {};

	// Dummy constructor functions that we use as the .constructor and
	// .constructor.prototype properties for functions that return Generator
	// objects. For full spec compliance, you may wish to configure your
	// minifier not to mangle the names of these two functions.
	function Generator() {}
	function GeneratorFunction() {}
	function GeneratorFunctionPrototype() {}

	// This is a polyfill for %IteratorPrototype% for environments that
	// don't natively support it.
	var IteratorPrototype = {};
	IteratorPrototype[iteratorSymbol] = function () {
		return this;
	};

	var getProto = Object.getPrototypeOf;
	var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
	if (NativeIteratorPrototype &&
		NativeIteratorPrototype !== Op &&
		hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
		// This environment has a native %IteratorPrototype%; use it instead
		// of the polyfill.
		IteratorPrototype = NativeIteratorPrototype;
	}

	var Gp = GeneratorFunctionPrototype.prototype =
		Generator.prototype = Object.create(IteratorPrototype);
	GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
	GeneratorFunctionPrototype.constructor = GeneratorFunction;
	GeneratorFunctionPrototype[toStringTagSymbol] =
		GeneratorFunction.displayName = "GeneratorFunction";

	// Helper for defining the .next, .throw, and .return methods of the
	// Iterator interface in terms of a single ._invoke method.
	function defineIteratorMethods(prototype) {
		["next", "throw", "return"].forEach(function(method) {
			prototype[method] = function(arg) {
				return this._invoke(method, arg);
			};
		});
	}

	runtime.isGeneratorFunction = function(genFun) {
		var ctor = typeof genFun === "function" && genFun.constructor;
		return ctor
			? ctor === GeneratorFunction ||
			// For the native GeneratorFunction constructor, the best we can
			// do is to check its .name property.
			(ctor.displayName || ctor.name) === "GeneratorFunction"
			: false;
	};

	runtime.mark = function(genFun) {
		if (Object.setPrototypeOf) {
			Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
		} else {
			genFun.__proto__ = GeneratorFunctionPrototype;
			if (!(toStringTagSymbol in genFun)) {
				genFun[toStringTagSymbol] = "GeneratorFunction";
			}
		}
		genFun.prototype = Object.create(Gp);
		return genFun;
	};

	// Within the body of any async function, `await x` is transformed to
	// `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
	// `hasOwn.call(value, "__await")` to determine if the yielded value is
	// meant to be awaited.
	runtime.awrap = function(arg) {
		return { __await: arg };
	};

	function AsyncIterator(generator) {
		function invoke(method, arg, resolve, reject) {
			var record = tryCatch(generator[method], generator, arg);
			if (record.type === "throw") {
				reject(record.arg);
			} else {
				var result = record.arg;
				var value = result.value;
				if (value &&
					typeof value === "object" &&
					hasOwn.call(value, "__await")) {
					return Promise.resolve(value.__await).then(function(value) {
						invoke("next", value, resolve, reject);
					}, function(err) {
						invoke("throw", err, resolve, reject);
					});
				}

				return Promise.resolve(value).then(function(unwrapped) {
					// When a yielded Promise is resolved, its final value becomes
					// the .value of the Promise<{value,done}> result for the
					// current iteration. If the Promise is rejected, however, the
					// result for this iteration will be rejected with the same
					// reason. Note that rejections of yielded Promises are not
					// thrown back into the generator function, as is the case
					// when an awaited Promise is rejected. This difference in
					// behavior between yield and await is important, because it
					// allows the consumer to decide what to do with the yielded
					// rejection (swallow it and continue, manually .throw it back
					// into the generator, abandon iteration, whatever). With
					// await, by contrast, there is no opportunity to examine the
					// rejection reason outside the generator function, so the
					// only option is to throw it from the await expression, and
					// let the generator function handle the exception.
					result.value = unwrapped;
					resolve(result);
				}, reject);
			}
		}

		var previousPromise;

		function enqueue(method, arg) {
			function callInvokeWithMethodAndArg() {
				return new Promise(function(resolve, reject) {
					invoke(method, arg, resolve, reject);
				});
			}

			return previousPromise =
				// If enqueue has been called before, then we want to wait until
				// all previous Promises have been resolved before calling invoke,
				// so that results are always delivered in the correct order. If
				// enqueue has not been called before, then it is important to
				// call invoke immediately, without waiting on a callback to fire,
				// so that the async generator function has the opportunity to do
				// any necessary setup in a predictable way. This predictability
				// is why the Promise constructor synchronously invokes its
				// executor callback, and why async functions synchronously
				// execute code before the first await. Since we implement simple
				// async functions in terms of async generators, it is especially
				// important to get this right, even though it requires care.
				previousPromise ? previousPromise.then(
					callInvokeWithMethodAndArg,
					// Avoid propagating failures to Promises returned by later
					// invocations of the iterator.
					callInvokeWithMethodAndArg
				) : callInvokeWithMethodAndArg();
		}

		// Define the unified helper method that is used to implement .next,
		// .throw, and .return (see defineIteratorMethods).
		this._invoke = enqueue;
	}

	defineIteratorMethods(AsyncIterator.prototype);
	AsyncIterator.prototype[asyncIteratorSymbol] = function () {
		return this;
	};
	runtime.AsyncIterator = AsyncIterator;

	// Note that simple async functions are implemented on top of
	// AsyncIterator objects; they just return a Promise for the value of
	// the final result produced by the iterator.
	runtime.async = function(innerFn, outerFn, self, tryLocsList) {
		var iter = new AsyncIterator(
			wrap(innerFn, outerFn, self, tryLocsList)
		);

		return runtime.isGeneratorFunction(outerFn)
			? iter // If outerFn is a generator, return the full iterator.
			: iter.next().then(function(result) {
				return result.done ? result.value : iter.next();
			});
	};

	function makeInvokeMethod(innerFn, self, context) {
		var state = GenStateSuspendedStart;

		return function invoke(method, arg) {
			if (state === GenStateExecuting) {
				throw new Error("Generator is already running");
			}

			if (state === GenStateCompleted) {
				if (method === "throw") {
					throw arg;
				}

				// Be forgiving, per 25.3.3.3.3 of the spec:
				// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
				return doneResult();
			}

			context.method = method;
			context.arg = arg;

			while (true) {
				var delegate = context.delegate;
				if (delegate) {
					var delegateResult = maybeInvokeDelegate(delegate, context);
					if (delegateResult) {
						if (delegateResult === ContinueSentinel) continue;
						return delegateResult;
					}
				}

				if (context.method === "next") {
					// Setting context._sent for legacy support of Babel's
					// function.sent implementation.
					context.sent = context._sent = context.arg;

				} else if (context.method === "throw") {
					if (state === GenStateSuspendedStart) {
						state = GenStateCompleted;
						throw context.arg;
					}

					context.dispatchException(context.arg);

				} else if (context.method === "return") {
					context.abrupt("return", context.arg);
				}

				state = GenStateExecuting;

				var record = tryCatch(innerFn, self, context);
				if (record.type === "normal") {
					// If an exception is thrown from innerFn, we leave state ===
					// GenStateExecuting and loop back for another invocation.
					state = context.done
						? GenStateCompleted
						: GenStateSuspendedYield;

					if (record.arg === ContinueSentinel) {
						continue;
					}

					return {
						value: record.arg,
						done: context.done
					};

				} else if (record.type === "throw") {
					state = GenStateCompleted;
					// Dispatch the exception by looping back around to the
					// context.dispatchException(context.arg) call above.
					context.method = "throw";
					context.arg = record.arg;
				}
			}
		};
	}

	// Call delegate.iterator[context.method](context.arg) and handle the
	// result, either by returning a { value, done } result from the
	// delegate iterator, or by modifying context.method and context.arg,
	// setting context.delegate to null, and returning the ContinueSentinel.
	function maybeInvokeDelegate(delegate, context) {
		var method = delegate.iterator[context.method];
		if (method === undefined) {
			// A .throw or .return when the delegate iterator has no .throw
			// method always terminates the yield* loop.
			context.delegate = null;

			if (context.method === "throw") {
				if (delegate.iterator.return) {
					// If the delegate iterator has a return method, give it a
					// chance to clean up.
					context.method = "return";
					context.arg = undefined;
					maybeInvokeDelegate(delegate, context);

					if (context.method === "throw") {
						// If maybeInvokeDelegate(context) changed context.method from
						// "return" to "throw", let that override the TypeError below.
						return ContinueSentinel;
					}
				}

				context.method = "throw";
				context.arg = new TypeError(
					"The iterator does not provide a 'throw' method");
			}

			return ContinueSentinel;
		}

		var record = tryCatch(method, delegate.iterator, context.arg);

		if (record.type === "throw") {
			context.method = "throw";
			context.arg = record.arg;
			context.delegate = null;
			return ContinueSentinel;
		}

		var info = record.arg;

		if (! info) {
			context.method = "throw";
			context.arg = new TypeError("iterator result is not an object");
			context.delegate = null;
			return ContinueSentinel;
		}

		if (info.done) {
			// Assign the result of the finished delegate to the temporary
			// variable specified by delegate.resultName (see delegateYield).
			context[delegate.resultName] = info.value;

			// Resume execution at the desired location (see delegateYield).
			context.next = delegate.nextLoc;

			// If context.method was "throw" but the delegate handled the
			// exception, let the outer generator proceed normally. If
			// context.method was "next", forget context.arg since it has been
			// "consumed" by the delegate iterator. If context.method was
			// "return", allow the original .return call to continue in the
			// outer generator.
			if (context.method !== "return") {
				context.method = "next";
				context.arg = undefined;
			}

		} else {
			// Re-yield the result returned by the delegate method.
			return info;
		}

		// The delegate iterator is finished, so forget it and continue with
		// the outer generator.
		context.delegate = null;
		return ContinueSentinel;
	}

	// Define Generator.prototype.{next,throw,return} in terms of the
	// unified ._invoke helper method.
	defineIteratorMethods(Gp);

	Gp[toStringTagSymbol] = "Generator";

	// A Generator should always return itself as the iterator object when the
	// @@iterator function is called on it. Some browsers' implementations of the
	// iterator prototype chain incorrectly implement this, causing the Generator
	// object to not be returned from this call. This ensures that doesn't happen.
	// See https://github.com/facebook/regenerator/issues/274 for more details.
	Gp[iteratorSymbol] = function() {
		return this;
	};

	Gp.toString = function() {
		return "[object Generator]";
	};

	function pushTryEntry(locs) {
		var entry = { tryLoc: locs[0] };

		if (1 in locs) {
			entry.catchLoc = locs[1];
		}

		if (2 in locs) {
			entry.finallyLoc = locs[2];
			entry.afterLoc = locs[3];
		}

		this.tryEntries.push(entry);
	}

	function resetTryEntry(entry) {
		var record = entry.completion || {};
		record.type = "normal";
		delete record.arg;
		entry.completion = record;
	}

	function Context(tryLocsList) {
		// The root entry object (effectively a try statement without a catch
		// or a finally block) gives us a place to store values thrown from
		// locations where there is no enclosing try statement.
		this.tryEntries = [{ tryLoc: "root" }];
		tryLocsList.forEach(pushTryEntry, this);
		this.reset(true);
	}

	runtime.keys = function(object) {
		var keys = [];
		for (var key in object) {
			keys.push(key);
		}
		keys.reverse();

		// Rather than returning an object with a next method, we keep
		// things simple and return the next function itself.
		return function next() {
			while (keys.length) {
				var key = keys.pop();
				if (key in object) {
					next.value = key;
					next.done = false;
					return next;
				}
			}

			// To avoid creating an additional object, we just hang the .value
			// and .done properties off the next function object itself. This
			// also ensures that the minifier will not anonymize the function.
			next.done = true;
			return next;
		};
	};

	function values(iterable) {
		if (iterable) {
			var iteratorMethod = iterable[iteratorSymbol];
			if (iteratorMethod) {
				return iteratorMethod.call(iterable);
			}

			if (typeof iterable.next === "function") {
				return iterable;
			}

			if (!isNaN(iterable.length)) {
				var i = -1, next = function next() {
					while (++i < iterable.length) {
						if (hasOwn.call(iterable, i)) {
							next.value = iterable[i];
							next.done = false;
							return next;
						}
					}

					next.value = undefined;
					next.done = true;

					return next;
				};

				return next.next = next;
			}
		}

		// Return an iterator with no values.
		return { next: doneResult };
	}
	runtime.values = values;

	function doneResult() {
		return { value: undefined, done: true };
	}

	Context.prototype = {
		constructor: Context,

		reset: function(skipTempReset) {
			this.prev = 0;
			this.next = 0;
			// Resetting context._sent for legacy support of Babel's
			// function.sent implementation.
			this.sent = this._sent = undefined;
			this.done = false;
			this.delegate = null;

			this.method = "next";
			this.arg = undefined;

			this.tryEntries.forEach(resetTryEntry);

			if (!skipTempReset) {
				for (var name in this) {
					// Not sure about the optimal order of these conditions:
					if (name.charAt(0) === "t" &&
						hasOwn.call(this, name) &&
						!isNaN(+name.slice(1))) {
						this[name] = undefined;
					}
				}
			}
		},

		stop: function() {
			this.done = true;

			var rootEntry = this.tryEntries[0];
			var rootRecord = rootEntry.completion;
			if (rootRecord.type === "throw") {
				throw rootRecord.arg;
			}

			return this.rval;
		},

		dispatchException: function(exception) {
			if (this.done) {
				throw exception;
			}

			var context = this;
			function handle(loc, caught) {
				record.type = "throw";
				record.arg = exception;
				context.next = loc;

				if (caught) {
					// If the dispatched exception was caught by a catch block,
					// then let that catch block handle the exception normally.
					context.method = "next";
					context.arg = undefined;
				}

				return !! caught;
			}

			for (var i = this.tryEntries.length - 1; i >= 0; --i) {
				var entry = this.tryEntries[i];
				var record = entry.completion;

				if (entry.tryLoc === "root") {
					// Exception thrown outside of any try block that could handle
					// it, so set the completion value of the entire function to
					// throw the exception.
					return handle("end");
				}

				if (entry.tryLoc <= this.prev) {
					var hasCatch = hasOwn.call(entry, "catchLoc");
					var hasFinally = hasOwn.call(entry, "finallyLoc");

					if (hasCatch && hasFinally) {
						if (this.prev < entry.catchLoc) {
							return handle(entry.catchLoc, true);
						} else if (this.prev < entry.finallyLoc) {
							return handle(entry.finallyLoc);
						}

					} else if (hasCatch) {
						if (this.prev < entry.catchLoc) {
							return handle(entry.catchLoc, true);
						}

					} else if (hasFinally) {
						if (this.prev < entry.finallyLoc) {
							return handle(entry.finallyLoc);
						}

					} else {
						throw new Error("try statement without catch or finally");
					}
				}
			}
		},

		abrupt: function(type, arg) {
			for (var i = this.tryEntries.length - 1; i >= 0; --i) {
				var entry = this.tryEntries[i];
				if (entry.tryLoc <= this.prev &&
					hasOwn.call(entry, "finallyLoc") &&
					this.prev < entry.finallyLoc) {
					var finallyEntry = entry;
					break;
				}
			}

			if (finallyEntry &&
				(type === "break" ||
					type === "continue") &&
				finallyEntry.tryLoc <= arg &&
				arg <= finallyEntry.finallyLoc) {
				// Ignore the finally entry if control is not jumping to a
				// location outside the try/catch block.
				finallyEntry = null;
			}

			var record = finallyEntry ? finallyEntry.completion : {};
			record.type = type;
			record.arg = arg;

			if (finallyEntry) {
				this.method = "next";
				this.next = finallyEntry.finallyLoc;
				return ContinueSentinel;
			}

			return this.complete(record);
		},

		complete: function(record, afterLoc) {
			if (record.type === "throw") {
				throw record.arg;
			}

			if (record.type === "break" ||
				record.type === "continue") {
				this.next = record.arg;
			} else if (record.type === "return") {
				this.rval = this.arg = record.arg;
				this.method = "return";
				this.next = "end";
			} else if (record.type === "normal" && afterLoc) {
				this.next = afterLoc;
			}

			return ContinueSentinel;
		},

		finish: function(finallyLoc) {
			for (var i = this.tryEntries.length - 1; i >= 0; --i) {
				var entry = this.tryEntries[i];
				if (entry.finallyLoc === finallyLoc) {
					this.complete(entry.completion, entry.afterLoc);
					resetTryEntry(entry);
					return ContinueSentinel;
				}
			}
		},

		"catch": function(tryLoc) {
			for (var i = this.tryEntries.length - 1; i >= 0; --i) {
				var entry = this.tryEntries[i];
				if (entry.tryLoc === tryLoc) {
					var record = entry.completion;
					if (record.type === "throw") {
						var thrown = record.arg;
						resetTryEntry(entry);
					}
					return thrown;
				}
			}

			// The context.catch method must only be called with a location
			// argument that corresponds to a known catch block.
			throw new Error("illegal catch attempt");
		},

		delegateYield: function(iterable, resultName, nextLoc) {
			this.delegate = {
				iterator: values(iterable),
				resultName: resultName,
				nextLoc: nextLoc
			};

			if (this.method === "next") {
				// Deliberately forget the last sent value so that we don't
				// accidentally pass it on to the delegate.
				this.arg = undefined;
			}

			return ContinueSentinel;
		}
	};
})(
	// In sloppy mode, unbound `this` refers to the global object, fallback to
	// Function constructor if we're in global strict mode. That is sadly a form
	// of indirect eval which violates Content Security Policy.
	(function() { return this })() || Function("return this")()
);

(function (exports) {
	'use strict';

	var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};
	function createCommonjsModule(fn, module) {
	  return module = {
	    exports: {}
	  }, fn(module, module.exports), module.exports;
	}

	var check = function (it) {
	  return it && it.Math == Math && it;
	}; // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028


	var global_1 = // eslint-disable-next-line es/no-global-this -- safe
	check(typeof globalThis == 'object' && globalThis) || check(typeof window == 'object' && window) || // eslint-disable-next-line no-restricted-globals -- safe
	check(typeof self == 'object' && self) || check(typeof commonjsGlobal == 'object' && commonjsGlobal) || // eslint-disable-next-line no-new-func -- fallback
	function () {
	  return this;
	}() || Function('return this')();

	var fails = function (exec) {
	  try {
	    return !!exec();
	  } catch (error) {
	    return true;
	  }
	};

	// Detect IE8's incomplete defineProperty implementation


	var descriptors = !fails(function () {
	  // eslint-disable-next-line es/no-object-defineproperty -- required for testing
	  return Object.defineProperty({}, 1, {
	    get: function () {
	      return 7;
	    }
	  })[1] != 7;
	});

	var call = Function.prototype.call;
	var functionCall = call.bind ? call.bind(call) : function () {
	  return call.apply(call, arguments);
	};

	var $propertyIsEnumerable = {}.propertyIsEnumerable; // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe

	var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor; // Nashorn ~ JDK8 bug

	var NASHORN_BUG = getOwnPropertyDescriptor && !$propertyIsEnumerable.call({
	  1: 2
	}, 1); // `Object.prototype.propertyIsEnumerable` method implementation
	// https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable

	var f = NASHORN_BUG ? function propertyIsEnumerable(V) {
	  var descriptor = getOwnPropertyDescriptor(this, V);
	  return !!descriptor && descriptor.enumerable;
	} : $propertyIsEnumerable;

	var objectPropertyIsEnumerable = {
		f: f
	};

	var createPropertyDescriptor = function (bitmap, value) {
	  return {
	    enumerable: !(bitmap & 1),
	    configurable: !(bitmap & 2),
	    writable: !(bitmap & 4),
	    value: value
	  };
	};

	var FunctionPrototype = Function.prototype;
	var bind = FunctionPrototype.bind;
	var call$1 = FunctionPrototype.call;
	var callBind = bind && bind.bind(call$1);
	var functionUncurryThis = bind ? function (fn) {
	  return fn && callBind(call$1, fn);
	} : function (fn) {
	  return fn && function () {
	    return call$1.apply(fn, arguments);
	  };
	};

	var toString = functionUncurryThis({}.toString);
	var stringSlice = functionUncurryThis(''.slice);

	var classofRaw = function (it) {
	  return stringSlice(toString(it), 8, -1);
	};

	var Object$1 = global_1.Object;
	var split = functionUncurryThis(''.split); // fallback for non-array-like ES3 and non-enumerable old V8 strings

	var indexedObject = fails(function () {
	  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
	  // eslint-disable-next-line no-prototype-builtins -- safe
	  return !Object$1('z').propertyIsEnumerable(0);
	}) ? function (it) {
	  return classofRaw(it) == 'String' ? split(it, '') : Object$1(it);
	} : Object$1;

	var TypeError$1 = global_1.TypeError; // `RequireObjectCoercible` abstract operation
	// https://tc39.es/ecma262/#sec-requireobjectcoercible

	var requireObjectCoercible = function (it) {
	  if (it == undefined) throw TypeError$1("Can't call method on " + it);
	  return it;
	};

	// toObject with fallback for non-array-like ES3 strings




	var toIndexedObject = function (it) {
	  return indexedObject(requireObjectCoercible(it));
	};

	// `IsCallable` abstract operation
	// https://tc39.es/ecma262/#sec-iscallable
	var isCallable = function (argument) {
	  return typeof argument == 'function';
	};

	var isObject = function (it) {
	  return typeof it == 'object' ? it !== null : isCallable(it);
	};

	var aFunction = function (argument) {
	  return isCallable(argument) ? argument : undefined;
	};

	var getBuiltIn = function (namespace, method) {
	  return arguments.length < 2 ? aFunction(global_1[namespace]) : global_1[namespace] && global_1[namespace][method];
	};

	var objectIsPrototypeOf = functionUncurryThis({}.isPrototypeOf);

	var engineUserAgent = getBuiltIn('navigator', 'userAgent') || '';

	var process = global_1.process;
	var Deno = global_1.Deno;
	var versions = process && process.versions || Deno && Deno.version;
	var v8 = versions && versions.v8;
	var match, version;

	if (v8) {
	  match = v8.split('.'); // in old Chrome, versions of V8 isn't V8 = Chrome / 10
	  // but their correct versions are not interesting for us

	  version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);
	} // BrowserFS NodeJS `process` polyfill incorrectly set `.v8` to `0.0`
	// so check `userAgent` even if `.v8` exists, but 0


	if (!version && engineUserAgent) {
	  match = engineUserAgent.match(/Edge\/(\d+)/);

	  if (!match || match[1] >= 74) {
	    match = engineUserAgent.match(/Chrome\/(\d+)/);
	    if (match) version = +match[1];
	  }
	}

	var engineV8Version = version;

	/* eslint-disable es/no-symbol -- required for testing */


	 // eslint-disable-next-line es/no-object-getownpropertysymbols -- required for testing


	var nativeSymbol = !!Object.getOwnPropertySymbols && !fails(function () {
	  var symbol = Symbol(); // Chrome 38 Symbol has incorrect toString conversion
	  // `get-own-property-symbols` polyfill symbols converted to object are not Symbol instances

	  return !String(symbol) || !(Object(symbol) instanceof Symbol) || // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
	  !Symbol.sham && engineV8Version && engineV8Version < 41;
	});

	/* eslint-disable es/no-symbol -- required for testing */


	var useSymbolAsUid = nativeSymbol && !Symbol.sham && typeof Symbol.iterator == 'symbol';

	var Object$2 = global_1.Object;
	var isSymbol = useSymbolAsUid ? function (it) {
	  return typeof it == 'symbol';
	} : function (it) {
	  var $Symbol = getBuiltIn('Symbol');
	  return isCallable($Symbol) && objectIsPrototypeOf($Symbol.prototype, Object$2(it));
	};

	var String$1 = global_1.String;

	var tryToString = function (argument) {
	  try {
	    return String$1(argument);
	  } catch (error) {
	    return 'Object';
	  }
	};

	var TypeError$2 = global_1.TypeError; // `Assert: IsCallable(argument) is true`

	var aCallable = function (argument) {
	  if (isCallable(argument)) return argument;
	  throw TypeError$2(tryToString(argument) + ' is not a function');
	};

	// `GetMethod` abstract operation
	// https://tc39.es/ecma262/#sec-getmethod


	var getMethod = function (V, P) {
	  var func = V[P];
	  return func == null ? undefined : aCallable(func);
	};

	var TypeError$3 = global_1.TypeError; // `OrdinaryToPrimitive` abstract operation
	// https://tc39.es/ecma262/#sec-ordinarytoprimitive

	var ordinaryToPrimitive = function (input, pref) {
	  var fn, val;
	  if (pref === 'string' && isCallable(fn = input.toString) && !isObject(val = functionCall(fn, input))) return val;
	  if (isCallable(fn = input.valueOf) && !isObject(val = functionCall(fn, input))) return val;
	  if (pref !== 'string' && isCallable(fn = input.toString) && !isObject(val = functionCall(fn, input))) return val;
	  throw TypeError$3("Can't convert object to primitive value");
	};

	var isPure = false;

	// eslint-disable-next-line es/no-object-defineproperty -- safe


	var defineProperty = Object.defineProperty;

	var setGlobal = function (key, value) {
	  try {
	    defineProperty(global_1, key, {
	      value: value,
	      configurable: true,
	      writable: true
	    });
	  } catch (error) {
	    global_1[key] = value;
	  }

	  return value;
	};

	var SHARED = '__core-js_shared__';
	var store = global_1[SHARED] || setGlobal(SHARED, {});
	var sharedStore = store;

	var shared = createCommonjsModule(function (module) {
	(module.exports = function (key, value) {
	  return sharedStore[key] || (sharedStore[key] = value !== undefined ? value : {});
	})('versions', []).push({
	  version: '3.19.2',
	  mode: 'global',
	  copyright: '(c) 2021 Denis Pushkarev (zloirock.ru)'
	});
	});

	var Object$3 = global_1.Object; // `ToObject` abstract operation
	// https://tc39.es/ecma262/#sec-toobject

	var toObject = function (argument) {
	  return Object$3(requireObjectCoercible(argument));
	};

	var hasOwnProperty = functionUncurryThis({}.hasOwnProperty); // `HasOwnProperty` abstract operation
	// https://tc39.es/ecma262/#sec-hasownproperty

	var hasOwnProperty_1 = Object.hasOwn || function hasOwn(it, key) {
	  return hasOwnProperty(toObject(it), key);
	};

	var id = 0;
	var postfix = Math.random();
	var toString$1 = functionUncurryThis(1.0.toString);

	var uid = function (key) {
	  return 'Symbol(' + (key === undefined ? '' : key) + ')_' + toString$1(++id + postfix, 36);
	};

	var WellKnownSymbolsStore = shared('wks');
	var Symbol$1 = global_1.Symbol;
	var symbolFor = Symbol$1 && Symbol$1['for'];
	var createWellKnownSymbol = useSymbolAsUid ? Symbol$1 : Symbol$1 && Symbol$1.withoutSetter || uid;

	var wellKnownSymbol = function (name) {
	  if (!hasOwnProperty_1(WellKnownSymbolsStore, name) || !(nativeSymbol || typeof WellKnownSymbolsStore[name] == 'string')) {
	    var description = 'Symbol.' + name;

	    if (nativeSymbol && hasOwnProperty_1(Symbol$1, name)) {
	      WellKnownSymbolsStore[name] = Symbol$1[name];
	    } else if (useSymbolAsUid && symbolFor) {
	      WellKnownSymbolsStore[name] = symbolFor(description);
	    } else {
	      WellKnownSymbolsStore[name] = createWellKnownSymbol(description);
	    }
	  }

	  return WellKnownSymbolsStore[name];
	};

	var TypeError$4 = global_1.TypeError;
	var TO_PRIMITIVE = wellKnownSymbol('toPrimitive'); // `ToPrimitive` abstract operation
	// https://tc39.es/ecma262/#sec-toprimitive

	var toPrimitive = function (input, pref) {
	  if (!isObject(input) || isSymbol(input)) return input;
	  var exoticToPrim = getMethod(input, TO_PRIMITIVE);
	  var result;

	  if (exoticToPrim) {
	    if (pref === undefined) pref = 'default';
	    result = functionCall(exoticToPrim, input, pref);
	    if (!isObject(result) || isSymbol(result)) return result;
	    throw TypeError$4("Can't convert object to primitive value");
	  }

	  if (pref === undefined) pref = 'number';
	  return ordinaryToPrimitive(input, pref);
	};

	// `ToPropertyKey` abstract operation
	// https://tc39.es/ecma262/#sec-topropertykey


	var toPropertyKey = function (argument) {
	  var key = toPrimitive(argument, 'string');
	  return isSymbol(key) ? key : key + '';
	};

	var document$1 = global_1.document; // typeof document.createElement is 'object' in old IE

	var EXISTS = isObject(document$1) && isObject(document$1.createElement);

	var documentCreateElement = function (it) {
	  return EXISTS ? document$1.createElement(it) : {};
	};

	// Thank's IE8 for his funny defineProperty


	var ie8DomDefine = !descriptors && !fails(function () {
	  // eslint-disable-next-line es/no-object-defineproperty -- requied for testing
	  return Object.defineProperty(documentCreateElement('div'), 'a', {
	    get: function () {
	      return 7;
	    }
	  }).a != 7;
	});

	// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe


	var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor; // `Object.getOwnPropertyDescriptor` method
	// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor

	var f$1 = descriptors ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
	  O = toIndexedObject(O);
	  P = toPropertyKey(P);
	  if (ie8DomDefine) try {
	    return $getOwnPropertyDescriptor(O, P);
	  } catch (error) {
	    /* empty */
	  }
	  if (hasOwnProperty_1(O, P)) return createPropertyDescriptor(!functionCall(objectPropertyIsEnumerable.f, O, P), O[P]);
	};

	var objectGetOwnPropertyDescriptor = {
		f: f$1
	};

	var String$2 = global_1.String;
	var TypeError$5 = global_1.TypeError; // `Assert: Type(argument) is Object`

	var anObject = function (argument) {
	  if (isObject(argument)) return argument;
	  throw TypeError$5(String$2(argument) + ' is not an object');
	};

	var TypeError$6 = global_1.TypeError; // eslint-disable-next-line es/no-object-defineproperty -- safe

	var $defineProperty = Object.defineProperty; // `Object.defineProperty` method
	// https://tc39.es/ecma262/#sec-object.defineproperty

	var f$2 = descriptors ? $defineProperty : function defineProperty(O, P, Attributes) {
	  anObject(O);
	  P = toPropertyKey(P);
	  anObject(Attributes);
	  if (ie8DomDefine) try {
	    return $defineProperty(O, P, Attributes);
	  } catch (error) {
	    /* empty */
	  }
	  if ('get' in Attributes || 'set' in Attributes) throw TypeError$6('Accessors not supported');
	  if ('value' in Attributes) O[P] = Attributes.value;
	  return O;
	};

	var objectDefineProperty = {
		f: f$2
	};

	var createNonEnumerableProperty = descriptors ? function (object, key, value) {
	  return objectDefineProperty.f(object, key, createPropertyDescriptor(1, value));
	} : function (object, key, value) {
	  object[key] = value;
	  return object;
	};

	var functionToString = functionUncurryThis(Function.toString); // this helper broken in `core-js@3.4.1-3.4.4`, so we can't use `shared` helper

	if (!isCallable(sharedStore.inspectSource)) {
	  sharedStore.inspectSource = function (it) {
	    return functionToString(it);
	  };
	}

	var inspectSource = sharedStore.inspectSource;

	var WeakMap = global_1.WeakMap;
	var nativeWeakMap = isCallable(WeakMap) && /native code/.test(inspectSource(WeakMap));

	var keys = shared('keys');

	var sharedKey = function (key) {
	  return keys[key] || (keys[key] = uid(key));
	};

	var hiddenKeys = {};

	var OBJECT_ALREADY_INITIALIZED = 'Object already initialized';
	var TypeError$7 = global_1.TypeError;
	var WeakMap$1 = global_1.WeakMap;
	var set, get, has;

	var enforce = function (it) {
	  return has(it) ? get(it) : set(it, {});
	};

	var getterFor = function (TYPE) {
	  return function (it) {
	    var state;

	    if (!isObject(it) || (state = get(it)).type !== TYPE) {
	      throw TypeError$7('Incompatible receiver, ' + TYPE + ' required');
	    }

	    return state;
	  };
	};

	if (nativeWeakMap || sharedStore.state) {
	  var store$1 = sharedStore.state || (sharedStore.state = new WeakMap$1());
	  var wmget = functionUncurryThis(store$1.get);
	  var wmhas = functionUncurryThis(store$1.has);
	  var wmset = functionUncurryThis(store$1.set);

	  set = function (it, metadata) {
	    if (wmhas(store$1, it)) throw new TypeError$7(OBJECT_ALREADY_INITIALIZED);
	    metadata.facade = it;
	    wmset(store$1, it, metadata);
	    return metadata;
	  };

	  get = function (it) {
	    return wmget(store$1, it) || {};
	  };

	  has = function (it) {
	    return wmhas(store$1, it);
	  };
	} else {
	  var STATE = sharedKey('state');
	  hiddenKeys[STATE] = true;

	  set = function (it, metadata) {
	    if (hasOwnProperty_1(it, STATE)) throw new TypeError$7(OBJECT_ALREADY_INITIALIZED);
	    metadata.facade = it;
	    createNonEnumerableProperty(it, STATE, metadata);
	    return metadata;
	  };

	  get = function (it) {
	    return hasOwnProperty_1(it, STATE) ? it[STATE] : {};
	  };

	  has = function (it) {
	    return hasOwnProperty_1(it, STATE);
	  };
	}

	var internalState = {
	  set: set,
	  get: get,
	  has: has,
	  enforce: enforce,
	  getterFor: getterFor
	};

	var FunctionPrototype$1 = Function.prototype; // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe

	var getDescriptor = descriptors && Object.getOwnPropertyDescriptor;
	var EXISTS$1 = hasOwnProperty_1(FunctionPrototype$1, 'name'); // additional protection from minified / mangled / dropped function names

	var PROPER = EXISTS$1 && function something() {
	  /* empty */
	}.name === 'something';

	var CONFIGURABLE = EXISTS$1 && (!descriptors || descriptors && getDescriptor(FunctionPrototype$1, 'name').configurable);
	var functionName = {
	  EXISTS: EXISTS$1,
	  PROPER: PROPER,
	  CONFIGURABLE: CONFIGURABLE
	};

	var redefine = createCommonjsModule(function (module) {
	var CONFIGURABLE_FUNCTION_NAME = functionName.CONFIGURABLE;

	var getInternalState = internalState.get;
	var enforceInternalState = internalState.enforce;
	var TEMPLATE = String(String).split('String');
	(module.exports = function (O, key, value, options) {
	  var unsafe = options ? !!options.unsafe : false;
	  var simple = options ? !!options.enumerable : false;
	  var noTargetGet = options ? !!options.noTargetGet : false;
	  var name = options && options.name !== undefined ? options.name : key;
	  var state;

	  if (isCallable(value)) {
	    if (String(name).slice(0, 7) === 'Symbol(') {
	      name = '[' + String(name).replace(/^Symbol\(([^)]*)\)/, '$1') + ']';
	    }

	    if (!hasOwnProperty_1(value, 'name') || CONFIGURABLE_FUNCTION_NAME && value.name !== name) {
	      createNonEnumerableProperty(value, 'name', name);
	    }

	    state = enforceInternalState(value);

	    if (!state.source) {
	      state.source = TEMPLATE.join(typeof name == 'string' ? name : '');
	    }
	  }

	  if (O === global_1) {
	    if (simple) O[key] = value;else setGlobal(key, value);
	    return;
	  } else if (!unsafe) {
	    delete O[key];
	  } else if (!noTargetGet && O[key]) {
	    simple = true;
	  }

	  if (simple) O[key] = value;else createNonEnumerableProperty(O, key, value); // add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
	})(Function.prototype, 'toString', function toString() {
	  return isCallable(this) && getInternalState(this).source || inspectSource(this);
	});
	});

	var ceil = Math.ceil;
	var floor = Math.floor; // `ToIntegerOrInfinity` abstract operation
	// https://tc39.es/ecma262/#sec-tointegerorinfinity

	var toIntegerOrInfinity = function (argument) {
	  var number = +argument; // eslint-disable-next-line no-self-compare -- safe

	  return number !== number || number === 0 ? 0 : (number > 0 ? floor : ceil)(number);
	};

	var max = Math.max;
	var min = Math.min; // Helper for a popular repeating case of the spec:
	// Let integer be ? ToInteger(index).
	// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).

	var toAbsoluteIndex = function (index, length) {
	  var integer = toIntegerOrInfinity(index);
	  return integer < 0 ? max(integer + length, 0) : min(integer, length);
	};

	var min$1 = Math.min; // `ToLength` abstract operation
	// https://tc39.es/ecma262/#sec-tolength

	var toLength = function (argument) {
	  return argument > 0 ? min$1(toIntegerOrInfinity(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991
	};

	// `LengthOfArrayLike` abstract operation
	// https://tc39.es/ecma262/#sec-lengthofarraylike


	var lengthOfArrayLike = function (obj) {
	  return toLength(obj.length);
	};

	// `Array.prototype.{ indexOf, includes }` methods implementation


	var createMethod = function (IS_INCLUDES) {
	  return function ($this, el, fromIndex) {
	    var O = toIndexedObject($this);
	    var length = lengthOfArrayLike(O);
	    var index = toAbsoluteIndex(fromIndex, length);
	    var value; // Array#includes uses SameValueZero equality algorithm
	    // eslint-disable-next-line no-self-compare -- NaN check

	    if (IS_INCLUDES && el != el) while (length > index) {
	      value = O[index++]; // eslint-disable-next-line no-self-compare -- NaN check

	      if (value != value) return true; // Array#indexOf ignores holes, Array#includes - not
	    } else for (; length > index; index++) {
	      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
	    }
	    return !IS_INCLUDES && -1;
	  };
	};

	var arrayIncludes = {
	  // `Array.prototype.includes` method
	  // https://tc39.es/ecma262/#sec-array.prototype.includes
	  includes: createMethod(true),
	  // `Array.prototype.indexOf` method
	  // https://tc39.es/ecma262/#sec-array.prototype.indexof
	  indexOf: createMethod(false)
	};

	var indexOf = arrayIncludes.indexOf;



	var push = functionUncurryThis([].push);

	var objectKeysInternal = function (object, names) {
	  var O = toIndexedObject(object);
	  var i = 0;
	  var result = [];
	  var key;

	  for (key in O) !hasOwnProperty_1(hiddenKeys, key) && hasOwnProperty_1(O, key) && push(result, key); // Don't enum bug & hidden keys


	  while (names.length > i) if (hasOwnProperty_1(O, key = names[i++])) {
	    ~indexOf(result, key) || push(result, key);
	  }

	  return result;
	};

	// IE8- don't enum bug keys
	var enumBugKeys = ['constructor', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'toLocaleString', 'toString', 'valueOf'];

	var hiddenKeys$1 = enumBugKeys.concat('length', 'prototype'); // `Object.getOwnPropertyNames` method
	// https://tc39.es/ecma262/#sec-object.getownpropertynames
	// eslint-disable-next-line es/no-object-getownpropertynames -- safe

	var f$3 = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
	  return objectKeysInternal(O, hiddenKeys$1);
	};

	var objectGetOwnPropertyNames = {
		f: f$3
	};

	// eslint-disable-next-line es/no-object-getownpropertysymbols -- safe
	var f$4 = Object.getOwnPropertySymbols;

	var objectGetOwnPropertySymbols = {
		f: f$4
	};

	var concat = functionUncurryThis([].concat); // all object keys, includes non-enumerable and symbols

	var ownKeys = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {
	  var keys = objectGetOwnPropertyNames.f(anObject(it));
	  var getOwnPropertySymbols = objectGetOwnPropertySymbols.f;
	  return getOwnPropertySymbols ? concat(keys, getOwnPropertySymbols(it)) : keys;
	};

	var copyConstructorProperties = function (target, source) {
	  var keys = ownKeys(source);
	  var defineProperty = objectDefineProperty.f;
	  var getOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;

	  for (var i = 0; i < keys.length; i++) {
	    var key = keys[i];
	    if (!hasOwnProperty_1(target, key)) defineProperty(target, key, getOwnPropertyDescriptor(source, key));
	  }
	};

	var replacement = /#|\.prototype\./;

	var isForced = function (feature, detection) {
	  var value = data[normalize(feature)];
	  return value == POLYFILL ? true : value == NATIVE ? false : isCallable(detection) ? fails(detection) : !!detection;
	};

	var normalize = isForced.normalize = function (string) {
	  return String(string).replace(replacement, '.').toLowerCase();
	};

	var data = isForced.data = {};
	var NATIVE = isForced.NATIVE = 'N';
	var POLYFILL = isForced.POLYFILL = 'P';
	var isForced_1 = isForced;

	var getOwnPropertyDescriptor$1 = objectGetOwnPropertyDescriptor.f;










	/*
	  options.target      - name of the target object
	  options.global      - target is the global object
	  options.stat        - export as static methods of target
	  options.proto       - export as prototype methods of target
	  options.real        - real prototype method for the `pure` version
	  options.forced      - export even if the native feature is available
	  options.bind        - bind methods to the target, required for the `pure` version
	  options.wrap        - wrap constructors to preventing global pollution, required for the `pure` version
	  options.unsafe      - use the simple assignment of property instead of delete + defineProperty
	  options.sham        - add a flag to not completely full polyfills
	  options.enumerable  - export as enumerable property
	  options.noTargetGet - prevent calling a getter on target
	  options.name        - the .name of the function if it does not match the key
	*/


	var _export = function (options, source) {
	  var TARGET = options.target;
	  var GLOBAL = options.global;
	  var STATIC = options.stat;
	  var FORCED, target, key, targetProperty, sourceProperty, descriptor;

	  if (GLOBAL) {
	    target = global_1;
	  } else if (STATIC) {
	    target = global_1[TARGET] || setGlobal(TARGET, {});
	  } else {
	    target = (global_1[TARGET] || {}).prototype;
	  }

	  if (target) for (key in source) {
	    sourceProperty = source[key];

	    if (options.noTargetGet) {
	      descriptor = getOwnPropertyDescriptor$1(target, key);
	      targetProperty = descriptor && descriptor.value;
	    } else targetProperty = target[key];

	    FORCED = isForced_1(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced); // contained in target

	    if (!FORCED && targetProperty !== undefined) {
	      if (typeof sourceProperty == typeof targetProperty) continue;
	      copyConstructorProperties(sourceProperty, targetProperty);
	    } // add a flag to not completely full polyfills


	    if (options.sham || targetProperty && targetProperty.sham) {
	      createNonEnumerableProperty(sourceProperty, 'sham', true);
	    } // extend global


	    redefine(target, key, sourceProperty, options);
	  }
	};

	var correctPrototypeGetter = !fails(function () {
	  function F() {
	    /* empty */
	  }

	  F.prototype.constructor = null; // eslint-disable-next-line es/no-object-getprototypeof -- required for testing

	  return Object.getPrototypeOf(new F()) !== F.prototype;
	});

	var IE_PROTO = sharedKey('IE_PROTO');
	var Object$4 = global_1.Object;
	var ObjectPrototype = Object$4.prototype; // `Object.getPrototypeOf` method
	// https://tc39.es/ecma262/#sec-object.getprototypeof

	var objectGetPrototypeOf = correctPrototypeGetter ? Object$4.getPrototypeOf : function (O) {
	  var object = toObject(O);
	  if (hasOwnProperty_1(object, IE_PROTO)) return object[IE_PROTO];
	  var constructor = object.constructor;

	  if (isCallable(constructor) && object instanceof constructor) {
	    return constructor.prototype;
	  }

	  return object instanceof Object$4 ? ObjectPrototype : null;
	};

	var String$3 = global_1.String;
	var TypeError$8 = global_1.TypeError;

	var aPossiblePrototype = function (argument) {
	  if (typeof argument == 'object' || isCallable(argument)) return argument;
	  throw TypeError$8("Can't set " + String$3(argument) + ' as a prototype');
	};

	/* eslint-disable no-proto -- safe */




	 // `Object.setPrototypeOf` method
	// https://tc39.es/ecma262/#sec-object.setprototypeof
	// Works with __proto__ only. Old v8 can't work with null proto objects.
	// eslint-disable-next-line es/no-object-setprototypeof -- safe


	var objectSetPrototypeOf = Object.setPrototypeOf || ('__proto__' in {} ? function () {
	  var CORRECT_SETTER = false;
	  var test = {};
	  var setter;

	  try {
	    // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
	    setter = functionUncurryThis(Object.getOwnPropertyDescriptor(Object.prototype, '__proto__').set);
	    setter(test, []);
	    CORRECT_SETTER = test instanceof Array;
	  } catch (error) {
	    /* empty */
	  }

	  return function setPrototypeOf(O, proto) {
	    anObject(O);
	    aPossiblePrototype(proto);
	    if (CORRECT_SETTER) setter(O, proto);else O.__proto__ = proto;
	    return O;
	  };
	}() : undefined);

	// `Object.keys` method
	// https://tc39.es/ecma262/#sec-object.keys
	// eslint-disable-next-line es/no-object-keys -- safe


	var objectKeys = Object.keys || function keys(O) {
	  return objectKeysInternal(O, enumBugKeys);
	};

	// `Object.defineProperties` method
	// https://tc39.es/ecma262/#sec-object.defineproperties
	// eslint-disable-next-line es/no-object-defineproperties -- safe


	var objectDefineProperties = descriptors ? Object.defineProperties : function defineProperties(O, Properties) {
	  anObject(O);
	  var props = toIndexedObject(Properties);
	  var keys = objectKeys(Properties);
	  var length = keys.length;
	  var index = 0;
	  var key;

	  while (length > index) objectDefineProperty.f(O, key = keys[index++], props[key]);

	  return O;
	};

	var html = getBuiltIn('document', 'documentElement');

	/* global ActiveXObject -- old IE, WSH */














	var GT = '>';
	var LT = '<';
	var PROTOTYPE = 'prototype';
	var SCRIPT = 'script';
	var IE_PROTO$1 = sharedKey('IE_PROTO');

	var EmptyConstructor = function () {
	  /* empty */
	};

	var scriptTag = function (content) {
	  return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;
	}; // Create object with fake `null` prototype: use ActiveX Object with cleared prototype


	var NullProtoObjectViaActiveX = function (activeXDocument) {
	  activeXDocument.write(scriptTag(''));
	  activeXDocument.close();
	  var temp = activeXDocument.parentWindow.Object;
	  activeXDocument = null; // avoid memory leak

	  return temp;
	}; // Create object with fake `null` prototype: use iframe Object with cleared prototype


	var NullProtoObjectViaIFrame = function () {
	  // Thrash, waste and sodomy: IE GC bug
	  var iframe = documentCreateElement('iframe');
	  var JS = 'java' + SCRIPT + ':';
	  var iframeDocument;
	  iframe.style.display = 'none';
	  html.appendChild(iframe); // https://github.com/zloirock/core-js/issues/475

	  iframe.src = String(JS);
	  iframeDocument = iframe.contentWindow.document;
	  iframeDocument.open();
	  iframeDocument.write(scriptTag('document.F=Object'));
	  iframeDocument.close();
	  return iframeDocument.F;
	}; // Check for document.domain and active x support
	// No need to use active x approach when document.domain is not set
	// see https://github.com/es-shims/es5-shim/issues/150
	// variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346
	// avoid IE GC bug


	var activeXDocument;

	var NullProtoObject = function () {
	  try {
	    activeXDocument = new ActiveXObject('htmlfile');
	  } catch (error) {
	    /* ignore */
	  }

	  NullProtoObject = typeof document != 'undefined' ? document.domain && activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) // old IE
	  : NullProtoObjectViaIFrame() : NullProtoObjectViaActiveX(activeXDocument); // WSH

	  var length = enumBugKeys.length;

	  while (length--) delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];

	  return NullProtoObject();
	};

	hiddenKeys[IE_PROTO$1] = true; // `Object.create` method
	// https://tc39.es/ecma262/#sec-object.create

	var objectCreate = Object.create || function create(O, Properties) {
	  var result;

	  if (O !== null) {
	    EmptyConstructor[PROTOTYPE] = anObject(O);
	    result = new EmptyConstructor();
	    EmptyConstructor[PROTOTYPE] = null; // add "__proto__" for Object.getPrototypeOf polyfill

	    result[IE_PROTO$1] = O;
	  } else result = NullProtoObject();

	  return Properties === undefined ? result : objectDefineProperties(result, Properties);
	};

	var createProperty = function (object, key, value) {
	  var propertyKey = toPropertyKey(key);
	  if (propertyKey in object) objectDefineProperty.f(object, propertyKey, createPropertyDescriptor(0, value));else object[propertyKey] = value;
	};

	var Array$1 = global_1.Array;
	var max$1 = Math.max;

	var arraySliceSimple = function (O, start, end) {
	  var length = lengthOfArrayLike(O);
	  var k = toAbsoluteIndex(start, length);
	  var fin = toAbsoluteIndex(end === undefined ? length : end, length);
	  var result = Array$1(max$1(fin - k, 0));

	  for (var n = 0; k < fin; k++, n++) createProperty(result, n, O[k]);

	  result.length = n;
	  return result;
	};

	var replace = functionUncurryThis(''.replace);
	var split$1 = functionUncurryThis(''.split);
	var join = functionUncurryThis([].join);

	var TEST = function (arg) {
	  return String(Error(arg).stack);
	}('zxcasd');

	var V8_OR_CHAKRA_STACK_ENTRY = /\n\s*at [^:]*:[^\n]*/;
	var IS_V8_OR_CHAKRA_STACK = V8_OR_CHAKRA_STACK_ENTRY.test(TEST);
	var IS_FIREFOX_OR_SAFARI_STACK = /@[^\n]*\n/.test(TEST) && !/zxcasd/.test(TEST);

	var clearErrorStack = function (stack, dropEntries) {
	  if (typeof stack != 'string') return stack;

	  if (IS_V8_OR_CHAKRA_STACK) {
	    while (dropEntries--) stack = replace(stack, V8_OR_CHAKRA_STACK_ENTRY, '');
	  } else if (IS_FIREFOX_OR_SAFARI_STACK) {
	    return join(arraySliceSimple(split$1(stack, '\n'), dropEntries), '\n');
	  }

	  return stack;
	};

	// `InstallErrorCause` abstract operation
	// https://tc39.es/proposal-error-cause/#sec-errorobjects-install-error-cause


	var installErrorCause = function (O, options) {
	  if (isObject(options) && 'cause' in options) {
	    createNonEnumerableProperty(O, 'cause', options.cause);
	  }
	};

	var bind$1 = functionUncurryThis(functionUncurryThis.bind); // optional / simple context binding

	var functionBindContext = function (fn, that) {
	  aCallable(fn);
	  return that === undefined ? fn : bind$1 ? bind$1(fn, that) : function ()
	  /* ...args */
	  {
	    return fn.apply(that, arguments);
	  };
	};

	var iterators = {};

	var ITERATOR = wellKnownSymbol('iterator');
	var ArrayPrototype = Array.prototype; // check on default Array iterator

	var isArrayIteratorMethod = function (it) {
	  return it !== undefined && (iterators.Array === it || ArrayPrototype[ITERATOR] === it);
	};

	var TO_STRING_TAG = wellKnownSymbol('toStringTag');
	var test = {};
	test[TO_STRING_TAG] = 'z';
	var toStringTagSupport = String(test) === '[object z]';

	var TO_STRING_TAG$1 = wellKnownSymbol('toStringTag');
	var Object$5 = global_1.Object; // ES3 wrong here

	var CORRECT_ARGUMENTS = classofRaw(function () {
	  return arguments;
	}()) == 'Arguments'; // fallback for IE11 Script Access Denied error

	var tryGet = function (it, key) {
	  try {
	    return it[key];
	  } catch (error) {
	    /* empty */
	  }
	}; // getting tag from ES6+ `Object.prototype.toString`


	var classof = toStringTagSupport ? classofRaw : function (it) {
	  var O, tag, result;
	  return it === undefined ? 'Undefined' : it === null ? 'Null' // @@toStringTag case
	  : typeof (tag = tryGet(O = Object$5(it), TO_STRING_TAG$1)) == 'string' ? tag // builtinTag case
	  : CORRECT_ARGUMENTS ? classofRaw(O) // ES3 arguments fallback
	  : (result = classofRaw(O)) == 'Object' && isCallable(O.callee) ? 'Arguments' : result;
	};

	var ITERATOR$1 = wellKnownSymbol('iterator');

	var getIteratorMethod = function (it) {
	  if (it != undefined) return getMethod(it, ITERATOR$1) || getMethod(it, '@@iterator') || iterators[classof(it)];
	};

	var TypeError$9 = global_1.TypeError;

	var getIterator = function (argument, usingIterator) {
	  var iteratorMethod = arguments.length < 2 ? getIteratorMethod(argument) : usingIterator;
	  if (aCallable(iteratorMethod)) return anObject(functionCall(iteratorMethod, argument));
	  throw TypeError$9(tryToString(argument) + ' is not iterable');
	};

	var iteratorClose = function (iterator, kind, value) {
	  var innerResult, innerError;
	  anObject(iterator);

	  try {
	    innerResult = getMethod(iterator, 'return');

	    if (!innerResult) {
	      if (kind === 'throw') throw value;
	      return value;
	    }

	    innerResult = functionCall(innerResult, iterator);
	  } catch (error) {
	    innerError = true;
	    innerResult = error;
	  }

	  if (kind === 'throw') throw value;
	  if (innerError) throw innerResult;
	  anObject(innerResult);
	  return value;
	};

	var TypeError$a = global_1.TypeError;

	var Result = function (stopped, result) {
	  this.stopped = stopped;
	  this.result = result;
	};

	var ResultPrototype = Result.prototype;

	var iterate = function (iterable, unboundFunction, options) {
	  var that = options && options.that;
	  var AS_ENTRIES = !!(options && options.AS_ENTRIES);
	  var IS_ITERATOR = !!(options && options.IS_ITERATOR);
	  var INTERRUPTED = !!(options && options.INTERRUPTED);
	  var fn = functionBindContext(unboundFunction, that);
	  var iterator, iterFn, index, length, result, next, step;

	  var stop = function (condition) {
	    if (iterator) iteratorClose(iterator, 'normal', condition);
	    return new Result(true, condition);
	  };

	  var callFn = function (value) {
	    if (AS_ENTRIES) {
	      anObject(value);
	      return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);
	    }

	    return INTERRUPTED ? fn(value, stop) : fn(value);
	  };

	  if (IS_ITERATOR) {
	    iterator = iterable;
	  } else {
	    iterFn = getIteratorMethod(iterable);
	    if (!iterFn) throw TypeError$a(tryToString(iterable) + ' is not iterable'); // optimisation for array iterators

	    if (isArrayIteratorMethod(iterFn)) {
	      for (index = 0, length = lengthOfArrayLike(iterable); length > index; index++) {
	        result = callFn(iterable[index]);
	        if (result && objectIsPrototypeOf(ResultPrototype, result)) return result;
	      }

	      return new Result(false);
	    }

	    iterator = getIterator(iterable, iterFn);
	  }

	  next = iterator.next;

	  while (!(step = functionCall(next, iterator)).done) {
	    try {
	      result = callFn(step.value);
	    } catch (error) {
	      iteratorClose(iterator, 'throw', error);
	    }

	    if (typeof result == 'object' && result && objectIsPrototypeOf(ResultPrototype, result)) return result;
	  }

	  return new Result(false);
	};

	var String$4 = global_1.String;

	var toString_1 = function (argument) {
	  if (classof(argument) === 'Symbol') throw TypeError('Cannot convert a Symbol value to a string');
	  return String$4(argument);
	};

	var normalizeStringArgument = function (argument, $default) {
	  return argument === undefined ? arguments.length < 2 ? '' : $default : toString_1(argument);
	};

	var errorStackInstallable = !fails(function () {
	  var error = Error('a');
	  if (!('stack' in error)) return true; // eslint-disable-next-line es/no-object-defineproperty -- safe

	  Object.defineProperty(error, 'stack', createPropertyDescriptor(1, 7));
	  return error.stack !== 7;
	});

	var TO_STRING_TAG$2 = wellKnownSymbol('toStringTag');
	var Error$1 = global_1.Error;
	var push$1 = [].push;

	var $AggregateError = function AggregateError(errors, message
	/* , options */
	) {
	  var options = arguments.length > 2 ? arguments[2] : undefined;
	  var isInstance = objectIsPrototypeOf(AggregateErrorPrototype, this);
	  var that;

	  if (objectSetPrototypeOf) {
	    that = objectSetPrototypeOf(new Error$1(undefined), isInstance ? objectGetPrototypeOf(this) : AggregateErrorPrototype);
	  } else {
	    that = isInstance ? this : objectCreate(AggregateErrorPrototype);
	    createNonEnumerableProperty(that, TO_STRING_TAG$2, 'Error');
	  }

	  createNonEnumerableProperty(that, 'message', normalizeStringArgument(message, ''));
	  if (errorStackInstallable) createNonEnumerableProperty(that, 'stack', clearErrorStack(that.stack, 1));
	  installErrorCause(that, options);
	  var errorsArray = [];
	  iterate(errors, push$1, {
	    that: errorsArray
	  });
	  createNonEnumerableProperty(that, 'errors', errorsArray);
	  return that;
	};

	if (objectSetPrototypeOf) objectSetPrototypeOf($AggregateError, Error$1);else copyConstructorProperties($AggregateError, Error$1);
	var AggregateErrorPrototype = $AggregateError.prototype = objectCreate(Error$1.prototype, {
	  constructor: createPropertyDescriptor(1, $AggregateError),
	  message: createPropertyDescriptor(1, ''),
	  name: createPropertyDescriptor(1, 'AggregateError')
	}); // `AggregateError` constructor
	// https://tc39.es/ecma262/#sec-aggregate-error-constructor

	_export({
	  global: true
	}, {
	  AggregateError: $AggregateError
	});

	var UNSCOPABLES = wellKnownSymbol('unscopables');
	var ArrayPrototype$1 = Array.prototype; // Array.prototype[@@unscopables]
	// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables

	if (ArrayPrototype$1[UNSCOPABLES] == undefined) {
	  objectDefineProperty.f(ArrayPrototype$1, UNSCOPABLES, {
	    configurable: true,
	    value: objectCreate(null)
	  });
	} // add a key to Array.prototype[@@unscopables]


	var addToUnscopables = function (key) {
	  ArrayPrototype$1[UNSCOPABLES][key] = true;
	};

	// `Array.prototype.at` method
	// https://github.com/tc39/proposal-relative-indexing-method


	_export({
	  target: 'Array',
	  proto: true
	}, {
	  at: function at(index) {
	    var O = toObject(this);
	    var len = lengthOfArrayLike(O);
	    var relativeIndex = toIntegerOrInfinity(index);
	    var k = relativeIndex >= 0 ? relativeIndex : len + relativeIndex;
	    return k < 0 || k >= len ? undefined : O[k];
	  }
	});
	addToUnscopables('at');

	// `IsArray` abstract operation
	// https://tc39.es/ecma262/#sec-isarray
	// eslint-disable-next-line es/no-array-isarray -- safe


	var isArray = Array.isArray || function isArray(argument) {
	  return classofRaw(argument) == 'Array';
	};

	var un$Reverse = functionUncurryThis([].reverse);
	var test$1 = [1, 2]; // `Array.prototype.reverse` method
	// https://tc39.es/ecma262/#sec-array.prototype.reverse
	// fix for Safari 12.0 bug
	// https://bugs.webkit.org/show_bug.cgi?id=188794

	_export({
	  target: 'Array',
	  proto: true,
	  forced: String(test$1) === String(test$1.reverse())
	}, {
	  reverse: function reverse() {
	    // eslint-disable-next-line no-self-assign -- dirty hack
	    if (isArray(this)) this.length = this.length;
	    return un$Reverse(this);
	  }
	});

	// eslint-disable-next-line es/no-typed-arrays -- safe
	var arrayBufferNative = typeof ArrayBuffer != 'undefined' && typeof DataView != 'undefined';

	var redefineAll = function (target, src, options) {
	  for (var key in src) redefine(target, key, src[key], options);

	  return target;
	};

	var TypeError$b = global_1.TypeError;

	var anInstance = function (it, Prototype) {
	  if (objectIsPrototypeOf(Prototype, it)) return it;
	  throw TypeError$b('Incorrect invocation');
	};

	var RangeError = global_1.RangeError; // `ToIndex` abstract operation
	// https://tc39.es/ecma262/#sec-toindex

	var toIndex = function (it) {
	  if (it === undefined) return 0;
	  var number = toIntegerOrInfinity(it);
	  var length = toLength(number);
	  if (number !== length) throw RangeError('Wrong length or index');
	  return length;
	};

	// IEEE754 conversions based on https://github.com/feross/ieee754


	var Array$2 = global_1.Array;
	var abs = Math.abs;
	var pow = Math.pow;
	var floor$1 = Math.floor;
	var log = Math.log;
	var LN2 = Math.LN2;

	var pack = function (number, mantissaLength, bytes) {
	  var buffer = Array$2(bytes);
	  var exponentLength = bytes * 8 - mantissaLength - 1;
	  var eMax = (1 << exponentLength) - 1;
	  var eBias = eMax >> 1;
	  var rt = mantissaLength === 23 ? pow(2, -24) - pow(2, -77) : 0;
	  var sign = number < 0 || number === 0 && 1 / number < 0 ? 1 : 0;
	  var index = 0;
	  var exponent, mantissa, c;
	  number = abs(number); // eslint-disable-next-line no-self-compare -- NaN check

	  if (number != number || number === Infinity) {
	    // eslint-disable-next-line no-self-compare -- NaN check
	    mantissa = number != number ? 1 : 0;
	    exponent = eMax;
	  } else {
	    exponent = floor$1(log(number) / LN2);
	    c = pow(2, -exponent);

	    if (number * c < 1) {
	      exponent--;
	      c *= 2;
	    }

	    if (exponent + eBias >= 1) {
	      number += rt / c;
	    } else {
	      number += rt * pow(2, 1 - eBias);
	    }

	    if (number * c >= 2) {
	      exponent++;
	      c /= 2;
	    }

	    if (exponent + eBias >= eMax) {
	      mantissa = 0;
	      exponent = eMax;
	    } else if (exponent + eBias >= 1) {
	      mantissa = (number * c - 1) * pow(2, mantissaLength);
	      exponent = exponent + eBias;
	    } else {
	      mantissa = number * pow(2, eBias - 1) * pow(2, mantissaLength);
	      exponent = 0;
	    }
	  }

	  while (mantissaLength >= 8) {
	    buffer[index++] = mantissa & 255;
	    mantissa /= 256;
	    mantissaLength -= 8;
	  }

	  exponent = exponent << mantissaLength | mantissa;
	  exponentLength += mantissaLength;

	  while (exponentLength > 0) {
	    buffer[index++] = exponent & 255;
	    exponent /= 256;
	    exponentLength -= 8;
	  }

	  buffer[--index] |= sign * 128;
	  return buffer;
	};

	var unpack = function (buffer, mantissaLength) {
	  var bytes = buffer.length;
	  var exponentLength = bytes * 8 - mantissaLength - 1;
	  var eMax = (1 << exponentLength) - 1;
	  var eBias = eMax >> 1;
	  var nBits = exponentLength - 7;
	  var index = bytes - 1;
	  var sign = buffer[index--];
	  var exponent = sign & 127;
	  var mantissa;
	  sign >>= 7;

	  while (nBits > 0) {
	    exponent = exponent * 256 + buffer[index--];
	    nBits -= 8;
	  }

	  mantissa = exponent & (1 << -nBits) - 1;
	  exponent >>= -nBits;
	  nBits += mantissaLength;

	  while (nBits > 0) {
	    mantissa = mantissa * 256 + buffer[index--];
	    nBits -= 8;
	  }

	  if (exponent === 0) {
	    exponent = 1 - eBias;
	  } else if (exponent === eMax) {
	    return mantissa ? NaN : sign ? -Infinity : Infinity;
	  } else {
	    mantissa = mantissa + pow(2, mantissaLength);
	    exponent = exponent - eBias;
	  }

	  return (sign ? -1 : 1) * mantissa * pow(2, exponent - mantissaLength);
	};

	var ieee754 = {
	  pack: pack,
	  unpack: unpack
	};

	// `Array.prototype.fill` method implementation
	// https://tc39.es/ecma262/#sec-array.prototype.fill


	var arrayFill = function fill(value
	/* , start = 0, end = @length */
	) {
	  var O = toObject(this);
	  var length = lengthOfArrayLike(O);
	  var argumentsLength = arguments.length;
	  var index = toAbsoluteIndex(argumentsLength > 1 ? arguments[1] : undefined, length);
	  var end = argumentsLength > 2 ? arguments[2] : undefined;
	  var endPos = end === undefined ? length : toAbsoluteIndex(end, length);

	  while (endPos > index) O[index++] = value;

	  return O;
	};

	var defineProperty$1 = objectDefineProperty.f;





	var TO_STRING_TAG$3 = wellKnownSymbol('toStringTag');

	var setToStringTag = function (it, TAG, STATIC) {
	  if (it && !hasOwnProperty_1(it = STATIC ? it : it.prototype, TO_STRING_TAG$3)) {
	    defineProperty$1(it, TO_STRING_TAG$3, {
	      configurable: true,
	      value: TAG
	    });
	  }
	};

	var getOwnPropertyNames = objectGetOwnPropertyNames.f;

	var defineProperty$2 = objectDefineProperty.f;









	var PROPER_FUNCTION_NAME = functionName.PROPER;
	var CONFIGURABLE_FUNCTION_NAME = functionName.CONFIGURABLE;
	var getInternalState = internalState.get;
	var setInternalState = internalState.set;
	var ARRAY_BUFFER = 'ArrayBuffer';
	var DATA_VIEW = 'DataView';
	var PROTOTYPE$1 = 'prototype';
	var WRONG_LENGTH = 'Wrong length';
	var WRONG_INDEX = 'Wrong index';
	var NativeArrayBuffer = global_1[ARRAY_BUFFER];
	var $ArrayBuffer = NativeArrayBuffer;
	var ArrayBufferPrototype = $ArrayBuffer && $ArrayBuffer[PROTOTYPE$1];
	var $DataView = global_1[DATA_VIEW];
	var DataViewPrototype = $DataView && $DataView[PROTOTYPE$1];
	var ObjectPrototype$1 = Object.prototype;
	var Array$3 = global_1.Array;
	var RangeError$1 = global_1.RangeError;
	var fill = functionUncurryThis(arrayFill);
	var reverse = functionUncurryThis([].reverse);
	var packIEEE754 = ieee754.pack;
	var unpackIEEE754 = ieee754.unpack;

	var packInt8 = function (number) {
	  return [number & 0xFF];
	};

	var packInt16 = function (number) {
	  return [number & 0xFF, number >> 8 & 0xFF];
	};

	var packInt32 = function (number) {
	  return [number & 0xFF, number >> 8 & 0xFF, number >> 16 & 0xFF, number >> 24 & 0xFF];
	};

	var unpackInt32 = function (buffer) {
	  return buffer[3] << 24 | buffer[2] << 16 | buffer[1] << 8 | buffer[0];
	};

	var packFloat32 = function (number) {
	  return packIEEE754(number, 23, 4);
	};

	var packFloat64 = function (number) {
	  return packIEEE754(number, 52, 8);
	};

	var addGetter = function (Constructor, key) {
	  defineProperty$2(Constructor[PROTOTYPE$1], key, {
	    get: function () {
	      return getInternalState(this)[key];
	    }
	  });
	};

	var get$1 = function (view, count, index, isLittleEndian) {
	  var intIndex = toIndex(index);
	  var store = getInternalState(view);
	  if (intIndex + count > store.byteLength) throw RangeError$1(WRONG_INDEX);
	  var bytes = getInternalState(store.buffer).bytes;
	  var start = intIndex + store.byteOffset;
	  var pack = arraySliceSimple(bytes, start, start + count);
	  return isLittleEndian ? pack : reverse(pack);
	};

	var set$1 = function (view, count, index, conversion, value, isLittleEndian) {
	  var intIndex = toIndex(index);
	  var store = getInternalState(view);
	  if (intIndex + count > store.byteLength) throw RangeError$1(WRONG_INDEX);
	  var bytes = getInternalState(store.buffer).bytes;
	  var start = intIndex + store.byteOffset;
	  var pack = conversion(+value);

	  for (var i = 0; i < count; i++) bytes[start + i] = pack[isLittleEndian ? i : count - i - 1];
	};

	if (!arrayBufferNative) {
	  $ArrayBuffer = function ArrayBuffer(length) {
	    anInstance(this, ArrayBufferPrototype);
	    var byteLength = toIndex(length);
	    setInternalState(this, {
	      bytes: fill(Array$3(byteLength), 0),
	      byteLength: byteLength
	    });
	    if (!descriptors) this.byteLength = byteLength;
	  };

	  ArrayBufferPrototype = $ArrayBuffer[PROTOTYPE$1];

	  $DataView = function DataView(buffer, byteOffset, byteLength) {
	    anInstance(this, DataViewPrototype);
	    anInstance(buffer, ArrayBufferPrototype);
	    var bufferLength = getInternalState(buffer).byteLength;
	    var offset = toIntegerOrInfinity(byteOffset);
	    if (offset < 0 || offset > bufferLength) throw RangeError$1('Wrong offset');
	    byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength);
	    if (offset + byteLength > bufferLength) throw RangeError$1(WRONG_LENGTH);
	    setInternalState(this, {
	      buffer: buffer,
	      byteLength: byteLength,
	      byteOffset: offset
	    });

	    if (!descriptors) {
	      this.buffer = buffer;
	      this.byteLength = byteLength;
	      this.byteOffset = offset;
	    }
	  };

	  DataViewPrototype = $DataView[PROTOTYPE$1];

	  if (descriptors) {
	    addGetter($ArrayBuffer, 'byteLength');
	    addGetter($DataView, 'buffer');
	    addGetter($DataView, 'byteLength');
	    addGetter($DataView, 'byteOffset');
	  }

	  redefineAll(DataViewPrototype, {
	    getInt8: function getInt8(byteOffset) {
	      return get$1(this, 1, byteOffset)[0] << 24 >> 24;
	    },
	    getUint8: function getUint8(byteOffset) {
	      return get$1(this, 1, byteOffset)[0];
	    },
	    getInt16: function getInt16(byteOffset
	    /* , littleEndian */
	    ) {
	      var bytes = get$1(this, 2, byteOffset, arguments.length > 1 ? arguments[1] : undefined);
	      return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
	    },
	    getUint16: function getUint16(byteOffset
	    /* , littleEndian */
	    ) {
	      var bytes = get$1(this, 2, byteOffset, arguments.length > 1 ? arguments[1] : undefined);
	      return bytes[1] << 8 | bytes[0];
	    },
	    getInt32: function getInt32(byteOffset
	    /* , littleEndian */
	    ) {
	      return unpackInt32(get$1(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : undefined));
	    },
	    getUint32: function getUint32(byteOffset
	    /* , littleEndian */
	    ) {
	      return unpackInt32(get$1(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : undefined)) >>> 0;
	    },
	    getFloat32: function getFloat32(byteOffset
	    /* , littleEndian */
	    ) {
	      return unpackIEEE754(get$1(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : undefined), 23);
	    },
	    getFloat64: function getFloat64(byteOffset
	    /* , littleEndian */
	    ) {
	      return unpackIEEE754(get$1(this, 8, byteOffset, arguments.length > 1 ? arguments[1] : undefined), 52);
	    },
	    setInt8: function setInt8(byteOffset, value) {
	      set$1(this, 1, byteOffset, packInt8, value);
	    },
	    setUint8: function setUint8(byteOffset, value) {
	      set$1(this, 1, byteOffset, packInt8, value);
	    },
	    setInt16: function setInt16(byteOffset, value
	    /* , littleEndian */
	    ) {
	      set$1(this, 2, byteOffset, packInt16, value, arguments.length > 2 ? arguments[2] : undefined);
	    },
	    setUint16: function setUint16(byteOffset, value
	    /* , littleEndian */
	    ) {
	      set$1(this, 2, byteOffset, packInt16, value, arguments.length > 2 ? arguments[2] : undefined);
	    },
	    setInt32: function setInt32(byteOffset, value
	    /* , littleEndian */
	    ) {
	      set$1(this, 4, byteOffset, packInt32, value, arguments.length > 2 ? arguments[2] : undefined);
	    },
	    setUint32: function setUint32(byteOffset, value
	    /* , littleEndian */
	    ) {
	      set$1(this, 4, byteOffset, packInt32, value, arguments.length > 2 ? arguments[2] : undefined);
	    },
	    setFloat32: function setFloat32(byteOffset, value
	    /* , littleEndian */
	    ) {
	      set$1(this, 4, byteOffset, packFloat32, value, arguments.length > 2 ? arguments[2] : undefined);
	    },
	    setFloat64: function setFloat64(byteOffset, value
	    /* , littleEndian */
	    ) {
	      set$1(this, 8, byteOffset, packFloat64, value, arguments.length > 2 ? arguments[2] : undefined);
	    }
	  });
	} else {
	  var INCORRECT_ARRAY_BUFFER_NAME = PROPER_FUNCTION_NAME && NativeArrayBuffer.name !== ARRAY_BUFFER;
	  /* eslint-disable no-new -- required for testing */

	  if (!fails(function () {
	    NativeArrayBuffer(1);
	  }) || !fails(function () {
	    new NativeArrayBuffer(-1);
	  }) || fails(function () {
	    new NativeArrayBuffer();
	    new NativeArrayBuffer(1.5);
	    new NativeArrayBuffer(NaN);
	    return INCORRECT_ARRAY_BUFFER_NAME && !CONFIGURABLE_FUNCTION_NAME;
	  })) {
	    /* eslint-enable no-new -- required for testing */
	    $ArrayBuffer = function ArrayBuffer(length) {
	      anInstance(this, ArrayBufferPrototype);
	      return new NativeArrayBuffer(toIndex(length));
	    };

	    $ArrayBuffer[PROTOTYPE$1] = ArrayBufferPrototype;

	    for (var keys$1 = getOwnPropertyNames(NativeArrayBuffer), j = 0, key; keys$1.length > j;) {
	      if (!((key = keys$1[j++]) in $ArrayBuffer)) {
	        createNonEnumerableProperty($ArrayBuffer, key, NativeArrayBuffer[key]);
	      }
	    }

	    ArrayBufferPrototype.constructor = $ArrayBuffer;
	  } else if (INCORRECT_ARRAY_BUFFER_NAME && CONFIGURABLE_FUNCTION_NAME) {
	    createNonEnumerableProperty(NativeArrayBuffer, 'name', ARRAY_BUFFER);
	  } // WebKit bug - the same parent prototype for typed arrays and data view


	  if (objectSetPrototypeOf && objectGetPrototypeOf(DataViewPrototype) !== ObjectPrototype$1) {
	    objectSetPrototypeOf(DataViewPrototype, ObjectPrototype$1);
	  } // iOS Safari 7.x bug


	  var testView = new $DataView(new $ArrayBuffer(2));
	  var $setInt8 = functionUncurryThis(DataViewPrototype.setInt8);
	  testView.setInt8(0, 2147483648);
	  testView.setInt8(1, 2147483649);
	  if (testView.getInt8(0) || !testView.getInt8(1)) redefineAll(DataViewPrototype, {
	    setInt8: function setInt8(byteOffset, value) {
	      $setInt8(this, byteOffset, value << 24 >> 24);
	    },
	    setUint8: function setUint8(byteOffset, value) {
	      $setInt8(this, byteOffset, value << 24 >> 24);
	    }
	  }, {
	    unsafe: true
	  });
	}

	setToStringTag($ArrayBuffer, ARRAY_BUFFER);
	setToStringTag($DataView, DATA_VIEW);
	var arrayBuffer = {
	  ArrayBuffer: $ArrayBuffer,
	  DataView: $DataView
	};

	var noop = function () {
	  /* empty */
	};

	var empty = [];
	var construct = getBuiltIn('Reflect', 'construct');
	var constructorRegExp = /^\s*(?:class|function)\b/;
	var exec = functionUncurryThis(constructorRegExp.exec);
	var INCORRECT_TO_STRING = !constructorRegExp.exec(noop);

	var isConstructorModern = function (argument) {
	  if (!isCallable(argument)) return false;

	  try {
	    construct(noop, empty, argument);
	    return true;
	  } catch (error) {
	    return false;
	  }
	};

	var isConstructorLegacy = function (argument) {
	  if (!isCallable(argument)) return false;

	  switch (classof(argument)) {
	    case 'AsyncFunction':
	    case 'GeneratorFunction':
	    case 'AsyncGeneratorFunction':
	      return false;
	    // we can't check .prototype since constructors produced by .bind haven't it
	  }

	  return INCORRECT_TO_STRING || !!exec(constructorRegExp, inspectSource(argument));
	}; // `IsConstructor` abstract operation
	// https://tc39.es/ecma262/#sec-isconstructor


	var isConstructor = !construct || fails(function () {
	  var called;
	  return isConstructorModern(isConstructorModern.call) || !isConstructorModern(Object) || !isConstructorModern(function () {
	    called = true;
	  }) || called;
	}) ? isConstructorLegacy : isConstructorModern;

	var TypeError$c = global_1.TypeError; // `Assert: IsConstructor(argument) is true`

	var aConstructor = function (argument) {
	  if (isConstructor(argument)) return argument;
	  throw TypeError$c(tryToString(argument) + ' is not a constructor');
	};

	var SPECIES = wellKnownSymbol('species'); // `SpeciesConstructor` abstract operation
	// https://tc39.es/ecma262/#sec-speciesconstructor

	var speciesConstructor = function (O, defaultConstructor) {
	  var C = anObject(O).constructor;
	  var S;
	  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? defaultConstructor : aConstructor(S);
	};

	var ArrayBuffer$1 = arrayBuffer.ArrayBuffer;
	var DataView$1 = arrayBuffer.DataView;
	var DataViewPrototype$1 = DataView$1.prototype;
	var un$ArrayBufferSlice = functionUncurryThis(ArrayBuffer$1.prototype.slice);
	var getUint8 = functionUncurryThis(DataViewPrototype$1.getUint8);
	var setUint8 = functionUncurryThis(DataViewPrototype$1.setUint8);
	var INCORRECT_SLICE = fails(function () {
	  return !new ArrayBuffer$1(2).slice(1, undefined).byteLength;
	}); // `ArrayBuffer.prototype.slice` method
	// https://tc39.es/ecma262/#sec-arraybuffer.prototype.slice

	_export({
	  target: 'ArrayBuffer',
	  proto: true,
	  unsafe: true,
	  forced: INCORRECT_SLICE
	}, {
	  slice: function slice(start, end) {
	    if (un$ArrayBufferSlice && end === undefined) {
	      return un$ArrayBufferSlice(anObject(this), start); // FF fix
	    }

	    var length = anObject(this).byteLength;
	    var first = toAbsoluteIndex(start, length);
	    var fin = toAbsoluteIndex(end === undefined ? length : end, length);
	    var result = new (speciesConstructor(this, ArrayBuffer$1))(toLength(fin - first));
	    var viewSource = new DataView$1(this);
	    var viewTarget = new DataView$1(result);
	    var index = 0;

	    while (first < fin) {
	      setUint8(viewTarget, index++, getUint8(viewSource, first++));
	    }

	    return result;
	  }
	});

	// `Object.fromEntries` method
	// https://github.com/tc39/proposal-object-from-entries


	_export({
	  target: 'Object',
	  stat: true
	}, {
	  fromEntries: function fromEntries(iterable) {
	    var obj = {};
	    iterate(iterable, function (k, v) {
	      createProperty(obj, k, v);
	    }, {
	      AS_ENTRIES: true
	    });
	    return obj;
	  }
	});

	// `Object.hasOwn` method
	// https://github.com/tc39/proposal-accessible-object-hasownproperty


	_export({
	  target: 'Object',
	  stat: true
	}, {
	  hasOwn: hasOwnProperty_1
	});

	var PromiseCapability = function (C) {
	  var resolve, reject;
	  this.promise = new C(function ($$resolve, $$reject) {
	    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
	    resolve = $$resolve;
	    reject = $$reject;
	  });
	  this.resolve = aCallable(resolve);
	  this.reject = aCallable(reject);
	}; // `NewPromiseCapability` abstract operation
	// https://tc39.es/ecma262/#sec-newpromisecapability


	var f$5 = function (C) {
	  return new PromiseCapability(C);
	};

	var newPromiseCapability = {
		f: f$5
	};

	var perform = function (exec) {
	  try {
	    return {
	      error: false,
	      value: exec()
	    };
	  } catch (error) {
	    return {
	      error: true,
	      value: error
	    };
	  }
	};

	// `Promise.allSettled` method
	// https://tc39.es/ecma262/#sec-promise.allsettled


	_export({
	  target: 'Promise',
	  stat: true
	}, {
	  allSettled: function allSettled(iterable) {
	    var C = this;
	    var capability = newPromiseCapability.f(C);
	    var resolve = capability.resolve;
	    var reject = capability.reject;
	    var result = perform(function () {
	      var promiseResolve = aCallable(C.resolve);
	      var values = [];
	      var counter = 0;
	      var remaining = 1;
	      iterate(iterable, function (promise) {
	        var index = counter++;
	        var alreadyCalled = false;
	        remaining++;
	        functionCall(promiseResolve, C, promise).then(function (value) {
	          if (alreadyCalled) return;
	          alreadyCalled = true;
	          values[index] = {
	            status: 'fulfilled',
	            value: value
	          };
	          --remaining || resolve(values);
	        }, function (error) {
	          if (alreadyCalled) return;
	          alreadyCalled = true;
	          values[index] = {
	            status: 'rejected',
	            reason: error
	          };
	          --remaining || resolve(values);
	        });
	      });
	      --remaining || resolve(values);
	    });
	    if (result.error) reject(result.value);
	    return capability.promise;
	  }
	});

	var PROMISE_ANY_ERROR = 'No one promise resolved'; // `Promise.any` method
	// https://tc39.es/ecma262/#sec-promise.any

	_export({
	  target: 'Promise',
	  stat: true
	}, {
	  any: function any(iterable) {
	    var C = this;
	    var AggregateError = getBuiltIn('AggregateError');
	    var capability = newPromiseCapability.f(C);
	    var resolve = capability.resolve;
	    var reject = capability.reject;
	    var result = perform(function () {
	      var promiseResolve = aCallable(C.resolve);
	      var errors = [];
	      var counter = 0;
	      var remaining = 1;
	      var alreadyResolved = false;
	      iterate(iterable, function (promise) {
	        var index = counter++;
	        var alreadyRejected = false;
	        remaining++;
	        functionCall(promiseResolve, C, promise).then(function (value) {
	          if (alreadyRejected || alreadyResolved) return;
	          alreadyResolved = true;
	          resolve(value);
	        }, function (error) {
	          if (alreadyRejected || alreadyResolved) return;
	          alreadyRejected = true;
	          errors[index] = error;
	          --remaining || reject(new AggregateError(errors, PROMISE_ANY_ERROR));
	        });
	      });
	      --remaining || reject(new AggregateError(errors, PROMISE_ANY_ERROR));
	    });
	    if (result.error) reject(result.value);
	    return capability.promise;
	  }
	});

	var nativePromiseConstructor = global_1.Promise;

	var promiseResolve = function (C, x) {
	  anObject(C);
	  if (isObject(x) && x.constructor === C) return x;
	  var promiseCapability = newPromiseCapability.f(C);
	  var resolve = promiseCapability.resolve;
	  resolve(x);
	  return promiseCapability.promise;
	};

	// Safari bug https://bugs.webkit.org/show_bug.cgi?id=200829


	var NON_GENERIC = !!nativePromiseConstructor && fails(function () {
	  nativePromiseConstructor.prototype['finally'].call({
	    then: function () {
	      /* empty */
	    }
	  }, function () {
	    /* empty */
	  });
	}); // `Promise.prototype.finally` method
	// https://tc39.es/ecma262/#sec-promise.prototype.finally

	_export({
	  target: 'Promise',
	  proto: true,
	  real: true,
	  forced: NON_GENERIC
	}, {
	  'finally': function (onFinally) {
	    var C = speciesConstructor(this, getBuiltIn('Promise'));
	    var isFunction = isCallable(onFinally);
	    return this.then(isFunction ? function (x) {
	      return promiseResolve(C, onFinally()).then(function () {
	        return x;
	      });
	    } : onFinally, isFunction ? function (e) {
	      return promiseResolve(C, onFinally()).then(function () {
	        throw e;
	      });
	    } : onFinally);
	  }
	}); // makes sure that native promise-based APIs `Promise#finally` properly works with patched `Promise#then`

	if (!isPure && isCallable(nativePromiseConstructor)) {
	  var method = getBuiltIn('Promise').prototype['finally'];

	  if (nativePromiseConstructor.prototype['finally'] !== method) {
	    redefine(nativePromiseConstructor.prototype, 'finally', method, {
	      unsafe: true
	    });
	  }
	}

	var ITERATOR$2 = wellKnownSymbol('iterator');
	var BUGGY_SAFARI_ITERATORS = false; // `%IteratorPrototype%` object
	// https://tc39.es/ecma262/#sec-%iteratorprototype%-object

	var IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;
	/* eslint-disable es/no-array-prototype-keys -- safe */

	if ([].keys) {
	  arrayIterator = [].keys(); // Safari 8 has buggy iterators w/o `next`

	  if (!('next' in arrayIterator)) BUGGY_SAFARI_ITERATORS = true;else {
	    PrototypeOfArrayIteratorPrototype = objectGetPrototypeOf(objectGetPrototypeOf(arrayIterator));
	    if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype = PrototypeOfArrayIteratorPrototype;
	  }
	}

	var NEW_ITERATOR_PROTOTYPE = IteratorPrototype == undefined || fails(function () {
	  var test = {}; // FF44- legacy iterators case

	  return IteratorPrototype[ITERATOR$2].call(test) !== test;
	});
	if (NEW_ITERATOR_PROTOTYPE) IteratorPrototype = {}; // `%IteratorPrototype%[@@iterator]()` method
	// https://tc39.es/ecma262/#sec-%iteratorprototype%-@@iterator

	if (!isCallable(IteratorPrototype[ITERATOR$2])) {
	  redefine(IteratorPrototype, ITERATOR$2, function () {
	    return this;
	  });
	}

	var iteratorsCore = {
	  IteratorPrototype: IteratorPrototype,
	  BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS
	};

	var IteratorPrototype$1 = iteratorsCore.IteratorPrototype;









	var returnThis = function () {
	  return this;
	};

	var createIteratorConstructor = function (IteratorConstructor, NAME, next) {
	  var TO_STRING_TAG = NAME + ' Iterator';
	  IteratorConstructor.prototype = objectCreate(IteratorPrototype$1, {
	    next: createPropertyDescriptor(1, next)
	  });
	  setToStringTag(IteratorConstructor, TO_STRING_TAG, false, true);
	  iterators[TO_STRING_TAG] = returnThis;
	  return IteratorConstructor;
	};

	var MATCH = wellKnownSymbol('match'); // `IsRegExp` abstract operation
	// https://tc39.es/ecma262/#sec-isregexp

	var isRegexp = function (it) {
	  var isRegExp;
	  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : classofRaw(it) == 'RegExp');
	};

	// `RegExp.prototype.flags` getter implementation
	// https://tc39.es/ecma262/#sec-get-regexp.prototype.flags


	var regexpFlags = function () {
	  var that = anObject(this);
	  var result = '';
	  if (that.global) result += 'g';
	  if (that.ignoreCase) result += 'i';
	  if (that.multiline) result += 'm';
	  if (that.dotAll) result += 's';
	  if (that.unicode) result += 'u';
	  if (that.sticky) result += 'y';
	  return result;
	};

	var charAt = functionUncurryThis(''.charAt);
	var charCodeAt = functionUncurryThis(''.charCodeAt);
	var stringSlice$1 = functionUncurryThis(''.slice);

	var createMethod$1 = function (CONVERT_TO_STRING) {
	  return function ($this, pos) {
	    var S = toString_1(requireObjectCoercible($this));
	    var position = toIntegerOrInfinity(pos);
	    var size = S.length;
	    var first, second;
	    if (position < 0 || position >= size) return CONVERT_TO_STRING ? '' : undefined;
	    first = charCodeAt(S, position);
	    return first < 0xD800 || first > 0xDBFF || position + 1 === size || (second = charCodeAt(S, position + 1)) < 0xDC00 || second > 0xDFFF ? CONVERT_TO_STRING ? charAt(S, position) : first : CONVERT_TO_STRING ? stringSlice$1(S, position, position + 2) : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;
	  };
	};

	var stringMultibyte = {
	  // `String.prototype.codePointAt` method
	  // https://tc39.es/ecma262/#sec-string.prototype.codepointat
	  codeAt: createMethod$1(false),
	  // `String.prototype.at` method
	  // https://github.com/mathiasbynens/String.prototype.at
	  charAt: createMethod$1(true)
	};

	var charAt$1 = stringMultibyte.charAt; // `AdvanceStringIndex` abstract operation
	// https://tc39.es/ecma262/#sec-advancestringindex


	var advanceStringIndex = function (S, index, unicode) {
	  return index + (unicode ? charAt$1(S, index).length : 1);
	};

	// babel-minify and Closure Compiler transpiles RegExp('a', 'y') -> /a/y and it causes SyntaxError


	var $RegExp = global_1.RegExp;
	var UNSUPPORTED_Y = fails(function () {
	  var re = $RegExp('a', 'y');
	  re.lastIndex = 2;
	  return re.exec('abcd') != null;
	}); // UC Browser bug
	// https://github.com/zloirock/core-js/issues/1008

	var MISSED_STICKY = UNSUPPORTED_Y || fails(function () {
	  return !$RegExp('a', 'y').sticky;
	});
	var BROKEN_CARET = UNSUPPORTED_Y || fails(function () {
	  // https://bugzilla.mozilla.org/show_bug.cgi?id=773687
	  var re = $RegExp('^r', 'gy');
	  re.lastIndex = 2;
	  return re.exec('str') != null;
	});
	var regexpStickyHelpers = {
	  BROKEN_CARET: BROKEN_CARET,
	  MISSED_STICKY: MISSED_STICKY,
	  UNSUPPORTED_Y: UNSUPPORTED_Y
	};

	// babel-minify and Closure Compiler transpiles RegExp('.', 's') -> /./s and it causes SyntaxError


	var $RegExp$1 = global_1.RegExp;
	var regexpUnsupportedDotAll = fails(function () {
	  var re = $RegExp$1('.', 's');
	  return !(re.dotAll && re.exec('\n') && re.flags === 's');
	});

	// babel-minify and Closure Compiler transpiles RegExp('(?<a>b)', 'g') -> /(?<a>b)/g and it causes SyntaxError


	var $RegExp$2 = global_1.RegExp;
	var regexpUnsupportedNcg = fails(function () {
	  var re = $RegExp$2('(?<a>b)', 'g');
	  return re.exec('b').groups.a !== 'b' || 'b'.replace(re, '$<a>c') !== 'bc';
	});

	/* eslint-disable regexp/no-empty-capturing-group, regexp/no-empty-group, regexp/no-lazy-ends -- testing */

	/* eslint-disable regexp/no-useless-quantifier -- testing */















	var getInternalState$1 = internalState.get;





	var nativeReplace = shared('native-string-replace', String.prototype.replace);
	var nativeExec = RegExp.prototype.exec;
	var patchedExec = nativeExec;
	var charAt$2 = functionUncurryThis(''.charAt);
	var indexOf$1 = functionUncurryThis(''.indexOf);
	var replace$1 = functionUncurryThis(''.replace);
	var stringSlice$2 = functionUncurryThis(''.slice);

	var UPDATES_LAST_INDEX_WRONG = function () {
	  var re1 = /a/;
	  var re2 = /b*/g;
	  functionCall(nativeExec, re1, 'a');
	  functionCall(nativeExec, re2, 'a');
	  return re1.lastIndex !== 0 || re2.lastIndex !== 0;
	}();

	var UNSUPPORTED_Y$1 = regexpStickyHelpers.BROKEN_CARET; // nonparticipating capturing group, copied from es5-shim's String#split patch.

	var NPCG_INCLUDED = /()??/.exec('')[1] !== undefined;
	var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED || UNSUPPORTED_Y$1 || regexpUnsupportedDotAll || regexpUnsupportedNcg;

	if (PATCH) {
	  patchedExec = function exec(string) {
	    var re = this;
	    var state = getInternalState$1(re);
	    var str = toString_1(string);
	    var raw = state.raw;
	    var result, reCopy, lastIndex, match, i, object, group;

	    if (raw) {
	      raw.lastIndex = re.lastIndex;
	      result = functionCall(patchedExec, raw, str);
	      re.lastIndex = raw.lastIndex;
	      return result;
	    }

	    var groups = state.groups;
	    var sticky = UNSUPPORTED_Y$1 && re.sticky;
	    var flags = functionCall(regexpFlags, re);
	    var source = re.source;
	    var charsAdded = 0;
	    var strCopy = str;

	    if (sticky) {
	      flags = replace$1(flags, 'y', '');

	      if (indexOf$1(flags, 'g') === -1) {
	        flags += 'g';
	      }

	      strCopy = stringSlice$2(str, re.lastIndex); // Support anchored sticky behavior.

	      if (re.lastIndex > 0 && (!re.multiline || re.multiline && charAt$2(str, re.lastIndex - 1) !== '\n')) {
	        source = '(?: ' + source + ')';
	        strCopy = ' ' + strCopy;
	        charsAdded++;
	      } // ^(? + rx + ) is needed, in combination with some str slicing, to
	      // simulate the 'y' flag.


	      reCopy = new RegExp('^(?:' + source + ')', flags);
	    }

	    if (NPCG_INCLUDED) {
	      reCopy = new RegExp('^' + source + '$(?!\\s)', flags);
	    }

	    if (UPDATES_LAST_INDEX_WRONG) lastIndex = re.lastIndex;
	    match = functionCall(nativeExec, sticky ? reCopy : re, strCopy);

	    if (sticky) {
	      if (match) {
	        match.input = stringSlice$2(match.input, charsAdded);
	        match[0] = stringSlice$2(match[0], charsAdded);
	        match.index = re.lastIndex;
	        re.lastIndex += match[0].length;
	      } else re.lastIndex = 0;
	    } else if (UPDATES_LAST_INDEX_WRONG && match) {
	      re.lastIndex = re.global ? match.index + match[0].length : lastIndex;
	    }

	    if (NPCG_INCLUDED && match && match.length > 1) {
	      // Fix browsers whose `exec` methods don't consistently return `undefined`
	      // for NPCG, like IE8. NOTE: This doesn' work for /(.?)?/
	      functionCall(nativeReplace, match[0], reCopy, function () {
	        for (i = 1; i < arguments.length - 2; i++) {
	          if (arguments[i] === undefined) match[i] = undefined;
	        }
	      });
	    }

	    if (match && groups) {
	      match.groups = object = objectCreate(null);

	      for (i = 0; i < groups.length; i++) {
	        group = groups[i];
	        object[group[0]] = match[group[1]];
	      }
	    }

	    return match;
	  };
	}

	var regexpExec = patchedExec;

	var TypeError$d = global_1.TypeError; // `RegExpExec` abstract operation
	// https://tc39.es/ecma262/#sec-regexpexec

	var regexpExecAbstract = function (R, S) {
	  var exec = R.exec;

	  if (isCallable(exec)) {
	    var result = functionCall(exec, R, S);
	    if (result !== null) anObject(result);
	    return result;
	  }

	  if (classofRaw(R) === 'RegExp') return functionCall(regexpExec, R, S);
	  throw TypeError$d('RegExp#exec called on incompatible receiver');
	};

	/* eslint-disable es/no-string-prototype-matchall -- safe */













































	var MATCH_ALL = wellKnownSymbol('matchAll');
	var REGEXP_STRING = 'RegExp String';
	var REGEXP_STRING_ITERATOR = REGEXP_STRING + ' Iterator';
	var setInternalState$1 = internalState.set;
	var getInternalState$2 = internalState.getterFor(REGEXP_STRING_ITERATOR);
	var RegExpPrototype = RegExp.prototype;
	var TypeError$e = global_1.TypeError;
	var getFlags = functionUncurryThis(regexpFlags);
	var stringIndexOf = functionUncurryThis(''.indexOf);
	var un$MatchAll = functionUncurryThis(''.matchAll);
	var WORKS_WITH_NON_GLOBAL_REGEX = !!un$MatchAll && !fails(function () {
	  un$MatchAll('a', /./);
	});
	var $RegExpStringIterator = createIteratorConstructor(function RegExpStringIterator(regexp, string, $global, fullUnicode) {
	  setInternalState$1(this, {
	    type: REGEXP_STRING_ITERATOR,
	    regexp: regexp,
	    string: string,
	    global: $global,
	    unicode: fullUnicode,
	    done: false
	  });
	}, REGEXP_STRING, function next() {
	  var state = getInternalState$2(this);
	  if (state.done) return {
	    value: undefined,
	    done: true
	  };
	  var R = state.regexp;
	  var S = state.string;
	  var match = regexpExecAbstract(R, S);
	  if (match === null) return {
	    value: undefined,
	    done: state.done = true
	  };

	  if (state.global) {
	    if (toString_1(match[0]) === '') R.lastIndex = advanceStringIndex(S, toLength(R.lastIndex), state.unicode);
	    return {
	      value: match,
	      done: false
	    };
	  }

	  state.done = true;
	  return {
	    value: match,
	    done: false
	  };
	});

	var $matchAll = function (string) {
	  var R = anObject(this);
	  var S = toString_1(string);
	  var C, flagsValue, flags, matcher, $global, fullUnicode;
	  C = speciesConstructor(R, RegExp);
	  flagsValue = R.flags;

	  if (flagsValue === undefined && objectIsPrototypeOf(RegExpPrototype, R) && !('flags' in RegExpPrototype)) {
	    flagsValue = getFlags(R);
	  }

	  flags = flagsValue === undefined ? '' : toString_1(flagsValue);
	  matcher = new C(C === RegExp ? R.source : R, flags);
	  $global = !!~stringIndexOf(flags, 'g');
	  fullUnicode = !!~stringIndexOf(flags, 'u');
	  matcher.lastIndex = toLength(R.lastIndex);
	  return new $RegExpStringIterator(matcher, S, $global, fullUnicode);
	}; // `String.prototype.matchAll` method
	// https://tc39.es/ecma262/#sec-string.prototype.matchall


	_export({
	  target: 'String',
	  proto: true,
	  forced: WORKS_WITH_NON_GLOBAL_REGEX
	}, {
	  matchAll: function matchAll(regexp) {
	    var O = requireObjectCoercible(this);
	    var flags, S, matcher, rx;

	    if (regexp != null) {
	      if (isRegexp(regexp)) {
	        flags = toString_1(requireObjectCoercible('flags' in RegExpPrototype ? regexp.flags : getFlags(regexp)));
	        if (!~stringIndexOf(flags, 'g')) throw TypeError$e('`.matchAll` does not allow non-global regexes');
	      }

	      if (WORKS_WITH_NON_GLOBAL_REGEX) return un$MatchAll(O, regexp);
	      matcher = getMethod(regexp, MATCH_ALL);
	      if (matcher === undefined && isPure && classofRaw(regexp) == 'RegExp') matcher = $matchAll;
	      if (matcher) return functionCall(matcher, regexp, O);
	    } else if (WORKS_WITH_NON_GLOBAL_REGEX) return un$MatchAll(O, regexp);

	    S = toString_1(O);
	    rx = new RegExp(regexp, 'g');
	    return isPure ? functionCall($matchAll, rx, S) : rx[MATCH_ALL](S);
	  }
	});
	isPure || MATCH_ALL in RegExpPrototype || redefine(RegExpPrototype, MATCH_ALL, $matchAll);

	var floor$2 = Math.floor;
	var charAt$3 = functionUncurryThis(''.charAt);
	var replace$2 = functionUncurryThis(''.replace);
	var stringSlice$3 = functionUncurryThis(''.slice);
	var SUBSTITUTION_SYMBOLS = /\$([$&'`]|\d{1,2}|<[^>]*>)/g;
	var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&'`]|\d{1,2})/g; // `GetSubstitution` abstract operation
	// https://tc39.es/ecma262/#sec-getsubstitution

	var getSubstitution = function (matched, str, position, captures, namedCaptures, replacement) {
	  var tailPos = position + matched.length;
	  var m = captures.length;
	  var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;

	  if (namedCaptures !== undefined) {
	    namedCaptures = toObject(namedCaptures);
	    symbols = SUBSTITUTION_SYMBOLS;
	  }

	  return replace$2(replacement, symbols, function (match, ch) {
	    var capture;

	    switch (charAt$3(ch, 0)) {
	      case '$':
	        return '$';

	      case '&':
	        return matched;

	      case '`':
	        return stringSlice$3(str, 0, position);

	      case "'":
	        return stringSlice$3(str, tailPos);

	      case '<':
	        capture = namedCaptures[stringSlice$3(ch, 1, -1)];
	        break;

	      default:
	        // \d\d?
	        var n = +ch;
	        if (n === 0) return match;

	        if (n > m) {
	          var f = floor$2(n / 10);
	          if (f === 0) return match;
	          if (f <= m) return captures[f - 1] === undefined ? charAt$3(ch, 1) : captures[f - 1] + charAt$3(ch, 1);
	          return match;
	        }

	        capture = captures[n - 1];
	    }

	    return capture === undefined ? '' : capture;
	  });
	};

	var REPLACE = wellKnownSymbol('replace');
	var RegExpPrototype$1 = RegExp.prototype;
	var TypeError$f = global_1.TypeError;
	var getFlags$1 = functionUncurryThis(regexpFlags);
	var indexOf$2 = functionUncurryThis(''.indexOf);
	var replace$3 = functionUncurryThis(''.replace);
	var stringSlice$4 = functionUncurryThis(''.slice);
	var max$2 = Math.max;

	var stringIndexOf$1 = function (string, searchValue, fromIndex) {
	  if (fromIndex > string.length) return -1;
	  if (searchValue === '') return fromIndex;
	  return indexOf$2(string, searchValue, fromIndex);
	}; // `String.prototype.replaceAll` method
	// https://tc39.es/ecma262/#sec-string.prototype.replaceall


	_export({
	  target: 'String',
	  proto: true
	}, {
	  replaceAll: function replaceAll(searchValue, replaceValue) {
	    var O = requireObjectCoercible(this);
	    var IS_REG_EXP, flags, replacer, string, searchString, functionalReplace, searchLength, advanceBy, replacement;
	    var position = 0;
	    var endOfLastMatch = 0;
	    var result = '';

	    if (searchValue != null) {
	      IS_REG_EXP = isRegexp(searchValue);

	      if (IS_REG_EXP) {
	        flags = toString_1(requireObjectCoercible('flags' in RegExpPrototype$1 ? searchValue.flags : getFlags$1(searchValue)));
	        if (!~indexOf$2(flags, 'g')) throw TypeError$f('`.replaceAll` does not allow non-global regexes');
	      }

	      replacer = getMethod(searchValue, REPLACE);

	      if (replacer) {
	        return functionCall(replacer, searchValue, O, replaceValue);
	      } else if (isPure && IS_REG_EXP) {
	        return replace$3(toString_1(O), searchValue, replaceValue);
	      }
	    }

	    string = toString_1(O);
	    searchString = toString_1(searchValue);
	    functionalReplace = isCallable(replaceValue);
	    if (!functionalReplace) replaceValue = toString_1(replaceValue);
	    searchLength = searchString.length;
	    advanceBy = max$2(1, searchLength);
	    position = stringIndexOf$1(string, searchString, 0);

	    while (position !== -1) {
	      replacement = functionalReplace ? toString_1(replaceValue(searchString, position, string)) : getSubstitution(searchString, string, position, [], undefined, replaceValue);
	      result += stringSlice$4(string, endOfLastMatch, position) + replacement;
	      endOfLastMatch = position + searchLength;
	      position = stringIndexOf$1(string, searchString, position + advanceBy);
	    }

	    if (endOfLastMatch < string.length) {
	      result += stringSlice$4(string, endOfLastMatch);
	    }

	    return result;
	  }
	});

	var ITERATOR$3 = wellKnownSymbol('iterator');
	var SAFE_CLOSING = false;

	var checkCorrectnessOfIteration = function (exec, SKIP_CLOSING) {
	  if (!SKIP_CLOSING && !SAFE_CLOSING) return false;
	  var ITERATION_SUPPORT = false;

	  try {
	    var object = {};

	    object[ITERATOR$3] = function () {
	      return {
	        next: function () {
	          return {
	            done: ITERATION_SUPPORT = true
	          };
	        }
	      };
	    };

	    exec(object);
	  } catch (error) {
	    /* empty */
	  }

	  return ITERATION_SUPPORT;
	};

	var defineProperty$3 = objectDefineProperty.f;











	var Int8Array = global_1.Int8Array;
	var Int8ArrayPrototype = Int8Array && Int8Array.prototype;
	var Uint8ClampedArray = global_1.Uint8ClampedArray;
	var Uint8ClampedArrayPrototype = Uint8ClampedArray && Uint8ClampedArray.prototype;
	var TypedArray = Int8Array && objectGetPrototypeOf(Int8Array);
	var TypedArrayPrototype = Int8ArrayPrototype && objectGetPrototypeOf(Int8ArrayPrototype);
	var ObjectPrototype$2 = Object.prototype;
	var TypeError$g = global_1.TypeError;
	var TO_STRING_TAG$4 = wellKnownSymbol('toStringTag');
	var TYPED_ARRAY_TAG = uid('TYPED_ARRAY_TAG');
	var TYPED_ARRAY_CONSTRUCTOR = uid('TYPED_ARRAY_CONSTRUCTOR'); // Fixing native typed arrays in Opera Presto crashes the browser, see #595

	var NATIVE_ARRAY_BUFFER_VIEWS = arrayBufferNative && !!objectSetPrototypeOf && classof(global_1.opera) !== 'Opera';
	var TYPED_ARRAY_TAG_REQIRED = false;
	var NAME, Constructor, Prototype;
	var TypedArrayConstructorsList = {
	  Int8Array: 1,
	  Uint8Array: 1,
	  Uint8ClampedArray: 1,
	  Int16Array: 2,
	  Uint16Array: 2,
	  Int32Array: 4,
	  Uint32Array: 4,
	  Float32Array: 4,
	  Float64Array: 8
	};
	var BigIntArrayConstructorsList = {
	  BigInt64Array: 8,
	  BigUint64Array: 8
	};

	var isView = function isView(it) {
	  if (!isObject(it)) return false;
	  var klass = classof(it);
	  return klass === 'DataView' || hasOwnProperty_1(TypedArrayConstructorsList, klass) || hasOwnProperty_1(BigIntArrayConstructorsList, klass);
	};

	var isTypedArray = function (it) {
	  if (!isObject(it)) return false;
	  var klass = classof(it);
	  return hasOwnProperty_1(TypedArrayConstructorsList, klass) || hasOwnProperty_1(BigIntArrayConstructorsList, klass);
	};

	var aTypedArray = function (it) {
	  if (isTypedArray(it)) return it;
	  throw TypeError$g('Target is not a typed array');
	};

	var aTypedArrayConstructor = function (C) {
	  if (isCallable(C) && (!objectSetPrototypeOf || objectIsPrototypeOf(TypedArray, C))) return C;
	  throw TypeError$g(tryToString(C) + ' is not a typed array constructor');
	};

	var exportTypedArrayMethod = function (KEY, property, forced) {
	  if (!descriptors) return;
	  if (forced) for (var ARRAY in TypedArrayConstructorsList) {
	    var TypedArrayConstructor = global_1[ARRAY];
	    if (TypedArrayConstructor && hasOwnProperty_1(TypedArrayConstructor.prototype, KEY)) try {
	      delete TypedArrayConstructor.prototype[KEY];
	    } catch (error) {
	      /* empty */
	    }
	  }

	  if (!TypedArrayPrototype[KEY] || forced) {
	    redefine(TypedArrayPrototype, KEY, forced ? property : NATIVE_ARRAY_BUFFER_VIEWS && Int8ArrayPrototype[KEY] || property);
	  }
	};

	var exportTypedArrayStaticMethod = function (KEY, property, forced) {
	  var ARRAY, TypedArrayConstructor;
	  if (!descriptors) return;

	  if (objectSetPrototypeOf) {
	    if (forced) for (ARRAY in TypedArrayConstructorsList) {
	      TypedArrayConstructor = global_1[ARRAY];
	      if (TypedArrayConstructor && hasOwnProperty_1(TypedArrayConstructor, KEY)) try {
	        delete TypedArrayConstructor[KEY];
	      } catch (error) {
	        /* empty */
	      }
	    }

	    if (!TypedArray[KEY] || forced) {
	      // V8 ~ Chrome 49-50 `%TypedArray%` methods are non-writable non-configurable
	      try {
	        return redefine(TypedArray, KEY, forced ? property : NATIVE_ARRAY_BUFFER_VIEWS && TypedArray[KEY] || property);
	      } catch (error) {
	        /* empty */
	      }
	    } else return;
	  }

	  for (ARRAY in TypedArrayConstructorsList) {
	    TypedArrayConstructor = global_1[ARRAY];

	    if (TypedArrayConstructor && (!TypedArrayConstructor[KEY] || forced)) {
	      redefine(TypedArrayConstructor, KEY, property);
	    }
	  }
	};

	for (NAME in TypedArrayConstructorsList) {
	  Constructor = global_1[NAME];
	  Prototype = Constructor && Constructor.prototype;
	  if (Prototype) createNonEnumerableProperty(Prototype, TYPED_ARRAY_CONSTRUCTOR, Constructor);else NATIVE_ARRAY_BUFFER_VIEWS = false;
	}

	for (NAME in BigIntArrayConstructorsList) {
	  Constructor = global_1[NAME];
	  Prototype = Constructor && Constructor.prototype;
	  if (Prototype) createNonEnumerableProperty(Prototype, TYPED_ARRAY_CONSTRUCTOR, Constructor);
	} // WebKit bug - typed arrays constructors prototype is Object.prototype


	if (!NATIVE_ARRAY_BUFFER_VIEWS || !isCallable(TypedArray) || TypedArray === Function.prototype) {
	  // eslint-disable-next-line no-shadow -- safe
	  TypedArray = function TypedArray() {
	    throw TypeError$g('Incorrect invocation');
	  };

	  if (NATIVE_ARRAY_BUFFER_VIEWS) for (NAME in TypedArrayConstructorsList) {
	    if (global_1[NAME]) objectSetPrototypeOf(global_1[NAME], TypedArray);
	  }
	}

	if (!NATIVE_ARRAY_BUFFER_VIEWS || !TypedArrayPrototype || TypedArrayPrototype === ObjectPrototype$2) {
	  TypedArrayPrototype = TypedArray.prototype;
	  if (NATIVE_ARRAY_BUFFER_VIEWS) for (NAME in TypedArrayConstructorsList) {
	    if (global_1[NAME]) objectSetPrototypeOf(global_1[NAME].prototype, TypedArrayPrototype);
	  }
	} // WebKit bug - one more object in Uint8ClampedArray prototype chain


	if (NATIVE_ARRAY_BUFFER_VIEWS && objectGetPrototypeOf(Uint8ClampedArrayPrototype) !== TypedArrayPrototype) {
	  objectSetPrototypeOf(Uint8ClampedArrayPrototype, TypedArrayPrototype);
	}

	if (descriptors && !hasOwnProperty_1(TypedArrayPrototype, TO_STRING_TAG$4)) {
	  TYPED_ARRAY_TAG_REQIRED = true;
	  defineProperty$3(TypedArrayPrototype, TO_STRING_TAG$4, {
	    get: function () {
	      return isObject(this) ? this[TYPED_ARRAY_TAG] : undefined;
	    }
	  });

	  for (NAME in TypedArrayConstructorsList) if (global_1[NAME]) {
	    createNonEnumerableProperty(global_1[NAME], TYPED_ARRAY_TAG, NAME);
	  }
	}

	var arrayBufferViewCore = {
	  NATIVE_ARRAY_BUFFER_VIEWS: NATIVE_ARRAY_BUFFER_VIEWS,
	  TYPED_ARRAY_CONSTRUCTOR: TYPED_ARRAY_CONSTRUCTOR,
	  TYPED_ARRAY_TAG: TYPED_ARRAY_TAG_REQIRED && TYPED_ARRAY_TAG,
	  aTypedArray: aTypedArray,
	  aTypedArrayConstructor: aTypedArrayConstructor,
	  exportTypedArrayMethod: exportTypedArrayMethod,
	  exportTypedArrayStaticMethod: exportTypedArrayStaticMethod,
	  isView: isView,
	  isTypedArray: isTypedArray,
	  TypedArray: TypedArray,
	  TypedArrayPrototype: TypedArrayPrototype
	};

	/* eslint-disable no-new -- required for testing */






	var NATIVE_ARRAY_BUFFER_VIEWS$1 = arrayBufferViewCore.NATIVE_ARRAY_BUFFER_VIEWS;

	var ArrayBuffer$2 = global_1.ArrayBuffer;
	var Int8Array$1 = global_1.Int8Array;
	var typedArrayConstructorsRequireWrappers = !NATIVE_ARRAY_BUFFER_VIEWS$1 || !fails(function () {
	  Int8Array$1(1);
	}) || !fails(function () {
	  new Int8Array$1(-1);
	}) || !checkCorrectnessOfIteration(function (iterable) {
	  new Int8Array$1();
	  new Int8Array$1(null);
	  new Int8Array$1(1.5);
	  new Int8Array$1(iterable);
	}, true) || fails(function () {
	  // Safari (11+) bug - a reason why even Safari 13 should load a typed array polyfill
	  return new Int8Array$1(new ArrayBuffer$2(2), 1, undefined).length !== 1;
	});

	var floor$3 = Math.floor; // `IsIntegralNumber` abstract operation
	// https://tc39.es/ecma262/#sec-isintegralnumber
	// eslint-disable-next-line es/no-number-isinteger -- safe

	var isIntegralNumber = Number.isInteger || function isInteger(it) {
	  return !isObject(it) && isFinite(it) && floor$3(it) === it;
	};

	var RangeError$2 = global_1.RangeError;

	var toPositiveInteger = function (it) {
	  var result = toIntegerOrInfinity(it);
	  if (result < 0) throw RangeError$2("The argument can't be less than 0");
	  return result;
	};

	var RangeError$3 = global_1.RangeError;

	var toOffset = function (it, BYTES) {
	  var offset = toPositiveInteger(it);
	  if (offset % BYTES) throw RangeError$3('Wrong offset');
	  return offset;
	};

	var aTypedArrayConstructor$1 = arrayBufferViewCore.aTypedArrayConstructor;

	var typedArrayFrom = function from(source
	/* , mapfn, thisArg */
	) {
	  var C = aConstructor(this);
	  var O = toObject(source);
	  var argumentsLength = arguments.length;
	  var mapfn = argumentsLength > 1 ? arguments[1] : undefined;
	  var mapping = mapfn !== undefined;
	  var iteratorMethod = getIteratorMethod(O);
	  var i, length, result, step, iterator, next;

	  if (iteratorMethod && !isArrayIteratorMethod(iteratorMethod)) {
	    iterator = getIterator(O, iteratorMethod);
	    next = iterator.next;
	    O = [];

	    while (!(step = functionCall(next, iterator)).done) {
	      O.push(step.value);
	    }
	  }

	  if (mapping && argumentsLength > 2) {
	    mapfn = functionBindContext(mapfn, arguments[2]);
	  }

	  length = lengthOfArrayLike(O);
	  result = new (aTypedArrayConstructor$1(C))(length);

	  for (i = 0; length > i; i++) {
	    result[i] = mapping ? mapfn(O[i], i) : O[i];
	  }

	  return result;
	};

	var SPECIES$1 = wellKnownSymbol('species');
	var Array$4 = global_1.Array; // a part of `ArraySpeciesCreate` abstract operation
	// https://tc39.es/ecma262/#sec-arrayspeciescreate

	var arraySpeciesConstructor = function (originalArray) {
	  var C;

	  if (isArray(originalArray)) {
	    C = originalArray.constructor; // cross-realm fallback

	    if (isConstructor(C) && (C === Array$4 || isArray(C.prototype))) C = undefined;else if (isObject(C)) {
	      C = C[SPECIES$1];
	      if (C === null) C = undefined;
	    }
	  }

	  return C === undefined ? Array$4 : C;
	};

	// `ArraySpeciesCreate` abstract operation
	// https://tc39.es/ecma262/#sec-arrayspeciescreate


	var arraySpeciesCreate = function (originalArray, length) {
	  return new (arraySpeciesConstructor(originalArray))(length === 0 ? 0 : length);
	};

	var push$2 = functionUncurryThis([].push); // `Array.prototype.{ forEach, map, filter, some, every, find, findIndex, filterReject }` methods implementation

	var createMethod$2 = function (TYPE) {
	  var IS_MAP = TYPE == 1;
	  var IS_FILTER = TYPE == 2;
	  var IS_SOME = TYPE == 3;
	  var IS_EVERY = TYPE == 4;
	  var IS_FIND_INDEX = TYPE == 6;
	  var IS_FILTER_REJECT = TYPE == 7;
	  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
	  return function ($this, callbackfn, that, specificCreate) {
	    var O = toObject($this);
	    var self = indexedObject(O);
	    var boundFunction = functionBindContext(callbackfn, that);
	    var length = lengthOfArrayLike(self);
	    var index = 0;
	    var create = specificCreate || arraySpeciesCreate;
	    var target = IS_MAP ? create($this, length) : IS_FILTER || IS_FILTER_REJECT ? create($this, 0) : undefined;
	    var value, result;

	    for (; length > index; index++) if (NO_HOLES || index in self) {
	      value = self[index];
	      result = boundFunction(value, index, O);

	      if (TYPE) {
	        if (IS_MAP) target[index] = result; // map
	        else if (result) switch (TYPE) {
	            case 3:
	              return true;
	            // some

	            case 5:
	              return value;
	            // find

	            case 6:
	              return index;
	            // findIndex

	            case 2:
	              push$2(target, value);
	            // filter
	          } else switch (TYPE) {
	            case 4:
	              return false;
	            // every

	            case 7:
	              push$2(target, value);
	            // filterReject
	          }
	      }
	    }

	    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
	  };
	};

	var arrayIteration = {
	  // `Array.prototype.forEach` method
	  // https://tc39.es/ecma262/#sec-array.prototype.foreach
	  forEach: createMethod$2(0),
	  // `Array.prototype.map` method
	  // https://tc39.es/ecma262/#sec-array.prototype.map
	  map: createMethod$2(1),
	  // `Array.prototype.filter` method
	  // https://tc39.es/ecma262/#sec-array.prototype.filter
	  filter: createMethod$2(2),
	  // `Array.prototype.some` method
	  // https://tc39.es/ecma262/#sec-array.prototype.some
	  some: createMethod$2(3),
	  // `Array.prototype.every` method
	  // https://tc39.es/ecma262/#sec-array.prototype.every
	  every: createMethod$2(4),
	  // `Array.prototype.find` method
	  // https://tc39.es/ecma262/#sec-array.prototype.find
	  find: createMethod$2(5),
	  // `Array.prototype.findIndex` method
	  // https://tc39.es/ecma262/#sec-array.prototype.findIndex
	  findIndex: createMethod$2(6),
	  // `Array.prototype.filterReject` method
	  // https://github.com/tc39/proposal-array-filtering
	  filterReject: createMethod$2(7)
	};

	var SPECIES$2 = wellKnownSymbol('species');

	var setSpecies = function (CONSTRUCTOR_NAME) {
	  var Constructor = getBuiltIn(CONSTRUCTOR_NAME);
	  var defineProperty = objectDefineProperty.f;

	  if (descriptors && Constructor && !Constructor[SPECIES$2]) {
	    defineProperty(Constructor, SPECIES$2, {
	      configurable: true,
	      get: function () {
	        return this;
	      }
	    });
	  }
	};

	// makes subclassing work correct for wrapped built-ins


	var inheritIfRequired = function ($this, dummy, Wrapper) {
	  var NewTarget, NewTargetPrototype;
	  if ( // it can work only with native `setPrototypeOf`
	  objectSetPrototypeOf && // we haven't completely correct pre-ES6 way for getting `new.target`, so use this
	  isCallable(NewTarget = dummy.constructor) && NewTarget !== Wrapper && isObject(NewTargetPrototype = NewTarget.prototype) && NewTargetPrototype !== Wrapper.prototype) objectSetPrototypeOf($this, NewTargetPrototype);
	  return $this;
	};

	var typedArrayConstructor = createCommonjsModule(function (module) {













































	var getOwnPropertyNames = objectGetOwnPropertyNames.f;



	var forEach = arrayIteration.forEach;











	var getInternalState = internalState.get;
	var setInternalState = internalState.set;
	var nativeDefineProperty = objectDefineProperty.f;
	var nativeGetOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;
	var round = Math.round;
	var RangeError = global_1.RangeError;
	var ArrayBuffer = arrayBuffer.ArrayBuffer;
	var ArrayBufferPrototype = ArrayBuffer.prototype;
	var DataView = arrayBuffer.DataView;
	var NATIVE_ARRAY_BUFFER_VIEWS = arrayBufferViewCore.NATIVE_ARRAY_BUFFER_VIEWS;
	var TYPED_ARRAY_CONSTRUCTOR = arrayBufferViewCore.TYPED_ARRAY_CONSTRUCTOR;
	var TYPED_ARRAY_TAG = arrayBufferViewCore.TYPED_ARRAY_TAG;
	var TypedArray = arrayBufferViewCore.TypedArray;
	var TypedArrayPrototype = arrayBufferViewCore.TypedArrayPrototype;
	var aTypedArrayConstructor = arrayBufferViewCore.aTypedArrayConstructor;
	var isTypedArray = arrayBufferViewCore.isTypedArray;
	var BYTES_PER_ELEMENT = 'BYTES_PER_ELEMENT';
	var WRONG_LENGTH = 'Wrong length';

	var fromList = function (C, list) {
	  aTypedArrayConstructor(C);
	  var index = 0;
	  var length = list.length;
	  var result = new C(length);

	  while (length > index) result[index] = list[index++];

	  return result;
	};

	var addGetter = function (it, key) {
	  nativeDefineProperty(it, key, {
	    get: function () {
	      return getInternalState(this)[key];
	    }
	  });
	};

	var isArrayBuffer = function (it) {
	  var klass;
	  return objectIsPrototypeOf(ArrayBufferPrototype, it) || (klass = classof(it)) == 'ArrayBuffer' || klass == 'SharedArrayBuffer';
	};

	var isTypedArrayIndex = function (target, key) {
	  return isTypedArray(target) && !isSymbol(key) && key in target && isIntegralNumber(+key) && key >= 0;
	};

	var wrappedGetOwnPropertyDescriptor = function getOwnPropertyDescriptor(target, key) {
	  key = toPropertyKey(key);
	  return isTypedArrayIndex(target, key) ? createPropertyDescriptor(2, target[key]) : nativeGetOwnPropertyDescriptor(target, key);
	};

	var wrappedDefineProperty = function defineProperty(target, key, descriptor) {
	  key = toPropertyKey(key);

	  if (isTypedArrayIndex(target, key) && isObject(descriptor) && hasOwnProperty_1(descriptor, 'value') && !hasOwnProperty_1(descriptor, 'get') && !hasOwnProperty_1(descriptor, 'set') // TODO: add validation descriptor w/o calling accessors
	  && !descriptor.configurable && (!hasOwnProperty_1(descriptor, 'writable') || descriptor.writable) && (!hasOwnProperty_1(descriptor, 'enumerable') || descriptor.enumerable)) {
	    target[key] = descriptor.value;
	    return target;
	  }

	  return nativeDefineProperty(target, key, descriptor);
	};

	if (descriptors) {
	  if (!NATIVE_ARRAY_BUFFER_VIEWS) {
	    objectGetOwnPropertyDescriptor.f = wrappedGetOwnPropertyDescriptor;
	    objectDefineProperty.f = wrappedDefineProperty;
	    addGetter(TypedArrayPrototype, 'buffer');
	    addGetter(TypedArrayPrototype, 'byteOffset');
	    addGetter(TypedArrayPrototype, 'byteLength');
	    addGetter(TypedArrayPrototype, 'length');
	  }

	  _export({
	    target: 'Object',
	    stat: true,
	    forced: !NATIVE_ARRAY_BUFFER_VIEWS
	  }, {
	    getOwnPropertyDescriptor: wrappedGetOwnPropertyDescriptor,
	    defineProperty: wrappedDefineProperty
	  });

	  module.exports = function (TYPE, wrapper, CLAMPED) {
	    var BYTES = TYPE.match(/\d+$/)[0] / 8;
	    var CONSTRUCTOR_NAME = TYPE + (CLAMPED ? 'Clamped' : '') + 'Array';
	    var GETTER = 'get' + TYPE;
	    var SETTER = 'set' + TYPE;
	    var NativeTypedArrayConstructor = global_1[CONSTRUCTOR_NAME];
	    var TypedArrayConstructor = NativeTypedArrayConstructor;
	    var TypedArrayConstructorPrototype = TypedArrayConstructor && TypedArrayConstructor.prototype;
	    var exported = {};

	    var getter = function (that, index) {
	      var data = getInternalState(that);
	      return data.view[GETTER](index * BYTES + data.byteOffset, true);
	    };

	    var setter = function (that, index, value) {
	      var data = getInternalState(that);
	      if (CLAMPED) value = (value = round(value)) < 0 ? 0 : value > 0xFF ? 0xFF : value & 0xFF;
	      data.view[SETTER](index * BYTES + data.byteOffset, value, true);
	    };

	    var addElement = function (that, index) {
	      nativeDefineProperty(that, index, {
	        get: function () {
	          return getter(this, index);
	        },
	        set: function (value) {
	          return setter(this, index, value);
	        },
	        enumerable: true
	      });
	    };

	    if (!NATIVE_ARRAY_BUFFER_VIEWS) {
	      TypedArrayConstructor = wrapper(function (that, data, offset, $length) {
	        anInstance(that, TypedArrayConstructorPrototype);
	        var index = 0;
	        var byteOffset = 0;
	        var buffer, byteLength, length;

	        if (!isObject(data)) {
	          length = toIndex(data);
	          byteLength = length * BYTES;
	          buffer = new ArrayBuffer(byteLength);
	        } else if (isArrayBuffer(data)) {
	          buffer = data;
	          byteOffset = toOffset(offset, BYTES);
	          var $len = data.byteLength;

	          if ($length === undefined) {
	            if ($len % BYTES) throw RangeError(WRONG_LENGTH);
	            byteLength = $len - byteOffset;
	            if (byteLength < 0) throw RangeError(WRONG_LENGTH);
	          } else {
	            byteLength = toLength($length) * BYTES;
	            if (byteLength + byteOffset > $len) throw RangeError(WRONG_LENGTH);
	          }

	          length = byteLength / BYTES;
	        } else if (isTypedArray(data)) {
	          return fromList(TypedArrayConstructor, data);
	        } else {
	          return functionCall(typedArrayFrom, TypedArrayConstructor, data);
	        }

	        setInternalState(that, {
	          buffer: buffer,
	          byteOffset: byteOffset,
	          byteLength: byteLength,
	          length: length,
	          view: new DataView(buffer)
	        });

	        while (index < length) addElement(that, index++);
	      });
	      if (objectSetPrototypeOf) objectSetPrototypeOf(TypedArrayConstructor, TypedArray);
	      TypedArrayConstructorPrototype = TypedArrayConstructor.prototype = objectCreate(TypedArrayPrototype);
	    } else if (typedArrayConstructorsRequireWrappers) {
	      TypedArrayConstructor = wrapper(function (dummy, data, typedArrayOffset, $length) {
	        anInstance(dummy, TypedArrayConstructorPrototype);
	        return inheritIfRequired(function () {
	          if (!isObject(data)) return new NativeTypedArrayConstructor(toIndex(data));
	          if (isArrayBuffer(data)) return $length !== undefined ? new NativeTypedArrayConstructor(data, toOffset(typedArrayOffset, BYTES), $length) : typedArrayOffset !== undefined ? new NativeTypedArrayConstructor(data, toOffset(typedArrayOffset, BYTES)) : new NativeTypedArrayConstructor(data);
	          if (isTypedArray(data)) return fromList(TypedArrayConstructor, data);
	          return functionCall(typedArrayFrom, TypedArrayConstructor, data);
	        }(), dummy, TypedArrayConstructor);
	      });
	      if (objectSetPrototypeOf) objectSetPrototypeOf(TypedArrayConstructor, TypedArray);
	      forEach(getOwnPropertyNames(NativeTypedArrayConstructor), function (key) {
	        if (!(key in TypedArrayConstructor)) {
	          createNonEnumerableProperty(TypedArrayConstructor, key, NativeTypedArrayConstructor[key]);
	        }
	      });
	      TypedArrayConstructor.prototype = TypedArrayConstructorPrototype;
	    }

	    if (TypedArrayConstructorPrototype.constructor !== TypedArrayConstructor) {
	      createNonEnumerableProperty(TypedArrayConstructorPrototype, 'constructor', TypedArrayConstructor);
	    }

	    createNonEnumerableProperty(TypedArrayConstructorPrototype, TYPED_ARRAY_CONSTRUCTOR, TypedArrayConstructor);

	    if (TYPED_ARRAY_TAG) {
	      createNonEnumerableProperty(TypedArrayConstructorPrototype, TYPED_ARRAY_TAG, CONSTRUCTOR_NAME);
	    }

	    exported[CONSTRUCTOR_NAME] = TypedArrayConstructor;
	    _export({
	      global: true,
	      forced: TypedArrayConstructor != NativeTypedArrayConstructor,
	      sham: !NATIVE_ARRAY_BUFFER_VIEWS
	    }, exported);

	    if (!(BYTES_PER_ELEMENT in TypedArrayConstructor)) {
	      createNonEnumerableProperty(TypedArrayConstructor, BYTES_PER_ELEMENT, BYTES);
	    }

	    if (!(BYTES_PER_ELEMENT in TypedArrayConstructorPrototype)) {
	      createNonEnumerableProperty(TypedArrayConstructorPrototype, BYTES_PER_ELEMENT, BYTES);
	    }

	    setSpecies(CONSTRUCTOR_NAME);
	  };
	} else module.exports = function () {
	  /* empty */
	};
	});

	// `Float32Array` constructor
	// https://tc39.es/ecma262/#sec-typedarray-objects


	typedArrayConstructor('Float32', function (init) {
	  return function Float32Array(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	});

	// `Float64Array` constructor
	// https://tc39.es/ecma262/#sec-typedarray-objects


	typedArrayConstructor('Float64', function (init) {
	  return function Float64Array(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	});

	// `Int8Array` constructor
	// https://tc39.es/ecma262/#sec-typedarray-objects


	typedArrayConstructor('Int8', function (init) {
	  return function Int8Array(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	});

	// `Int16Array` constructor
	// https://tc39.es/ecma262/#sec-typedarray-objects


	typedArrayConstructor('Int16', function (init) {
	  return function Int16Array(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	});

	// `Int32Array` constructor
	// https://tc39.es/ecma262/#sec-typedarray-objects


	typedArrayConstructor('Int32', function (init) {
	  return function Int32Array(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	});

	// `Uint8Array` constructor
	// https://tc39.es/ecma262/#sec-typedarray-objects


	typedArrayConstructor('Uint8', function (init) {
	  return function Uint8Array(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	});

	// `Uint8ClampedArray` constructor
	// https://tc39.es/ecma262/#sec-typedarray-objects


	typedArrayConstructor('Uint8', function (init) {
	  return function Uint8ClampedArray(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	}, true);

	// `Uint16Array` constructor
	// https://tc39.es/ecma262/#sec-typedarray-objects


	typedArrayConstructor('Uint16', function (init) {
	  return function Uint16Array(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	});

	// `Uint32Array` constructor
	// https://tc39.es/ecma262/#sec-typedarray-objects


	typedArrayConstructor('Uint32', function (init) {
	  return function Uint32Array(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	});

	var aTypedArray$1 = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$1 = arrayBufferViewCore.exportTypedArrayMethod; // `%TypedArray%.prototype.at` method
	// https://github.com/tc39/proposal-relative-indexing-method

	exportTypedArrayMethod$1('at', function at(index) {
	  var O = aTypedArray$1(this);
	  var len = lengthOfArrayLike(O);
	  var relativeIndex = toIntegerOrInfinity(index);
	  var k = relativeIndex >= 0 ? relativeIndex : len + relativeIndex;
	  return k < 0 || k >= len ? undefined : O[k];
	});

	var exportTypedArrayStaticMethod$1 = arrayBufferViewCore.exportTypedArrayStaticMethod;

	 // `%TypedArray%.from` method
	// https://tc39.es/ecma262/#sec-%typedarray%.from


	exportTypedArrayStaticMethod$1('from', typedArrayFrom, typedArrayConstructorsRequireWrappers);

	var aTypedArrayConstructor$2 = arrayBufferViewCore.aTypedArrayConstructor;
	var exportTypedArrayStaticMethod$2 = arrayBufferViewCore.exportTypedArrayStaticMethod; // `%TypedArray%.of` method
	// https://tc39.es/ecma262/#sec-%typedarray%.of

	exportTypedArrayStaticMethod$2('of', function of()
	/* ...items */
	{
	  var index = 0;
	  var length = arguments.length;
	  var result = new (aTypedArrayConstructor$2(this))(length);

	  while (length > index) result[index] = arguments[index++];

	  return result;
	}, typedArrayConstructorsRequireWrappers);

	var floor$4 = Math.floor;

	var mergeSort = function (array, comparefn) {
	  var length = array.length;
	  var middle = floor$4(length / 2);
	  return length < 8 ? insertionSort(array, comparefn) : merge(array, mergeSort(arraySliceSimple(array, 0, middle), comparefn), mergeSort(arraySliceSimple(array, middle), comparefn), comparefn);
	};

	var insertionSort = function (array, comparefn) {
	  var length = array.length;
	  var i = 1;
	  var element, j;

	  while (i < length) {
	    j = i;
	    element = array[i];

	    while (j && comparefn(array[j - 1], element) > 0) {
	      array[j] = array[--j];
	    }

	    if (j !== i++) array[j] = element;
	  }

	  return array;
	};

	var merge = function (array, left, right, comparefn) {
	  var llength = left.length;
	  var rlength = right.length;
	  var lindex = 0;
	  var rindex = 0;

	  while (lindex < llength || rindex < rlength) {
	    array[lindex + rindex] = lindex < llength && rindex < rlength ? comparefn(left[lindex], right[rindex]) <= 0 ? left[lindex++] : right[rindex++] : lindex < llength ? left[lindex++] : right[rindex++];
	  }

	  return array;
	};

	var arraySort = mergeSort;

	var firefox = engineUserAgent.match(/firefox\/(\d+)/i);
	var engineFfVersion = !!firefox && +firefox[1];

	var engineIsIeOrEdge = /MSIE|Trident/.test(engineUserAgent);

	var webkit = engineUserAgent.match(/AppleWebKit\/(\d+)\./);
	var engineWebkitVersion = !!webkit && +webkit[1];

	var Array$5 = global_1.Array;
	var aTypedArray$2 = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$2 = arrayBufferViewCore.exportTypedArrayMethod;
	var Uint16Array = global_1.Uint16Array;
	var un$Sort = Uint16Array && functionUncurryThis(Uint16Array.prototype.sort); // WebKit

	var ACCEPT_INCORRECT_ARGUMENTS = !!un$Sort && !(fails(function () {
	  un$Sort(new Uint16Array(2), null);
	}) && fails(function () {
	  un$Sort(new Uint16Array(2), {});
	}));
	var STABLE_SORT = !!un$Sort && !fails(function () {
	  // feature detection can be too slow, so check engines versions
	  if (engineV8Version) return engineV8Version < 74;
	  if (engineFfVersion) return engineFfVersion < 67;
	  if (engineIsIeOrEdge) return true;
	  if (engineWebkitVersion) return engineWebkitVersion < 602;
	  var array = new Uint16Array(516);
	  var expected = Array$5(516);
	  var index, mod;

	  for (index = 0; index < 516; index++) {
	    mod = index % 4;
	    array[index] = 515 - index;
	    expected[index] = index - 2 * mod + 3;
	  }

	  un$Sort(array, function (a, b) {
	    return (a / 4 | 0) - (b / 4 | 0);
	  });

	  for (index = 0; index < 516; index++) {
	    if (array[index] !== expected[index]) return true;
	  }
	});

	var getSortCompare = function (comparefn) {
	  return function (x, y) {
	    if (comparefn !== undefined) return +comparefn(x, y) || 0; // eslint-disable-next-line no-self-compare -- NaN check

	    if (y !== y) return -1; // eslint-disable-next-line no-self-compare -- NaN check

	    if (x !== x) return 1;
	    if (x === 0 && y === 0) return 1 / x > 0 && 1 / y < 0 ? 1 : -1;
	    return x > y;
	  };
	}; // `%TypedArray%.prototype.sort` method
	// https://tc39.es/ecma262/#sec-%typedarray%.prototype.sort


	exportTypedArrayMethod$2('sort', function sort(comparefn) {
	  if (comparefn !== undefined) aCallable(comparefn);
	  if (STABLE_SORT) return un$Sort(this, comparefn);
	  return arraySort(aTypedArray$2(this), getSortCompare(comparefn));
	}, !STABLE_SORT || ACCEPT_INCORRECT_ARGUMENTS);

	// iterable DOM collections
	// flag - `iterable` interface - 'entries', 'keys', 'values', 'forEach' methods
	var domIterables = {
	  CSSRuleList: 0,
	  CSSStyleDeclaration: 0,
	  CSSValueList: 0,
	  ClientRectList: 0,
	  DOMRectList: 0,
	  DOMStringList: 0,
	  DOMTokenList: 1,
	  DataTransferItemList: 0,
	  FileList: 0,
	  HTMLAllCollection: 0,
	  HTMLCollection: 0,
	  HTMLFormElement: 0,
	  HTMLSelectElement: 0,
	  MediaList: 0,
	  MimeTypeArray: 0,
	  NamedNodeMap: 0,
	  NodeList: 1,
	  PaintRequestList: 0,
	  Plugin: 0,
	  PluginArray: 0,
	  SVGLengthList: 0,
	  SVGNumberList: 0,
	  SVGPathSegList: 0,
	  SVGPointList: 0,
	  SVGStringList: 0,
	  SVGTransformList: 0,
	  SourceBufferList: 0,
	  StyleSheetList: 0,
	  TextTrackCueList: 0,
	  TextTrackList: 0,
	  TouchList: 0
	};

	// in old WebKit versions, `element.classList` is not an instance of global `DOMTokenList`


	var classList = documentCreateElement('span').classList;
	var DOMTokenListPrototype = classList && classList.constructor && classList.constructor.prototype;
	var domTokenListPrototype = DOMTokenListPrototype === Object.prototype ? undefined : DOMTokenListPrototype;

	var PROPER_FUNCTION_NAME$1 = functionName.PROPER;
	var CONFIGURABLE_FUNCTION_NAME$1 = functionName.CONFIGURABLE;
	var IteratorPrototype$2 = iteratorsCore.IteratorPrototype;
	var BUGGY_SAFARI_ITERATORS$1 = iteratorsCore.BUGGY_SAFARI_ITERATORS;
	var ITERATOR$4 = wellKnownSymbol('iterator');
	var KEYS = 'keys';
	var VALUES = 'values';
	var ENTRIES = 'entries';

	var returnThis$1 = function () {
	  return this;
	};

	var defineIterator = function (Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
	  createIteratorConstructor(IteratorConstructor, NAME, next);

	  var getIterationMethod = function (KIND) {
	    if (KIND === DEFAULT && defaultIterator) return defaultIterator;
	    if (!BUGGY_SAFARI_ITERATORS$1 && KIND in IterablePrototype) return IterablePrototype[KIND];

	    switch (KIND) {
	      case KEYS:
	        return function keys() {
	          return new IteratorConstructor(this, KIND);
	        };

	      case VALUES:
	        return function values() {
	          return new IteratorConstructor(this, KIND);
	        };

	      case ENTRIES:
	        return function entries() {
	          return new IteratorConstructor(this, KIND);
	        };
	    }

	    return function () {
	      return new IteratorConstructor(this);
	    };
	  };

	  var TO_STRING_TAG = NAME + ' Iterator';
	  var INCORRECT_VALUES_NAME = false;
	  var IterablePrototype = Iterable.prototype;
	  var nativeIterator = IterablePrototype[ITERATOR$4] || IterablePrototype['@@iterator'] || DEFAULT && IterablePrototype[DEFAULT];
	  var defaultIterator = !BUGGY_SAFARI_ITERATORS$1 && nativeIterator || getIterationMethod(DEFAULT);
	  var anyNativeIterator = NAME == 'Array' ? IterablePrototype.entries || nativeIterator : nativeIterator;
	  var CurrentIteratorPrototype, methods, KEY; // fix native

	  if (anyNativeIterator) {
	    CurrentIteratorPrototype = objectGetPrototypeOf(anyNativeIterator.call(new Iterable()));

	    if (CurrentIteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
	      if (objectGetPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype$2) {
	        if (objectSetPrototypeOf) {
	          objectSetPrototypeOf(CurrentIteratorPrototype, IteratorPrototype$2);
	        } else if (!isCallable(CurrentIteratorPrototype[ITERATOR$4])) {
	          redefine(CurrentIteratorPrototype, ITERATOR$4, returnThis$1);
	        }
	      } // Set @@toStringTag to native iterators


	      setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true, true);
	    }
	  } // fix Array.prototype.{ values, @@iterator }.name in V8 / FF


	  if (PROPER_FUNCTION_NAME$1 && DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {
	    if (CONFIGURABLE_FUNCTION_NAME$1) {
	      createNonEnumerableProperty(IterablePrototype, 'name', VALUES);
	    } else {
	      INCORRECT_VALUES_NAME = true;

	      defaultIterator = function values() {
	        return functionCall(nativeIterator, this);
	      };
	    }
	  } // export additional methods


	  if (DEFAULT) {
	    methods = {
	      values: getIterationMethod(VALUES),
	      keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
	      entries: getIterationMethod(ENTRIES)
	    };
	    if (FORCED) for (KEY in methods) {
	      if (BUGGY_SAFARI_ITERATORS$1 || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
	        redefine(IterablePrototype, KEY, methods[KEY]);
	      }
	    } else _export({
	      target: NAME,
	      proto: true,
	      forced: BUGGY_SAFARI_ITERATORS$1 || INCORRECT_VALUES_NAME
	    }, methods);
	  } // define iterator


	  if (IterablePrototype[ITERATOR$4] !== defaultIterator) {
	    redefine(IterablePrototype, ITERATOR$4, defaultIterator, {
	      name: DEFAULT
	    });
	  }

	  iterators[NAME] = defaultIterator;
	  return methods;
	};

	var ARRAY_ITERATOR = 'Array Iterator';
	var setInternalState$2 = internalState.set;
	var getInternalState$3 = internalState.getterFor(ARRAY_ITERATOR); // `Array.prototype.entries` method
	// https://tc39.es/ecma262/#sec-array.prototype.entries
	// `Array.prototype.keys` method
	// https://tc39.es/ecma262/#sec-array.prototype.keys
	// `Array.prototype.values` method
	// https://tc39.es/ecma262/#sec-array.prototype.values
	// `Array.prototype[@@iterator]` method
	// https://tc39.es/ecma262/#sec-array.prototype-@@iterator
	// `CreateArrayIterator` internal method
	// https://tc39.es/ecma262/#sec-createarrayiterator

	var es_array_iterator = defineIterator(Array, 'Array', function (iterated, kind) {
	  setInternalState$2(this, {
	    type: ARRAY_ITERATOR,
	    target: toIndexedObject(iterated),
	    // target
	    index: 0,
	    // next index
	    kind: kind // kind

	  }); // `%ArrayIteratorPrototype%.next` method
	  // https://tc39.es/ecma262/#sec-%arrayiteratorprototype%.next
	}, function () {
	  var state = getInternalState$3(this);
	  var target = state.target;
	  var kind = state.kind;
	  var index = state.index++;

	  if (!target || index >= target.length) {
	    state.target = undefined;
	    return {
	      value: undefined,
	      done: true
	    };
	  }

	  if (kind == 'keys') return {
	    value: index,
	    done: false
	  };
	  if (kind == 'values') return {
	    value: target[index],
	    done: false
	  };
	  return {
	    value: [index, target[index]],
	    done: false
	  };
	}, 'values'); // argumentsList[@@iterator] is %ArrayProto_values%
	// https://tc39.es/ecma262/#sec-createunmappedargumentsobject
	// https://tc39.es/ecma262/#sec-createmappedargumentsobject

	iterators.Arguments = iterators.Array; // https://tc39.es/ecma262/#sec-array.prototype-@@unscopables

	addToUnscopables('keys');
	addToUnscopables('values');
	addToUnscopables('entries');

	var ITERATOR$5 = wellKnownSymbol('iterator');
	var TO_STRING_TAG$5 = wellKnownSymbol('toStringTag');
	var ArrayValues = es_array_iterator.values;

	var handlePrototype = function (CollectionPrototype, COLLECTION_NAME) {
	  if (CollectionPrototype) {
	    // some Chrome versions have non-configurable methods on DOMTokenList
	    if (CollectionPrototype[ITERATOR$5] !== ArrayValues) try {
	      createNonEnumerableProperty(CollectionPrototype, ITERATOR$5, ArrayValues);
	    } catch (error) {
	      CollectionPrototype[ITERATOR$5] = ArrayValues;
	    }

	    if (!CollectionPrototype[TO_STRING_TAG$5]) {
	      createNonEnumerableProperty(CollectionPrototype, TO_STRING_TAG$5, COLLECTION_NAME);
	    }

	    if (domIterables[COLLECTION_NAME]) for (var METHOD_NAME in es_array_iterator) {
	      // some Chrome versions have non-configurable methods on DOMTokenList
	      if (CollectionPrototype[METHOD_NAME] !== es_array_iterator[METHOD_NAME]) try {
	        createNonEnumerableProperty(CollectionPrototype, METHOD_NAME, es_array_iterator[METHOD_NAME]);
	      } catch (error) {
	        CollectionPrototype[METHOD_NAME] = es_array_iterator[METHOD_NAME];
	      }
	    }
	  }
	};

	for (var COLLECTION_NAME in domIterables) {
	  handlePrototype(global_1[COLLECTION_NAME] && global_1[COLLECTION_NAME].prototype, COLLECTION_NAME);
	}

	handlePrototype(domTokenListPrototype, 'DOMTokenList');

	var FunctionPrototype$2 = Function.prototype;
	var apply = FunctionPrototype$2.apply;
	var bind$2 = FunctionPrototype$2.bind;
	var call$2 = FunctionPrototype$2.call; // eslint-disable-next-line es/no-reflect -- safe

	var functionApply = typeof Reflect == 'object' && Reflect.apply || (bind$2 ? call$2.bind(apply) : function () {
	  return call$2.apply(apply, arguments);
	});

	var arraySlice = functionUncurryThis([].slice);

	var engineIsIos = /(?:ipad|iphone|ipod).*applewebkit/i.test(engineUserAgent);

	var engineIsNode = classofRaw(global_1.process) == 'process';

	var set$2 = global_1.setImmediate;
	var clear = global_1.clearImmediate;
	var process$1 = global_1.process;
	var Dispatch = global_1.Dispatch;
	var Function$1 = global_1.Function;
	var MessageChannel = global_1.MessageChannel;
	var String$5 = global_1.String;
	var counter = 0;
	var queue = {};
	var ONREADYSTATECHANGE = 'onreadystatechange';
	var location, defer, channel, port;

	try {
	  // Deno throws a ReferenceError on `location` access without `--location` flag
	  location = global_1.location;
	} catch (error) {
	  /* empty */
	}

	var run = function (id) {
	  if (hasOwnProperty_1(queue, id)) {
	    var fn = queue[id];
	    delete queue[id];
	    fn();
	  }
	};

	var runner = function (id) {
	  return function () {
	    run(id);
	  };
	};

	var listener = function (event) {
	  run(event.data);
	};

	var post = function (id) {
	  // old engines have not location.origin
	  global_1.postMessage(String$5(id), location.protocol + '//' + location.host);
	}; // Node.js 0.9+ & IE10+ has setImmediate, otherwise:


	if (!set$2 || !clear) {
	  set$2 = function setImmediate(fn) {
	    var args = arraySlice(arguments, 1);

	    queue[++counter] = function () {
	      functionApply(isCallable(fn) ? fn : Function$1(fn), undefined, args);
	    };

	    defer(counter);
	    return counter;
	  };

	  clear = function clearImmediate(id) {
	    delete queue[id];
	  }; // Node.js 0.8-


	  if (engineIsNode) {
	    defer = function (id) {
	      process$1.nextTick(runner(id));
	    }; // Sphere (JS game engine) Dispatch API

	  } else if (Dispatch && Dispatch.now) {
	    defer = function (id) {
	      Dispatch.now(runner(id));
	    }; // Browsers with MessageChannel, includes WebWorkers
	    // except iOS - https://github.com/zloirock/core-js/issues/624

	  } else if (MessageChannel && !engineIsIos) {
	    channel = new MessageChannel();
	    port = channel.port2;
	    channel.port1.onmessage = listener;
	    defer = functionBindContext(port.postMessage, port); // Browsers with postMessage, skip WebWorkers
	    // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
	  } else if (global_1.addEventListener && isCallable(global_1.postMessage) && !global_1.importScripts && location && location.protocol !== 'file:' && !fails(post)) {
	    defer = post;
	    global_1.addEventListener('message', listener, false); // IE8-
	  } else if (ONREADYSTATECHANGE in documentCreateElement('script')) {
	    defer = function (id) {
	      html.appendChild(documentCreateElement('script'))[ONREADYSTATECHANGE] = function () {
	        html.removeChild(this);
	        run(id);
	      };
	    }; // Rest old browsers

	  } else {
	    defer = function (id) {
	      setTimeout(runner(id), 0);
	    };
	  }
	}

	var task = {
	  set: set$2,
	  clear: clear
	};

	var FORCED = !global_1.setImmediate || !global_1.clearImmediate; // http://w3c.github.io/setImmediate/

	_export({
	  global: true,
	  bind: true,
	  enumerable: true,
	  forced: FORCED
	}, {
	  // `setImmediate` method
	  // http://w3c.github.io/setImmediate/#si-setImmediate
	  setImmediate: task.set,
	  // `clearImmediate` method
	  // http://w3c.github.io/setImmediate/#si-clearImmediate
	  clearImmediate: task.clear
	});

	var engineIsIosPebble = /ipad|iphone|ipod/i.test(engineUserAgent) && global_1.Pebble !== undefined;

	var engineIsWebosWebkit = /web0s(?!.*chrome)/i.test(engineUserAgent);

	var getOwnPropertyDescriptor$2 = objectGetOwnPropertyDescriptor.f;

	var macrotask = task.set;









	var MutationObserver = global_1.MutationObserver || global_1.WebKitMutationObserver;
	var document$2 = global_1.document;
	var process$2 = global_1.process;
	var Promise = global_1.Promise; // Node.js 11 shows ExperimentalWarning on getting `queueMicrotask`

	var queueMicrotaskDescriptor = getOwnPropertyDescriptor$2(global_1, 'queueMicrotask');
	var queueMicrotask = queueMicrotaskDescriptor && queueMicrotaskDescriptor.value;
	var flush, head, last, notify, toggle, node, promise, then; // modern engines have queueMicrotask method

	if (!queueMicrotask) {
	  flush = function () {
	    var parent, fn;
	    if (engineIsNode && (parent = process$2.domain)) parent.exit();

	    while (head) {
	      fn = head.fn;
	      head = head.next;

	      try {
	        fn();
	      } catch (error) {
	        if (head) notify();else last = undefined;
	        throw error;
	      }
	    }

	    last = undefined;
	    if (parent) parent.enter();
	  }; // browsers with MutationObserver, except iOS - https://github.com/zloirock/core-js/issues/339
	  // also except WebOS Webkit https://github.com/zloirock/core-js/issues/898


	  if (!engineIsIos && !engineIsNode && !engineIsWebosWebkit && MutationObserver && document$2) {
	    toggle = true;
	    node = document$2.createTextNode('');
	    new MutationObserver(flush).observe(node, {
	      characterData: true
	    });

	    notify = function () {
	      node.data = toggle = !toggle;
	    }; // environments with maybe non-completely correct, but existent Promise

	  } else if (!engineIsIosPebble && Promise && Promise.resolve) {
	    // Promise.resolve without an argument throws an error in LG WebOS 2
	    promise = Promise.resolve(undefined); // workaround of WebKit ~ iOS Safari 10.1 bug

	    promise.constructor = Promise;
	    then = functionBindContext(promise.then, promise);

	    notify = function () {
	      then(flush);
	    }; // Node.js without promises

	  } else if (engineIsNode) {
	    notify = function () {
	      process$2.nextTick(flush);
	    }; // for other environments - macrotask based on:
	    // - setImmediate
	    // - MessageChannel
	    // - window.postMessag
	    // - onreadystatechange
	    // - setTimeout

	  } else {
	    // strange IE + webpack dev server bug - use .bind(global)
	    macrotask = functionBindContext(macrotask, global_1);

	    notify = function () {
	      macrotask(flush);
	    };
	  }
	}

	var microtask = queueMicrotask || function (fn) {
	  var task$$1 = {
	    fn: fn,
	    next: undefined
	  };
	  if (last) last.next = task$$1;

	  if (!head) {
	    head = task$$1;
	    notify();
	  }

	  last = task$$1;
	};

	var process$3 = global_1.process; // `queueMicrotask` method
	// https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#dom-queuemicrotask

	_export({
	  global: true,
	  enumerable: true,
	  noTargetGet: true
	}, {
	  queueMicrotask: function queueMicrotask(fn) {
	    var domain = engineIsNode && process$3.domain;
	    microtask(domain ? domain.bind(fn) : fn);
	  }
	});

	// File generated automatically. Don't modify it.

}((this.window = this.window || {})));



if (window._main_polyfill_core)
{
	console.warn('main.polyfill.core is loaded more than once on this page');
}

window._main_polyfill_core = true;


(function (exports) {
	'use strict';

	/**
	 * Gets object.toString result
	 * @param value
	 * @return {string}
	 */
	function getTag(value) {
	  return Object.prototype.toString.call(value);
	}

	var objectCtorString = Function.prototype.toString.call(Object);
	/**
	 * @memberOf BX
	 */

	var Type = /*#__PURE__*/function () {
	  function Type() {
	    babelHelpers.classCallCheck(this, Type);
	  }

	  babelHelpers.createClass(Type, null, [{
	    key: "isString",

	    /**
	     * Checks that value is string
	     * @param value
	     * @return {boolean}
	     */
	    value: function isString(value) {
	      return typeof value === 'string';
	    }
	    /**
	     * Returns true if a value is not empty string
	     * @param value
	     * @returns {boolean}
	     */

	  }, {
	    key: "isStringFilled",
	    value: function isStringFilled(value) {
	      return this.isString(value) && value !== '';
	    }
	    /**
	     * Checks that value is function
	     * @param value
	     * @return {boolean}
	     */

	  }, {
	    key: "isFunction",
	    value: function isFunction(value) {
	      return typeof value === 'function';
	    }
	    /**
	     * Checks that value is object
	     * @param value
	     * @return {boolean}
	     */

	  }, {
	    key: "isObject",
	    value: function isObject(value) {
	      return !!value && (babelHelpers["typeof"](value) === 'object' || typeof value === 'function');
	    }
	    /**
	     * Checks that value is object like
	     * @param value
	     * @return {boolean}
	     */

	  }, {
	    key: "isObjectLike",
	    value: function isObjectLike(value) {
	      return !!value && babelHelpers["typeof"](value) === 'object';
	    }
	    /**
	     * Checks that value is plain object
	     * @param value
	     * @return {boolean}
	     */

	  }, {
	    key: "isPlainObject",
	    value: function isPlainObject(value) {
	      if (!Type.isObjectLike(value) || getTag(value) !== '[object Object]') {
	        return false;
	      }

	      var proto = Object.getPrototypeOf(value);

	      if (proto === null) {
	        return true;
	      }

	      var ctor = proto.hasOwnProperty('constructor') && proto.constructor;
	      return typeof ctor === 'function' && Function.prototype.toString.call(ctor) === objectCtorString;
	    }
	    /**
	     * Checks that value is boolean
	     * @param value
	     * @return {boolean}
	     */

	  }, {
	    key: "isBoolean",
	    value: function isBoolean(value) {
	      return value === true || value === false;
	    }
	    /**
	     * Checks that value is number
	     * @param value
	     * @return {boolean}
	     */

	  }, {
	    key: "isNumber",
	    value: function isNumber(value) {
	      return !Number.isNaN(value) && typeof value === 'number';
	    }
	    /**
	     * Checks that value is integer
	     * @param value
	     * @return {boolean}
	     */

	  }, {
	    key: "isInteger",
	    value: function isInteger(value) {
	      return Type.isNumber(value) && value % 1 === 0;
	    }
	    /**
	     * Checks that value is float
	     * @param value
	     * @return {boolean}
	     */

	  }, {
	    key: "isFloat",
	    value: function isFloat(value) {
	      return Type.isNumber(value) && !Type.isInteger(value);
	    }
	    /**
	     * Checks that value is nil
	     * @param value
	     * @return {boolean}
	     */

	  }, {
	    key: "isNil",
	    value: function isNil(value) {
	      return value === null || value === undefined;
	    }
	    /**
	     * Checks that value is array
	     * @param value
	     * @return {boolean}
	     */

	  }, {
	    key: "isArray",
	    value: function isArray(value) {
	      return !Type.isNil(value) && Array.isArray(value);
	    }
	    /**
	     * Returns true if a value is an array and it has at least one element
	     * @param value
	     * @returns {boolean}
	     */

	  }, {
	    key: "isArrayFilled",
	    value: function isArrayFilled(value) {
	      return this.isArray(value) && value.length > 0;
	    }
	    /**
	     * Checks that value is array like
	     * @param value
	     * @return {boolean}
	     */

	  }, {
	    key: "isArrayLike",
	    value: function isArrayLike(value) {
	      return !Type.isNil(value) && !Type.isFunction(value) && value.length > -1 && value.length <= Number.MAX_SAFE_INTEGER;
	    }
	    /**
	     * Checks that value is Date
	     * @param value
	     * @return {boolean}
	     */

	  }, {
	    key: "isDate",
	    value: function isDate(value) {
	      return Type.isObjectLike(value) && getTag(value) === '[object Date]';
	    }
	    /**
	     * Checks that is DOM node
	     * @param value
	     * @return {boolean}
	     */

	  }, {
	    key: "isDomNode",
	    value: function isDomNode(value) {
	      return Type.isObjectLike(value) && !Type.isPlainObject(value) && 'nodeType' in value;
	    }
	    /**
	     * Checks that value is element node
	     * @param value
	     * @return {boolean}
	     */

	  }, {
	    key: "isElementNode",
	    value: function isElementNode(value) {
	      return Type.isDomNode(value) && value.nodeType === Node.ELEMENT_NODE;
	    }
	    /**
	     * Checks that value is text node
	     * @param value
	     * @return {boolean}
	     */

	  }, {
	    key: "isTextNode",
	    value: function isTextNode(value) {
	      return Type.isDomNode(value) && value.nodeType === Node.TEXT_NODE;
	    }
	    /**
	     * Checks that value is Map
	     * @param value
	     * @return {boolean}
	     */

	  }, {
	    key: "isMap",
	    value: function isMap(value) {
	      return Type.isObjectLike(value) && getTag(value) === '[object Map]';
	    }
	    /**
	     * Checks that value is Set
	     * @param value
	     * @return {boolean}
	     */

	  }, {
	    key: "isSet",
	    value: function isSet(value) {
	      return Type.isObjectLike(value) && getTag(value) === '[object Set]';
	    }
	    /**
	     * Checks that value is WeakMap
	     * @param value
	     * @return {boolean}
	     */

	  }, {
	    key: "isWeakMap",
	    value: function isWeakMap(value) {
	      return Type.isObjectLike(value) && getTag(value) === '[object WeakMap]';
	    }
	    /**
	     * Checks that value is WeakSet
	     * @param value
	     * @return {boolean}
	     */

	  }, {
	    key: "isWeakSet",
	    value: function isWeakSet(value) {
	      return Type.isObjectLike(value) && getTag(value) === '[object WeakSet]';
	    }
	    /**
	     * Checks that value is prototype
	     * @param value
	     * @return {boolean}
	     */

	  }, {
	    key: "isPrototype",
	    value: function isPrototype(value) {
	      return (typeof (value && value.constructor) === 'function' && value.constructor.prototype || Object.prototype) === value;
	    }
	    /**
	     * Checks that value is regexp
	     * @param value
	     * @return {boolean}
	     */

	  }, {
	    key: "isRegExp",
	    value: function isRegExp(value) {
	      return Type.isObjectLike(value) && getTag(value) === '[object RegExp]';
	    }
	    /**
	     * Checks that value is null
	     * @param value
	     * @return {boolean}
	     */

	  }, {
	    key: "isNull",
	    value: function isNull(value) {
	      return value === null;
	    }
	    /**
	     * Checks that value is undefined
	     * @param value
	     * @return {boolean}
	     */

	  }, {
	    key: "isUndefined",
	    value: function isUndefined(value) {
	      return typeof value === 'undefined';
	    }
	    /**
	     * Checks that value is ArrayBuffer
	     * @param value
	     * @return {boolean}
	     */

	  }, {
	    key: "isArrayBuffer",
	    value: function isArrayBuffer(value) {
	      return Type.isObjectLike(value) && getTag(value) === '[object ArrayBuffer]';
	    }
	    /**
	     * Checks that value is typed array
	     * @param value
	     * @return {boolean}
	     */

	  }, {
	    key: "isTypedArray",
	    value: function isTypedArray(value) {
	      var regExpTypedTag = /^\[object (?:Float(?:32|64)|(?:Int|Uint)(?:8|16|32)|Uint8Clamped)]$/;
	      return Type.isObjectLike(value) && regExpTypedTag.test(getTag(value));
	    }
	    /**
	     * Checks that value is Blob
	     * @param value
	     * @return {boolean}
	     */

	  }, {
	    key: "isBlob",
	    value: function isBlob(value) {
	      return Type.isObjectLike(value) && Type.isNumber(value.size) && Type.isString(value.type) && Type.isFunction(value.slice);
	    }
	    /**
	     * Checks that value is File
	     * @param value
	     * @return {boolean}
	     */

	  }, {
	    key: "isFile",
	    value: function isFile(value) {
	      return Type.isBlob(value) && Type.isString(value.name) && (Type.isNumber(value.lastModified) || Type.isObjectLike(value.lastModifiedDate));
	    }
	    /**
	     * Checks that value is FormData
	     * @param value
	     * @return {boolean}
	     */

	  }, {
	    key: "isFormData",
	    value: function isFormData(value) {
	      return value instanceof FormData;
	    }
	  }]);
	  return Type;
	}();

	/**
	 * @memberOf BX
	 */

	var Reflection = /*#__PURE__*/function () {
	  function Reflection() {
	    babelHelpers.classCallCheck(this, Reflection);
	  }

	  babelHelpers.createClass(Reflection, null, [{
	    key: "getClass",

	    /**
	     * Gets link to function by function name
	     * @param className
	     * @return {?Function}
	     */
	    value: function getClass(className) {
	      if (Type.isString(className) && !!className) {
	        var classFn = null;
	        var currentNamespace = window;
	        var namespaces = className.split('.');

	        for (var i = 0; i < namespaces.length; i += 1) {
	          var namespace = namespaces[i];

	          if (!currentNamespace[namespace]) {
	            return null;
	          }

	          currentNamespace = currentNamespace[namespace];
	          classFn = currentNamespace;
	        }

	        return classFn;
	      }

	      if (Type.isFunction(className)) {
	        return className;
	      }

	      return null;
	    }
	    /**
	     * Creates a namespace or returns a link to a previously created one
	     * @param {String} namespaceName
	     * @return {Object<string, any> | Function | null}
	     */

	  }, {
	    key: "namespace",
	    value: function namespace(namespaceName) {
	      var parts = namespaceName.split('.');
	      var parent = window.BX;

	      if (parts[0] === 'BX') {
	        parts = parts.slice(1);
	      }

	      for (var i = 0; i < parts.length; i += 1) {
	        if (Type.isUndefined(parent[parts[i]])) {
	          parent[parts[i]] = {};
	        }

	        parent = parent[parts[i]];
	      }

	      return parent;
	    }
	  }]);
	  return Reflection;
	}();

	var reEscape = /[&<>'"]/g;
	var reUnescape = /&(?:amp|#38|lt|#60|gt|#62|apos|#39|quot|#34);/g;
	var escapeEntities = {
	  '&': '&amp;',
	  '<': '&lt;',
	  '>': '&gt;',
	  "'": '&#39;',
	  '"': '&quot;'
	};
	var unescapeEntities = {
	  '&amp;': '&',
	  '&#38;': '&',
	  '&lt;': '<',
	  '&#60;': '<',
	  '&gt;': '>',
	  '&#62;': '>',
	  '&apos;': "'",
	  '&#39;': "'",
	  '&quot;': '"',
	  '&#34;': '"'
	};
	/**
	 * @memberOf BX
	 */

	var Text = /*#__PURE__*/function () {
	  function Text() {
	    babelHelpers.classCallCheck(this, Text);
	  }

	  babelHelpers.createClass(Text, null, [{
	    key: "encode",

	    /**
	     * Encodes all unsafe entities
	     * @param {string} value
	     * @return {string}
	     */
	    value: function encode(value) {
	      if (Type.isString(value)) {
	        return value.replace(reEscape, function (item) {
	          return escapeEntities[item];
	        });
	      }

	      return value;
	    }
	    /**
	     * Decodes all encoded entities
	     * @param {string} value
	     * @return {string}
	     */

	  }, {
	    key: "decode",
	    value: function decode(value) {
	      if (Type.isString(value)) {
	        return value.replace(reUnescape, function (item) {
	          return unescapeEntities[item];
	        });
	      }

	      return value;
	    }
	  }, {
	    key: "getRandom",
	    value: function getRandom() {
	      var length = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 8;
	      // eslint-disable-next-line
	      return babelHelpers.toConsumableArray(Array(length)).map(function () {
	        return (~~(Math.random() * 36)).toString(36);
	      }).join('');
	    }
	  }, {
	    key: "toNumber",
	    value: function toNumber(value) {
	      var parsedValue = Number.parseFloat(value);

	      if (Type.isNumber(parsedValue)) {
	        return parsedValue;
	      }

	      return 0;
	    }
	  }, {
	    key: "toInteger",
	    value: function toInteger(value) {
	      return Text.toNumber(Number.parseInt(value, 10));
	    }
	  }, {
	    key: "toBoolean",
	    value: function toBoolean(value) {
	      var trueValues = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
	      var transformedValue = Type.isString(value) ? value.toLowerCase() : value;
	      return ['true', 'y', '1', 1, true].concat(babelHelpers.toConsumableArray(trueValues)).includes(transformedValue);
	    }
	  }, {
	    key: "toCamelCase",
	    value: function toCamelCase(str) {
	      if (!Type.isStringFilled(str)) {
	        return str;
	      }

	      var regex = /[-_\s]+(.)?/g;

	      if (!regex.test(str)) {
	        return str.match(/^[A-Z]+$/) ? str.toLowerCase() : str[0].toLowerCase() + str.slice(1);
	      }

	      str = str.toLowerCase();
	      str = str.replace(regex, function (match, letter) {
	        return letter ? letter.toUpperCase() : '';
	      });
	      return str[0].toLowerCase() + str.substr(1);
	    }
	  }, {
	    key: "toPascalCase",
	    value: function toPascalCase(str) {
	      if (!Type.isStringFilled(str)) {
	        return str;
	      }

	      return this.capitalize(this.toCamelCase(str));
	    }
	  }, {
	    key: "toKebabCase",
	    value: function toKebabCase(str) {
	      if (!Type.isStringFilled(str)) {
	        return str;
	      }

	      var matches = str.match(/[A-Z]{2,}(?=[A-Z][a-z]+[0-9]*|\b)|[A-Z]?[a-z]+[0-9]*|[A-Z]|[0-9]+/g);

	      if (!matches) {
	        return str;
	      }

	      return matches.map(function (x) {
	        return x.toLowerCase();
	      }).join('-');
	    }
	  }, {
	    key: "capitalize",
	    value: function capitalize(str) {
	      if (!Type.isStringFilled(str)) {
	        return str;
	      }

	      return str[0].toUpperCase() + str.substr(1);
	    }
	  }]);
	  return Text;
	}();

	var aliases = {
	  mousewheel: ['DOMMouseScroll'],
	  bxchange: ['change', 'cut', 'paste', 'drop', 'keyup'],
	  animationend: ['animationend', 'oAnimationEnd', 'webkitAnimationEnd', 'MSAnimationEnd'],
	  transitionend: ['webkitTransitionEnd', 'otransitionend', 'oTransitionEnd', 'msTransitionEnd', 'transitionend'],
	  fullscreenchange: ['fullscreenchange', 'webkitfullscreenchange', 'mozfullscreenchange', 'MSFullscreenChange'],
	  fullscreenerror: ['fullscreenerror', 'webkitfullscreenerror', 'mozfullscreenerror', 'MSFullscreenError']
	};

	var Registry = /*#__PURE__*/function () {
	  function Registry() {
	    babelHelpers.classCallCheck(this, Registry);
	    babelHelpers.defineProperty(this, "registry", new WeakMap());
	  }

	  babelHelpers.createClass(Registry, [{
	    key: "set",
	    value: function set(target, event, listener) {
	      var events = this.get(target);

	      if (!Type.isSet(events[event])) {
	        events[event] = new Set();
	      }

	      events[event].add(listener);
	      this.registry.set(target, events);
	    }
	  }, {
	    key: "get",
	    value: function get(target) {
	      return this.registry.get(target) || {};
	    }
	  }, {
	    key: "has",
	    value: function has(target, event, listener) {
	      if (event && listener) {
	        return this.registry.has(target) && this.registry.get(target)[event].has(listener);
	      }

	      return this.registry.has(target);
	    }
	  }, {
	    key: "delete",
	    value: function _delete(target, event, listener) {
	      if (!Type.isDomNode(target)) {
	        return;
	      }

	      if (Type.isString(event) && Type.isFunction(listener)) {
	        var events = this.registry.get(target);

	        if (Type.isPlainObject(events) && Type.isSet(events[event])) {
	          events[event]["delete"](listener);
	        }

	        return;
	      }

	      if (Type.isString(event)) {
	        var _events = this.registry.get(target);

	        if (Type.isPlainObject(_events) && Type.isSet(_events[event])) {
	          _events[event] = new Set();
	        }

	        return;
	      }

	      this.registry["delete"](target);
	    }
	  }]);
	  return Registry;
	}();
	var registry = new Registry();

	function isOptionSupported(name) {
	  var isSupported = false;

	  try {
	    var options = Object.defineProperty({}, name, {
	      get: function get() {
	        isSupported = true;
	        return undefined;
	      }
	    });
	    window.addEventListener('test', null, options);
	  } // eslint-disable-next-line
	  catch (err) {}

	  return isSupported;
	}

	function fetchSupportedListenerOptions(options) {
	  if (!Type.isPlainObject(options)) {
	    return options;
	  }

	  return Object.keys(options).reduce(function (acc, name) {
	    if (isOptionSupported(name)) {
	      acc[name] = options[name];
	    }

	    return acc;
	  }, {});
	}

	function bind(target, eventName, handler, options) {
	  if (!Type.isObject(target) || !Type.isFunction(target.addEventListener)) {
	    return;
	  }

	  var listenerOptions = fetchSupportedListenerOptions(options);

	  if (eventName in aliases) {
	    aliases[eventName].forEach(function (key) {
	      target.addEventListener(key, handler, listenerOptions);
	      registry.set(target, eventName, handler);
	    });
	    return;
	  }

	  target.addEventListener(eventName, handler, listenerOptions);
	  registry.set(target, eventName, handler);
	}

	function unbind(target, eventName, handler, options) {
	  if (!Type.isObject(target) || !Type.isFunction(target.removeEventListener)) {
	    return;
	  }

	  var listenerOptions = fetchSupportedListenerOptions(options);

	  if (eventName in aliases) {
	    aliases[eventName].forEach(function (key) {
	      target.removeEventListener(key, handler, listenerOptions);
	      registry["delete"](target, key, handler);
	    });
	    return;
	  }

	  target.removeEventListener(eventName, handler, listenerOptions);
	  registry["delete"](target, eventName, handler);
	}

	function unbindAll(target, eventName) {
	  var events = registry.get(target);
	  Object.keys(events).forEach(function (currentEvent) {
	    events[currentEvent].forEach(function (handler) {
	      if (!Type.isString(eventName) || eventName === currentEvent) {
	        unbind(target, currentEvent, handler);
	      }
	    });
	  });
	}

	function bindOnce(target, eventName, handler, options) {
	  var once = function once() {
	    unbind(target, eventName, once, options);
	    handler.apply(void 0, arguments);
	  };

	  bind(target, eventName, once, options);
	}

	var debugState = true;
	function enableDebug() {
	  debugState = true;
	}
	function disableDebug() {
	  debugState = false;
	}
	function isDebugEnabled() {
	  return debugState;
	}
	function debug() {
	  if (isDebugEnabled() && Type.isObject(window.console)) {
	    if (Type.isFunction(window.console.log)) {
	      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
	        args[_key] = arguments[_key];
	      }

	      window.console.log('BX.debug: ', args.length > 0 ? args : args[0]);

	      if (args[0] instanceof Error && args[0].stack) {
	        window.console.log('BX.debug error stack trace', args[0].stack);
	      }
	    }

	    if (Type.isFunction(window.console.trace)) {
	      // eslint-disable-next-line
	      console.trace();
	    }
	  }
	}

	function fetchExtensionSettings(html) {
	  if (Type.isStringFilled(html)) {
	    var scripts = html.match(/<script type="extension\/settings" \b[^>]*>([\s\S]*?)<\/script>/g);

	    if (Type.isArrayFilled(scripts)) {
	      return scripts.map(function (script) {
	        var _script$match = script.match(/data-extension="(.[a-z0-9_.-]+)"/),
	            _script$match2 = babelHelpers.slicedToArray(_script$match, 2),
	            extension = _script$match2[1];

	        return {
	          extension: extension,
	          script: script
	        };
	      });
	    }
	  }

	  return [];
	}

	var Extension = /*#__PURE__*/function () {
	  function Extension(options) {
	    babelHelpers.classCallCheck(this, Extension);
	    this.config = options.config || {};
	    this.name = options.extension;
	    this.state = 'scheduled'; // eslint-disable-next-line

	    var result = BX.processHTML(options.html || '');
	    this.inlineScripts = result.SCRIPT.reduce(inlineScripts, []);
	    this.externalScripts = result.SCRIPT.reduce(externalScripts, []);
	    this.externalStyles = result.STYLE.reduce(externalStyles, []);
	    this.settingsScripts = fetchExtensionSettings(result.HTML);
	  }

	  babelHelpers.createClass(Extension, [{
	    key: "load",
	    value: function load() {
	      var _this = this;

	      if (this.state === 'error') {
	        this.loadPromise = this.loadPromise || Promise.resolve(this);
	        console.warn('Extension', this.name, 'not found');
	      }

	      if (!this.loadPromise && this.state) {
	        this.state = 'load';
	        this.settingsScripts.forEach(function (entry) {
	          var isLoaded = !!document.querySelector("script[data-extension=\"".concat(entry.extension, "\"]"));

	          if (!isLoaded) {
	            document.body.insertAdjacentHTML('beforeend', entry.script);
	          }
	        });
	        this.inlineScripts.forEach(BX.evalGlobal);
	        this.loadPromise = Promise.all([loadAll(this.externalScripts), loadAll(this.externalStyles)]).then(function () {
	          _this.state = 'loaded';

	          if (Type.isPlainObject(_this.config) && _this.config.namespace) {
	            return Reflection.getClass(_this.config.namespace);
	          }

	          return window;
	        });
	      }

	      return this.loadPromise;
	    }
	  }]);
	  return Extension;
	}();

	var initialized = {};
	var ajaxController = 'main.bitrix.main.controller.loadext.getextensions';

	function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { babelHelpers.defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
	function makeIterable(value) {
	  return Type.isArray(value) ? value : [value];
	}
	function isInitialized(extension) {
	  return extension in initialized;
	}
	function getInitialized(extension) {
	  return initialized[extension];
	}
	function isAllInitialized(extensions) {
	  return extensions.every(isInitialized);
	}
	function loadExtensions(extensions) {
	  return Promise.all(extensions.map(function (item) {
	    return item.load();
	  }));
	}
	function mergeExports(exports) {
	  return exports.reduce(function (acc, currentExports) {
	    if (Type.isObject(currentExports)) {
	      return _objectSpread({}, currentExports);
	    }

	    return currentExports;
	  }, {});
	}
	function inlineScripts(acc, item) {
	  if (item.isInternal) {
	    acc.push(item.JS);
	  }

	  return acc;
	}
	function externalScripts(acc, item) {
	  if (!item.isInternal) {
	    acc.push(item.JS);
	  }

	  return acc;
	}
	function externalStyles(acc, item) {
	  if (Type.isString(item) && item !== '') {
	    acc.push(item);
	  }

	  return acc;
	}
	function request(options) {
	  return new Promise(function (resolve) {
	    // eslint-disable-next-line
	    BX.ajax.runAction(ajaxController, {
	      data: options
	    }).then(resolve);
	  });
	}
	function prepareExtensions(response) {
	  if (response.status !== 'success') {
	    response.errors.map(console.warn);
	    return [];
	  }

	  return response.data.map(function (item) {
	    var initializedExtension = getInitialized(item.extension);

	    if (initializedExtension) {
	      return initializedExtension;
	    }

	    initialized[item.extension] = new Extension(item);
	    return initialized[item.extension];
	  });
	}
	function loadAll(items) {
	  var itemsList = makeIterable(items);

	  if (!itemsList.length) {
	    return Promise.resolve();
	  }

	  return new Promise(function (resolve) {
	    // eslint-disable-next-line
	    BX.load(itemsList, resolve);
	  });
	}

	/**
	 * Loads extensions asynchronously
	 * @param {string|Array<string>} extension
	 * @return {Promise<Array<Extension>>}
	 */
	function loadExtension(extension) {
	  var extensions = makeIterable(extension);
	  var isAllInitialized$$1 = isAllInitialized(extensions);

	  if (isAllInitialized$$1) {
	    var initializedExtensions = extensions.map(getInitialized);
	    return loadExtensions(initializedExtensions).then(mergeExports);
	  }

	  return request({
	    extension: extensions
	  }).then(prepareExtensions).then(loadExtensions).then(mergeExports);
	}

	var cloneableTags = ['[object Object]', '[object Array]', '[object RegExp]', '[object Arguments]', '[object Date]', '[object Error]', '[object Map]', '[object Set]', '[object ArrayBuffer]', '[object DataView]', '[object Float32Array]', '[object Float64Array]', '[object Int8Array]', '[object Int16Array]', '[object Int32Array]', '[object Uint8Array]', '[object Uint16Array]', '[object Uint32Array]', '[object Uint8ClampedArray]'];

	function isCloneable(value) {
	  var isCloneableValue = Type.isObjectLike(value) && cloneableTags.includes(getTag(value));
	  return isCloneableValue || Type.isDomNode(value);
	}

	function internalClone(value, map) {
	  if (map.has(value)) {
	    return map.get(value);
	  }

	  if (isCloneable(value)) {
	    if (Type.isArray(value)) {
	      var cloned = Array.from(value);
	      map.set(value, cloned);
	      value.forEach(function (item, index) {
	        cloned[index] = internalClone(item, map);
	      });
	      return map.get(value);
	    }

	    if (Type.isDomNode(value)) {
	      return value.cloneNode(true);
	    }

	    if (Type.isMap(value)) {
	      var _result = new Map();

	      map.set(value, _result);
	      value.forEach(function (item, key) {
	        _result.set(internalClone(key, map), internalClone(item, map));
	      });
	      return _result;
	    }

	    if (Type.isSet(value)) {
	      var _result2 = new Set();

	      map.set(value, _result2);
	      value.forEach(function (item) {
	        _result2.add(internalClone(item, map));
	      });
	      return _result2;
	    }

	    if (Type.isDate(value)) {
	      return new Date(value);
	    }

	    if (Type.isRegExp(value)) {
	      var regExpFlags = /\w*$/;
	      var flags = regExpFlags.exec(value);

	      var _result3 = new RegExp(value.source);

	      if (flags && Type.isArray(flags)) {
	        _result3 = new RegExp(value.source, flags[0]);
	      }

	      _result3.lastIndex = value.lastIndex;
	      return _result3;
	    }

	    var proto = Object.getPrototypeOf(value);
	    var result = Object.assign(Object.create(proto), value);
	    map.set(value, result);
	    Object.keys(value).forEach(function (key) {
	      result[key] = internalClone(value[key], map);
	    });
	    return result;
	  }

	  return value;
	}
	/**
	 * Clones any cloneable object
	 * @param value
	 * @return {*}
	 */

	function clone(value) {
	  return internalClone(value, new WeakMap());
	}

	function merge(current, target) {
	  return Object.entries(target).reduce(function (acc, _ref) {
	    var _ref2 = babelHelpers.slicedToArray(_ref, 2),
	        key = _ref2[0],
	        value = _ref2[1];

	    if (!Type.isDomNode(acc[key]) && Type.isObjectLike(acc[key]) && Type.isObjectLike(value)) {
	      acc[key] = merge(acc[key], value);
	      return acc;
	    }

	    acc[key] = value;
	    return acc;
	  }, current);
	}

	function createComparator(fields) {
	  var orders = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
	  return function (a, b) {
	    var field = fields[0];
	    var order = orders[0] || 'asc';

	    if (Type.isUndefined(field)) {
	      return 0;
	    }

	    var valueA = a[field];
	    var valueB = b[field];

	    if (Type.isString(valueA) && Type.isString(valueB)) {
	      valueA = valueA.toLowerCase();
	      valueB = valueB.toLowerCase();
	    }

	    if (valueA < valueB) {
	      return order === 'asc' ? -1 : 1;
	    }

	    if (valueA > valueB) {
	      return order === 'asc' ? 1 : -1;
	    }

	    return createComparator(fields.slice(1), orders.slice(1))(a, b);
	  };
	}

	/**
	 * @memberOf BX
	 */

	var Runtime = /*#__PURE__*/function () {
	  function Runtime() {
	    babelHelpers.classCallCheck(this, Runtime);
	  }

	  babelHelpers.createClass(Runtime, null, [{
	    key: "debounce",
	    value: function debounce(func) {
	      var wait = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
	      var context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
	      var timeoutId;
	      return function debounced() {
	        var _this = this;

	        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
	          args[_key] = arguments[_key];
	        }

	        if (Type.isNumber(timeoutId)) {
	          clearTimeout(timeoutId);
	        }

	        timeoutId = setTimeout(function () {
	          func.apply(context || _this, args);
	        }, wait);
	      };
	    }
	  }, {
	    key: "throttle",
	    value: function throttle(func) {
	      var wait = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
	      var context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
	      var timer = 0;
	      var invoke;
	      return function wrapper() {
	        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
	          args[_key2] = arguments[_key2];
	        }

	        invoke = true;

	        if (!timer) {
	          var q = function q() {
	            if (invoke) {
	              func.apply(context || this, args);
	              invoke = false;
	              timer = setTimeout(q, wait);
	            } else {
	              timer = null;
	            }
	          };

	          q();
	        }
	      };
	    }
	  }, {
	    key: "html",
	    value: function html(node, _html) {
	      var params = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

	      if (Type.isNil(_html) && Type.isDomNode(node)) {
	        return node.innerHTML;
	      } // eslint-disable-next-line


	      var parsedHtml = BX.processHTML(_html);
	      var externalCss = parsedHtml.STYLE.reduce(externalStyles, []);
	      var externalJs = parsedHtml.SCRIPT.reduce(externalScripts, []);
	      var inlineJs = parsedHtml.SCRIPT.reduce(inlineScripts, []);

	      if (Type.isDomNode(node)) {
	        if (params.htmlFirst || !externalJs.length && !externalCss.length) {
	          if (params.useAdjacentHTML) {
	            node.insertAdjacentHTML('beforeend', parsedHtml.HTML);
	          } else {
	            node.innerHTML = parsedHtml.HTML;
	          }
	        }
	      }

	      return Promise.all([loadAll(externalJs), loadAll(externalCss)]).then(function () {
	        if (Type.isDomNode(node) && (externalJs.length > 0 || externalCss.length > 0)) {
	          if (params.useAdjacentHTML) {
	            node.insertAdjacentHTML('beforeend', parsedHtml.HTML);
	          } else {
	            node.innerHTML = parsedHtml.HTML;
	          }
	        } // eslint-disable-next-line


	        inlineJs.forEach(function (script) {
	          return BX.evalGlobal(script);
	        });

	        if (Type.isFunction(params.callback)) {
	          params.callback();
	        }
	      });
	    }
	    /**
	     * Merges objects or arrays
	     * @param targets
	     * @return {any}
	     */

	  }, {
	    key: "merge",
	    value: function merge$$1() {
	      for (var _len3 = arguments.length, targets = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
	        targets[_key3] = arguments[_key3];
	      }

	      if (Type.isArray(targets[0])) {
	        targets.unshift([]);
	      } else if (Type.isObject(targets[0])) {
	        targets.unshift({});
	      }

	      return targets.reduce(function (acc, item) {
	        return merge(acc, item);
	      }, targets[0]);
	    }
	  }, {
	    key: "orderBy",
	    value: function orderBy(collection) {
	      var fields = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
	      var orders = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
	      var comparator = createComparator(fields, orders);
	      return Object.values(collection).sort(comparator);
	    }
	  }, {
	    key: "destroy",
	    value: function destroy(target) {
	      var errorMessage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'Object is destroyed';

	      if (Type.isObject(target)) {
	        var onPropertyAccess = function onPropertyAccess() {
	          throw new Error(errorMessage);
	        };

	        var ownProperties = Object.keys(target);

	        var prototypeProperties = function () {
	          var targetPrototype = Object.getPrototypeOf(target);

	          if (Type.isObject(targetPrototype)) {
	            return Object.getOwnPropertyNames(targetPrototype);
	          }

	          return [];
	        }();

	        var uniquePropertiesList = babelHelpers.toConsumableArray(new Set([].concat(babelHelpers.toConsumableArray(ownProperties), babelHelpers.toConsumableArray(prototypeProperties))));
	        uniquePropertiesList.filter(function (name) {
	          var descriptor = Object.getOwnPropertyDescriptor(target, name);
	          return !/__(.+)__/.test(name) && (!Type.isObject(descriptor) || descriptor.configurable === true);
	        }).forEach(function (name) {
	          Object.defineProperty(target, name, {
	            get: onPropertyAccess,
	            set: onPropertyAccess,
	            configurable: false
	          });
	        });
	        Object.setPrototypeOf(target, null);
	      }
	    }
	  }]);
	  return Runtime;
	}();

	babelHelpers.defineProperty(Runtime, "debug", debug);
	babelHelpers.defineProperty(Runtime, "loadExtension", loadExtension);
	babelHelpers.defineProperty(Runtime, "clone", clone);

	var _isError = Symbol["for"]('BX.BaseError.isError');
	/**
	 * @memberOf BX
	 */


	var BaseError = /*#__PURE__*/function () {
	  function BaseError(message, code, customData) {
	    babelHelpers.classCallCheck(this, BaseError);
	    this[_isError] = true;
	    this.message = '';
	    this.code = null;
	    this.customData = null;
	    this.setMessage(message);
	    this.setCode(code);
	    this.setCustomData(customData);
	  }
	  /**
	   * Returns a brief description of the error
	   * @returns {string}
	   */


	  babelHelpers.createClass(BaseError, [{
	    key: "getMessage",
	    value: function getMessage() {
	      return this.message;
	    }
	    /**
	     * Sets a message of the error
	     * @param {string} message
	     * @returns {this}
	     */

	  }, {
	    key: "setMessage",
	    value: function setMessage(message) {
	      if (Type.isString(message)) {
	        this.message = message;
	      }

	      return this;
	    }
	    /**
	     * Returns a code of the error
	     * @returns {?string}
	     */

	  }, {
	    key: "getCode",
	    value: function getCode() {
	      return this.code;
	    }
	    /**
	     * Sets a code of the error
	     * @param {string} code
	     * @returns {this}
	     */

	  }, {
	    key: "setCode",
	    value: function setCode(code) {
	      if (Type.isStringFilled(code) || code === null) {
	        this.code = code;
	      }

	      return this;
	    }
	    /**
	     * Returns custom data of the error
	     * @returns {null|*}
	     */

	  }, {
	    key: "getCustomData",
	    value: function getCustomData() {
	      return this.customData;
	    }
	    /**
	     * Sets custom data of the error
	     * @returns {this}
	     */

	  }, {
	    key: "setCustomData",
	    value: function setCustomData(customData) {
	      if (!Type.isUndefined(customData)) {
	        this.customData = customData;
	      }

	      return this;
	    }
	  }, {
	    key: "toString",
	    value: function toString() {
	      var code = this.getCode();
	      var message = this.getMessage();

	      if (!Type.isStringFilled(code) && !Type.isStringFilled(message)) {
	        return '';
	      } else if (!Type.isStringFilled(code)) {
	        return "Error: ".concat(message);
	      } else if (!Type.isStringFilled(message)) {
	        return code;
	      } else {
	        return "".concat(code, ": ").concat(message);
	      }
	    }
	    /**
	     * Returns true if the object is an instance of BaseError
	     * @param error
	     * @returns {boolean}
	     */

	  }], [{
	    key: "isError",
	    value: function isError(error) {
	      return Type.isObject(error) && error[_isError] === true;
	    }
	  }]);
	  return BaseError;
	}();

	/**
	 * Implements base event object interface
	 */

	var BaseEvent = /*#__PURE__*/function () {
	  function BaseEvent() {
	    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
	      data: {}
	    };
	    babelHelpers.classCallCheck(this, BaseEvent);
	    this.type = '';
	    this.data = null;
	    this.target = null;
	    this.compatData = null;
	    this.defaultPrevented = false;
	    this.immediatePropagationStopped = false;
	    this.errors = [];
	    this.setData(options.data);
	    this.setCompatData(options.compatData);
	  }

	  babelHelpers.createClass(BaseEvent, [{
	    key: "getType",

	    /**
	     * Returns the name of the event
	     * @returns {string}
	     */
	    value: function getType() {
	      return this.type;
	    }
	    /**
	     *
	     * @param {string} type
	     */

	  }, {
	    key: "setType",
	    value: function setType(type) {
	      if (Type.isStringFilled(type)) {
	        this.type = type;
	      }

	      return this;
	    }
	    /**
	     * Returns an event data
	     */

	  }, {
	    key: "getData",
	    value: function getData() {
	      return this.data;
	    }
	    /**
	     * Sets an event data
	     * @param data
	     */

	  }, {
	    key: "setData",
	    value: function setData(data) {
	      if (!Type.isUndefined(data)) {
	        this.data = data;
	      }

	      return this;
	    }
	    /**
	     * Returns arguments for BX.addCustomEvent handlers (deprecated).
	     * @returns {array | null}
	     */

	  }, {
	    key: "getCompatData",
	    value: function getCompatData() {
	      return this.compatData;
	    }
	    /**
	     * Sets arguments for BX.addCustomEvent handlers (deprecated)
	     * @param data
	     */

	  }, {
	    key: "setCompatData",
	    value: function setCompatData(data) {
	      if (Type.isArrayLike(data)) {
	        this.compatData = data;
	      }

	      return this;
	    }
	    /**
	     * Sets a event target
	     * @param target
	     */

	  }, {
	    key: "setTarget",
	    value: function setTarget(target) {
	      this.target = target;
	      return this;
	    }
	    /**
	     * Returns a event target
	     */

	  }, {
	    key: "getTarget",
	    value: function getTarget() {
	      return this.target;
	    }
	    /**
	     * Returns an array of event errors
	     * @returns {[]}
	     */

	  }, {
	    key: "getErrors",
	    value: function getErrors() {
	      return this.errors;
	    }
	    /**
	     * Adds an error of the event.
	     * Event listeners can prevent emitter's default action and set the reason of this behavior.
	     * @param error
	     */

	  }, {
	    key: "setError",
	    value: function setError(error) {
	      if (BaseError.isError(error)) {
	        this.errors.push(error);
	      }
	    }
	    /**
	     * Prevents default action
	     */

	  }, {
	    key: "preventDefault",
	    value: function preventDefault() {
	      this.defaultPrevented = true;
	    }
	    /**
	     * Checks that is default action prevented
	     * @return {boolean}
	     */

	  }, {
	    key: "isDefaultPrevented",
	    value: function isDefaultPrevented() {
	      return this.defaultPrevented;
	    }
	    /**
	     * Stops event immediate propagation
	     */

	  }, {
	    key: "stopImmediatePropagation",
	    value: function stopImmediatePropagation() {
	      this.immediatePropagationStopped = true;
	    }
	    /**
	     * Checks that is immediate propagation stopped
	     * @return {boolean}
	     */

	  }, {
	    key: "isImmediatePropagationStopped",
	    value: function isImmediatePropagationStopped() {
	      return this.immediatePropagationStopped;
	    }
	  }], [{
	    key: "create",
	    value: function create(options) {
	      return new this(options);
	    }
	  }]);
	  return BaseEvent;
	}();

	var EventStore = /*#__PURE__*/function () {
	  function EventStore() {
	    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	    babelHelpers.classCallCheck(this, EventStore);
	    this.defaultMaxListeners = Type.isNumber(options.defaultMaxListeners) ? options.defaultMaxListeners : 10;
	    this.eventStore = new WeakMap();
	  }

	  babelHelpers.createClass(EventStore, [{
	    key: "add",
	    value: function add(target) {
	      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	      var record = this.getRecordScheme();

	      if (Type.isNumber(options.maxListeners)) {
	        record.maxListeners = options.maxListeners;
	      }

	      this.eventStore.set(target, record);
	      return record;
	    }
	  }, {
	    key: "get",
	    value: function get(target) {
	      return this.eventStore.get(target);
	    }
	  }, {
	    key: "getOrAdd",
	    value: function getOrAdd(target) {
	      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	      return this.get(target) || this.add(target, options);
	    }
	  }, {
	    key: "delete",
	    value: function _delete(context) {
	      this.eventStore["delete"](context);
	    }
	  }, {
	    key: "getRecordScheme",
	    value: function getRecordScheme() {
	      return {
	        eventsMap: new Map(),
	        onceMap: new Map(),
	        maxListeners: this.getDefaultMaxListeners(),
	        eventsMaxListeners: new Map()
	      };
	    }
	  }, {
	    key: "getDefaultMaxListeners",
	    value: function getDefaultMaxListeners() {
	      return this.defaultMaxListeners;
	    }
	  }]);
	  return EventStore;
	}();

	var WarningStore = /*#__PURE__*/function () {
	  function WarningStore() {
	    babelHelpers.classCallCheck(this, WarningStore);
	    this.warnings = new Map();
	    this.printDelayed = Runtime.debounce(this.print.bind(this), 500);
	  }

	  babelHelpers.createClass(WarningStore, [{
	    key: "add",
	    value: function add(target, eventName, listeners) {
	      var contextWarnings = this.warnings.get(target);

	      if (!contextWarnings) {
	        contextWarnings = Object.create(null);
	        this.warnings.set(target, contextWarnings);
	      }

	      if (!contextWarnings[eventName]) {
	        contextWarnings[eventName] = {};
	      }

	      contextWarnings[eventName].size = listeners.size;

	      if (!Type.isArray(contextWarnings[eventName].errors)) {
	        contextWarnings[eventName].errors = [];
	      }

	      contextWarnings[eventName].errors.push(new Error());
	    }
	  }, {
	    key: "print",
	    value: function print() {
	      this.warnings.forEach(function (warnings) {
	        for (var eventName in warnings) {
	          console.groupCollapsed('Possible BX.Event.EventEmitter memory leak detected. ' + warnings[eventName].size + ' "' + eventName + '" listeners added. ' + 'Use emitter.setMaxListeners() to increase limit.');
	          console.dir(warnings[eventName].errors);
	          console.groupEnd();
	        }
	      });
	      this.clear();
	    }
	  }, {
	    key: "clear",
	    value: function clear() {
	      this.warnings.clear();
	    }
	  }, {
	    key: "printDelayed",
	    value: function printDelayed() {}
	  }]);
	  return WarningStore;
	}();

	var eventStore = new EventStore({
	  defaultMaxListeners: 10
	});
	var warningStore = new WarningStore();
	var aliasStore = new Map();
	var globalTarget = {
	  GLOBAL_TARGET: 'GLOBAL_TARGET' // this key only for debugging purposes

	};
	eventStore.add(globalTarget, {
	  maxListeners: 25
	});
	var isEmitterProperty = Symbol["for"]('BX.Event.EventEmitter.isEmitter');
	var namespaceProperty = Symbol('namespaceProperty');
	var targetProperty = Symbol('targetProperty');

	var EventEmitter = /*#__PURE__*/function () {
	  /** @private */
	  function EventEmitter() {
	    babelHelpers.classCallCheck(this, EventEmitter);
	    this[targetProperty] = null;
	    this[namespaceProperty] = null;
	    this[isEmitterProperty] = true;
	    var target = this;

	    if (Object.getPrototypeOf(this) === EventEmitter.prototype && arguments.length > 0) //new EventEmitter(obj) case
	      {
	        if (!Type.isObject(arguments.length <= 0 ? undefined : arguments[0])) {
	          throw new TypeError("The \"target\" argument must be an object.");
	        }

	        target = arguments.length <= 0 ? undefined : arguments[0];
	        this.setEventNamespace(arguments.length <= 1 ? undefined : arguments[1]);
	      }

	    this[targetProperty] = target;
	  }
	  /**
	   * Makes a target observable
	   * @param {object} target
	   * @param {string} namespace
	   */


	  babelHelpers.createClass(EventEmitter, [{
	    key: "setEventNamespace",
	    value: function setEventNamespace(namespace) {
	      if (Type.isStringFilled(namespace)) {
	        this[namespaceProperty] = namespace;
	      }
	    }
	  }, {
	    key: "getEventNamespace",
	    value: function getEventNamespace() {
	      return this[namespaceProperty];
	    }
	    /**
	     * Subscribes listener on specified global event
	     * @param {object} target
	     * @param {string} eventName
	     * @param {Function<BaseEvent>} listener
	     * @param {object} options
	     */

	  }, {
	    key: "subscribe",

	    /**
	     * Subscribes a listener on a specified event
	     * @param {string} eventName
	     * @param {Function<BaseEvent>} listener
	     * @return {this}
	     */
	    value: function subscribe(eventName, listener) {
	      EventEmitter.subscribe(this, eventName, listener);
	      return this;
	    }
	    /**
	     *
	     * @param {object} options
	     * @param {object} [aliases]
	     * @param {boolean} [compatMode=false]
	     */

	  }, {
	    key: "subscribeFromOptions",
	    value: function subscribeFromOptions(options, aliases, compatMode) {
	      var _this = this;

	      if (!Type.isPlainObject(options)) {
	        return;
	      }

	      aliases = Type.isPlainObject(aliases) ? EventEmitter.normalizeAliases(aliases) : {};
	      Object.keys(options).forEach(function (eventName) {
	        var listener = EventEmitter.normalizeListener(options[eventName]);
	        eventName = EventEmitter.normalizeEventName(eventName);

	        if (aliases[eventName]) {
	          var actualName = aliases[eventName].eventName;
	          EventEmitter.subscribe(_this, actualName, listener, {
	            compatMode: compatMode !== false
	          });
	        } else {
	          EventEmitter.subscribe(_this, eventName, listener, {
	            compatMode: compatMode === true
	          });
	        }
	      });
	    }
	    /**
	     * Subscribes a listener that is called at
	     * most once for a specified event.
	     * @param {object} target
	     * @param {string} eventName
	     * @param {Function<BaseEvent>} listener
	     */

	  }, {
	    key: "subscribeOnce",

	    /**
	     * Subscribes a listener that is called at most once for a specified event.
	     * @param {string} eventName
	     * @param {Function<BaseEvent>} listener
	     * @return {this}
	     */
	    value: function subscribeOnce(eventName, listener) {
	      EventEmitter.subscribeOnce(this, eventName, listener);
	      return this;
	    }
	    /**
	     * Unsubscribes an event listener
	     * @param {object} target
	     * @param {string} eventName
	     * @param {Function<BaseEvent>} listener
	     * @param options
	     */

	  }, {
	    key: "unsubscribe",

	    /**
	     * Unsubscribes an event listener
	     * @param {string} eventName
	     * @param {Function<BaseEvent>} listener
	     * @return {this}
	     */
	    value: function unsubscribe(eventName, listener) {
	      EventEmitter.unsubscribe(this, eventName, listener);
	      return this;
	    }
	    /**
	     * Unsubscribes all event listeners
	     * @param {object} target
	     * @param {string} eventName
	     * @param options
	     */

	  }, {
	    key: "unsubscribeAll",

	    /**
	     * Unsubscribes all event listeners
	     * @param {string} [eventName]
	     */
	    value: function unsubscribeAll(eventName) {
	      EventEmitter.unsubscribeAll(this, eventName);
	    }
	    /**
	     *
	     * @param {object} target
	     * @param {string} eventName
	     * @param {BaseEvent | any} event
	     * @param {object} options
	     * @returns {Array}
	     */

	  }, {
	    key: "emit",

	    /**
	     * Emits specified event with specified event object
	     * @param {string} eventName
	     * @param {BaseEvent | any} event
	     * @return {this}
	     */
	    value: function emit(eventName, event) {
	      if (this.getEventNamespace() === null) {
	        console.warn('The instance of BX.Event.EventEmitter is supposed to have an event namespace. ' + 'Use emitter.setEventNamespace() to make events more unique.');
	      }

	      EventEmitter.emit(this, eventName, event);
	      return this;
	    }
	    /**
	     * Emits global event and returns a promise that is resolved when
	     * all promise returned from event handlers are resolved,
	     * or rejected when at least one of the returned promise is rejected.
	     * Importantly. You can return any value from synchronous handlers, not just promise
	     * @param {object} target
	     * @param {string} eventName
	     * @param {BaseEvent | any} event
	     * @return {Promise<Array>}
	     */

	  }, {
	    key: "emitAsync",

	    /**
	     * Emits event and returns a promise that is resolved when
	     * all promise returned from event handlers are resolved,
	     * or rejected when at least one of the returned promise is rejected.
	     * Importantly. You can return any value from synchronous handlers, not just promise
	     * @param {string} eventName
	     * @param {BaseEvent|any} event
	     * @return {Promise<Array>}
	     */
	    value: function emitAsync(eventName, event) {
	      if (this.getEventNamespace() === null) {
	        console.warn('The instance of BX.Event.EventEmitter is supposed to have an event namespace. ' + 'Use emitter.setEventNamespace() to make events more unique.');
	      }

	      return EventEmitter.emitAsync(this, eventName, event);
	    }
	    /**
	     * @private
	     * @param {object} target
	     * @param {string} eventName
	     * @param {BaseEvent|any} event
	     * @returns {BaseEvent}
	     */

	  }, {
	    key: "setMaxListeners",

	    /**
	     * Sets max events listeners count
	     * this.setMaxListeners(10) - sets the default value for all events
	     * this.setMaxListeners("onClose", 10) sets the value for onClose event
	     * @return {this}
	     * @param args
	     */
	    value: function setMaxListeners() {
	      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
	        args[_key] = arguments[_key];
	      }

	      EventEmitter.setMaxListeners.apply(EventEmitter, [this].concat(args));
	      return this;
	    }
	    /**
	     * Returns max event listeners count
	     * @param {object} target
	     * @param {string} [eventName]
	     * @returns {number}
	     */

	  }, {
	    key: "getMaxListeners",

	    /**
	     * Returns max event listeners count
	     * @param {string} [eventName]
	     * @returns {number}
	     */
	    value: function getMaxListeners(eventName) {
	      return EventEmitter.getMaxListeners(this, eventName);
	    }
	    /**
	     * Adds or subtracts max listeners count
	     * Event.EventEmitter.addMaxListeners() - adds one max listener for all events of global target
	     * Event.EventEmitter.addMaxListeners(3) - adds three max listeners for all events of global target
	     * Event.EventEmitter.addMaxListeners(-1) - subtracts one max listener for all events of global target
	     * Event.EventEmitter.addMaxListeners('onClose') - adds one max listener for onClose event of global target
	     * Event.EventEmitter.addMaxListeners('onClose', 2) - adds two max listeners for onClose event of global target
	     * Event.EventEmitter.addMaxListeners('onClose', -1) - subtracts one max listener for onClose event of global target
	     *
	     * Event.EventEmitter.addMaxListeners(obj) - adds one max listener for all events of 'obj' target
	     * Event.EventEmitter.addMaxListeners(obj, 3) - adds three max listeners for all events of 'obj' target
	     * Event.EventEmitter.addMaxListeners(obj, -1) - subtracts one max listener for all events of 'obj' target
	     * Event.EventEmitter.addMaxListeners(obj, 'onClose') - adds one max listener for onClose event of 'obj' target
	     * Event.EventEmitter.addMaxListeners(obj, 'onClose', 2) - adds two max listeners for onClose event of 'obj' target
	     * Event.EventEmitter.addMaxListeners(obj, 'onClose', -1) - subtracts one max listener for onClose event of 'obj' target
	     * @param args
	     * @returns {number}
	     */

	  }, {
	    key: "incrementMaxListeners",

	    /**
	     * Increases max listeners count
	     * this.incrementMaxListeners() - adds one max listener for all events
	     * this.incrementMaxListeners(3) - adds three max listeners for all events
	     * this.incrementMaxListeners('onClose') - adds one max listener for onClose event
	     * this.incrementMaxListeners('onClose', 2) - adds two max listeners for onClose event
	     */
	    value: function incrementMaxListeners() {
	      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
	        args[_key2] = arguments[_key2];
	      }

	      return EventEmitter.incrementMaxListeners.apply(EventEmitter, [this].concat(args));
	    }
	    /**
	     * Decreases max listeners count
	     *
	     * Event.EventEmitter.decrementMaxListeners() - subtracts one max listener for all events of global target
	     * Event.EventEmitter.decrementMaxListeners(3) - subtracts three max listeners for all events of global target
	     * Event.EventEmitter.decrementMaxListeners('onClose') - subtracts one max listener for onClose event of global target
	     * Event.EventEmitter.decrementMaxListeners('onClose', 2) - subtracts two max listeners for onClose event of global target
	     *
	     * Event.EventEmitter.decrementMaxListeners(obj) - subtracts one max listener for all events of 'obj' target
	     * Event.EventEmitter.decrementMaxListeners(obj, 3) - subtracts three max listeners for all events of 'obj' target
	     * Event.EventEmitter.decrementMaxListeners(obj, 'onClose') - subtracts one max listener for onClose event of 'obj' target
	     * Event.EventEmitter.decrementMaxListeners(obj, 'onClose', 2) - subtracts two max listeners for onClose event of 'obj' target
	     */

	  }, {
	    key: "decrementMaxListeners",

	    /**
	     * Increases max listeners count
	     * this.decrementMaxListeners() - subtracts one max listener for all events
	     * this.decrementMaxListeners(3) - subtracts three max listeners for all events
	     * this.decrementMaxListeners('onClose') - subtracts one max listener for onClose event
	     * this.decrementMaxListeners('onClose', 2) - subtracts two max listeners for onClose event
	     */
	    value: function decrementMaxListeners() {
	      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
	        args[_key3] = arguments[_key3];
	      }

	      return EventEmitter.decrementMaxListeners.apply(EventEmitter, [this].concat(args));
	    }
	    /**
	     * @private
	     * @param {Array} args
	     * @returns Array
	     */

	  }, {
	    key: "getListeners",

	    /**
	     * Gets listeners list for specified event
	     * @param {string} eventName
	     */
	    value: function getListeners(eventName) {
	      return EventEmitter.getListeners(this, eventName);
	    }
	    /**
	     * Returns a full event name with namespace
	     * @param {string} eventName
	     * @returns {string}
	     */

	  }, {
	    key: "getFullEventName",
	    value: function getFullEventName(eventName) {
	      if (!Type.isStringFilled(eventName)) {
	        throw new TypeError("The \"eventName\" argument must be a string.");
	      }

	      return EventEmitter.makeFullEventName(this.getEventNamespace(), eventName);
	    }
	    /**
	     * Registers aliases (old event names for BX.onCustomEvent)
	     * @param aliases
	     */

	  }], [{
	    key: "makeObservable",
	    value: function makeObservable(target, namespace) {
	      if (!Type.isObject(target)) {
	        throw new TypeError('The "target" argument must be an object.');
	      }

	      if (!Type.isStringFilled(namespace)) {
	        throw new TypeError('The "namespace" must be an non-empty string.');
	      }

	      if (EventEmitter.isEventEmitter(target)) {
	        throw new TypeError('The "target" is an event emitter already.');
	      }

	      var targetProto = Object.getPrototypeOf(target);
	      var emitter = new EventEmitter();
	      emitter.setEventNamespace(namespace);
	      Object.setPrototypeOf(emitter, targetProto);
	      Object.setPrototypeOf(target, emitter);
	      Object.getOwnPropertyNames(EventEmitter.prototype).forEach(function (method) {
	        if (['constructor'].includes(method)) {
	          return;
	        }

	        emitter[method] = function () {
	          for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
	            args[_key4] = arguments[_key4];
	          }

	          return EventEmitter.prototype[method].apply(target, args);
	        };
	      });
	    }
	  }, {
	    key: "subscribe",
	    value: function subscribe(target, eventName, listener, options) {
	      if (Type.isString(target)) {
	        options = listener;
	        listener = eventName;
	        eventName = target;
	        target = this.GLOBAL_TARGET;
	      }

	      if (!Type.isObject(target)) {
	        throw new TypeError("The \"target\" argument must be an object.");
	      }

	      eventName = this.normalizeEventName(eventName);

	      if (!Type.isStringFilled(eventName)) {
	        throw new TypeError("The \"eventName\" argument must be a string.");
	      }

	      listener = this.normalizeListener(listener);
	      options = Type.isPlainObject(options) ? options : {};
	      var fullEventName = this.resolveEventName(eventName, target, options.useGlobalNaming === true);

	      var _eventStore$getOrAdd = eventStore.getOrAdd(target),
	          eventsMap = _eventStore$getOrAdd.eventsMap,
	          onceMap = _eventStore$getOrAdd.onceMap;

	      var onceListeners = onceMap.get(fullEventName);
	      var listeners = eventsMap.get(fullEventName);

	      if (listeners && listeners.has(listener) || onceListeners && onceListeners.has(listener)) {
	        console.error("You cannot subscribe the same \"".concat(fullEventName, "\" event listener twice."));
	      } else {
	        if (listeners) {
	          listeners.set(listener, {
	            listener: listener,
	            options: options,
	            sort: this.getNextSequenceValue()
	          });
	        } else {
	          listeners = new Map([[listener, {
	            listener: listener,
	            options: options,
	            sort: this.getNextSequenceValue()
	          }]]);
	          eventsMap.set(fullEventName, listeners);
	        }
	      }

	      var maxListeners = this.getMaxListeners(target, eventName);

	      if (listeners.size > maxListeners) {
	        warningStore.add(target, fullEventName, listeners);
	        warningStore.printDelayed();
	      }
	    }
	  }, {
	    key: "subscribeOnce",
	    value: function subscribeOnce(target, eventName, listener) {
	      var _this2 = this;

	      if (Type.isString(target)) {
	        listener = eventName;
	        eventName = target;
	        target = this.GLOBAL_TARGET;
	      }

	      if (!Type.isObject(target)) {
	        throw new TypeError("The \"target\" argument must be an object.");
	      }

	      eventName = this.normalizeEventName(eventName);

	      if (!Type.isStringFilled(eventName)) {
	        throw new TypeError("The \"eventName\" argument must be a string.");
	      }

	      listener = this.normalizeListener(listener);
	      var fullEventName = this.resolveEventName(eventName, target);

	      var _eventStore$getOrAdd2 = eventStore.getOrAdd(target),
	          eventsMap = _eventStore$getOrAdd2.eventsMap,
	          onceMap = _eventStore$getOrAdd2.onceMap;

	      var listeners = eventsMap.get(fullEventName);
	      var onceListeners = onceMap.get(fullEventName);

	      if (listeners && listeners.has(listener) || onceListeners && onceListeners.has(listener)) {
	        console.error("You cannot subscribe the same \"".concat(fullEventName, "\" event listener twice."));
	      } else {
	        var once = function once() {
	          _this2.unsubscribe(target, eventName, once);

	          onceListeners["delete"](listener);
	          listener.apply(void 0, arguments);
	        };

	        if (onceListeners) {
	          onceListeners.set(listener, once);
	        } else {
	          onceListeners = new Map([[listener, once]]);
	          onceMap.set(fullEventName, onceListeners);
	        }

	        this.subscribe(target, eventName, once);
	      }
	    }
	  }, {
	    key: "unsubscribe",
	    value: function unsubscribe(target, eventName, listener, options) {
	      if (Type.isString(target)) {
	        listener = eventName;
	        eventName = target;
	        target = this.GLOBAL_TARGET;
	      }

	      eventName = this.normalizeEventName(eventName);

	      if (!Type.isStringFilled(eventName)) {
	        throw new TypeError("The \"eventName\" argument must be a string.");
	      }

	      listener = this.normalizeListener(listener);
	      options = Type.isPlainObject(options) ? options : {};
	      var fullEventName = this.resolveEventName(eventName, target, options.useGlobalNaming === true);
	      var targetInfo = eventStore.get(target);
	      var listeners = targetInfo && targetInfo.eventsMap.get(fullEventName);
	      var onceListeners = targetInfo && targetInfo.onceMap.get(fullEventName);

	      if (listeners) {
	        listeners["delete"](listener);
	      }

	      if (onceListeners) {
	        var once = onceListeners.get(listener);

	        if (once) {
	          onceListeners["delete"](listener);
	          listeners["delete"](once);
	        }
	      }
	    }
	  }, {
	    key: "unsubscribeAll",
	    value: function unsubscribeAll(target, eventName, options) {
	      if (Type.isString(target)) {
	        eventName = target;
	        target = this.GLOBAL_TARGET;
	      }

	      if (Type.isStringFilled(eventName)) {
	        var targetInfo = eventStore.get(target);

	        if (targetInfo) {
	          options = Type.isPlainObject(options) ? options : {};
	          var fullEventName = this.resolveEventName(eventName, target, options.useGlobalNaming === true);
	          targetInfo.eventsMap["delete"](fullEventName);
	          targetInfo.onceMap["delete"](fullEventName);
	        }
	      } else if (Type.isNil(eventName)) {
	        if (target === this.GLOBAL_TARGET) {
	          console.error('You cannot unsubscribe all global listeners.');
	        } else {
	          eventStore["delete"](target);
	        }
	      }
	    }
	  }, {
	    key: "emit",
	    value: function emit(target, eventName, event, options) {
	      if (Type.isString(target)) {
	        options = event;
	        event = eventName;
	        eventName = target;
	        target = this.GLOBAL_TARGET;
	      }

	      if (!Type.isObject(target)) {
	        throw new TypeError("The \"target\" argument must be an object.");
	      }

	      eventName = this.normalizeEventName(eventName);

	      if (!Type.isStringFilled(eventName)) {
	        throw new TypeError("The \"eventName\" argument must be a string.");
	      }

	      options = Type.isPlainObject(options) ? options : {};
	      var fullEventName = this.resolveEventName(eventName, target, options.useGlobalNaming === true);
	      var globalEvents = eventStore.get(this.GLOBAL_TARGET);
	      var globalListeners = globalEvents && globalEvents.eventsMap.get(fullEventName) || new Map();
	      var targetListeners = new Set();

	      if (target !== this.GLOBAL_TARGET) {
	        var targetEvents = eventStore.get(target);
	        targetListeners = targetEvents && targetEvents.eventsMap.get(fullEventName) || new Map();
	      }

	      var listeners = [].concat(babelHelpers.toConsumableArray(globalListeners.values()), babelHelpers.toConsumableArray(targetListeners.values()));
	      listeners.sort(function (a, b) {
	        return a.sort - b.sort;
	      });
	      var preparedEvent = this.prepareEvent(target, fullEventName, event);
	      var result = [];

	      for (var i = 0; i < listeners.length; i++) {
	        if (preparedEvent.isImmediatePropagationStopped()) {
	          break;
	        }

	        var _listeners$i = listeners[i],
	            listener = _listeners$i.listener,
	            listenerOptions = _listeners$i.options; //A previous listener could remove a current listener.

	        if (globalListeners.has(listener) || targetListeners.has(listener)) {
	          var listenerResult = void 0;

	          if (listenerOptions.compatMode) {
	            var params = [];
	            var compatData = preparedEvent.getCompatData();

	            if (compatData !== null) {
	              params = options.cloneData === true ? Runtime.clone(compatData) : compatData;
	            } else {
	              params = [preparedEvent];
	            }

	            var context = Type.isUndefined(options.thisArg) ? target : options.thisArg;
	            listenerResult = listener.apply(context, params);
	          } else {
	            listenerResult = Type.isUndefined(options.thisArg) ? listener(preparedEvent) : listener.call(options.thisArg, preparedEvent);
	          }

	          result.push(listenerResult);
	        }
	      }

	      return result;
	    }
	  }, {
	    key: "emitAsync",
	    value: function emitAsync(target, eventName, event) {
	      if (Type.isString(target)) {
	        event = eventName;
	        eventName = target;
	        target = this.GLOBAL_TARGET;
	      }

	      return Promise.all(this.emit(target, eventName, event));
	    }
	  }, {
	    key: "prepareEvent",
	    value: function prepareEvent(target, eventName, event) {
	      var preparedEvent = event;

	      if (!(event instanceof BaseEvent)) {
	        preparedEvent = new BaseEvent();
	        preparedEvent.setData(event);
	      }

	      preparedEvent.setTarget(this.isEventEmitter(target) ? target[targetProperty] : target);
	      preparedEvent.setType(eventName);
	      return preparedEvent;
	    }
	    /**
	     * @private
	     * @returns {number}
	     */

	  }, {
	    key: "getNextSequenceValue",
	    value: function getNextSequenceValue() {
	      return this.sequenceValue++;
	    }
	    /**
	     * Sets max global events listeners count
	     * Event.EventEmitter.setMaxListeners(10) - sets the default value for all events (global target)
	     * Event.EventEmitter.setMaxListeners("onClose", 10) - sets the value for onClose event (global target)
	     * Event.EventEmitter.setMaxListeners(obj, 10) - sets the default value for all events (obj target)
	     * Event.EventEmitter.setMaxListeners(obj, "onClose", 10); - sets the value for onClose event (obj target)
	     * @return {void}
	     * @param args
	     */

	  }, {
	    key: "setMaxListeners",
	    value: function setMaxListeners() {
	      var target = this.GLOBAL_TARGET;
	      var eventName = null;
	      var count = undefined;

	      for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
	        args[_key5] = arguments[_key5];
	      }

	      if (args.length === 1) {
	        count = args[0];
	      } else if (args.length === 2) {
	        if (Type.isString(args[0])) {
	          eventName = args[0];
	          count = args[1];
	        } else {
	          target = args[0];
	          count = args[1];
	        }
	      } else if (args.length >= 3) {
	        target = args[0];
	        eventName = args[1];
	        count = args[2];
	      }

	      if (!Type.isObject(target)) {
	        throw new TypeError("The \"target\" argument must be an object.");
	      }

	      if (eventName !== null && !Type.isStringFilled(eventName)) {
	        throw new TypeError("The \"eventName\" argument must be a string.");
	      }

	      if (!Type.isNumber(count) || count < 0) {
	        throw new TypeError("The value of \"count\" is out of range. It must be a non-negative number. Received ".concat(count, "."));
	      }

	      var targetInfo = eventStore.getOrAdd(target);

	      if (Type.isStringFilled(eventName)) {
	        var fullEventName = this.resolveEventName(eventName, target);
	        targetInfo.eventsMaxListeners.set(fullEventName, count);
	      } else {
	        targetInfo.maxListeners = count;
	      }
	    }
	  }, {
	    key: "getMaxListeners",
	    value: function getMaxListeners(target, eventName) {
	      if (Type.isString(target)) {
	        eventName = target;
	        target = this.GLOBAL_TARGET;
	      } else if (Type.isNil(target)) {
	        target = this.GLOBAL_TARGET;
	      }

	      if (!Type.isObject(target)) {
	        throw new TypeError("The \"target\" argument must be an object.");
	      }

	      var targetInfo = eventStore.get(target);

	      if (targetInfo) {
	        var maxListeners = targetInfo.maxListeners;

	        if (Type.isStringFilled(eventName)) {
	          var fullEventName = this.resolveEventName(eventName, target);
	          maxListeners = targetInfo.eventsMaxListeners.get(fullEventName) || maxListeners;
	        }

	        return maxListeners;
	      }

	      return this.DEFAULT_MAX_LISTENERS;
	    }
	  }, {
	    key: "addMaxListeners",
	    value: function addMaxListeners() {
	      var _this$destructMaxList = this.destructMaxListenersArgs.apply(this, arguments),
	          _this$destructMaxList2 = babelHelpers.slicedToArray(_this$destructMaxList, 3),
	          target = _this$destructMaxList2[0],
	          eventName = _this$destructMaxList2[1],
	          increment = _this$destructMaxList2[2];

	      var maxListeners = Math.max(this.getMaxListeners(target, eventName) + increment, 0);

	      if (Type.isStringFilled(eventName)) {
	        EventEmitter.setMaxListeners(target, eventName, maxListeners);
	      } else {
	        EventEmitter.setMaxListeners(target, maxListeners);
	      }

	      return maxListeners;
	    }
	    /**
	     * Increases max listeners count
	     *
	     * Event.EventEmitter.incrementMaxListeners() - adds one max listener for all events of global target
	     * Event.EventEmitter.incrementMaxListeners(3) - adds three max listeners for all events of global target
	     * Event.EventEmitter.incrementMaxListeners('onClose') - adds one max listener for onClose event of global target
	     * Event.EventEmitter.incrementMaxListeners('onClose', 2) - adds two max listeners for onClose event of global target
	     *
	     * Event.EventEmitter.incrementMaxListeners(obj) - adds one max listener for all events of 'obj' target
	     * Event.EventEmitter.incrementMaxListeners(obj, 3) - adds three max listeners for all events of 'obj' target
	     * Event.EventEmitter.incrementMaxListeners(obj, 'onClose') - adds one max listener for onClose event of 'obj' target
	     * Event.EventEmitter.incrementMaxListeners(obj, 'onClose', 2) - adds two max listeners for onClose event of 'obj' target
	     */

	  }, {
	    key: "incrementMaxListeners",
	    value: function incrementMaxListeners() {
	      var _this$destructMaxList3 = this.destructMaxListenersArgs.apply(this, arguments),
	          _this$destructMaxList4 = babelHelpers.slicedToArray(_this$destructMaxList3, 3),
	          target = _this$destructMaxList4[0],
	          eventName = _this$destructMaxList4[1],
	          increment = _this$destructMaxList4[2];

	      return this.addMaxListeners(target, eventName, Math.abs(increment));
	    }
	  }, {
	    key: "decrementMaxListeners",
	    value: function decrementMaxListeners() {
	      var _this$destructMaxList5 = this.destructMaxListenersArgs.apply(this, arguments),
	          _this$destructMaxList6 = babelHelpers.slicedToArray(_this$destructMaxList5, 3),
	          target = _this$destructMaxList6[0],
	          eventName = _this$destructMaxList6[1],
	          increment = _this$destructMaxList6[2];

	      return this.addMaxListeners(target, eventName, -Math.abs(increment));
	    }
	  }, {
	    key: "destructMaxListenersArgs",
	    value: function destructMaxListenersArgs() {
	      var eventName = null;
	      var increment = 1;
	      var target = this.GLOBAL_TARGET;

	      for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
	        args[_key6] = arguments[_key6];
	      }

	      if (args.length === 1) {
	        if (Type.isNumber(args[0])) {
	          increment = args[0];
	        } else if (Type.isString(args[0])) {
	          eventName = args[0];
	        } else {
	          target = args[0];
	        }
	      } else if (args.length === 2) {
	        if (Type.isString(args[0])) {
	          eventName = args[0];
	          increment = args[1];
	        } else if (Type.isString(args[1])) {
	          target = args[0];
	          eventName = args[1];
	        } else {
	          target = args[0];
	          increment = args[1];
	        }
	      } else if (args.length >= 3) {
	        target = args[0];
	        eventName = args[1];
	        increment = args[2];
	      }

	      if (!Type.isObject(target)) {
	        throw new TypeError("The \"target\" argument must be an object.");
	      }

	      if (eventName !== null && !Type.isStringFilled(eventName)) {
	        throw new TypeError("The \"eventName\" argument must be a string.");
	      }

	      if (!Type.isNumber(increment)) {
	        throw new TypeError("The value of \"increment\" must be a number.");
	      }

	      return [target, eventName, increment];
	    }
	    /**
	     * Gets listeners list for a specified event
	     * @param {object} target
	     * @param {string} eventName
	     */

	  }, {
	    key: "getListeners",
	    value: function getListeners(target, eventName) {
	      if (Type.isString(target)) {
	        eventName = target;
	        target = this.GLOBAL_TARGET;
	      }

	      if (!Type.isObject(target)) {
	        throw new TypeError("The \"target\" argument must be an object.");
	      }

	      eventName = this.normalizeEventName(eventName);

	      if (!Type.isStringFilled(eventName)) {
	        throw new TypeError("The \"eventName\" argument must be a string.");
	      }

	      var targetInfo = eventStore.get(target);

	      if (!targetInfo) {
	        return new Map();
	      }

	      var fullEventName = this.resolveEventName(eventName, target);
	      return targetInfo.eventsMap.get(fullEventName) || new Map();
	    }
	  }, {
	    key: "registerAliases",
	    value: function registerAliases(aliases) {
	      aliases = this.normalizeAliases(aliases);
	      Object.keys(aliases).forEach(function (alias) {
	        aliasStore.set(alias, {
	          eventName: aliases[alias].eventName,
	          namespace: aliases[alias].namespace
	        });
	      });
	      EventEmitter.mergeEventAliases(aliases);
	    }
	    /**
	     * @private
	     * @param aliases
	     */

	  }, {
	    key: "normalizeAliases",
	    value: function normalizeAliases(aliases) {
	      if (!Type.isPlainObject(aliases)) {
	        throw new TypeError("The \"aliases\" argument must be an object.");
	      }

	      var result = Object.create(null);

	      for (var _alias in aliases) {
	        if (!Type.isStringFilled(_alias)) {
	          throw new TypeError("The alias must be an non-empty string.");
	        }

	        var options = aliases[_alias];

	        if (!options || !Type.isStringFilled(options.eventName) || !Type.isStringFilled(options.namespace)) {
	          throw new TypeError("The alias options must set the \"eventName\" and the \"namespace\".");
	        }

	        _alias = this.normalizeEventName(_alias);
	        result[_alias] = {
	          eventName: options.eventName,
	          namespace: options.namespace
	        };
	      }

	      return result;
	    }
	    /**
	     * @private
	     */

	  }, {
	    key: "mergeEventAliases",
	    value: function mergeEventAliases(aliases) {
	      var _this3 = this;

	      var globalEvents = eventStore.get(this.GLOBAL_TARGET);

	      if (!globalEvents) {
	        return;
	      }

	      Object.keys(aliases).forEach(function (alias) {
	        var options = aliases[alias];
	        alias = _this3.normalizeEventName(alias);

	        var fullEventName = _this3.makeFullEventName(options.namespace, options.eventName);

	        var aliasListeners = globalEvents.eventsMap.get(alias);

	        if (aliasListeners) {
	          var listeners = globalEvents.eventsMap.get(fullEventName) || new Map();
	          globalEvents.eventsMap.set(fullEventName, new Map([].concat(babelHelpers.toConsumableArray(listeners), babelHelpers.toConsumableArray(aliasListeners))));
	          globalEvents.eventsMap["delete"](alias);
	        }

	        var aliasOnceListeners = globalEvents.onceMap.get(alias);

	        if (aliasOnceListeners) {
	          var onceListeners = globalEvents.onceMap.get(fullEventName) || new Map();
	          globalEvents.onceMap.set(fullEventName, new Map([].concat(babelHelpers.toConsumableArray(onceListeners), babelHelpers.toConsumableArray(aliasOnceListeners))));
	          globalEvents.onceMap["delete"](alias);
	        }

	        var aliasMaxListeners = globalEvents.eventsMaxListeners.get(alias);

	        if (aliasMaxListeners) {
	          var eventMaxListeners = globalEvents.eventsMaxListeners.get(fullEventName) || 0;
	          globalEvents.eventsMaxListeners.set(fullEventName, Math.max(eventMaxListeners, aliasMaxListeners));
	          globalEvents.eventsMaxListeners["delete"](alias);
	        }
	      });
	    }
	    /**
	     * Returns true if the target is an instance of Event.EventEmitter
	     * @param {object} target
	     * @returns {boolean}
	     */

	  }, {
	    key: "isEventEmitter",
	    value: function isEventEmitter(target) {
	      return Type.isObject(target) && target[isEmitterProperty] === true;
	    }
	    /**
	     * @private
	     * @param {string} eventName
	     * @returns {string}
	     */

	  }, {
	    key: "normalizeEventName",
	    value: function normalizeEventName(eventName) {
	      if (!Type.isStringFilled(eventName)) {
	        return '';
	      }

	      return eventName.toLowerCase();
	    }
	    /**
	     * @private
	     */

	  }, {
	    key: "normalizeListener",
	    value: function normalizeListener(listener) {
	      if (Type.isString(listener)) {
	        listener = Reflection.getClass(listener);
	      }

	      if (!Type.isFunction(listener)) {
	        throw new TypeError("The \"listener\" argument must be of type Function. Received type ".concat(babelHelpers["typeof"](listener), "."));
	      }

	      return listener;
	    }
	    /**
	     * @private
	     * @param eventName
	     * @param target
	     * @param useGlobalNaming
	     * @returns {string}
	     */

	  }, {
	    key: "resolveEventName",
	    value: function resolveEventName(eventName, target) {
	      var useGlobalNaming = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
	      eventName = this.normalizeEventName(eventName);

	      if (!Type.isStringFilled(eventName)) {
	        return '';
	      }

	      if (this.isEventEmitter(target) && useGlobalNaming !== true) {
	        if (target.getEventNamespace() !== null && eventName.includes('.')) {
	          console.warn("Possible the wrong event name \"".concat(eventName, "\"."));
	        }

	        eventName = target.getFullEventName(eventName);
	      } else if (aliasStore.has(eventName)) {
	        var _aliasStore$get = aliasStore.get(eventName),
	            namespace = _aliasStore$get.namespace,
	            actualEventName = _aliasStore$get.eventName;

	        eventName = this.makeFullEventName(namespace, actualEventName);
	      }

	      return eventName;
	    }
	    /**
	     * @private
	     * @param {string} namespace
	     * @param {string} eventName
	     * @returns {string}
	     */

	  }, {
	    key: "makeFullEventName",
	    value: function makeFullEventName(namespace, eventName) {
	      var fullName = Type.isStringFilled(namespace) ? "".concat(namespace, ":").concat(eventName) : eventName;
	      return Type.isStringFilled(fullName) ? fullName.toLowerCase() : '';
	    }
	  }]);
	  return EventEmitter;
	}();

	babelHelpers.defineProperty(EventEmitter, "GLOBAL_TARGET", globalTarget);
	babelHelpers.defineProperty(EventEmitter, "DEFAULT_MAX_LISTENERS", eventStore.getDefaultMaxListeners());
	babelHelpers.defineProperty(EventEmitter, "sequenceValue", 1);

	var stack = [];
	/**
	 * For compatibility only
	 * @type {boolean}
	 */
	// eslint-disable-next-line

	exports.isReady = false;
	function ready(handler) {
	  switch (document.readyState) {
	    case 'loading':
	      stack.push(handler);
	      break;

	    case 'interactive':
	    case 'complete':
	      if (Type.isFunction(handler)) {
	        handler();
	      }

	      exports.isReady = true;
	      break;

	    default:
	      break;
	  }
	}
	document.addEventListener('readystatechange', function () {
	  if (!exports.isReady) {
	    stack.forEach(ready);
	    stack = [];
	  }
	});

	/**
	 * @memberOf BX
	 */

	var Event = function Event() {
	  babelHelpers.classCallCheck(this, Event);
	};

	babelHelpers.defineProperty(Event, "bind", bind);
	babelHelpers.defineProperty(Event, "bindOnce", bindOnce);
	babelHelpers.defineProperty(Event, "unbind", unbind);
	babelHelpers.defineProperty(Event, "unbindAll", unbindAll);
	babelHelpers.defineProperty(Event, "ready", ready);
	babelHelpers.defineProperty(Event, "EventEmitter", EventEmitter);
	babelHelpers.defineProperty(Event, "BaseEvent", BaseEvent);

	function encodeAttributeValue(value) {
	  if (Type.isPlainObject(value) || Type.isArray(value)) {
	    return JSON.stringify(value);
	  }

	  return Text.encode(Text.decode(value));
	}

	function decodeAttributeValue(value) {
	  if (Type.isString(value)) {
	    var decodedValue = Text.decode(value);
	    var result;

	    try {
	      result = JSON.parse(decodedValue);
	    } catch (e) {
	      result = decodedValue;
	    }

	    if (result === decodedValue) {
	      if (/^[\d.]+[.]?\d+$/.test(result)) {
	        return Number(result);
	      }
	    }

	    if (result === 'true' || result === 'false') {
	      return Boolean(result);
	    }

	    return result;
	  }

	  return value;
	}

	function getPageScroll() {
	  var _document = document,
	      documentElement = _document.documentElement,
	      body = _document.body;
	  var scrollTop = Math.max(window.pageYOffset || 0, documentElement ? documentElement.scrollTop : 0, body ? body.scrollTop : 0);
	  var scrollLeft = Math.max(window.pageXOffset || 0, documentElement ? documentElement.scrollLeft : 0, body ? body.scrollLeft : 0);
	  return {
	    scrollTop: scrollTop,
	    scrollLeft: scrollLeft
	  };
	}

	/**
	 * @memberOf BX
	 */

	var Dom = /*#__PURE__*/function () {
	  function Dom() {
	    babelHelpers.classCallCheck(this, Dom);
	  }

	  babelHelpers.createClass(Dom, null, [{
	    key: "replace",

	    /**
	     * Replaces old html element to new html element
	     * @param oldElement
	     * @param newElement
	     */
	    value: function replace(oldElement, newElement) {
	      if (Type.isDomNode(oldElement) && Type.isDomNode(newElement)) {
	        if (Type.isDomNode(oldElement.parentNode)) {
	          oldElement.parentNode.replaceChild(newElement, oldElement);
	        }
	      }
	    }
	    /**
	     * Removes element
	     * @param element
	     */

	  }, {
	    key: "remove",
	    value: function remove(element) {
	      if (Type.isDomNode(element) && Type.isDomNode(element.parentNode)) {
	        element.parentNode.removeChild(element);
	      }
	    }
	    /**
	     * Cleans element
	     * @param element
	     */

	  }, {
	    key: "clean",
	    value: function clean(element) {
	      if (Type.isDomNode(element)) {
	        while (element.childNodes.length > 0) {
	          element.removeChild(element.firstChild);
	        }

	        return;
	      }

	      if (Type.isString(element)) {
	        Dom.clean(document.getElementById(element));
	      }
	    }
	    /**
	     * Inserts element before target element
	     * @param current
	     * @param target
	     */

	  }, {
	    key: "insertBefore",
	    value: function insertBefore(current, target) {
	      if (Type.isDomNode(current) && Type.isDomNode(target)) {
	        if (Type.isDomNode(target.parentNode)) {
	          target.parentNode.insertBefore(current, target);
	        }
	      }
	    }
	    /**
	     * Inserts element after target element
	     * @param current
	     * @param target
	     */

	  }, {
	    key: "insertAfter",
	    value: function insertAfter(current, target) {
	      if (Type.isDomNode(current) && Type.isDomNode(target)) {
	        if (Type.isDomNode(target.parentNode)) {
	          var parent = target.parentNode;

	          if (Type.isDomNode(target.nextSibling)) {
	            parent.insertBefore(current, target.nextSibling);
	            return;
	          }

	          parent.appendChild(current);
	        }
	      }
	    }
	    /**
	     * Appends element to target element
	     * @param current
	     * @param target
	     */

	  }, {
	    key: "append",
	    value: function append(current, target) {
	      if (Type.isDomNode(current) && Type.isDomNode(target)) {
	        target.appendChild(current);
	      }
	    }
	    /**
	     * Prepends element to target element
	     * @param current
	     * @param target
	     */

	  }, {
	    key: "prepend",
	    value: function prepend(current, target) {
	      if (Type.isDomNode(current) && Type.isDomNode(target)) {
	        if (Type.isDomNode(target.firstChild)) {
	          target.insertBefore(current, target.firstChild);
	          return;
	        }

	        Dom.append(current, target);
	      }
	    }
	    /**
	     * Checks that element contains class name or class names
	     * @param element
	     * @param className
	     * @return {Boolean}
	     */

	  }, {
	    key: "hasClass",
	    value: function hasClass(element, className) {
	      if (Type.isElementNode(element)) {
	        if (Type.isString(className)) {
	          var preparedClassName = className.trim();

	          if (preparedClassName.length > 0) {
	            if (preparedClassName.includes(' ')) {
	              return preparedClassName.split(' ').every(function (name) {
	                return Dom.hasClass(element, name);
	              });
	            }

	            if ('classList' in element) {
	              return element.classList.contains(preparedClassName);
	            }

	            if (Type.isObject(element.className) && Type.isString(element.className.baseVal)) {
	              return element.getAttribute('class').split(' ').some(function (name) {
	                return name === preparedClassName;
	              });
	            }
	          }
	        }

	        if (Type.isArray(className) && className.length > 0) {
	          return className.every(function (name) {
	            return Dom.hasClass(element, name);
	          });
	        }
	      }

	      return false;
	    }
	    /**
	     * Adds class name
	     * @param element
	     * @param className
	     */

	  }, {
	    key: "addClass",
	    value: function addClass(element, className) {
	      if (Type.isElementNode(element)) {
	        if (Type.isString(className)) {
	          var preparedClassName = className.trim();

	          if (preparedClassName.length > 0) {
	            if (preparedClassName.includes(' ')) {
	              Dom.addClass(element, preparedClassName.split(' '));
	              return;
	            }

	            if ('classList' in element) {
	              element.classList.add(preparedClassName);
	              return;
	            }

	            if (Type.isObject(element.className) && Type.isString(element.className.baseVal)) {
	              if (element.className.baseVal === '') {
	                element.className.baseVal = preparedClassName;
	                return;
	              }

	              var names = element.className.baseVal.split(' ');

	              if (!names.includes(preparedClassName)) {
	                names.push(preparedClassName);
	                element.className.baseVal = names.join(' ').trim();
	                return;
	              }
	            }

	            return;
	          }
	        }

	        if (Type.isArray(className)) {
	          className.forEach(function (name) {
	            return Dom.addClass(element, name);
	          });
	        }
	      }
	    }
	    /**
	     * Removes class name
	     * @param element
	     * @param className
	     */

	  }, {
	    key: "removeClass",
	    value: function removeClass(element, className) {
	      if (Type.isElementNode(element)) {
	        if (Type.isString(className)) {
	          var preparedClassName = className.trim();

	          if (preparedClassName.length > 0) {
	            if (preparedClassName.includes(' ')) {
	              Dom.removeClass(element, preparedClassName.split(' '));
	              return;
	            }

	            if ('classList' in element) {
	              element.classList.remove(preparedClassName);
	              return;
	            }

	            if (Type.isObject(element.className) && Type.isString(element.className.baseVal)) {
	              var names = element.className.baseVal.split(' ').filter(function (name) {
	                return name !== preparedClassName;
	              });
	              element.className.baseVal = names.join(' ');
	              return;
	            }
	          }
	        }

	        if (Type.isArray(className)) {
	          className.forEach(function (name) {
	            return Dom.removeClass(element, name);
	          });
	        }
	      }
	    }
	    /**
	     * Toggles class name
	     * @param element
	     * @param className
	     */

	  }, {
	    key: "toggleClass",
	    value: function toggleClass(element, className) {
	      if (Type.isElementNode(element)) {
	        if (Type.isString(className)) {
	          var preparedClassName = className.trim();

	          if (preparedClassName.length > 0) {
	            if (preparedClassName.includes(' ')) {
	              Dom.toggleClass(element, preparedClassName.split(' '));
	              return;
	            }

	            element.classList.toggle(preparedClassName);
	            return;
	          }
	        }

	        if (Type.isArray(className)) {
	          className.forEach(function (name) {
	            return Dom.toggleClass(element, name);
	          });
	        }
	      }
	    }
	    /**
	     * Styles element
	     */

	  }, {
	    key: "style",
	    value: function style(element, prop, value) {
	      if (Type.isElementNode(element)) {
	        if (Type.isNull(prop)) {
	          element.removeAttribute('style');
	          return element;
	        }

	        if (Type.isPlainObject(prop)) {
	          Object.entries(prop).forEach(function (item) {
	            var _item = babelHelpers.slicedToArray(item, 2),
	                currentKey = _item[0],
	                currentValue = _item[1];

	            Dom.style(element, currentKey, currentValue);
	          });
	          return element;
	        }

	        if (Type.isString(prop)) {
	          if (Type.isUndefined(value) && element.nodeType !== Node.DOCUMENT_NODE) {
	            var computedStyle = getComputedStyle(element);

	            if (prop in computedStyle) {
	              return computedStyle[prop];
	            }

	            return computedStyle.getPropertyValue(prop);
	          }

	          if (Type.isNull(value) || value === '' || value === 'null') {
	            if (String(prop).startsWith('--')) {
	              // eslint-disable-next-line
	              element.style.removeProperty(prop);
	              return element;
	            } // eslint-disable-next-line


	            element.style[prop] = '';
	            return element;
	          }

	          if (Type.isString(value) || Type.isNumber(value)) {
	            if (String(prop).startsWith('--')) {
	              // eslint-disable-next-line
	              element.style.setProperty(prop, value);
	              return element;
	            } // eslint-disable-next-line


	            element.style[prop] = value;
	            return element;
	          }
	        }
	      }

	      return null;
	    }
	    /**
	     * Adjusts element
	     * @param target
	     * @param data
	     * @return {*}
	     */

	  }, {
	    key: "adjust",
	    value: function adjust(target) {
	      var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

	      if (!target.nodeType) {
	        return null;
	      }

	      var element = target;

	      if (target.nodeType === Node.DOCUMENT_NODE) {
	        element = target.body;
	      }

	      if (Type.isPlainObject(data)) {
	        if (Type.isPlainObject(data.attrs)) {
	          Object.keys(data.attrs).forEach(function (key) {
	            if (key === 'class' || key.toLowerCase() === 'classname') {
	              element.className = data.attrs[key];
	              return;
	            } // eslint-disable-next-line


	            if (data.attrs[key] == '') {
	              element.removeAttribute(key);
	              return;
	            }

	            element.setAttribute(key, data.attrs[key]);
	          });
	        }

	        if (Type.isPlainObject(data.style)) {
	          Dom.style(element, data.style);
	        }

	        if (Type.isPlainObject(data.props)) {
	          Object.keys(data.props).forEach(function (key) {
	            element[key] = data.props[key];
	          });
	        }

	        if (Type.isPlainObject(data.events)) {
	          Object.keys(data.events).forEach(function (key) {
	            Event.bind(element, key, data.events[key]);
	          });
	        }

	        if (Type.isPlainObject(data.dataset)) {
	          Object.keys(data.dataset).forEach(function (key) {
	            element.dataset[key] = data.dataset[key];
	          });
	        }

	        if (Type.isString(data.children)) {
	          data.children = [data.children];
	        }

	        if (Type.isArray(data.children) && data.children.length > 0) {
	          data.children.forEach(function (item) {
	            if (Type.isDomNode(item)) {
	              Dom.append(item, element);
	            }

	            if (Type.isString(item)) {
	              element.insertAdjacentHTML('beforeend', item);
	            }
	          });
	          return element;
	        }

	        if ('text' in data && !Type.isNil(data.text)) {
	          element.innerText = data.text;
	          return element;
	        }

	        if ('html' in data && !Type.isNil(data.html)) {
	          element.innerHTML = data.html;
	        }
	      }

	      return element;
	    }
	    /**
	     * Creates element
	     * @param tag
	     * @param data
	     * @param context
	     * @return {HTMLElement|HTMLBodyElement}
	     */

	  }, {
	    key: "create",
	    value: function create(tag) {
	      var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	      var context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : document;
	      var tagName = tag;
	      var options = data;

	      if (Type.isObjectLike(tag)) {
	        options = tag;
	        tagName = tag.tag;
	      }

	      return Dom.adjust(context.createElement(tagName), options);
	    }
	    /**
	     * Shows element
	     * @param element
	     */

	  }, {
	    key: "show",
	    value: function show(element) {
	      if (Type.isDomNode(element)) {
	        // eslint-disable-next-line
	        element.hidden = false;
	      }
	    }
	    /**
	     * Hides element
	     * @param element
	     */

	  }, {
	    key: "hide",
	    value: function hide(element) {
	      if (Type.isDomNode(element)) {
	        // eslint-disable-next-line
	        element.hidden = true;
	      }
	    }
	    /**
	     * Checks that element is shown
	     * @param element
	     * @return {*|boolean}
	     */

	  }, {
	    key: "isShown",
	    value: function isShown(element) {
	      return Type.isDomNode(element) && !element.hidden && element.style.getPropertyValue('display') !== 'none';
	    }
	    /**
	     * Toggles element visibility
	     * @param element
	     */

	  }, {
	    key: "toggle",
	    value: function toggle(element) {
	      if (Type.isDomNode(element)) {
	        if (Dom.isShown(element)) {
	          Dom.hide(element);
	        } else {
	          Dom.show(element);
	        }
	      }
	    }
	    /**
	     * Gets element position relative page
	     * @param {HTMLElement} element
	     * @return {DOMRect}
	     */

	  }, {
	    key: "getPosition",
	    value: function getPosition(element) {
	      if (Type.isDomNode(element)) {
	        var elementRect = element.getBoundingClientRect();

	        var _getPageScroll = getPageScroll(),
	            scrollLeft = _getPageScroll.scrollLeft,
	            scrollTop = _getPageScroll.scrollTop;

	        return new DOMRect(elementRect.left + scrollLeft, elementRect.top + scrollTop, elementRect.width, elementRect.height);
	      }

	      return new DOMRect();
	    }
	    /**
	     * Gets element position relative specified element position
	     * @param {HTMLElement} element
	     * @param {HTMLElement} relationElement
	     * @return {DOMRect}
	     */

	  }, {
	    key: "getRelativePosition",
	    value: function getRelativePosition(element, relationElement) {
	      if (Type.isDomNode(element) && Type.isDomNode(relationElement)) {
	        var elementPosition = Dom.getPosition(element);
	        var relationElementPosition = Dom.getPosition(relationElement);
	        return new DOMRect(elementPosition.left - relationElementPosition.left, elementPosition.top - relationElementPosition.top, elementPosition.width, elementPosition.height);
	      }

	      return new DOMRect();
	    }
	  }, {
	    key: "attr",
	    value: function attr(element, _attr, value) {
	      if (Type.isElementNode(element)) {
	        if (Type.isString(_attr)) {
	          if (!Type.isNil(value)) {
	            return element.setAttribute(_attr, encodeAttributeValue(value));
	          }

	          if (Type.isNull(value)) {
	            return element.removeAttribute(_attr);
	          }

	          return decodeAttributeValue(element.getAttribute(_attr));
	        }

	        if (Type.isPlainObject(_attr)) {
	          return Object.entries(_attr).forEach(function (_ref) {
	            var _ref2 = babelHelpers.slicedToArray(_ref, 2),
	                attrKey = _ref2[0],
	                attrValue = _ref2[1];

	            Dom.attr(element, attrKey, attrValue);
	          });
	        }
	      }

	      return null;
	    }
	  }]);
	  return Dom;
	}();

	var UA = navigator.userAgent.toLowerCase();
	/**
	 * @memberOf BX
	 */

	var Browser = /*#__PURE__*/function () {
	  function Browser() {
	    babelHelpers.classCallCheck(this, Browser);
	  }

	  babelHelpers.createClass(Browser, null, [{
	    key: "isOpera",
	    value: function isOpera() {
	      return UA.includes('opera');
	    }
	  }, {
	    key: "isIE",
	    value: function isIE() {
	      return 'attachEvent' in document && !Browser.isOpera();
	    }
	  }, {
	    key: "isIE6",
	    value: function isIE6() {
	      return UA.includes('msie 6');
	    }
	  }, {
	    key: "isIE7",
	    value: function isIE7() {
	      return UA.includes('msie 7');
	    }
	  }, {
	    key: "isIE8",
	    value: function isIE8() {
	      return UA.includes('msie 8');
	    }
	  }, {
	    key: "isIE9",
	    value: function isIE9() {
	      return 'documentMode' in document && document.documentMode >= 9;
	    }
	  }, {
	    key: "isIE10",
	    value: function isIE10() {
	      return 'documentMode' in document && document.documentMode >= 10;
	    }
	  }, {
	    key: "isSafari",
	    value: function isSafari() {
	      return UA.includes('safari') && !UA.includes('chrome');
	    }
	  }, {
	    key: "isFirefox",
	    value: function isFirefox() {
	      return UA.includes('firefox');
	    }
	  }, {
	    key: "isChrome",
	    value: function isChrome() {
	      return UA.includes('chrome');
	    }
	  }, {
	    key: "detectIEVersion",
	    value: function detectIEVersion() {
	      if (Browser.isOpera() || Browser.isSafari() || Browser.isFirefox() || Browser.isChrome()) {
	        return -1;
	      }

	      var rv = -1;

	      if (!!window.MSStream && !window.ActiveXObject && 'ActiveXObject' in window) {
	        rv = 11;
	      } else if (Browser.isIE10()) {
	        rv = 10;
	      } else if (Browser.isIE9()) {
	        rv = 9;
	      } else if (Browser.isIE()) {
	        rv = 8;
	      }

	      if (rv === -1 || rv === 8) {
	        if (navigator.appName === 'Microsoft Internet Explorer') {
	          var re = new RegExp('MSIE ([0-9]+[.0-9]*)');
	          var res = navigator.userAgent.match(re);

	          if (Type.isArrayLike(res) && res.length > 0) {
	            rv = parseFloat(res[1]);
	          }
	        }

	        if (navigator.appName === 'Netscape') {
	          // Alternative check for IE 11
	          rv = 11;

	          var _re = new RegExp('Trident/.*rv:([0-9]+[.0-9]*)');

	          if (_re.exec(navigator.userAgent) != null) {
	            var _res = navigator.userAgent.match(_re);

	            if (Type.isArrayLike(_res) && _res.length > 0) {
	              rv = parseFloat(_res[1]);
	            }
	          }
	        }
	      }

	      return rv;
	    }
	  }, {
	    key: "isIE11",
	    value: function isIE11() {
	      return Browser.detectIEVersion() >= 11;
	    }
	  }, {
	    key: "isMac",
	    value: function isMac() {
	      return UA.includes('macintosh');
	    }
	  }, {
	    key: "isWin",
	    value: function isWin() {
	      return UA.includes('windows');
	    }
	  }, {
	    key: "isLinux",
	    value: function isLinux() {
	      return UA.includes('linux') && !Browser.isAndroid();
	    }
	  }, {
	    key: "isAndroid",
	    value: function isAndroid() {
	      return UA.includes('android');
	    }
	  }, {
	    key: "isIPad",
	    value: function isIPad() {
	      return UA.includes('ipad;') || this.isMac() && this.isTouchDevice();
	    }
	  }, {
	    key: "isIPhone",
	    value: function isIPhone() {
	      return UA.includes('iphone;');
	    }
	  }, {
	    key: "isIOS",
	    value: function isIOS() {
	      return Browser.isIPad() || Browser.isIPhone();
	    }
	  }, {
	    key: "isMobile",
	    value: function isMobile() {
	      return Browser.isIPhone() || Browser.isIPad() || Browser.isAndroid() || UA.includes('mobile') || UA.includes('touch');
	    }
	  }, {
	    key: "isRetina",
	    value: function isRetina() {
	      return window.devicePixelRatio && window.devicePixelRatio >= 2;
	    }
	  }, {
	    key: "isTouchDevice",
	    value: function isTouchDevice() {
	      return 'ontouchstart' in window || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0;
	    }
	  }, {
	    key: "isDoctype",
	    value: function isDoctype(target) {
	      var doc = target || document;

	      if (doc.compatMode) {
	        return doc.compatMode === 'CSS1Compat';
	      }

	      return doc.documentElement && doc.documentElement.clientHeight;
	    }
	  }, {
	    key: "isLocalStorageSupported",
	    value: function isLocalStorageSupported() {
	      try {
	        localStorage.setItem('test', 'test');
	        localStorage.removeItem('test');
	        return true;
	      } catch (e) {
	        return false;
	      }
	    }
	  }, {
	    key: "addGlobalClass",
	    value: function addGlobalClass(target) {
	      var globalClass = 'bx-core';
	      target = Type.isElementNode(target) ? target : document.documentElement;

	      if (Dom.hasClass(target, globalClass)) {
	        return;
	      }

	      if (Browser.isIOS()) {
	        globalClass += ' bx-ios';
	      } else if (Browser.isWin()) {
	        globalClass += ' bx-win';
	      } else if (Browser.isMac()) {
	        globalClass += ' bx-mac';
	      } else if (Browser.isLinux()) {
	        globalClass += ' bx-linux';
	      } else if (Browser.isAndroid()) {
	        globalClass += ' bx-android';
	      }

	      globalClass += Browser.isMobile() ? ' bx-touch' : ' bx-no-touch';
	      globalClass += Browser.isRetina() ? ' bx-retina' : ' bx-no-retina';

	      if (/AppleWebKit/.test(navigator.userAgent)) {
	        globalClass += ' bx-chrome';
	      } else if (/Opera/.test(navigator.userAgent)) {
	        globalClass += ' bx-opera';
	      } else if (Browser.isFirefox()) {
	        globalClass += ' bx-firefox';
	      }

	      Dom.addClass(target, globalClass);
	    }
	  }, {
	    key: "detectAndroidVersion",
	    value: function detectAndroidVersion() {
	      var re = new RegExp('Android ([0-9]+[.0-9]*)');

	      if (re.exec(navigator.userAgent) != null) {
	        var res = navigator.userAgent.match(re);

	        if (Type.isArrayLike(res) && res.length > 0) {
	          return parseFloat(res[1]);
	        }
	      }

	      return 0;
	    }
	  }, {
	    key: "isPropertySupported",
	    value: function isPropertySupported(jsProperty, returnCSSName) {
	      if (jsProperty === '') {
	        return false;
	      }

	      function getCssName(propertyName) {
	        return propertyName.replace(/([A-Z])/g, function () {
	          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
	            args[_key] = arguments[_key];
	          }

	          return "-".concat(args[1].toLowerCase());
	        });
	      }

	      function getJsName(cssName) {
	        var reg = /(\\-([a-z]))/g;

	        if (reg.test(cssName)) {
	          return cssName.replace(reg, function () {
	            for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
	              args[_key2] = arguments[_key2];
	            }

	            return args[2].toUpperCase();
	          });
	        }

	        return cssName;
	      }

	      var property = jsProperty.includes('-') ? getJsName(jsProperty) : jsProperty;
	      var bReturnCSSName = !!returnCSSName;
	      var ucProperty = property.charAt(0).toUpperCase() + property.slice(1);
	      var props = ['Webkit', 'Moz', 'O', 'ms'].join("".concat(ucProperty, " "));
	      var properties = "".concat(property, " ").concat(props, " ").concat(ucProperty).split(' ');
	      var obj = document.body || document.documentElement;

	      for (var i = 0; i < properties.length; i += 1) {
	        var prop = properties[i];

	        if (obj && 'style' in obj && prop in obj.style) {
	          var lowerProp = prop.substr(0, prop.length - property.length).toLowerCase();
	          var prefix = prop === property ? '' : "-".concat(lowerProp, "-");
	          return bReturnCSSName ? prefix + getCssName(property) : prop;
	        }
	      }

	      return false;
	    }
	  }, {
	    key: "addGlobalFeatures",
	    value: function addGlobalFeatures(features) {
	      if (!Type.isArray(features)) {
	        return;
	      }

	      var classNames = [];

	      for (var i = 0; i < features.length; i += 1) {
	        var support = !!Browser.isPropertySupported(features[i]);
	        classNames.push("bx-".concat(support ? '' : 'no-').concat(features[i].toLowerCase()));
	      }

	      Dom.addClass(document.documentElement, classNames.join(' '));
	    }
	  }]);
	  return Browser;
	}();

	function ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$1(Object(source), !0).forEach(function (key) { babelHelpers.defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

	var Cookie = /*#__PURE__*/function () {
	  function Cookie() {
	    babelHelpers.classCallCheck(this, Cookie);
	  }

	  babelHelpers.createClass(Cookie, null, [{
	    key: "getList",

	    /**
	     * Gets cookies list for current domain
	     * @return {object}
	     */
	    value: function getList() {
	      return document.cookie.split(';').map(function (item) {
	        return item.split('=');
	      }).map(function (item) {
	        return item.map(function (subItem) {
	          return subItem.trim();
	        });
	      }).reduce(function (acc, item) {
	        var _item = babelHelpers.slicedToArray(item, 2),
	            key = _item[0],
	            value = _item[1];

	        acc[decodeURIComponent(key)] = decodeURIComponent(value);
	        return acc;
	      }, {});
	    }
	    /**
	     * Gets cookie value
	     * @param {string} name
	     * @return {*}
	     */

	  }, {
	    key: "get",
	    value: function get(name) {
	      var cookiesList = Cookie.getList();

	      if (name in cookiesList) {
	        return cookiesList[name];
	      }

	      return undefined;
	    }
	    /**
	     * Sets cookie
	     * @param {string} name
	     * @param {*} value
	     * @param {object} [options]
	     */

	  }, {
	    key: "set",
	    value: function set(name, value) {
	      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

	      var attributes = _objectSpread$1({
	        expires: ''
	      }, options);

	      if (Type.isNumber(attributes.expires)) {
	        var now = +new Date();
	        var days = attributes.expires;
	        var dayInMs = 864e+5;
	        attributes.expires = new Date(now + days * dayInMs);
	      }

	      if (Type.isDate(attributes.expires)) {
	        attributes.expires = attributes.expires.toUTCString();
	      }

	      var safeName = decodeURIComponent(String(name)).replace(/%(23|24|26|2B|5E|60|7C)/g, decodeURIComponent).replace(/[()]/g, escape);
	      var safeValue = encodeURIComponent(String(value)).replace(/%(23|24|26|2B|3A|3C|3E|3D|2F|3F|40|5B|5D|5E|60|7B|7D|7C)/g, decodeURIComponent);
	      var stringifiedAttributes = Object.keys(attributes).reduce(function (acc, key) {
	        var attributeValue = attributes[key];

	        if (!attributeValue) {
	          return acc;
	        }

	        if (attributeValue === true) {
	          return "".concat(acc, "; ").concat(key);
	        }
	        /**
	         * Considers RFC 6265 section 5.2:
	         * ...
	         * 3. If the remaining unparsed-attributes contains a %x3B (';')
	         * character:
	         * Consume the characters of the unparsed-attributes up to,
	         * not including, the first %x3B (';') character.
	         */


	        return "".concat(acc, "; ").concat(key, "=").concat(attributeValue.split(';')[0]);
	      }, '');
	      document.cookie = "".concat(safeName, "=").concat(safeValue).concat(stringifiedAttributes);
	    }
	    /**
	     * Removes cookie
	     * @param {string} name
	     * @param {object} [options]
	     */

	  }, {
	    key: "remove",
	    value: function remove(name) {
	      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	      Cookie.set(name, '', _objectSpread$1(_objectSpread$1({}, options), {}, {
	        expires: -1
	      }));
	    }
	  }]);
	  return Cookie;
	}();

	function objectToFormData(source) {
	  var formData = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new FormData();
	  var pre = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

	  if (Type.isUndefined(source)) {
	    return formData;
	  }

	  if (Type.isNull(source)) {
	    formData.append(pre, '');
	  } else if (Type.isArray(source)) {
	    if (!source.length) {
	      var _key = "".concat(pre, "[]");

	      formData.append(_key, '');
	    } else {
	      source.forEach(function (value, index) {
	        var key = "".concat(pre, "[").concat(index, "]");
	        objectToFormData(value, formData, key);
	      });
	    }
	  } else if (Type.isDate(source)) {
	    formData.append(pre, source.toISOString());
	  } else if (Type.isObject(source) && !Type.isFile(source) && !Type.isBlob(source)) {
	    Object.keys(source).forEach(function (property) {
	      var value = source[property];
	      var preparedProperty = property;

	      if (Type.isArray(value)) {
	        while (property.length > 2 && property.lastIndexOf('[]') === property.length - 2) {
	          preparedProperty = property.substring(0, property.length - 2);
	        }
	      }

	      var key = pre ? "".concat(pre, "[").concat(preparedProperty, "]") : preparedProperty;
	      objectToFormData(value, formData, key);
	    });
	  } else {
	    formData.append(pre, source);
	  }

	  return formData;
	}

	var Data = /*#__PURE__*/function () {
	  function Data() {
	    babelHelpers.classCallCheck(this, Data);
	  }

	  babelHelpers.createClass(Data, null, [{
	    key: "convertObjectToFormData",

	    /**
	     * Converts object to FormData
	     * @param source
	     * @return {FormData}
	     */
	    value: function convertObjectToFormData(source) {
	      return objectToFormData(source);
	    }
	  }]);
	  return Data;
	}();

	/**
	 * @memberOf BX
	 */

	var Http = function Http() {
	  babelHelpers.classCallCheck(this, Http);
	};

	babelHelpers.defineProperty(Http, "Cookie", Cookie);
	babelHelpers.defineProperty(Http, "Data", Data);

	function message(value) {
	  if (Type.isString(value)) {
	    if (Type.isNil(message[value])) {
	      // eslint-disable-next-line
	      EventEmitter.emit('onBXMessageNotFound', new BaseEvent({
	        compatData: [value]
	      }));

	      if (Type.isNil(message[value])) {
	        Runtime.debug("message undefined: ".concat(value));
	        message[value] = '';
	      }
	    }
	  }

	  if (Type.isPlainObject(value)) {
	    Object.keys(value).forEach(function (key) {
	      message[key] = value[key];
	    });
	  }

	  return message[value];
	}

	if (!Type.isNil(window.BX) && Type.isFunction(window.BX.message)) {
	  Object.keys(window.BX.message).forEach(function (key) {
	    message(babelHelpers.defineProperty({}, key, window.BX.message[key]));
	  });
	}

	/**
	 * Implements interface for works with language messages
	 * @memberOf BX
	 */

	var Loc = /*#__PURE__*/function () {
	  function Loc() {
	    babelHelpers.classCallCheck(this, Loc);
	  }

	  babelHelpers.createClass(Loc, null, [{
	    key: "getMessage",

	    /**
	     * Gets message by id
	     * @param {string} messageId
	     * @param {object} replacements
	     * @return {?string}
	     */
	    value: function getMessage(messageId) {
	      var replacements = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
	      var mess = message(messageId);

	      if (Type.isString(mess) && Type.isPlainObject(replacements)) {
	        var _escape = function _escape(str) {
	          return String(str).replace(/[\\^$*+?.()|[\]{}]/g, '\\$&');
	        };

	        Object.keys(replacements).forEach(function (replacement) {
	          var globalRegexp = new RegExp(_escape(replacement), 'gi');
	          mess = mess.replace(globalRegexp, function () {
	            return Type.isNil(replacements[replacement]) ? '' : String(replacements[replacement]);
	          });
	        });
	      }

	      return mess;
	    }
	  }, {
	    key: "hasMessage",
	    value: function hasMessage(messageId) {
	      return Type.isString(messageId) && !Type.isNil(message[messageId]);
	    }
	    /**
	     * Sets message or messages
	     * @param {string | Object<string, string>} id
	     * @param {string} [value]
	     */

	  }, {
	    key: "setMessage",
	    value: function setMessage(id, value) {
	      if (Type.isString(id) && Type.isString(value)) {
	        message(babelHelpers.defineProperty({}, id, value));
	      }

	      if (Type.isObject(id)) {
	        message(id);
	      }
	    }
	    /**
	     * Gets plural message by id and number
	     * @param {string} messageId
	     * @param {number} value
	     * @param {object} [replacements]
	     * @return {?string}
	     */

	  }, {
	    key: "getMessagePlural",
	    value: function getMessagePlural(messageId, value) {
	      var replacements = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
	      var result = '';

	      if (Type.isNumber(value)) {
	        if (this.hasMessage("".concat(messageId, "_PLURAL_").concat(this.getPluralForm(value)))) {
	          result = this.getMessage("".concat(messageId, "_PLURAL_").concat(this.getPluralForm(value)), replacements);
	        } else {
	          result = this.getMessage("".concat(messageId, "_PLURAL_1"), replacements);
	        }
	      } else {
	        result = this.getMessage(messageId, replacements);
	      }

	      return result;
	    }
	    /**
	     * Gets language plural form id by number
	     * see http://docs.translatehouse.org/projects/localization-guide/en/latest/l10n/pluralforms.html
	     * @param {number} value
	     * @param {string} [languageId]
	     * @return {?number}
	     */

	  }, {
	    key: "getPluralForm",
	    value: function getPluralForm(value, languageId) {
	      var pluralForm;

	      if (!Type.isStringFilled(languageId)) {
	        languageId = message('LANGUAGE_ID');
	      }

	      if (value < 0) {
	        value = -1 * value;
	      }

	      switch (languageId) {
	        case 'ar':
	          pluralForm = value !== 1 ? 1 : 0;
	          /*
	          				if (value === 0)
	          				{
	          					pluralForm = 0;
	          				}
	          				else if (value === 1)
	          				{
	          					pluralForm = 1;
	          				}
	          				else if (value === 2)
	          				{
	          					pluralForm = 2;
	          				}
	          				else if (
	          					value % 100 >= 3
	          					&& value % 100 <= 10
	          				)
	          				{
	          					pluralForm = 3;
	          				}
	          				else if (value % 100 >= 11)
	          				{
	          					pluralForm = 4;
	          				}
	          				else
	          				{
	          					pluralForm = 5;
	          				}
	           */

	          break;

	        case 'br':
	        case 'fr':
	        case 'tr':
	          pluralForm = value > 1 ? 1 : 0;
	          break;

	        case 'de':
	        case 'en':
	        case 'hi':
	        case 'it':
	        case 'la':
	          pluralForm = value !== 1 ? 1 : 0;
	          break;

	        case 'ru':
	        case 'ua':
	          if (value % 10 === 1 && value % 100 !== 11) {
	            pluralForm = 0;
	          } else if (value % 10 >= 2 && value % 10 <= 4 && (value % 100 < 10 || value % 100 >= 20)) {
	            pluralForm = 1;
	          } else {
	            pluralForm = 2;
	          }

	          break;

	        case 'pl':
	          if (value === 1) {
	            pluralForm = 0;
	          } else if (value % 10 >= 2 && value % 10 <= 4 && (value % 100 < 10 || value % 100 >= 20)) {
	            pluralForm = 1;
	          } else {
	            pluralForm = 2;
	          }

	          break;

	        case 'id':
	        case 'ja':
	        case 'ms':
	        case 'sc':
	        case 'tc':
	        case 'th':
	        case 'vn':
	          pluralForm = 0;
	          break;

	        default:
	          pluralForm = 1;
	          break;
	      }

	      return pluralForm;
	    }
	  }]);
	  return Loc;
	}();

	var voidElements = ['area', 'base', 'br', 'col', 'embed', 'hr', 'img', 'input', 'link', 'meta', 'param', 'source', 'track', 'wbr'];
	function isVoidElement(element) {
	  return voidElements.includes(element);
	}

	var matchers = {
	  tag: /<[a-zA-Z0-9\-\!\/](?:"[^"]*"|'[^']*'|[^'">])*>|{{uid[0-9]+}}/g,
	  comment: /<!--(?!<!)[^\[>].*?-->/g,
	  tagName: /<\/?([^\s]+?)[/\s>]/,
	  attributes: /\s([\w\-_:.]+)\s?\n?=\s?\n?"([^"]+)?"|\s([\w\-_:.]+)\s?\n?=\s?\n?'([^']+)?'|\s([\w\-_:.]+)/g,
	  placeholder: /{{uid[0-9]+}}/g
	};

	function parseTag(tag) {
	  var tagResult = {
	    type: 'tag',
	    name: '',
	    svg: false,
	    attrs: {},
	    children: [],
	    voidElement: false
	  };

	  if (tag.startsWith('<!--')) {
	    var endIndex = tag.indexOf('-->');
	    var openTagLength = '<!--'.length;
	    return {
	      type: 'comment',
	      content: endIndex !== -1 ? tag.slice(openTagLength, endIndex) : ''
	    };
	  }

	  var tagNameMatch = tag.match(matchers.tagName);

	  if (Type.isArrayFilled(tagNameMatch)) {
	    var _tagNameMatch = babelHelpers.slicedToArray(tagNameMatch, 2),
	        tagName = _tagNameMatch[1];

	    tagResult.name = tagName;
	    tagResult.svg = tagName === 'svg';
	    tagResult.voidElement = isVoidElement(tagName) || tag.trim().endsWith('/>');
	  }

	  var reg = new RegExp(matchers.attributes);

	  for (;;) {
	    var result = reg.exec(tag);

	    if (!Type.isNil(result)) {
	      // Attributes with double quotes
	      var _result = babelHelpers.slicedToArray(result, 3),
	          attrName = _result[1],
	          attrValue = _result[2];

	      if (!Type.isNil(attrName)) {
	        tagResult.attrs[attrName] = Type.isStringFilled(attrValue) ? attrValue : '';
	      } else {
	        // Attributes with single quotes
	        var _result2 = babelHelpers.slicedToArray(result, 5),
	            _attrName = _result2[3],
	            _attrValue = _result2[4];

	        if (!Type.isNil(_attrName)) {
	          tagResult.attrs[_attrName] = Type.isStringFilled(_attrValue) ? _attrValue : '';
	        } else {
	          // Attributes without value
	          var _result3 = babelHelpers.slicedToArray(result, 6),
	              _attrName2 = _result3[5];

	          tagResult.attrs[_attrName2] = '';
	        }
	      }
	    } else {
	      break;
	    }
	  }

	  return tagResult;
	}

	function parseText(input) {
	  var preparedText = input.replace(/[\n\r\t]$/, '');
	  var placeholders = preparedText.match(matchers.placeholder);
	  return preparedText.split(matchers.placeholder).reduce(function (acc, item, index) {
	    if (Type.isStringFilled(item)) {
	      acc.push.apply(acc, babelHelpers.toConsumableArray(item.split(/\n/).reduce(function (textAcc, text) {
	        var preparedItemText = text.replace(/[\t\r]/g, '');

	        if (Type.isStringFilled(preparedItemText)) {
	          textAcc.push({
	            type: 'text',
	            content: preparedItemText
	          });
	        }

	        return textAcc;
	      }, [])));
	    }

	    if (placeholders && placeholders[index]) {
	      acc.push({
	        type: 'placeholder',
	        uid: parseInt(placeholders[index].replace(/{{uid|}}/, ''))
	      });
	    }

	    return acc;
	  }, []);
	}

	function parse(html, substitutions) {
	  var result = [];

	  if (html.indexOf('<') !== 0 && !html.startsWith('{{')) {
	    var end = html.indexOf('<');
	    result.push.apply(result, babelHelpers.toConsumableArray(parseText(end === -1 ? html : html.slice(0, end))));
	  }

	  var commentsContent = [];
	  var commentIndex = -1;
	  html = html.replace(matchers.comment, function (tag) {
	    commentIndex += 1;
	    commentsContent.push(tag.replace(/^<!--|-->$/g, ''));
	    return "<!--{{cUid".concat(commentIndex, "}}-->");
	  });
	  var arr = [];
	  var level = -1;
	  var current;
	  html.replace(matchers.tag, function (tag, index) {
	    var start = index + tag.length;
	    var nextChar = html.charAt(start);
	    var parent;

	    if (tag.startsWith('<!--')) {
	      var comment = parseTag(tag, substitutions);
	      comment.content = commentsContent[tag.replace(/<!--{{cUid|}}-->/g, '')];

	      if (level < 0) {
	        result.push(comment);
	        return result;
	      }

	      parent = arr[level];
	      parent.children.push(comment);
	      return result;
	    }

	    if (tag.startsWith('{{')) {
	      var _parseText = parseText(tag),
	          _parseText2 = babelHelpers.slicedToArray(_parseText, 1),
	          placeholder = _parseText2[0];

	      if (level < 0) {
	        result.push(placeholder);
	        return result;
	      }

	      parent = arr[level];
	      parent.children.push(placeholder);
	      return result;
	    }

	    if (!tag.startsWith('</')) {
	      level++;
	      current = parseTag(tag, substitutions);

	      if (!current.voidElement && nextChar && nextChar !== '<') {
	        var _current$children;

	        (_current$children = current.children).push.apply(_current$children, babelHelpers.toConsumableArray(parseText(html.slice(start, html.indexOf('<', start)))));
	      }

	      if (level === 0) {
	        result.push(current);
	      }

	      parent = arr[level - 1];

	      if (parent) {
	        if (!current.svg) {
	          current.svg = parent.svg;
	        }

	        parent.children.push(current);
	      }

	      arr[level] = current;
	    }

	    if (tag.startsWith('</') || current.voidElement) {
	      if (level > -1 && (current.voidElement || current.name === tag.slice(2, -1))) {
	        level--;
	        current = level === -1 ? result : arr[level];
	      }

	      if (nextChar && nextChar !== '<') {
	        parent = level === -1 ? result : arr[level].children;

	        var _end = html.indexOf('<', start);

	        var content = html.slice(start, _end === -1 ? undefined : _end);

	        if (_end > -1 && level + parent.length >= 0 || content !== ' ') {
	          var _parent;

	          (_parent = parent).push.apply(_parent, babelHelpers.toConsumableArray(parseText(content)));
	        }
	      }
	    }
	  });
	  return result;
	}

	var appendElement = function appendElement(current, target) {
	  if (Type.isDomNode(current) && Type.isDomNode(target)) {
	    if (target.nodeName !== 'TEMPLATE') {
	      Dom.append(current, target);
	    } else {
	      // eslint-disable-next-line bitrix-rules/no-native-dom-methods
	      target.content.append(current);
	    }
	  }
	};

	function renderNode(options) {
	  var node = options.node,
	      parentElement = options.parentElement,
	      substitutions = options.substitutions;

	  if (node.type === 'tag') {
	    var element = function () {
	      if (node.svg) {
	        return document.createElementNS('http://www.w3.org/2000/svg', node.name);
	      }

	      return document.createElement(node.name);
	    }();

	    Object.entries(node.attrs).forEach(function (_ref) {
	      var _ref2 = babelHelpers.slicedToArray(_ref, 2),
	          key = _ref2[0],
	          value = _ref2[1];

	      if (key.startsWith('on') && new RegExp(matchers.placeholder).test(value)) {
	        var substitution = substitutions[parseInt(value.replace(/{{uid|}}/, '')) - 1];

	        if (Type.isFunction(substitution)) {
	          var bindFunctionName = key.endsWith('once') ? 'bindOnce' : 'bind';
	          Event[bindFunctionName](element, key.replace(/^on|once$/g, ''), substitution);
	        } else {
	          element.setAttribute(key, substitution);
	        }
	      } else {
	        if (new RegExp(matchers.placeholder).test(value)) {
	          var preparedValue = value.split(/{{|}}/).reduce(function (acc, item) {
	            if (item.startsWith('uid')) {
	              var _substitution = substitutions[parseInt(item.replace('uid', '')) - 1];
	              return "".concat(acc).concat(_substitution);
	            }

	            return "".concat(acc).concat(item);
	          }, '');
	          element.setAttribute(key, preparedValue);
	        } else {
	          element.setAttribute(key, Text.decode(value));
	        }
	      }
	    });
	    node.children.forEach(function (childNode) {
	      var result = renderNode({
	        node: childNode,
	        parentElement: element,
	        substitutions: substitutions
	      });

	      if (Type.isArray(result)) {
	        result.forEach(function (subChildElement) {
	          appendElement(subChildElement, element);
	        });
	      } else {
	        appendElement(result, element);
	      }
	    });
	    return element;
	  }

	  if (node.type === 'comment') {
	    return document.createComment(node.content);
	  }

	  if (node.type === 'text') {
	    if (parentElement) {
	      if (parentElement.nodeName !== 'TEMPLATE') {
	        parentElement.insertAdjacentHTML('beforeend', node.content);
	      } else {
	        parentElement.content.append(node.content);
	      }

	      return;
	    }

	    return document.createTextNode(node.content);
	  }

	  if (node.type === 'placeholder') {
	    return substitutions[node.uid - 1];
	  }
	}

	function render(sections) {
	  for (var _len = arguments.length, substitutions = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	    substitutions[_key - 1] = arguments[_key];
	  }

	  var html = sections.reduce(function (acc, item, index) {
	    if (index > 0) {
	      var substitution = substitutions[index - 1];

	      if (Type.isString(substitution) || Type.isNumber(substitution)) {
	        return "".concat(acc).concat(substitution).concat(item);
	      }

	      return "".concat(acc, "{{uid").concat(index, "}}").concat(item);
	    }

	    return acc;
	  }, sections[0]).replace(/^[\r\n\t\s]+/gm, '').replace(/>[\n]+/g, '>').replace(/[}][\n]+/g, '}');
	  var ast = parse(html);

	  if (ast.length === 1) {
	    return renderNode({
	      node: ast[0],
	      substitutions: substitutions
	    });
	  }

	  if (ast.length > 1) {
	    return ast.map(function (node) {
	      return renderNode({
	        node: node,
	        substitutions: substitutions
	      });
	    });
	  }

	  return false;
	}

	function parseProps(sections) {
	  for (var _len = arguments.length, substitutions = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	    substitutions[_key - 1] = arguments[_key];
	  }

	  return substitutions.reduce(function (acc, item, index) {
	    var nextSectionIndex = index + 1;

	    if (!Type.isPlainObject(item) && !Type.isArray(item)) {
	      return acc + item + sections[nextSectionIndex];
	    }

	    return "".concat(acc, "__s").concat(index).concat(sections[nextSectionIndex]);
	  }, sections[0]).replace(/[\r\t]/gm, '').split(';\n').map(function (item) {
	    return item.replace(/\n/, '');
	  }).reduce(function (acc, item) {
	    if (item !== '') {
	      var matches = item.match(/^[\w-. ]+:/);
	      var splitted = item.split(/^[\w-. ]+:/);

	      var _key2 = matches[0].replace(':', '').trim();

	      var value = splitted[1].trim();
	      var substitutionPlaceholderExp = /^__s\d+/;

	      if (substitutionPlaceholderExp.test(value)) {
	        acc[_key2] = substitutions[value.replace('__s', '')];
	        return acc;
	      }

	      acc[_key2] = value;
	    }

	    return acc;
	  }, {});
	}
	/**
	 * @memberOf BX
	 */


	var Tag = /*#__PURE__*/function () {
	  function Tag() {
	    babelHelpers.classCallCheck(this, Tag);
	  }

	  babelHelpers.createClass(Tag, null, [{
	    key: "safe",

	    /**
	     * Encodes all substitutions
	     * @param sections
	     * @param substitutions
	     * @return {string}
	     */
	    value: function safe(sections) {
	      for (var _len2 = arguments.length, substitutions = new Array(_len2 > 1 ? _len2 - 1 : 0), _key3 = 1; _key3 < _len2; _key3++) {
	        substitutions[_key3 - 1] = arguments[_key3];
	      }

	      return substitutions.reduce(function (acc, item, index) {
	        return acc + Text.encode(item) + sections[index + 1];
	      }, sections[0]);
	    }
	    /**
	     * Decodes all substitutions
	     * @param sections
	     * @param substitutions
	     * @return {string}
	     */

	  }, {
	    key: "unsafe",
	    value: function unsafe(sections) {
	      for (var _len3 = arguments.length, substitutions = new Array(_len3 > 1 ? _len3 - 1 : 0), _key4 = 1; _key4 < _len3; _key4++) {
	        substitutions[_key4 - 1] = arguments[_key4];
	      }

	      return substitutions.reduce(function (acc, item, index) {
	        return acc + Text.decode(item) + sections[index + 1];
	      }, sections[0]);
	    }
	    /**
	     * Adds styles to specified element
	     * @param {HTMLElement} element
	     * @return {Function}
	     */

	  }, {
	    key: "style",
	    value: function style(element) {
	      if (!Type.isDomNode(element)) {
	        throw new Error('element is not HTMLElement');
	      }

	      return function styleTagHandler() {
	        Dom.style(element, parseProps.apply(void 0, arguments));
	      };
	    }
	    /**
	     * Replace all messages identifiers to real messages
	     * @param sections
	     * @param substitutions
	     * @return {string}
	     */

	  }, {
	    key: "message",
	    value: function message(sections) {
	      for (var _len4 = arguments.length, substitutions = new Array(_len4 > 1 ? _len4 - 1 : 0), _key5 = 1; _key5 < _len4; _key5++) {
	        substitutions[_key5 - 1] = arguments[_key5];
	      }

	      return substitutions.reduce(function (acc, item, index) {
	        return acc + Loc.getMessage(item) + sections[index + 1];
	      }, sections[0]);
	    }
	  }, {
	    key: "attrs",

	    /**
	     * Adds attributes to specified element
	     * @param element
	     * @return {Function}
	     */
	    value: function attrs(element) {
	      if (!Type.isDomNode(element)) {
	        throw new Error('element is not HTMLElement');
	      }

	      return function attrsTagHandler() {
	        Dom.attr(element, parseProps.apply(void 0, arguments));
	      };
	    }
	  }]);
	  return Tag;
	}();

	babelHelpers.defineProperty(Tag, "render", render);
	babelHelpers.defineProperty(Tag, "attr", Tag.attrs);

	function getParser(format) {
	  switch (format) {
	    case 'index':
	      return function (sourceKey, value, accumulator) {
	        var result = /\[(\w*)\]$/.exec(sourceKey);
	        var key = sourceKey.replace(/\[\w*\]$/, '');

	        if (Type.isNil(result)) {
	          accumulator[key] = value;
	          return;
	        }

	        if (Type.isUndefined(accumulator[key])) {
	          accumulator[key] = {};
	        }

	        accumulator[key][result[1]] = value;
	      };

	    case 'bracket':
	      return function (sourceKey, value, accumulator) {
	        var result = /(\[\])$/.exec(sourceKey);
	        var key = sourceKey.replace(/\[\]$/, '');

	        if (Type.isNil(result)) {
	          accumulator[key] = value;
	          return;
	        }

	        if (Type.isUndefined(accumulator[key])) {
	          accumulator[key] = [value];
	          return;
	        }

	        accumulator[key] = [].concat(accumulator[key], value);
	      };

	    default:
	      return function (sourceKey, value, accumulator) {
	        var key = sourceKey.replace(/\[\]$/, '');
	        accumulator[key] = value;
	      };
	  }
	}

	function getKeyFormat(key) {
	  if (/^\w+\[([\w]+)\]$/.test(key)) {
	    return 'index';
	  }

	  if (/^\w+\[\]$/.test(key)) {
	    return 'bracket';
	  }

	  return 'default';
	}

	function parseQuery(input) {
	  if (!Type.isString(input)) {
	    return {};
	  }

	  var url = input.trim().replace(/^[?#&]/, '');

	  if (!url) {
	    return {};
	  }

	  return url.split('&').reduce(function (acc, param) {
	    var _param$replace$split = param.replace(/\+/g, ' ').split('='),
	        _param$replace$split2 = babelHelpers.slicedToArray(_param$replace$split, 2),
	        key = _param$replace$split2[0],
	        value = _param$replace$split2[1];

	    var keyFormat = getKeyFormat(key);
	    var formatter = getParser(keyFormat);
	    formatter(key, value, acc);
	    return acc;
	  }, {});
	}

	var urlExp = /^((\w+):)?(\/\/((\w+)?(:(\w+))?@)?([^\/\?:]+)(:(\d+))?)?(\/?([^\/\?#][^\?#]*)?)?(\?([^#]+))?(#(\w*))?/;
	function parseUrl(url) {
	  var result = url.match(urlExp);

	  if (Type.isArray(result)) {
	    var queryParams = parseQuery(result[14]);
	    return {
	      useShort: /^\/\//.test(url),
	      href: result[0] || '',
	      schema: result[2] || '',
	      host: result[8] || '',
	      port: result[10] || '',
	      path: result[11] || '',
	      query: result[14] || '',
	      queryParams: queryParams,
	      hash: result[16] || '',
	      username: result[5] || '',
	      password: result[7] || '',
	      origin: result[8] || ''
	    };
	  }

	  return {};
	}

	function buildQueryString() {
	  var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	  var queryString = Object.keys(params).reduce(function (acc, key) {
	    if (Type.isArray(params[key])) {
	      params[key].forEach(function (paramValue) {
	        acc.push("".concat(key, "[]=").concat(paramValue));
	      }, '');
	    }

	    if (Type.isPlainObject(params[key])) {
	      Object.keys(params[key]).forEach(function (paramIndex) {
	        acc.push("".concat(key, "[").concat(paramIndex, "]=").concat(params[key][paramIndex]));
	      }, '');
	    }

	    if (!Type.isObject(params[key]) && !Type.isArray(params[key])) {
	      acc.push("".concat(key, "=").concat(params[key]));
	    }

	    return acc;
	  }, []).join('&');

	  if (queryString.length > 0) {
	    return "?".concat(queryString);
	  }

	  return queryString;
	}

	function ownKeys$2(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread$2(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$2(Object(source), !0).forEach(function (key) { babelHelpers.defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$2(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
	function prepareParamValue(value) {
	  if (Type.isArray(value)) {
	    return value.map(function (item) {
	      return String(item);
	    });
	  }

	  if (Type.isPlainObject(value)) {
	    return _objectSpread$2({}, value);
	  }

	  return String(value);
	}

	function ownKeys$3(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread$3(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$3(Object(source), !0).forEach(function (key) { babelHelpers.defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$3(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
	var map = new WeakMap();
	/**
	 * Implements interface for works with URI
	 * @memberOf BX
	 */

	var Uri = /*#__PURE__*/function () {
	  babelHelpers.createClass(Uri, null, [{
	    key: "addParam",
	    value: function addParam(url) {
	      var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	      return new Uri(url).setQueryParams(params).toString();
	    }
	  }, {
	    key: "removeParam",
	    value: function removeParam(url, params) {
	      var _Uri;

	      var removableParams = Type.isArray(params) ? params : [params];
	      return (_Uri = new Uri(url)).removeQueryParam.apply(_Uri, babelHelpers.toConsumableArray(removableParams)).toString();
	    }
	  }]);

	  function Uri() {
	    var url = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
	    babelHelpers.classCallCheck(this, Uri);
	    map.set(this, parseUrl(url));
	  }
	  /**
	   * Gets schema
	   * @return {?string}
	   */


	  babelHelpers.createClass(Uri, [{
	    key: "getSchema",
	    value: function getSchema() {
	      return map.get(this).schema;
	    }
	    /**
	     * Sets schema
	     * @param {string} schema
	     * @return {Uri}
	     */

	  }, {
	    key: "setSchema",
	    value: function setSchema(schema) {
	      map.get(this).schema = String(schema);
	      return this;
	    }
	    /**
	     * Gets host
	     * @return {?string}
	     */

	  }, {
	    key: "getHost",
	    value: function getHost() {
	      return map.get(this).host;
	    }
	    /**
	     * Sets host
	     * @param {string} host
	     * @return {Uri}
	     */

	  }, {
	    key: "setHost",
	    value: function setHost(host) {
	      map.get(this).host = String(host);
	      return this;
	    }
	    /**
	     * Gets port
	     * @return {?string}
	     */

	  }, {
	    key: "getPort",
	    value: function getPort() {
	      return map.get(this).port;
	    }
	    /**
	     * Sets port
	     * @param {String | Number} port
	     * @return {Uri}
	     */

	  }, {
	    key: "setPort",
	    value: function setPort(port) {
	      map.get(this).port = String(port);
	      return this;
	    }
	    /**
	     * Gets path
	     * @return {?string}
	     */

	  }, {
	    key: "getPath",
	    value: function getPath() {
	      return map.get(this).path;
	    }
	    /**
	     * Sets path
	     * @param {string} path
	     * @return {Uri}
	     */

	  }, {
	    key: "setPath",
	    value: function setPath(path) {
	      if (!/^\//.test(path)) {
	        map.get(this).path = "/".concat(String(path));
	        return this;
	      }

	      map.get(this).path = String(path);
	      return this;
	    }
	    /**
	     * Gets query
	     * @return {?string}
	     */

	  }, {
	    key: "getQuery",
	    value: function getQuery() {
	      return buildQueryString(map.get(this).queryParams);
	    }
	    /**
	     * Gets query param value by name
	     * @param {string} key
	     * @return {?string}
	     */

	  }, {
	    key: "getQueryParam",
	    value: function getQueryParam(key) {
	      var params = this.getQueryParams();

	      if (key in params) {
	        return params[key];
	      }

	      return null;
	    }
	    /**
	     * Sets query param
	     * @param {string} key
	     * @param [value]
	     * @return {Uri}
	     */

	  }, {
	    key: "setQueryParam",
	    value: function setQueryParam(key) {
	      var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
	      map.get(this).queryParams[key] = prepareParamValue(value);
	      return this;
	    }
	    /**
	     * Gets query params
	     * @return {Object<string, any>}
	     */

	  }, {
	    key: "getQueryParams",
	    value: function getQueryParams() {
	      return _objectSpread$3({}, map.get(this).queryParams);
	    }
	    /**
	     * Sets query params
	     * @param {Object<string, any>} params
	     * @return {Uri}
	     */

	  }, {
	    key: "setQueryParams",
	    value: function setQueryParams() {
	      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	      var currentParams = this.getQueryParams();

	      var newParams = _objectSpread$3(_objectSpread$3({}, currentParams), params);

	      Object.keys(newParams).forEach(function (key) {
	        newParams[key] = prepareParamValue(newParams[key]);
	      });
	      map.get(this).queryParams = newParams;
	      return this;
	    }
	    /**
	     * Removes query params by name
	     * @param keys
	     * @return {Uri}
	     */

	  }, {
	    key: "removeQueryParam",
	    value: function removeQueryParam() {
	      var currentParams = _objectSpread$3({}, map.get(this).queryParams);

	      for (var _len = arguments.length, keys = new Array(_len), _key = 0; _key < _len; _key++) {
	        keys[_key] = arguments[_key];
	      }

	      keys.forEach(function (key) {
	        if (key in currentParams) {
	          delete currentParams[key];
	        }
	      });
	      map.get(this).queryParams = currentParams;
	      return this;
	    }
	    /**
	     * Gets fragment
	     * @return {?string}
	     */

	  }, {
	    key: "getFragment",
	    value: function getFragment() {
	      return map.get(this).hash;
	    }
	    /**
	     * Sets fragment
	     * @param {string} hash
	     * @return {Uri}
	     */

	  }, {
	    key: "setFragment",
	    value: function setFragment(hash) {
	      map.get(this).hash = String(hash);
	      return this;
	    }
	    /**
	     * Serializes URI
	     * @return {Object}
	     */

	  }, {
	    key: "serialize",
	    value: function serialize() {
	      var serialized = _objectSpread$3({}, map.get(this));

	      serialized.href = this.toString();
	      return serialized;
	    }
	    /**
	     * Gets URI string
	     * @return {string}
	     */

	  }, {
	    key: "toString",
	    value: function toString() {
	      var data = _objectSpread$3({}, map.get(this));

	      var protocol = data.schema ? "".concat(data.schema, "://") : '';

	      if (data.useShort) {
	        protocol = '//';
	      }

	      var port = function () {
	        if (Type.isString(data.port) && !['', '80'].includes(data.port)) {
	          return ":".concat(data.port);
	        }

	        return '';
	      }();

	      var host = this.getHost();
	      var path = this.getPath();
	      var query = buildQueryString(data.queryParams);
	      var hash = data.hash ? "#".concat(data.hash) : '';
	      return "".concat(host ? protocol : '').concat(host).concat(host ? port : '').concat(path).concat(query).concat(hash);
	    }
	  }]);
	  return Uri;
	}();

	/**
	 * @memberOf BX
	 */
	var Validation = /*#__PURE__*/function () {
	  function Validation() {
	    babelHelpers.classCallCheck(this, Validation);
	  }

	  babelHelpers.createClass(Validation, null, [{
	    key: "isEmail",

	    /**
	     * Checks that value is valid email
	     * @param value
	     * @return {boolean}
	     */
	    value: function isEmail(value) {
	      var exp = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
	      return exp.test(String(value).toLowerCase());
	    }
	  }]);
	  return Validation;
	}();

	var BaseCache = /*#__PURE__*/function () {
	  function BaseCache() {
	    babelHelpers.classCallCheck(this, BaseCache);
	    babelHelpers.defineProperty(this, "storage", new Map());
	  }

	  babelHelpers.createClass(BaseCache, [{
	    key: "get",

	    /**
	     * Gets cached value or default value
	     */
	    value: function get(key, defaultValue) {
	      if (!this.storage.has(key)) {
	        if (Type.isFunction(defaultValue)) {
	          return defaultValue();
	        }

	        if (!Type.isUndefined(defaultValue)) {
	          return defaultValue;
	        }
	      }

	      return this.storage.get(key);
	    }
	    /**
	     * Sets cache entry
	     */

	  }, {
	    key: "set",
	    value: function set(key, value) {
	      this.storage.set(key, value);
	    }
	    /**
	     * Deletes cache entry
	     */

	  }, {
	    key: "delete",
	    value: function _delete(key) {
	      this.storage["delete"](key);
	    }
	    /**
	     * Checks that storage contains entry with specified key
	     */

	  }, {
	    key: "has",
	    value: function has(key) {
	      return this.storage.has(key);
	    }
	    /**
	     * Gets cached value if exists,
	     */

	  }, {
	    key: "remember",
	    value: function remember(key, defaultValue) {
	      if (!this.storage.has(key)) {
	        if (Type.isFunction(defaultValue)) {
	          this.storage.set(key, defaultValue());
	        } else if (!Type.isUndefined(defaultValue)) {
	          this.storage.set(key, defaultValue);
	        }
	      }

	      return this.storage.get(key);
	    }
	    /**
	     * Gets storage size
	     */

	  }, {
	    key: "size",
	    value: function size() {
	      return this.storage.size;
	    }
	    /**
	     * Gets storage keys
	     */

	  }, {
	    key: "keys",
	    value: function keys() {
	      return babelHelpers.toConsumableArray(this.storage.keys());
	    }
	    /**
	     * Gets storage values
	     */

	  }, {
	    key: "values",
	    value: function values() {
	      return babelHelpers.toConsumableArray(this.storage.values());
	    }
	  }]);
	  return BaseCache;
	}();

	var MemoryCache = /*#__PURE__*/function (_BaseCache) {
	  babelHelpers.inherits(MemoryCache, _BaseCache);

	  function MemoryCache() {
	    var _babelHelpers$getProt;

	    var _this;

	    babelHelpers.classCallCheck(this, MemoryCache);

	    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }

	    _this = babelHelpers.possibleConstructorReturn(this, (_babelHelpers$getProt = babelHelpers.getPrototypeOf(MemoryCache)).call.apply(_babelHelpers$getProt, [this].concat(args)));
	    babelHelpers.defineProperty(babelHelpers.assertThisInitialized(_this), "storage", new Map());
	    return _this;
	  }

	  return MemoryCache;
	}(BaseCache);

	var LsStorage = /*#__PURE__*/function () {
	  function LsStorage() {
	    babelHelpers.classCallCheck(this, LsStorage);
	    babelHelpers.defineProperty(this, "stackKey", 'BX.Cache.Storage.LsStorage.stack');
	    babelHelpers.defineProperty(this, "stack", null);
	  }

	  babelHelpers.createClass(LsStorage, [{
	    key: "getStack",

	    /**
	     * @private
	     */
	    value: function getStack() {
	      if (Type.isPlainObject(this.stack)) {
	        return this.stack;
	      }

	      var stack = localStorage.getItem(this.stackKey);

	      if (Type.isString(stack) && stack !== '') {
	        var parsedStack = JSON.parse(stack);

	        if (Type.isPlainObject(parsedStack)) {
	          this.stack = parsedStack;
	          return this.stack;
	        }
	      }

	      this.stack = {};
	      return this.stack;
	    }
	    /**
	     * @private
	     */

	  }, {
	    key: "saveStack",
	    value: function saveStack() {
	      if (Type.isPlainObject(this.stack)) {
	        var preparedStack = JSON.stringify(this.stack);
	        localStorage.setItem(this.stackKey, preparedStack);
	      }
	    }
	  }, {
	    key: "get",
	    value: function get(key) {
	      var stack = this.getStack();
	      return stack[key];
	    }
	  }, {
	    key: "set",
	    value: function set(key, value) {
	      var stack = this.getStack();
	      stack[key] = value;
	      this.saveStack();
	    }
	  }, {
	    key: "delete",
	    value: function _delete(key) {
	      var stack = this.getStack();

	      if (key in stack) {
	        delete stack[key];
	      }
	    }
	  }, {
	    key: "has",
	    value: function has(key) {
	      var stack = this.getStack();
	      return key in stack;
	    }
	  }, {
	    key: "keys",
	    value: function keys() {
	      var stack = this.getStack();
	      return Object.keys(stack);
	    }
	  }, {
	    key: "values",
	    value: function values() {
	      var stack = this.getStack();
	      return Object.values(stack);
	    }
	  }, {
	    key: "size",
	    get: function get() {
	      var stack = this.getStack();
	      return Object.keys(stack).length;
	    }
	  }]);
	  return LsStorage;
	}();

	var LocalStorageCache = /*#__PURE__*/function (_BaseCache) {
	  babelHelpers.inherits(LocalStorageCache, _BaseCache);

	  function LocalStorageCache() {
	    var _babelHelpers$getProt;

	    var _this;

	    babelHelpers.classCallCheck(this, LocalStorageCache);

	    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }

	    _this = babelHelpers.possibleConstructorReturn(this, (_babelHelpers$getProt = babelHelpers.getPrototypeOf(LocalStorageCache)).call.apply(_babelHelpers$getProt, [this].concat(args)));
	    babelHelpers.defineProperty(babelHelpers.assertThisInitialized(_this), "storage", new LsStorage());
	    return _this;
	  }

	  return LocalStorageCache;
	}(BaseCache);

	/**
	 * @memberOf BX
	 */

	var Cache = function Cache() {
	  babelHelpers.classCallCheck(this, Cache);
	};

	babelHelpers.defineProperty(Cache, "MemoryCache", MemoryCache);
	babelHelpers.defineProperty(Cache, "LocalStorageCache", LocalStorageCache);

	var _Symbol$iterator;

	function _classPrivateMethodInitSpec(obj, privateSet) { _checkPrivateRedeclaration(obj, privateSet); privateSet.add(obj); }

	function _checkPrivateRedeclaration(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError("Cannot initialize the same private elements twice on an object"); } }

	function _classPrivateMethodGet(receiver, privateSet, fn) { if (!privateSet.has(receiver)) { throw new TypeError("attempted to get private field on non-instance"); } return fn; }

	var _searchIndexToInsert = /*#__PURE__*/new WeakSet();

	_Symbol$iterator = Symbol.iterator;

	var OrderedArray = /*#__PURE__*/function () {
	  function OrderedArray() {
	    var comparator = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
	    babelHelpers.classCallCheck(this, OrderedArray);

	    _classPrivateMethodInitSpec(this, _searchIndexToInsert);

	    babelHelpers.defineProperty(this, "comparator", null);
	    babelHelpers.defineProperty(this, "items", []);
	    this.comparator = Type.isFunction(comparator) ? comparator : null;
	  }

	  babelHelpers.createClass(OrderedArray, [{
	    key: "add",
	    value: function add(item) {
	      var index = -1;

	      if (this.comparator) {
	        index = _classPrivateMethodGet(this, _searchIndexToInsert, _searchIndexToInsert2).call(this, item);
	        this.items.splice(index, 0, item);
	      } else {
	        this.items.push(item);
	      }

	      return index;
	    }
	  }, {
	    key: "has",
	    value: function has(item) {
	      return this.items.includes(item);
	    }
	  }, {
	    key: "getIndex",
	    value: function getIndex(item) {
	      return this.items.indexOf(item);
	    }
	  }, {
	    key: "getByIndex",
	    value: function getByIndex(index) {
	      if (Type.isNumber(index) && index >= 0) {
	        var item = this.items[index];
	        return Type.isUndefined(item) ? null : item;
	      }

	      return null;
	    }
	  }, {
	    key: "getFirst",
	    value: function getFirst() {
	      var first = this.items[0];
	      return Type.isUndefined(first) ? null : first;
	    }
	  }, {
	    key: "getLast",
	    value: function getLast() {
	      var last = this.items[this.count() - 1];
	      return Type.isUndefined(last) ? null : last;
	    }
	  }, {
	    key: "count",
	    value: function count() {
	      return this.items.length;
	    }
	  }, {
	    key: "delete",
	    value: function _delete(item) {
	      var index = this.getIndex(item);

	      if (index !== -1) {
	        this.items.splice(index, 1);
	        return true;
	      }

	      return false;
	    }
	  }, {
	    key: "clear",
	    value: function clear() {
	      this.items = [];
	    }
	  }, {
	    key: _Symbol$iterator,
	    value: function value() {
	      return this.items[Symbol.iterator]();
	    }
	  }, {
	    key: "forEach",
	    value: function forEach(callbackfn, thisArg) {
	      return this.items.forEach(callbackfn, thisArg);
	    }
	  }, {
	    key: "getAll",
	    value: function getAll() {
	      return this.items;
	    }
	  }, {
	    key: "getComparator",
	    value: function getComparator() {
	      return this.comparator;
	    }
	  }, {
	    key: "sort",
	    value: function sort() {
	      var _this = this;

	      var comparator = this.getComparator();

	      if (comparator === null) {
	        return;
	      }
	      /*
	      Simple implementation
	      this.items.sort((item1, item2) => {
	      	return comparator(item1, item2);
	      });
	      */
	      // For stable sorting https://v8.dev/features/stable-sort


	      var length = this.items.length;
	      var indexes = new Array(length);

	      for (var i = 0; i < length; i++) {
	        indexes[i] = i;
	      } // If the comparator returns zero, use the original indexes


	      indexes.sort(function (index1, index2) {
	        return comparator(_this.items[index1], _this.items[index2]) || index1 - index2;
	      });

	      for (var _i = 0; _i < length; _i++) {
	        indexes[_i] = this.items[indexes[_i]];
	      }

	      for (var _i2 = 0; _i2 < length; _i2++) {
	        this.items[_i2] = indexes[_i2];
	      }
	    }
	  }]);
	  return OrderedArray;
	}();

	function _searchIndexToInsert2(value) {
	  var low = 0;
	  var high = this.items.length;

	  while (low < high) {
	    var mid = Math.floor((low + high) / 2);

	    if (this.comparator(this.items[mid], value) >= 0) {
	      high = mid;
	    } else {
	      low = mid + 1;
	    }
	  }

	  return low;
	}

	var ZIndexComponent = /*#__PURE__*/function (_EventEmitter) {
	  babelHelpers.inherits(ZIndexComponent, _EventEmitter);

	  function ZIndexComponent(element) {
	    var _this;

	    var componentOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	    babelHelpers.classCallCheck(this, ZIndexComponent);
	    _this = babelHelpers.possibleConstructorReturn(this, babelHelpers.getPrototypeOf(ZIndexComponent).call(this));
	    babelHelpers.defineProperty(babelHelpers.assertThisInitialized(_this), "sort", 0);
	    babelHelpers.defineProperty(babelHelpers.assertThisInitialized(_this), "alwaysOnTop", false);
	    babelHelpers.defineProperty(babelHelpers.assertThisInitialized(_this), "zIndex", 0);
	    babelHelpers.defineProperty(babelHelpers.assertThisInitialized(_this), "element", null);
	    babelHelpers.defineProperty(babelHelpers.assertThisInitialized(_this), "overlay", null);
	    babelHelpers.defineProperty(babelHelpers.assertThisInitialized(_this), "overlayGap", -5);
	    babelHelpers.defineProperty(babelHelpers.assertThisInitialized(_this), "stack", null);

	    _this.setEventNamespace('BX.Main.ZIndexManager.Component');

	    if (!Type.isElementNode(element)) {
	      throw new Error('ZIndexManager.Component: The argument \'element\' must be a DOM element.');
	    }

	    _this.element = element;
	    var options = Type.isPlainObject(componentOptions) ? componentOptions : {};

	    _this.setAlwaysOnTop(options.alwaysOnTop);

	    _this.setOverlay(options.overlay);

	    _this.setOverlayGap(options.overlayGap);

	    _this.subscribeFromOptions(options.events);

	    return _this;
	  }

	  babelHelpers.createClass(ZIndexComponent, [{
	    key: "getSort",
	    value: function getSort() {
	      return this.sort;
	    }
	    /**
	     * @internal
	     * @param sort
	     */

	  }, {
	    key: "setSort",
	    value: function setSort(sort) {
	      if (Type.isNumber(sort)) {
	        this.sort = sort;
	      }
	    }
	    /**
	     * @internal
	     * @param stack
	     */

	  }, {
	    key: "setStack",
	    value: function setStack(stack) {
	      this.stack = stack;
	    }
	  }, {
	    key: "getStack",
	    value: function getStack() {
	      return this.stack;
	    }
	  }, {
	    key: "getZIndex",
	    value: function getZIndex() {
	      return this.zIndex;
	    }
	    /**
	     * @internal
	     */

	  }, {
	    key: "setZIndex",
	    value: function setZIndex(zIndex) {
	      var changed = this.getZIndex() !== zIndex;
	      this.getElement().style.setProperty('z-index', zIndex, 'important');
	      this.zIndex = zIndex;

	      if (this.getOverlay() !== null) {
	        this.getOverlay().style.setProperty('z-index', zIndex + this.getOverlayGap(), 'important');
	      }

	      if (changed) {
	        this.emit('onZIndexChange', {
	          component: this
	        });
	      }
	    }
	  }, {
	    key: "getAlwaysOnTop",
	    value: function getAlwaysOnTop() {
	      return this.alwaysOnTop;
	    }
	  }, {
	    key: "setAlwaysOnTop",
	    value: function setAlwaysOnTop(value) {
	      if (Type.isNumber(value) || Type.isBoolean(value)) {
	        this.alwaysOnTop = value;
	      }
	    }
	  }, {
	    key: "getElement",
	    value: function getElement() {
	      return this.element;
	    }
	  }, {
	    key: "setOverlay",
	    value: function setOverlay(overlay, gap) {
	      if (Type.isElementNode(overlay) || overlay === null) {
	        this.overlay = overlay;
	        this.setOverlayGap(gap);

	        if (this.getStack()) {
	          this.getStack().sort();
	        }
	      }
	    }
	  }, {
	    key: "getOverlay",
	    value: function getOverlay() {
	      return this.overlay;
	    }
	  }, {
	    key: "setOverlayGap",
	    value: function setOverlayGap(gap) {
	      if (Type.isNumber(gap)) {
	        this.overlayGap = gap;
	      }
	    }
	  }, {
	    key: "getOverlayGap",
	    value: function getOverlayGap() {
	      return this.overlayGap;
	    }
	  }]);
	  return ZIndexComponent;
	}(EventEmitter);

	var ZIndexStack = /*#__PURE__*/function () {
	  function ZIndexStack(container) {
	    babelHelpers.classCallCheck(this, ZIndexStack);
	    babelHelpers.defineProperty(this, "container", null);
	    babelHelpers.defineProperty(this, "components", null);
	    babelHelpers.defineProperty(this, "elements", new WeakMap());
	    babelHelpers.defineProperty(this, "baseIndex", 1000);
	    babelHelpers.defineProperty(this, "baseStep", 50);
	    babelHelpers.defineProperty(this, "sortCount", 0);

	    if (!Type.isDomNode(container)) {
	      throw new Error('ZIndexManager.Stack: The \'container\' argument must be a DOM element.');
	    }

	    this.container = container;

	    var comparator = function comparator(componentA, componentB) {
	      var result = (componentA.getAlwaysOnTop() || 0) - (componentB.getAlwaysOnTop() || 0);

	      if (!result) {
	        result = componentA.getSort() - componentB.getSort();
	      }

	      return result;
	    };

	    this.components = new OrderedArray(comparator);
	  }

	  babelHelpers.createClass(ZIndexStack, [{
	    key: "getBaseIndex",
	    value: function getBaseIndex() {
	      return this.baseIndex;
	    }
	  }, {
	    key: "setBaseIndex",
	    value: function setBaseIndex(index) {
	      if (Type.isNumber(index) && index >= 0) {
	        this.baseIndex = index;
	        this.sort();
	      }
	    }
	  }, {
	    key: "setBaseStep",
	    value: function setBaseStep(step) {
	      if (Type.isNumber(step) && step > 0) {
	        this.baseStep = step;
	        this.sort();
	      }
	    }
	  }, {
	    key: "getBaseStep",
	    value: function getBaseStep() {
	      return this.baseStep;
	    }
	  }, {
	    key: "register",
	    value: function register(element) {
	      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

	      if (this.getComponent(element)) {
	        console.warn('ZIndexManager: You cannot register the element twice.', element);
	        return this.getComponent(element);
	      }

	      var component = new ZIndexComponent(element, options);
	      component.setStack(this);
	      component.setSort(++this.sortCount);
	      this.elements.set(element, component);
	      this.components.add(component);
	      this.sort();
	      return component;
	    }
	  }, {
	    key: "unregister",
	    value: function unregister(element) {
	      var component = this.elements.get(element);
	      this.components["delete"](component);
	      this.elements["delete"](element);
	      this.sort();
	    }
	  }, {
	    key: "getComponent",
	    value: function getComponent(element) {
	      return this.elements.get(element) || null;
	    }
	  }, {
	    key: "getComponents",
	    value: function getComponents() {
	      return this.components.getAll();
	    }
	  }, {
	    key: "getMaxZIndex",
	    value: function getMaxZIndex() {
	      var last = this.components.getLast();
	      return last ? last.getZIndex() : this.baseIndex;
	    }
	  }, {
	    key: "sort",
	    value: function sort() {
	      var _this = this;

	      this.components.sort();
	      var zIndex = this.baseIndex;
	      this.components.forEach(function (component) {
	        component.setZIndex(zIndex);
	        zIndex += _this.baseStep;
	      });
	    }
	  }, {
	    key: "bringToFront",
	    value: function bringToFront(element) {
	      var component = this.getComponent(element);

	      if (!component) {
	        console.error('ZIndexManager: element was not found in the stack.', element);
	        return null;
	      }

	      component.setSort(++this.sortCount);
	      this.sort();
	      return component;
	    }
	  }]);
	  return ZIndexStack;
	}();

	function _classStaticPrivateMethodGet(receiver, classConstructor, method) { _classCheckPrivateStaticAccess(receiver, classConstructor); return method; }

	function _classCheckPrivateStaticAccess(receiver, classConstructor) { if (receiver !== classConstructor) { throw new TypeError("Private static access of wrong provenance"); } }

	/**
	 * @memberof BX
	 */
	var ZIndexManager = /*#__PURE__*/function () {
	  function ZIndexManager() {
	    babelHelpers.classCallCheck(this, ZIndexManager);
	  }

	  babelHelpers.createClass(ZIndexManager, null, [{
	    key: "register",
	    value: function register(element) {
	      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

	      var parentNode = _classStaticPrivateMethodGet(this, ZIndexManager, _getParentNode).call(this, element);

	      if (!parentNode) {
	        return null;
	      }

	      var stack = this.getOrAddStack(parentNode);
	      return stack.register(element, options);
	    }
	  }, {
	    key: "unregister",
	    value: function unregister(element) {
	      var parentNode = _classStaticPrivateMethodGet(this, ZIndexManager, _getParentNode).call(this, element);

	      var stack = this.getStack(parentNode);

	      if (stack) {
	        stack.unregister(element);
	      }
	    }
	  }, {
	    key: "addStack",
	    value: function addStack(container) {
	      var stack = new ZIndexStack(container);
	      this.stacks.set(container, stack);
	      return stack;
	    }
	  }, {
	    key: "getStack",
	    value: function getStack(container) {
	      return this.stacks.get(container) || null;
	    }
	  }, {
	    key: "getOrAddStack",
	    value: function getOrAddStack(container) {
	      return this.getStack(container) || this.addStack(container);
	    }
	  }, {
	    key: "getComponent",
	    value: function getComponent(element) {
	      var parentNode = _classStaticPrivateMethodGet(this, ZIndexManager, _getParentNode).call(this, element, true);

	      if (!parentNode) {
	        return null;
	      }

	      var stack = this.getStack(parentNode);
	      return stack ? stack.getComponent(element) : null;
	    }
	  }, {
	    key: "bringToFront",
	    value: function bringToFront(element) {
	      var parentNode = _classStaticPrivateMethodGet(this, ZIndexManager, _getParentNode).call(this, element);

	      var stack = this.getStack(parentNode);

	      if (stack) {
	        return stack.bringToFront(element);
	      }

	      return null;
	    }
	  }]);
	  return ZIndexManager;
	}();

	function _getParentNode(element) {
	  var suppressWarnings = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

	  if (!Type.isElementNode(element)) {
	    if (!suppressWarnings) {
	      console.error('ZIndexManager: The argument \'element\' must be a DOM element.', element);
	    }

	    return null;
	  } else if (!Type.isElementNode(element.parentNode)) {
	    if (!suppressWarnings) {
	      console.error('ZIndexManager: The \'element\' doesn\'t have a parent node.', element);
	    }

	    return null;
	  }

	  return element.parentNode;
	}

	babelHelpers.defineProperty(ZIndexManager, "stacks", new WeakMap());

	function convertPath(path) {
	  if (Type.isStringFilled(path)) {
	    return path.split('.').reduce(function (acc, item) {
	      item.split(/\[['"]?(.+?)['"]?\]/g).forEach(function (key) {
	        if (Type.isStringFilled(key)) {
	          acc.push(key);
	        }
	      });
	      return acc;
	    }, []);
	  }

	  return [];
	}

	var SettingsCollection = /*#__PURE__*/function () {
	  function SettingsCollection() {
	    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	    babelHelpers.classCallCheck(this, SettingsCollection);

	    if (Type.isPlainObject(options)) {
	      Object.assign(this, options);
	    }
	  }

	  babelHelpers.createClass(SettingsCollection, [{
	    key: "get",
	    value: function get(path) {
	      var defaultValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
	      var convertedPath = convertPath(path);
	      return convertedPath.reduce(function (acc, key) {
	        if (!Type.isNil(acc) && acc !== defaultValue) {
	          if (!Type.isUndefined(acc[key])) {
	            return acc[key];
	          }

	          return defaultValue;
	        }

	        return acc;
	      }, this);
	    }
	  }]);
	  return SettingsCollection;
	}();

	function deepFreeze(target) {
	  if (Type.isObject(target)) {
	    Object.values(target).forEach(function (value) {
	      deepFreeze(value);
	    });
	    return Object.freeze(target);
	  }

	  return target;
	}

	var settingsStorage = new Map();

	var Extension$1 = /*#__PURE__*/function () {
	  function Extension() {
	    babelHelpers.classCallCheck(this, Extension);
	  }

	  babelHelpers.createClass(Extension, null, [{
	    key: "getSettings",
	    value: function getSettings(extensionName) {
	      if (Type.isStringFilled(extensionName)) {
	        if (settingsStorage.has(extensionName)) {
	          return settingsStorage.get(extensionName);
	        }

	        var settingsScriptNode = document.querySelector("script[data-extension=\"".concat(extensionName, "\"]"));

	        if (Type.isDomNode(settingsScriptNode)) {
	          var decodedSettings = function () {
	            try {
	              return new SettingsCollection(JSON.parse(settingsScriptNode.innerHTML));
	            } catch (error) {
	              return new SettingsCollection();
	            }
	          }();

	          var frozenSettings = deepFreeze(decodedSettings);
	          settingsStorage.set(extensionName, frozenSettings);
	          return frozenSettings;
	        }
	      }

	      return deepFreeze(new SettingsCollection());
	    }
	  }]);
	  return Extension;
	}();

	function getElement(element) {
	  if (Type.isString(element)) {
	    return document.getElementById(element);
	  }

	  return element;
	}

	function getWindow(element) {
	  if (Type.isElementNode(element)) {
	    return element.ownerDocument.parentWindow || element.ownerDocument.defaultView || window;
	  }

	  if (Type.isDomNode(element)) {
	    return element.parentWindow || element.defaultView || window;
	  }

	  return window;
	}

	function ownKeys$4(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread$4(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$4(Object(source), !0).forEach(function (key) { babelHelpers.defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$4(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

	var getClass = Reflection.getClass,
	    namespace = Reflection.namespace;
	var message$1 = message;
	/**
	 * @memberOf BX
	 */

	var replace = Dom.replace,
	    remove = Dom.remove,
	    clean = Dom.clean,
	    insertBefore = Dom.insertBefore,
	    insertAfter = Dom.insertAfter,
	    append = Dom.append,
	    prepend = Dom.prepend,
	    style = Dom.style,
	    adjust = Dom.adjust,
	    create = Dom.create,
	    isShown = Dom.isShown;
	var addClass = function addClass() {
	  Dom.addClass.apply(Dom, babelHelpers.toConsumableArray(Runtime.merge([], Array.from(arguments), [getElement(arguments[0])])));
	};
	var removeClass = function removeClass() {
	  Dom.removeClass.apply(Dom, babelHelpers.toConsumableArray(Runtime.merge(Array.from(arguments), [getElement(arguments[0])])));
	};
	var hasClass = function hasClass() {
	  return Dom.hasClass.apply(Dom, babelHelpers.toConsumableArray(Runtime.merge(Array.from(arguments), [getElement(arguments[0])])));
	};
	var toggleClass = function toggleClass() {
	  Dom.toggleClass.apply(Dom, babelHelpers.toConsumableArray(Runtime.merge(Array.from(arguments), [getElement(arguments[0])])));
	};
	var cleanNode = function cleanNode(element) {
	  var removeElement = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
	  var currentElement = getElement(element);

	  if (Type.isDomNode(currentElement)) {
	    Dom.clean(currentElement);

	    if (removeElement) {
	      Dom.remove(currentElement);
	      return currentElement;
	    }
	  }

	  return currentElement;
	};
	var getCookie = Http.Cookie.get;
	var setCookie = function setCookie(name, value) {
	  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

	  var attributes = _objectSpread$4({}, options);

	  if (Type.isNumber(attributes.expires)) {
	    attributes.expires /= 3600 * 24;
	  }

	  Http.Cookie.set(name, value, attributes);
	};
	var bind$1 = Event.bind,
	    unbind$1 = Event.unbind,
	    unbindAll$1 = Event.unbindAll,
	    bindOnce$1 = Event.bindOnce,
	    ready$1 = Event.ready;
	var debugEnableFlag = debugState,
	    debugStatus = isDebugEnabled,
	    debug$1 = debug;
	var debugEnable = function debugEnable(value) {
	  if (value) {
	    enableDebug();
	  } else {
	    disableDebug();
	  }
	};
	var clone$1 = Runtime.clone,
	    loadExt = Runtime.loadExtension,
	    debounce = Runtime.debounce,
	    throttle = Runtime.throttle,
	    html = Runtime.html; // BX.type
	var type = _objectSpread$4(_objectSpread$4({}, Object.getOwnPropertyNames(Type).filter(function (key) {
	  return !['name', 'length', 'prototype', 'caller', 'arguments'].includes(key);
	}).reduce(function (acc, key) {
	  acc[key] = Type[key];
	  return acc;
	}, {})), {}, {
	  isNotEmptyString: function isNotEmptyString(value) {
	    return Type.isString(value) && value !== '';
	  },
	  isNotEmptyObject: function isNotEmptyObject(value) {
	    return Type.isObjectLike(value) && Object.keys(value).length > 0;
	  },
	  isMapKey: Type.isObject,
	  stringToInt: function stringToInt(value) {
	    var parsed = parseInt(value);
	    return !Number.isNaN(parsed) ? parsed : 0;
	  }
	}); // BX.browser

	var browser = {
	  IsOpera: Browser.isOpera,
	  IsIE: Browser.isIE,
	  IsIE6: Browser.isIE6,
	  IsIE7: Browser.isIE7,
	  IsIE8: Browser.isIE8,
	  IsIE9: Browser.isIE9,
	  IsIE10: Browser.isIE10,
	  IsIE11: Browser.isIE11,
	  IsSafari: Browser.isSafari,
	  IsFirefox: Browser.isFirefox,
	  IsChrome: Browser.isChrome,
	  DetectIeVersion: Browser.detectIEVersion,
	  IsMac: Browser.isMac,
	  IsAndroid: Browser.isAndroid,
	  isIPad: Browser.isIPad,
	  isIPhone: Browser.isIPhone,
	  IsIOS: Browser.isIOS,
	  IsMobile: Browser.isMobile,
	  isRetina: Browser.isRetina,
	  IsDoctype: Browser.isDoctype,
	  SupportLocalStorage: Browser.isLocalStorageSupported,
	  addGlobalClass: Browser.addGlobalClass,
	  DetectAndroidVersion: Browser.detectAndroidVersion,
	  isPropertySupported: Browser.isPropertySupported,
	  addGlobalFeatures: Browser.addGlobalFeatures
	}; // eslint-disable-next-line

	var ajax = window.BX ? window.BX.ajax : function () {};
	function GetWindowScrollSize() {
	  var doc = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : document;
	  return {
	    scrollWidth: doc.documentElement.scrollWidth,
	    scrollHeight: doc.documentElement.scrollHeight
	  };
	}
	function GetWindowScrollPos() {
	  var doc = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : document;
	  var win = getWindow(doc);
	  return {
	    scrollLeft: win.pageXOffset,
	    scrollTop: win.pageYOffset
	  };
	}
	function GetWindowInnerSize() {
	  var doc = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : document;
	  var win = getWindow(doc);
	  return {
	    innerWidth: win.innerWidth,
	    innerHeight: win.innerHeight
	  };
	}
	function GetWindowSize() {
	  var doc = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : document;
	  return _objectSpread$4(_objectSpread$4(_objectSpread$4({}, GetWindowInnerSize(doc)), GetWindowScrollPos(doc)), GetWindowScrollSize(doc));
	}
	function GetContext(node) {
	  return getWindow(node);
	}
	function pos(element) {
	  var relative = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

	  if (!element) {
	    return new DOMRect().toJSON();
	  }

	  if (element.ownerDocument === document && !relative) {
	    var clientRect = element.getBoundingClientRect();
	    var root = document.documentElement;
	    var _document = document,
	        body = _document.body;
	    return {
	      top: Math.round(clientRect.top + (root.scrollTop || body.scrollTop)),
	      left: Math.round(clientRect.left + (root.scrollLeft || body.scrollLeft)),
	      width: Math.round(clientRect.right - clientRect.left),
	      height: Math.round(clientRect.bottom - clientRect.top),
	      right: Math.round(clientRect.right + (root.scrollLeft || body.scrollLeft)),
	      bottom: Math.round(clientRect.bottom + (root.scrollTop || body.scrollTop))
	    };
	  }

	  var x = 0;
	  var y = 0;
	  var w = element.offsetWidth;
	  var h = element.offsetHeight;
	  var first = true; // eslint-disable-next-line no-param-reassign

	  for (; element != null; element = element.offsetParent) {
	    if (!first && relative && BX.is_relative(element)) {
	      break;
	    }

	    x += element.offsetLeft;
	    y += element.offsetTop;

	    if (first) {
	      first = false; // eslint-disable-next-line no-continue

	      continue;
	    }

	    x += Text.toNumber(Dom.style(element, 'border-left-width'));
	    y += Text.toNumber(Dom.style(element, 'border-top-width'));
	  }

	  return new DOMRect(x, y, w, h).toJSON();
	}
	function addCustomEvent(eventObject, eventName, eventHandler) {
	  if (Type.isString(eventObject)) {
	    eventHandler = eventName;
	    eventName = eventObject;
	    eventObject = EventEmitter.GLOBAL_TARGET;
	  }

	  if (eventObject === window) {
	    eventObject = EventEmitter.GLOBAL_TARGET;
	  }

	  if (!Type.isObject(eventObject)) {
	    console.error('The "eventObject" argument must be an object. Received type ' + babelHelpers["typeof"](eventObject) + '.');
	    return;
	  }

	  if (!Type.isStringFilled(eventName)) {
	    console.error('The "eventName" argument must be a string.');
	    return;
	  }

	  if (!Type.isFunction(eventHandler)) {
	    console.error('The "eventHandler" argument must be a function. Received type ' + babelHelpers["typeof"](eventHandler) + '.');
	    return;
	  }

	  eventName = eventName.toLowerCase();
	  EventEmitter.subscribe(eventObject, eventName, eventHandler, {
	    compatMode: true,
	    useGlobalNaming: true
	  });
	}
	function onCustomEvent(eventObject, eventName, eventParams, secureParams) {
	  if (Type.isString(eventObject)) {
	    secureParams = eventParams;
	    eventParams = eventName;
	    eventName = eventObject;
	    eventObject = EventEmitter.GLOBAL_TARGET;
	  }

	  if (!Type.isObject(eventObject) || eventObject === window) {
	    eventObject = EventEmitter.GLOBAL_TARGET;
	  }

	  if (!eventParams) {
	    eventParams = [];
	  }

	  eventName = eventName.toLowerCase();
	  var event = new BaseEvent();
	  event.setData(eventParams);
	  event.setCompatData(eventParams);
	  EventEmitter.emit(eventObject, eventName, event, {
	    cloneData: secureParams === true,
	    useGlobalNaming: true
	  });
	}
	function removeCustomEvent(eventObject, eventName, eventHandler) {
	  if (Type.isString(eventObject)) {
	    eventHandler = eventName;
	    eventName = eventObject;
	    eventObject = EventEmitter.GLOBAL_TARGET;
	  }

	  if (!Type.isFunction(eventHandler)) {
	    console.error('The "eventHandler" argument must be a function. Received type ' + babelHelpers["typeof"](eventHandler) + '.');
	    return;
	  }

	  if (eventObject === window) {
	    eventObject = EventEmitter.GLOBAL_TARGET;
	  }

	  eventName = eventName.toLowerCase();
	  EventEmitter.unsubscribe(eventObject, eventName, eventHandler, {
	    useGlobalNaming: true
	  });
	}
	function removeAllCustomEvents(eventObject, eventName) {
	  if (Type.isString(eventObject)) {
	    eventName = eventObject;
	    eventObject = EventEmitter.GLOBAL_TARGET;
	  }

	  if (eventObject === window) {
	    eventObject = EventEmitter.GLOBAL_TARGET;
	  }

	  eventName = eventName.toLowerCase();
	  EventEmitter.unsubscribeAll(eventObject, eventName, {
	    useGlobalNaming: true
	  });
	}

	//import './internal/bx';

	exports.Type = Type;
	exports.Reflection = Reflection;
	exports.Text = Text;
	exports.Dom = Dom;
	exports.Browser = Browser;
	exports.Event = Event;
	exports.Http = Http;
	exports.Runtime = Runtime;
	exports.Loc = Loc;
	exports.Tag = Tag;
	exports.Uri = Uri;
	exports.Validation = Validation;
	exports.Cache = Cache;
	exports.BaseError = BaseError;
	exports.ZIndexManager = ZIndexManager;
	exports.Extension = Extension$1;
	exports.getClass = getClass;
	exports.namespace = namespace;
	exports.message = message$1;
	exports.replace = replace;
	exports.remove = remove;
	exports.clean = clean;
	exports.insertBefore = insertBefore;
	exports.insertAfter = insertAfter;
	exports.append = append;
	exports.prepend = prepend;
	exports.style = style;
	exports.adjust = adjust;
	exports.create = create;
	exports.isShown = isShown;
	exports.addClass = addClass;
	exports.removeClass = removeClass;
	exports.hasClass = hasClass;
	exports.toggleClass = toggleClass;
	exports.cleanNode = cleanNode;
	exports.getCookie = getCookie;
	exports.setCookie = setCookie;
	exports.bind = bind$1;
	exports.unbind = unbind$1;
	exports.unbindAll = unbindAll$1;
	exports.bindOnce = bindOnce$1;
	exports.ready = ready$1;
	exports.debugEnableFlag = debugEnableFlag;
	exports.debugStatus = debugStatus;
	exports.debug = debug$1;
	exports.debugEnable = debugEnable;
	exports.clone = clone$1;
	exports.loadExt = loadExt;
	exports.debounce = debounce;
	exports.throttle = throttle;
	exports.html = html;
	exports.type = type;
	exports.browser = browser;
	exports.ajax = ajax;
	exports.GetWindowScrollSize = GetWindowScrollSize;
	exports.GetWindowScrollPos = GetWindowScrollPos;
	exports.GetWindowInnerSize = GetWindowInnerSize;
	exports.GetWindowSize = GetWindowSize;
	exports.GetContext = GetContext;
	exports.pos = pos;
	exports.addCustomEvent = addCustomEvent;
	exports.onCustomEvent = onCustomEvent;
	exports.removeCustomEvent = removeCustomEvent;
	exports.removeAllCustomEvents = removeAllCustomEvents;

}((this.BX = this.BX || {})));



})();




// file: /bitrix/js/main/polyfill/customevent/main.polyfill.customevent.js
/**
 * window.CustomEvent polyfill
 */
;(function() {
	'use strict';

	try
	{
		new window.CustomEvent('bx-test-custom-event', {
			bubbles: true,
  			cancelable: true
		});
	}
	catch (exception)
	{
		var CustomEventPolyfill = function(event, params)
		{
			params = params || {};
			params.bubbles = !!params.bubbles;
			params.cancelable = !!params.cancelable;

			var customEvent = document.createEvent('CustomEvent');

			customEvent.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);

			var originalPreventFunction = customEvent.preventDefault;

			customEvent.preventDefault = function()
			{
				Object.defineProperty(this, 'defaultPrevented', {
					get: function() { return true; }
				});

				originalPreventFunction.call(this);
			};

			return customEvent;
		};

		CustomEventPolyfill.prototype = window.Event.prototype;

		window.CustomEvent = CustomEventPolyfill;
	}

})();



// file: /bitrix/js/ui/vue/vue2/prod/dist/vue.bundle.js
;(function() {

	if (typeof this.BX !== 'undefined' && typeof this.BX.WidgetVue !== 'undefined')
	{
		var currentVersion = '2.6.14';

		if (this.BX.WidgetVue.version() !== currentVersion)
		{
			console.warn('BX.WidgetVue already loaded. Loaded: ' + this.BX.WidgetVue.version() + ', Skipped: ' + currentVersion + '. Version differences may cause errors!');
		}

		return;
	}

(function (exports,main_core_events,main_core,rest_client,pull_client) {
	'use strict';

	function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { babelHelpers.defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
	var BitrixVue = /*#__PURE__*/function () {
	  function BitrixVue(VueVendor) {
	    babelHelpers.classCallCheck(this, BitrixVue);
	    this._appCounter = 0;
	    this._components = {};
	    this._mutations = {};
	    this._clones = {};
	    this._instance = VueVendor;

	    this._instance.use(this);

	    this.event = new VueVendor();
	    this.events = {
	      restClientChange: 'RestClient::change',
	      pullClientChange: 'PullClient::change'
	    };
	    var settings = main_core.Extension.getSettings('ui.vue');
	    this.localizationMode = settings.get('localizationDebug', false) ? 'development' : 'production';
	  }
	  /**
	   * Create new Vue instance
	   *
	   * @param {Object} params - definition
	   *
	   * @see https://vuejs.org/v2/guide/
	   */


	  babelHelpers.createClass(BitrixVue, [{
	    key: "create",
	    value: function create(params) {
	      BitrixVue.showNotice('Method Vue.create is deprecated, use BitrixVue.createApp instead.\n' + 'If you are using "el" property or .$mount(...) to bind your application, use .mount(...) instead.');
	      return this.createApp(params);
	    }
	    /**
	     * Create new Vue instance
	     *
	     * @param {Object} params - definition
	     *
	     * @see https://v2.vuejs.org/v2/guide/
	     */

	  }, {
	    key: "createApp",
	    value: function createApp(params) {
	      var bitrixVue = this; // 1. Init Bitrix public api

	      var $Bitrix = {}; // 1.1 Localization

	      $Bitrix.Loc = {
	        messages: {},
	        getMessage: function getMessage(messageId) {
	          var replacements = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

	          if (bitrixVue.localizationMode === 'development') {
	            var debugMessageId = [messageId];

	            if (main_core.Type.isPlainObject(replacements)) {
	              var replaceKeys = Object.keys(replacements);

	              if (replaceKeys.length > 0) {
	                debugMessageId = [messageId, ' (replacements: ', replaceKeys.join(', '), ')'];
	              }
	            }

	            return debugMessageId.join('');
	          }

	          var message = '';

	          if (!main_core.Type.isUndefined(this.messages[messageId])) {
	            message = this.messages[messageId];
	          } else {
	            message = main_core.Loc.getMessage(messageId);
	            this.messages[messageId] = message;
	          }

	          if (main_core.Type.isString(message) && main_core.Type.isPlainObject(replacements)) {
	            Object.keys(replacements).forEach(function (replacement) {
	              var globalRegexp = new RegExp(replacement, 'gi');
	              message = message.replace(globalRegexp, function () {
	                return main_core.Type.isNil(replacements[replacement]) ? '' : String(replacements[replacement]);
	              });
	            });
	          }

	          return message;
	        },
	        hasMessage: function hasMessage(messageId) {
	          return main_core.Type.isString(messageId) && !main_core.Type.isNil(this.getMessages()[messageId]);
	        },
	        getMessages: function getMessages() {
	          if (typeof BX.message !== 'undefined') {
	            return _objectSpread(_objectSpread({}, BX.message), this.messages);
	          }

	          return _objectSpread({}, this.messages);
	        },
	        setMessage: function setMessage(id, value) {
	          if (main_core.Type.isString(id)) {
	            this.messages[id] = value;
	          }

	          if (main_core.Type.isObject(id)) {
	            for (var code in id) {
	              if (id.hasOwnProperty(code)) {
	                this.messages[code] = id[code];
	              }
	            }
	          }
	        }
	      }; // 1.2  Application Data

	      $Bitrix.Application = {
	        instance: null,
	        get: function get() {
	          return this.instance;
	        },
	        set: function set(instance) {
	          this.instance = instance;
	        }
	      }; // 1.3  Application Data

	      $Bitrix.Data = {
	        data: {},
	        get: function get(name, defaultValue) {
	          var _this$data$name;

	          return (_this$data$name = this.data[name]) !== null && _this$data$name !== void 0 ? _this$data$name : defaultValue;
	        },
	        set: function set(name, value) {
	          this.data[name] = value;
	        }
	      }; // 1.4  Application EventEmitter

	      $Bitrix.eventEmitter = new main_core_events.EventEmitter();

	      if (typeof $Bitrix.eventEmitter.setEventNamespace === 'function') {
	        this._appCounter++;
	        $Bitrix.eventEmitter.setEventNamespace('vue:app:' + this._appCounter);
	      } else // hack for old version of Bitrix SM
	        {
	          window.BX.Event.EventEmitter.prototype.setEventNamespace = function () {};

	          $Bitrix.eventEmitter.setEventNamespace = function () {};
	        } // 1.5  Application RestClient


	      $Bitrix.RestClient = {
	        instance: null,
	        get: function get() {
	          var _this$instance;

	          return (_this$instance = this.instance) !== null && _this$instance !== void 0 ? _this$instance : rest_client.rest;
	        },
	        set: function set(instance) {
	          this.instance = instance;
	          $Bitrix.eventEmitter.emit(bitrixVue.events.restClientChange);
	        },
	        isCustom: function isCustom() {
	          return this.instance !== null;
	        }
	      }; // 1.6  Application PullClient

	      $Bitrix.PullClient = {
	        instance: null,
	        get: function get() {
	          var _this$instance2;

	          return (_this$instance2 = this.instance) !== null && _this$instance2 !== void 0 ? _this$instance2 : pull_client.PULL;
	        },
	        set: function set(instance) {
	          this.instance = instance;
	          $Bitrix.eventEmitter.emit(bitrixVue.events.pullClientChange);
	        },
	        isCustom: function isCustom() {
	          return this.instance !== null;
	        }
	      };

	      if (typeof params.mixins === 'undefined') {
	        params.mixins = [];
	      }

	      params.mixins.unshift({
	        beforeCreate: function beforeCreate() {
	          this.$bitrix = $Bitrix;
	        }
	      });
	      var instance = new this._instance(params);

	      instance.mount = function (rootContainer) {
	        return this.$mount(rootContainer);
	      };

	      return instance;
	    }
	    /**
	     * Register Vue component
	     *
	     * @param {String} id
	     * @param {Object} params
	     * @param {Object} [options]
	     *
	     * @see https://v2.vuejs.org/v2/guide/components.html
	     */

	  }, {
	    key: "component",
	    value: function component(id, params) {
	      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

	      if (!params.name) {
	        params.name = id;
	      }

	      this._components[id] = Object.assign({}, params);
	      this._components[id].bitrixOptions = {
	        immutable: options.immutable === true,
	        local: options.local === true
	      };

	      if (typeof this._clones[id] !== 'undefined') {
	        this._registerCloneComponent(id);
	      }

	      var componentParams = this._getFinalComponentParams(id);

	      if (this.isLocal(id)) {
	        return componentParams;
	      }

	      return this._instance.component(id, componentParams);
	    }
	    /**
	     * Register Vue component (local)
	     * @see https://v2.vuejs.org/v2/guide/components.html
	     *
	     * @param {string} name
	     * @param {Object} definition
	     * @param {Object} [options]
	     *
	     * @returns {Object}
	     */

	  }, {
	    key: "localComponent",
	    value: function localComponent(name, definition) {
	      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
	      return this.component(name, definition, _objectSpread(_objectSpread({}, options), {}, {
	        local: true
	      }));
	    }
	    /**
	     * Get local Vue component
	     * @see https://v2.vuejs.org/v2/guide/components.html
	     *
	     * @param {string} name
	     *
	     * @returns {Object}
	     */

	  }, {
	    key: "getLocalComponent",
	    value: function getLocalComponent(name) {
	      if (!this.isComponent(name)) {
	        BitrixVue.showNotice('Component "' + name + '" is not registered yet.');
	        return null;
	      }

	      if (!this.isLocal(name)) {
	        BitrixVue.showNotice('You cannot get the component "' + name + '" because it is marked as global.');
	        return null;
	      }

	      return this._getFinalComponentParams(name);
	    }
	    /**
	     * Modify Vue component
	     *
	     * @param {String} id
	     * @param {Object} mutations
	     *
	     * @returns {Function|boolean} - function for remove this modification
	     */

	  }, {
	    key: "mutateComponent",
	    value: function mutateComponent(id, mutations) {
	      var _this = this;

	      var mutable = this.isMutable(id);

	      if (mutable === false) {
	        BitrixVue.showNotice('You cannot mutate the component "' + id + '" because it is marked as immutable, perhaps cloning the component is fine for you.');
	        return false;
	      }

	      if (typeof this._mutations[id] === 'undefined') {
	        this._mutations[id] = [];
	      }

	      this._mutations[id].push(mutations);

	      if (typeof this._components[id] !== 'undefined' && !this.isLocal(id)) {
	        this.component(id, this._components[id], this._components[id].bitrixOptions);
	      }

	      return function () {
	        _this._mutations[id] = _this._mutations[id].filter(function (element) {
	          return element !== mutations;
	        });
	      };
	    }
	    /**
	     * Clone Vue component
	     *
	     * @param {string} id
	     * @param {string} sourceId
	     * @param {object} mutations
	     * @returns {boolean}
	     */

	  }, {
	    key: "cloneComponent",
	    value: function cloneComponent(id, sourceId, mutations) {
	      if (this.isLocal(sourceId)) {
	        var definition = this.getLocalComponent(sourceId);
	        definition.name = id;
	        this.component(id, definition, {
	          immutable: false,
	          local: true
	        });
	        this.mutateComponent(id, mutations);
	        return true;
	      }

	      if (typeof this._clones[sourceId] === 'undefined') {
	        this._clones[sourceId] = {};
	      }

	      this._clones[sourceId][id] = {
	        id: id,
	        sourceId: sourceId,
	        mutations: mutations
	      };

	      if (typeof this._components[sourceId] !== 'undefined') {
	        this._registerCloneComponent(sourceId, id);
	      }

	      return true;
	    }
	    /**
	     * Clone Vue component (object)
	     *
	     * @param {object} source
	     * @param {object} mutations
	     * @returns {object}
	     */

	  }, {
	    key: "cloneLocalComponent",
	    value: function cloneLocalComponent(source, mutations) {
	      if (babelHelpers["typeof"](source) !== 'object') {
	        source = this.getLocalComponent(source);

	        if (!source) {
	          return null;
	        }
	      }

	      return this._applyMutation(this._cloneObjectWithoutDuplicateFunction(source, mutations), mutations);
	    }
	    /**
	     * Check exists Vue component
	     *
	     * @param {string} id
	     * @returns {boolean}
	     */

	  }, {
	    key: "isComponent",
	    value: function isComponent(id) {
	      return typeof this._components[id] !== 'undefined';
	    }
	    /**
	     * Check able to mutate Vue component
	     *
	     * @param id
	     * @returns {boolean|undefined} - undefined when component not registered yet.
	     */

	  }, {
	    key: "isMutable",
	    value: function isMutable(id) {
	      if (typeof this._components[id] === 'undefined') {
	        return undefined;
	      }

	      return !this._components[id].bitrixOptions.immutable;
	    }
	    /**
	     * Check component is a local
	     *
	     * @param id
	     * @returns {boolean|undefined} - undefined when component not registered yet.
	     */

	  }, {
	    key: "isLocal",
	    value: function isLocal(id) {
	      if (typeof this._components[id] === 'undefined') {
	        return undefined;
	      }

	      return this._components[id].bitrixOptions.local === true;
	    }
	    /**
	     * Create a "subclass" of the base Vue constructor.
	     *
	     * @param options
	     * @returns {*}
	     *
	     * @see https://v2.vuejs.org/v2/api/#Vue-extend
	     */

	  }, {
	    key: "extend",
	    value: function extend(options) {
	      return this._instance.extend(options);
	    }
	    /**
	     *	Defer the callback to be executed after the next DOM update cycle. Use it immediately after you have changed some data to wait for the DOM update.
	     *
	     * @param {Function} callback
	     * @param {Object} context
	     * @returns {Promise|void}
	     *
	     * @see https://v2.vuejs.org/v2/api/#Vue-nextTick
	     */

	  }, {
	    key: "nextTick",
	    value: function nextTick(callback, context) {
	      return this._instance.nextTick(callback, context);
	    }
	    /**
	     * Adds a property to a reactive object, ensuring the new property is also reactive, so triggers view updates.
	     *
	     * @param {Object|Array} target
	     * @param {String|Number} key
	     * @param {*} value
	     * @returns {*}
	     *
	     * @see https://v2.vuejs.org/v2/api/#Vue-set
	     */

	  }, {
	    key: "set",
	    value: function set(target, key, value) {
	      return this._instance.set(target, key, value);
	    }
	    /**
	     * Delete a property on an object. If the object is reactive, ensure the deletion triggers view updates.
	     *
	     * @param {Object|Array} target
	     * @param {String|Number} key
	     * @returns {*}
	     */

	  }, {
	    key: "delete",
	    value: function _delete(target, key) {
	      return this._instance["delete"](target, key);
	    }
	    /**
	     * Register or retrieve a global directive.
	     *
	     * @param {String} id
	     * @param {Object|Function} definition
	     * @returns {*}
	     *
	     * @see https://v2.vuejs.org/v2/api/#Vue-directive
	     */

	  }, {
	    key: "directive",
	    value: function directive(id, definition) {
	      return this._instance.directive(id, definition);
	    }
	    /**
	     * Register or retrieve a global filter.
	     *
	     * @param id
	     * @param definition
	     * @returns {*}
	     *
	     * @see https://v2.vuejs.org/v2/api/#Vue-filter
	     */

	  }, {
	    key: "filter",
	    value: function filter(id, definition) {
	      return this._instance.filter(id, definition);
	    }
	    /**
	     * Install a Vue.js plugin.
	     *
	     * @param {Object|Function} plugin
	     * @returns {*}
	     *
	     * @see https://v2.vuejs.org/v2/api/#Vue-use
	     */

	  }, {
	    key: "use",
	    value: function use(plugin) {
	      return this._instance.use(plugin);
	    }
	    /**
	     * Apply a mixin globally, which affects every Vue instance created afterwards.
	     *
	     * @param {Object} mixin
	     * @returns {*|Function|Object}
	     *
	     * @see https://v2.vuejs.org/v2/api/#Vue-mixin
	     */

	  }, {
	    key: "mixin",
	    value: function mixin(_mixin) {
	      return this._instance.mixin(_mixin);
	    }
	    /**
	     * Make an object reactive. Internally, Vue uses this on the object returned by the data function.
	     *
	     * @param object
	     * @returns {*}
	     *
	     * @see https://v2.vuejs.org/v2/api/#Vue-observable
	     */

	  }, {
	    key: "observable",
	    value: function observable(object) {
	      return this._instance.observable(object);
	    }
	    /**
	     * Compiles a template string into a render function.
	     *
	     * @param template
	     * @returns {*}
	     *
	     * @see https://v2.vuejs.org/v2/api/#Vue-compile
	     */

	  }, {
	    key: "compile",
	    value: function compile(template) {
	      return this._instance.compile(template);
	    }
	    /**
	     * Provides the installed version of Vue as a string.
	     *
	     * @returns {String}
	     *
	     * @see https://v2.vuejs.org/v2/api/#Vue-version
	     */

	  }, {
	    key: "version",
	    value: function version() {
	      return this._instance.version;
	    }
	    /**
	     * Test node for compliance with parameters
	     *
	     * @param obj
	     * @param params
	     * @returns {boolean}
	     */

	  }, {
	    key: "testNode",
	    value: function testNode(obj, params) {
	      if (!params || babelHelpers["typeof"](params) !== 'object') {
	        return true;
	      }

	      var i, j, len;

	      for (i in params) {
	        if (!params.hasOwnProperty(i)) {
	          continue;
	        }

	        switch (i) {
	          case 'tag':
	          case 'tagName':
	            if (typeof params[i] === "string") {
	              if (obj.tagName.toUpperCase() !== params[i].toUpperCase()) {
	                return false;
	              }
	            } else if (params[i] instanceof RegExp) {
	              if (!params[i].test(obj.tagName)) {
	                return false;
	              }
	            }

	            break;

	          case 'class':
	          case 'className':
	            if (typeof params[i] === "string") {
	              if (!obj.classList.contains(params[i].trim())) {
	                return false;
	              }
	            } else if (params[i] instanceof RegExp) {
	              if (typeof obj.className !== "string" || !params[i].test(obj.className)) {
	                return false;
	              }
	            }

	            break;

	          case 'attr':
	          case 'attrs':
	          case 'attribute':
	            if (typeof params[i] === "string") {
	              if (!obj.getAttribute(params[i])) {
	                return false;
	              }
	            } else if (params[i] && Object.prototype.toString.call(params[i]) === "[object Array]") {
	              for (j = 0, len = params[i].length; j < len; j++) {
	                if (params[i][j] && !obj.getAttribute(params[i][j])) {
	                  return false;
	                }
	              }
	            } else {
	              for (j in params[i]) {
	                if (!params[i].hasOwnProperty(j)) {
	                  continue;
	                }

	                var value = obj.getAttribute(j);

	                if (typeof value !== "string") {
	                  return false;
	                }

	                if (params[i][j] instanceof RegExp) {
	                  if (!params[i][j].test(value)) {
	                    return false;
	                  }
	                } else if (value !== '' + params[i][j]) {
	                  return false;
	                }
	              }
	            }

	            break;

	          case 'property':
	          case 'props':
	            if (typeof params[i] === "string") {
	              if (!obj[params[i]]) {
	                return false;
	              }
	            } else if (params[i] && Object.prototype.toString.call(params[i]) == "[object Array]") {
	              for (j = 0, len = params[i].length; j < len; j++) {
	                if (params[i][j] && !obj[params[i][j]]) {
	                  return false;
	                }
	              }
	            } else {
	              for (j in params[i]) {
	                if (!params[i].hasOwnProperty(j)) {
	                  continue;
	                }

	                if (typeof params[i][j] === "string") {
	                  if (obj[j] != params[i][j]) {
	                    return false;
	                  }
	                } else if (params[i][j] instanceof RegExp) {
	                  if (typeof obj[j] !== "string" || !params[i][j].test(obj[j])) {
	                    return false;
	                  }
	                }
	              }
	            }

	            break;
	        }
	      }

	      return true;
	    }
	    /**
	     * Getting a part of localization object for insertion into computed property.
	     *
	     * @param {String} phrasePrefix
	     * @param {Object|null} phrases
	     * @returns {ReadonlyArray<any>}
	     */

	  }, {
	    key: "getFilteredPhrases",
	    value: function getFilteredPhrases(phrasePrefix) {
	      var _this2 = this;

	      var phrases = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
	      var result = {};

	      if (!phrases && typeof BX.message !== 'undefined') {
	        phrases = BX.message;
	      } else if (main_core.Type.isObject(phrases) && main_core.Type.isObject(phrases.$Bitrix)) {
	        phrases = phrases.$Bitrix.Loc.getMessages();
	      }

	      if (Array.isArray(phrasePrefix)) {
	        var _loop = function _loop(message) {
	          if (!phrases.hasOwnProperty(message)) {
	            return "continue";
	          }

	          if (!phrasePrefix.find(function (element) {
	            return message.toString().startsWith(element);
	          })) {
	            return "continue";
	          }

	          if (_this2.localizationMode === 'development') {
	            result[message] = message;
	          } else {
	            result[message] = phrases[message];
	          }
	        };

	        for (var message in phrases) {
	          var _ret = _loop(message);

	          if (_ret === "continue") continue;
	        }
	      } else {
	        for (var _message in phrases) {
	          if (!phrases.hasOwnProperty(_message)) {
	            continue;
	          }

	          if (!_message.startsWith(phrasePrefix)) {
	            continue;
	          }

	          if (this.localizationMode === 'development') {
	            result[_message] = _message;
	          } else {
	            result[_message] = phrases[_message];
	          }
	        }
	      }

	      return Object.freeze(result);
	    }
	    /**
	     * Return component params with mutation
	     *
	     * @param {String} componentId
	     * @param {Object} mutations
	     * @returns {null|Object}
	     *
	     * @private
	     */

	  }, {
	    key: "_getComponentParamsWithMutation",
	    value: function _getComponentParamsWithMutation(componentId, mutations) {
	      var _this3 = this;

	      if (typeof this._components[componentId] === 'undefined') {
	        return null;
	      }

	      var componentParams = Object.assign({}, this._components[componentId]);

	      if (typeof mutations === 'undefined') {
	        return componentParams;
	      }

	      mutations.forEach(function (mutation) {
	        componentParams = _this3._applyMutation(_this3._cloneObjectWithoutDuplicateFunction(componentParams, mutation), mutation);
	      });
	      return componentParams;
	    }
	  }, {
	    key: "_getFinalComponentParams",
	    value: function _getFinalComponentParams(id) {
	      var mutations = this.isMutable(id) ? this._mutations[id] : undefined;
	      return this._getComponentParamsWithMutation(id, mutations);
	    }
	    /**
	     * Register clone of components
	     *
	     * @param {String} sourceId
	     * @param {String|null} [id]
	     *
	     * @private
	     */

	  }, {
	    key: "_registerCloneComponent",
	    value: function _registerCloneComponent(sourceId) {
	      var _this4 = this;

	      var id = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
	      var components = [];

	      if (id) {
	        if (typeof this._clones[sourceId][id] !== 'undefined') {
	          components.push(this._clones[sourceId][id]);
	        }
	      } else {
	        for (var cloneId in this._clones[sourceId]) {
	          if (!this._clones[sourceId].hasOwnProperty(cloneId)) {
	            continue;
	          }

	          components.push(this._clones[sourceId][cloneId]);
	        }
	      }

	      components.forEach(function (element) {
	        var mutations = [];

	        if (typeof _this4._mutations[element.sourceId] !== 'undefined') {
	          mutations = mutations.concat(_this4._mutations[element.sourceId]);
	        }

	        mutations.push(element.mutations);

	        var componentParams = _this4._getComponentParamsWithMutation(element.sourceId, mutations);

	        if (!componentParams) {
	          return false;
	        }

	        _this4.component(element.id, componentParams);
	      });
	    }
	    /**
	     * Clone object without duplicate function for apply mutation
	     *
	     * @param objectParams
	     * @param mutation
	     * @param level
	     * @param previousParamName
	     * @private
	     */

	  }, {
	    key: "_cloneObjectWithoutDuplicateFunction",
	    value: function _cloneObjectWithoutDuplicateFunction() {
	      var objectParams = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	      var mutation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	      var level = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
	      var previousParamName = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';
	      var object = {};

	      for (var param in objectParams) {
	        if (!objectParams.hasOwnProperty(param)) {
	          continue;
	        }

	        if (main_core.Type.isString(objectParams[param])) {
	          object[param] = objectParams[param];
	        } else if (main_core.Type.isArray(objectParams[param])) {
	          object[param] = [].concat(objectParams[param]);
	        } else if (main_core.Type.isObjectLike(objectParams[param])) {
	          if (previousParamName === 'watch' || previousParamName === 'props' || previousParamName === 'directives') {
	            object[param] = objectParams[param];
	          } else if (main_core.Type.isNull(objectParams[param])) {
	            object[param] = null;
	          } else if (main_core.Type.isObjectLike(mutation[param])) {
	            object[param] = this._cloneObjectWithoutDuplicateFunction(objectParams[param], mutation[param], level + 1, param);
	          } else {
	            object[param] = Object.assign({}, objectParams[param]);
	          }
	        } else if (main_core.Type.isFunction(objectParams[param])) {
	          if (!main_core.Type.isFunction(mutation[param])) {
	            object[param] = objectParams[param];
	          } else if (level > 1) {
	            if (previousParamName === 'watch') {
	              object[param] = objectParams[param];
	            } else {
	              object['parent' + param[0].toUpperCase() + param.substr(1)] = objectParams[param];
	            }
	          } else {
	            if (main_core.Type.isUndefined(object['methods'])) {
	              object['methods'] = {};
	            }

	            object['methods']['parent' + param[0].toUpperCase() + param.substr(1)] = objectParams[param];

	            if (main_core.Type.isUndefined(objectParams['methods'])) {
	              objectParams['methods'] = {};
	            }

	            objectParams['methods']['parent' + param[0].toUpperCase() + param.substr(1)] = objectParams[param];
	          }
	        } else if (!main_core.Type.isUndefined(objectParams[param])) {
	          object[param] = objectParams[param];
	        }
	      }

	      return object;
	    }
	    /**
	     * Apply mutation
	     *
	     * @param clonedObject
	     * @param mutation
	     * @param level
	     * @private
	     */

	  }, {
	    key: "_applyMutation",
	    value: function _applyMutation() {
	      var _this5 = this;

	      var clonedObject = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	      var mutation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	      var level = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
	      var object = Object.assign({}, clonedObject);

	      var _loop2 = function _loop2(param) {
	        if (!mutation.hasOwnProperty(param)) {
	          return "continue";
	        }

	        if (level === 1 && (param === 'compilerOptions' || param === 'setup')) {
	          object[param] = mutation[param];
	        } else if (level === 1 && param === 'extends') {
	          object[param] = mutation[param];
	        } else if (main_core.Type.isString(mutation[param])) {
	          if (main_core.Type.isString(object[param])) {
	            object[param] = mutation[param].replace("#PARENT_".concat(param.toUpperCase(), "#"), object[param]);
	          } else {
	            object[param] = mutation[param].replace("#PARENT_".concat(param.toUpperCase(), "#"), '');
	          }
	        } else if (main_core.Type.isArray(mutation[param])) {
	          if (level === 1 && param === 'replaceMixins') {
	            object['mixins'] = [].concat(mutation[param]);
	          } else if (level === 1 && param === 'replaceInject') {
	            object['inject'] = [].concat(mutation[param]);
	          } else if (level === 1 && param === 'replaceEmits') {
	            object['emits'] = [].concat(mutation[param]);
	          } else if (level === 1 && param === 'replaceExpose') {
	            object['expose'] = [].concat(mutation[param]);
	          } else if (main_core.Type.isPlainObject(object[param])) {
	            mutation[param].forEach(function (element) {
	              return object[param][element] = null;
	            });
	          } else {
	            object[param] = object[param].concat(mutation[param]);
	          }
	        } else if (main_core.Type.isObjectLike(mutation[param])) {
	          if (level === 1 && param === 'props' && main_core.Type.isArray(object[param]) || level === 1 && param === 'emits' && main_core.Type.isArray(object[param])) {
	            var newObject = {};
	            object[param].forEach(function (element) {
	              newObject[element] = null;
	            });
	            object[param] = newObject;
	          }

	          if (level === 1 && param === 'watch') {
	            for (var paramName in object[param]) {
	              if (!object[param].hasOwnProperty(paramName)) {
	                continue;
	              }

	              if (paramName.includes('.')) {
	                continue;
	              }

	              if (main_core.Type.isFunction(object[param][paramName]) || main_core.Type.isObject(object[param][paramName]) && main_core.Type.isFunction(object[param][paramName]['handler'])) {
	                if (main_core.Type.isUndefined(object['methods'])) {
	                  object['methods'] = {};
	                }

	                var originNewFunctionName = 'parentWatch' + paramName[0].toUpperCase() + paramName.substr(1);

	                if (main_core.Type.isFunction(object[param][paramName])) {
	                  object['methods'][originNewFunctionName] = object[param][paramName];
	                } else {
	                  object['methods'][originNewFunctionName] = object[param][paramName]['handler'];
	                }
	              }
	            }
	          }

	          if (level === 1 && param === 'replaceEmits') {
	            object['emits'] = Object.assign({}, mutation[param]);
	          } else if (level === 1 && (param === 'components' || param === 'directives')) {
	            if (main_core.Type.isUndefined(object[param])) {
	              object[param] = {};
	            }

	            for (var objectName in mutation[param]) {
	              if (!mutation[param].hasOwnProperty(objectName)) {
	                continue;
	              }

	              var parentObjectName = objectName[0].toUpperCase() + objectName.substr(1);
	              parentObjectName = param === 'components' ? 'Parent' + parentObjectName : 'parent' + parentObjectName;
	              object[param][parentObjectName] = Object.assign({}, object[param][objectName]);

	              if (param === 'components') {
	                if (main_core.Type.isUndefined(mutation[param][objectName].components)) {
	                  mutation[param][objectName].components = {};
	                }

	                mutation[param][objectName].components = Object.assign(babelHelpers.defineProperty({}, parentObjectName, object[param][objectName]), mutation[param][objectName].components);
	              }

	              object[param][objectName] = mutation[param][objectName];
	            }
	          } else if (main_core.Type.isArray(object[param])) {
	            for (var mutationName in mutation[param]) {
	              if (!mutation[param].hasOwnProperty(mutationName)) {
	                continue;
	              }

	              object[param].push(mutationName);
	            }
	          } else if (main_core.Type.isObjectLike(object[param])) {
	            object[param] = _this5._applyMutation(object[param], mutation[param], level + 1);
	          } else {
	            object[param] = mutation[param];
	          }
	        } else {
	          object[param] = mutation[param];
	        }
	      };

	      for (var param in mutation) {
	        var _ret2 = _loop2(param);

	        if (_ret2 === "continue") continue;
	      }

	      return object;
	    }
	    /**
	     * @private
	     * @param text
	     */

	  }, {
	    key: "install",

	    /**
	     * @deprecated Special method for plugin registration
	     */
	    value: function install(app, options) {
	      app.mixin({
	        beforeCreate: function beforeCreate() {
	          if (typeof this.$root !== 'undefined') {
	            this.$bitrix = this.$root.$bitrix;
	          }
	        },
	        computed: {
	          $Bitrix: function $Bitrix() {
	            return this.$root.$bitrix;
	          }
	        },
	        mounted: function mounted() {
	          if (!main_core.Type.isNil(this.$root.$bitrixApplication)) {
	            BitrixVue.showNotice("Store reference in global variables (like: this.$bitrixApplication) is deprecated, use this.$Bitrix.Data.set(...) instead.");
	          }

	          if (!main_core.Type.isNil(this.$root.$bitrixController)) {
	            BitrixVue.showNotice("Store reference in global variables (like: this.$bitrixController) is deprecated, use this.$Bitrix.Data.set(...) instead.");
	          }

	          if (!main_core.Type.isNil(this.$root.$bitrixMessages)) {
	            BitrixVue.showNotice("Store localization in global variable this.$bitrixMessages is deprecated, use this.$Bitrix.Log.setMessage(...) instead.");
	          }

	          if (!main_core.Type.isNil(this.$root.$bitrixRestClient)) {
	            BitrixVue.showNotice("Working with a Rest-client through an old variable this.$bitrixRestClient is deprecated, use this.$Bitrix.RestClient.get() instead.");
	          }

	          if (!main_core.Type.isNil(this.$root.$bitrixPullClient)) {
	            BitrixVue.showNotice("Working with a Pull-client through an old variable this.$bitrixPullClient is deprecated, use this.$Bitrix.PullClient.get() instead.");
	          }
	        }
	      });
	    }
	  }], [{
	    key: "showNotice",
	    value: function showNotice(text) {
	      if (BitrixVue.developerMode) {
	        console.warn('BitrixVue: ' + text);
	      }
	    }
	  }]);
	  return BitrixVue;
	}();
	babelHelpers.defineProperty(BitrixVue, "developerMode", false);

	/*!
	 * Vue.js v2.6.14
	 * (c) 2014-2021 Evan You
	 * Released under the MIT License.
	 *
	 * @source: https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.esm.browser.min.js
	 */

	/**
	 * Modify list for integration with Bitrix Framework:
	 * - change default export to local for work in Bitrix CoreJS extensions;
	 */
	// origin-start
	var t = Object.freeze({});

	function e(t) {
	  return null == t;
	}

	function n(t) {
	  return null != t;
	}

	function o(t) {
	  return !0 === t;
	}

	function r(t) {
	  return "string" == typeof t || "number" == typeof t || "symbol" == babelHelpers["typeof"](t) || "boolean" == typeof t;
	}

	function s(t) {
	  return null !== t && "object" == babelHelpers["typeof"](t);
	}

	var i = Object.prototype.toString;

	function a(t) {
	  return "[object Object]" === i.call(t);
	}

	function c(t) {
	  var e = parseFloat(String(t));
	  return e >= 0 && Math.floor(e) === e && isFinite(t);
	}

	function l(t) {
	  return n(t) && "function" == typeof t.then && "function" == typeof t["catch"];
	}

	function u(t) {
	  return null == t ? "" : Array.isArray(t) || a(t) && t.toString === i ? JSON.stringify(t, null, 2) : String(t);
	}

	function f(t) {
	  var e = parseFloat(t);
	  return isNaN(e) ? t : e;
	}

	function d(t, e) {
	  var n = Object.create(null),
	      o = t.split(",");

	  for (var _t2 = 0; _t2 < o.length; _t2++) {
	    n[o[_t2]] = !0;
	  }

	  return e ? function (t) {
	    return n[t.toLowerCase()];
	  } : function (t) {
	    return n[t];
	  };
	}

	var p = d("slot,component", !0),
	    h = d("key,ref,slot,slot-scope,is");

	function m(t, e) {
	  if (t.length) {
	    var _n2 = t.indexOf(e);

	    if (_n2 > -1) return t.splice(_n2, 1);
	  }
	}

	var y = Object.prototype.hasOwnProperty;

	function g(t, e) {
	  return y.call(t, e);
	}

	function v(t) {
	  var e = Object.create(null);
	  return function (n) {
	    return e[n] || (e[n] = t(n));
	  };
	}

	var $ = /-(\w)/g,
	    _ = v(function (t) {
	  return t.replace($, function (t, e) {
	    return e ? e.toUpperCase() : "";
	  });
	}),
	    b = v(function (t) {
	  return t.charAt(0).toUpperCase() + t.slice(1);
	}),
	    w = /\B([A-Z])/g,
	    C = v(function (t) {
	  return t.replace(w, "-$1").toLowerCase();
	});

	var x = Function.prototype.bind ? function (t, e) {
	  return t.bind(e);
	} : function (t, e) {
	  function n(n) {
	    var o = arguments.length;
	    return o ? o > 1 ? t.apply(e, arguments) : t.call(e, n) : t.call(e);
	  }

	  return n._length = t.length, n;
	};

	function k(t, e) {
	  e = e || 0;
	  var n = t.length - e;
	  var o = new Array(n);

	  for (; n--;) {
	    o[n] = t[n + e];
	  }

	  return o;
	}

	function A(t, e) {
	  for (var _n3 in e) {
	    t[_n3] = e[_n3];
	  }

	  return t;
	}

	function O(t) {
	  var e = {};

	  for (var _n4 = 0; _n4 < t.length; _n4++) {
	    t[_n4] && A(e, t[_n4]);
	  }

	  return e;
	}

	function S(t, e, n) {}

	var T = function T(t, e, n) {
	  return !1;
	},
	    N = function N(t) {
	  return t;
	};

	function E(t, e) {
	  if (t === e) return !0;
	  var n = s(t),
	      o = s(e);
	  if (!n || !o) return !n && !o && String(t) === String(e);

	  try {
	    var _n5 = Array.isArray(t),
	        _o2 = Array.isArray(e);

	    if (_n5 && _o2) return t.length === e.length && t.every(function (t, n) {
	      return E(t, e[n]);
	    });
	    if (t instanceof Date && e instanceof Date) return t.getTime() === e.getTime();
	    if (_n5 || _o2) return !1;
	    {
	      var _n6 = Object.keys(t),
	          _o3 = Object.keys(e);

	      return _n6.length === _o3.length && _n6.every(function (n) {
	        return E(t[n], e[n]);
	      });
	    }
	  } catch (t) {
	    return !1;
	  }
	}

	function j(t, e) {
	  for (var _n7 = 0; _n7 < t.length; _n7++) {
	    if (E(t[_n7], e)) return _n7;
	  }

	  return -1;
	}

	function D(t) {
	  var e = !1;
	  return function () {
	    e || (e = !0, t.apply(this, arguments));
	  };
	}

	var L = "data-server-rendered",
	    I = ["component", "directive", "filter"],
	    M = ["beforeCreate", "created", "beforeMount", "mounted", "beforeUpdate", "updated", "beforeDestroy", "destroyed", "activated", "deactivated", "errorCaptured", "serverPrefetch"];
	var F = {
	  optionMergeStrategies: Object.create(null),
	  silent: !1,
	  productionTip: !1,
	  devtools: !1,
	  performance: !1,
	  errorHandler: null,
	  warnHandler: null,
	  ignoredElements: [],
	  keyCodes: Object.create(null),
	  isReservedTag: T,
	  isReservedAttr: T,
	  isUnknownElement: T,
	  getTagNamespace: S,
	  parsePlatformTagName: N,
	  mustUseProp: T,
	  async: !0,
	  _lifecycleHooks: M
	};
	var P = /a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;

	function R(t) {
	  var e = (t + "").charCodeAt(0);
	  return 36 === e || 95 === e;
	}

	function H(t, e, n, o) {
	  Object.defineProperty(t, e, {
	    value: n,
	    enumerable: !!o,
	    writable: !0,
	    configurable: !0
	  });
	}

	var B = new RegExp("[^".concat(P.source, ".$_\\d]"));
	var U = ("__proto__" in {}),
	    V = "undefined" != typeof window,
	    z = "undefined" != typeof WXEnvironment && !!WXEnvironment.platform,
	    K = z && WXEnvironment.platform.toLowerCase(),
	    J = V && window.navigator.userAgent.toLowerCase(),
	    q = J && /msie|trident/.test(J),
	    W = J && J.indexOf("msie 9.0") > 0,
	    Z = J && J.indexOf("edge/") > 0,
	    G = (J && J.indexOf("android"), J && /iphone|ipad|ipod|ios/.test(J) || "ios" === K),
	    X = (J && /chrome\/\d+/.test(J), J && /phantomjs/.test(J), J && J.match(/firefox\/(\d+)/)),
	    Y = {}.watch;
	var Q,
	    tt = !1;
	if (V) try {
	  var _t3 = {};
	  Object.defineProperty(_t3, "passive", {
	    get: function get() {
	      tt = !0;
	    }
	  }), window.addEventListener("test-passive", null, _t3);
	} catch (t) {}

	var et = function et() {
	  return void 0 === Q && (Q = !V && !z && "undefined" != typeof global && global.process && "server" === global.process.env.VUE_ENV), Q;
	},
	    nt = V && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;

	function ot(t) {
	  return "function" == typeof t && /native code/.test(t.toString());
	}

	var rt = "undefined" != typeof Symbol && ot(Symbol) && "undefined" != typeof Reflect && ot(Reflect.ownKeys);
	var st;
	st = "undefined" != typeof Set && ot(Set) ? Set : /*#__PURE__*/function () {
	  function _class() {
	    babelHelpers.classCallCheck(this, _class);
	    this.set = Object.create(null);
	  }

	  babelHelpers.createClass(_class, [{
	    key: "has",
	    value: function has(t) {
	      return !0 === this.set[t];
	    }
	  }, {
	    key: "add",
	    value: function add(t) {
	      this.set[t] = !0;
	    }
	  }, {
	    key: "clear",
	    value: function clear() {
	      this.set = Object.create(null);
	    }
	  }]);
	  return _class;
	}();
	var it = S,
	    at = 0;

	var ct = /*#__PURE__*/function () {
	  function ct() {
	    babelHelpers.classCallCheck(this, ct);
	    this.id = at++, this.subs = [];
	  }

	  babelHelpers.createClass(ct, [{
	    key: "addSub",
	    value: function addSub(t) {
	      this.subs.push(t);
	    }
	  }, {
	    key: "removeSub",
	    value: function removeSub(t) {
	      m(this.subs, t);
	    }
	  }, {
	    key: "depend",
	    value: function depend() {
	      ct.target && ct.target.addDep(this);
	    }
	  }, {
	    key: "notify",
	    value: function notify() {
	      var t = this.subs.slice();

	      for (var _e2 = 0, _n8 = t.length; _e2 < _n8; _e2++) {
	        t[_e2].update();
	      }
	    }
	  }]);
	  return ct;
	}();

	ct.target = null;
	var lt = [];

	function ut(t) {
	  lt.push(t), ct.target = t;
	}

	function ft() {
	  lt.pop(), ct.target = lt[lt.length - 1];
	}

	var dt = /*#__PURE__*/function () {
	  function dt(t, e, n, o, r, s, i, a) {
	    babelHelpers.classCallCheck(this, dt);
	    this.tag = t, this.data = e, this.children = n, this.text = o, this.elm = r, this.ns = void 0, this.context = s, this.fnContext = void 0, this.fnOptions = void 0, this.fnScopeId = void 0, this.key = e && e.key, this.componentOptions = i, this.componentInstance = void 0, this.parent = void 0, this.raw = !1, this.isStatic = !1, this.isRootInsert = !0, this.isComment = !1, this.isCloned = !1, this.isOnce = !1, this.asyncFactory = a, this.asyncMeta = void 0, this.isAsyncPlaceholder = !1;
	  }

	  babelHelpers.createClass(dt, [{
	    key: "child",
	    get: function get() {
	      return this.componentInstance;
	    }
	  }]);
	  return dt;
	}();

	var pt = function pt() {
	  var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
	  var e = new dt();
	  return e.text = t, e.isComment = !0, e;
	};

	function ht(t) {
	  return new dt(void 0, void 0, void 0, String(t));
	}

	function mt(t) {
	  var e = new dt(t.tag, t.data, t.children && t.children.slice(), t.text, t.elm, t.context, t.componentOptions, t.asyncFactory);
	  return e.ns = t.ns, e.isStatic = t.isStatic, e.key = t.key, e.isComment = t.isComment, e.fnContext = t.fnContext, e.fnOptions = t.fnOptions, e.fnScopeId = t.fnScopeId, e.asyncMeta = t.asyncMeta, e.isCloned = !0, e;
	}

	var yt = Array.prototype,
	    gt = Object.create(yt);
	["push", "pop", "shift", "unshift", "splice", "sort", "reverse"].forEach(function (t) {
	  var e = yt[t];
	  H(gt, t, function () {
	    for (var _len = arguments.length, n = new Array(_len), _key = 0; _key < _len; _key++) {
	      n[_key] = arguments[_key];
	    }

	    var o = e.apply(this, n),
	        r = this.__ob__;
	    var s;

	    switch (t) {
	      case "push":
	      case "unshift":
	        s = n;
	        break;

	      case "splice":
	        s = n.slice(2);
	    }

	    return s && r.observeArray(s), r.dep.notify(), o;
	  });
	});
	var vt = Object.getOwnPropertyNames(gt);
	var $t = !0;

	function _t(t) {
	  $t = t;
	}

	var bt = /*#__PURE__*/function () {
	  function bt(t) {
	    babelHelpers.classCallCheck(this, bt);
	    var e;
	    this.value = t, this.dep = new ct(), this.vmCount = 0, H(t, "__ob__", this), Array.isArray(t) ? (U ? (e = gt, t.__proto__ = e) : function (t, e, n) {
	      for (var _o4 = 0, _r2 = n.length; _o4 < _r2; _o4++) {
	        var _r3 = n[_o4];
	        H(t, _r3, e[_r3]);
	      }
	    }(t, gt, vt), this.observeArray(t)) : this.walk(t);
	  }

	  babelHelpers.createClass(bt, [{
	    key: "walk",
	    value: function walk(t) {
	      var e = Object.keys(t);

	      for (var _n9 = 0; _n9 < e.length; _n9++) {
	        Ct(t, e[_n9]);
	      }
	    }
	  }, {
	    key: "observeArray",
	    value: function observeArray(t) {
	      for (var _e3 = 0, _n10 = t.length; _e3 < _n10; _e3++) {
	        wt(t[_e3]);
	      }
	    }
	  }]);
	  return bt;
	}();

	function wt(t, e) {
	  if (!s(t) || t instanceof dt) return;
	  var n;
	  return g(t, "__ob__") && t.__ob__ instanceof bt ? n = t.__ob__ : $t && !et() && (Array.isArray(t) || a(t)) && Object.isExtensible(t) && !t._isVue && (n = new bt(t)), e && n && n.vmCount++, n;
	}

	function Ct(t, e, n, o, r) {
	  var s = new ct(),
	      i = Object.getOwnPropertyDescriptor(t, e);
	  if (i && !1 === i.configurable) return;
	  var a = i && i.get,
	      c = i && i.set;
	  a && !c || 2 !== arguments.length || (n = t[e]);
	  var l = !r && wt(n);
	  Object.defineProperty(t, e, {
	    enumerable: !0,
	    configurable: !0,
	    get: function get() {
	      var e = a ? a.call(t) : n;
	      return ct.target && (s.depend(), l && (l.dep.depend(), Array.isArray(e) && function t(e) {
	        for (var _n11, _o5 = 0, _r4 = e.length; _o5 < _r4; _o5++) {
	          (_n11 = e[_o5]) && _n11.__ob__ && _n11.__ob__.dep.depend(), Array.isArray(_n11) && t(_n11);
	        }
	      }(e))), e;
	    },
	    set: function set(e) {
	      var o = a ? a.call(t) : n;
	      e === o || e != e && o != o || a && !c || (c ? c.call(t, e) : n = e, l = !r && wt(e), s.notify());
	    }
	  });
	}

	function xt(t, e, n) {
	  if (Array.isArray(t) && c(e)) return t.length = Math.max(t.length, e), t.splice(e, 1, n), n;
	  if (e in t && !(e in Object.prototype)) return t[e] = n, n;
	  var o = t.__ob__;
	  return t._isVue || o && o.vmCount ? n : o ? (Ct(o.value, e, n), o.dep.notify(), n) : (t[e] = n, n);
	}

	function kt(t, e) {
	  if (Array.isArray(t) && c(e)) return void t.splice(e, 1);
	  var n = t.__ob__;
	  t._isVue || n && n.vmCount || g(t, e) && (delete t[e], n && n.dep.notify());
	}

	var At = F.optionMergeStrategies;

	function Ot(t, e) {
	  if (!e) return t;
	  var n, o, r;
	  var s = rt ? Reflect.ownKeys(e) : Object.keys(e);

	  for (var _i2 = 0; _i2 < s.length; _i2++) {
	    "__ob__" !== (n = s[_i2]) && (o = t[n], r = e[n], g(t, n) ? o !== r && a(o) && a(r) && Ot(o, r) : xt(t, n, r));
	  }

	  return t;
	}

	function St(t, e, n) {
	  return n ? function () {
	    var o = "function" == typeof e ? e.call(n, n) : e,
	        r = "function" == typeof t ? t.call(n, n) : t;
	    return o ? Ot(o, r) : r;
	  } : e ? t ? function () {
	    return Ot("function" == typeof e ? e.call(this, this) : e, "function" == typeof t ? t.call(this, this) : t);
	  } : e : t;
	}

	function Tt(t, e) {
	  var n = e ? t ? t.concat(e) : Array.isArray(e) ? e : [e] : t;
	  return n ? function (t) {
	    var e = [];

	    for (var _n12 = 0; _n12 < t.length; _n12++) {
	      -1 === e.indexOf(t[_n12]) && e.push(t[_n12]);
	    }

	    return e;
	  }(n) : n;
	}

	function Nt(t, e, n, o) {
	  var r = Object.create(t || null);
	  return e ? A(r, e) : r;
	}

	At.data = function (t, e, n) {
	  return n ? St(t, e, n) : e && "function" != typeof e ? t : St(t, e);
	}, M.forEach(function (t) {
	  At[t] = Tt;
	}), I.forEach(function (t) {
	  At[t + "s"] = Nt;
	}), At.watch = function (t, e, n, o) {
	  if (t === Y && (t = void 0), e === Y && (e = void 0), !e) return Object.create(t || null);
	  if (!t) return e;
	  var r = {};
	  A(r, t);

	  for (var _t4 in e) {
	    var _n13 = r[_t4];
	    var _o6 = e[_t4];
	    _n13 && !Array.isArray(_n13) && (_n13 = [_n13]), r[_t4] = _n13 ? _n13.concat(_o6) : Array.isArray(_o6) ? _o6 : [_o6];
	  }

	  return r;
	}, At.props = At.methods = At.inject = At.computed = function (t, e, n, o) {
	  if (!t) return e;
	  var r = Object.create(null);
	  return A(r, t), e && A(r, e), r;
	}, At.provide = St;

	var Et = function Et(t, e) {
	  return void 0 === e ? t : e;
	};

	function jt(t, e, n) {
	  if ("function" == typeof e && (e = e.options), function (t, e) {
	    var n = t.props;
	    if (!n) return;
	    var o = {};
	    var r, s, i;
	    if (Array.isArray(n)) for (r = n.length; r--;) {
	      "string" == typeof (s = n[r]) && (o[i = _(s)] = {
	        type: null
	      });
	    } else if (a(n)) for (var _t5 in n) {
	      s = n[_t5], o[i = _(_t5)] = a(s) ? s : {
	        type: s
	      };
	    }
	    t.props = o;
	  }(e), function (t, e) {
	    var n = t.inject;
	    if (!n) return;
	    var o = t.inject = {};
	    if (Array.isArray(n)) for (var _t6 = 0; _t6 < n.length; _t6++) {
	      o[n[_t6]] = {
	        from: n[_t6]
	      };
	    } else if (a(n)) for (var _t7 in n) {
	      var _e4 = n[_t7];
	      o[_t7] = a(_e4) ? A({
	        from: _t7
	      }, _e4) : {
	        from: _e4
	      };
	    }
	  }(e), function (t) {
	    var e = t.directives;
	    if (e) for (var _t8 in e) {
	      var _n14 = e[_t8];
	      "function" == typeof _n14 && (e[_t8] = {
	        bind: _n14,
	        update: _n14
	      });
	    }
	  }(e), !e._base && (e["extends"] && (t = jt(t, e["extends"], n)), e.mixins)) for (var _o7 = 0, _r5 = e.mixins.length; _o7 < _r5; _o7++) {
	    t = jt(t, e.mixins[_o7], n);
	  }
	  var o = {};
	  var r;

	  for (r in t) {
	    s(r);
	  }

	  for (r in e) {
	    g(t, r) || s(r);
	  }

	  function s(r) {
	    var s = At[r] || Et;
	    o[r] = s(t[r], e[r], n, r);
	  }

	  return o;
	}

	function Dt(t, e, n, o) {
	  if ("string" != typeof n) return;
	  var r = t[e];
	  if (g(r, n)) return r[n];

	  var s = _(n);

	  if (g(r, s)) return r[s];
	  var i = b(s);
	  return g(r, i) ? r[i] : r[n] || r[s] || r[i];
	}

	function Lt(t, e, n, o) {
	  var r = e[t],
	      s = !g(n, t);
	  var i = n[t];
	  var a = Pt(Boolean, r.type);
	  if (a > -1) if (s && !g(r, "default")) i = !1;else if ("" === i || i === C(t)) {
	    var _t9 = Pt(String, r.type);

	    (_t9 < 0 || a < _t9) && (i = !0);
	  }

	  if (void 0 === i) {
	    i = function (t, e, n) {
	      if (!g(e, "default")) return;
	      var o = e["default"];
	      if (t && t.$options.propsData && void 0 === t.$options.propsData[n] && void 0 !== t._props[n]) return t._props[n];
	      return "function" == typeof o && "Function" !== Mt(e.type) ? o.call(t) : o;
	    }(o, r, t);

	    var _e5 = $t;
	    _t(!0), wt(i), _t(_e5);
	  }

	  return i;
	}

	var It = /^\s*function (\w+)/;

	function Mt(t) {
	  var e = t && t.toString().match(It);
	  return e ? e[1] : "";
	}

	function Ft(t, e) {
	  return Mt(t) === Mt(e);
	}

	function Pt(t, e) {
	  if (!Array.isArray(e)) return Ft(e, t) ? 0 : -1;

	  for (var _n15 = 0, _o8 = e.length; _n15 < _o8; _n15++) {
	    if (Ft(e[_n15], t)) return _n15;
	  }

	  return -1;
	}

	function Rt(t, e, n) {
	  ut();

	  try {
	    if (e) {
	      var _o9 = e;

	      for (; _o9 = _o9.$parent;) {
	        var _r6 = _o9.$options.errorCaptured;
	        if (_r6) for (var _s2 = 0; _s2 < _r6.length; _s2++) {
	          try {
	            if (!1 === _r6[_s2].call(_o9, t, e, n)) return;
	          } catch (t) {
	            Bt(t, _o9, "errorCaptured hook");
	          }
	        }
	      }
	    }

	    Bt(t, e, n);
	  } finally {
	    ft();
	  }
	}

	function Ht(t, e, n, o, r) {
	  var s;

	  try {
	    (s = n ? t.apply(e, n) : t.call(e)) && !s._isVue && l(s) && !s._handled && (s["catch"](function (t) {
	      return Rt(t, o, r + " (Promise/async)");
	    }), s._handled = !0);
	  } catch (t) {
	    Rt(t, o, r);
	  }

	  return s;
	}

	function Bt(t, e, n) {
	  if (F.errorHandler) try {
	    return F.errorHandler.call(null, t, e, n);
	  } catch (e) {
	    e !== t && Ut(e, null, "config.errorHandler");
	  }
	  Ut(t, e, n);
	}

	function Ut(t, e, n) {
	  if (!V && !z || "undefined" == typeof console) throw t;
	  console.error(t);
	}

	var Vt = !1;
	var zt = [];
	var Kt,
	    Jt = !1;

	function qt() {
	  Jt = !1;
	  var t = zt.slice(0);
	  zt.length = 0;

	  for (var _e6 = 0; _e6 < t.length; _e6++) {
	    t[_e6]();
	  }
	}

	if ("undefined" != typeof Promise && ot(Promise)) {
	  var _t10 = Promise.resolve();

	  Kt = function Kt() {
	    _t10.then(qt), G && setTimeout(S);
	  }, Vt = !0;
	} else if (q || "undefined" == typeof MutationObserver || !ot(MutationObserver) && "[object MutationObserverConstructor]" !== MutationObserver.toString()) Kt = "undefined" != typeof setImmediate && ot(setImmediate) ? function () {
	  setImmediate(qt);
	} : function () {
	  setTimeout(qt, 0);
	};else {
	  var _t11 = 1;

	  var _e7 = new MutationObserver(qt),
	      _n16 = document.createTextNode(String(_t11));

	  _e7.observe(_n16, {
	    characterData: !0
	  }), Kt = function Kt() {
	    _t11 = (_t11 + 1) % 2, _n16.data = String(_t11);
	  }, Vt = !0;
	}

	function Wt(t, e) {
	  var n;
	  if (zt.push(function () {
	    if (t) try {
	      t.call(e);
	    } catch (t) {
	      Rt(t, e, "nextTick");
	    } else n && n(e);
	  }), Jt || (Jt = !0, Kt()), !t && "undefined" != typeof Promise) return new Promise(function (t) {
	    n = t;
	  });
	}

	var Zt = new st();

	function Gt(t) {
	  !function t(e, n) {
	    var o, r;
	    var i = Array.isArray(e);
	    if (!i && !s(e) || Object.isFrozen(e) || e instanceof dt) return;

	    if (e.__ob__) {
	      var _t12 = e.__ob__.dep.id;
	      if (n.has(_t12)) return;
	      n.add(_t12);
	    }

	    if (i) for (o = e.length; o--;) {
	      t(e[o], n);
	    } else for (r = Object.keys(e), o = r.length; o--;) {
	      t(e[r[o]], n);
	    }
	  }(t, Zt), Zt.clear();
	}

	var Xt = v(function (t) {
	  var e = "&" === t.charAt(0),
	      n = "~" === (t = e ? t.slice(1) : t).charAt(0),
	      o = "!" === (t = n ? t.slice(1) : t).charAt(0);
	  return {
	    name: t = o ? t.slice(1) : t,
	    once: n,
	    capture: o,
	    passive: e
	  };
	});

	function Yt(t, e) {
	  function n() {
	    var t = n.fns;
	    if (!Array.isArray(t)) return Ht(t, null, arguments, e, "v-on handler");
	    {
	      var _n17 = t.slice();

	      for (var _t13 = 0; _t13 < _n17.length; _t13++) {
	        Ht(_n17[_t13], null, arguments, e, "v-on handler");
	      }
	    }
	  }

	  return n.fns = t, n;
	}

	function Qt(t, n, r, s, i, a) {
	  var c, l, u, f, d;

	  for (c in t) {
	    l = u = t[c], f = n[c], d = Xt(c), e(u) || (e(f) ? (e(u.fns) && (u = t[c] = Yt(u, a)), o(d.once) && (u = t[c] = i(d.name, u, d.capture)), r(d.name, u, d.capture, d.passive, d.params)) : u !== f && (f.fns = u, t[c] = f));
	  }

	  for (c in n) {
	    e(t[c]) && s((d = Xt(c)).name, n[c], d.capture);
	  }
	}

	function te(t, r, s) {
	  var i;
	  t instanceof dt && (t = t.data.hook || (t.data.hook = {}));
	  var a = t[r];

	  function c() {
	    s.apply(this, arguments), m(i.fns, c);
	  }

	  e(a) ? i = Yt([c]) : n(a.fns) && o(a.merged) ? (i = a).fns.push(c) : i = Yt([a, c]), i.merged = !0, t[r] = i;
	}

	function ee(t, e, o, r, s) {
	  if (n(e)) {
	    if (g(e, o)) return t[o] = e[o], s || delete e[o], !0;
	    if (g(e, r)) return t[o] = e[r], s || delete e[r], !0;
	  }

	  return !1;
	}

	function ne(t) {
	  return r(t) ? [ht(t)] : Array.isArray(t) ? function t(s, i) {
	    var a = [];
	    var c, l, u, f;

	    for (c = 0; c < s.length; c++) {
	      e(l = s[c]) || "boolean" == typeof l || (u = a.length - 1, f = a[u], Array.isArray(l) ? l.length > 0 && (oe((l = t(l, "".concat(i || "", "_").concat(c)))[0]) && oe(f) && (a[u] = ht(f.text + l[0].text), l.shift()), a.push.apply(a, l)) : r(l) ? oe(f) ? a[u] = ht(f.text + l) : "" !== l && a.push(ht(l)) : oe(l) && oe(f) ? a[u] = ht(f.text + l.text) : (o(s._isVList) && n(l.tag) && e(l.key) && n(i) && (l.key = "__vlist".concat(i, "_").concat(c, "__")), a.push(l)));
	    }

	    return a;
	  }(t) : void 0;
	}

	function oe(t) {
	  return n(t) && n(t.text) && !1 === t.isComment;
	}

	function re(t, e) {
	  if (t) {
	    var _n18 = Object.create(null),
	        _o10 = rt ? Reflect.ownKeys(t) : Object.keys(t);

	    for (var _r7 = 0; _r7 < _o10.length; _r7++) {
	      var _s3 = _o10[_r7];
	      if ("__ob__" === _s3) continue;
	      var _i3 = t[_s3].from;
	      var _a = e;

	      for (; _a;) {
	        if (_a._provided && g(_a._provided, _i3)) {
	          _n18[_s3] = _a._provided[_i3];
	          break;
	        }

	        _a = _a.$parent;
	      }

	      if (!_a && "default" in t[_s3]) {
	        var _o11 = t[_s3]["default"];
	        _n18[_s3] = "function" == typeof _o11 ? _o11.call(e) : _o11;
	      }
	    }

	    return _n18;
	  }
	}

	function se(t, e) {
	  if (!t || !t.length) return {};
	  var n = {};

	  for (var _o12 = 0, _r8 = t.length; _o12 < _r8; _o12++) {
	    var _r9 = t[_o12],
	        _s4 = _r9.data;
	    if (_s4 && _s4.attrs && _s4.attrs.slot && delete _s4.attrs.slot, _r9.context !== e && _r9.fnContext !== e || !_s4 || null == _s4.slot) (n["default"] || (n["default"] = [])).push(_r9);else {
	      var _t14 = _s4.slot,
	          _e8 = n[_t14] || (n[_t14] = []);

	      "template" === _r9.tag ? _e8.push.apply(_e8, _r9.children || []) : _e8.push(_r9);
	    }
	  }

	  for (var _t15 in n) {
	    n[_t15].every(ie) && delete n[_t15];
	  }

	  return n;
	}

	function ie(t) {
	  return t.isComment && !t.asyncFactory || " " === t.text;
	}

	function ae(t) {
	  return t.isComment && t.asyncFactory;
	}

	function ce(e, n, o) {
	  var r;
	  var s = Object.keys(n).length > 0,
	      i = e ? !!e.$stable : !s,
	      a = e && e.$key;

	  if (e) {
	    if (e._normalized) return e._normalized;
	    if (i && o && o !== t && a === o.$key && !s && !o.$hasNormal) return o;
	    r = {};

	    for (var _t16 in e) {
	      e[_t16] && "$" !== _t16[0] && (r[_t16] = le(n, _t16, e[_t16]));
	    }
	  } else r = {};

	  for (var _t17 in n) {
	    _t17 in r || (r[_t17] = ue(n, _t17));
	  }

	  return e && Object.isExtensible(e) && (e._normalized = r), H(r, "$stable", i), H(r, "$key", a), H(r, "$hasNormal", s), r;
	}

	function le(t, e, n) {
	  var o = function o() {
	    var t = arguments.length ? n.apply(null, arguments) : n({}),
	        e = (t = t && "object" == babelHelpers["typeof"](t) && !Array.isArray(t) ? [t] : ne(t)) && t[0];
	    return t && (!e || 1 === t.length && e.isComment && !ae(e)) ? void 0 : t;
	  };

	  return n.proxy && Object.defineProperty(t, e, {
	    get: o,
	    enumerable: !0,
	    configurable: !0
	  }), o;
	}

	function ue(t, e) {
	  return function () {
	    return t[e];
	  };
	}

	function fe(t, e) {
	  var o, r, i, a, c;
	  if (Array.isArray(t) || "string" == typeof t) for (o = new Array(t.length), r = 0, i = t.length; r < i; r++) {
	    o[r] = e(t[r], r);
	  } else if ("number" == typeof t) for (o = new Array(t), r = 0; r < t; r++) {
	    o[r] = e(r + 1, r);
	  } else if (s(t)) if (rt && t[Symbol.iterator]) {
	    o = [];

	    var _n19 = t[Symbol.iterator]();

	    var _r10 = _n19.next();

	    for (; !_r10.done;) {
	      o.push(e(_r10.value, o.length)), _r10 = _n19.next();
	    }
	  } else for (a = Object.keys(t), o = new Array(a.length), r = 0, i = a.length; r < i; r++) {
	    c = a[r], o[r] = e(t[c], c, r);
	  }
	  return n(o) || (o = []), o._isVList = !0, o;
	}

	function de(t, e, n, o) {
	  var r = this.$scopedSlots[t];
	  var s;
	  r ? (n = n || {}, o && (n = A(A({}, o), n)), s = r(n) || ("function" == typeof e ? e() : e)) : s = this.$slots[t] || ("function" == typeof e ? e() : e);
	  var i = n && n.slot;
	  return i ? this.$createElement("template", {
	    slot: i
	  }, s) : s;
	}

	function pe(t) {
	  return Dt(this.$options, "filters", t) || N;
	}

	function he(t, e) {
	  return Array.isArray(t) ? -1 === t.indexOf(e) : t !== e;
	}

	function me(t, e, n, o, r) {
	  var s = F.keyCodes[e] || n;
	  return r && o && !F.keyCodes[e] ? he(r, o) : s ? he(s, t) : o ? C(o) !== e : void 0 === t;
	}

	function ye(t, e, n, o, r) {
	  if (n) if (s(n)) {
	    var _s5;

	    Array.isArray(n) && (n = O(n));

	    var _loop = function _loop(_i4) {
	      if ("class" === _i4 || "style" === _i4 || h(_i4)) _s5 = t;else {
	        var _n20 = t.attrs && t.attrs.type;

	        _s5 = o || F.mustUseProp(e, _n20, _i4) ? t.domProps || (t.domProps = {}) : t.attrs || (t.attrs = {});
	      }

	      var a = _(_i4),
	          c = C(_i4);

	      if (!(a in _s5 || c in _s5) && (_s5[_i4] = n[_i4], r)) {
	        (t.on || (t.on = {}))["update:".concat(_i4)] = function (t) {
	          n[_i4] = t;
	        };
	      }
	    };

	    for (var _i4 in n) {
	      _loop(_i4);
	    }
	  }
	  return t;
	}

	function ge(t, e) {
	  var n = this._staticTrees || (this._staticTrees = []);
	  var o = n[t];
	  return o && !e ? o : ($e(o = n[t] = this.$options.staticRenderFns[t].call(this._renderProxy, null, this), "__static__".concat(t), !1), o);
	}

	function ve(t, e, n) {
	  return $e(t, "__once__".concat(e).concat(n ? "_".concat(n) : ""), !0), t;
	}

	function $e(t, e, n) {
	  if (Array.isArray(t)) for (var _o13 = 0; _o13 < t.length; _o13++) {
	    t[_o13] && "string" != typeof t[_o13] && _e(t[_o13], "".concat(e, "_").concat(_o13), n);
	  } else _e(t, e, n);
	}

	function _e(t, e, n) {
	  t.isStatic = !0, t.key = e, t.isOnce = n;
	}

	function be(t, e) {
	  if (e) if (a(e)) {
	    var _n21 = t.on = t.on ? A({}, t.on) : {};

	    for (var _t18 in e) {
	      var _o14 = _n21[_t18],
	          _r11 = e[_t18];
	      _n21[_t18] = _o14 ? [].concat(_o14, _r11) : _r11;
	    }
	  }
	  return t;
	}

	function we(t, e, n, o) {
	  e = e || {
	    $stable: !n
	  };

	  for (var _o15 = 0; _o15 < t.length; _o15++) {
	    var _r12 = t[_o15];
	    Array.isArray(_r12) ? we(_r12, e, n) : _r12 && (_r12.proxy && (_r12.fn.proxy = !0), e[_r12.key] = _r12.fn);
	  }

	  return o && (e.$key = o), e;
	}

	function Ce(t, e) {
	  for (var _n22 = 0; _n22 < e.length; _n22 += 2) {
	    var _o16 = e[_n22];
	    "string" == typeof _o16 && _o16 && (t[e[_n22]] = e[_n22 + 1]);
	  }

	  return t;
	}

	function xe(t, e) {
	  return "string" == typeof t ? e + t : t;
	}

	function ke(t) {
	  t._o = ve, t._n = f, t._s = u, t._l = fe, t._t = de, t._q = E, t._i = j, t._m = ge, t._f = pe, t._k = me, t._b = ye, t._v = ht, t._e = pt, t._u = we, t._g = be, t._d = Ce, t._p = xe;
	}

	function Ae(e, n, r, s, i) {
	  var _this = this;

	  var a = i.options;
	  var c;
	  g(s, "_uid") ? (c = Object.create(s))._original = s : (c = s, s = s._original);
	  var l = o(a._compiled),
	      u = !l;
	  this.data = e, this.props = n, this.children = r, this.parent = s, this.listeners = e.on || t, this.injections = re(a.inject, s), this.slots = function () {
	    return _this.$slots || ce(e.scopedSlots, _this.$slots = se(r, s)), _this.$slots;
	  }, Object.defineProperty(this, "scopedSlots", {
	    enumerable: !0,
	    get: function get() {
	      return ce(e.scopedSlots, this.slots());
	    }
	  }), l && (this.$options = a, this.$slots = this.slots(), this.$scopedSlots = ce(e.scopedSlots, this.$slots)), a._scopeId ? this._c = function (t, e, n, o) {
	    var r = Ie(c, t, e, n, o, u);
	    return r && !Array.isArray(r) && (r.fnScopeId = a._scopeId, r.fnContext = s), r;
	  } : this._c = function (t, e, n, o) {
	    return Ie(c, t, e, n, o, u);
	  };
	}

	function Oe(t, e, n, o, r) {
	  var s = mt(t);
	  return s.fnContext = n, s.fnOptions = o, e.slot && ((s.data || (s.data = {})).slot = e.slot), s;
	}

	function Se(t, e) {
	  for (var _n23 in e) {
	    t[_(_n23)] = e[_n23];
	  }
	}

	ke(Ae.prototype);
	var Te = {
	  init: function init(t, e) {
	    if (t.componentInstance && !t.componentInstance._isDestroyed && t.data.keepAlive) {
	      var _e9 = t;
	      Te.prepatch(_e9, _e9);
	    } else {
	      (t.componentInstance = function (t, e) {
	        var o = {
	          _isComponent: !0,
	          _parentVnode: t,
	          parent: e
	        },
	            r = t.data.inlineTemplate;
	        n(r) && (o.render = r.render, o.staticRenderFns = r.staticRenderFns);
	        return new t.componentOptions.Ctor(o);
	      }(t, ze)).$mount(e ? t.elm : void 0, e);
	    }
	  },
	  prepatch: function prepatch(e, n) {
	    var o = n.componentOptions;
	    !function (e, n, o, r, s) {
	      var i = r.data.scopedSlots,
	          a = e.$scopedSlots,
	          c = !!(i && !i.$stable || a !== t && !a.$stable || i && e.$scopedSlots.$key !== i.$key || !i && e.$scopedSlots.$key),
	          l = !!(s || e.$options._renderChildren || c);
	      e.$options._parentVnode = r, e.$vnode = r, e._vnode && (e._vnode.parent = r);

	      if (e.$options._renderChildren = s, e.$attrs = r.data.attrs || t, e.$listeners = o || t, n && e.$options.props) {
	        _t(!1);

	        var _t19 = e._props,
	            _o17 = e.$options._propKeys || [];

	        for (var _r13 = 0; _r13 < _o17.length; _r13++) {
	          var _s6 = _o17[_r13],
	              _i5 = e.$options.props;
	          _t19[_s6] = Lt(_s6, _i5, n, e);
	        }

	        _t(!0), e.$options.propsData = n;
	      }

	      o = o || t;
	      var u = e.$options._parentListeners;
	      e.$options._parentListeners = o, Ve(e, o, u), l && (e.$slots = se(s, r.context), e.$forceUpdate());
	    }(n.componentInstance = e.componentInstance, o.propsData, o.listeners, n, o.children);
	  },
	  insert: function insert(t) {
	    var e = t.context,
	        n = t.componentInstance;
	    var o;
	    n._isMounted || (n._isMounted = !0, We(n, "mounted")), t.data.keepAlive && (e._isMounted ? ((o = n)._inactive = !1, Ge.push(o)) : qe(n, !0));
	  },
	  destroy: function destroy(t) {
	    var e = t.componentInstance;
	    e._isDestroyed || (t.data.keepAlive ? function t(e, n) {
	      if (n && (e._directInactive = !0, Je(e))) return;

	      if (!e._inactive) {
	        e._inactive = !0;

	        for (var _n24 = 0; _n24 < e.$children.length; _n24++) {
	          t(e.$children[_n24]);
	        }

	        We(e, "deactivated");
	      }
	    }(e, !0) : e.$destroy());
	  }
	},
	    Ne = Object.keys(Te);

	function Ee(r, i, a, c, u) {
	  if (e(r)) return;
	  var f = a.$options._base;
	  if (s(r) && (r = f.extend(r)), "function" != typeof r) return;
	  var d;
	  if (e(r.cid) && void 0 === (r = function (t, r) {
	    if (o(t.error) && n(t.errorComp)) return t.errorComp;
	    if (n(t.resolved)) return t.resolved;
	    var i = Fe;
	    i && n(t.owners) && -1 === t.owners.indexOf(i) && t.owners.push(i);
	    if (o(t.loading) && n(t.loadingComp)) return t.loadingComp;

	    if (i && !n(t.owners)) {
	      var _o18 = t.owners = [i];

	      var _a2 = !0,
	          _c = null,
	          _u = null;

	      i.$on("hook:destroyed", function () {
	        return m(_o18, i);
	      });

	      var _f = function _f(t) {
	        for (var _t20 = 0, _e10 = _o18.length; _t20 < _e10; _t20++) {
	          _o18[_t20].$forceUpdate();
	        }

	        t && (_o18.length = 0, null !== _c && (clearTimeout(_c), _c = null), null !== _u && (clearTimeout(_u), _u = null));
	      },
	          _d = D(function (e) {
	        t.resolved = Pe(e, r), _a2 ? _o18.length = 0 : _f(!0);
	      }),
	          _p = D(function (e) {
	        n(t.errorComp) && (t.error = !0, _f(!0));
	      }),
	          _h = t(_d, _p);

	      return s(_h) && (l(_h) ? e(t.resolved) && _h.then(_d, _p) : l(_h.component) && (_h.component.then(_d, _p), n(_h.error) && (t.errorComp = Pe(_h.error, r)), n(_h.loading) && (t.loadingComp = Pe(_h.loading, r), 0 === _h.delay ? t.loading = !0 : _c = setTimeout(function () {
	        _c = null, e(t.resolved) && e(t.error) && (t.loading = !0, _f(!1));
	      }, _h.delay || 200)), n(_h.timeout) && (_u = setTimeout(function () {
	        _u = null, e(t.resolved) && _p(null);
	      }, _h.timeout)))), _a2 = !1, t.loading ? t.loadingComp : t.resolved;
	    }
	  }(d = r, f))) return function (t, e, n, o, r) {
	    var s = pt();
	    return s.asyncFactory = t, s.asyncMeta = {
	      data: e,
	      context: n,
	      children: o,
	      tag: r
	    }, s;
	  }(d, i, a, c, u);
	  i = i || {}, yn(r), n(i.model) && function (t, e) {
	    var o = t.model && t.model.prop || "value",
	        r = t.model && t.model.event || "input";
	    (e.attrs || (e.attrs = {}))[o] = e.model.value;
	    var s = e.on || (e.on = {}),
	        i = s[r],
	        a = e.model.callback;
	    n(i) ? (Array.isArray(i) ? -1 === i.indexOf(a) : i !== a) && (s[r] = [a].concat(i)) : s[r] = a;
	  }(r.options, i);

	  var p = function (t, o, r) {
	    var s = o.options.props;
	    if (e(s)) return;
	    var i = {},
	        a = t.attrs,
	        c = t.props;
	    if (n(a) || n(c)) for (var _t21 in s) {
	      var _e11 = C(_t21);

	      ee(i, c, _t21, _e11, !0) || ee(i, a, _t21, _e11, !1);
	    }
	    return i;
	  }(i, r);

	  if (o(r.options.functional)) return function (e, o, r, s, i) {
	    var a = e.options,
	        c = {},
	        l = a.props;
	    if (n(l)) for (var _e12 in l) {
	      c[_e12] = Lt(_e12, l, o || t);
	    } else n(r.attrs) && Se(c, r.attrs), n(r.props) && Se(c, r.props);
	    var u = new Ae(r, c, i, s, e),
	        f = a.render.call(null, u._c, u);
	    if (f instanceof dt) return Oe(f, r, u.parent, a);

	    if (Array.isArray(f)) {
	      var _t22 = ne(f) || [],
	          _e13 = new Array(_t22.length);

	      for (var _n25 = 0; _n25 < _t22.length; _n25++) {
	        _e13[_n25] = Oe(_t22[_n25], r, u.parent, a);
	      }

	      return _e13;
	    }
	  }(r, p, i, a, c);
	  var h = i.on;

	  if (i.on = i.nativeOn, o(r.options["abstract"])) {
	    var _t23 = i.slot;
	    i = {}, _t23 && (i.slot = _t23);
	  }

	  !function (t) {
	    var e = t.hook || (t.hook = {});

	    for (var _t24 = 0; _t24 < Ne.length; _t24++) {
	      var _n26 = Ne[_t24],
	          _o19 = e[_n26],
	          _r14 = Te[_n26];
	      _o19 === _r14 || _o19 && _o19._merged || (e[_n26] = _o19 ? je(_r14, _o19) : _r14);
	    }
	  }(i);
	  var y = r.options.name || u;
	  return new dt("vue-component-".concat(r.cid).concat(y ? "-".concat(y) : ""), i, void 0, void 0, void 0, a, {
	    Ctor: r,
	    propsData: p,
	    listeners: h,
	    tag: u,
	    children: c
	  }, d);
	}

	function je(t, e) {
	  var n = function n(_n27, o) {
	    t(_n27, o), e(_n27, o);
	  };

	  return n._merged = !0, n;
	}

	var De = 1,
	    Le = 2;

	function Ie(t, i, a, c, l, u) {
	  return (Array.isArray(a) || r(a)) && (l = c, c = a, a = void 0), o(u) && (l = Le), function (t, r, i, a, c) {
	    if (n(i) && n(i.__ob__)) return pt();
	    n(i) && n(i.is) && (r = i.is);
	    if (!r) return pt();
	    Array.isArray(a) && "function" == typeof a[0] && ((i = i || {}).scopedSlots = {
	      "default": a[0]
	    }, a.length = 0);
	    c === Le ? a = ne(a) : c === De && (a = function (t) {
	      for (var _e14 = 0; _e14 < t.length; _e14++) {
	        if (Array.isArray(t[_e14])) return Array.prototype.concat.apply([], t);
	      }

	      return t;
	    }(a));
	    var l, u;

	    if ("string" == typeof r) {
	      var _e15;

	      u = t.$vnode && t.$vnode.ns || F.getTagNamespace(r), l = F.isReservedTag(r) ? new dt(F.parsePlatformTagName(r), i, a, void 0, void 0, t) : i && i.pre || !n(_e15 = Dt(t.$options, "components", r)) ? new dt(r, i, a, void 0, void 0, t) : Ee(_e15, i, t, a, r);
	    } else l = Ee(r, i, t, a);

	    return Array.isArray(l) ? l : n(l) ? (n(u) && function t(r, s, i) {
	      r.ns = s;
	      "foreignObject" === r.tag && (s = void 0, i = !0);
	      if (n(r.children)) for (var _a3 = 0, _c2 = r.children.length; _a3 < _c2; _a3++) {
	        var _c3 = r.children[_a3];
	        n(_c3.tag) && (e(_c3.ns) || o(i) && "svg" !== _c3.tag) && t(_c3, s, i);
	      }
	    }(l, u), n(i) && function (t) {
	      s(t.style) && Gt(t.style);
	      s(t["class"]) && Gt(t["class"]);
	    }(i), l) : pt();
	  }(t, i, a, c, l);
	}

	var Me,
	    Fe = null;

	function Pe(t, e) {
	  return (t.__esModule || rt && "Module" === t[Symbol.toStringTag]) && (t = t["default"]), s(t) ? e.extend(t) : t;
	}

	function Re(t) {
	  if (Array.isArray(t)) for (var _e16 = 0; _e16 < t.length; _e16++) {
	    var _o20 = t[_e16];
	    if (n(_o20) && (n(_o20.componentOptions) || ae(_o20))) return _o20;
	  }
	}

	function He(t, e) {
	  Me.$on(t, e);
	}

	function Be(t, e) {
	  Me.$off(t, e);
	}

	function Ue(t, e) {
	  var n = Me;
	  return function o() {
	    null !== e.apply(null, arguments) && n.$off(t, o);
	  };
	}

	function Ve(t, e, n) {
	  Me = t, Qt(e, n || {}, He, Be, Ue, t), Me = void 0;
	}

	var ze = null;

	function Ke(t) {
	  var e = ze;
	  return ze = t, function () {
	    ze = e;
	  };
	}

	function Je(t) {
	  for (; t && (t = t.$parent);) {
	    if (t._inactive) return !0;
	  }

	  return !1;
	}

	function qe(t, e) {
	  if (e) {
	    if (t._directInactive = !1, Je(t)) return;
	  } else if (t._directInactive) return;

	  if (t._inactive || null === t._inactive) {
	    t._inactive = !1;

	    for (var _e17 = 0; _e17 < t.$children.length; _e17++) {
	      qe(t.$children[_e17]);
	    }

	    We(t, "activated");
	  }
	}

	function We(t, e) {
	  ut();
	  var n = t.$options[e],
	      o = "".concat(e, " hook");
	  if (n) for (var _e18 = 0, _r15 = n.length; _e18 < _r15; _e18++) {
	    Ht(n[_e18], t, null, t, o);
	  }
	  t._hasHookEvent && t.$emit("hook:" + e), ft();
	}

	var Ze = [],
	    Ge = [];
	var Xe = {},
	    Ye = !1,
	    Qe = !1,
	    tn = 0;
	var en = 0,
	    nn = Date.now;

	if (V && !q) {
	  var _t25 = window.performance;
	  _t25 && "function" == typeof _t25.now && nn() > document.createEvent("Event").timeStamp && (nn = function nn() {
	    return _t25.now();
	  });
	}

	function on() {
	  var t, e;

	  for (en = nn(), Qe = !0, Ze.sort(function (t, e) {
	    return t.id - e.id;
	  }), tn = 0; tn < Ze.length; tn++) {
	    (t = Ze[tn]).before && t.before(), e = t.id, Xe[e] = null, t.run();
	  }

	  var n = Ge.slice(),
	      o = Ze.slice();
	  tn = Ze.length = Ge.length = 0, Xe = {}, Ye = Qe = !1, function (t) {
	    for (var _e19 = 0; _e19 < t.length; _e19++) {
	      t[_e19]._inactive = !0, qe(t[_e19], !0);
	    }
	  }(n), function (t) {
	    var e = t.length;

	    for (; e--;) {
	      var _n28 = t[e],
	          _o21 = _n28.vm;
	      _o21._watcher === _n28 && _o21._isMounted && !_o21._isDestroyed && We(_o21, "updated");
	    }
	  }(o), nt && F.devtools && nt.emit("flush");
	}

	var rn = 0;

	var sn = /*#__PURE__*/function () {
	  function sn(t, e, n, o, r) {
	    babelHelpers.classCallCheck(this, sn);
	    this.vm = t, r && (t._watcher = this), t._watchers.push(this), o ? (this.deep = !!o.deep, this.user = !!o.user, this.lazy = !!o.lazy, this.sync = !!o.sync, this.before = o.before) : this.deep = this.user = this.lazy = this.sync = !1, this.cb = n, this.id = ++rn, this.active = !0, this.dirty = this.lazy, this.deps = [], this.newDeps = [], this.depIds = new st(), this.newDepIds = new st(), this.expression = "", "function" == typeof e ? this.getter = e : (this.getter = function (t) {
	      if (B.test(t)) return;
	      var e = t.split(".");
	      return function (t) {
	        for (var _n29 = 0; _n29 < e.length; _n29++) {
	          if (!t) return;
	          t = t[e[_n29]];
	        }

	        return t;
	      };
	    }(e), this.getter || (this.getter = S)), this.value = this.lazy ? void 0 : this.get();
	  }

	  babelHelpers.createClass(sn, [{
	    key: "get",
	    value: function get() {
	      var t;
	      ut(this);
	      var e = this.vm;

	      try {
	        t = this.getter.call(e, e);
	      } catch (t) {
	        if (!this.user) throw t;
	        Rt(t, e, "getter for watcher \"".concat(this.expression, "\""));
	      } finally {
	        this.deep && Gt(t), ft(), this.cleanupDeps();
	      }

	      return t;
	    }
	  }, {
	    key: "addDep",
	    value: function addDep(t) {
	      var e = t.id;
	      this.newDepIds.has(e) || (this.newDepIds.add(e), this.newDeps.push(t), this.depIds.has(e) || t.addSub(this));
	    }
	  }, {
	    key: "cleanupDeps",
	    value: function cleanupDeps() {
	      var t = this.deps.length;

	      for (; t--;) {
	        var _e20 = this.deps[t];
	        this.newDepIds.has(_e20.id) || _e20.removeSub(this);
	      }

	      var e = this.depIds;
	      this.depIds = this.newDepIds, this.newDepIds = e, this.newDepIds.clear(), e = this.deps, this.deps = this.newDeps, this.newDeps = e, this.newDeps.length = 0;
	    }
	  }, {
	    key: "update",
	    value: function update() {
	      this.lazy ? this.dirty = !0 : this.sync ? this.run() : function (t) {
	        var e = t.id;

	        if (null == Xe[e]) {
	          if (Xe[e] = !0, Qe) {
	            var _e21 = Ze.length - 1;

	            for (; _e21 > tn && Ze[_e21].id > t.id;) {
	              _e21--;
	            }

	            Ze.splice(_e21 + 1, 0, t);
	          } else Ze.push(t);

	          Ye || (Ye = !0, Wt(on));
	        }
	      }(this);
	    }
	  }, {
	    key: "run",
	    value: function run() {
	      if (this.active) {
	        var _t26 = this.get();

	        if (_t26 !== this.value || s(_t26) || this.deep) {
	          var _e22 = this.value;

	          if (this.value = _t26, this.user) {
	            var _n30 = "callback for watcher \"".concat(this.expression, "\"");

	            Ht(this.cb, this.vm, [_t26, _e22], this.vm, _n30);
	          } else this.cb.call(this.vm, _t26, _e22);
	        }
	      }
	    }
	  }, {
	    key: "evaluate",
	    value: function evaluate() {
	      this.value = this.get(), this.dirty = !1;
	    }
	  }, {
	    key: "depend",
	    value: function depend() {
	      var t = this.deps.length;

	      for (; t--;) {
	        this.deps[t].depend();
	      }
	    }
	  }, {
	    key: "teardown",
	    value: function teardown() {
	      if (this.active) {
	        this.vm._isBeingDestroyed || m(this.vm._watchers, this);
	        var _t27 = this.deps.length;

	        for (; _t27--;) {
	          this.deps[_t27].removeSub(this);
	        }

	        this.active = !1;
	      }
	    }
	  }]);
	  return sn;
	}();

	var an = {
	  enumerable: !0,
	  configurable: !0,
	  get: S,
	  set: S
	};

	function cn(t, e, n) {
	  an.get = function () {
	    return this[e][n];
	  }, an.set = function (t) {
	    this[e][n] = t;
	  }, Object.defineProperty(t, n, an);
	}

	function ln(t) {
	  t._watchers = [];
	  var e = t.$options;
	  e.props && function (t, e) {
	    var n = t.$options.propsData || {},
	        o = t._props = {},
	        r = t.$options._propKeys = [];
	    t.$parent && _t(!1);

	    for (var _s7 in e) {
	      r.push(_s7);

	      var _i6 = Lt(_s7, e, n, t);

	      Ct(o, _s7, _i6), _s7 in t || cn(t, "_props", _s7);
	    }

	    _t(!0);
	  }(t, e.props), e.methods && function (t, e) {
	    t.$options.props;

	    for (var _n31 in e) {
	      t[_n31] = "function" != typeof e[_n31] ? S : x(e[_n31], t);
	    }
	  }(t, e.methods), e.data ? function (t) {
	    var e = t.$options.data;
	    a(e = t._data = "function" == typeof e ? function (t, e) {
	      ut();

	      try {
	        return t.call(e, e);
	      } catch (t) {
	        return Rt(t, e, "data()"), {};
	      } finally {
	        ft();
	      }
	    }(e, t) : e || {}) || (e = {});
	    var n = Object.keys(e),
	        o = t.$options.props;
	    t.$options.methods;
	    var r = n.length;

	    for (; r--;) {
	      var _e23 = n[r];
	      o && g(o, _e23) || R(_e23) || cn(t, "_data", _e23);
	    }

	    wt(e, !0);
	  }(t) : wt(t._data = {}, !0), e.computed && function (t, e) {
	    var n = t._computedWatchers = Object.create(null),
	        o = et();

	    for (var _r16 in e) {
	      var _s8 = e[_r16],
	          _i7 = "function" == typeof _s8 ? _s8 : _s8.get;

	      o || (n[_r16] = new sn(t, _i7 || S, S, un)), _r16 in t || fn(t, _r16, _s8);
	    }
	  }(t, e.computed), e.watch && e.watch !== Y && function (t, e) {
	    for (var _n32 in e) {
	      var _o22 = e[_n32];
	      if (Array.isArray(_o22)) for (var _e24 = 0; _e24 < _o22.length; _e24++) {
	        hn(t, _n32, _o22[_e24]);
	      } else hn(t, _n32, _o22);
	    }
	  }(t, e.watch);
	}

	var un = {
	  lazy: !0
	};

	function fn(t, e, n) {
	  var o = !et();
	  "function" == typeof n ? (an.get = o ? dn(e) : pn(n), an.set = S) : (an.get = n.get ? o && !1 !== n.cache ? dn(e) : pn(n.get) : S, an.set = n.set || S), Object.defineProperty(t, e, an);
	}

	function dn(t) {
	  return function () {
	    var e = this._computedWatchers && this._computedWatchers[t];
	    if (e) return e.dirty && e.evaluate(), ct.target && e.depend(), e.value;
	  };
	}

	function pn(t) {
	  return function () {
	    return t.call(this, this);
	  };
	}

	function hn(t, e, n, o) {
	  return a(n) && (o = n, n = n.handler), "string" == typeof n && (n = t[n]), t.$watch(e, n, o);
	}

	var mn = 0;

	function yn(t) {
	  var e = t.options;

	  if (t["super"]) {
	    var _n33 = yn(t["super"]);

	    if (_n33 !== t.superOptions) {
	      t.superOptions = _n33;

	      var _o23 = function (t) {
	        var e;
	        var n = t.options,
	            o = t.sealedOptions;

	        for (var _t28 in n) {
	          n[_t28] !== o[_t28] && (e || (e = {}), e[_t28] = n[_t28]);
	        }

	        return e;
	      }(t);

	      _o23 && A(t.extendOptions, _o23), (e = t.options = jt(_n33, t.extendOptions)).name && (e.components[e.name] = t);
	    }
	  }

	  return e;
	}

	function gn(t) {
	  this._init(t);
	}

	function vn(t) {
	  t.cid = 0;
	  var e = 1;

	  t.extend = function (t) {
	    t = t || {};
	    var n = this,
	        o = n.cid,
	        r = t._Ctor || (t._Ctor = {});
	    if (r[o]) return r[o];

	    var s = t.name || n.options.name,
	        i = function i(t) {
	      this._init(t);
	    };

	    return (i.prototype = Object.create(n.prototype)).constructor = i, i.cid = e++, i.options = jt(n.options, t), i["super"] = n, i.options.props && function (t) {
	      var e = t.options.props;

	      for (var _n34 in e) {
	        cn(t.prototype, "_props", _n34);
	      }
	    }(i), i.options.computed && function (t) {
	      var e = t.options.computed;

	      for (var _n35 in e) {
	        fn(t.prototype, _n35, e[_n35]);
	      }
	    }(i), i.extend = n.extend, i.mixin = n.mixin, i.use = n.use, I.forEach(function (t) {
	      i[t] = n[t];
	    }), s && (i.options.components[s] = i), i.superOptions = n.options, i.extendOptions = t, i.sealedOptions = A({}, i.options), r[o] = i, i;
	  };
	}

	function $n(t) {
	  return t && (t.Ctor.options.name || t.tag);
	}

	function _n(t, e) {
	  return Array.isArray(t) ? t.indexOf(e) > -1 : "string" == typeof t ? t.split(",").indexOf(e) > -1 : (n = t, "[object RegExp]" === i.call(n) && t.test(e));
	  var n;
	}

	function bn(t, e) {
	  var n = t.cache,
	      o = t.keys,
	      r = t._vnode;

	  for (var _t29 in n) {
	    var _s9 = n[_t29];

	    if (_s9) {
	      var _i8 = _s9.name;
	      _i8 && !e(_i8) && wn(n, _t29, o, r);
	    }
	  }
	}

	function wn(t, e, n, o) {
	  var r = t[e];
	  !r || o && r.tag === o.tag || r.componentInstance.$destroy(), t[e] = null, m(n, e);
	}

	!function (e) {
	  e.prototype._init = function (e) {
	    var n = this;
	    n._uid = mn++, n._isVue = !0, e && e._isComponent ? function (t, e) {
	      var n = t.$options = Object.create(t.constructor.options),
	          o = e._parentVnode;
	      n.parent = e.parent, n._parentVnode = o;
	      var r = o.componentOptions;
	      n.propsData = r.propsData, n._parentListeners = r.listeners, n._renderChildren = r.children, n._componentTag = r.tag, e.render && (n.render = e.render, n.staticRenderFns = e.staticRenderFns);
	    }(n, e) : n.$options = jt(yn(n.constructor), e || {}, n), n._renderProxy = n, n._self = n, function (t) {
	      var e = t.$options;
	      var n = e.parent;

	      if (n && !e["abstract"]) {
	        for (; n.$options["abstract"] && n.$parent;) {
	          n = n.$parent;
	        }

	        n.$children.push(t);
	      }

	      t.$parent = n, t.$root = n ? n.$root : t, t.$children = [], t.$refs = {}, t._watcher = null, t._inactive = null, t._directInactive = !1, t._isMounted = !1, t._isDestroyed = !1, t._isBeingDestroyed = !1;
	    }(n), function (t) {
	      t._events = Object.create(null), t._hasHookEvent = !1;
	      var e = t.$options._parentListeners;
	      e && Ve(t, e);
	    }(n), function (e) {
	      e._vnode = null, e._staticTrees = null;
	      var n = e.$options,
	          o = e.$vnode = n._parentVnode,
	          r = o && o.context;
	      e.$slots = se(n._renderChildren, r), e.$scopedSlots = t, e._c = function (t, n, o, r) {
	        return Ie(e, t, n, o, r, !1);
	      }, e.$createElement = function (t, n, o, r) {
	        return Ie(e, t, n, o, r, !0);
	      };
	      var s = o && o.data;
	      Ct(e, "$attrs", s && s.attrs || t, null, !0), Ct(e, "$listeners", n._parentListeners || t, null, !0);
	    }(n), We(n, "beforeCreate"), function (t) {
	      var e = re(t.$options.inject, t);
	      e && (_t(!1), Object.keys(e).forEach(function (n) {
	        Ct(t, n, e[n]);
	      }), _t(!0));
	    }(n), ln(n), function (t) {
	      var e = t.$options.provide;
	      e && (t._provided = "function" == typeof e ? e.call(t) : e);
	    }(n), We(n, "created"), n.$options.el && n.$mount(n.$options.el);
	  };
	}(gn), function (t) {
	  var e = {
	    get: function get() {
	      return this._data;
	    }
	  },
	      n = {
	    get: function get() {
	      return this._props;
	    }
	  };
	  Object.defineProperty(t.prototype, "$data", e), Object.defineProperty(t.prototype, "$props", n), t.prototype.$set = xt, t.prototype.$delete = kt, t.prototype.$watch = function (t, e, n) {
	    var o = this;
	    if (a(e)) return hn(o, t, e, n);
	    (n = n || {}).user = !0;
	    var r = new sn(o, t, e, n);

	    if (n.immediate) {
	      var _t30 = "callback for immediate watcher \"".concat(r.expression, "\"");

	      ut(), Ht(e, o, [r.value], o, _t30), ft();
	    }

	    return function () {
	      r.teardown();
	    };
	  };
	}(gn), function (t) {
	  var e = /^hook:/;
	  t.prototype.$on = function (t, n) {
	    var o = this;
	    if (Array.isArray(t)) for (var _e25 = 0, _r17 = t.length; _e25 < _r17; _e25++) {
	      o.$on(t[_e25], n);
	    } else (o._events[t] || (o._events[t] = [])).push(n), e.test(t) && (o._hasHookEvent = !0);
	    return o;
	  }, t.prototype.$once = function (t, e) {
	    var n = this;

	    function o() {
	      n.$off(t, o), e.apply(n, arguments);
	    }

	    return o.fn = e, n.$on(t, o), n;
	  }, t.prototype.$off = function (t, e) {
	    var n = this;
	    if (!arguments.length) return n._events = Object.create(null), n;

	    if (Array.isArray(t)) {
	      for (var _o24 = 0, _r18 = t.length; _o24 < _r18; _o24++) {
	        n.$off(t[_o24], e);
	      }

	      return n;
	    }

	    var o = n._events[t];
	    if (!o) return n;
	    if (!e) return n._events[t] = null, n;
	    var r,
	        s = o.length;

	    for (; s--;) {
	      if ((r = o[s]) === e || r.fn === e) {
	        o.splice(s, 1);
	        break;
	      }
	    }

	    return n;
	  }, t.prototype.$emit = function (t) {
	    var e = this;
	    var n = e._events[t];

	    if (n) {
	      n = n.length > 1 ? k(n) : n;

	      var _o25 = k(arguments, 1),
	          _r19 = "event handler for \"".concat(t, "\"");

	      for (var _t31 = 0, _s10 = n.length; _t31 < _s10; _t31++) {
	        Ht(n[_t31], e, _o25, e, _r19);
	      }
	    }

	    return e;
	  };
	}(gn), function (t) {
	  t.prototype._update = function (t, e) {
	    var n = this,
	        o = n.$el,
	        r = n._vnode,
	        s = Ke(n);
	    n._vnode = t, n.$el = r ? n.__patch__(r, t) : n.__patch__(n.$el, t, e, !1), s(), o && (o.__vue__ = null), n.$el && (n.$el.__vue__ = n), n.$vnode && n.$parent && n.$vnode === n.$parent._vnode && (n.$parent.$el = n.$el);
	  }, t.prototype.$forceUpdate = function () {
	    var t = this;
	    t._watcher && t._watcher.update();
	  }, t.prototype.$destroy = function () {
	    var t = this;
	    if (t._isBeingDestroyed) return;
	    We(t, "beforeDestroy"), t._isBeingDestroyed = !0;
	    var e = t.$parent;
	    !e || e._isBeingDestroyed || t.$options["abstract"] || m(e.$children, t), t._watcher && t._watcher.teardown();
	    var n = t._watchers.length;

	    for (; n--;) {
	      t._watchers[n].teardown();
	    }

	    t._data.__ob__ && t._data.__ob__.vmCount--, t._isDestroyed = !0, t.__patch__(t._vnode, null), We(t, "destroyed"), t.$off(), t.$el && (t.$el.__vue__ = null), t.$vnode && (t.$vnode.parent = null);
	  };
	}(gn), function (t) {
	  ke(t.prototype), t.prototype.$nextTick = function (t) {
	    return Wt(t, this);
	  }, t.prototype._render = function () {
	    var t = this,
	        _t$$options = t.$options,
	        e = _t$$options.render,
	        n = _t$$options._parentVnode;
	    var o;
	    n && (t.$scopedSlots = ce(n.data.scopedSlots, t.$slots, t.$scopedSlots)), t.$vnode = n;

	    try {
	      Fe = t, o = e.call(t._renderProxy, t.$createElement);
	    } catch (e) {
	      Rt(e, t, "render"), o = t._vnode;
	    } finally {
	      Fe = null;
	    }

	    return Array.isArray(o) && 1 === o.length && (o = o[0]), o instanceof dt || (o = pt()), o.parent = n, o;
	  };
	}(gn);
	var Cn = [String, RegExp, Array];
	var xn = {
	  KeepAlive: {
	    name: "keep-alive",
	    "abstract": !0,
	    props: {
	      include: Cn,
	      exclude: Cn,
	      max: [String, Number]
	    },
	    methods: {
	      cacheVNode: function cacheVNode() {
	        var t = this.cache,
	            e = this.keys,
	            n = this.vnodeToCache,
	            o = this.keyToCache;

	        if (n) {
	          var _r20 = n.tag,
	              _s11 = n.componentInstance,
	              _i9 = n.componentOptions;
	          t[o] = {
	            name: $n(_i9),
	            tag: _r20,
	            componentInstance: _s11
	          }, e.push(o), this.max && e.length > parseInt(this.max) && wn(t, e[0], e, this._vnode), this.vnodeToCache = null;
	        }
	      }
	    },
	    created: function created() {
	      this.cache = Object.create(null), this.keys = [];
	    },
	    destroyed: function destroyed() {
	      for (var _t32 in this.cache) {
	        wn(this.cache, _t32, this.keys);
	      }
	    },
	    mounted: function mounted() {
	      var _this2 = this;

	      this.cacheVNode(), this.$watch("include", function (t) {
	        bn(_this2, function (e) {
	          return _n(t, e);
	        });
	      }), this.$watch("exclude", function (t) {
	        bn(_this2, function (e) {
	          return !_n(t, e);
	        });
	      });
	    },
	    updated: function updated() {
	      this.cacheVNode();
	    },
	    render: function render() {
	      var t = this.$slots["default"],
	          e = Re(t),
	          n = e && e.componentOptions;

	      if (n) {
	        var _t33 = $n(n),
	            _o26 = this.include,
	            _r21 = this.exclude;

	        if (_o26 && (!_t33 || !_n(_o26, _t33)) || _r21 && _t33 && _n(_r21, _t33)) return e;

	        var _s12 = this.cache,
	            _i10 = this.keys,
	            _a4 = null == e.key ? n.Ctor.cid + (n.tag ? "::".concat(n.tag) : "") : e.key;

	        _s12[_a4] ? (e.componentInstance = _s12[_a4].componentInstance, m(_i10, _a4), _i10.push(_a4)) : (this.vnodeToCache = e, this.keyToCache = _a4), e.data.keepAlive = !0;
	      }

	      return e || t && t[0];
	    }
	  }
	};
	!function (t) {
	  var e = {
	    get: function get() {
	      return F;
	    }
	  };
	  Object.defineProperty(t, "config", e), t.util = {
	    warn: it,
	    extend: A,
	    mergeOptions: jt,
	    defineReactive: Ct
	  }, t.set = xt, t["delete"] = kt, t.nextTick = Wt, t.observable = function (t) {
	    return wt(t), t;
	  }, t.options = Object.create(null), I.forEach(function (e) {
	    t.options[e + "s"] = Object.create(null);
	  }), t.options._base = t, A(t.options.components, xn), function (t) {
	    t.use = function (t) {
	      var e = this._installedPlugins || (this._installedPlugins = []);
	      if (e.indexOf(t) > -1) return this;
	      var n = k(arguments, 1);
	      return n.unshift(this), "function" == typeof t.install ? t.install.apply(t, n) : "function" == typeof t && t.apply(null, n), e.push(t), this;
	    };
	  }(t), function (t) {
	    t.mixin = function (t) {
	      return this.options = jt(this.options, t), this;
	    };
	  }(t), vn(t), function (t) {
	    I.forEach(function (e) {
	      t[e] = function (t, n) {
	        return n ? ("component" === e && a(n) && (n.name = n.name || t, n = this.options._base.extend(n)), "directive" === e && "function" == typeof n && (n = {
	          bind: n,
	          update: n
	        }), this.options[e + "s"][t] = n, n) : this.options[e + "s"][t];
	      };
	    });
	  }(t);
	}(gn), Object.defineProperty(gn.prototype, "$isServer", {
	  get: et
	}), Object.defineProperty(gn.prototype, "$ssrContext", {
	  get: function get() {
	    return this.$vnode && this.$vnode.ssrContext;
	  }
	}), Object.defineProperty(gn, "FunctionalRenderContext", {
	  value: Ae
	}), gn.version = "2.6.14";

	var kn = d("style,class"),
	    An = d("input,textarea,option,select,progress"),
	    On = function On(t, e, n) {
	  return "value" === n && An(t) && "button" !== e || "selected" === n && "option" === t || "checked" === n && "input" === t || "muted" === n && "video" === t;
	},
	    Sn = d("contenteditable,draggable,spellcheck"),
	    Tn = d("events,caret,typing,plaintext-only"),
	    Nn = function Nn(t, e) {
	  return In(e) || "false" === e ? "false" : "contenteditable" === t && Tn(e) ? e : "true";
	},
	    En = d("allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,truespeed,typemustmatch,visible"),
	    jn = "http://www.w3.org/1999/xlink",
	    Dn = function Dn(t) {
	  return ":" === t.charAt(5) && "xlink" === t.slice(0, 5);
	},
	    Ln = function Ln(t) {
	  return Dn(t) ? t.slice(6, t.length) : "";
	},
	    In = function In(t) {
	  return null == t || !1 === t;
	};

	function Mn(t) {
	  var e = t.data,
	      o = t,
	      r = t;

	  for (; n(r.componentInstance);) {
	    (r = r.componentInstance._vnode) && r.data && (e = Fn(r.data, e));
	  }

	  for (; n(o = o.parent);) {
	    o && o.data && (e = Fn(e, o.data));
	  }

	  return function (t, e) {
	    if (n(t) || n(e)) return Pn(t, Rn(e));
	    return "";
	  }(e.staticClass, e["class"]);
	}

	function Fn(t, e) {
	  return {
	    staticClass: Pn(t.staticClass, e.staticClass),
	    "class": n(t["class"]) ? [t["class"], e["class"]] : e["class"]
	  };
	}

	function Pn(t, e) {
	  return t ? e ? t + " " + e : t : e || "";
	}

	function Rn(t) {
	  return Array.isArray(t) ? function (t) {
	    var e,
	        o = "";

	    for (var _r22 = 0, _s13 = t.length; _r22 < _s13; _r22++) {
	      n(e = Rn(t[_r22])) && "" !== e && (o && (o += " "), o += e);
	    }

	    return o;
	  }(t) : s(t) ? function (t) {
	    var e = "";

	    for (var _n36 in t) {
	      t[_n36] && (e && (e += " "), e += _n36);
	    }

	    return e;
	  }(t) : "string" == typeof t ? t : "";
	}

	var Hn = {
	  svg: "http://www.w3.org/2000/svg",
	  math: "http://www.w3.org/1998/Math/MathML"
	},
	    Bn = d("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template,blockquote,iframe,tfoot"),
	    Un = d("svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view", !0),
	    Vn = function Vn(t) {
	  return Bn(t) || Un(t);
	};

	function zn(t) {
	  return Un(t) ? "svg" : "math" === t ? "math" : void 0;
	}

	var Kn = Object.create(null);
	var Jn = d("text,number,password,search,email,tel,url");

	function qn(t) {
	  if ("string" == typeof t) {
	    var _e26 = document.querySelector(t);

	    return _e26 || document.createElement("div");
	  }

	  return t;
	}

	var Wn = Object.freeze({
	  createElement: function createElement(t, e) {
	    var n = document.createElement(t);
	    return "select" !== t ? n : (e.data && e.data.attrs && void 0 !== e.data.attrs.multiple && n.setAttribute("multiple", "multiple"), n);
	  },
	  createElementNS: function createElementNS(t, e) {
	    return document.createElementNS(Hn[t], e);
	  },
	  createTextNode: function createTextNode(t) {
	    return document.createTextNode(t);
	  },
	  createComment: function createComment(t) {
	    return document.createComment(t);
	  },
	  insertBefore: function insertBefore(t, e, n) {
	    t.insertBefore(e, n);
	  },
	  removeChild: function removeChild(t, e) {
	    t.removeChild(e);
	  },
	  appendChild: function appendChild(t, e) {
	    t.appendChild(e);
	  },
	  parentNode: function parentNode(t) {
	    return t.parentNode;
	  },
	  nextSibling: function nextSibling(t) {
	    return t.nextSibling;
	  },
	  tagName: function tagName(t) {
	    return t.tagName;
	  },
	  setTextContent: function setTextContent(t, e) {
	    t.textContent = e;
	  },
	  setStyleScope: function setStyleScope(t, e) {
	    t.setAttribute(e, "");
	  }
	}),
	    Zn = {
	  create: function create(t, e) {
	    Gn(e);
	  },
	  update: function update(t, e) {
	    t.data.ref !== e.data.ref && (Gn(t, !0), Gn(e));
	  },
	  destroy: function destroy(t) {
	    Gn(t, !0);
	  }
	};

	function Gn(t, e) {
	  var o = t.data.ref;
	  if (!n(o)) return;
	  var r = t.context,
	      s = t.componentInstance || t.elm,
	      i = r.$refs;
	  e ? Array.isArray(i[o]) ? m(i[o], s) : i[o] === s && (i[o] = void 0) : t.data.refInFor ? Array.isArray(i[o]) ? i[o].indexOf(s) < 0 && i[o].push(s) : i[o] = [s] : i[o] = s;
	}

	var Xn = new dt("", {}, []),
	    Yn = ["create", "activate", "update", "remove", "destroy"];

	function Qn(t, r) {
	  return t.key === r.key && t.asyncFactory === r.asyncFactory && (t.tag === r.tag && t.isComment === r.isComment && n(t.data) === n(r.data) && function (t, e) {
	    if ("input" !== t.tag) return !0;
	    var o;
	    var r = n(o = t.data) && n(o = o.attrs) && o.type,
	        s = n(o = e.data) && n(o = o.attrs) && o.type;
	    return r === s || Jn(r) && Jn(s);
	  }(t, r) || o(t.isAsyncPlaceholder) && e(r.asyncFactory.error));
	}

	function to(t, e, o) {
	  var r, s;
	  var i = {};

	  for (r = e; r <= o; ++r) {
	    n(s = t[r].key) && (i[s] = r);
	  }

	  return i;
	}

	var eo = {
	  create: no,
	  update: no,
	  destroy: function destroy(t) {
	    no(t, Xn);
	  }
	};

	function no(t, e) {
	  (t.data.directives || e.data.directives) && function (t, e) {
	    var n = t === Xn,
	        o = e === Xn,
	        r = ro(t.data.directives, t.context),
	        s = ro(e.data.directives, e.context),
	        i = [],
	        a = [];
	    var c, l, u;

	    for (c in s) {
	      l = r[c], u = s[c], l ? (u.oldValue = l.value, u.oldArg = l.arg, io(u, "update", e, t), u.def && u.def.componentUpdated && a.push(u)) : (io(u, "bind", e, t), u.def && u.def.inserted && i.push(u));
	    }

	    if (i.length) {
	      var _o27 = function _o27() {
	        for (var _n37 = 0; _n37 < i.length; _n37++) {
	          io(i[_n37], "inserted", e, t);
	        }
	      };

	      n ? te(e, "insert", _o27) : _o27();
	    }

	    a.length && te(e, "postpatch", function () {
	      for (var _n38 = 0; _n38 < a.length; _n38++) {
	        io(a[_n38], "componentUpdated", e, t);
	      }
	    });
	    if (!n) for (c in r) {
	      s[c] || io(r[c], "unbind", t, t, o);
	    }
	  }(t, e);
	}

	var oo = Object.create(null);

	function ro(t, e) {
	  var n = Object.create(null);
	  if (!t) return n;
	  var o, r;

	  for (o = 0; o < t.length; o++) {
	    (r = t[o]).modifiers || (r.modifiers = oo), n[so(r)] = r, r.def = Dt(e.$options, "directives", r.name);
	  }

	  return n;
	}

	function so(t) {
	  return t.rawName || "".concat(t.name, ".").concat(Object.keys(t.modifiers || {}).join("."));
	}

	function io(t, e, n, o, r) {
	  var s = t.def && t.def[e];
	  if (s) try {
	    s(n.elm, t, n, o, r);
	  } catch (o) {
	    Rt(o, n.context, "directive ".concat(t.name, " ").concat(e, " hook"));
	  }
	}

	var ao = [Zn, eo];

	function co(t, o) {
	  var r = o.componentOptions;
	  if (n(r) && !1 === r.Ctor.options.inheritAttrs) return;
	  if (e(t.data.attrs) && e(o.data.attrs)) return;
	  var s, i, a;
	  var c = o.elm,
	      l = t.data.attrs || {};
	  var u = o.data.attrs || {};

	  for (s in n(u.__ob__) && (u = o.data.attrs = A({}, u)), u) {
	    i = u[s], (a = l[s]) !== i && lo(c, s, i, o.data.pre);
	  }

	  for (s in (q || Z) && u.value !== l.value && lo(c, "value", u.value), l) {
	    e(u[s]) && (Dn(s) ? c.removeAttributeNS(jn, Ln(s)) : Sn(s) || c.removeAttribute(s));
	  }
	}

	function lo(t, e, n, o) {
	  o || t.tagName.indexOf("-") > -1 ? uo(t, e, n) : En(e) ? In(n) ? t.removeAttribute(e) : (n = "allowfullscreen" === e && "EMBED" === t.tagName ? "true" : e, t.setAttribute(e, n)) : Sn(e) ? t.setAttribute(e, Nn(e, n)) : Dn(e) ? In(n) ? t.removeAttributeNS(jn, Ln(e)) : t.setAttributeNS(jn, e, n) : uo(t, e, n);
	}

	function uo(t, e, n) {
	  if (In(n)) t.removeAttribute(e);else {
	    if (q && !W && "TEXTAREA" === t.tagName && "placeholder" === e && "" !== n && !t.__ieph) {
	      var _e27 = function _e27(n) {
	        n.stopImmediatePropagation(), t.removeEventListener("input", _e27);
	      };

	      t.addEventListener("input", _e27), t.__ieph = !0;
	    }

	    t.setAttribute(e, n);
	  }
	}

	var fo = {
	  create: co,
	  update: co
	};

	function po(t, o) {
	  var r = o.elm,
	      s = o.data,
	      i = t.data;
	  if (e(s.staticClass) && e(s["class"]) && (e(i) || e(i.staticClass) && e(i["class"]))) return;
	  var a = Mn(o);
	  var c = r._transitionClasses;
	  n(c) && (a = Pn(a, Rn(c))), a !== r._prevClass && (r.setAttribute("class", a), r._prevClass = a);
	}

	var ho = {
	  create: po,
	  update: po
	};
	var mo = /[\w).+\-_$\]]/;

	function yo(t) {
	  var e,
	      n,
	      o,
	      r,
	      s,
	      i = !1,
	      a = !1,
	      c = !1,
	      l = !1,
	      u = 0,
	      f = 0,
	      d = 0,
	      p = 0;

	  for (o = 0; o < t.length; o++) {
	    if (n = e, e = t.charCodeAt(o), i) 39 === e && 92 !== n && (i = !1);else if (a) 34 === e && 92 !== n && (a = !1);else if (c) 96 === e && 92 !== n && (c = !1);else if (l) 47 === e && 92 !== n && (l = !1);else if (124 !== e || 124 === t.charCodeAt(o + 1) || 124 === t.charCodeAt(o - 1) || u || f || d) {
	      switch (e) {
	        case 34:
	          a = !0;
	          break;

	        case 39:
	          i = !0;
	          break;

	        case 96:
	          c = !0;
	          break;

	        case 40:
	          d++;
	          break;

	        case 41:
	          d--;
	          break;

	        case 91:
	          f++;
	          break;

	        case 93:
	          f--;
	          break;

	        case 123:
	          u++;
	          break;

	        case 125:
	          u--;
	      }

	      if (47 === e) {
	        var _e28 = void 0,
	            _n39 = o - 1;

	        for (; _n39 >= 0 && " " === (_e28 = t.charAt(_n39)); _n39--) {
	        }

	        _e28 && mo.test(_e28) || (l = !0);
	      }
	    } else void 0 === r ? (p = o + 1, r = t.slice(0, o).trim()) : h();
	  }

	  function h() {
	    (s || (s = [])).push(t.slice(p, o).trim()), p = o + 1;
	  }

	  if (void 0 === r ? r = t.slice(0, o).trim() : 0 !== p && h(), s) for (o = 0; o < s.length; o++) {
	    r = go(r, s[o]);
	  }
	  return r;
	}

	function go(t, e) {
	  var n = e.indexOf("(");
	  if (n < 0) return "_f(\"".concat(e, "\")(").concat(t, ")");
	  {
	    var _o28 = e.slice(0, n),
	        _r23 = e.slice(n + 1);

	    return "_f(\"".concat(_o28, "\")(").concat(t).concat(")" !== _r23 ? "," + _r23 : _r23);
	  }
	}

	function vo(t, e) {
	  console.error("[Vue compiler]: ".concat(t));
	}

	function $o(t, e) {
	  return t ? t.map(function (t) {
	    return t[e];
	  }).filter(function (t) {
	    return t;
	  }) : [];
	}

	function _o(t, e, n, o, r) {
	  (t.props || (t.props = [])).push(To({
	    name: e,
	    value: n,
	    dynamic: r
	  }, o)), t.plain = !1;
	}

	function bo(t, e, n, o, r) {
	  (r ? t.dynamicAttrs || (t.dynamicAttrs = []) : t.attrs || (t.attrs = [])).push(To({
	    name: e,
	    value: n,
	    dynamic: r
	  }, o)), t.plain = !1;
	}

	function wo(t, e, n, o) {
	  t.attrsMap[e] = n, t.attrsList.push(To({
	    name: e,
	    value: n
	  }, o));
	}

	function Co(t, e, n, o, r, s, i, a) {
	  (t.directives || (t.directives = [])).push(To({
	    name: e,
	    rawName: n,
	    value: o,
	    arg: r,
	    isDynamicArg: s,
	    modifiers: i
	  }, a)), t.plain = !1;
	}

	function xo(t, e, n) {
	  return n ? "_p(".concat(e, ",\"").concat(t, "\")") : t + e;
	}

	function ko(e, n, o, r, s, i, a, c) {
	  var l;
	  (r = r || t).right ? c ? n = "(".concat(n, ")==='click'?'contextmenu':(").concat(n, ")") : "click" === n && (n = "contextmenu", delete r.right) : r.middle && (c ? n = "(".concat(n, ")==='click'?'mouseup':(").concat(n, ")") : "click" === n && (n = "mouseup")), r.capture && (delete r.capture, n = xo("!", n, c)), r.once && (delete r.once, n = xo("~", n, c)), r.passive && (delete r.passive, n = xo("&", n, c)), r["native"] ? (delete r["native"], l = e.nativeEvents || (e.nativeEvents = {})) : l = e.events || (e.events = {});
	  var u = To({
	    value: o.trim(),
	    dynamic: c
	  }, a);
	  r !== t && (u.modifiers = r);
	  var f = l[n];
	  Array.isArray(f) ? s ? f.unshift(u) : f.push(u) : l[n] = f ? s ? [u, f] : [f, u] : u, e.plain = !1;
	}

	function Ao(t, e, n) {
	  var o = Oo(t, ":" + e) || Oo(t, "v-bind:" + e);
	  if (null != o) return yo(o);

	  if (!1 !== n) {
	    var _n40 = Oo(t, e);

	    if (null != _n40) return JSON.stringify(_n40);
	  }
	}

	function Oo(t, e, n) {
	  var o;

	  if (null != (o = t.attrsMap[e])) {
	    var _n41 = t.attrsList;

	    for (var _t34 = 0, _o29 = _n41.length; _t34 < _o29; _t34++) {
	      if (_n41[_t34].name === e) {
	        _n41.splice(_t34, 1);

	        break;
	      }
	    }
	  }

	  return n && delete t.attrsMap[e], o;
	}

	function So(t, e) {
	  var n = t.attrsList;

	  for (var _t35 = 0, _o30 = n.length; _t35 < _o30; _t35++) {
	    var _o31 = n[_t35];
	    if (e.test(_o31.name)) return n.splice(_t35, 1), _o31;
	  }
	}

	function To(t, e) {
	  return e && (null != e.start && (t.start = e.start), null != e.end && (t.end = e.end)), t;
	}

	function No(t, e, n) {
	  var _ref = n || {},
	      o = _ref.number,
	      r = _ref.trim;

	  var s = "$$v";
	  r && (s = "(typeof $$v === 'string'? $$v.trim(): $$v)"), o && (s = "_n(".concat(s, ")"));
	  var i = Eo(e, s);
	  t.model = {
	    value: "(".concat(e, ")"),
	    expression: JSON.stringify(e),
	    callback: "function ($$v) {".concat(i, "}")
	  };
	}

	function Eo(t, e) {
	  var n = function (t) {
	    if (t = t.trim(), jo = t.length, t.indexOf("[") < 0 || t.lastIndexOf("]") < jo - 1) return (Io = t.lastIndexOf(".")) > -1 ? {
	      exp: t.slice(0, Io),
	      key: '"' + t.slice(Io + 1) + '"'
	    } : {
	      exp: t,
	      key: null
	    };
	    Do = t, Io = Mo = Fo = 0;

	    for (; !Ro();) {
	      Ho(Lo = Po()) ? Uo(Lo) : 91 === Lo && Bo(Lo);
	    }

	    return {
	      exp: t.slice(0, Mo),
	      key: t.slice(Mo + 1, Fo)
	    };
	  }(t);

	  return null === n.key ? "".concat(t, "=").concat(e) : "$set(".concat(n.exp, ", ").concat(n.key, ", ").concat(e, ")");
	}

	var jo, Do, Lo, Io, Mo, Fo;

	function Po() {
	  return Do.charCodeAt(++Io);
	}

	function Ro() {
	  return Io >= jo;
	}

	function Ho(t) {
	  return 34 === t || 39 === t;
	}

	function Bo(t) {
	  var e = 1;

	  for (Mo = Io; !Ro();) {
	    if (Ho(t = Po())) Uo(t);else if (91 === t && e++, 93 === t && e--, 0 === e) {
	      Fo = Io;
	      break;
	    }
	  }
	}

	function Uo(t) {
	  var e = t;

	  for (; !Ro() && (t = Po()) !== e;) {
	  }
	}

	var Vo = "__r",
	    zo = "__c";
	var Ko;

	function Jo(t, e, n) {
	  var o = Ko;
	  return function r() {
	    null !== e.apply(null, arguments) && Zo(t, r, n, o);
	  };
	}

	var qo = Vt && !(X && Number(X[1]) <= 53);

	function Wo(t, e, n, o) {
	  if (qo) {
	    var _t36 = en,
	        _n42 = e;

	    e = _n42._wrapper = function (e) {
	      if (e.target === e.currentTarget || e.timeStamp >= _t36 || e.timeStamp <= 0 || e.target.ownerDocument !== document) return _n42.apply(this, arguments);
	    };
	  }

	  Ko.addEventListener(t, e, tt ? {
	    capture: n,
	    passive: o
	  } : n);
	}

	function Zo(t, e, n, o) {
	  (o || Ko).removeEventListener(t, e._wrapper || e, n);
	}

	function Go(t, o) {
	  if (e(t.data.on) && e(o.data.on)) return;
	  var r = o.data.on || {},
	      s = t.data.on || {};
	  Ko = o.elm, function (t) {
	    if (n(t[Vo])) {
	      var _e29 = q ? "change" : "input";

	      t[_e29] = [].concat(t[Vo], t[_e29] || []), delete t[Vo];
	    }

	    n(t[zo]) && (t.change = [].concat(t[zo], t.change || []), delete t[zo]);
	  }(r), Qt(r, s, Wo, Zo, Jo, o.context), Ko = void 0;
	}

	var Xo = {
	  create: Go,
	  update: Go
	};
	var Yo;

	function Qo(t, o) {
	  if (e(t.data.domProps) && e(o.data.domProps)) return;
	  var r, s;
	  var i = o.elm,
	      a = t.data.domProps || {};
	  var c = o.data.domProps || {};

	  for (r in n(c.__ob__) && (c = o.data.domProps = A({}, c)), a) {
	    r in c || (i[r] = "");
	  }

	  for (r in c) {
	    if (s = c[r], "textContent" === r || "innerHTML" === r) {
	      if (o.children && (o.children.length = 0), s === a[r]) continue;
	      1 === i.childNodes.length && i.removeChild(i.childNodes[0]);
	    }

	    if ("value" === r && "PROGRESS" !== i.tagName) {
	      i._value = s;

	      var _t37 = e(s) ? "" : String(s);

	      tr(i, _t37) && (i.value = _t37);
	    } else if ("innerHTML" === r && Un(i.tagName) && e(i.innerHTML)) {
	      (Yo = Yo || document.createElement("div")).innerHTML = "<svg>".concat(s, "</svg>");
	      var _t38 = Yo.firstChild;

	      for (; i.firstChild;) {
	        i.removeChild(i.firstChild);
	      }

	      for (; _t38.firstChild;) {
	        i.appendChild(_t38.firstChild);
	      }
	    } else if (s !== a[r]) try {
	      i[r] = s;
	    } catch (t) {}
	  }
	}

	function tr(t, e) {
	  return !t.composing && ("OPTION" === t.tagName || function (t, e) {
	    var n = !0;

	    try {
	      n = document.activeElement !== t;
	    } catch (t) {}

	    return n && t.value !== e;
	  }(t, e) || function (t, e) {
	    var o = t.value,
	        r = t._vModifiers;

	    if (n(r)) {
	      if (r.number) return f(o) !== f(e);
	      if (r.trim) return o.trim() !== e.trim();
	    }

	    return o !== e;
	  }(t, e));
	}

	var er = {
	  create: Qo,
	  update: Qo
	};
	var nr = v(function (t) {
	  var e = {},
	      n = /:(.+)/;
	  return t.split(/;(?![^(]*\))/g).forEach(function (t) {
	    if (t) {
	      var _o32 = t.split(n);

	      _o32.length > 1 && (e[_o32[0].trim()] = _o32[1].trim());
	    }
	  }), e;
	});

	function or(t) {
	  var e = rr(t.style);
	  return t.staticStyle ? A(t.staticStyle, e) : e;
	}

	function rr(t) {
	  return Array.isArray(t) ? O(t) : "string" == typeof t ? nr(t) : t;
	}

	var sr = /^--/,
	    ir = /\s*!important$/,
	    ar = function ar(t, e, n) {
	  if (sr.test(e)) t.style.setProperty(e, n);else if (ir.test(n)) t.style.setProperty(C(e), n.replace(ir, ""), "important");else {
	    var _o33 = ur(e);

	    if (Array.isArray(n)) for (var _e30 = 0, _r24 = n.length; _e30 < _r24; _e30++) {
	      t.style[_o33] = n[_e30];
	    } else t.style[_o33] = n;
	  }
	},
	    cr = ["Webkit", "Moz", "ms"];

	var lr;
	var ur = v(function (t) {
	  if (lr = lr || document.createElement("div").style, "filter" !== (t = _(t)) && t in lr) return t;
	  var e = t.charAt(0).toUpperCase() + t.slice(1);

	  for (var _t39 = 0; _t39 < cr.length; _t39++) {
	    var _n43 = cr[_t39] + e;

	    if (_n43 in lr) return _n43;
	  }
	});

	function fr(t, o) {
	  var r = o.data,
	      s = t.data;
	  if (e(r.staticStyle) && e(r.style) && e(s.staticStyle) && e(s.style)) return;
	  var i, a;
	  var c = o.elm,
	      l = s.staticStyle,
	      u = s.normalizedStyle || s.style || {},
	      f = l || u,
	      d = rr(o.data.style) || {};
	  o.data.normalizedStyle = n(d.__ob__) ? A({}, d) : d;

	  var p = function (t, e) {
	    var n = {};
	    var o;

	    if (e) {
	      var _e31 = t;

	      for (; _e31.componentInstance;) {
	        (_e31 = _e31.componentInstance._vnode) && _e31.data && (o = or(_e31.data)) && A(n, o);
	      }
	    }

	    (o = or(t.data)) && A(n, o);
	    var r = t;

	    for (; r = r.parent;) {
	      r.data && (o = or(r.data)) && A(n, o);
	    }

	    return n;
	  }(o, !0);

	  for (a in f) {
	    e(p[a]) && ar(c, a, "");
	  }

	  for (a in p) {
	    (i = p[a]) !== f[a] && ar(c, a, null == i ? "" : i);
	  }
	}

	var dr = {
	  create: fr,
	  update: fr
	};
	var pr = /\s+/;

	function hr(t, e) {
	  if (e && (e = e.trim())) if (t.classList) e.indexOf(" ") > -1 ? e.split(pr).forEach(function (e) {
	    return t.classList.add(e);
	  }) : t.classList.add(e);else {
	    var _n44 = " ".concat(t.getAttribute("class") || "", " ");

	    _n44.indexOf(" " + e + " ") < 0 && t.setAttribute("class", (_n44 + e).trim());
	  }
	}

	function mr(t, e) {
	  if (e && (e = e.trim())) if (t.classList) e.indexOf(" ") > -1 ? e.split(pr).forEach(function (e) {
	    return t.classList.remove(e);
	  }) : t.classList.remove(e), t.classList.length || t.removeAttribute("class");else {
	    var _n45 = " ".concat(t.getAttribute("class") || "", " ");

	    var _o34 = " " + e + " ";

	    for (; _n45.indexOf(_o34) >= 0;) {
	      _n45 = _n45.replace(_o34, " ");
	    }

	    (_n45 = _n45.trim()) ? t.setAttribute("class", _n45) : t.removeAttribute("class");
	  }
	}

	function yr(t) {
	  if (t) {
	    if ("object" == babelHelpers["typeof"](t)) {
	      var _e32 = {};
	      return !1 !== t.css && A(_e32, gr(t.name || "v")), A(_e32, t), _e32;
	    }

	    return "string" == typeof t ? gr(t) : void 0;
	  }
	}

	var gr = v(function (t) {
	  return {
	    enterClass: "".concat(t, "-enter"),
	    enterToClass: "".concat(t, "-enter-to"),
	    enterActiveClass: "".concat(t, "-enter-active"),
	    leaveClass: "".concat(t, "-leave"),
	    leaveToClass: "".concat(t, "-leave-to"),
	    leaveActiveClass: "".concat(t, "-leave-active")
	  };
	}),
	    vr = V && !W,
	    $r = "transition",
	    _r = "animation";
	var br = "transition",
	    wr = "transitionend",
	    Cr = "animation",
	    xr = "animationend";
	vr && (void 0 === window.ontransitionend && void 0 !== window.onwebkittransitionend && (br = "WebkitTransition", wr = "webkitTransitionEnd"), void 0 === window.onanimationend && void 0 !== window.onwebkitanimationend && (Cr = "WebkitAnimation", xr = "webkitAnimationEnd"));
	var kr = V ? window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : setTimeout : function (t) {
	  return t();
	};

	function Ar(t) {
	  kr(function () {
	    kr(t);
	  });
	}

	function Or(t, e) {
	  var n = t._transitionClasses || (t._transitionClasses = []);
	  n.indexOf(e) < 0 && (n.push(e), hr(t, e));
	}

	function Sr(t, e) {
	  t._transitionClasses && m(t._transitionClasses, e), mr(t, e);
	}

	function Tr(t, e, n) {
	  var _Er = Er(t, e),
	      o = _Er.type,
	      r = _Er.timeout,
	      s = _Er.propCount;

	  if (!o) return n();
	  var i = o === $r ? wr : xr;
	  var a = 0;

	  var c = function c() {
	    t.removeEventListener(i, l), n();
	  },
	      l = function l(e) {
	    e.target === t && ++a >= s && c();
	  };

	  setTimeout(function () {
	    a < s && c();
	  }, r + 1), t.addEventListener(i, l);
	}

	var Nr = /\b(transform|all)(,|$)/;

	function Er(t, e) {
	  var n = window.getComputedStyle(t),
	      o = (n[br + "Delay"] || "").split(", "),
	      r = (n[br + "Duration"] || "").split(", "),
	      s = jr(o, r),
	      i = (n[Cr + "Delay"] || "").split(", "),
	      a = (n[Cr + "Duration"] || "").split(", "),
	      c = jr(i, a);
	  var l,
	      u = 0,
	      f = 0;
	  return e === $r ? s > 0 && (l = $r, u = s, f = r.length) : e === _r ? c > 0 && (l = _r, u = c, f = a.length) : f = (l = (u = Math.max(s, c)) > 0 ? s > c ? $r : _r : null) ? l === $r ? r.length : a.length : 0, {
	    type: l,
	    timeout: u,
	    propCount: f,
	    hasTransform: l === $r && Nr.test(n[br + "Property"])
	  };
	}

	function jr(t, e) {
	  for (; t.length < e.length;) {
	    t = t.concat(t);
	  }

	  return Math.max.apply(null, e.map(function (e, n) {
	    return Dr(e) + Dr(t[n]);
	  }));
	}

	function Dr(t) {
	  return 1e3 * Number(t.slice(0, -1).replace(",", "."));
	}

	function Lr(t, o) {
	  var r = t.elm;
	  n(r._leaveCb) && (r._leaveCb.cancelled = !0, r._leaveCb());
	  var i = yr(t.data.transition);
	  if (e(i)) return;
	  if (n(r._enterCb) || 1 !== r.nodeType) return;
	  var a = i.css,
	      c = i.type,
	      l = i.enterClass,
	      u = i.enterToClass,
	      d = i.enterActiveClass,
	      p = i.appearClass,
	      h = i.appearToClass,
	      m = i.appearActiveClass,
	      y = i.beforeEnter,
	      g = i.enter,
	      v = i.afterEnter,
	      $ = i.enterCancelled,
	      _ = i.beforeAppear,
	      b = i.appear,
	      w = i.afterAppear,
	      C = i.appearCancelled,
	      x = i.duration;
	  var k = ze,
	      A = ze.$vnode;

	  for (; A && A.parent;) {
	    k = A.context, A = A.parent;
	  }

	  var O = !k._isMounted || !t.isRootInsert;
	  if (O && !b && "" !== b) return;
	  var S = O && p ? p : l,
	      T = O && m ? m : d,
	      N = O && h ? h : u,
	      E = O && _ || y,
	      j = O && "function" == typeof b ? b : g,
	      L = O && w || v,
	      I = O && C || $,
	      M = f(s(x) ? x.enter : x),
	      F = !1 !== a && !W,
	      P = Fr(j),
	      R = r._enterCb = D(function () {
	    F && (Sr(r, N), Sr(r, T)), R.cancelled ? (F && Sr(r, S), I && I(r)) : L && L(r), r._enterCb = null;
	  });
	  t.data.show || te(t, "insert", function () {
	    var e = r.parentNode,
	        n = e && e._pending && e._pending[t.key];
	    n && n.tag === t.tag && n.elm._leaveCb && n.elm._leaveCb(), j && j(r, R);
	  }), E && E(r), F && (Or(r, S), Or(r, T), Ar(function () {
	    Sr(r, S), R.cancelled || (Or(r, N), P || (Mr(M) ? setTimeout(R, M) : Tr(r, c, R)));
	  })), t.data.show && (o && o(), j && j(r, R)), F || P || R();
	}

	function Ir(t, o) {
	  var r = t.elm;
	  n(r._enterCb) && (r._enterCb.cancelled = !0, r._enterCb());
	  var i = yr(t.data.transition);
	  if (e(i) || 1 !== r.nodeType) return o();
	  if (n(r._leaveCb)) return;

	  var a = i.css,
	      c = i.type,
	      l = i.leaveClass,
	      u = i.leaveToClass,
	      d = i.leaveActiveClass,
	      p = i.beforeLeave,
	      h = i.leave,
	      m = i.afterLeave,
	      y = i.leaveCancelled,
	      g = i.delayLeave,
	      v = i.duration,
	      $ = !1 !== a && !W,
	      _ = Fr(h),
	      b = f(s(v) ? v.leave : v),
	      w = r._leaveCb = D(function () {
	    r.parentNode && r.parentNode._pending && (r.parentNode._pending[t.key] = null), $ && (Sr(r, u), Sr(r, d)), w.cancelled ? ($ && Sr(r, l), y && y(r)) : (o(), m && m(r)), r._leaveCb = null;
	  });

	  function C() {
	    w.cancelled || (!t.data.show && r.parentNode && ((r.parentNode._pending || (r.parentNode._pending = {}))[t.key] = t), p && p(r), $ && (Or(r, l), Or(r, d), Ar(function () {
	      Sr(r, l), w.cancelled || (Or(r, u), _ || (Mr(b) ? setTimeout(w, b) : Tr(r, c, w)));
	    })), h && h(r, w), $ || _ || w());
	  }

	  g ? g(C) : C();
	}

	function Mr(t) {
	  return "number" == typeof t && !isNaN(t);
	}

	function Fr(t) {
	  if (e(t)) return !1;
	  var o = t.fns;
	  return n(o) ? Fr(Array.isArray(o) ? o[0] : o) : (t._length || t.length) > 1;
	}

	function Pr(t, e) {
	  !0 !== e.data.show && Lr(e);
	}

	var Rr = function (t) {
	  var s, i;
	  var a = {},
	      c = t.modules,
	      l = t.nodeOps;

	  for (s = 0; s < Yn.length; ++s) {
	    for (a[Yn[s]] = [], i = 0; i < c.length; ++i) {
	      n(c[i][Yn[s]]) && a[Yn[s]].push(c[i][Yn[s]]);
	    }
	  }

	  function u(t) {
	    var e = l.parentNode(t);
	    n(e) && l.removeChild(e, t);
	  }

	  function f(t, e, r, s, i, c, u) {
	    if (n(t.elm) && n(c) && (t = c[u] = mt(t)), t.isRootInsert = !i, function (t, e, r, s) {
	      var i = t.data;

	      if (n(i)) {
	        var _c4 = n(t.componentInstance) && i.keepAlive;

	        if (n(i = i.hook) && n(i = i.init) && i(t, !1), n(t.componentInstance)) return p(t, e), h(r, t.elm, s), o(_c4) && function (t, e, o, r) {
	          var s,
	              i = t;

	          for (; i.componentInstance;) {
	            if (i = i.componentInstance._vnode, n(s = i.data) && n(s = s.transition)) {
	              for (s = 0; s < a.activate.length; ++s) {
	                a.activate[s](Xn, i);
	              }

	              e.push(i);
	              break;
	            }
	          }

	          h(o, t.elm, r);
	        }(t, e, r, s), !0;
	      }
	    }(t, e, r, s)) return;
	    var f = t.data,
	        d = t.children,
	        y = t.tag;
	    n(y) ? (t.elm = t.ns ? l.createElementNS(t.ns, y) : l.createElement(y, t), v(t), m(t, d, e), n(f) && g(t, e), h(r, t.elm, s)) : o(t.isComment) ? (t.elm = l.createComment(t.text), h(r, t.elm, s)) : (t.elm = l.createTextNode(t.text), h(r, t.elm, s));
	  }

	  function p(t, e) {
	    n(t.data.pendingInsert) && (e.push.apply(e, t.data.pendingInsert), t.data.pendingInsert = null), t.elm = t.componentInstance.$el, y(t) ? (g(t, e), v(t)) : (Gn(t), e.push(t));
	  }

	  function h(t, e, o) {
	    n(t) && (n(o) ? l.parentNode(o) === t && l.insertBefore(t, e, o) : l.appendChild(t, e));
	  }

	  function m(t, e, n) {
	    if (Array.isArray(e)) for (var _o35 = 0; _o35 < e.length; ++_o35) {
	      f(e[_o35], n, t.elm, null, !0, e, _o35);
	    } else r(t.text) && l.appendChild(t.elm, l.createTextNode(String(t.text)));
	  }

	  function y(t) {
	    for (; t.componentInstance;) {
	      t = t.componentInstance._vnode;
	    }

	    return n(t.tag);
	  }

	  function g(t, e) {
	    for (var _e33 = 0; _e33 < a.create.length; ++_e33) {
	      a.create[_e33](Xn, t);
	    }

	    n(s = t.data.hook) && (n(s.create) && s.create(Xn, t), n(s.insert) && e.push(t));
	  }

	  function v(t) {
	    var e;
	    if (n(e = t.fnScopeId)) l.setStyleScope(t.elm, e);else {
	      var _o36 = t;

	      for (; _o36;) {
	        n(e = _o36.context) && n(e = e.$options._scopeId) && l.setStyleScope(t.elm, e), _o36 = _o36.parent;
	      }
	    }
	    n(e = ze) && e !== t.context && e !== t.fnContext && n(e = e.$options._scopeId) && l.setStyleScope(t.elm, e);
	  }

	  function $(t, e, n, o, r, s) {
	    for (; o <= r; ++o) {
	      f(n[o], s, t, e, !1, n, o);
	    }
	  }

	  function _(t) {
	    var e, o;
	    var r = t.data;
	    if (n(r)) for (n(e = r.hook) && n(e = e.destroy) && e(t), e = 0; e < a.destroy.length; ++e) {
	      a.destroy[e](t);
	    }
	    if (n(e = t.children)) for (o = 0; o < t.children.length; ++o) {
	      _(t.children[o]);
	    }
	  }

	  function b(t, e, o) {
	    for (; e <= o; ++e) {
	      var _o37 = t[e];
	      n(_o37) && (n(_o37.tag) ? (w(_o37), _(_o37)) : u(_o37.elm));
	    }
	  }

	  function w(t, e) {
	    if (n(e) || n(t.data)) {
	      var _o38;

	      var _r25 = a.remove.length + 1;

	      for (n(e) ? e.listeners += _r25 : e = function (t, e) {
	        function n() {
	          0 == --n.listeners && u(t);
	        }

	        return n.listeners = e, n;
	      }(t.elm, _r25), n(_o38 = t.componentInstance) && n(_o38 = _o38._vnode) && n(_o38.data) && w(_o38, e), _o38 = 0; _o38 < a.remove.length; ++_o38) {
	        a.remove[_o38](t, e);
	      }

	      n(_o38 = t.data.hook) && n(_o38 = _o38.remove) ? _o38(t, e) : e();
	    } else u(t.elm);
	  }

	  function C(t, e, o, r) {
	    for (var _s14 = o; _s14 < r; _s14++) {
	      var _o39 = e[_s14];
	      if (n(_o39) && Qn(t, _o39)) return _s14;
	    }
	  }

	  function x(t, r, s, i, c, u) {
	    if (t === r) return;
	    n(r.elm) && n(i) && (r = i[c] = mt(r));
	    var d = r.elm = t.elm;
	    if (o(t.isAsyncPlaceholder)) return void (n(r.asyncFactory.resolved) ? O(t.elm, r, s) : r.isAsyncPlaceholder = !0);
	    if (o(r.isStatic) && o(t.isStatic) && r.key === t.key && (o(r.isCloned) || o(r.isOnce))) return void (r.componentInstance = t.componentInstance);
	    var p;
	    var h = r.data;
	    n(h) && n(p = h.hook) && n(p = p.prepatch) && p(t, r);
	    var m = t.children,
	        g = r.children;

	    if (n(h) && y(r)) {
	      for (p = 0; p < a.update.length; ++p) {
	        a.update[p](t, r);
	      }

	      n(p = h.hook) && n(p = p.update) && p(t, r);
	    }

	    e(r.text) ? n(m) && n(g) ? m !== g && function (t, o, r, s, i) {
	      var a,
	          c,
	          u,
	          d,
	          p = 0,
	          h = 0,
	          m = o.length - 1,
	          y = o[0],
	          g = o[m],
	          v = r.length - 1,
	          _ = r[0],
	          w = r[v];
	      var k = !i;

	      for (; p <= m && h <= v;) {
	        e(y) ? y = o[++p] : e(g) ? g = o[--m] : Qn(y, _) ? (x(y, _, s, r, h), y = o[++p], _ = r[++h]) : Qn(g, w) ? (x(g, w, s, r, v), g = o[--m], w = r[--v]) : Qn(y, w) ? (x(y, w, s, r, v), k && l.insertBefore(t, y.elm, l.nextSibling(g.elm)), y = o[++p], w = r[--v]) : Qn(g, _) ? (x(g, _, s, r, h), k && l.insertBefore(t, g.elm, y.elm), g = o[--m], _ = r[++h]) : (e(a) && (a = to(o, p, m)), e(c = n(_.key) ? a[_.key] : C(_, o, p, m)) ? f(_, s, t, y.elm, !1, r, h) : Qn(u = o[c], _) ? (x(u, _, s, r, h), o[c] = void 0, k && l.insertBefore(t, u.elm, y.elm)) : f(_, s, t, y.elm, !1, r, h), _ = r[++h]);
	      }

	      p > m ? $(t, d = e(r[v + 1]) ? null : r[v + 1].elm, r, h, v, s) : h > v && b(o, p, m);
	    }(d, m, g, s, u) : n(g) ? (n(t.text) && l.setTextContent(d, ""), $(d, null, g, 0, g.length - 1, s)) : n(m) ? b(m, 0, m.length - 1) : n(t.text) && l.setTextContent(d, "") : t.text !== r.text && l.setTextContent(d, r.text), n(h) && n(p = h.hook) && n(p = p.postpatch) && p(t, r);
	  }

	  function k(t, e, r) {
	    if (o(r) && n(t.parent)) t.parent.data.pendingInsert = e;else for (var _t40 = 0; _t40 < e.length; ++_t40) {
	      e[_t40].data.hook.insert(e[_t40]);
	    }
	  }

	  var A = d("attrs,class,staticClass,staticStyle,key");

	  function O(t, e, r, s) {
	    var i;
	    var a = e.tag,
	        c = e.data,
	        l = e.children;
	    if (s = s || c && c.pre, e.elm = t, o(e.isComment) && n(e.asyncFactory)) return e.isAsyncPlaceholder = !0, !0;
	    if (n(c) && (n(i = c.hook) && n(i = i.init) && i(e, !0), n(i = e.componentInstance))) return p(e, r), !0;

	    if (n(a)) {
	      if (n(l)) if (t.hasChildNodes()) {
	        if (n(i = c) && n(i = i.domProps) && n(i = i.innerHTML)) {
	          if (i !== t.innerHTML) return !1;
	        } else {
	          var _e34 = !0,
	              _n46 = t.firstChild;

	          for (var _t41 = 0; _t41 < l.length; _t41++) {
	            if (!_n46 || !O(_n46, l[_t41], r, s)) {
	              _e34 = !1;
	              break;
	            }

	            _n46 = _n46.nextSibling;
	          }

	          if (!_e34 || _n46) return !1;
	        }
	      } else m(e, l, r);

	      if (n(c)) {
	        var _t42 = !1;

	        for (var _n47 in c) {
	          if (!A(_n47)) {
	            _t42 = !0, g(e, r);
	            break;
	          }
	        }

	        !_t42 && c["class"] && Gt(c["class"]);
	      }
	    } else t.data !== e.text && (t.data = e.text);

	    return !0;
	  }

	  return function (t, r, s, i) {
	    if (e(r)) return void (n(t) && _(t));
	    var c = !1;
	    var u = [];
	    if (e(t)) c = !0, f(r, u);else {
	      var _e35 = n(t.nodeType);

	      if (!_e35 && Qn(t, r)) x(t, r, u, null, null, i);else {
	        if (_e35) {
	          if (1 === t.nodeType && t.hasAttribute(L) && (t.removeAttribute(L), s = !0), o(s) && O(t, r, u)) return k(r, u, !0), t;
	          d = t, t = new dt(l.tagName(d).toLowerCase(), {}, [], void 0, d);
	        }

	        var _i11 = t.elm,
	            _c5 = l.parentNode(_i11);

	        if (f(r, u, _i11._leaveCb ? null : _c5, l.nextSibling(_i11)), n(r.parent)) {
	          var _t43 = r.parent;

	          var _e36 = y(r);

	          for (; _t43;) {
	            for (var _e37 = 0; _e37 < a.destroy.length; ++_e37) {
	              a.destroy[_e37](_t43);
	            }

	            if (_t43.elm = r.elm, _e36) {
	              for (var _e39 = 0; _e39 < a.create.length; ++_e39) {
	                a.create[_e39](Xn, _t43);
	              }

	              var _e38 = _t43.data.hook.insert;
	              if (_e38.merged) for (var _t44 = 1; _t44 < _e38.fns.length; _t44++) {
	                _e38.fns[_t44]();
	              }
	            } else Gn(_t43);

	            _t43 = _t43.parent;
	          }
	        }

	        n(_c5) ? b([t], 0, 0) : n(t.tag) && _(t);
	      }
	    }
	    var d;
	    return k(r, u, c), r.elm;
	  };
	}({
	  nodeOps: Wn,
	  modules: [fo, ho, Xo, er, dr, V ? {
	    create: Pr,
	    activate: Pr,
	    remove: function remove(t, e) {
	      !0 !== t.data.show ? Ir(t, e) : e();
	    }
	  } : {}].concat(ao)
	});

	W && document.addEventListener("selectionchange", function () {
	  var t = document.activeElement;
	  t && t.vmodel && qr(t, "input");
	});
	var Hr = {
	  inserted: function inserted(t, e, n, o) {
	    "select" === n.tag ? (o.elm && !o.elm._vOptions ? te(n, "postpatch", function () {
	      Hr.componentUpdated(t, e, n);
	    }) : Br(t, e, n.context), t._vOptions = [].map.call(t.options, zr)) : ("textarea" === n.tag || Jn(t.type)) && (t._vModifiers = e.modifiers, e.modifiers.lazy || (t.addEventListener("compositionstart", Kr), t.addEventListener("compositionend", Jr), t.addEventListener("change", Jr), W && (t.vmodel = !0)));
	  },
	  componentUpdated: function componentUpdated(t, e, n) {
	    if ("select" === n.tag) {
	      Br(t, e, n.context);

	      var _o40 = t._vOptions,
	          _r26 = t._vOptions = [].map.call(t.options, zr);

	      if (_r26.some(function (t, e) {
	        return !E(t, _o40[e]);
	      })) {
	        (t.multiple ? e.value.some(function (t) {
	          return Vr(t, _r26);
	        }) : e.value !== e.oldValue && Vr(e.value, _r26)) && qr(t, "change");
	      }
	    }
	  }
	};

	function Br(t, e, n) {
	  Ur(t, e, n), (q || Z) && setTimeout(function () {
	    Ur(t, e, n);
	  }, 0);
	}

	function Ur(t, e, n) {
	  var o = e.value,
	      r = t.multiple;
	  if (r && !Array.isArray(o)) return;
	  var s, i;

	  for (var _e40 = 0, _n48 = t.options.length; _e40 < _n48; _e40++) {
	    if (i = t.options[_e40], r) s = j(o, zr(i)) > -1, i.selected !== s && (i.selected = s);else if (E(zr(i), o)) return void (t.selectedIndex !== _e40 && (t.selectedIndex = _e40));
	  }

	  r || (t.selectedIndex = -1);
	}

	function Vr(t, e) {
	  return e.every(function (e) {
	    return !E(e, t);
	  });
	}

	function zr(t) {
	  return "_value" in t ? t._value : t.value;
	}

	function Kr(t) {
	  t.target.composing = !0;
	}

	function Jr(t) {
	  t.target.composing && (t.target.composing = !1, qr(t.target, "input"));
	}

	function qr(t, e) {
	  var n = document.createEvent("HTMLEvents");
	  n.initEvent(e, !0, !0), t.dispatchEvent(n);
	}

	function Wr(t) {
	  return !t.componentInstance || t.data && t.data.transition ? t : Wr(t.componentInstance._vnode);
	}

	var Zr = {
	  model: Hr,
	  show: {
	    bind: function bind(t, _ref2, n) {
	      var e = _ref2.value;
	      var o = (n = Wr(n)).data && n.data.transition,
	          r = t.__vOriginalDisplay = "none" === t.style.display ? "" : t.style.display;
	      e && o ? (n.data.show = !0, Lr(n, function () {
	        t.style.display = r;
	      })) : t.style.display = e ? r : "none";
	    },
	    update: function update(t, _ref3, o) {
	      var e = _ref3.value,
	          n = _ref3.oldValue;
	      if (!e == !n) return;
	      (o = Wr(o)).data && o.data.transition ? (o.data.show = !0, e ? Lr(o, function () {
	        t.style.display = t.__vOriginalDisplay;
	      }) : Ir(o, function () {
	        t.style.display = "none";
	      })) : t.style.display = e ? t.__vOriginalDisplay : "none";
	    },
	    unbind: function unbind(t, e, n, o, r) {
	      r || (t.style.display = t.__vOriginalDisplay);
	    }
	  }
	};
	var Gr = {
	  name: String,
	  appear: Boolean,
	  css: Boolean,
	  mode: String,
	  type: String,
	  enterClass: String,
	  leaveClass: String,
	  enterToClass: String,
	  leaveToClass: String,
	  enterActiveClass: String,
	  leaveActiveClass: String,
	  appearClass: String,
	  appearActiveClass: String,
	  appearToClass: String,
	  duration: [Number, String, Object]
	};

	function Xr(t) {
	  var e = t && t.componentOptions;
	  return e && e.Ctor.options["abstract"] ? Xr(Re(e.children)) : t;
	}

	function Yr(t) {
	  var e = {},
	      n = t.$options;

	  for (var _o41 in n.propsData) {
	    e[_o41] = t[_o41];
	  }

	  var o = n._parentListeners;

	  for (var _t45 in o) {
	    e[_(_t45)] = o[_t45];
	  }

	  return e;
	}

	function Qr(t, e) {
	  if (/\d-keep-alive$/.test(e.tag)) return t("keep-alive", {
	    props: e.componentOptions.propsData
	  });
	}

	var ts = function ts(t) {
	  return t.tag || ae(t);
	},
	    es = function es(t) {
	  return "show" === t.name;
	};

	var ns = {
	  name: "transition",
	  props: Gr,
	  "abstract": !0,
	  render: function render(t) {
	    var _this3 = this;

	    var e = this.$slots["default"];
	    if (!e) return;
	    if (!(e = e.filter(ts)).length) return;
	    var n = this.mode,
	        o = e[0];
	    if (function (t) {
	      for (; t = t.parent;) {
	        if (t.data.transition) return !0;
	      }
	    }(this.$vnode)) return o;
	    var s = Xr(o);
	    if (!s) return o;
	    if (this._leaving) return Qr(t, o);
	    var i = "__transition-".concat(this._uid, "-");
	    s.key = null == s.key ? s.isComment ? i + "comment" : i + s.tag : r(s.key) ? 0 === String(s.key).indexOf(i) ? s.key : i + s.key : s.key;
	    var a = (s.data || (s.data = {})).transition = Yr(this),
	        c = this._vnode,
	        l = Xr(c);

	    if (s.data.directives && s.data.directives.some(es) && (s.data.show = !0), l && l.data && !function (t, e) {
	      return e.key === t.key && e.tag === t.tag;
	    }(s, l) && !ae(l) && (!l.componentInstance || !l.componentInstance._vnode.isComment)) {
	      var _e41 = l.data.transition = A({}, a);

	      if ("out-in" === n) return this._leaving = !0, te(_e41, "afterLeave", function () {
	        _this3._leaving = !1, _this3.$forceUpdate();
	      }), Qr(t, o);

	      if ("in-out" === n) {
	        if (ae(s)) return c;

	        var _t46;

	        var _n49 = function _n49() {
	          _t46();
	        };

	        te(a, "afterEnter", _n49), te(a, "enterCancelled", _n49), te(_e41, "delayLeave", function (e) {
	          _t46 = e;
	        });
	      }
	    }

	    return o;
	  }
	};
	var os = A({
	  tag: String,
	  moveClass: String
	}, Gr);

	function rs(t) {
	  t.elm._moveCb && t.elm._moveCb(), t.elm._enterCb && t.elm._enterCb();
	}

	function ss(t) {
	  t.data.newPos = t.elm.getBoundingClientRect();
	}

	function is(t) {
	  var e = t.data.pos,
	      n = t.data.newPos,
	      o = e.left - n.left,
	      r = e.top - n.top;

	  if (o || r) {
	    t.data.moved = !0;
	    var _e42 = t.elm.style;
	    _e42.transform = _e42.WebkitTransform = "translate(".concat(o, "px,").concat(r, "px)"), _e42.transitionDuration = "0s";
	  }
	}

	delete os.mode;
	var as = {
	  Transition: ns,
	  TransitionGroup: {
	    props: os,
	    beforeMount: function beforeMount() {
	      var _this4 = this;

	      var t = this._update;

	      this._update = function (e, n) {
	        var o = Ke(_this4);
	        _this4.__patch__(_this4._vnode, _this4.kept, !1, !0), _this4._vnode = _this4.kept, o(), t.call(_this4, e, n);
	      };
	    },
	    render: function render(t) {
	      var e = this.tag || this.$vnode.data.tag || "span",
	          n = Object.create(null),
	          o = this.prevChildren = this.children,
	          r = this.$slots["default"] || [],
	          s = this.children = [],
	          i = Yr(this);

	      for (var _t47 = 0; _t47 < r.length; _t47++) {
	        var _e43 = r[_t47];
	        _e43.tag && null != _e43.key && 0 !== String(_e43.key).indexOf("__vlist") && (s.push(_e43), n[_e43.key] = _e43, (_e43.data || (_e43.data = {})).transition = i);
	      }

	      if (o) {
	        var _r27 = [],
	            _s15 = [];

	        for (var _t48 = 0; _t48 < o.length; _t48++) {
	          var _e44 = o[_t48];
	          _e44.data.transition = i, _e44.data.pos = _e44.elm.getBoundingClientRect(), n[_e44.key] ? _r27.push(_e44) : _s15.push(_e44);
	        }

	        this.kept = t(e, null, _r27), this.removed = _s15;
	      }

	      return t(e, null, s);
	    },
	    updated: function updated() {
	      var t = this.prevChildren,
	          e = this.moveClass || (this.name || "v") + "-move";
	      t.length && this.hasMove(t[0].elm, e) && (t.forEach(rs), t.forEach(ss), t.forEach(is), this._reflow = document.body.offsetHeight, t.forEach(function (t) {
	        if (t.data.moved) {
	          var _n50 = t.elm,
	              _o42 = _n50.style;
	          Or(_n50, e), _o42.transform = _o42.WebkitTransform = _o42.transitionDuration = "", _n50.addEventListener(wr, _n50._moveCb = function t(o) {
	            o && o.target !== _n50 || o && !/transform$/.test(o.propertyName) || (_n50.removeEventListener(wr, t), _n50._moveCb = null, Sr(_n50, e));
	          });
	        }
	      }));
	    },
	    methods: {
	      hasMove: function hasMove(t, e) {
	        if (!vr) return !1;
	        if (this._hasMove) return this._hasMove;
	        var n = t.cloneNode();
	        t._transitionClasses && t._transitionClasses.forEach(function (t) {
	          mr(n, t);
	        }), hr(n, e), n.style.display = "none", this.$el.appendChild(n);
	        var o = Er(n);
	        return this.$el.removeChild(n), this._hasMove = o.hasTransform;
	      }
	    }
	  }
	};
	gn.config.mustUseProp = On, gn.config.isReservedTag = Vn, gn.config.isReservedAttr = kn, gn.config.getTagNamespace = zn, gn.config.isUnknownElement = function (t) {
	  if (!V) return !0;
	  if (Vn(t)) return !1;
	  if (t = t.toLowerCase(), null != Kn[t]) return Kn[t];
	  var e = document.createElement(t);
	  return t.indexOf("-") > -1 ? Kn[t] = e.constructor === window.HTMLUnknownElement || e.constructor === window.HTMLElement : Kn[t] = /HTMLUnknownElement/.test(e.toString());
	}, A(gn.options.directives, Zr), A(gn.options.components, as), gn.prototype.__patch__ = V ? Rr : S, gn.prototype.$mount = function (t, e) {
	  return function (t, e, n) {
	    var o;
	    return t.$el = e, t.$options.render || (t.$options.render = pt), We(t, "beforeMount"), o = function o() {
	      t._update(t._render(), n);
	    }, new sn(t, o, S, {
	      before: function before() {
	        t._isMounted && !t._isDestroyed && We(t, "beforeUpdate");
	      }
	    }, !0), n = !1, null == t.$vnode && (t._isMounted = !0, We(t, "mounted")), t;
	  }(this, t = t && V ? qn(t) : void 0, e);
	}, V && setTimeout(function () {
	  F.devtools && nt && nt.emit("init", gn);
	}, 0);
	var cs = /\{\{((?:.|\r?\n)+?)\}\}/g,
	    ls = /[-.*+?^${}()|[\]\/\\]/g,
	    us = v(function (t) {
	  var e = t[0].replace(ls, "\\$&"),
	      n = t[1].replace(ls, "\\$&");
	  return new RegExp(e + "((?:.|\\n)+?)" + n, "g");
	});
	var fs = {
	  staticKeys: ["staticClass"],
	  transformNode: function transformNode(t, e) {
	    e.warn;
	    var n = Oo(t, "class");
	    n && (t.staticClass = JSON.stringify(n));
	    var o = Ao(t, "class", !1);
	    o && (t.classBinding = o);
	  },
	  genData: function genData(t) {
	    var e = "";
	    return t.staticClass && (e += "staticClass:".concat(t.staticClass, ",")), t.classBinding && (e += "class:".concat(t.classBinding, ",")), e;
	  }
	};
	var ds = {
	  staticKeys: ["staticStyle"],
	  transformNode: function transformNode(t, e) {
	    e.warn;
	    var n = Oo(t, "style");
	    n && (t.staticStyle = JSON.stringify(nr(n)));
	    var o = Ao(t, "style", !1);
	    o && (t.styleBinding = o);
	  },
	  genData: function genData(t) {
	    var e = "";
	    return t.staticStyle && (e += "staticStyle:".concat(t.staticStyle, ",")), t.styleBinding && (e += "style:(".concat(t.styleBinding, "),")), e;
	  }
	};
	var ps;
	var hs = {
	  decode: function decode(t) {
	    return (ps = ps || document.createElement("div")).innerHTML = t, ps.textContent;
	  }
	};

	var ms = d("area,base,br,col,embed,frame,hr,img,input,isindex,keygen,link,meta,param,source,track,wbr"),
	    ys = d("colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source"),
	    gs = d("address,article,aside,base,blockquote,body,caption,col,colgroup,dd,details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,title,tr,track"),
	    vs = /^\s*([^\s"'<>\/=]+)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/,
	    $s = /^\s*((?:v-[\w-]+:|@|:|#)\[[^=]+?\][^\s"'<>\/=]*)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/,
	    _s = "[a-zA-Z_][\\-\\.0-9_a-zA-Z".concat(P.source, "]*"),
	    bs = "((?:".concat(_s, "\\:)?").concat(_s, ")"),
	    ws = new RegExp("^<".concat(bs)),
	    Cs = /^\s*(\/?)>/,
	    xs = new RegExp("^<\\/".concat(bs, "[^>]*>")),
	    ks = /^<!DOCTYPE [^>]+>/i,
	    As = /^<!\--/,
	    Os = /^<!\[/,
	    Ss = d("script,style,textarea", !0),
	    Ts = {},
	    Ns = {
	  "&lt;": "<",
	  "&gt;": ">",
	  "&quot;": '"',
	  "&amp;": "&",
	  "&#10;": "\n",
	  "&#9;": "\t",
	  "&#39;": "'"
	},
	    Es = /&(?:lt|gt|quot|amp|#39);/g,
	    js = /&(?:lt|gt|quot|amp|#39|#10|#9);/g,
	    Ds = d("pre,textarea", !0),
	    Ls = function Ls(t, e) {
	  return t && Ds(t) && "\n" === e[0];
	};

	function Is(t, e) {
	  var n = e ? js : Es;
	  return t.replace(n, function (t) {
	    return Ns[t];
	  });
	}

	var Ms = /^@|^v-on:/,
	    Fs = /^v-|^@|^:|^#/,
	    Ps = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/,
	    Rs = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/,
	    Hs = /^\(|\)$/g,
	    Bs = /^\[.*\]$/,
	    Us = /:(.*)$/,
	    Vs = /^:|^\.|^v-bind:/,
	    zs = /\.[^.\]]+(?=[^\]]*$)/g,
	    Ks = /^v-slot(:|$)|^#/,
	    Js = /[\r\n]/,
	    qs = /[ \f\t\r\n]+/g,
	    Ws = v(hs.decode),
	    Zs = "_empty_";
	var Gs, Xs, Ys, Qs, ti, ei, ni, oi;

	function ri(t, e, n) {
	  return {
	    type: 1,
	    tag: t,
	    attrsList: e,
	    attrsMap: fi(e),
	    rawAttrsMap: {},
	    parent: n,
	    children: []
	  };
	}

	function si(t, e) {
	  Gs = e.warn || vo, ei = e.isPreTag || T, ni = e.mustUseProp || T, oi = e.getTagNamespace || T;
	  e.isReservedTag;
	  Ys = $o(e.modules, "transformNode"), Qs = $o(e.modules, "preTransformNode"), ti = $o(e.modules, "postTransformNode"), Xs = e.delimiters;
	  var n = [],
	      o = !1 !== e.preserveWhitespace,
	      r = e.whitespace;
	  var s,
	      i,
	      a = !1,
	      c = !1;

	  function l(t) {
	    if (u(t), a || t.processed || (t = ii(t, e)), n.length || t === s || s["if"] && (t.elseif || t["else"]) && ci(s, {
	      exp: t.elseif,
	      block: t
	    }), i && !t.forbidden) if (t.elseif || t["else"]) !function (t, e) {
	      var n = function (t) {
	        var e = t.length;

	        for (; e--;) {
	          if (1 === t[e].type) return t[e];
	          t.pop();
	        }
	      }(e.children);

	      n && n["if"] && ci(n, {
	        exp: t.elseif,
	        block: t
	      });
	    }(t, i);else {
	      if (t.slotScope) {
	        var _e45 = t.slotTarget || '"default"';

	        (i.scopedSlots || (i.scopedSlots = {}))[_e45] = t;
	      }

	      i.children.push(t), t.parent = i;
	    }
	    t.children = t.children.filter(function (t) {
	      return !t.slotScope;
	    }), u(t), t.pre && (a = !1), ei(t.tag) && (c = !1);

	    for (var _n51 = 0; _n51 < ti.length; _n51++) {
	      ti[_n51](t, e);
	    }
	  }

	  function u(t) {
	    if (!c) {
	      var _e46;

	      for (; (_e46 = t.children[t.children.length - 1]) && 3 === _e46.type && " " === _e46.text;) {
	        t.children.pop();
	      }
	    }
	  }

	  return function (t, e) {
	    var n = [],
	        o = e.expectHTML,
	        r = e.isUnaryTag || T,
	        s = e.canBeLeftOpenTag || T;
	    var i,
	        a,
	        c = 0;

	    for (; t;) {
	      if (i = t, a && Ss(a)) {
	        (function () {
	          var n = 0;
	          var o = a.toLowerCase(),
	              r = Ts[o] || (Ts[o] = new RegExp("([\\s\\S]*?)(</" + o + "[^>]*>)", "i")),
	              s = t.replace(r, function (t, r, s) {
	            return n = s.length, Ss(o) || "noscript" === o || (r = r.replace(/<!\--([\s\S]*?)-->/g, "$1").replace(/<!\[CDATA\[([\s\S]*?)]]>/g, "$1")), Ls(o, r) && (r = r.slice(1)), e.chars && e.chars(r), "";
	          });
	          c += t.length - s.length, t = s, d(o, c - n, c);
	        })();
	      } else {
	        var _n52 = void 0,
	            _o43 = void 0,
	            _r28 = void 0,
	            _s16 = t.indexOf("<");

	        if (0 === _s16) {
	          if (As.test(t)) {
	            var _n54 = t.indexOf("--\x3e");

	            if (_n54 >= 0) {
	              e.shouldKeepComment && e.comment(t.substring(4, _n54), c, c + _n54 + 3), l(_n54 + 3);
	              continue;
	            }
	          }

	          if (Os.test(t)) {
	            var _e47 = t.indexOf("]>");

	            if (_e47 >= 0) {
	              l(_e47 + 2);
	              continue;
	            }
	          }

	          var _n53 = t.match(ks);

	          if (_n53) {
	            l(_n53[0].length);
	            continue;
	          }

	          var _o44 = t.match(xs);

	          if (_o44) {
	            var _t49 = c;
	            l(_o44[0].length), d(_o44[1], _t49, c);
	            continue;
	          }

	          var _r29 = u();

	          if (_r29) {
	            f(_r29), Ls(_r29.tagName, t) && l(1);
	            continue;
	          }
	        }

	        if (_s16 >= 0) {
	          for (_o43 = t.slice(_s16); !(xs.test(_o43) || ws.test(_o43) || As.test(_o43) || Os.test(_o43) || (_r28 = _o43.indexOf("<", 1)) < 0);) {
	            _s16 += _r28, _o43 = t.slice(_s16);
	          }

	          _n52 = t.substring(0, _s16);
	        }

	        _s16 < 0 && (_n52 = t), _n52 && l(_n52.length), e.chars && _n52 && e.chars(_n52, c - _n52.length, c);
	      }

	      if (t === i) {
	        e.chars && e.chars(t);
	        break;
	      }
	    }

	    function l(e) {
	      c += e, t = t.substring(e);
	    }

	    function u() {
	      var e = t.match(ws);

	      if (e) {
	        var _n55 = {
	          tagName: e[1],
	          attrs: [],
	          start: c
	        };

	        var _o45, _r30;

	        for (l(e[0].length); !(_o45 = t.match(Cs)) && (_r30 = t.match($s) || t.match(vs));) {
	          _r30.start = c, l(_r30[0].length), _r30.end = c, _n55.attrs.push(_r30);
	        }

	        if (_o45) return _n55.unarySlash = _o45[1], l(_o45[0].length), _n55.end = c, _n55;
	      }
	    }

	    function f(t) {
	      var i = t.tagName,
	          c = t.unarySlash;
	      o && ("p" === a && gs(i) && d(a), s(i) && a === i && d(i));
	      var l = r(i) || !!c,
	          u = t.attrs.length,
	          f = new Array(u);

	      for (var _n56 = 0; _n56 < u; _n56++) {
	        var _o46 = t.attrs[_n56],
	            _r31 = _o46[3] || _o46[4] || _o46[5] || "",
	            _s17 = "a" === i && "href" === _o46[1] ? e.shouldDecodeNewlinesForHref : e.shouldDecodeNewlines;

	        f[_n56] = {
	          name: _o46[1],
	          value: Is(_r31, _s17)
	        };
	      }

	      l || (n.push({
	        tag: i,
	        lowerCasedTag: i.toLowerCase(),
	        attrs: f,
	        start: t.start,
	        end: t.end
	      }), a = i), e.start && e.start(i, f, l, t.start, t.end);
	    }

	    function d(t, o, r) {
	      var s, i;
	      if (null == o && (o = c), null == r && (r = c), t) for (i = t.toLowerCase(), s = n.length - 1; s >= 0 && n[s].lowerCasedTag !== i; s--) {
	      } else s = 0;

	      if (s >= 0) {
	        for (var _t50 = n.length - 1; _t50 >= s; _t50--) {
	          e.end && e.end(n[_t50].tag, o, r);
	        }

	        n.length = s, a = s && n[s - 1].tag;
	      } else "br" === i ? e.start && e.start(t, [], !0, o, r) : "p" === i && (e.start && e.start(t, [], !1, o, r), e.end && e.end(t, o, r));
	    }

	    d();
	  }(t, {
	    warn: Gs,
	    expectHTML: e.expectHTML,
	    isUnaryTag: e.isUnaryTag,
	    canBeLeftOpenTag: e.canBeLeftOpenTag,
	    shouldDecodeNewlines: e.shouldDecodeNewlines,
	    shouldDecodeNewlinesForHref: e.shouldDecodeNewlinesForHref,
	    shouldKeepComment: e.comments,
	    outputSourceRange: e.outputSourceRange,
	    start: function start(t, o, r, u, f) {
	      var d = i && i.ns || oi(t);
	      q && "svg" === d && (o = function (t) {
	        var e = [];

	        for (var _n57 = 0; _n57 < t.length; _n57++) {
	          var _o47 = t[_n57];
	          di.test(_o47.name) || (_o47.name = _o47.name.replace(pi, ""), e.push(_o47));
	        }

	        return e;
	      }(o));
	      var p = ri(t, o, i);
	      var h;
	      d && (p.ns = d), "style" !== (h = p).tag && ("script" !== h.tag || h.attrsMap.type && "text/javascript" !== h.attrsMap.type) || et() || (p.forbidden = !0);

	      for (var _t51 = 0; _t51 < Qs.length; _t51++) {
	        p = Qs[_t51](p, e) || p;
	      }

	      a || (!function (t) {
	        null != Oo(t, "v-pre") && (t.pre = !0);
	      }(p), p.pre && (a = !0)), ei(p.tag) && (c = !0), a ? function (t) {
	        var e = t.attrsList,
	            n = e.length;

	        if (n) {
	          var _o48 = t.attrs = new Array(n);

	          for (var _t52 = 0; _t52 < n; _t52++) {
	            _o48[_t52] = {
	              name: e[_t52].name,
	              value: JSON.stringify(e[_t52].value)
	            }, null != e[_t52].start && (_o48[_t52].start = e[_t52].start, _o48[_t52].end = e[_t52].end);
	          }
	        } else t.pre || (t.plain = !0);
	      }(p) : p.processed || (ai(p), function (t) {
	        var e = Oo(t, "v-if");
	        if (e) t["if"] = e, ci(t, {
	          exp: e,
	          block: t
	        });else {
	          null != Oo(t, "v-else") && (t["else"] = !0);

	          var _e48 = Oo(t, "v-else-if");

	          _e48 && (t.elseif = _e48);
	        }
	      }(p), function (t) {
	        null != Oo(t, "v-once") && (t.once = !0);
	      }(p)), s || (s = p), r ? l(p) : (i = p, n.push(p));
	    },
	    end: function end(t, e, o) {
	      var r = n[n.length - 1];
	      n.length -= 1, i = n[n.length - 1], l(r);
	    },
	    chars: function chars(t, e, n) {
	      if (!i) return;
	      if (q && "textarea" === i.tag && i.attrsMap.placeholder === t) return;
	      var s = i.children;
	      var l;

	      if (t = c || t.trim() ? "script" === (l = i).tag || "style" === l.tag ? t : Ws(t) : s.length ? r ? "condense" === r && Js.test(t) ? "" : " " : o ? " " : "" : "") {
	        var _e49, _n58;

	        c || "condense" !== r || (t = t.replace(qs, " ")), !a && " " !== t && (_e49 = function (t, e) {
	          var n = e ? us(e) : cs;
	          if (!n.test(t)) return;
	          var o = [],
	              r = [];
	          var s,
	              i,
	              a,
	              c = n.lastIndex = 0;

	          for (; s = n.exec(t);) {
	            (i = s.index) > c && (r.push(a = t.slice(c, i)), o.push(JSON.stringify(a)));

	            var _e50 = yo(s[1].trim());

	            o.push("_s(".concat(_e50, ")")), r.push({
	              "@binding": _e50
	            }), c = i + s[0].length;
	          }

	          return c < t.length && (r.push(a = t.slice(c)), o.push(JSON.stringify(a))), {
	            expression: o.join("+"),
	            tokens: r
	          };
	        }(t, Xs)) ? _n58 = {
	          type: 2,
	          expression: _e49.expression,
	          tokens: _e49.tokens,
	          text: t
	        } : " " === t && s.length && " " === s[s.length - 1].text || (_n58 = {
	          type: 3,
	          text: t
	        }), _n58 && s.push(_n58);
	      }
	    },
	    comment: function comment(t, e, n) {
	      if (i) {
	        var _e51 = {
	          type: 3,
	          text: t,
	          isComment: !0
	        };
	        i.children.push(_e51);
	      }
	    }
	  }), s;
	}

	function ii(t, e) {
	  var n;
	  !function (t) {
	    var e = Ao(t, "key");
	    e && (t.key = e);
	  }(t), t.plain = !t.key && !t.scopedSlots && !t.attrsList.length, function (t) {
	    var e = Ao(t, "ref");
	    e && (t.ref = e, t.refInFor = function (t) {
	      var e = t;

	      for (; e;) {
	        if (void 0 !== e["for"]) return !0;
	        e = e.parent;
	      }

	      return !1;
	    }(t));
	  }(t), function (t) {
	    var e;
	    "template" === t.tag ? (e = Oo(t, "scope"), t.slotScope = e || Oo(t, "slot-scope")) : (e = Oo(t, "slot-scope")) && (t.slotScope = e);
	    var n = Ao(t, "slot");
	    n && (t.slotTarget = '""' === n ? '"default"' : n, t.slotTargetDynamic = !(!t.attrsMap[":slot"] && !t.attrsMap["v-bind:slot"]), "template" === t.tag || t.slotScope || bo(t, "slot", n, function (t, e) {
	      return t.rawAttrsMap[":" + e] || t.rawAttrsMap["v-bind:" + e] || t.rawAttrsMap[e];
	    }(t, "slot")));

	    if ("template" === t.tag) {
	      var _e52 = So(t, Ks);

	      if (_e52) {
	        var _li = li(_e52),
	            _n59 = _li.name,
	            _o49 = _li.dynamic;

	        t.slotTarget = _n59, t.slotTargetDynamic = _o49, t.slotScope = _e52.value || Zs;
	      }
	    } else {
	      var _e53 = So(t, Ks);

	      if (_e53) {
	        var _n60 = t.scopedSlots || (t.scopedSlots = {}),
	            _li2 = li(_e53),
	            _o50 = _li2.name,
	            _r32 = _li2.dynamic,
	            _s18 = _n60[_o50] = ri("template", [], t);

	        _s18.slotTarget = _o50, _s18.slotTargetDynamic = _r32, _s18.children = t.children.filter(function (t) {
	          if (!t.slotScope) return t.parent = _s18, !0;
	        }), _s18.slotScope = _e53.value || Zs, t.children = [], t.plain = !1;
	      }
	    }
	  }(t), "slot" === (n = t).tag && (n.slotName = Ao(n, "name")), function (t) {
	    var e;
	    (e = Ao(t, "is")) && (t.component = e);
	    null != Oo(t, "inline-template") && (t.inlineTemplate = !0);
	  }(t);

	  for (var _n61 = 0; _n61 < Ys.length; _n61++) {
	    t = Ys[_n61](t, e) || t;
	  }

	  return function (t) {
	    var e = t.attrsList;
	    var n, o, r, s, i, a, c, l;

	    for (n = 0, o = e.length; n < o; n++) {
	      if (r = s = e[n].name, i = e[n].value, Fs.test(r)) {
	        if (t.hasBindings = !0, (a = ui(r.replace(Fs, ""))) && (r = r.replace(zs, "")), Vs.test(r)) r = r.replace(Vs, ""), i = yo(i), (l = Bs.test(r)) && (r = r.slice(1, -1)), a && (a.prop && !l && "innerHtml" === (r = _(r)) && (r = "innerHTML"), a.camel && !l && (r = _(r)), a.sync && (c = Eo(i, "$event"), l ? ko(t, "\"update:\"+(".concat(r, ")"), c, null, !1, 0, e[n], !0) : (ko(t, "update:".concat(_(r)), c, null, !1, 0, e[n]), C(r) !== _(r) && ko(t, "update:".concat(C(r)), c, null, !1, 0, e[n])))), a && a.prop || !t.component && ni(t.tag, t.attrsMap.type, r) ? _o(t, r, i, e[n], l) : bo(t, r, i, e[n], l);else if (Ms.test(r)) r = r.replace(Ms, ""), (l = Bs.test(r)) && (r = r.slice(1, -1)), ko(t, r, i, a, !1, 0, e[n], l);else {
	          var _o51 = (r = r.replace(Fs, "")).match(Us);

	          var _c6 = _o51 && _o51[1];

	          l = !1, _c6 && (r = r.slice(0, -(_c6.length + 1)), Bs.test(_c6) && (_c6 = _c6.slice(1, -1), l = !0)), Co(t, r, s, i, _c6, l, a, e[n]);
	        }
	      } else bo(t, r, JSON.stringify(i), e[n]), !t.component && "muted" === r && ni(t.tag, t.attrsMap.type, r) && _o(t, r, "true", e[n]);
	    }
	  }(t), t;
	}

	function ai(t) {
	  var e;

	  if (e = Oo(t, "v-for")) {
	    var _n62 = function (t) {
	      var e = t.match(Ps);
	      if (!e) return;
	      var n = {};
	      n["for"] = e[2].trim();
	      var o = e[1].trim().replace(Hs, ""),
	          r = o.match(Rs);
	      r ? (n.alias = o.replace(Rs, "").trim(), n.iterator1 = r[1].trim(), r[2] && (n.iterator2 = r[2].trim())) : n.alias = o;
	      return n;
	    }(e);

	    _n62 && A(t, _n62);
	  }
	}

	function ci(t, e) {
	  t.ifConditions || (t.ifConditions = []), t.ifConditions.push(e);
	}

	function li(t) {
	  var e = t.name.replace(Ks, "");
	  return e || "#" !== t.name[0] && (e = "default"), Bs.test(e) ? {
	    name: e.slice(1, -1),
	    dynamic: !0
	  } : {
	    name: "\"".concat(e, "\""),
	    dynamic: !1
	  };
	}

	function ui(t) {
	  var e = t.match(zs);

	  if (e) {
	    var _t53 = {};
	    return e.forEach(function (e) {
	      _t53[e.slice(1)] = !0;
	    }), _t53;
	  }
	}

	function fi(t) {
	  var e = {};

	  for (var _n63 = 0, _o52 = t.length; _n63 < _o52; _n63++) {
	    e[t[_n63].name] = t[_n63].value;
	  }

	  return e;
	}

	var di = /^xmlns:NS\d+/,
	    pi = /^NS\d+:/;

	function hi(t) {
	  return ri(t.tag, t.attrsList.slice(), t.parent);
	}

	var mi = [fs, ds, {
	  preTransformNode: function preTransformNode(t, e) {
	    if ("input" === t.tag) {
	      var _n64 = t.attrsMap;
	      if (!_n64["v-model"]) return;

	      var _o53;

	      if ((_n64[":type"] || _n64["v-bind:type"]) && (_o53 = Ao(t, "type")), _n64.type || _o53 || !_n64["v-bind"] || (_o53 = "(".concat(_n64["v-bind"], ").type")), _o53) {
	        var _n65 = Oo(t, "v-if", !0),
	            _r33 = _n65 ? "&&(".concat(_n65, ")") : "",
	            _s19 = null != Oo(t, "v-else", !0),
	            _i12 = Oo(t, "v-else-if", !0),
	            _a5 = hi(t);

	        ai(_a5), wo(_a5, "type", "checkbox"), ii(_a5, e), _a5.processed = !0, _a5["if"] = "(".concat(_o53, ")==='checkbox'") + _r33, ci(_a5, {
	          exp: _a5["if"],
	          block: _a5
	        });

	        var _c7 = hi(t);

	        Oo(_c7, "v-for", !0), wo(_c7, "type", "radio"), ii(_c7, e), ci(_a5, {
	          exp: "(".concat(_o53, ")==='radio'") + _r33,
	          block: _c7
	        });

	        var _l = hi(t);

	        return Oo(_l, "v-for", !0), wo(_l, ":type", _o53), ii(_l, e), ci(_a5, {
	          exp: _n65,
	          block: _l
	        }), _s19 ? _a5["else"] = !0 : _i12 && (_a5.elseif = _i12), _a5;
	      }
	    }
	  }
	}];
	var yi = {
	  expectHTML: !0,
	  modules: mi,
	  directives: {
	    model: function model(t, e, n) {
	      var o = e.value,
	          r = e.modifiers,
	          s = t.tag,
	          i = t.attrsMap.type;
	      if (t.component) return No(t, o, r), !1;
	      if ("select" === s) !function (t, e, n) {
	        var o = "var $$selectedVal = ".concat('Array.prototype.filter.call($event.target.options,function(o){return o.selected}).map(function(o){var val = "_value" in o ? o._value : o.value;' + "return ".concat(n && n.number ? "_n(val)" : "val", "})"), ";");
	        o = "".concat(o, " ").concat(Eo(e, "$event.target.multiple ? $$selectedVal : $$selectedVal[0]")), ko(t, "change", o, null, !0);
	      }(t, o, r);else if ("input" === s && "checkbox" === i) !function (t, e, n) {
	        var o = n && n.number,
	            r = Ao(t, "value") || "null",
	            s = Ao(t, "true-value") || "true",
	            i = Ao(t, "false-value") || "false";
	        _o(t, "checked", "Array.isArray(".concat(e, ")") + "?_i(".concat(e, ",").concat(r, ")>-1") + ("true" === s ? ":(".concat(e, ")") : ":_q(".concat(e, ",").concat(s, ")"))), ko(t, "change", "var $$a=".concat(e, ",") + "$$el=$event.target," + "$$c=$$el.checked?(".concat(s, "):(").concat(i, ");") + "if(Array.isArray($$a)){" + "var $$v=".concat(o ? "_n(" + r + ")" : r, ",") + "$$i=_i($$a,$$v);" + "if($$el.checked){$$i<0&&(".concat(Eo(e, "$$a.concat([$$v])"), ")}") + "else{$$i>-1&&(".concat(Eo(e, "$$a.slice(0,$$i).concat($$a.slice($$i+1))"), ")}") + "}else{".concat(Eo(e, "$$c"), "}"), null, !0);
	      }(t, o, r);else if ("input" === s && "radio" === i) !function (t, e, n) {
	        var o = n && n.number;
	        var r = Ao(t, "value") || "null";
	        _o(t, "checked", "_q(".concat(e, ",").concat(r = o ? "_n(".concat(r, ")") : r, ")")), ko(t, "change", Eo(e, r), null, !0);
	      }(t, o, r);else if ("input" === s || "textarea" === s) !function (t, e, n) {
	        var o = t.attrsMap.type,
	            _ref4 = n || {},
	            r = _ref4.lazy,
	            s = _ref4.number,
	            i = _ref4.trim,
	            a = !r && "range" !== o,
	            c = r ? "change" : "range" === o ? Vo : "input";

	        var l = "$event.target.value";
	        i && (l = "$event.target.value.trim()"), s && (l = "_n(".concat(l, ")"));
	        var u = Eo(e, l);
	        a && (u = "if($event.target.composing)return;".concat(u)), _o(t, "value", "(".concat(e, ")")), ko(t, c, u, null, !0), (i || s) && ko(t, "blur", "$forceUpdate()");
	      }(t, o, r);else if (!F.isReservedTag(s)) return No(t, o, r), !1;
	      return !0;
	    },
	    text: function text(t, e) {
	      e.value && _o(t, "textContent", "_s(".concat(e.value, ")"), e);
	    },
	    html: function html(t, e) {
	      e.value && _o(t, "innerHTML", "_s(".concat(e.value, ")"), e);
	    }
	  },
	  isPreTag: function isPreTag(t) {
	    return "pre" === t;
	  },
	  isUnaryTag: ms,
	  mustUseProp: On,
	  canBeLeftOpenTag: ys,
	  isReservedTag: Vn,
	  getTagNamespace: zn,
	  staticKeys: function (t) {
	    return t.reduce(function (t, e) {
	      return t.concat(e.staticKeys || []);
	    }, []).join(",");
	  }(mi)
	};
	var gi, vi;
	var $i = v(function (t) {
	  return d("type,tag,attrsList,attrsMap,plain,parent,children,attrs,start,end,rawAttrsMap" + (t ? "," + t : ""));
	});

	function _i(t, e) {
	  t && (gi = $i(e.staticKeys || ""), vi = e.isReservedTag || T, function t(e) {
	    e["static"] = function (t) {
	      if (2 === t.type) return !1;
	      if (3 === t.type) return !0;
	      return !(!t.pre && (t.hasBindings || t["if"] || t["for"] || p(t.tag) || !vi(t.tag) || function (t) {
	        for (; t.parent;) {
	          if ("template" !== (t = t.parent).tag) return !1;
	          if (t["for"]) return !0;
	        }

	        return !1;
	      }(t) || !Object.keys(t).every(gi)));
	    }(e);

	    if (1 === e.type) {
	      if (!vi(e.tag) && "slot" !== e.tag && null == e.attrsMap["inline-template"]) return;

	      for (var _n66 = 0, _o54 = e.children.length; _n66 < _o54; _n66++) {
	        var _o55 = e.children[_n66];
	        t(_o55), _o55["static"] || (e["static"] = !1);
	      }

	      if (e.ifConditions) for (var _n67 = 1, _o56 = e.ifConditions.length; _n67 < _o56; _n67++) {
	        var _o57 = e.ifConditions[_n67].block;
	        t(_o57), _o57["static"] || (e["static"] = !1);
	      }
	    }
	  }(t), function t(e, n) {
	    if (1 === e.type) {
	      if ((e["static"] || e.once) && (e.staticInFor = n), e["static"] && e.children.length && (1 !== e.children.length || 3 !== e.children[0].type)) return void (e.staticRoot = !0);
	      if (e.staticRoot = !1, e.children) for (var _o58 = 0, _r34 = e.children.length; _o58 < _r34; _o58++) {
	        t(e.children[_o58], n || !!e["for"]);
	      }
	      if (e.ifConditions) for (var _o59 = 1, _r35 = e.ifConditions.length; _o59 < _r35; _o59++) {
	        t(e.ifConditions[_o59].block, n);
	      }
	    }
	  }(t, !1));
	}

	var bi = /^([\w$_]+|\([^)]*?\))\s*=>|^function(?:\s+[\w$]+)?\s*\(/,
	    wi = /\([^)]*?\);*$/,
	    Ci = /^[A-Za-z_$][\w$]*(?:\.[A-Za-z_$][\w$]*|\['[^']*?']|\["[^"]*?"]|\[\d+]|\[[A-Za-z_$][\w$]*])*$/,
	    xi = {
	  esc: 27,
	  tab: 9,
	  enter: 13,
	  space: 32,
	  up: 38,
	  left: 37,
	  right: 39,
	  down: 40,
	  "delete": [8, 46]
	},
	    ki = {
	  esc: ["Esc", "Escape"],
	  tab: "Tab",
	  enter: "Enter",
	  space: [" ", "Spacebar"],
	  up: ["Up", "ArrowUp"],
	  left: ["Left", "ArrowLeft"],
	  right: ["Right", "ArrowRight"],
	  down: ["Down", "ArrowDown"],
	  "delete": ["Backspace", "Delete", "Del"]
	},
	    Ai = function Ai(t) {
	  return "if(".concat(t, ")return null;");
	},
	    Oi = {
	  stop: "$event.stopPropagation();",
	  prevent: "$event.preventDefault();",
	  self: Ai("$event.target !== $event.currentTarget"),
	  ctrl: Ai("!$event.ctrlKey"),
	  shift: Ai("!$event.shiftKey"),
	  alt: Ai("!$event.altKey"),
	  meta: Ai("!$event.metaKey"),
	  left: Ai("'button' in $event && $event.button !== 0"),
	  middle: Ai("'button' in $event && $event.button !== 1"),
	  right: Ai("'button' in $event && $event.button !== 2")
	};

	function Si(t, e) {
	  var n = e ? "nativeOn:" : "on:";
	  var o = "",
	      r = "";

	  for (var _e54 in t) {
	    var _n68 = Ti(t[_e54]);

	    t[_e54] && t[_e54].dynamic ? r += "".concat(_e54, ",").concat(_n68, ",") : o += "\"".concat(_e54, "\":").concat(_n68, ",");
	  }

	  return o = "{".concat(o.slice(0, -1), "}"), r ? n + "_d(".concat(o, ",[").concat(r.slice(0, -1), "])") : n + o;
	}

	function Ti(t) {
	  if (!t) return "function(){}";
	  if (Array.isArray(t)) return "[".concat(t.map(function (t) {
	    return Ti(t);
	  }).join(","), "]");
	  var e = Ci.test(t.value),
	      n = bi.test(t.value),
	      o = Ci.test(t.value.replace(wi, ""));

	  if (t.modifiers) {
	    var _r36 = "",
	        _s20 = "";
	    var _i13 = [];

	    for (var _e55 in t.modifiers) {
	      if (Oi[_e55]) _s20 += Oi[_e55], xi[_e55] && _i13.push(_e55);else if ("exact" === _e55) {
	        (function () {
	          var e = t.modifiers;
	          _s20 += Ai(["ctrl", "shift", "alt", "meta"].filter(function (t) {
	            return !e[t];
	          }).map(function (t) {
	            return "$event.".concat(t, "Key");
	          }).join("||"));
	        })();
	      } else _i13.push(_e55);
	    }

	    return _i13.length && (_r36 += function (t) {
	      return "if(!$event.type.indexOf('key')&&" + "".concat(t.map(Ni).join("&&"), ")return null;");
	    }(_i13)), _s20 && (_r36 += _s20), "function($event){".concat(_r36).concat(e ? "return ".concat(t.value, ".apply(null, arguments)") : n ? "return (".concat(t.value, ").apply(null, arguments)") : o ? "return ".concat(t.value) : t.value, "}");
	  }

	  return e || n ? t.value : "function($event){".concat(o ? "return ".concat(t.value) : t.value, "}");
	}

	function Ni(t) {
	  var e = parseInt(t, 10);
	  if (e) return "$event.keyCode!==".concat(e);
	  var n = xi[t],
	      o = ki[t];
	  return "_k($event.keyCode," + "".concat(JSON.stringify(t), ",") + "".concat(JSON.stringify(n), ",") + "$event.key," + "".concat(JSON.stringify(o)) + ")";
	}

	var Ei = {
	  on: function on(t, e) {
	    t.wrapListeners = function (t) {
	      return "_g(".concat(t, ",").concat(e.value, ")");
	    };
	  },
	  bind: function bind(t, e) {
	    t.wrapData = function (n) {
	      return "_b(".concat(n, ",'").concat(t.tag, "',").concat(e.value, ",").concat(e.modifiers && e.modifiers.prop ? "true" : "false").concat(e.modifiers && e.modifiers.sync ? ",true" : "", ")");
	    };
	  },
	  cloak: S
	};

	var ji = function ji(t) {
	  babelHelpers.classCallCheck(this, ji);
	  this.options = t, this.warn = t.warn || vo, this.transforms = $o(t.modules, "transformCode"), this.dataGenFns = $o(t.modules, "genData"), this.directives = A(A({}, Ei), t.directives);
	  var e = t.isReservedTag || T;
	  this.maybeComponent = function (t) {
	    return !!t.component || !e(t.tag);
	  }, this.onceId = 0, this.staticRenderFns = [], this.pre = !1;
	};

	function Di(t, e) {
	  var n = new ji(e);
	  return {
	    render: "with(this){return ".concat(t ? "script" === t.tag ? "null" : Li(t, n) : '_c("div")', "}"),
	    staticRenderFns: n.staticRenderFns
	  };
	}

	function Li(t, e) {
	  if (t.parent && (t.pre = t.pre || t.parent.pre), t.staticRoot && !t.staticProcessed) return Ii(t, e);
	  if (t.once && !t.onceProcessed) return Mi(t, e);
	  if (t["for"] && !t.forProcessed) return Pi(t, e);
	  if (t["if"] && !t.ifProcessed) return Fi(t, e);

	  if ("template" !== t.tag || t.slotTarget || e.pre) {
	    if ("slot" === t.tag) return function (t, e) {
	      var n = t.slotName || '"default"',
	          o = Ui(t, e);
	      var r = "_t(".concat(n).concat(o ? ",function(){return ".concat(o, "}") : "");
	      var s = t.attrs || t.dynamicAttrs ? Ki((t.attrs || []).concat(t.dynamicAttrs || []).map(function (t) {
	        return {
	          name: _(t.name),
	          value: t.value,
	          dynamic: t.dynamic
	        };
	      })) : null,
	          i = t.attrsMap["v-bind"];
	      !s && !i || o || (r += ",null");
	      s && (r += ",".concat(s));
	      i && (r += "".concat(s ? "" : ",null", ",").concat(i));
	      return r + ")";
	    }(t, e);
	    {
	      var _n69;

	      if (t.component) _n69 = function (t, e, n) {
	        var o = e.inlineTemplate ? null : Ui(e, n, !0);
	        return "_c(".concat(t, ",").concat(Ri(e, n)).concat(o ? ",".concat(o) : "", ")");
	      }(t.component, t, e);else {
	        var _o60;

	        (!t.plain || t.pre && e.maybeComponent(t)) && (_o60 = Ri(t, e));

	        var _r37 = t.inlineTemplate ? null : Ui(t, e, !0);

	        _n69 = "_c('".concat(t.tag, "'").concat(_o60 ? ",".concat(_o60) : "").concat(_r37 ? ",".concat(_r37) : "", ")");
	      }

	      for (var _o61 = 0; _o61 < e.transforms.length; _o61++) {
	        _n69 = e.transforms[_o61](t, _n69);
	      }

	      return _n69;
	    }
	  }

	  return Ui(t, e) || "void 0";
	}

	function Ii(t, e) {
	  t.staticProcessed = !0;
	  var n = e.pre;
	  return t.pre && (e.pre = t.pre), e.staticRenderFns.push("with(this){return ".concat(Li(t, e), "}")), e.pre = n, "_m(".concat(e.staticRenderFns.length - 1).concat(t.staticInFor ? ",true" : "", ")");
	}

	function Mi(t, e) {
	  if (t.onceProcessed = !0, t["if"] && !t.ifProcessed) return Fi(t, e);

	  if (t.staticInFor) {
	    var _n70 = "",
	        _o62 = t.parent;

	    for (; _o62;) {
	      if (_o62["for"]) {
	        _n70 = _o62.key;
	        break;
	      }

	      _o62 = _o62.parent;
	    }

	    return _n70 ? "_o(".concat(Li(t, e), ",").concat(e.onceId++, ",").concat(_n70, ")") : Li(t, e);
	  }

	  return Ii(t, e);
	}

	function Fi(t, e, n, o) {
	  return t.ifProcessed = !0, function t(e, n, o, r) {
	    if (!e.length) return r || "_e()";
	    var s = e.shift();
	    return s.exp ? "(".concat(s.exp, ")?").concat(i(s.block), ":").concat(t(e, n, o, r)) : "".concat(i(s.block));

	    function i(t) {
	      return o ? o(t, n) : t.once ? Mi(t, n) : Li(t, n);
	    }
	  }(t.ifConditions.slice(), e, n, o);
	}

	function Pi(t, e, n, o) {
	  var r = t["for"],
	      s = t.alias,
	      i = t.iterator1 ? ",".concat(t.iterator1) : "",
	      a = t.iterator2 ? ",".concat(t.iterator2) : "";
	  return t.forProcessed = !0, "".concat(o || "_l", "((").concat(r, "),") + "function(".concat(s).concat(i).concat(a, "){") + "return ".concat((n || Li)(t, e)) + "})";
	}

	function Ri(t, e) {
	  var n = "{";

	  var o = function (t, e) {
	    var n = t.directives;
	    if (!n) return;
	    var o,
	        r,
	        s,
	        i,
	        a = "directives:[",
	        c = !1;

	    for (o = 0, r = n.length; o < r; o++) {
	      s = n[o], i = !0;
	      var _r38 = e.directives[s.name];
	      _r38 && (i = !!_r38(t, s, e.warn)), i && (c = !0, a += "{name:\"".concat(s.name, "\",rawName:\"").concat(s.rawName, "\"").concat(s.value ? ",value:(".concat(s.value, "),expression:").concat(JSON.stringify(s.value)) : "").concat(s.arg ? ",arg:".concat(s.isDynamicArg ? s.arg : "\"".concat(s.arg, "\"")) : "").concat(s.modifiers ? ",modifiers:".concat(JSON.stringify(s.modifiers)) : "", "},"));
	    }

	    if (c) return a.slice(0, -1) + "]";
	  }(t, e);

	  o && (n += o + ","), t.key && (n += "key:".concat(t.key, ",")), t.ref && (n += "ref:".concat(t.ref, ",")), t.refInFor && (n += "refInFor:true,"), t.pre && (n += "pre:true,"), t.component && (n += "tag:\"".concat(t.tag, "\","));

	  for (var _o63 = 0; _o63 < e.dataGenFns.length; _o63++) {
	    n += e.dataGenFns[_o63](t);
	  }

	  if (t.attrs && (n += "attrs:".concat(Ki(t.attrs), ",")), t.props && (n += "domProps:".concat(Ki(t.props), ",")), t.events && (n += "".concat(Si(t.events, !1), ",")), t.nativeEvents && (n += "".concat(Si(t.nativeEvents, !0), ",")), t.slotTarget && !t.slotScope && (n += "slot:".concat(t.slotTarget, ",")), t.scopedSlots && (n += "".concat(function (t, e, n) {
	    var o = t["for"] || Object.keys(e).some(function (t) {
	      var n = e[t];
	      return n.slotTargetDynamic || n["if"] || n["for"] || Hi(n);
	    }),
	        r = !!t["if"];

	    if (!o) {
	      var _e56 = t.parent;

	      for (; _e56;) {
	        if (_e56.slotScope && _e56.slotScope !== Zs || _e56["for"]) {
	          o = !0;
	          break;
	        }

	        _e56["if"] && (r = !0), _e56 = _e56.parent;
	      }
	    }

	    var s = Object.keys(e).map(function (t) {
	      return Bi(e[t], n);
	    }).join(",");
	    return "scopedSlots:_u([".concat(s, "]").concat(o ? ",null,true" : "").concat(!o && r ? ",null,false,".concat(function (t) {
	      var e = 5381,
	          n = t.length;

	      for (; n;) {
	        e = 33 * e ^ t.charCodeAt(--n);
	      }

	      return e >>> 0;
	    }(s)) : "", ")");
	  }(t, t.scopedSlots, e), ",")), t.model && (n += "model:{value:".concat(t.model.value, ",callback:").concat(t.model.callback, ",expression:").concat(t.model.expression, "},")), t.inlineTemplate) {
	    var _o64 = function (t, e) {
	      var n = t.children[0];

	      if (n && 1 === n.type) {
	        var _t54 = Di(n, e.options);

	        return "inlineTemplate:{render:function(){".concat(_t54.render, "},staticRenderFns:[").concat(_t54.staticRenderFns.map(function (t) {
	          return "function(){".concat(t, "}");
	        }).join(","), "]}");
	      }
	    }(t, e);

	    _o64 && (n += "".concat(_o64, ","));
	  }

	  return n = n.replace(/,$/, "") + "}", t.dynamicAttrs && (n = "_b(".concat(n, ",\"").concat(t.tag, "\",").concat(Ki(t.dynamicAttrs), ")")), t.wrapData && (n = t.wrapData(n)), t.wrapListeners && (n = t.wrapListeners(n)), n;
	}

	function Hi(t) {
	  return 1 === t.type && ("slot" === t.tag || t.children.some(Hi));
	}

	function Bi(t, e) {
	  var n = t.attrsMap["slot-scope"];
	  if (t["if"] && !t.ifProcessed && !n) return Fi(t, e, Bi, "null");
	  if (t["for"] && !t.forProcessed) return Pi(t, e, Bi);
	  var o = t.slotScope === Zs ? "" : String(t.slotScope),
	      r = "function(".concat(o, "){") + "return ".concat("template" === t.tag ? t["if"] && n ? "(".concat(t["if"], ")?").concat(Ui(t, e) || "undefined", ":undefined") : Ui(t, e) || "undefined" : Li(t, e), "}"),
	      s = o ? "" : ",proxy:true";
	  return "{key:".concat(t.slotTarget || '"default"', ",fn:").concat(r).concat(s, "}");
	}

	function Ui(t, e, n, o, r) {
	  var s = t.children;

	  if (s.length) {
	    var _t55 = s[0];

	    if (1 === s.length && _t55["for"] && "template" !== _t55.tag && "slot" !== _t55.tag) {
	      var _r39 = n ? e.maybeComponent(_t55) ? ",1" : ",0" : "";

	      return "".concat((o || Li)(_t55, e)).concat(_r39);
	    }

	    var _i14 = n ? function (t, e) {
	      var n = 0;

	      for (var _o65 = 0; _o65 < t.length; _o65++) {
	        var _r40 = t[_o65];

	        if (1 === _r40.type) {
	          if (Vi(_r40) || _r40.ifConditions && _r40.ifConditions.some(function (t) {
	            return Vi(t.block);
	          })) {
	            n = 2;
	            break;
	          }

	          (e(_r40) || _r40.ifConditions && _r40.ifConditions.some(function (t) {
	            return e(t.block);
	          })) && (n = 1);
	        }
	      }

	      return n;
	    }(s, e.maybeComponent) : 0,
	        _a6 = r || zi;

	    return "[".concat(s.map(function (t) {
	      return _a6(t, e);
	    }).join(","), "]").concat(_i14 ? ",".concat(_i14) : "");
	  }
	}

	function Vi(t) {
	  return void 0 !== t["for"] || "template" === t.tag || "slot" === t.tag;
	}

	function zi(t, e) {
	  return 1 === t.type ? Li(t, e) : 3 === t.type && t.isComment ? (o = t, "_e(".concat(JSON.stringify(o.text), ")")) : "_v(".concat(2 === (n = t).type ? n.expression : Ji(JSON.stringify(n.text)), ")");
	  var n, o;
	}

	function Ki(t) {
	  var e = "",
	      n = "";

	  for (var _o66 = 0; _o66 < t.length; _o66++) {
	    var _r41 = t[_o66],
	        _s21 = Ji(_r41.value);

	    _r41.dynamic ? n += "".concat(_r41.name, ",").concat(_s21, ",") : e += "\"".concat(_r41.name, "\":").concat(_s21, ",");
	  }

	  return e = "{".concat(e.slice(0, -1), "}"), n ? "_d(".concat(e, ",[").concat(n.slice(0, -1), "])") : e;
	}

	function Ji(t) {
	  return t.replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
	}

	function qi(t, e) {
	  try {
	    return new Function(t);
	  } catch (n) {
	    return e.push({
	      err: n,
	      code: t
	    }), S;
	  }
	}

	function Wi(t) {
	  var e = Object.create(null);
	  return function (n, o, r) {
	    (o = A({}, o)).warn;
	    delete o.warn;
	    var s = o.delimiters ? String(o.delimiters) + n : n;
	    if (e[s]) return e[s];
	    var i = t(n, o),
	        a = {},
	        c = [];
	    return a.render = qi(i.render, c), a.staticRenderFns = i.staticRenderFns.map(function (t) {
	      return qi(t, c);
	    }), e[s] = a;
	  };
	}

	var Zi = (Gi = function Gi(t, e) {
	  var n = si(t.trim(), e);
	  !1 !== e.optimize && _i(n, e);
	  var o = Di(n, e);
	  return {
	    ast: n,
	    render: o.render,
	    staticRenderFns: o.staticRenderFns
	  };
	}, function (t) {
	  function e(e, n) {
	    var o = Object.create(t),
	        r = [],
	        s = [];

	    if (n) {
	      n.modules && (o.modules = (t.modules || []).concat(n.modules)), n.directives && (o.directives = A(Object.create(t.directives || null), n.directives));

	      for (var _t56 in n) {
	        "modules" !== _t56 && "directives" !== _t56 && (o[_t56] = n[_t56]);
	      }
	    }

	    o.warn = function (t, e, n) {
	      (n ? s : r).push(t);
	    };

	    var i = Gi(e.trim(), o);
	    return i.errors = r, i.tips = s, i;
	  }

	  return {
	    compile: e,
	    compileToFunctions: Wi(e)
	  };
	});
	var Gi;

	var _Zi = Zi(yi),
	    Xi = _Zi.compile,
	    Yi = _Zi.compileToFunctions;

	var Qi;

	function ta(t) {
	  return (Qi = Qi || document.createElement("div")).innerHTML = t ? '<a href="\n"/>' : '<div a="\n"/>', Qi.innerHTML.indexOf("&#10;") > 0;
	}

	var ea = !!V && ta(!1),
	    na = !!V && ta(!0),
	    oa = v(function (t) {
	  var e = qn(t);
	  return e && e.innerHTML;
	}),
	    ra = gn.prototype.$mount;
	gn.prototype.$mount = function (t, e) {
	  if ((t = t && qn(t)) === document.body || t === document.documentElement) return this;
	  var n = this.$options;

	  if (!n.render) {
	    var _e57 = n.template;
	    if (_e57) {
	      if ("string" == typeof _e57) "#" === _e57.charAt(0) && (_e57 = oa(_e57));else {
	        if (!_e57.nodeType) return this;
	        _e57 = _e57.innerHTML;
	      }
	    } else t && (_e57 = function (t) {
	      if (t.outerHTML) return t.outerHTML;
	      {
	        var _e58 = document.createElement("div");

	        return _e58.appendChild(t.cloneNode(!0)), _e58.innerHTML;
	      }
	    }(t));

	    if (_e57) {
	      var _Yi = Yi(_e57, {
	        outputSourceRange: !1,
	        shouldDecodeNewlines: ea,
	        shouldDecodeNewlinesForHref: na,
	        delimiters: n.delimiters,
	        comments: n.comments
	      }, this),
	          _t57 = _Yi.render,
	          _o67 = _Yi.staticRenderFns;

	      n.render = _t57, n.staticRenderFns = _o67;
	    }
	  }

	  return ra.call(this, t, e);
	}, gn.compile = Yi; // origin-end
	var BitrixVueInstance = new BitrixVue(gn);

	exports.WidgetBitrixVue = BitrixVueInstance;
	exports.WidgetVue = BitrixVueInstance;
	exports.WidgetVueVendor = gn;
	exports.WidgetVueVendorV2 = gn;

}((this.BX = this.BX || {}),BX.Event,BX,BX,BX));



})();




// file: /bitrix/js/pull/protobuf/protobuf.js
/*!
 * protobuf.js v6.8.6 (c) 2016, daniel wirtz
 * compiled mon, 26 feb 2018 11:35:34 utc
 * licensed under the bsd-3-clause license
 * see: https://github.com/dcodeio/protobuf.js for details
 *
 * Modify list for integration with Bitrix Framework:
 * - removed integration with RequireJS and AMD package builders;
 */
(function(global,undefined){"use strict";(function prelude(modules, cache, entries) {

    // This is the prelude used to bundle protobuf.js for the browser. Wraps up the CommonJS
    // sources through a conflict-free require shim and is again wrapped within an iife that
    // provides a unified `global` and a minification-friendly `undefined` var plus a global
    // "use strict" directive so that minification can remove the directives of each module.

    function $require(name) {
        var $module = cache[name];
        if (!$module)
            modules[name][0].call($module = cache[name] = { exports: {} }, $require, $module, $module.exports);
        return $module.exports;
    }

    // Expose globally
    var protobuf = global.protobuf = $require(entries[0]);

    // Be nice to AMD
    /*if (typeof define === "function" && define.amd)
        define(["long"], function(Long) {
            if (Long && Long.isLong) {
                protobuf.util.Long = Long;
                protobuf.configure();
            }
            return protobuf;
        });*/

    // Be nice to CommonJS
    /*if (typeof module === "object" && module && module.exports)
        module.exports = protobuf;*/

})/* end of prelude */({1:[function(require,module,exports){
"use strict";
module.exports = asPromise;

/**
 * Callback as used by {@link util.asPromise}.
 * @typedef asPromiseCallback
 * @type {function}
 * @param {Error|null} error Error, if any
 * @param {...*} params Additional arguments
 * @returns {undefined}
 */

/**
 * Returns a promise from a node-style callback function.
 * @memberof util
 * @param {asPromiseCallback} fn Function to call
 * @param {*} ctx Function context
 * @param {...*} params Function arguments
 * @returns {Promise<*>} Promisified function
 */
function asPromise(fn, ctx/*, varargs */) {
    var params  = new Array(arguments.length - 1),
        offset  = 0,
        index   = 2,
        pending = true;
    while (index < arguments.length)
        params[offset++] = arguments[index++];
    return new Promise(function executor(resolve, reject) {
        params[offset] = function callback(err/*, varargs */) {
            if (pending) {
                pending = false;
                if (err)
                    reject(err);
                else {
                    var params = new Array(arguments.length - 1),
                        offset = 0;
                    while (offset < params.length)
                        params[offset++] = arguments[offset];
                    resolve.apply(null, params);
                }
            }
        };
        try {
            fn.apply(ctx || null, params);
        } catch (err) {
            if (pending) {
                pending = false;
                reject(err);
            }
        }
    });
}

},{}],2:[function(require,module,exports){
"use strict";

/**
 * A minimal base64 implementation for number arrays.
 * @memberof util
 * @namespace
 */
var base64 = exports;

/**
 * Calculates the byte length of a base64 encoded string.
 * @param {string} string Base64 encoded string
 * @returns {number} Byte length
 */
base64.length = function length(string) {
    var p = string.length;
    if (!p)
        return 0;
    var n = 0;
    while (--p % 4 > 1 && string.charAt(p) === "=")
        ++n;
    return Math.ceil(string.length * 3) / 4 - n;
};

// Base64 encoding table
var b64 = new Array(64);

// Base64 decoding table
var s64 = new Array(123);

// 65..90, 97..122, 48..57, 43, 47
for (var i = 0; i < 64;)
    s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;

/**
 * Encodes a buffer to a base64 encoded string.
 * @param {Uint8Array} buffer Source buffer
 * @param {number} start Source start
 * @param {number} end Source end
 * @returns {string} Base64 encoded string
 */
base64.encode = function encode(buffer, start, end) {
    var parts = null,
        chunk = [];
    var i = 0, // output index
        j = 0, // goto index
        t;     // temporary
    while (start < end) {
        var b = buffer[start++];
        switch (j) {
            case 0:
                chunk[i++] = b64[b >> 2];
                t = (b & 3) << 4;
                j = 1;
                break;
            case 1:
                chunk[i++] = b64[t | b >> 4];
                t = (b & 15) << 2;
                j = 2;
                break;
            case 2:
                chunk[i++] = b64[t | b >> 6];
                chunk[i++] = b64[b & 63];
                j = 0;
                break;
        }
        if (i > 8191) {
            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
            i = 0;
        }
    }
    if (j) {
        chunk[i++] = b64[t];
        chunk[i++] = 61;
        if (j === 1)
            chunk[i++] = 61;
    }
    if (parts) {
        if (i)
            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
    }
    return String.fromCharCode.apply(String, chunk.slice(0, i));
};

var invalidEncoding = "invalid encoding";

/**
 * Decodes a base64 encoded string to a buffer.
 * @param {string} string Source string
 * @param {Uint8Array} buffer Destination buffer
 * @param {number} offset Destination offset
 * @returns {number} Number of bytes written
 * @throws {Error} If encoding is invalid
 */
base64.decode = function decode(string, buffer, offset) {
    var start = offset;
    var j = 0, // goto index
        t;     // temporary
    for (var i = 0; i < string.length;) {
        var c = string.charCodeAt(i++);
        if (c === 61 && j > 1)
            break;
        if ((c = s64[c]) === undefined)
            throw Error(invalidEncoding);
        switch (j) {
            case 0:
                t = c;
                j = 1;
                break;
            case 1:
                buffer[offset++] = t << 2 | (c & 48) >> 4;
                t = c;
                j = 2;
                break;
            case 2:
                buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;
                t = c;
                j = 3;
                break;
            case 3:
                buffer[offset++] = (t & 3) << 6 | c;
                j = 0;
                break;
        }
    }
    if (j === 1)
        throw Error(invalidEncoding);
    return offset - start;
};

/**
 * Tests if the specified string appears to be base64 encoded.
 * @param {string} string String to test
 * @returns {boolean} `true` if probably base64 encoded, otherwise false
 */
base64.test = function test(string) {
    return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);
};

},{}],3:[function(require,module,exports){
"use strict";
module.exports = codegen;

/**
 * Begins generating a function.
 * @memberof util
 * @param {string[]} functionParams Function parameter names
 * @param {string} [functionName] Function name if not anonymous
 * @returns {Codegen} Appender that appends code to the function's body
 */
function codegen(functionParams, functionName) {

    /* istanbul ignore if */
    if (typeof functionParams === "string") {
        functionName = functionParams;
        functionParams = undefined;
    }

    var body = [];

    /**
     * Appends code to the function's body or finishes generation.
     * @typedef Codegen
     * @type {function}
     * @param {string|Object.<string,*>} [formatStringOrScope] Format string or, to finish the function, an object of additional scope variables, if any
     * @param {...*} [formatParams] Format parameters
     * @returns {Codegen|Function} Itself or the generated function if finished
     * @throws {Error} If format parameter counts do not match
     */

    function Codegen(formatStringOrScope) {
        // note that explicit array handling below makes this ~50% faster

        // finish the function
        if (typeof formatStringOrScope !== "string") {
            var source = toString();
            if (codegen.verbose)
                console.log("codegen: " + source); // eslint-disable-line no-console
            source = "return " + source;
            if (formatStringOrScope) {
                var scopeKeys   = Object.keys(formatStringOrScope),
                    scopeParams = new Array(scopeKeys.length + 1),
                    scopeValues = new Array(scopeKeys.length),
                    scopeOffset = 0;
                while (scopeOffset < scopeKeys.length) {
                    scopeParams[scopeOffset] = scopeKeys[scopeOffset];
                    scopeValues[scopeOffset] = formatStringOrScope[scopeKeys[scopeOffset++]];
                }
                scopeParams[scopeOffset] = source;
                return Function.apply(null, scopeParams).apply(null, scopeValues); // eslint-disable-line no-new-func
            }
            return Function(source)(); // eslint-disable-line no-new-func
        }

        // otherwise append to body
        var formatParams = new Array(arguments.length - 1),
            formatOffset = 0;
        while (formatOffset < formatParams.length)
            formatParams[formatOffset] = arguments[++formatOffset];
        formatOffset = 0;
        formatStringOrScope = formatStringOrScope.replace(/%([%dfijs])/g, function replace($0, $1) {
            var value = formatParams[formatOffset++];
            switch ($1) {
                case "d": case "f": return String(Number(value));
                case "i": return String(Math.floor(value));
                case "j": return JSON.stringify(value);
                case "s": return String(value);
            }
            return "%";
        });
        if (formatOffset !== formatParams.length)
            throw Error("parameter count mismatch");
        body.push(formatStringOrScope);
        return Codegen;
    }

    function toString(functionNameOverride) {
        return "function " + (functionNameOverride || functionName || "") + "(" + (functionParams && functionParams.join(",") || "") + "){\n  " + body.join("\n  ") + "\n}";
    }

    Codegen.toString = toString;
    return Codegen;
}

/**
 * Begins generating a function.
 * @memberof util
 * @function codegen
 * @param {string} [functionName] Function name if not anonymous
 * @returns {Codegen} Appender that appends code to the function's body
 * @variation 2
 */

/**
 * When set to `true`, codegen will log generated code to console. Useful for debugging.
 * @name util.codegen.verbose
 * @type {boolean}
 */
codegen.verbose = false;

},{}],4:[function(require,module,exports){
"use strict";
module.exports = EventEmitter;

/**
 * Constructs a new event emitter instance.
 * @classdesc A minimal event emitter.
 * @memberof util
 * @constructor
 */
function EventEmitter() {

    /**
     * Registered listeners.
     * @type {Object.<string,*>}
     * @private
     */
    this._listeners = {};
}

/**
 * Registers an event listener.
 * @param {string} evt Event name
 * @param {function} fn Listener
 * @param {*} [ctx] Listener context
 * @returns {util.EventEmitter} `this`
 */
EventEmitter.prototype.on = function on(evt, fn, ctx) {
    (this._listeners[evt] || (this._listeners[evt] = [])).push({
        fn  : fn,
        ctx : ctx || this
    });
    return this;
};

/**
 * Removes an event listener or any matching listeners if arguments are omitted.
 * @param {string} [evt] Event name. Removes all listeners if omitted.
 * @param {function} [fn] Listener to remove. Removes all listeners of `evt` if omitted.
 * @returns {util.EventEmitter} `this`
 */
EventEmitter.prototype.off = function off(evt, fn) {
    if (evt === undefined)
        this._listeners = {};
    else {
        if (fn === undefined)
            this._listeners[evt] = [];
        else {
            var listeners = this._listeners[evt];
            for (var i = 0; i < listeners.length;)
                if (listeners[i].fn === fn)
                    listeners.splice(i, 1);
                else
                    ++i;
        }
    }
    return this;
};

/**
 * Emits an event by calling its listeners with the specified arguments.
 * @param {string} evt Event name
 * @param {...*} args Arguments
 * @returns {util.EventEmitter} `this`
 */
EventEmitter.prototype.emit = function emit(evt) {
    var listeners = this._listeners[evt];
    if (listeners) {
        var args = [],
            i = 1;
        for (; i < arguments.length;)
            args.push(arguments[i++]);
        for (i = 0; i < listeners.length;)
            listeners[i].fn.apply(listeners[i++].ctx, args);
    }
    return this;
};

},{}],5:[function(require,module,exports){
"use strict";
module.exports = fetch;

var asPromise = require(1),
    inquire   = require(7);

var fs = inquire("fs");

/**
 * Node-style callback as used by {@link util.fetch}.
 * @typedef FetchCallback
 * @type {function}
 * @param {?Error} error Error, if any, otherwise `null`
 * @param {string} [contents] File contents, if there hasn't been an error
 * @returns {undefined}
 */

/**
 * Options as used by {@link util.fetch}.
 * @typedef FetchOptions
 * @type {Object}
 * @property {boolean} [binary=false] Whether expecting a binary response
 * @property {boolean} [xhr=false] If `true`, forces the use of XMLHttpRequest
 */

/**
 * Fetches the contents of a file.
 * @memberof util
 * @param {string} filename File path or url
 * @param {FetchOptions} options Fetch options
 * @param {FetchCallback} callback Callback function
 * @returns {undefined}
 */
function fetch(filename, options, callback) {
    if (typeof options === "function") {
        callback = options;
        options = {};
    } else if (!options)
        options = {};

    if (!callback)
        return asPromise(fetch, this, filename, options); // eslint-disable-line no-invalid-this

    // if a node-like filesystem is present, try it first but fall back to XHR if nothing is found.
    if (!options.xhr && fs && fs.readFile)
        return fs.readFile(filename, function fetchReadFileCallback(err, contents) {
            return err && typeof XMLHttpRequest !== "undefined"
                ? fetch.xhr(filename, options, callback)
                : err
                ? callback(err)
                : callback(null, options.binary ? contents : contents.toString("utf8"));
        });

    // use the XHR version otherwise.
    return fetch.xhr(filename, options, callback);
}

/**
 * Fetches the contents of a file.
 * @name util.fetch
 * @function
 * @param {string} path File path or url
 * @param {FetchCallback} callback Callback function
 * @returns {undefined}
 * @variation 2
 */

/**
 * Fetches the contents of a file.
 * @name util.fetch
 * @function
 * @param {string} path File path or url
 * @param {FetchOptions} [options] Fetch options
 * @returns {Promise<string|Uint8Array>} Promise
 * @variation 3
 */

/**/
fetch.xhr = function fetch_xhr(filename, options, callback) {
    var xhr = new XMLHttpRequest();
    xhr.onreadystatechange /* works everywhere */ = function fetchOnReadyStateChange() {

        if (xhr.readyState !== 4)
            return undefined;

        // local cors security errors return status 0 / empty string, too. afaik this cannot be
        // reliably distinguished from an actually empty file for security reasons. feel free
        // to send a pull request if you are aware of a solution.
        if (xhr.status !== 0 && xhr.status !== 200)
            return callback(Error("status " + xhr.status));

        // if binary data is expected, make sure that some sort of array is returned, even if
        // ArrayBuffers are not supported. the binary string fallback, however, is unsafe.
        if (options.binary) {
            var buffer = xhr.response;
            if (!buffer) {
                buffer = [];
                for (var i = 0; i < xhr.responseText.length; ++i)
                    buffer.push(xhr.responseText.charCodeAt(i) & 255);
            }
            return callback(null, typeof Uint8Array !== "undefined" ? new Uint8Array(buffer) : buffer);
        }
        return callback(null, xhr.responseText);
    };

    if (options.binary) {
        // ref: https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/Sending_and_Receiving_Binary_Data#Receiving_binary_data_in_older_browsers
        if ("overrideMimeType" in xhr)
            xhr.overrideMimeType("text/plain; charset=x-user-defined");
        xhr.responseType = "arraybuffer";
    }

    xhr.open("GET", filename);
    xhr.send();
};

},{"1":1,"7":7}],6:[function(require,module,exports){
"use strict";

module.exports = factory(factory);

/**
 * Reads / writes floats / doubles from / to buffers.
 * @name util.float
 * @namespace
 */

/**
 * Writes a 32 bit float to a buffer using little endian byte order.
 * @name util.float.writeFloatLE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Writes a 32 bit float to a buffer using big endian byte order.
 * @name util.float.writeFloatBE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Reads a 32 bit float from a buffer using little endian byte order.
 * @name util.float.readFloatLE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

/**
 * Reads a 32 bit float from a buffer using big endian byte order.
 * @name util.float.readFloatBE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

/**
 * Writes a 64 bit double to a buffer using little endian byte order.
 * @name util.float.writeDoubleLE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Writes a 64 bit double to a buffer using big endian byte order.
 * @name util.float.writeDoubleBE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Reads a 64 bit double from a buffer using little endian byte order.
 * @name util.float.readDoubleLE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

/**
 * Reads a 64 bit double from a buffer using big endian byte order.
 * @name util.float.readDoubleBE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

// Factory function for the purpose of node-based testing in modified global environments
function factory(exports) {

    // float: typed array
    if (typeof Float32Array !== "undefined") (function() {

        var f32 = new Float32Array([ -0 ]),
            f8b = new Uint8Array(f32.buffer),
            le  = f8b[3] === 128;

        function writeFloat_f32_cpy(val, buf, pos) {
            f32[0] = val;
            buf[pos    ] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
        }

        function writeFloat_f32_rev(val, buf, pos) {
            f32[0] = val;
            buf[pos    ] = f8b[3];
            buf[pos + 1] = f8b[2];
            buf[pos + 2] = f8b[1];
            buf[pos + 3] = f8b[0];
        }

        /* istanbul ignore next */
        exports.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;
        /* istanbul ignore next */
        exports.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;

        function readFloat_f32_cpy(buf, pos) {
            f8b[0] = buf[pos    ];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            return f32[0];
        }

        function readFloat_f32_rev(buf, pos) {
            f8b[3] = buf[pos    ];
            f8b[2] = buf[pos + 1];
            f8b[1] = buf[pos + 2];
            f8b[0] = buf[pos + 3];
            return f32[0];
        }

        /* istanbul ignore next */
        exports.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;
        /* istanbul ignore next */
        exports.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;

    // float: ieee754
    })(); else (function() {

        function writeFloat_ieee754(writeUint, val, buf, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign)
                val = -val;
            if (val === 0)
                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos);
            else if (isNaN(val))
                writeUint(2143289344, buf, pos);
            else if (val > 3.4028234663852886e+38) // +-Infinity
                writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);
            else if (val < 1.1754943508222875e-38) // denormal
                writeUint((sign << 31 | Math.round(val / 1.401298464324817e-45)) >>> 0, buf, pos);
            else {
                var exponent = Math.floor(Math.log(val) / Math.LN2),
                    mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
                writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);
            }
        }

        exports.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
        exports.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);

        function readFloat_ieee754(readUint, buf, pos) {
            var uint = readUint(buf, pos),
                sign = (uint >> 31) * 2 + 1,
                exponent = uint >>> 23 & 255,
                mantissa = uint & 8388607;
            return exponent === 255
                ? mantissa
                ? NaN
                : sign * Infinity
                : exponent === 0 // denormal
                ? sign * 1.401298464324817e-45 * mantissa
                : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);
        }

        exports.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
        exports.readFloatBE = readFloat_ieee754.bind(null, readUintBE);

    })();

    // double: typed array
    if (typeof Float64Array !== "undefined") (function() {

        var f64 = new Float64Array([-0]),
            f8b = new Uint8Array(f64.buffer),
            le  = f8b[7] === 128;

        function writeDouble_f64_cpy(val, buf, pos) {
            f64[0] = val;
            buf[pos    ] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
            buf[pos + 4] = f8b[4];
            buf[pos + 5] = f8b[5];
            buf[pos + 6] = f8b[6];
            buf[pos + 7] = f8b[7];
        }

        function writeDouble_f64_rev(val, buf, pos) {
            f64[0] = val;
            buf[pos    ] = f8b[7];
            buf[pos + 1] = f8b[6];
            buf[pos + 2] = f8b[5];
            buf[pos + 3] = f8b[4];
            buf[pos + 4] = f8b[3];
            buf[pos + 5] = f8b[2];
            buf[pos + 6] = f8b[1];
            buf[pos + 7] = f8b[0];
        }

        /* istanbul ignore next */
        exports.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;
        /* istanbul ignore next */
        exports.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;

        function readDouble_f64_cpy(buf, pos) {
            f8b[0] = buf[pos    ];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            f8b[4] = buf[pos + 4];
            f8b[5] = buf[pos + 5];
            f8b[6] = buf[pos + 6];
            f8b[7] = buf[pos + 7];
            return f64[0];
        }

        function readDouble_f64_rev(buf, pos) {
            f8b[7] = buf[pos    ];
            f8b[6] = buf[pos + 1];
            f8b[5] = buf[pos + 2];
            f8b[4] = buf[pos + 3];
            f8b[3] = buf[pos + 4];
            f8b[2] = buf[pos + 5];
            f8b[1] = buf[pos + 6];
            f8b[0] = buf[pos + 7];
            return f64[0];
        }

        /* istanbul ignore next */
        exports.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;
        /* istanbul ignore next */
        exports.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;

    // double: ieee754
    })(); else (function() {

        function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign)
                val = -val;
            if (val === 0) {
                writeUint(0, buf, pos + off0);
                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos + off1);
            } else if (isNaN(val)) {
                writeUint(0, buf, pos + off0);
                writeUint(2146959360, buf, pos + off1);
            } else if (val > 1.7976931348623157e+308) { // +-Infinity
                writeUint(0, buf, pos + off0);
                writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);
            } else {
                var mantissa;
                if (val < 2.2250738585072014e-308) { // denormal
                    mantissa = val / 5e-324;
                    writeUint(mantissa >>> 0, buf, pos + off0);
                    writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);
                } else {
                    var exponent = Math.floor(Math.log(val) / Math.LN2);
                    if (exponent === 1024)
                        exponent = 1023;
                    mantissa = val * Math.pow(2, -exponent);
                    writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);
                    writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);
                }
            }
        }

        exports.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
        exports.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);

        function readDouble_ieee754(readUint, off0, off1, buf, pos) {
            var lo = readUint(buf, pos + off0),
                hi = readUint(buf, pos + off1);
            var sign = (hi >> 31) * 2 + 1,
                exponent = hi >>> 20 & 2047,
                mantissa = 4294967296 * (hi & 1048575) + lo;
            return exponent === 2047
                ? mantissa
                ? NaN
                : sign * Infinity
                : exponent === 0 // denormal
                ? sign * 5e-324 * mantissa
                : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
        }

        exports.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
        exports.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);

    })();

    return exports;
}

// uint helpers

function writeUintLE(val, buf, pos) {
    buf[pos    ] =  val        & 255;
    buf[pos + 1] =  val >>> 8  & 255;
    buf[pos + 2] =  val >>> 16 & 255;
    buf[pos + 3] =  val >>> 24;
}

function writeUintBE(val, buf, pos) {
    buf[pos    ] =  val >>> 24;
    buf[pos + 1] =  val >>> 16 & 255;
    buf[pos + 2] =  val >>> 8  & 255;
    buf[pos + 3] =  val        & 255;
}

function readUintLE(buf, pos) {
    return (buf[pos    ]
          | buf[pos + 1] << 8
          | buf[pos + 2] << 16
          | buf[pos + 3] << 24) >>> 0;
}

function readUintBE(buf, pos) {
    return (buf[pos    ] << 24
          | buf[pos + 1] << 16
          | buf[pos + 2] << 8
          | buf[pos + 3]) >>> 0;
}

},{}],7:[function(require,module,exports){
"use strict";
module.exports = inquire;

/**
 * Requires a module only if available.
 * @memberof util
 * @param {string} moduleName Module to require
 * @returns {?Object} Required module if available and not empty, otherwise `null`
 */
function inquire(moduleName) {
    try {
        var mod = eval("quire".replace(/^/,"re"))(moduleName); // eslint-disable-line no-eval
        if (mod && (mod.length || Object.keys(mod).length))
            return mod;
    } catch (e) {} // eslint-disable-line no-empty
    return null;
}

},{}],8:[function(require,module,exports){
"use strict";

/**
 * A minimal path module to resolve Unix, Windows and URL paths alike.
 * @memberof util
 * @namespace
 */
var path = exports;

var isAbsolute =
/**
 * Tests if the specified path is absolute.
 * @param {string} path Path to test
 * @returns {boolean} `true` if path is absolute
 */
path.isAbsolute = function isAbsolute(path) {
    return /^(?:\/|\w+:)/.test(path);
};

var normalize =
/**
 * Normalizes the specified path.
 * @param {string} path Path to normalize
 * @returns {string} Normalized path
 */
path.normalize = function normalize(path) {
    path = path.replace(/\\/g, "/")
               .replace(/\/{2,}/g, "/");
    var parts    = path.split("/"),
        absolute = isAbsolute(path),
        prefix   = "";
    if (absolute)
        prefix = parts.shift() + "/";
    for (var i = 0; i < parts.length;) {
        if (parts[i] === "..") {
            if (i > 0 && parts[i - 1] !== "..")
                parts.splice(--i, 2);
            else if (absolute)
                parts.splice(i, 1);
            else
                ++i;
        } else if (parts[i] === ".")
            parts.splice(i, 1);
        else
            ++i;
    }
    return prefix + parts.join("/");
};

/**
 * Resolves the specified include path against the specified origin path.
 * @param {string} originPath Path to the origin file
 * @param {string} includePath Include path relative to origin path
 * @param {boolean} [alreadyNormalized=false] `true` if both paths are already known to be normalized
 * @returns {string} Path to the include file
 */
path.resolve = function resolve(originPath, includePath, alreadyNormalized) {
    if (!alreadyNormalized)
        includePath = normalize(includePath);
    if (isAbsolute(includePath))
        return includePath;
    if (!alreadyNormalized)
        originPath = normalize(originPath);
    return (originPath = originPath.replace(/(?:\/|^)[^/]+$/, "")).length ? normalize(originPath + "/" + includePath) : includePath;
};

},{}],9:[function(require,module,exports){
"use strict";
module.exports = pool;

/**
 * An allocator as used by {@link util.pool}.
 * @typedef PoolAllocator
 * @type {function}
 * @param {number} size Buffer size
 * @returns {Uint8Array} Buffer
 */

/**
 * A slicer as used by {@link util.pool}.
 * @typedef PoolSlicer
 * @type {function}
 * @param {number} start Start offset
 * @param {number} end End offset
 * @returns {Uint8Array} Buffer slice
 * @this {Uint8Array}
 */

/**
 * A general purpose buffer pool.
 * @memberof util
 * @function
 * @param {PoolAllocator} alloc Allocator
 * @param {PoolSlicer} slice Slicer
 * @param {number} [size=8192] Slab size
 * @returns {PoolAllocator} Pooled allocator
 */
function pool(alloc, slice, size) {
    var SIZE   = size || 8192;
    var MAX    = SIZE >>> 1;
    var slab   = null;
    var offset = SIZE;
    return function pool_alloc(size) {
        if (size < 1 || size > MAX)
            return alloc(size);
        if (offset + size > SIZE) {
            slab = alloc(SIZE);
            offset = 0;
        }
        var buf = slice.call(slab, offset, offset += size);
        if (offset & 7) // align to 32 bit
            offset = (offset | 7) + 1;
        return buf;
    };
}

},{}],10:[function(require,module,exports){
"use strict";

/**
 * A minimal UTF8 implementation for number arrays.
 * @memberof util
 * @namespace
 */
var utf8 = exports;

/**
 * Calculates the UTF8 byte length of a string.
 * @param {string} string String
 * @returns {number} Byte length
 */
utf8.length = function utf8_length(string) {
    var len = 0,
        c = 0;
    for (var i = 0; i < string.length; ++i) {
        c = string.charCodeAt(i);
        if (c < 128)
            len += 1;
        else if (c < 2048)
            len += 2;
        else if ((c & 0xFC00) === 0xD800 && (string.charCodeAt(i + 1) & 0xFC00) === 0xDC00) {
            ++i;
            len += 4;
        } else
            len += 3;
    }
    return len;
};

/**
 * Reads UTF8 bytes as a string.
 * @param {Uint8Array} buffer Source buffer
 * @param {number} start Source start
 * @param {number} end Source end
 * @returns {string} String read
 */
utf8.read = function utf8_read(buffer, start, end) {
    var len = end - start;
    if (len < 1)
        return "";
    var parts = null,
        chunk = [],
        i = 0, // char offset
        t;     // temporary
    while (start < end) {
        t = buffer[start++];
        if (t < 128)
            chunk[i++] = t;
        else if (t > 191 && t < 224)
            chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;
        else if (t > 239 && t < 365) {
            t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 0x10000;
            chunk[i++] = 0xD800 + (t >> 10);
            chunk[i++] = 0xDC00 + (t & 1023);
        } else
            chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;
        if (i > 8191) {
            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
            i = 0;
        }
    }
    if (parts) {
        if (i)
            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
    }
    return String.fromCharCode.apply(String, chunk.slice(0, i));
};

/**
 * Writes a string as UTF8 bytes.
 * @param {string} string Source string
 * @param {Uint8Array} buffer Destination buffer
 * @param {number} offset Destination offset
 * @returns {number} Bytes written
 */
utf8.write = function utf8_write(string, buffer, offset) {
    var start = offset,
        c1, // character 1
        c2; // character 2
    for (var i = 0; i < string.length; ++i) {
        c1 = string.charCodeAt(i);
        if (c1 < 128) {
            buffer[offset++] = c1;
        } else if (c1 < 2048) {
            buffer[offset++] = c1 >> 6       | 192;
            buffer[offset++] = c1       & 63 | 128;
        } else if ((c1 & 0xFC00) === 0xD800 && ((c2 = string.charCodeAt(i + 1)) & 0xFC00) === 0xDC00) {
            c1 = 0x10000 + ((c1 & 0x03FF) << 10) + (c2 & 0x03FF);
            ++i;
            buffer[offset++] = c1 >> 18      | 240;
            buffer[offset++] = c1 >> 12 & 63 | 128;
            buffer[offset++] = c1 >> 6  & 63 | 128;
            buffer[offset++] = c1       & 63 | 128;
        } else {
            buffer[offset++] = c1 >> 12      | 224;
            buffer[offset++] = c1 >> 6  & 63 | 128;
            buffer[offset++] = c1       & 63 | 128;
        }
    }
    return offset - start;
};

},{}],11:[function(require,module,exports){
"use strict";
module.exports = common;

var commonRe = /\/|\./;

/**
 * Provides common type definitions.
 * Can also be used to provide additional google types or your own custom types.
 * @param {string} name Short name as in `google/protobuf/[name].proto` or full file name
 * @param {Object.<string,*>} json JSON definition within `google.protobuf` if a short name, otherwise the file's root definition
 * @returns {undefined}
 * @property {INamespace} google/protobuf/any.proto Any
 * @property {INamespace} google/protobuf/duration.proto Duration
 * @property {INamespace} google/protobuf/empty.proto Empty
 * @property {INamespace} google/protobuf/field_mask.proto FieldMask
 * @property {INamespace} google/protobuf/struct.proto Struct, Value, NullValue and ListValue
 * @property {INamespace} google/protobuf/timestamp.proto Timestamp
 * @property {INamespace} google/protobuf/wrappers.proto Wrappers
 * @example
 * // manually provides descriptor.proto (assumes google/protobuf/ namespace and .proto extension)
 * protobuf.common("descriptor", descriptorJson);
 *
 * // manually provides a custom definition (uses my.foo namespace)
 * protobuf.common("my/foo/bar.proto", myFooBarJson);
 */
function common(name, json) {
    if (!commonRe.test(name)) {
        name = "google/protobuf/" + name + ".proto";
        json = { nested: { google: { nested: { protobuf: { nested: json } } } } };
    }
    common[name] = json;
}

// Not provided because of limited use (feel free to discuss or to provide yourself):
//
// google/protobuf/descriptor.proto
// google/protobuf/source_context.proto
// google/protobuf/type.proto
//
// Stripped and pre-parsed versions of these non-bundled files are instead available as part of
// the repository or package within the google/protobuf directory.

common("any", {

    /**
     * Properties of a google.protobuf.Any message.
     * @interface IAny
     * @type {Object}
     * @property {string} [typeUrl]
     * @property {Uint8Array} [bytes]
     * @memberof common
     */
    Any: {
        fields: {
            type_url: {
                type: "string",
                id: 1
            },
            value: {
                type: "bytes",
                id: 2
            }
        }
    }
});

var timeType;

common("duration", {

    /**
     * Properties of a google.protobuf.Duration message.
     * @interface IDuration
     * @type {Object}
     * @property {number|Long} [seconds]
     * @property {number} [nanos]
     * @memberof common
     */
    Duration: timeType = {
        fields: {
            seconds: {
                type: "int64",
                id: 1
            },
            nanos: {
                type: "int32",
                id: 2
            }
        }
    }
});

common("timestamp", {

    /**
     * Properties of a google.protobuf.Timestamp message.
     * @interface ITimestamp
     * @type {Object}
     * @property {number|Long} [seconds]
     * @property {number} [nanos]
     * @memberof common
     */
    Timestamp: timeType
});

common("empty", {

    /**
     * Properties of a google.protobuf.Empty message.
     * @interface IEmpty
     * @memberof common
     */
    Empty: {
        fields: {}
    }
});

common("struct", {

    /**
     * Properties of a google.protobuf.Struct message.
     * @interface IStruct
     * @type {Object}
     * @property {Object.<string,IValue>} [fields]
     * @memberof common
     */
    Struct: {
        fields: {
            fields: {
                keyType: "string",
                type: "Value",
                id: 1
            }
        }
    },

    /**
     * Properties of a google.protobuf.Value message.
     * @interface IValue
     * @type {Object}
     * @property {string} [kind]
     * @property {0} [nullValue]
     * @property {number} [numberValue]
     * @property {string} [stringValue]
     * @property {boolean} [boolValue]
     * @property {IStruct} [structValue]
     * @property {IListValue} [listValue]
     * @memberof common
     */
    Value: {
        oneofs: {
            kind: {
                oneof: [
                    "nullValue",
                    "numberValue",
                    "stringValue",
                    "boolValue",
                    "structValue",
                    "listValue"
                ]
            }
        },
        fields: {
            nullValue: {
                type: "NullValue",
                id: 1
            },
            numberValue: {
                type: "double",
                id: 2
            },
            stringValue: {
                type: "string",
                id: 3
            },
            boolValue: {
                type: "bool",
                id: 4
            },
            structValue: {
                type: "Struct",
                id: 5
            },
            listValue: {
                type: "ListValue",
                id: 6
            }
        }
    },

    NullValue: {
        values: {
            NULL_VALUE: 0
        }
    },

    /**
     * Properties of a google.protobuf.ListValue message.
     * @interface IListValue
     * @type {Object}
     * @property {Array.<IValue>} [values]
     * @memberof common
     */
    ListValue: {
        fields: {
            values: {
                rule: "repeated",
                type: "Value",
                id: 1
            }
        }
    }
});

common("wrappers", {

    /**
     * Properties of a google.protobuf.DoubleValue message.
     * @interface IDoubleValue
     * @type {Object}
     * @property {number} [value]
     * @memberof common
     */
    DoubleValue: {
        fields: {
            value: {
                type: "double",
                id: 1
            }
        }
    },

    /**
     * Properties of a google.protobuf.FloatValue message.
     * @interface IFloatValue
     * @type {Object}
     * @property {number} [value]
     * @memberof common
     */
    FloatValue: {
        fields: {
            value: {
                type: "float",
                id: 1
            }
        }
    },

    /**
     * Properties of a google.protobuf.Int64Value message.
     * @interface IInt64Value
     * @type {Object}
     * @property {number|Long} [value]
     * @memberof common
     */
    Int64Value: {
        fields: {
            value: {
                type: "int64",
                id: 1
            }
        }
    },

    /**
     * Properties of a google.protobuf.UInt64Value message.
     * @interface IUInt64Value
     * @type {Object}
     * @property {number|Long} [value]
     * @memberof common
     */
    UInt64Value: {
        fields: {
            value: {
                type: "uint64",
                id: 1
            }
        }
    },

    /**
     * Properties of a google.protobuf.Int32Value message.
     * @interface IInt32Value
     * @type {Object}
     * @property {number} [value]
     * @memberof common
     */
    Int32Value: {
        fields: {
            value: {
                type: "int32",
                id: 1
            }
        }
    },

    /**
     * Properties of a google.protobuf.UInt32Value message.
     * @interface IUInt32Value
     * @type {Object}
     * @property {number} [value]
     * @memberof common
     */
    UInt32Value: {
        fields: {
            value: {
                type: "uint32",
                id: 1
            }
        }
    },

    /**
     * Properties of a google.protobuf.BoolValue message.
     * @interface IBoolValue
     * @type {Object}
     * @property {boolean} [value]
     * @memberof common
     */
    BoolValue: {
        fields: {
            value: {
                type: "bool",
                id: 1
            }
        }
    },

    /**
     * Properties of a google.protobuf.StringValue message.
     * @interface IStringValue
     * @type {Object}
     * @property {string} [value]
     * @memberof common
     */
    StringValue: {
        fields: {
            value: {
                type: "string",
                id: 1
            }
        }
    },

    /**
     * Properties of a google.protobuf.BytesValue message.
     * @interface IBytesValue
     * @type {Object}
     * @property {Uint8Array} [value]
     * @memberof common
     */
    BytesValue: {
        fields: {
            value: {
                type: "bytes",
                id: 1
            }
        }
    }
});

common("field_mask", {

    /**
     * Properties of a google.protobuf.FieldMask message.
     * @interface IDoubleValue
     * @type {Object}
     * @property {number} [value]
     * @memberof common
     */
    FieldMask: {
        fields: {
            paths: {
                rule: "repeated",
                type: "string",
                id: 1
            }
        }
    }
});

/**
 * Gets the root definition of the specified common proto file.
 *
 * Bundled definitions are:
 * - google/protobuf/any.proto
 * - google/protobuf/duration.proto
 * - google/protobuf/empty.proto
 * - google/protobuf/field_mask.proto
 * - google/protobuf/struct.proto
 * - google/protobuf/timestamp.proto
 * - google/protobuf/wrappers.proto
 *
 * @param {string} file Proto file name
 * @returns {INamespace|null} Root definition or `null` if not defined
 */
common.get = function get(file) {
    return common[file] || null;
};

},{}],12:[function(require,module,exports){
"use strict";
/**
 * Runtime message from/to plain object converters.
 * @namespace
 */
var converter = exports;

var Enum = require(15),
    util = require(37);

/**
 * Generates a partial value fromObject conveter.
 * @param {Codegen} gen Codegen instance
 * @param {Field} field Reflected field
 * @param {number} fieldIndex Field index
 * @param {string} prop Property reference
 * @returns {Codegen} Codegen instance
 * @ignore
 */
function genValuePartial_fromObject(gen, field, fieldIndex, prop) {
    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */
    if (field.resolvedType) {
        if (field.resolvedType instanceof Enum) { gen
            ("switch(d%s){", prop);
            for (var values = field.resolvedType.values, keys = Object.keys(values), i = 0; i < keys.length; ++i) {
                if (field.repeated && values[keys[i]] === field.typeDefault) gen
                ("default:");
                gen
                ("case%j:", keys[i])
                ("case %i:", values[keys[i]])
                    ("m%s=%j", prop, values[keys[i]])
                    ("break");
            } gen
            ("}");
        } else gen
            ("if(typeof d%s!==\"object\")", prop)
                ("throw TypeError(%j)", field.fullName + ": object expected")
            ("m%s=types[%i].fromObject(d%s)", prop, fieldIndex, prop);
    } else {
        var isUnsigned = false;
        switch (field.type) {
            case "double":
            case "float": gen
                ("m%s=Number(d%s)", prop, prop); // also catches "NaN", "Infinity"
                break;
            case "uint32":
            case "fixed32": gen
                ("m%s=d%s>>>0", prop, prop);
                break;
            case "int32":
            case "sint32":
            case "sfixed32": gen
                ("m%s=d%s|0", prop, prop);
                break;
            case "uint64":
                isUnsigned = true;
                // eslint-disable-line no-fallthrough
            case "int64":
            case "sint64":
            case "fixed64":
            case "sfixed64": gen
                ("if(util.Long)")
                    ("(m%s=util.Long.fromValue(d%s)).unsigned=%j", prop, prop, isUnsigned)
                ("else if(typeof d%s===\"string\")", prop)
                    ("m%s=parseInt(d%s,10)", prop, prop)
                ("else if(typeof d%s===\"number\")", prop)
                    ("m%s=d%s", prop, prop)
                ("else if(typeof d%s===\"object\")", prop)
                    ("m%s=new util.LongBits(d%s.low>>>0,d%s.high>>>0).toNumber(%s)", prop, prop, prop, isUnsigned ? "true" : "");
                break;
            case "bytes": gen
                ("if(typeof d%s===\"string\")", prop)
                    ("util.base64.decode(d%s,m%s=util.newBuffer(util.base64.length(d%s)),0)", prop, prop, prop)
                ("else if(d%s.length)", prop)
                    ("m%s=d%s", prop, prop);
                break;
            case "string": gen
                ("m%s=String(d%s)", prop, prop);
                break;
            case "bool": gen
                ("m%s=Boolean(d%s)", prop, prop);
                break;
            /* default: gen
                ("m%s=d%s", prop, prop);
                break; */
        }
    }
    return gen;
    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */
}

/**
 * Generates a plain object to runtime message converter specific to the specified message type.
 * @param {Type} mtype Message type
 * @returns {Codegen} Codegen instance
 */
converter.fromObject = function fromObject(mtype) {
    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */
    var fields = mtype.fieldsArray;
    var gen = util.codegen(["d"], mtype.name + "$fromObject")
    ("if(d instanceof this.ctor)")
        ("return d");
    if (!fields.length) return gen
    ("return new this.ctor");
    gen
    ("var m=new this.ctor");
    for (var i = 0; i < fields.length; ++i) {
        var field  = fields[i].resolve(),
            prop   = util.safeProp(field.name);

        // Map fields
        if (field.map) { gen
    ("if(d%s){", prop)
        ("if(typeof d%s!==\"object\")", prop)
            ("throw TypeError(%j)", field.fullName + ": object expected")
        ("m%s={}", prop)
        ("for(var ks=Object.keys(d%s),i=0;i<ks.length;++i){", prop);
            genValuePartial_fromObject(gen, field, /* not sorted */ i, prop + "[ks[i]]")
        ("}")
    ("}");

        // Repeated fields
        } else if (field.repeated) { gen
    ("if(d%s){", prop)
        ("if(!Array.isArray(d%s))", prop)
            ("throw TypeError(%j)", field.fullName + ": array expected")
        ("m%s=[]", prop)
        ("for(var i=0;i<d%s.length;++i){", prop);
            genValuePartial_fromObject(gen, field, /* not sorted */ i, prop + "[i]")
        ("}")
    ("}");

        // Non-repeated fields
        } else {
            if (!(field.resolvedType instanceof Enum)) gen // no need to test for null/undefined if an enum (uses switch)
    ("if(d%s!=null){", prop); // !== undefined && !== null
        genValuePartial_fromObject(gen, field, /* not sorted */ i, prop);
            if (!(field.resolvedType instanceof Enum)) gen
    ("}");
        }
    } return gen
    ("return m");
    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */
};

/**
 * Generates a partial value toObject converter.
 * @param {Codegen} gen Codegen instance
 * @param {Field} field Reflected field
 * @param {number} fieldIndex Field index
 * @param {string} prop Property reference
 * @returns {Codegen} Codegen instance
 * @ignore
 */
function genValuePartial_toObject(gen, field, fieldIndex, prop) {
    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */
    if (field.resolvedType) {
        if (field.resolvedType instanceof Enum) gen
            ("d%s=o.enums===String?types[%i].values[m%s]:m%s", prop, fieldIndex, prop, prop);
        else gen
            ("d%s=types[%i].toObject(m%s,o)", prop, fieldIndex, prop);
    } else {
        var isUnsigned = false;
        switch (field.type) {
            case "double":
            case "float": gen
            ("d%s=o.json&&!isFinite(m%s)?String(m%s):m%s", prop, prop, prop, prop);
                break;
            case "uint64":
                isUnsigned = true;
                // eslint-disable-line no-fallthrough
            case "int64":
            case "sint64":
            case "fixed64":
            case "sfixed64": gen
            ("if(typeof m%s===\"number\")", prop)
                ("d%s=o.longs===String?String(m%s):m%s", prop, prop, prop)
            ("else") // Long-like
                ("d%s=o.longs===String?util.Long.prototype.toString.call(m%s):o.longs===Number?new util.LongBits(m%s.low>>>0,m%s.high>>>0).toNumber(%s):m%s", prop, prop, prop, prop, isUnsigned ? "true": "", prop);
                break;
            case "bytes": gen
            ("d%s=o.bytes===String?util.base64.encode(m%s,0,m%s.length):o.bytes===Array?Array.prototype.slice.call(m%s):m%s", prop, prop, prop, prop, prop);
                break;
            default: gen
            ("d%s=m%s", prop, prop);
                break;
        }
    }
    return gen;
    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */
}

/**
 * Generates a runtime message to plain object converter specific to the specified message type.
 * @param {Type} mtype Message type
 * @returns {Codegen} Codegen instance
 */
converter.toObject = function toObject(mtype) {
    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */
    var fields = mtype.fieldsArray.slice().sort(util.compareFieldsById);
    if (!fields.length)
        return util.codegen()("return {}");
    var gen = util.codegen(["m", "o"], mtype.name + "$toObject")
    ("if(!o)")
        ("o={}")
    ("var d={}");

    var repeatedFields = [],
        mapFields = [],
        normalFields = [],
        i = 0;
    for (; i < fields.length; ++i)
        if (!fields[i].partOf)
            ( fields[i].resolve().repeated ? repeatedFields
            : fields[i].map ? mapFields
            : normalFields).push(fields[i]);

    if (repeatedFields.length) { gen
    ("if(o.arrays||o.defaults){");
        for (i = 0; i < repeatedFields.length; ++i) gen
        ("d%s=[]", util.safeProp(repeatedFields[i].name));
        gen
    ("}");
    }

    if (mapFields.length) { gen
    ("if(o.objects||o.defaults){");
        for (i = 0; i < mapFields.length; ++i) gen
        ("d%s={}", util.safeProp(mapFields[i].name));
        gen
    ("}");
    }

    if (normalFields.length) { gen
    ("if(o.defaults){");
        for (i = 0; i < normalFields.length; ++i) {
            var field = normalFields[i],
                prop  = util.safeProp(field.name);
            if (field.resolvedType instanceof Enum) gen
        ("d%s=o.enums===String?%j:%j", prop, field.resolvedType.valuesById[field.typeDefault], field.typeDefault);
            else if (field.long) gen
        ("if(util.Long){")
            ("var n=new util.Long(%i,%i,%j)", field.typeDefault.low, field.typeDefault.high, field.typeDefault.unsigned)
            ("d%s=o.longs===String?n.toString():o.longs===Number?n.toNumber():n", prop)
        ("}else")
            ("d%s=o.longs===String?%j:%i", prop, field.typeDefault.toString(), field.typeDefault.toNumber());
            else if (field.bytes) gen
        ("d%s=o.bytes===String?%j:%s", prop, String.fromCharCode.apply(String, field.typeDefault), "[" + Array.prototype.slice.call(field.typeDefault).join(",") + "]");
            else gen
        ("d%s=%j", prop, field.typeDefault); // also messages (=null)
        } gen
    ("}");
    }
    var hasKs2 = false;
    for (i = 0; i < fields.length; ++i) {
        var field = fields[i],
            index = mtype._fieldsArray.indexOf(field),
            prop  = util.safeProp(field.name);
        if (field.map) {
            if (!hasKs2) { hasKs2 = true; gen
    ("var ks2");
            } gen
    ("if(m%s&&(ks2=Object.keys(m%s)).length){", prop, prop)
        ("d%s={}", prop)
        ("for(var j=0;j<ks2.length;++j){");
            genValuePartial_toObject(gen, field, /* sorted */ index, prop + "[ks2[j]]")
        ("}");
        } else if (field.repeated) { gen
    ("if(m%s&&m%s.length){", prop, prop)
        ("d%s=[]", prop)
        ("for(var j=0;j<m%s.length;++j){", prop);
            genValuePartial_toObject(gen, field, /* sorted */ index, prop + "[j]")
        ("}");
        } else { gen
    ("if(m%s!=null&&m.hasOwnProperty(%j)){", prop, field.name); // !== undefined && !== null
        genValuePartial_toObject(gen, field, /* sorted */ index, prop);
        if (field.partOf) gen
        ("if(o.oneofs)")
            ("d%s=%j", util.safeProp(field.partOf.name), field.name);
        }
        gen
    ("}");
    }
    return gen
    ("return d");
    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */
};

},{"15":15,"37":37}],13:[function(require,module,exports){
"use strict";
module.exports = decoder;

var Enum    = require(15),
    types   = require(36),
    util    = require(37);

function missing(field) {
    return "missing required '" + field.name + "'";
}

/**
 * Generates a decoder specific to the specified message type.
 * @param {Type} mtype Message type
 * @returns {Codegen} Codegen instance
 */
function decoder(mtype) {
    /* eslint-disable no-unexpected-multiline */
    var gen = util.codegen(["r", "l"], mtype.name + "$decode")
    ("if(!(r instanceof Reader))")
        ("r=Reader.create(r)")
    ("var c=l===undefined?r.len:r.pos+l,m=new this.ctor" + (mtype.fieldsArray.filter(function(field) { return field.map; }).length ? ",k" : ""))
    ("while(r.pos<c){")
        ("var t=r.uint32()");
    if (mtype.group) gen
        ("if((t&7)===4)")
            ("break");
    gen
        ("switch(t>>>3){");

    var i = 0;
    for (; i < /* initializes */ mtype.fieldsArray.length; ++i) {
        var field = mtype._fieldsArray[i].resolve(),
            type  = field.resolvedType instanceof Enum ? "int32" : field.type,
            ref   = "m" + util.safeProp(field.name); gen
            ("case %i:", field.id);

        // Map fields
        if (field.map) { gen
                ("r.skip().pos++") // assumes id 1 + key wireType
                ("if(%s===util.emptyObject)", ref)
                    ("%s={}", ref)
                ("k=r.%s()", field.keyType)
                ("r.pos++"); // assumes id 2 + value wireType
            if (types.long[field.keyType] !== undefined) {
                if (types.basic[type] === undefined) gen
                ("%s[typeof k===\"object\"?util.longToHash(k):k]=types[%i].decode(r,r.uint32())", ref, i); // can't be groups
                else gen
                ("%s[typeof k===\"object\"?util.longToHash(k):k]=r.%s()", ref, type);
            } else {
                if (types.basic[type] === undefined) gen
                ("%s[k]=types[%i].decode(r,r.uint32())", ref, i); // can't be groups
                else gen
                ("%s[k]=r.%s()", ref, type);
            }

        // Repeated fields
        } else if (field.repeated) { gen

                ("if(!(%s&&%s.length))", ref, ref)
                    ("%s=[]", ref);

            // Packable (always check for forward and backward compatiblity)
            if (types.packed[type] !== undefined) gen
                ("if((t&7)===2){")
                    ("var c2=r.uint32()+r.pos")
                    ("while(r.pos<c2)")
                        ("%s.push(r.%s())", ref, type)
                ("}else");

            // Non-packed
            if (types.basic[type] === undefined) gen(field.resolvedType.group
                    ? "%s.push(types[%i].decode(r))"
                    : "%s.push(types[%i].decode(r,r.uint32()))", ref, i);
            else gen
                    ("%s.push(r.%s())", ref, type);

        // Non-repeated
        } else if (types.basic[type] === undefined) gen(field.resolvedType.group
                ? "%s=types[%i].decode(r)"
                : "%s=types[%i].decode(r,r.uint32())", ref, i);
        else gen
                ("%s=r.%s()", ref, type);
        gen
                ("break");
    // Unknown fields
    } gen
            ("default:")
                ("r.skipType(t&7)")
                ("break")

        ("}")
    ("}");

    // Field presence
    for (i = 0; i < mtype._fieldsArray.length; ++i) {
        var rfield = mtype._fieldsArray[i];
        if (rfield.required) gen
    ("if(!m.hasOwnProperty(%j))", rfield.name)
        ("throw util.ProtocolError(%j,{instance:m})", missing(rfield));
    }

    return gen
    ("return m");
    /* eslint-enable no-unexpected-multiline */
}

},{"15":15,"36":36,"37":37}],14:[function(require,module,exports){
"use strict";
module.exports = encoder;

var Enum     = require(15),
    types    = require(36),
    util     = require(37);

/**
 * Generates a partial message type encoder.
 * @param {Codegen} gen Codegen instance
 * @param {Field} field Reflected field
 * @param {number} fieldIndex Field index
 * @param {string} ref Variable reference
 * @returns {Codegen} Codegen instance
 * @ignore
 */
function genTypePartial(gen, field, fieldIndex, ref) {
    return field.resolvedType.group
        ? gen("types[%i].encode(%s,w.uint32(%i)).uint32(%i)", fieldIndex, ref, (field.id << 3 | 3) >>> 0, (field.id << 3 | 4) >>> 0)
        : gen("types[%i].encode(%s,w.uint32(%i).fork()).ldelim()", fieldIndex, ref, (field.id << 3 | 2) >>> 0);
}

/**
 * Generates an encoder specific to the specified message type.
 * @param {Type} mtype Message type
 * @returns {Codegen} Codegen instance
 */
function encoder(mtype) {
    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */
    var gen = util.codegen(["m", "w"], mtype.name + "$encode")
    ("if(!w)")
        ("w=Writer.create()");

    var i, ref;

    // "when a message is serialized its known fields should be written sequentially by field number"
    var fields = /* initializes */ mtype.fieldsArray.slice().sort(util.compareFieldsById);

    for (var i = 0; i < fields.length; ++i) {
        var field    = fields[i].resolve(),
            index    = mtype._fieldsArray.indexOf(field),
            type     = field.resolvedType instanceof Enum ? "int32" : field.type,
            wireType = types.basic[type];
            ref      = "m" + util.safeProp(field.name);

        // Map fields
        if (field.map) {
            gen
    ("if(%s!=null&&m.hasOwnProperty(%j)){", ref, field.name) // !== undefined && !== null
        ("for(var ks=Object.keys(%s),i=0;i<ks.length;++i){", ref)
            ("w.uint32(%i).fork().uint32(%i).%s(ks[i])", (field.id << 3 | 2) >>> 0, 8 | types.mapKey[field.keyType], field.keyType);
            if (wireType === undefined) gen
            ("types[%i].encode(%s[ks[i]],w.uint32(18).fork()).ldelim().ldelim()", index, ref); // can't be groups
            else gen
            (".uint32(%i).%s(%s[ks[i]]).ldelim()", 16 | wireType, type, ref);
            gen
        ("}")
    ("}");

            // Repeated fields
        } else if (field.repeated) { gen
    ("if(%s!=null&&%s.length){", ref, ref); // !== undefined && !== null

            // Packed repeated
            if (field.packed && types.packed[type] !== undefined) { gen

        ("w.uint32(%i).fork()", (field.id << 3 | 2) >>> 0)
        ("for(var i=0;i<%s.length;++i)", ref)
            ("w.%s(%s[i])", type, ref)
        ("w.ldelim()");

            // Non-packed
            } else { gen

        ("for(var i=0;i<%s.length;++i)", ref);
                if (wireType === undefined)
            genTypePartial(gen, field, index, ref + "[i]");
                else gen
            ("w.uint32(%i).%s(%s[i])", (field.id << 3 | wireType) >>> 0, type, ref);

            } gen
    ("}");

        // Non-repeated
        } else {
            if (field.optional) gen
    ("if(%s!=null&&m.hasOwnProperty(%j))", ref, field.name); // !== undefined && !== null

            if (wireType === undefined)
        genTypePartial(gen, field, index, ref);
            else gen
        ("w.uint32(%i).%s(%s)", (field.id << 3 | wireType) >>> 0, type, ref);

        }
    }

    return gen
    ("return w");
    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */
}
},{"15":15,"36":36,"37":37}],15:[function(require,module,exports){
"use strict";
module.exports = Enum;

// extends ReflectionObject
var ReflectionObject = require(24);
((Enum.prototype = Object.create(ReflectionObject.prototype)).constructor = Enum).className = "Enum";

var Namespace = require(23),
    util = require(37);

/**
 * Constructs a new enum instance.
 * @classdesc Reflected enum.
 * @extends ReflectionObject
 * @constructor
 * @param {string} name Unique name within its namespace
 * @param {Object.<string,number>} [values] Enum values as an object, by name
 * @param {Object.<string,*>} [options] Declared options
 * @param {string} [comment] The comment for this enum
 * @param {Object.<string,string>} [comments] The value comments for this enum
 */
function Enum(name, values, options, comment, comments) {
    ReflectionObject.call(this, name, options);

    if (values && typeof values !== "object")
        throw TypeError("values must be an object");

    /**
     * Enum values by id.
     * @type {Object.<number,string>}
     */
    this.valuesById = {};

    /**
     * Enum values by name.
     * @type {Object.<string,number>}
     */
    this.values = Object.create(this.valuesById); // toJSON, marker

    /**
     * Enum comment text.
     * @type {string|null}
     */
    this.comment = comment;

    /**
     * Value comment texts, if any.
     * @type {Object.<string,string>}
     */
    this.comments = comments || {};

    /**
     * Reserved ranges, if any.
     * @type {Array.<number[]|string>}
     */
    this.reserved = undefined; // toJSON

    // Note that values inherit valuesById on their prototype which makes them a TypeScript-
    // compatible enum. This is used by pbts to write actual enum definitions that work for
    // static and reflection code alike instead of emitting generic object definitions.

    if (values)
        for (var keys = Object.keys(values), i = 0; i < keys.length; ++i)
            if (typeof values[keys[i]] === "number") // use forward entries only
                this.valuesById[ this.values[keys[i]] = values[keys[i]] ] = keys[i];
}

/**
 * Enum descriptor.
 * @interface IEnum
 * @property {Object.<string,number>} values Enum values
 * @property {Object.<string,*>} [options] Enum options
 */

/**
 * Constructs an enum from an enum descriptor.
 * @param {string} name Enum name
 * @param {IEnum} json Enum descriptor
 * @returns {Enum} Created enum
 * @throws {TypeError} If arguments are invalid
 */
Enum.fromJSON = function fromJSON(name, json) {
    var enm = new Enum(name, json.values, json.options, json.comment, json.comments);
    enm.reserved = json.reserved;
    return enm;
};

/**
 * Converts this enum to an enum descriptor.
 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
 * @returns {IEnum} Enum descriptor
 */
Enum.prototype.toJSON = function toJSON(toJSONOptions) {
    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
    return util.toObject([
        "options"  , this.options,
        "values"   , this.values,
        "reserved" , this.reserved && this.reserved.length ? this.reserved : undefined,
        "comment"  , keepComments ? this.comment : undefined,
        "comments" , keepComments ? this.comments : undefined
    ]);
};

/**
 * Adds a value to this enum.
 * @param {string} name Value name
 * @param {number} id Value id
 * @param {string} [comment] Comment, if any
 * @returns {Enum} `this`
 * @throws {TypeError} If arguments are invalid
 * @throws {Error} If there is already a value with this name or id
 */
Enum.prototype.add = function add(name, id, comment) {
    // utilized by the parser but not by .fromJSON

    if (!util.isString(name))
        throw TypeError("name must be a string");

    if (!util.isInteger(id))
        throw TypeError("id must be an integer");

    if (this.values[name] !== undefined)
        throw Error("duplicate name '" + name + "' in " + this);

    if (this.isReservedId(id))
        throw Error("id " + id + " is reserved in " + this);

    if (this.isReservedName(name))
        throw Error("name '" + name + "' is reserved in " + this);

    if (this.valuesById[id] !== undefined) {
        if (!(this.options && this.options.allow_alias))
            throw Error("duplicate id " + id + " in " + this);
        this.values[name] = id;
    } else
        this.valuesById[this.values[name] = id] = name;

    this.comments[name] = comment || null;
    return this;
};

/**
 * Removes a value from this enum
 * @param {string} name Value name
 * @returns {Enum} `this`
 * @throws {TypeError} If arguments are invalid
 * @throws {Error} If `name` is not a name of this enum
 */
Enum.prototype.remove = function remove(name) {

    if (!util.isString(name))
        throw TypeError("name must be a string");

    var val = this.values[name];
    if (val == null)
        throw Error("name '" + name + "' does not exist in " + this);

    delete this.valuesById[val];
    delete this.values[name];
    delete this.comments[name];

    return this;
};

/**
 * Tests if the specified id is reserved.
 * @param {number} id Id to test
 * @returns {boolean} `true` if reserved, otherwise `false`
 */
Enum.prototype.isReservedId = function isReservedId(id) {
    return Namespace.isReservedId(this.reserved, id);
};

/**
 * Tests if the specified name is reserved.
 * @param {string} name Name to test
 * @returns {boolean} `true` if reserved, otherwise `false`
 */
Enum.prototype.isReservedName = function isReservedName(name) {
    return Namespace.isReservedName(this.reserved, name);
};

},{"23":23,"24":24,"37":37}],16:[function(require,module,exports){
"use strict";
module.exports = Field;

// extends ReflectionObject
var ReflectionObject = require(24);
((Field.prototype = Object.create(ReflectionObject.prototype)).constructor = Field).className = "Field";

var Enum  = require(15),
    types = require(36),
    util  = require(37);

var Type; // cyclic

var ruleRe = /^required|optional|repeated$/;

/**
 * Constructs a new message field instance. Note that {@link MapField|map fields} have their own class.
 * @name Field
 * @classdesc Reflected message field.
 * @extends FieldBase
 * @constructor
 * @param {string} name Unique name within its namespace
 * @param {number} id Unique id within its namespace
 * @param {string} type Value type
 * @param {string|Object.<string,*>} [rule="optional"] Field rule
 * @param {string|Object.<string,*>} [extend] Extended type if different from parent
 * @param {Object.<string,*>} [options] Declared options
 */

/**
 * Constructs a field from a field descriptor.
 * @param {string} name Field name
 * @param {IField} json Field descriptor
 * @returns {Field} Created field
 * @throws {TypeError} If arguments are invalid
 */
Field.fromJSON = function fromJSON(name, json) {
    return new Field(name, json.id, json.type, json.rule, json.extend, json.options, json.comment);
};

/**
 * Not an actual constructor. Use {@link Field} instead.
 * @classdesc Base class of all reflected message fields. This is not an actual class but here for the sake of having consistent type definitions.
 * @exports FieldBase
 * @extends ReflectionObject
 * @constructor
 * @param {string} name Unique name within its namespace
 * @param {number} id Unique id within its namespace
 * @param {string} type Value type
 * @param {string|Object.<string,*>} [rule="optional"] Field rule
 * @param {string|Object.<string,*>} [extend] Extended type if different from parent
 * @param {Object.<string,*>} [options] Declared options
 * @param {string} [comment] Comment associated with this field
 */
function Field(name, id, type, rule, extend, options, comment) {

    if (util.isObject(rule)) {
        comment = extend;
        options = rule;
        rule = extend = undefined;
    } else if (util.isObject(extend)) {
        comment = options;
        options = extend;
        extend = undefined;
    }

    ReflectionObject.call(this, name, options);

    if (!util.isInteger(id) || id < 0)
        throw TypeError("id must be a non-negative integer");

    if (!util.isString(type))
        throw TypeError("type must be a string");

    if (rule !== undefined && !ruleRe.test(rule = rule.toString().toLowerCase()))
        throw TypeError("rule must be a string rule");

    if (extend !== undefined && !util.isString(extend))
        throw TypeError("extend must be a string");

    /**
     * Field rule, if any.
     * @type {string|undefined}
     */
    this.rule = rule && rule !== "optional" ? rule : undefined; // toJSON

    /**
     * Field type.
     * @type {string}
     */
    this.type = type; // toJSON

    /**
     * Unique field id.
     * @type {number}
     */
    this.id = id; // toJSON, marker

    /**
     * Extended type if different from parent.
     * @type {string|undefined}
     */
    this.extend = extend || undefined; // toJSON

    /**
     * Whether this field is required.
     * @type {boolean}
     */
    this.required = rule === "required";

    /**
     * Whether this field is optional.
     * @type {boolean}
     */
    this.optional = !this.required;

    /**
     * Whether this field is repeated.
     * @type {boolean}
     */
    this.repeated = rule === "repeated";

    /**
     * Whether this field is a map or not.
     * @type {boolean}
     */
    this.map = false;

    /**
     * Message this field belongs to.
     * @type {Type|null}
     */
    this.message = null;

    /**
     * OneOf this field belongs to, if any,
     * @type {OneOf|null}
     */
    this.partOf = null;

    /**
     * The field type's default value.
     * @type {*}
     */
    this.typeDefault = null;

    /**
     * The field's default value on prototypes.
     * @type {*}
     */
    this.defaultValue = null;

    /**
     * Whether this field's value should be treated as a long.
     * @type {boolean}
     */
    this.long = util.Long ? types.long[type] !== undefined : /* istanbul ignore next */ false;

    /**
     * Whether this field's value is a buffer.
     * @type {boolean}
     */
    this.bytes = type === "bytes";

    /**
     * Resolved type if not a basic type.
     * @type {Type|Enum|null}
     */
    this.resolvedType = null;

    /**
     * Sister-field within the extended type if a declaring extension field.
     * @type {Field|null}
     */
    this.extensionField = null;

    /**
     * Sister-field within the declaring namespace if an extended field.
     * @type {Field|null}
     */
    this.declaringField = null;

    /**
     * Internally remembers whether this field is packed.
     * @type {boolean|null}
     * @private
     */
    this._packed = null;

    /**
     * Comment for this field.
     * @type {string|null}
     */
    this.comment = comment;
}

/**
 * Determines whether this field is packed. Only relevant when repeated and working with proto2.
 * @name Field#packed
 * @type {boolean}
 * @readonly
 */
Object.defineProperty(Field.prototype, "packed", {
    get: function() {
        // defaults to packed=true if not explicity set to false
        if (this._packed === null)
            this._packed = this.getOption("packed") !== false;
        return this._packed;
    }
});

/**
 * @override
 */
Field.prototype.setOption = function setOption(name, value, ifNotSet) {
    if (name === "packed") // clear cached before setting
        this._packed = null;
    return ReflectionObject.prototype.setOption.call(this, name, value, ifNotSet);
};

/**
 * Field descriptor.
 * @interface IField
 * @property {string} [rule="optional"] Field rule
 * @property {string} type Field type
 * @property {number} id Field id
 * @property {Object.<string,*>} [options] Field options
 */

/**
 * Extension field descriptor.
 * @interface IExtensionField
 * @extends IField
 * @property {string} extend Extended type
 */

/**
 * Converts this field to a field descriptor.
 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
 * @returns {IField} Field descriptor
 */
Field.prototype.toJSON = function toJSON(toJSONOptions) {
    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
    return util.toObject([
        "rule"    , this.rule !== "optional" && this.rule || undefined,
        "type"    , this.type,
        "id"      , this.id,
        "extend"  , this.extend,
        "options" , this.options,
        "comment" , keepComments ? this.comment : undefined
    ]);
};

/**
 * Resolves this field's type references.
 * @returns {Field} `this`
 * @throws {Error} If any reference cannot be resolved
 */
Field.prototype.resolve = function resolve() {

    if (this.resolved)
        return this;

    if ((this.typeDefault = types.defaults[this.type]) === undefined) { // if not a basic type, resolve it
        this.resolvedType = (this.declaringField ? this.declaringField.parent : this.parent).lookupTypeOrEnum(this.type);
        if (this.resolvedType instanceof Type)
            this.typeDefault = null;
        else // instanceof Enum
            this.typeDefault = this.resolvedType.values[Object.keys(this.resolvedType.values)[0]]; // first defined
    }

    // use explicitly set default value if present
    if (this.options && this.options["default"] != null) {
        this.typeDefault = this.options["default"];
        if (this.resolvedType instanceof Enum && typeof this.typeDefault === "string")
            this.typeDefault = this.resolvedType.values[this.typeDefault];
    }

    // remove unnecessary options
    if (this.options) {
        if (this.options.packed === true || this.options.packed !== undefined && this.resolvedType && !(this.resolvedType instanceof Enum))
            delete this.options.packed;
        if (!Object.keys(this.options).length)
            this.options = undefined;
    }

    // convert to internal data type if necesssary
    if (this.long) {
        this.typeDefault = util.Long.fromNumber(this.typeDefault, this.type.charAt(0) === "u");

        /* istanbul ignore else */
        if (Object.freeze)
            Object.freeze(this.typeDefault); // long instances are meant to be immutable anyway (i.e. use small int cache that even requires it)

    } else if (this.bytes && typeof this.typeDefault === "string") {
        var buf;
        if (util.base64.test(this.typeDefault))
            util.base64.decode(this.typeDefault, buf = util.newBuffer(util.base64.length(this.typeDefault)), 0);
        else
            util.utf8.write(this.typeDefault, buf = util.newBuffer(util.utf8.length(this.typeDefault)), 0);
        this.typeDefault = buf;
    }

    // take special care of maps and repeated fields
    if (this.map)
        this.defaultValue = util.emptyObject;
    else if (this.repeated)
        this.defaultValue = util.emptyArray;
    else
        this.defaultValue = this.typeDefault;

    // ensure proper value on prototype
    if (this.parent instanceof Type)
        this.parent.ctor.prototype[this.name] = this.defaultValue;

    return ReflectionObject.prototype.resolve.call(this);
};

/**
 * Decorator function as returned by {@link Field.d} and {@link MapField.d} (TypeScript).
 * @typedef FieldDecorator
 * @type {function}
 * @param {Object} prototype Target prototype
 * @param {string} fieldName Field name
 * @returns {undefined}
 */

/**
 * Field decorator (TypeScript).
 * @name Field.d
 * @function
 * @param {number} fieldId Field id
 * @param {"double"|"float"|"int32"|"uint32"|"sint32"|"fixed32"|"sfixed32"|"int64"|"uint64"|"sint64"|"fixed64"|"sfixed64"|"string"|"bool"|"bytes"|Object} fieldType Field type
 * @param {"optional"|"required"|"repeated"} [fieldRule="optional"] Field rule
 * @param {T} [defaultValue] Default value
 * @returns {FieldDecorator} Decorator function
 * @template T extends number | number[] | Long | Long[] | string | string[] | boolean | boolean[] | Uint8Array | Uint8Array[] | Buffer | Buffer[]
 */
Field.d = function decorateField(fieldId, fieldType, fieldRule, defaultValue) {

    // submessage: decorate the submessage and use its name as the type
    if (typeof fieldType === "function")
        fieldType = util.decorateType(fieldType).name;

    // enum reference: create a reflected copy of the enum and keep reuseing it
    else if (fieldType && typeof fieldType === "object")
        fieldType = util.decorateEnum(fieldType).name;

    return function fieldDecorator(prototype, fieldName) {
        util.decorateType(prototype.constructor)
            .add(new Field(fieldName, fieldId, fieldType, fieldRule, { "default": defaultValue }));
    };
};

/**
 * Field decorator (TypeScript).
 * @name Field.d
 * @function
 * @param {number} fieldId Field id
 * @param {Constructor<T>|string} fieldType Field type
 * @param {"optional"|"required"|"repeated"} [fieldRule="optional"] Field rule
 * @returns {FieldDecorator} Decorator function
 * @template T extends Message<T>
 * @variation 2
 */
// like Field.d but without a default value

Field._configure = function configure(Type_) {
    Type = Type_;
};

},{"15":15,"24":24,"36":36,"37":37}],17:[function(require,module,exports){
"use strict";
var protobuf = module.exports = require(18);

protobuf.build = "light";

/**
 * A node-style callback as used by {@link load} and {@link Root#load}.
 * @typedef LoadCallback
 * @type {function}
 * @param {Error|null} error Error, if any, otherwise `null`
 * @param {Root} [root] Root, if there hasn't been an error
 * @returns {undefined}
 */

/**
 * Loads one or multiple .proto or preprocessed .json files into a common root namespace and calls the callback.
 * @param {string|string[]} filename One or multiple files to load
 * @param {Root} root Root namespace, defaults to create a new one if omitted.
 * @param {LoadCallback} callback Callback function
 * @returns {undefined}
 * @see {@link Root#load}
 */
function load(filename, root, callback) {
    if (typeof root === "function") {
        callback = root;
        root = new protobuf.Root();
    } else if (!root)
        root = new protobuf.Root();
    return root.load(filename, callback);
}

/**
 * Loads one or multiple .proto or preprocessed .json files into a common root namespace and calls the callback.
 * @name load
 * @function
 * @param {string|string[]} filename One or multiple files to load
 * @param {LoadCallback} callback Callback function
 * @returns {undefined}
 * @see {@link Root#load}
 * @variation 2
 */
// function load(filename:string, callback:LoadCallback):undefined

/**
 * Loads one or multiple .proto or preprocessed .json files into a common root namespace and returns a promise.
 * @name load
 * @function
 * @param {string|string[]} filename One or multiple files to load
 * @param {Root} [root] Root namespace, defaults to create a new one if omitted.
 * @returns {Promise<Root>} Promise
 * @see {@link Root#load}
 * @variation 3
 */
// function load(filename:string, [root:Root]):Promise<Root>

protobuf.load = load;

/**
 * Synchronously loads one or multiple .proto or preprocessed .json files into a common root namespace (node only).
 * @param {string|string[]} filename One or multiple files to load
 * @param {Root} [root] Root namespace, defaults to create a new one if omitted.
 * @returns {Root} Root namespace
 * @throws {Error} If synchronous fetching is not supported (i.e. in browsers) or if a file's syntax is invalid
 * @see {@link Root#loadSync}
 */
function loadSync(filename, root) {
    if (!root)
        root = new protobuf.Root();
    return root.loadSync(filename);
}

protobuf.loadSync = loadSync;

// Serialization
protobuf.encoder          = require(14);
protobuf.decoder          = require(13);
protobuf.verifier         = require(40);
protobuf.converter        = require(12);

// Reflection
protobuf.ReflectionObject = require(24);
protobuf.Namespace        = require(23);
protobuf.Root             = require(29);
protobuf.Enum             = require(15);
protobuf.Type             = require(35);
protobuf.Field            = require(16);
protobuf.OneOf            = require(25);
protobuf.MapField         = require(20);
protobuf.Service          = require(33);
protobuf.Method           = require(22);

// Runtime
protobuf.Message          = require(21);
protobuf.wrappers         = require(41);

// Utility
protobuf.types            = require(36);
protobuf.util             = require(37);

// Configure reflection
protobuf.ReflectionObject._configure(protobuf.Root);
protobuf.Namespace._configure(protobuf.Type, protobuf.Service);
protobuf.Root._configure(protobuf.Type);
protobuf.Field._configure(protobuf.Type);

},{"12":12,"13":13,"14":14,"15":15,"16":16,"18":18,"20":20,"21":21,"22":22,"23":23,"24":24,"25":25,"29":29,"33":33,"35":35,"36":36,"37":37,"40":40,"41":41}],18:[function(require,module,exports){
"use strict";
var protobuf = exports;

/**
 * Build type, one of `"full"`, `"light"` or `"minimal"`.
 * @name build
 * @type {string}
 * @const
 */
protobuf.build = "minimal";

// Serialization
protobuf.Writer       = require(42);
protobuf.BufferWriter = require(43);
protobuf.Reader       = require(27);
protobuf.BufferReader = require(28);

// Utility
protobuf.util         = require(39);
protobuf.rpc          = require(31);
protobuf.roots        = require(30);
protobuf.configure    = configure;

/* istanbul ignore next */
/**
 * Reconfigures the library according to the environment.
 * @returns {undefined}
 */
function configure() {
    protobuf.Reader._configure(protobuf.BufferReader);
    protobuf.util._configure();
}

// Configure serialization
protobuf.Writer._configure(protobuf.BufferWriter);
configure();

},{"27":27,"28":28,"30":30,"31":31,"39":39,"42":42,"43":43}],19:[function(require,module,exports){
"use strict";
var protobuf = module.exports = require(17);

protobuf.build = "full";

// Parser
protobuf.tokenize         = require(34);
protobuf.parse            = require(26);
protobuf.common           = require(11);

// Configure parser
protobuf.Root._configure(protobuf.Type, protobuf.parse, protobuf.common);

},{"11":11,"17":17,"26":26,"34":34}],20:[function(require,module,exports){
"use strict";
module.exports = MapField;

// extends Field
var Field = require(16);
((MapField.prototype = Object.create(Field.prototype)).constructor = MapField).className = "MapField";

var types   = require(36),
    util    = require(37);

/**
 * Constructs a new map field instance.
 * @classdesc Reflected map field.
 * @extends FieldBase
 * @constructor
 * @param {string} name Unique name within its namespace
 * @param {number} id Unique id within its namespace
 * @param {string} keyType Key type
 * @param {string} type Value type
 * @param {Object.<string,*>} [options] Declared options
 * @param {string} [comment] Comment associated with this field
 */
function MapField(name, id, keyType, type, options, comment) {
    Field.call(this, name, id, type, undefined, undefined, options, comment);

    /* istanbul ignore if */
    if (!util.isString(keyType))
        throw TypeError("keyType must be a string");

    /**
     * Key type.
     * @type {string}
     */
    this.keyType = keyType; // toJSON, marker

    /**
     * Resolved key type if not a basic type.
     * @type {ReflectionObject|null}
     */
    this.resolvedKeyType = null;

    // Overrides Field#map
    this.map = true;
}

/**
 * Map field descriptor.
 * @interface IMapField
 * @extends {IField}
 * @property {string} keyType Key type
 */

/**
 * Extension map field descriptor.
 * @interface IExtensionMapField
 * @extends IMapField
 * @property {string} extend Extended type
 */

/**
 * Constructs a map field from a map field descriptor.
 * @param {string} name Field name
 * @param {IMapField} json Map field descriptor
 * @returns {MapField} Created map field
 * @throws {TypeError} If arguments are invalid
 */
MapField.fromJSON = function fromJSON(name, json) {
    return new MapField(name, json.id, json.keyType, json.type, json.options, json.comment);
};

/**
 * Converts this map field to a map field descriptor.
 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
 * @returns {IMapField} Map field descriptor
 */
MapField.prototype.toJSON = function toJSON(toJSONOptions) {
    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
    return util.toObject([
        "keyType" , this.keyType,
        "type"    , this.type,
        "id"      , this.id,
        "extend"  , this.extend,
        "options" , this.options,
        "comment" , keepComments ? this.comment : undefined
    ]);
};

/**
 * @override
 */
MapField.prototype.resolve = function resolve() {
    if (this.resolved)
        return this;

    // Besides a value type, map fields have a key type that may be "any scalar type except for floating point types and bytes"
    if (types.mapKey[this.keyType] === undefined)
        throw Error("invalid key type: " + this.keyType);

    return Field.prototype.resolve.call(this);
};

/**
 * Map field decorator (TypeScript).
 * @name MapField.d
 * @function
 * @param {number} fieldId Field id
 * @param {"int32"|"uint32"|"sint32"|"fixed32"|"sfixed32"|"int64"|"uint64"|"sint64"|"fixed64"|"sfixed64"|"bool"|"string"} fieldKeyType Field key type
 * @param {"double"|"float"|"int32"|"uint32"|"sint32"|"fixed32"|"sfixed32"|"int64"|"uint64"|"sint64"|"fixed64"|"sfixed64"|"bool"|"string"|"bytes"|Object|Constructor<{}>} fieldValueType Field value type
 * @returns {FieldDecorator} Decorator function
 * @template T extends { [key: string]: number | Long | string | boolean | Uint8Array | Buffer | number[] | Message<{}> }
 */
MapField.d = function decorateMapField(fieldId, fieldKeyType, fieldValueType) {

    // submessage value: decorate the submessage and use its name as the type
    if (typeof fieldValueType === "function")
        fieldValueType = util.decorateType(fieldValueType).name;

    // enum reference value: create a reflected copy of the enum and keep reuseing it
    else if (fieldValueType && typeof fieldValueType === "object")
        fieldValueType = util.decorateEnum(fieldValueType).name;

    return function mapFieldDecorator(prototype, fieldName) {
        util.decorateType(prototype.constructor)
            .add(new MapField(fieldName, fieldId, fieldKeyType, fieldValueType));
    };
};

},{"16":16,"36":36,"37":37}],21:[function(require,module,exports){
"use strict";
module.exports = Message;

var util = require(39);

/**
 * Constructs a new message instance.
 * @classdesc Abstract runtime message.
 * @constructor
 * @param {Properties<T>} [properties] Properties to set
 * @template T extends object
 */
function Message(properties) {
    // not used internally
    if (properties)
        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            this[keys[i]] = properties[keys[i]];
}

/**
 * Reference to the reflected type.
 * @name Message.$type
 * @type {Type}
 * @readonly
 */

/**
 * Reference to the reflected type.
 * @name Message#$type
 * @type {Type}
 * @readonly
 */

/*eslint-disable valid-jsdoc*/

/**
 * Creates a new message of this type using the specified properties.
 * @param {Object.<string,*>} [properties] Properties to set
 * @returns {Message<T>} Message instance
 * @template T extends Message<T>
 * @this Constructor<T>
 */
Message.create = function create(properties) {
    return this.$type.create(properties);
};

/**
 * Encodes a message of this type.
 * @param {T|Object.<string,*>} message Message to encode
 * @param {Writer} [writer] Writer to use
 * @returns {Writer} Writer
 * @template T extends Message<T>
 * @this Constructor<T>
 */
Message.encode = function encode(message, writer) {
    return this.$type.encode(message, writer);
};

/**
 * Encodes a message of this type preceeded by its length as a varint.
 * @param {T|Object.<string,*>} message Message to encode
 * @param {Writer} [writer] Writer to use
 * @returns {Writer} Writer
 * @template T extends Message<T>
 * @this Constructor<T>
 */
Message.encodeDelimited = function encodeDelimited(message, writer) {
    return this.$type.encodeDelimited(message, writer);
};

/**
 * Decodes a message of this type.
 * @name Message.decode
 * @function
 * @param {Reader|Uint8Array} reader Reader or buffer to decode
 * @returns {T} Decoded message
 * @template T extends Message<T>
 * @this Constructor<T>
 */
Message.decode = function decode(reader) {
    return this.$type.decode(reader);
};

/**
 * Decodes a message of this type preceeded by its length as a varint.
 * @name Message.decodeDelimited
 * @function
 * @param {Reader|Uint8Array} reader Reader or buffer to decode
 * @returns {T} Decoded message
 * @template T extends Message<T>
 * @this Constructor<T>
 */
Message.decodeDelimited = function decodeDelimited(reader) {
    return this.$type.decodeDelimited(reader);
};

/**
 * Verifies a message of this type.
 * @name Message.verify
 * @function
 * @param {Object.<string,*>} message Plain object to verify
 * @returns {string|null} `null` if valid, otherwise the reason why it is not
 */
Message.verify = function verify(message) {
    return this.$type.verify(message);
};

/**
 * Creates a new message of this type from a plain object. Also converts values to their respective internal types.
 * @param {Object.<string,*>} object Plain object
 * @returns {T} Message instance
 * @template T extends Message<T>
 * @this Constructor<T>
 */
Message.fromObject = function fromObject(object) {
    return this.$type.fromObject(object);
};

/**
 * Creates a plain object from a message of this type. Also converts values to other types if specified.
 * @param {T} message Message instance
 * @param {IConversionOptions} [options] Conversion options
 * @returns {Object.<string,*>} Plain object
 * @template T extends Message<T>
 * @this Constructor<T>
 */
Message.toObject = function toObject(message, options) {
    return this.$type.toObject(message, options);
};

/**
 * Converts this message to JSON.
 * @returns {Object.<string,*>} JSON object
 */
Message.prototype.toJSON = function toJSON() {
    return this.$type.toObject(this, util.toJSONOptions);
};

/*eslint-enable valid-jsdoc*/
},{"39":39}],22:[function(require,module,exports){
"use strict";
module.exports = Method;

// extends ReflectionObject
var ReflectionObject = require(24);
((Method.prototype = Object.create(ReflectionObject.prototype)).constructor = Method).className = "Method";

var util = require(37);

/**
 * Constructs a new service method instance.
 * @classdesc Reflected service method.
 * @extends ReflectionObject
 * @constructor
 * @param {string} name Method name
 * @param {string|undefined} type Method type, usually `"rpc"`
 * @param {string} requestType Request message type
 * @param {string} responseType Response message type
 * @param {boolean|Object.<string,*>} [requestStream] Whether the request is streamed
 * @param {boolean|Object.<string,*>} [responseStream] Whether the response is streamed
 * @param {Object.<string,*>} [options] Declared options
 * @param {string} [comment] The comment for this method
 */
function Method(name, type, requestType, responseType, requestStream, responseStream, options, comment) {

    /* istanbul ignore next */
    if (util.isObject(requestStream)) {
        options = requestStream;
        requestStream = responseStream = undefined;
    } else if (util.isObject(responseStream)) {
        options = responseStream;
        responseStream = undefined;
    }

    /* istanbul ignore if */
    if (!(type === undefined || util.isString(type)))
        throw TypeError("type must be a string");

    /* istanbul ignore if */
    if (!util.isString(requestType))
        throw TypeError("requestType must be a string");

    /* istanbul ignore if */
    if (!util.isString(responseType))
        throw TypeError("responseType must be a string");

    ReflectionObject.call(this, name, options);

    /**
     * Method type.
     * @type {string}
     */
    this.type = type || "rpc"; // toJSON

    /**
     * Request type.
     * @type {string}
     */
    this.requestType = requestType; // toJSON, marker

    /**
     * Whether requests are streamed or not.
     * @type {boolean|undefined}
     */
    this.requestStream = requestStream ? true : undefined; // toJSON

    /**
     * Response type.
     * @type {string}
     */
    this.responseType = responseType; // toJSON

    /**
     * Whether responses are streamed or not.
     * @type {boolean|undefined}
     */
    this.responseStream = responseStream ? true : undefined; // toJSON

    /**
     * Resolved request type.
     * @type {Type|null}
     */
    this.resolvedRequestType = null;

    /**
     * Resolved response type.
     * @type {Type|null}
     */
    this.resolvedResponseType = null;

    /**
     * Comment for this method
     * @type {string|null}
     */
    this.comment = comment;
}

/**
 * Method descriptor.
 * @interface IMethod
 * @property {string} [type="rpc"] Method type
 * @property {string} requestType Request type
 * @property {string} responseType Response type
 * @property {boolean} [requestStream=false] Whether requests are streamed
 * @property {boolean} [responseStream=false] Whether responses are streamed
 * @property {Object.<string,*>} [options] Method options
 */

/**
 * Constructs a method from a method descriptor.
 * @param {string} name Method name
 * @param {IMethod} json Method descriptor
 * @returns {Method} Created method
 * @throws {TypeError} If arguments are invalid
 */
Method.fromJSON = function fromJSON(name, json) {
    return new Method(name, json.type, json.requestType, json.responseType, json.requestStream, json.responseStream, json.options, json.comment);
};

/**
 * Converts this method to a method descriptor.
 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
 * @returns {IMethod} Method descriptor
 */
Method.prototype.toJSON = function toJSON(toJSONOptions) {
    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
    return util.toObject([
        "type"           , this.type !== "rpc" && /* istanbul ignore next */ this.type || undefined,
        "requestType"    , this.requestType,
        "requestStream"  , this.requestStream,
        "responseType"   , this.responseType,
        "responseStream" , this.responseStream,
        "options"        , this.options,
        "comment"        , keepComments ? this.comment : undefined
    ]);
};

/**
 * @override
 */
Method.prototype.resolve = function resolve() {

    /* istanbul ignore if */
    if (this.resolved)
        return this;

    this.resolvedRequestType = this.parent.lookupType(this.requestType);
    this.resolvedResponseType = this.parent.lookupType(this.responseType);

    return ReflectionObject.prototype.resolve.call(this);
};

},{"24":24,"37":37}],23:[function(require,module,exports){
"use strict";
module.exports = Namespace;

// extends ReflectionObject
var ReflectionObject = require(24);
((Namespace.prototype = Object.create(ReflectionObject.prototype)).constructor = Namespace).className = "Namespace";

var Enum     = require(15),
    Field    = require(16),
    util     = require(37);

var Type,    // cyclic
    Service; // "

/**
 * Constructs a new namespace instance.
 * @name Namespace
 * @classdesc Reflected namespace.
 * @extends NamespaceBase
 * @constructor
 * @param {string} name Namespace name
 * @param {Object.<string,*>} [options] Declared options
 */

/**
 * Constructs a namespace from JSON.
 * @memberof Namespace
 * @function
 * @param {string} name Namespace name
 * @param {Object.<string,*>} json JSON object
 * @returns {Namespace} Created namespace
 * @throws {TypeError} If arguments are invalid
 */
Namespace.fromJSON = function fromJSON(name, json) {
    return new Namespace(name, json.options).addJSON(json.nested);
};

/**
 * Converts an array of reflection objects to JSON.
 * @memberof Namespace
 * @param {ReflectionObject[]} array Object array
 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
 * @returns {Object.<string,*>|undefined} JSON object or `undefined` when array is empty
 */
function arrayToJSON(array, toJSONOptions) {
    if (!(array && array.length))
        return undefined;
    var obj = {};
    for (var i = 0; i < array.length; ++i)
        obj[array[i].name] = array[i].toJSON(toJSONOptions);
    return obj;
}

Namespace.arrayToJSON = arrayToJSON;

/**
 * Tests if the specified id is reserved.
 * @param {Array.<number[]|string>|undefined} reserved Array of reserved ranges and names
 * @param {number} id Id to test
 * @returns {boolean} `true` if reserved, otherwise `false`
 */
Namespace.isReservedId = function isReservedId(reserved, id) {
    if (reserved)
        for (var i = 0; i < reserved.length; ++i)
            if (typeof reserved[i] !== "string" && reserved[i][0] <= id && reserved[i][1] >= id)
                return true;
    return false;
};

/**
 * Tests if the specified name is reserved.
 * @param {Array.<number[]|string>|undefined} reserved Array of reserved ranges and names
 * @param {string} name Name to test
 * @returns {boolean} `true` if reserved, otherwise `false`
 */
Namespace.isReservedName = function isReservedName(reserved, name) {
    if (reserved)
        for (var i = 0; i < reserved.length; ++i)
            if (reserved[i] === name)
                return true;
    return false;
};

/**
 * Not an actual constructor. Use {@link Namespace} instead.
 * @classdesc Base class of all reflection objects containing nested objects. This is not an actual class but here for the sake of having consistent type definitions.
 * @exports NamespaceBase
 * @extends ReflectionObject
 * @abstract
 * @constructor
 * @param {string} name Namespace name
 * @param {Object.<string,*>} [options] Declared options
 * @see {@link Namespace}
 */
function Namespace(name, options) {
    ReflectionObject.call(this, name, options);

    /**
     * Nested objects by name.
     * @type {Object.<string,ReflectionObject>|undefined}
     */
    this.nested = undefined; // toJSON

    /**
     * Cached nested objects as an array.
     * @type {ReflectionObject[]|null}
     * @private
     */
    this._nestedArray = null;
}

function clearCache(namespace) {
    namespace._nestedArray = null;
    return namespace;
}

/**
 * Nested objects of this namespace as an array for iteration.
 * @name NamespaceBase#nestedArray
 * @type {ReflectionObject[]}
 * @readonly
 */
Object.defineProperty(Namespace.prototype, "nestedArray", {
    get: function() {
        return this._nestedArray || (this._nestedArray = util.toArray(this.nested));
    }
});

/**
 * Namespace descriptor.
 * @interface INamespace
 * @property {Object.<string,*>} [options] Namespace options
 * @property {Object.<string,AnyNestedObject>} [nested] Nested object descriptors
 */

/**
 * Any extension field descriptor.
 * @typedef AnyExtensionField
 * @type {IExtensionField|IExtensionMapField}
 */

/**
 * Any nested object descriptor.
 * @typedef AnyNestedObject
 * @type {IEnum|IType|IService|AnyExtensionField|INamespace}
 */
// ^ BEWARE: VSCode hangs forever when using more than 5 types (that's why AnyExtensionField exists in the first place)

/**
 * Converts this namespace to a namespace descriptor.
 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
 * @returns {INamespace} Namespace descriptor
 */
Namespace.prototype.toJSON = function toJSON(toJSONOptions) {
    return util.toObject([
        "options" , this.options,
        "nested"  , arrayToJSON(this.nestedArray, toJSONOptions)
    ]);
};

/**
 * Adds nested objects to this namespace from nested object descriptors.
 * @param {Object.<string,AnyNestedObject>} nestedJson Any nested object descriptors
 * @returns {Namespace} `this`
 */
Namespace.prototype.addJSON = function addJSON(nestedJson) {
    var ns = this;
    /* istanbul ignore else */
    if (nestedJson) {
        for (var names = Object.keys(nestedJson), i = 0, nested; i < names.length; ++i) {
            nested = nestedJson[names[i]];
            ns.add( // most to least likely
                ( nested.fields !== undefined
                ? Type.fromJSON
                : nested.values !== undefined
                ? Enum.fromJSON
                : nested.methods !== undefined
                ? Service.fromJSON
                : nested.id !== undefined
                ? Field.fromJSON
                : Namespace.fromJSON )(names[i], nested)
            );
        }
    }
    return this;
};

/**
 * Gets the nested object of the specified name.
 * @param {string} name Nested object name
 * @returns {ReflectionObject|null} The reflection object or `null` if it doesn't exist
 */
Namespace.prototype.get = function get(name) {
    return this.nested && this.nested[name]
        || null;
};

/**
 * Gets the values of the nested {@link Enum|enum} of the specified name.
 * This methods differs from {@link Namespace#get|get} in that it returns an enum's values directly and throws instead of returning `null`.
 * @param {string} name Nested enum name
 * @returns {Object.<string,number>} Enum values
 * @throws {Error} If there is no such enum
 */
Namespace.prototype.getEnum = function getEnum(name) {
    if (this.nested && this.nested[name] instanceof Enum)
        return this.nested[name].values;
    throw Error("no such enum: " + name);
};

/**
 * Adds a nested object to this namespace.
 * @param {ReflectionObject} object Nested object to add
 * @returns {Namespace} `this`
 * @throws {TypeError} If arguments are invalid
 * @throws {Error} If there is already a nested object with this name
 */
Namespace.prototype.add = function add(object) {

    if (!(object instanceof Field && object.extend !== undefined || object instanceof Type || object instanceof Enum || object instanceof Service || object instanceof Namespace))
        throw TypeError("object must be a valid nested object");

    if (!this.nested)
        this.nested = {};
    else {
        var prev = this.get(object.name);
        if (prev) {
            if (prev instanceof Namespace && object instanceof Namespace && !(prev instanceof Type || prev instanceof Service)) {
                // replace plain namespace but keep existing nested elements and options
                var nested = prev.nestedArray;
                for (var i = 0; i < nested.length; ++i)
                    object.add(nested[i]);
                this.remove(prev);
                if (!this.nested)
                    this.nested = {};
                object.setOptions(prev.options, true);

            } else
                throw Error("duplicate name '" + object.name + "' in " + this);
        }
    }
    this.nested[object.name] = object;
    object.onAdd(this);
    return clearCache(this);
};

/**
 * Removes a nested object from this namespace.
 * @param {ReflectionObject} object Nested object to remove
 * @returns {Namespace} `this`
 * @throws {TypeError} If arguments are invalid
 * @throws {Error} If `object` is not a member of this namespace
 */
Namespace.prototype.remove = function remove(object) {

    if (!(object instanceof ReflectionObject))
        throw TypeError("object must be a ReflectionObject");
    if (object.parent !== this)
        throw Error(object + " is not a member of " + this);

    delete this.nested[object.name];
    if (!Object.keys(this.nested).length)
        this.nested = undefined;

    object.onRemove(this);
    return clearCache(this);
};

/**
 * Defines additial namespaces within this one if not yet existing.
 * @param {string|string[]} path Path to create
 * @param {*} [json] Nested types to create from JSON
 * @returns {Namespace} Pointer to the last namespace created or `this` if path is empty
 */
Namespace.prototype.define = function define(path, json) {

    if (util.isString(path))
        path = path.split(".");
    else if (!Array.isArray(path))
        throw TypeError("illegal path");
    if (path && path.length && path[0] === "")
        throw Error("path must be relative");

    var ptr = this;
    while (path.length > 0) {
        var part = path.shift();
        if (ptr.nested && ptr.nested[part]) {
            ptr = ptr.nested[part];
            if (!(ptr instanceof Namespace))
                throw Error("path conflicts with non-namespace objects");
        } else
            ptr.add(ptr = new Namespace(part));
    }
    if (json)
        ptr.addJSON(json);
    return ptr;
};

/**
 * Resolves this namespace's and all its nested objects' type references. Useful to validate a reflection tree, but comes at a cost.
 * @returns {Namespace} `this`
 */
Namespace.prototype.resolveAll = function resolveAll() {
    var nested = this.nestedArray, i = 0;
    while (i < nested.length)
        if (nested[i] instanceof Namespace)
            nested[i++].resolveAll();
        else
            nested[i++].resolve();
    return this.resolve();
};

/**
 * Recursively looks up the reflection object matching the specified path in the scope of this namespace.
 * @param {string|string[]} path Path to look up
 * @param {*|Array.<*>} filterTypes Filter types, any combination of the constructors of `protobuf.Type`, `protobuf.Enum`, `protobuf.Service` etc.
 * @param {boolean} [parentAlreadyChecked=false] If known, whether the parent has already been checked
 * @returns {ReflectionObject|null} Looked up object or `null` if none could be found
 */
Namespace.prototype.lookup = function lookup(path, filterTypes, parentAlreadyChecked) {

    /* istanbul ignore next */
    if (typeof filterTypes === "boolean") {
        parentAlreadyChecked = filterTypes;
        filterTypes = undefined;
    } else if (filterTypes && !Array.isArray(filterTypes))
        filterTypes = [ filterTypes ];

    if (util.isString(path) && path.length) {
        if (path === ".")
            return this.root;
        path = path.split(".");
    } else if (!path.length)
        return this;

    // Start at root if path is absolute
    if (path[0] === "")
        return this.root.lookup(path.slice(1), filterTypes);

    // Test if the first part matches any nested object, and if so, traverse if path contains more
    var found = this.get(path[0]);
    if (found) {
        if (path.length === 1) {
            if (!filterTypes || filterTypes.indexOf(found.constructor) > -1)
                return found;
        } else if (found instanceof Namespace && (found = found.lookup(path.slice(1), filterTypes, true)))
            return found;

    // Otherwise try each nested namespace
    } else
        for (var i = 0; i < this.nestedArray.length; ++i)
            if (this._nestedArray[i] instanceof Namespace && (found = this._nestedArray[i].lookup(path, filterTypes, true)))
                return found;

    // If there hasn't been a match, try again at the parent
    if (this.parent === null || parentAlreadyChecked)
        return null;
    return this.parent.lookup(path, filterTypes);
};

/**
 * Looks up the reflection object at the specified path, relative to this namespace.
 * @name NamespaceBase#lookup
 * @function
 * @param {string|string[]} path Path to look up
 * @param {boolean} [parentAlreadyChecked=false] Whether the parent has already been checked
 * @returns {ReflectionObject|null} Looked up object or `null` if none could be found
 * @variation 2
 */
// lookup(path: string, [parentAlreadyChecked: boolean])

/**
 * Looks up the {@link Type|type} at the specified path, relative to this namespace.
 * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.
 * @param {string|string[]} path Path to look up
 * @returns {Type} Looked up type
 * @throws {Error} If `path` does not point to a type
 */
Namespace.prototype.lookupType = function lookupType(path) {
    var found = this.lookup(path, [ Type ]);
    if (!found)
        throw Error("no such type: " + path);
    return found;
};

/**
 * Looks up the values of the {@link Enum|enum} at the specified path, relative to this namespace.
 * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.
 * @param {string|string[]} path Path to look up
 * @returns {Enum} Looked up enum
 * @throws {Error} If `path` does not point to an enum
 */
Namespace.prototype.lookupEnum = function lookupEnum(path) {
    var found = this.lookup(path, [ Enum ]);
    if (!found)
        throw Error("no such Enum '" + path + "' in " + this);
    return found;
};

/**
 * Looks up the {@link Type|type} or {@link Enum|enum} at the specified path, relative to this namespace.
 * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.
 * @param {string|string[]} path Path to look up
 * @returns {Type} Looked up type or enum
 * @throws {Error} If `path` does not point to a type or enum
 */
Namespace.prototype.lookupTypeOrEnum = function lookupTypeOrEnum(path) {
    var found = this.lookup(path, [ Type, Enum ]);
    if (!found)
        throw Error("no such Type or Enum '" + path + "' in " + this);
    return found;
};

/**
 * Looks up the {@link Service|service} at the specified path, relative to this namespace.
 * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.
 * @param {string|string[]} path Path to look up
 * @returns {Service} Looked up service
 * @throws {Error} If `path` does not point to a service
 */
Namespace.prototype.lookupService = function lookupService(path) {
    var found = this.lookup(path, [ Service ]);
    if (!found)
        throw Error("no such Service '" + path + "' in " + this);
    return found;
};

Namespace._configure = function(Type_, Service_) {
    Type    = Type_;
    Service = Service_;
};

},{"15":15,"16":16,"24":24,"37":37}],24:[function(require,module,exports){
"use strict";
module.exports = ReflectionObject;

ReflectionObject.className = "ReflectionObject";

var util = require(37);

var Root; // cyclic

/**
 * Constructs a new reflection object instance.
 * @classdesc Base class of all reflection objects.
 * @constructor
 * @param {string} name Object name
 * @param {Object.<string,*>} [options] Declared options
 * @abstract
 */
function ReflectionObject(name, options) {

    if (!util.isString(name))
        throw TypeError("name must be a string");

    if (options && !util.isObject(options))
        throw TypeError("options must be an object");

    /**
     * Options.
     * @type {Object.<string,*>|undefined}
     */
    this.options = options; // toJSON

    /**
     * Unique name within its namespace.
     * @type {string}
     */
    this.name = name;

    /**
     * Parent namespace.
     * @type {Namespace|null}
     */
    this.parent = null;

    /**
     * Whether already resolved or not.
     * @type {boolean}
     */
    this.resolved = false;

    /**
     * Comment text, if any.
     * @type {string|null}
     */
    this.comment = null;

    /**
     * Defining file name.
     * @type {string|null}
     */
    this.filename = null;
}

Object.defineProperties(ReflectionObject.prototype, {

    /**
     * Reference to the root namespace.
     * @name ReflectionObject#root
     * @type {Root}
     * @readonly
     */
    root: {
        get: function() {
            var ptr = this;
            while (ptr.parent !== null)
                ptr = ptr.parent;
            return ptr;
        }
    },

    /**
     * Full name including leading dot.
     * @name ReflectionObject#fullName
     * @type {string}
     * @readonly
     */
    fullName: {
        get: function() {
            var path = [ this.name ],
                ptr = this.parent;
            while (ptr) {
                path.unshift(ptr.name);
                ptr = ptr.parent;
            }
            return path.join(".");
        }
    }
});

/**
 * Converts this reflection object to its descriptor representation.
 * @returns {Object.<string,*>} Descriptor
 * @abstract
 */
ReflectionObject.prototype.toJSON = /* istanbul ignore next */ function toJSON() {
    throw Error(); // not implemented, shouldn't happen
};

/**
 * Called when this object is added to a parent.
 * @param {ReflectionObject} parent Parent added to
 * @returns {undefined}
 */
ReflectionObject.prototype.onAdd = function onAdd(parent) {
    if (this.parent && this.parent !== parent)
        this.parent.remove(this);
    this.parent = parent;
    this.resolved = false;
    var root = parent.root;
    if (root instanceof Root)
        root._handleAdd(this);
};

/**
 * Called when this object is removed from a parent.
 * @param {ReflectionObject} parent Parent removed from
 * @returns {undefined}
 */
ReflectionObject.prototype.onRemove = function onRemove(parent) {
    var root = parent.root;
    if (root instanceof Root)
        root._handleRemove(this);
    this.parent = null;
    this.resolved = false;
};

/**
 * Resolves this objects type references.
 * @returns {ReflectionObject} `this`
 */
ReflectionObject.prototype.resolve = function resolve() {
    if (this.resolved)
        return this;
    if (this.root instanceof Root)
        this.resolved = true; // only if part of a root
    return this;
};

/**
 * Gets an option value.
 * @param {string} name Option name
 * @returns {*} Option value or `undefined` if not set
 */
ReflectionObject.prototype.getOption = function getOption(name) {
    if (this.options)
        return this.options[name];
    return undefined;
};

/**
 * Sets an option.
 * @param {string} name Option name
 * @param {*} value Option value
 * @param {boolean} [ifNotSet] Sets the option only if it isn't currently set
 * @returns {ReflectionObject} `this`
 */
ReflectionObject.prototype.setOption = function setOption(name, value, ifNotSet) {
    if (!ifNotSet || !this.options || this.options[name] === undefined)
        (this.options || (this.options = {}))[name] = value;
    return this;
};

/**
 * Sets multiple options.
 * @param {Object.<string,*>} options Options to set
 * @param {boolean} [ifNotSet] Sets an option only if it isn't currently set
 * @returns {ReflectionObject} `this`
 */
ReflectionObject.prototype.setOptions = function setOptions(options, ifNotSet) {
    if (options)
        for (var keys = Object.keys(options), i = 0; i < keys.length; ++i)
            this.setOption(keys[i], options[keys[i]], ifNotSet);
    return this;
};

/**
 * Converts this instance to its string representation.
 * @returns {string} Class name[, space, full name]
 */
ReflectionObject.prototype.toString = function toString() {
    var className = this.constructor.className,
        fullName  = this.fullName;
    if (fullName.length)
        return className + " " + fullName;
    return className;
};

ReflectionObject._configure = function(Root_) {
    Root = Root_;
};

},{"37":37}],25:[function(require,module,exports){
"use strict";
module.exports = OneOf;

// extends ReflectionObject
var ReflectionObject = require(24);
((OneOf.prototype = Object.create(ReflectionObject.prototype)).constructor = OneOf).className = "OneOf";

var Field = require(16),
    util  = require(37);

/**
 * Constructs a new oneof instance.
 * @classdesc Reflected oneof.
 * @extends ReflectionObject
 * @constructor
 * @param {string} name Oneof name
 * @param {string[]|Object.<string,*>} [fieldNames] Field names
 * @param {Object.<string,*>} [options] Declared options
 * @param {string} [comment] Comment associated with this field
 */
function OneOf(name, fieldNames, options, comment) {
    if (!Array.isArray(fieldNames)) {
        options = fieldNames;
        fieldNames = undefined;
    }
    ReflectionObject.call(this, name, options);

    /* istanbul ignore if */
    if (!(fieldNames === undefined || Array.isArray(fieldNames)))
        throw TypeError("fieldNames must be an Array");

    /**
     * Field names that belong to this oneof.
     * @type {string[]}
     */
    this.oneof = fieldNames || []; // toJSON, marker

    /**
     * Fields that belong to this oneof as an array for iteration.
     * @type {Field[]}
     * @readonly
     */
    this.fieldsArray = []; // declared readonly for conformance, possibly not yet added to parent

    /**
     * Comment for this field.
     * @type {string|null}
     */
    this.comment = comment;
}

/**
 * Oneof descriptor.
 * @interface IOneOf
 * @property {Array.<string>} oneof Oneof field names
 * @property {Object.<string,*>} [options] Oneof options
 */

/**
 * Constructs a oneof from a oneof descriptor.
 * @param {string} name Oneof name
 * @param {IOneOf} json Oneof descriptor
 * @returns {OneOf} Created oneof
 * @throws {TypeError} If arguments are invalid
 */
OneOf.fromJSON = function fromJSON(name, json) {
    return new OneOf(name, json.oneof, json.options, json.comment);
};

/**
 * Converts this oneof to a oneof descriptor.
 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
 * @returns {IOneOf} Oneof descriptor
 */
OneOf.prototype.toJSON = function toJSON(toJSONOptions) {
    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
    return util.toObject([
        "options" , this.options,
        "oneof"   , this.oneof,
        "comment" , keepComments ? this.comment : undefined
    ]);
};

/**
 * Adds the fields of the specified oneof to the parent if not already done so.
 * @param {OneOf} oneof The oneof
 * @returns {undefined}
 * @inner
 * @ignore
 */
function addFieldsToParent(oneof) {
    if (oneof.parent)
        for (var i = 0; i < oneof.fieldsArray.length; ++i)
            if (!oneof.fieldsArray[i].parent)
                oneof.parent.add(oneof.fieldsArray[i]);
}

/**
 * Adds a field to this oneof and removes it from its current parent, if any.
 * @param {Field} field Field to add
 * @returns {OneOf} `this`
 */
OneOf.prototype.add = function add(field) {

    /* istanbul ignore if */
    if (!(field instanceof Field))
        throw TypeError("field must be a Field");

    if (field.parent && field.parent !== this.parent)
        field.parent.remove(field);
    this.oneof.push(field.name);
    this.fieldsArray.push(field);
    field.partOf = this; // field.parent remains null
    addFieldsToParent(this);
    return this;
};

/**
 * Removes a field from this oneof and puts it back to the oneof's parent.
 * @param {Field} field Field to remove
 * @returns {OneOf} `this`
 */
OneOf.prototype.remove = function remove(field) {

    /* istanbul ignore if */
    if (!(field instanceof Field))
        throw TypeError("field must be a Field");

    var index = this.fieldsArray.indexOf(field);

    /* istanbul ignore if */
    if (index < 0)
        throw Error(field + " is not a member of " + this);

    this.fieldsArray.splice(index, 1);
    index = this.oneof.indexOf(field.name);

    /* istanbul ignore else */
    if (index > -1) // theoretical
        this.oneof.splice(index, 1);

    field.partOf = null;
    return this;
};

/**
 * @override
 */
OneOf.prototype.onAdd = function onAdd(parent) {
    ReflectionObject.prototype.onAdd.call(this, parent);
    var self = this;
    // Collect present fields
    for (var i = 0; i < this.oneof.length; ++i) {
        var field = parent.get(this.oneof[i]);
        if (field && !field.partOf) {
            field.partOf = self;
            self.fieldsArray.push(field);
        }
    }
    // Add not yet present fields
    addFieldsToParent(this);
};

/**
 * @override
 */
OneOf.prototype.onRemove = function onRemove(parent) {
    for (var i = 0, field; i < this.fieldsArray.length; ++i)
        if ((field = this.fieldsArray[i]).parent)
            field.parent.remove(field);
    ReflectionObject.prototype.onRemove.call(this, parent);
};

/**
 * Decorator function as returned by {@link OneOf.d} (TypeScript).
 * @typedef OneOfDecorator
 * @type {function}
 * @param {Object} prototype Target prototype
 * @param {string} oneofName OneOf name
 * @returns {undefined}
 */

/**
 * OneOf decorator (TypeScript).
 * @function
 * @param {...string} fieldNames Field names
 * @returns {OneOfDecorator} Decorator function
 * @template T extends string
 */
OneOf.d = function decorateOneOf() {
    var fieldNames = new Array(arguments.length),
        index = 0;
    while (index < arguments.length)
        fieldNames[index] = arguments[index++];
    return function oneOfDecorator(prototype, oneofName) {
        util.decorateType(prototype.constructor)
            .add(new OneOf(oneofName, fieldNames));
        Object.defineProperty(prototype, oneofName, {
            get: util.oneOfGetter(fieldNames),
            set: util.oneOfSetter(fieldNames)
        });
    };
};

},{"16":16,"24":24,"37":37}],26:[function(require,module,exports){
"use strict";
module.exports = parse;

parse.filename = null;
parse.defaults = { keepCase: false };

var tokenize  = require(34),
    Root      = require(29),
    Type      = require(35),
    Field     = require(16),
    MapField  = require(20),
    OneOf     = require(25),
    Enum      = require(15),
    Service   = require(33),
    Method    = require(22),
    types     = require(36),
    util      = require(37);

var base10Re    = /^[1-9][0-9]*$/,
    base10NegRe = /^-?[1-9][0-9]*$/,
    base16Re    = /^0[x][0-9a-fA-F]+$/,
    base16NegRe = /^-?0[x][0-9a-fA-F]+$/,
    base8Re     = /^0[0-7]+$/,
    base8NegRe  = /^-?0[0-7]+$/,
    numberRe    = /^(?![eE])[0-9]*(?:\.[0-9]*)?(?:[eE][+-]?[0-9]+)?$/,
    nameRe      = /^[a-zA-Z_][a-zA-Z_0-9]*$/,
    typeRefRe   = /^(?:\.?[a-zA-Z_][a-zA-Z_0-9]*)(?:\.[a-zA-Z_][a-zA-Z_0-9]*)*$/,
    fqTypeRefRe = /^(?:\.[a-zA-Z_][a-zA-Z_0-9]*)+$/;

/**
 * Result object returned from {@link parse}.
 * @interface IParserResult
 * @property {string|undefined} package Package name, if declared
 * @property {string[]|undefined} imports Imports, if any
 * @property {string[]|undefined} weakImports Weak imports, if any
 * @property {string|undefined} syntax Syntax, if specified (either `"proto2"` or `"proto3"`)
 * @property {Root} root Populated root instance
 */

/**
 * Options modifying the behavior of {@link parse}.
 * @interface IParseOptions
 * @property {boolean} [keepCase=false] Keeps field casing instead of converting to camel case
 * @property {boolean} [alternateCommentMode=false] Recognize double-slash comments in addition to doc-block comments.
 */

/**
 * Options modifying the behavior of JSON serialization.
 * @interface IToJSONOptions
 * @property {boolean} [keepComments=false] Serializes comments.
 */

/**
 * Parses the given .proto source and returns an object with the parsed contents.
 * @param {string} source Source contents
 * @param {Root} root Root to populate
 * @param {IParseOptions} [options] Parse options. Defaults to {@link parse.defaults} when omitted.
 * @returns {IParserResult} Parser result
 * @property {string} filename=null Currently processing file name for error reporting, if known
 * @property {IParseOptions} defaults Default {@link IParseOptions}
 */
function parse(source, root, options) {
    /* eslint-disable callback-return */
    if (!(root instanceof Root)) {
        options = root;
        root = new Root();
    }
    if (!options)
        options = parse.defaults;

    var tn = tokenize(source, options.alternateCommentMode || false),
        next = tn.next,
        push = tn.push,
        peek = tn.peek,
        skip = tn.skip,
        cmnt = tn.cmnt;

    var head = true,
        pkg,
        imports,
        weakImports,
        syntax,
        isProto3 = false;

    var ptr = root;

    var applyCase = options.keepCase ? function(name) { return name; } : util.camelCase;

    /* istanbul ignore next */
    function illegal(token, name, insideTryCatch) {
        var filename = parse.filename;
        if (!insideTryCatch)
            parse.filename = null;
        return Error("illegal " + (name || "token") + " '" + token + "' (" + (filename ? filename + ", " : "") + "line " + tn.line + ")");
    }

    function readString() {
        var values = [],
            token;
        do {
            /* istanbul ignore if */
            if ((token = next()) !== "\"" && token !== "'")
                throw illegal(token);

            values.push(next());
            skip(token);
            token = peek();
        } while (token === "\"" || token === "'");
        return values.join("");
    }

    function readValue(acceptTypeRef) {
        var token = next();
        switch (token) {
            case "'":
            case "\"":
                push(token);
                return readString();
            case "true": case "TRUE":
                return true;
            case "false": case "FALSE":
                return false;
        }
        try {
            return parseNumber(token, /* insideTryCatch */ true);
        } catch (e) {

            /* istanbul ignore else */
            if (acceptTypeRef && typeRefRe.test(token))
                return token;

            /* istanbul ignore next */
            throw illegal(token, "value");
        }
    }

    function readRanges(target, acceptStrings) {
        var token, start;
        do {
            if (acceptStrings && ((token = peek()) === "\"" || token === "'"))
                target.push(readString());
            else
                target.push([ start = parseId(next()), skip("to", true) ? parseId(next()) : start ]);
        } while (skip(",", true));
        skip(";");
    }

    function parseNumber(token, insideTryCatch) {
        var sign = 1;
        if (token.charAt(0) === "-") {
            sign = -1;
            token = token.substring(1);
        }
        switch (token) {
            case "inf": case "INF": case "Inf":
                return sign * Infinity;
            case "nan": case "NAN": case "Nan": case "NaN":
                return NaN;
            case "0":
                return 0;
        }
        if (base10Re.test(token))
            return sign * parseInt(token, 10);
        if (base16Re.test(token))
            return sign * parseInt(token, 16);
        if (base8Re.test(token))
            return sign * parseInt(token, 8);

        /* istanbul ignore else */
        if (numberRe.test(token))
            return sign * parseFloat(token);

        /* istanbul ignore next */
        throw illegal(token, "number", insideTryCatch);
    }

    function parseId(token, acceptNegative) {
        switch (token) {
            case "max": case "MAX": case "Max":
                return 536870911;
            case "0":
                return 0;
        }

        /* istanbul ignore if */
        if (!acceptNegative && token.charAt(0) === "-")
            throw illegal(token, "id");

        if (base10NegRe.test(token))
            return parseInt(token, 10);
        if (base16NegRe.test(token))
            return parseInt(token, 16);

        /* istanbul ignore else */
        if (base8NegRe.test(token))
            return parseInt(token, 8);

        /* istanbul ignore next */
        throw illegal(token, "id");
    }

    function parsePackage() {

        /* istanbul ignore if */
        if (pkg !== undefined)
            throw illegal("package");

        pkg = next();

        /* istanbul ignore if */
        if (!typeRefRe.test(pkg))
            throw illegal(pkg, "name");

        ptr = ptr.define(pkg);
        skip(";");
    }

    function parseImport() {
        var token = peek();
        var whichImports;
        switch (token) {
            case "weak":
                whichImports = weakImports || (weakImports = []);
                next();
                break;
            case "public":
                next();
                // eslint-disable-line no-fallthrough
            default:
                whichImports = imports || (imports = []);
                break;
        }
        token = readString();
        skip(";");
        whichImports.push(token);
    }

    function parseSyntax() {
        skip("=");
        syntax = readString();
        isProto3 = syntax === "proto3";

        /* istanbul ignore if */
        if (!isProto3 && syntax !== "proto2")
            throw illegal(syntax, "syntax");

        skip(";");
    }

    function parseCommon(parent, token) {
        switch (token) {

            case "option":
                parseOption(parent, token);
                skip(";");
                return true;

            case "message":
                parseType(parent, token);
                return true;

            case "enum":
                parseEnum(parent, token);
                return true;

            case "service":
                parseService(parent, token);
                return true;

            case "extend":
                parseExtension(parent, token);
                return true;
        }
        return false;
    }

    function ifBlock(obj, fnIf, fnElse) {
        var trailingLine = tn.line;
        if (obj) {
            obj.comment = cmnt(); // try block-type comment
            obj.filename = parse.filename;
        }
        if (skip("{", true)) {
            var token;
            while ((token = next()) !== "}")
                fnIf(token);
            skip(";", true);
        } else {
            if (fnElse)
                fnElse();
            skip(";");
            if (obj && typeof obj.comment !== "string")
                obj.comment = cmnt(trailingLine); // try line-type comment if no block
        }
    }

    function parseType(parent, token) {

        /* istanbul ignore if */
        if (!nameRe.test(token = next()))
            throw illegal(token, "type name");

        var type = new Type(token);
        ifBlock(type, function parseType_block(token) {
            if (parseCommon(type, token))
                return;

            switch (token) {

                case "map":
                    parseMapField(type, token);
                    break;

                case "required":
                case "optional":
                case "repeated":
                    parseField(type, token);
                    break;

                case "oneof":
                    parseOneOf(type, token);
                    break;

                case "extensions":
                    readRanges(type.extensions || (type.extensions = []));
                    break;

                case "reserved":
                    readRanges(type.reserved || (type.reserved = []), true);
                    break;

                default:
                    /* istanbul ignore if */
                    if (!isProto3 || !typeRefRe.test(token))
                        throw illegal(token);

                    push(token);
                    parseField(type, "optional");
                    break;
            }
        });
        parent.add(type);
    }

    function parseField(parent, rule, extend) {
        var type = next();
        if (type === "group") {
            parseGroup(parent, rule);
            return;
        }

        /* istanbul ignore if */
        if (!typeRefRe.test(type))
            throw illegal(type, "type");

        var name = next();

        /* istanbul ignore if */
        if (!nameRe.test(name))
            throw illegal(name, "name");

        name = applyCase(name);
        skip("=");

        var field = new Field(name, parseId(next()), type, rule, extend);
        ifBlock(field, function parseField_block(token) {

            /* istanbul ignore else */
            if (token === "option") {
                parseOption(field, token);
                skip(";");
            } else
                throw illegal(token);

        }, function parseField_line() {
            parseInlineOptions(field);
        });
        parent.add(field);

        // JSON defaults to packed=true if not set so we have to set packed=false explicity when
        // parsing proto2 descriptors without the option, where applicable. This must be done for
        // all known packable types and anything that could be an enum (= is not a basic type).
        if (!isProto3 && field.repeated && (types.packed[type] !== undefined || types.basic[type] === undefined))
            field.setOption("packed", false, /* ifNotSet */ true);
    }

    function parseGroup(parent, rule) {
        var name = next();

        /* istanbul ignore if */
        if (!nameRe.test(name))
            throw illegal(name, "name");

        var fieldName = util.lcFirst(name);
        if (name === fieldName)
            name = util.ucFirst(name);
        skip("=");
        var id = parseId(next());
        var type = new Type(name);
        type.group = true;
        var field = new Field(fieldName, id, name, rule);
        field.filename = parse.filename;
        ifBlock(type, function parseGroup_block(token) {
            switch (token) {

                case "option":
                    parseOption(type, token);
                    skip(";");
                    break;

                case "required":
                case "optional":
                case "repeated":
                    parseField(type, token);
                    break;

                /* istanbul ignore next */
                default:
                    throw illegal(token); // there are no groups with proto3 semantics
            }
        });
        parent.add(type)
              .add(field);
    }

    function parseMapField(parent) {
        skip("<");
        var keyType = next();

        /* istanbul ignore if */
        if (types.mapKey[keyType] === undefined)
            throw illegal(keyType, "type");

        skip(",");
        var valueType = next();

        /* istanbul ignore if */
        if (!typeRefRe.test(valueType))
            throw illegal(valueType, "type");

        skip(">");
        var name = next();

        /* istanbul ignore if */
        if (!nameRe.test(name))
            throw illegal(name, "name");

        skip("=");
        var field = new MapField(applyCase(name), parseId(next()), keyType, valueType);
        ifBlock(field, function parseMapField_block(token) {

            /* istanbul ignore else */
            if (token === "option") {
                parseOption(field, token);
                skip(";");
            } else
                throw illegal(token);

        }, function parseMapField_line() {
            parseInlineOptions(field);
        });
        parent.add(field);
    }

    function parseOneOf(parent, token) {

        /* istanbul ignore if */
        if (!nameRe.test(token = next()))
            throw illegal(token, "name");

        var oneof = new OneOf(applyCase(token));
        ifBlock(oneof, function parseOneOf_block(token) {
            if (token === "option") {
                parseOption(oneof, token);
                skip(";");
            } else {
                push(token);
                parseField(oneof, "optional");
            }
        });
        parent.add(oneof);
    }

    function parseEnum(parent, token) {

        /* istanbul ignore if */
        if (!nameRe.test(token = next()))
            throw illegal(token, "name");

        var enm = new Enum(token);
        ifBlock(enm, function parseEnum_block(token) {
          switch(token) {
            case "option":
              parseOption(enm, token);
              skip(";");
              break;

            case "reserved":
              readRanges(enm.reserved || (enm.reserved = []), true);
              break;

            default:
              parseEnumValue(enm, token);
          }
        });
        parent.add(enm);
    }

    function parseEnumValue(parent, token) {

        /* istanbul ignore if */
        if (!nameRe.test(token))
            throw illegal(token, "name");

        skip("=");
        var value = parseId(next(), true),
            dummy = {};
        ifBlock(dummy, function parseEnumValue_block(token) {

            /* istanbul ignore else */
            if (token === "option") {
                parseOption(dummy, token); // skip
                skip(";");
            } else
                throw illegal(token);

        }, function parseEnumValue_line() {
            parseInlineOptions(dummy); // skip
        });
        parent.add(token, value, dummy.comment);
    }

    function parseOption(parent, token) {
        var isCustom = skip("(", true);

        /* istanbul ignore if */
        if (!typeRefRe.test(token = next()))
            throw illegal(token, "name");

        var name = token;
        if (isCustom) {
            skip(")");
            name = "(" + name + ")";
            token = peek();
            if (fqTypeRefRe.test(token)) {
                name += token;
                next();
            }
        }
        skip("=");
        parseOptionValue(parent, name);
    }

    function parseOptionValue(parent, name) {
        if (skip("{", true)) { // { a: "foo" b { c: "bar" } }
            do {
                /* istanbul ignore if */
                if (!nameRe.test(token = next()))
                    throw illegal(token, "name");

                if (peek() === "{")
                    parseOptionValue(parent, name + "." + token);
                else {
                    skip(":");
                    if (peek() === "{")
                        parseOptionValue(parent, name + "." + token);
                    else
                        setOption(parent, name + "." + token, readValue(true));
                }
            } while (!skip("}", true));
        } else
            setOption(parent, name, readValue(true));
        // Does not enforce a delimiter to be universal
    }

    function setOption(parent, name, value) {
        if (parent.setOption)
            parent.setOption(name, value);
    }

    function parseInlineOptions(parent) {
        if (skip("[", true)) {
            do {
                parseOption(parent, "option");
            } while (skip(",", true));
            skip("]");
        }
        return parent;
    }

    function parseService(parent, token) {

        /* istanbul ignore if */
        if (!nameRe.test(token = next()))
            throw illegal(token, "service name");

        var service = new Service(token);
        ifBlock(service, function parseService_block(token) {
            if (parseCommon(service, token))
                return;

            /* istanbul ignore else */
            if (token === "rpc")
                parseMethod(service, token);
            else
                throw illegal(token);
        });
        parent.add(service);
    }

    function parseMethod(parent, token) {
        var type = token;

        /* istanbul ignore if */
        if (!nameRe.test(token = next()))
            throw illegal(token, "name");

        var name = token,
            requestType, requestStream,
            responseType, responseStream;

        skip("(");
        if (skip("stream", true))
            requestStream = true;

        /* istanbul ignore if */
        if (!typeRefRe.test(token = next()))
            throw illegal(token);

        requestType = token;
        skip(")"); skip("returns"); skip("(");
        if (skip("stream", true))
            responseStream = true;

        /* istanbul ignore if */
        if (!typeRefRe.test(token = next()))
            throw illegal(token);

        responseType = token;
        skip(")");

        var method = new Method(name, type, requestType, responseType, requestStream, responseStream);
        ifBlock(method, function parseMethod_block(token) {

            /* istanbul ignore else */
            if (token === "option") {
                parseOption(method, token);
                skip(";");
            } else
                throw illegal(token);

        });
        parent.add(method);
    }

    function parseExtension(parent, token) {

        /* istanbul ignore if */
        if (!typeRefRe.test(token = next()))
            throw illegal(token, "reference");

        var reference = token;
        ifBlock(null, function parseExtension_block(token) {
            switch (token) {

                case "required":
                case "repeated":
                case "optional":
                    parseField(parent, token, reference);
                    break;

                default:
                    /* istanbul ignore if */
                    if (!isProto3 || !typeRefRe.test(token))
                        throw illegal(token);
                    push(token);
                    parseField(parent, "optional", reference);
                    break;
            }
        });
    }

    var token;
    while ((token = next()) !== null) {
        switch (token) {

            case "package":

                /* istanbul ignore if */
                if (!head)
                    throw illegal(token);

                parsePackage();
                break;

            case "import":

                /* istanbul ignore if */
                if (!head)
                    throw illegal(token);

                parseImport();
                break;

            case "syntax":

                /* istanbul ignore if */
                if (!head)
                    throw illegal(token);

                parseSyntax();
                break;

            case "option":

                /* istanbul ignore if */
                if (!head)
                    throw illegal(token);

                parseOption(ptr, token);
                skip(";");
                break;

            default:

                /* istanbul ignore else */
                if (parseCommon(ptr, token)) {
                    head = false;
                    continue;
                }

                /* istanbul ignore next */
                throw illegal(token);
        }
    }

    parse.filename = null;
    return {
        "package"     : pkg,
        "imports"     : imports,
         weakImports  : weakImports,
         syntax       : syntax,
         root         : root
    };
}

/**
 * Parses the given .proto source and returns an object with the parsed contents.
 * @name parse
 * @function
 * @param {string} source Source contents
 * @param {IParseOptions} [options] Parse options. Defaults to {@link parse.defaults} when omitted.
 * @returns {IParserResult} Parser result
 * @property {string} filename=null Currently processing file name for error reporting, if known
 * @property {IParseOptions} defaults Default {@link IParseOptions}
 * @variation 2
 */

},{"15":15,"16":16,"20":20,"22":22,"25":25,"29":29,"33":33,"34":34,"35":35,"36":36,"37":37}],27:[function(require,module,exports){
"use strict";
module.exports = Reader;

var util      = require(39);

var BufferReader; // cyclic

var LongBits  = util.LongBits,
    utf8      = util.utf8;

/* istanbul ignore next */
function indexOutOfRange(reader, writeLength) {
    return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);
}

/**
 * Constructs a new reader instance using the specified buffer.
 * @classdesc Wire format reader using `Uint8Array` if available, otherwise `Array`.
 * @constructor
 * @param {Uint8Array} buffer Buffer to read from
 */
function Reader(buffer) {

    /**
     * Read buffer.
     * @type {Uint8Array}
     */
    this.buf = buffer;

    /**
     * Read buffer position.
     * @type {number}
     */
    this.pos = 0;

    /**
     * Read buffer length.
     * @type {number}
     */
    this.len = buffer.length;
}

var create_array = typeof Uint8Array !== "undefined"
    ? function create_typed_array(buffer) {
        if (buffer instanceof Uint8Array || Array.isArray(buffer))
            return new Reader(buffer);
        throw Error("illegal buffer");
    }
    /* istanbul ignore next */
    : function create_array(buffer) {
        if (Array.isArray(buffer))
            return new Reader(buffer);
        throw Error("illegal buffer");
    };

/**
 * Creates a new reader using the specified buffer.
 * @function
 * @param {Uint8Array|Buffer} buffer Buffer to read from
 * @returns {Reader|BufferReader} A {@link BufferReader} if `buffer` is a Buffer, otherwise a {@link Reader}
 * @throws {Error} If `buffer` is not a valid buffer
 */
Reader.create = util.Buffer
    ? function create_buffer_setup(buffer) {
        return (Reader.create = function create_buffer(buffer) {
            return util.Buffer.isBuffer(buffer)
                ? new BufferReader(buffer)
                /* istanbul ignore next */
                : create_array(buffer);
        })(buffer);
    }
    /* istanbul ignore next */
    : create_array;

Reader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */ util.Array.prototype.slice;

/**
 * Reads a varint as an unsigned 32 bit value.
 * @function
 * @returns {number} Value read
 */
Reader.prototype.uint32 = (function read_uint32_setup() {
    var value = 4294967295; // optimizer type-hint, tends to deopt otherwise (?!)
    return function read_uint32() {
        value = (         this.buf[this.pos] & 127       ) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) <<  7) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] &  15) << 28) >>> 0; if (this.buf[this.pos++] < 128) return value;

        /* istanbul ignore if */
        if ((this.pos += 5) > this.len) {
            this.pos = this.len;
            throw indexOutOfRange(this, 10);
        }
        return value;
    };
})();

/**
 * Reads a varint as a signed 32 bit value.
 * @returns {number} Value read
 */
Reader.prototype.int32 = function read_int32() {
    return this.uint32() | 0;
};

/**
 * Reads a zig-zag encoded varint as a signed 32 bit value.
 * @returns {number} Value read
 */
Reader.prototype.sint32 = function read_sint32() {
    var value = this.uint32();
    return value >>> 1 ^ -(value & 1) | 0;
};

/* eslint-disable no-invalid-this */

function readLongVarint() {
    // tends to deopt with local vars for octet etc.
    var bits = new LongBits(0, 0);
    var i = 0;
    if (this.len - this.pos > 4) { // fast route (lo)
        for (; i < 4; ++i) {
            // 1st..4th
            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
        // 5th
        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >>  4) >>> 0;
        if (this.buf[this.pos++] < 128)
            return bits;
        i = 0;
    } else {
        for (; i < 3; ++i) {
            /* istanbul ignore if */
            if (this.pos >= this.len)
                throw indexOutOfRange(this);
            // 1st..3th
            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
        // 4th
        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;
        return bits;
    }
    if (this.len - this.pos > 4) { // fast route (hi)
        for (; i < 5; ++i) {
            // 6th..10th
            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
    } else {
        for (; i < 5; ++i) {
            /* istanbul ignore if */
            if (this.pos >= this.len)
                throw indexOutOfRange(this);
            // 6th..10th
            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
    }
    /* istanbul ignore next */
    throw Error("invalid varint encoding");
}

/* eslint-enable no-invalid-this */

/**
 * Reads a varint as a signed 64 bit value.
 * @name Reader#int64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a varint as an unsigned 64 bit value.
 * @name Reader#uint64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a zig-zag encoded varint as a signed 64 bit value.
 * @name Reader#sint64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a varint as a boolean.
 * @returns {boolean} Value read
 */
Reader.prototype.bool = function read_bool() {
    return this.uint32() !== 0;
};

function readFixed32_end(buf, end) { // note that this uses `end`, not `pos`
    return (buf[end - 4]
          | buf[end - 3] << 8
          | buf[end - 2] << 16
          | buf[end - 1] << 24) >>> 0;
}

/**
 * Reads fixed 32 bits as an unsigned 32 bit integer.
 * @returns {number} Value read
 */
Reader.prototype.fixed32 = function read_fixed32() {

    /* istanbul ignore if */
    if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);

    return readFixed32_end(this.buf, this.pos += 4);
};

/**
 * Reads fixed 32 bits as a signed 32 bit integer.
 * @returns {number} Value read
 */
Reader.prototype.sfixed32 = function read_sfixed32() {

    /* istanbul ignore if */
    if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);

    return readFixed32_end(this.buf, this.pos += 4) | 0;
};

/* eslint-disable no-invalid-this */

function readFixed64(/* this: Reader */) {

    /* istanbul ignore if */
    if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 8);

    return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
}

/* eslint-enable no-invalid-this */

/**
 * Reads fixed 64 bits.
 * @name Reader#fixed64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads zig-zag encoded fixed 64 bits.
 * @name Reader#sfixed64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a float (32 bit) as a number.
 * @function
 * @returns {number} Value read
 */
Reader.prototype.float = function read_float() {

    /* istanbul ignore if */
    if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);

    var value = util.float.readFloatLE(this.buf, this.pos);
    this.pos += 4;
    return value;
};

/**
 * Reads a double (64 bit float) as a number.
 * @function
 * @returns {number} Value read
 */
Reader.prototype.double = function read_double() {

    /* istanbul ignore if */
    if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 4);

    var value = util.float.readDoubleLE(this.buf, this.pos);
    this.pos += 8;
    return value;
};

/**
 * Reads a sequence of bytes preceeded by its length as a varint.
 * @returns {Uint8Array} Value read
 */
Reader.prototype.bytes = function read_bytes() {
    var length = this.uint32(),
        start  = this.pos,
        end    = this.pos + length;

    /* istanbul ignore if */
    if (end > this.len)
        throw indexOutOfRange(this, length);

    this.pos += length;
    if (Array.isArray(this.buf)) // plain array
        return this.buf.slice(start, end);
    return start === end // fix for IE 10/Win8 and others' subarray returning array of size 1
        ? new this.buf.constructor(0)
        : this._slice.call(this.buf, start, end);
};

/**
 * Reads a string preceeded by its byte length as a varint.
 * @returns {string} Value read
 */
Reader.prototype.string = function read_string() {
    var bytes = this.bytes();
    return utf8.read(bytes, 0, bytes.length);
};

/**
 * Skips the specified number of bytes if specified, otherwise skips a varint.
 * @param {number} [length] Length if known, otherwise a varint is assumed
 * @returns {Reader} `this`
 */
Reader.prototype.skip = function skip(length) {
    if (typeof length === "number") {
        /* istanbul ignore if */
        if (this.pos + length > this.len)
            throw indexOutOfRange(this, length);
        this.pos += length;
    } else {
        do {
            /* istanbul ignore if */
            if (this.pos >= this.len)
                throw indexOutOfRange(this);
        } while (this.buf[this.pos++] & 128);
    }
    return this;
};

/**
 * Skips the next element of the specified wire type.
 * @param {number} wireType Wire type received
 * @returns {Reader} `this`
 */
Reader.prototype.skipType = function(wireType) {
    switch (wireType) {
        case 0:
            this.skip();
            break;
        case 1:
            this.skip(8);
            break;
        case 2:
            this.skip(this.uint32());
            break;
        case 3:
            do { // eslint-disable-line no-constant-condition
                if ((wireType = this.uint32() & 7) === 4)
                    break;
                this.skipType(wireType);
            } while (true);
            break;
        case 5:
            this.skip(4);
            break;

        /* istanbul ignore next */
        default:
            throw Error("invalid wire type " + wireType + " at offset " + this.pos);
    }
    return this;
};

Reader._configure = function(BufferReader_) {
    BufferReader = BufferReader_;

    var fn = util.Long ? "toLong" : /* istanbul ignore next */ "toNumber";
    util.merge(Reader.prototype, {

        int64: function read_int64() {
            return readLongVarint.call(this)[fn](false);
        },

        uint64: function read_uint64() {
            return readLongVarint.call(this)[fn](true);
        },

        sint64: function read_sint64() {
            return readLongVarint.call(this).zzDecode()[fn](false);
        },

        fixed64: function read_fixed64() {
            return readFixed64.call(this)[fn](true);
        },

        sfixed64: function read_sfixed64() {
            return readFixed64.call(this)[fn](false);
        }

    });
};

},{"39":39}],28:[function(require,module,exports){
"use strict";
module.exports = BufferReader;

// extends Reader
var Reader = require(27);
(BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;

var util = require(39);

/**
 * Constructs a new buffer reader instance.
 * @classdesc Wire format reader using node buffers.
 * @extends Reader
 * @constructor
 * @param {Buffer} buffer Buffer to read from
 */
function BufferReader(buffer) {
    Reader.call(this, buffer);

    /**
     * Read buffer.
     * @name BufferReader#buf
     * @type {Buffer}
     */
}

/* istanbul ignore else */
if (util.Buffer)
    BufferReader.prototype._slice = util.Buffer.prototype.slice;

/**
 * @override
 */
BufferReader.prototype.string = function read_string_buffer() {
    var len = this.uint32(); // modifies pos
    return this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len));
};

/**
 * Reads a sequence of bytes preceeded by its length as a varint.
 * @name BufferReader#bytes
 * @function
 * @returns {Buffer} Value read
 */

},{"27":27,"39":39}],29:[function(require,module,exports){
"use strict";
module.exports = Root;

// extends Namespace
var Namespace = require(23);
((Root.prototype = Object.create(Namespace.prototype)).constructor = Root).className = "Root";

var Field   = require(16),
    Enum    = require(15),
    OneOf   = require(25),
    util    = require(37);

var Type,   // cyclic
    parse,  // might be excluded
    common; // "

/**
 * Constructs a new root namespace instance.
 * @classdesc Root namespace wrapping all types, enums, services, sub-namespaces etc. that belong together.
 * @extends NamespaceBase
 * @constructor
 * @param {Object.<string,*>} [options] Top level options
 */
function Root(options) {
    Namespace.call(this, "", options);

    /**
     * Deferred extension fields.
     * @type {Field[]}
     */
    this.deferred = [];

    /**
     * Resolved file names of loaded files.
     * @type {string[]}
     */
    this.files = [];
}

/**
 * Loads a namespace descriptor into a root namespace.
 * @param {INamespace} json Nameespace descriptor
 * @param {Root} [root] Root namespace, defaults to create a new one if omitted
 * @returns {Root} Root namespace
 */
Root.fromJSON = function fromJSON(json, root) {
    if (!root)
        root = new Root();
    if (json.options)
        root.setOptions(json.options);
    return root.addJSON(json.nested);
};

/**
 * Resolves the path of an imported file, relative to the importing origin.
 * This method exists so you can override it with your own logic in case your imports are scattered over multiple directories.
 * @function
 * @param {string} origin The file name of the importing file
 * @param {string} target The file name being imported
 * @returns {string|null} Resolved path to `target` or `null` to skip the file
 */
Root.prototype.resolvePath = util.path.resolve;

// A symbol-like function to safely signal synchronous loading
/* istanbul ignore next */
function SYNC() {} // eslint-disable-line no-empty-function

/**
 * Loads one or multiple .proto or preprocessed .json files into this root namespace and calls the callback.
 * @param {string|string[]} filename Names of one or multiple files to load
 * @param {IParseOptions} options Parse options
 * @param {LoadCallback} callback Callback function
 * @returns {undefined}
 */
Root.prototype.load = function load(filename, options, callback) {
    if (typeof options === "function") {
        callback = options;
        options = undefined;
    }
    var self = this;
    if (!callback)
        return util.asPromise(load, self, filename, options);

    var sync = callback === SYNC; // undocumented

    // Finishes loading by calling the callback (exactly once)
    function finish(err, root) {
        /* istanbul ignore if */
        if (!callback)
            return;
        var cb = callback;
        callback = null;
        if (sync)
            throw err;
        cb(err, root);
    }

    // Processes a single file
    function process(filename, source) {
        try {
            if (util.isString(source) && source.charAt(0) === "{")
                source = JSON.parse(source);
            if (!util.isString(source))
                self.setOptions(source.options).addJSON(source.nested);
            else {
                parse.filename = filename;
                var parsed = parse(source, self, options),
                    resolved,
                    i = 0;
                if (parsed.imports)
                    for (; i < parsed.imports.length; ++i)
                        if (resolved = self.resolvePath(filename, parsed.imports[i]))
                            fetch(resolved);
                if (parsed.weakImports)
                    for (i = 0; i < parsed.weakImports.length; ++i)
                        if (resolved = self.resolvePath(filename, parsed.weakImports[i]))
                            fetch(resolved, true);
            }
        } catch (err) {
            finish(err);
        }
        if (!sync && !queued)
            finish(null, self); // only once anyway
    }

    // Fetches a single file
    function fetch(filename, weak) {

        // Strip path if this file references a bundled definition
        var idx = filename.lastIndexOf("google/protobuf/");
        if (idx > -1) {
            var altname = filename.substring(idx);
            if (altname in common)
                filename = altname;
        }

        // Skip if already loaded / attempted
        if (self.files.indexOf(filename) > -1)
            return;
        self.files.push(filename);

        // Shortcut bundled definitions
        if (filename in common) {
            if (sync)
                process(filename, common[filename]);
            else {
                ++queued;
                setTimeout(function() {
                    --queued;
                    process(filename, common[filename]);
                });
            }
            return;
        }

        // Otherwise fetch from disk or network
        if (sync) {
            var source;
            try {
                source = util.fs.readFileSync(filename).toString("utf8");
            } catch (err) {
                if (!weak)
                    finish(err);
                return;
            }
            process(filename, source);
        } else {
            ++queued;
            util.fetch(filename, function(err, source) {
                --queued;
                /* istanbul ignore if */
                if (!callback)
                    return; // terminated meanwhile
                if (err) {
                    /* istanbul ignore else */
                    if (!weak)
                        finish(err);
                    else if (!queued) // can't be covered reliably
                        finish(null, self);
                    return;
                }
                process(filename, source);
            });
        }
    }
    var queued = 0;

    // Assembling the root namespace doesn't require working type
    // references anymore, so we can load everything in parallel
    if (util.isString(filename))
        filename = [ filename ];
    for (var i = 0, resolved; i < filename.length; ++i)
        if (resolved = self.resolvePath("", filename[i]))
            fetch(resolved);

    if (sync)
        return self;
    if (!queued)
        finish(null, self);
    return undefined;
};
// function load(filename:string, options:IParseOptions, callback:LoadCallback):undefined

/**
 * Loads one or multiple .proto or preprocessed .json files into this root namespace and calls the callback.
 * @function Root#load
 * @param {string|string[]} filename Names of one or multiple files to load
 * @param {LoadCallback} callback Callback function
 * @returns {undefined}
 * @variation 2
 */
// function load(filename:string, callback:LoadCallback):undefined

/**
 * Loads one or multiple .proto or preprocessed .json files into this root namespace and returns a promise.
 * @function Root#load
 * @param {string|string[]} filename Names of one or multiple files to load
 * @param {IParseOptions} [options] Parse options. Defaults to {@link parse.defaults} when omitted.
 * @returns {Promise<Root>} Promise
 * @variation 3
 */
// function load(filename:string, [options:IParseOptions]):Promise<Root>

/**
 * Synchronously loads one or multiple .proto or preprocessed .json files into this root namespace (node only).
 * @function Root#loadSync
 * @param {string|string[]} filename Names of one or multiple files to load
 * @param {IParseOptions} [options] Parse options. Defaults to {@link parse.defaults} when omitted.
 * @returns {Root} Root namespace
 * @throws {Error} If synchronous fetching is not supported (i.e. in browsers) or if a file's syntax is invalid
 */
Root.prototype.loadSync = function loadSync(filename, options) {
    if (!util.isNode)
        throw Error("not supported");
    return this.load(filename, options, SYNC);
};

/**
 * @override
 */
Root.prototype.resolveAll = function resolveAll() {
    if (this.deferred.length)
        throw Error("unresolvable extensions: " + this.deferred.map(function(field) {
            return "'extend " + field.extend + "' in " + field.parent.fullName;
        }).join(", "));
    return Namespace.prototype.resolveAll.call(this);
};

// only uppercased (and thus conflict-free) children are exposed, see below
var exposeRe = /^[A-Z]/;

/**
 * Handles a deferred declaring extension field by creating a sister field to represent it within its extended type.
 * @param {Root} root Root instance
 * @param {Field} field Declaring extension field witin the declaring type
 * @returns {boolean} `true` if successfully added to the extended type, `false` otherwise
 * @inner
 * @ignore
 */
function tryHandleExtension(root, field) {
    var extendedType = field.parent.lookup(field.extend);
    if (extendedType) {
        var sisterField = new Field(field.fullName, field.id, field.type, field.rule, undefined, field.options);
        sisterField.declaringField = field;
        field.extensionField = sisterField;
        extendedType.add(sisterField);
        return true;
    }
    return false;
}

/**
 * Called when any object is added to this root or its sub-namespaces.
 * @param {ReflectionObject} object Object added
 * @returns {undefined}
 * @private
 */
Root.prototype._handleAdd = function _handleAdd(object) {
    if (object instanceof Field) {

        if (/* an extension field (implies not part of a oneof) */ object.extend !== undefined && /* not already handled */ !object.extensionField)
            if (!tryHandleExtension(this, object))
                this.deferred.push(object);

    } else if (object instanceof Enum) {

        if (exposeRe.test(object.name))
            object.parent[object.name] = object.values; // expose enum values as property of its parent

    } else if (!(object instanceof OneOf)) /* everything else is a namespace */ {

        if (object instanceof Type) // Try to handle any deferred extensions
            for (var i = 0; i < this.deferred.length;)
                if (tryHandleExtension(this, this.deferred[i]))
                    this.deferred.splice(i, 1);
                else
                    ++i;
        for (var j = 0; j < /* initializes */ object.nestedArray.length; ++j) // recurse into the namespace
            this._handleAdd(object._nestedArray[j]);
        if (exposeRe.test(object.name))
            object.parent[object.name] = object; // expose namespace as property of its parent
    }

    // The above also adds uppercased (and thus conflict-free) nested types, services and enums as
    // properties of namespaces just like static code does. This allows using a .d.ts generated for
    // a static module with reflection-based solutions where the condition is met.
};

/**
 * Called when any object is removed from this root or its sub-namespaces.
 * @param {ReflectionObject} object Object removed
 * @returns {undefined}
 * @private
 */
Root.prototype._handleRemove = function _handleRemove(object) {
    if (object instanceof Field) {

        if (/* an extension field */ object.extend !== undefined) {
            if (/* already handled */ object.extensionField) { // remove its sister field
                object.extensionField.parent.remove(object.extensionField);
                object.extensionField = null;
            } else { // cancel the extension
                var index = this.deferred.indexOf(object);
                /* istanbul ignore else */
                if (index > -1)
                    this.deferred.splice(index, 1);
            }
        }

    } else if (object instanceof Enum) {

        if (exposeRe.test(object.name))
            delete object.parent[object.name]; // unexpose enum values

    } else if (object instanceof Namespace) {

        for (var i = 0; i < /* initializes */ object.nestedArray.length; ++i) // recurse into the namespace
            this._handleRemove(object._nestedArray[i]);

        if (exposeRe.test(object.name))
            delete object.parent[object.name]; // unexpose namespaces

    }
};

Root._configure = function(Type_, parse_, common_) {
    Type = Type_;
    parse = parse_;
    common = common_;
};

},{"15":15,"16":16,"23":23,"25":25,"37":37}],30:[function(require,module,exports){
"use strict";
module.exports = {};

/**
 * Named roots.
 * This is where pbjs stores generated structures (the option `-r, --root` specifies a name).
 * Can also be used manually to make roots available accross modules.
 * @name roots
 * @type {Object.<string,Root>}
 * @example
 * // pbjs -r myroot -o compiled.js ...
 *
 * // in another module:
 * require("./compiled.js");
 *
 * // in any subsequent module:
 * var root = protobuf.roots["myroot"];
 */

},{}],31:[function(require,module,exports){
"use strict";

/**
 * Streaming RPC helpers.
 * @namespace
 */
var rpc = exports;

/**
 * RPC implementation passed to {@link Service#create} performing a service request on network level, i.e. by utilizing http requests or websockets.
 * @typedef RPCImpl
 * @type {function}
 * @param {Method|rpc.ServiceMethod<Message<{}>,Message<{}>>} method Reflected or static method being called
 * @param {Uint8Array} requestData Request data
 * @param {RPCImplCallback} callback Callback function
 * @returns {undefined}
 * @example
 * function rpcImpl(method, requestData, callback) {
 *     if (protobuf.util.lcFirst(method.name) !== "myMethod") // compatible with static code
 *         throw Error("no such method");
 *     asynchronouslyObtainAResponse(requestData, function(err, responseData) {
 *         callback(err, responseData);
 *     });
 * }
 */

/**
 * Node-style callback as used by {@link RPCImpl}.
 * @typedef RPCImplCallback
 * @type {function}
 * @param {Error|null} error Error, if any, otherwise `null`
 * @param {Uint8Array|null} [response] Response data or `null` to signal end of stream, if there hasn't been an error
 * @returns {undefined}
 */

rpc.Service = require(32);

},{"32":32}],32:[function(require,module,exports){
"use strict";
module.exports = Service;

var util = require(39);

// Extends EventEmitter
(Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;

/**
 * A service method callback as used by {@link rpc.ServiceMethod|ServiceMethod}.
 *
 * Differs from {@link RPCImplCallback} in that it is an actual callback of a service method which may not return `response = null`.
 * @typedef rpc.ServiceMethodCallback
 * @template TRes extends Message<TRes>
 * @type {function}
 * @param {Error|null} error Error, if any
 * @param {TRes} [response] Response message
 * @returns {undefined}
 */

/**
 * A service method part of a {@link rpc.Service} as created by {@link Service.create}.
 * @typedef rpc.ServiceMethod
 * @template TReq extends Message<TReq>
 * @template TRes extends Message<TRes>
 * @type {function}
 * @param {TReq|Properties<TReq>} request Request message or plain object
 * @param {rpc.ServiceMethodCallback<TRes>} [callback] Node-style callback called with the error, if any, and the response message
 * @returns {Promise<Message<TRes>>} Promise if `callback` has been omitted, otherwise `undefined`
 */

/**
 * Constructs a new RPC service instance.
 * @classdesc An RPC service as returned by {@link Service#create}.
 * @exports rpc.Service
 * @extends util.EventEmitter
 * @constructor
 * @param {RPCImpl} rpcImpl RPC implementation
 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
 */
function Service(rpcImpl, requestDelimited, responseDelimited) {

    if (typeof rpcImpl !== "function")
        throw TypeError("rpcImpl must be a function");

    util.EventEmitter.call(this);

    /**
     * RPC implementation. Becomes `null` once the service is ended.
     * @type {RPCImpl|null}
     */
    this.rpcImpl = rpcImpl;

    /**
     * Whether requests are length-delimited.
     * @type {boolean}
     */
    this.requestDelimited = Boolean(requestDelimited);

    /**
     * Whether responses are length-delimited.
     * @type {boolean}
     */
    this.responseDelimited = Boolean(responseDelimited);
}

/**
 * Calls a service method through {@link rpc.Service#rpcImpl|rpcImpl}.
 * @param {Method|rpc.ServiceMethod<TReq,TRes>} method Reflected or static method
 * @param {Constructor<TReq>} requestCtor Request constructor
 * @param {Constructor<TRes>} responseCtor Response constructor
 * @param {TReq|Properties<TReq>} request Request message or plain object
 * @param {rpc.ServiceMethodCallback<TRes>} callback Service callback
 * @returns {undefined}
 * @template TReq extends Message<TReq>
 * @template TRes extends Message<TRes>
 */
Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {

    if (!request)
        throw TypeError("request must be specified");

    var self = this;
    if (!callback)
        return util.asPromise(rpcCall, self, method, requestCtor, responseCtor, request);

    if (!self.rpcImpl) {
        setTimeout(function() { callback(Error("already ended")); }, 0);
        return undefined;
    }

    try {
        return self.rpcImpl(
            method,
            requestCtor[self.requestDelimited ? "encodeDelimited" : "encode"](request).finish(),
            function rpcCallback(err, response) {

                if (err) {
                    self.emit("error", err, method);
                    return callback(err);
                }

                if (response === null) {
                    self.end(/* endedByRPC */ true);
                    return undefined;
                }

                if (!(response instanceof responseCtor)) {
                    try {
                        response = responseCtor[self.responseDelimited ? "decodeDelimited" : "decode"](response);
                    } catch (err) {
                        self.emit("error", err, method);
                        return callback(err);
                    }
                }

                self.emit("data", response, method);
                return callback(null, response);
            }
        );
    } catch (err) {
        self.emit("error", err, method);
        setTimeout(function() { callback(err); }, 0);
        return undefined;
    }
};

/**
 * Ends this service and emits the `end` event.
 * @param {boolean} [endedByRPC=false] Whether the service has been ended by the RPC implementation.
 * @returns {rpc.Service} `this`
 */
Service.prototype.end = function end(endedByRPC) {
    if (this.rpcImpl) {
        if (!endedByRPC) // signal end to rpcImpl
            this.rpcImpl(null, null, null);
        this.rpcImpl = null;
        this.emit("end").off();
    }
    return this;
};

},{"39":39}],33:[function(require,module,exports){
"use strict";
module.exports = Service;

// extends Namespace
var Namespace = require(23);
((Service.prototype = Object.create(Namespace.prototype)).constructor = Service).className = "Service";

var Method = require(22),
    util   = require(37),
    rpc    = require(31);

/**
 * Constructs a new service instance.
 * @classdesc Reflected service.
 * @extends NamespaceBase
 * @constructor
 * @param {string} name Service name
 * @param {Object.<string,*>} [options] Service options
 * @throws {TypeError} If arguments are invalid
 */
function Service(name, options) {
    Namespace.call(this, name, options);

    /**
     * Service methods.
     * @type {Object.<string,Method>}
     */
    this.methods = {}; // toJSON, marker

    /**
     * Cached methods as an array.
     * @type {Method[]|null}
     * @private
     */
    this._methodsArray = null;
}

/**
 * Service descriptor.
 * @interface IService
 * @extends INamespace
 * @property {Object.<string,IMethod>} methods Method descriptors
 */

/**
 * Constructs a service from a service descriptor.
 * @param {string} name Service name
 * @param {IService} json Service descriptor
 * @returns {Service} Created service
 * @throws {TypeError} If arguments are invalid
 */
Service.fromJSON = function fromJSON(name, json) {
    var service = new Service(name, json.options);
    /* istanbul ignore else */
    if (json.methods)
        for (var names = Object.keys(json.methods), i = 0; i < names.length; ++i)
            service.add(Method.fromJSON(names[i], json.methods[names[i]]));
    if (json.nested)
        service.addJSON(json.nested);
    service.comment = json.comment;
    return service;
};

/**
 * Converts this service to a service descriptor.
 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
 * @returns {IService} Service descriptor
 */
Service.prototype.toJSON = function toJSON(toJSONOptions) {
    var inherited = Namespace.prototype.toJSON.call(this, toJSONOptions);
    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
    return util.toObject([
        "options" , inherited && inherited.options || undefined,
        "methods" , Namespace.arrayToJSON(this.methodsArray, toJSONOptions) || /* istanbul ignore next */ {},
        "nested"  , inherited && inherited.nested || undefined,
        "comment" , keepComments ? this.comment : undefined
    ]);
};

/**
 * Methods of this service as an array for iteration.
 * @name Service#methodsArray
 * @type {Method[]}
 * @readonly
 */
Object.defineProperty(Service.prototype, "methodsArray", {
    get: function() {
        return this._methodsArray || (this._methodsArray = util.toArray(this.methods));
    }
});

function clearCache(service) {
    service._methodsArray = null;
    return service;
}

/**
 * @override
 */
Service.prototype.get = function get(name) {
    return this.methods[name]
        || Namespace.prototype.get.call(this, name);
};

/**
 * @override
 */
Service.prototype.resolveAll = function resolveAll() {
    var methods = this.methodsArray;
    for (var i = 0; i < methods.length; ++i)
        methods[i].resolve();
    return Namespace.prototype.resolve.call(this);
};

/**
 * @override
 */
Service.prototype.add = function add(object) {

    /* istanbul ignore if */
    if (this.get(object.name))
        throw Error("duplicate name '" + object.name + "' in " + this);

    if (object instanceof Method) {
        this.methods[object.name] = object;
        object.parent = this;
        return clearCache(this);
    }
    return Namespace.prototype.add.call(this, object);
};

/**
 * @override
 */
Service.prototype.remove = function remove(object) {
    if (object instanceof Method) {

        /* istanbul ignore if */
        if (this.methods[object.name] !== object)
            throw Error(object + " is not a member of " + this);

        delete this.methods[object.name];
        object.parent = null;
        return clearCache(this);
    }
    return Namespace.prototype.remove.call(this, object);
};

/**
 * Creates a runtime service using the specified rpc implementation.
 * @param {RPCImpl} rpcImpl RPC implementation
 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
 * @returns {rpc.Service} RPC service. Useful where requests and/or responses are streamed.
 */
Service.prototype.create = function create(rpcImpl, requestDelimited, responseDelimited) {
    var rpcService = new rpc.Service(rpcImpl, requestDelimited, responseDelimited);
    for (var i = 0, method; i < /* initializes */ this.methodsArray.length; ++i) {
        var methodName = util.lcFirst((method = this._methodsArray[i]).resolve().name).replace(/[^$\w_]/g, "");
        rpcService[methodName] = util.codegen(["r","c"], util.isReserved(methodName) ? methodName + "_" : methodName)("return this.rpcCall(m,q,s,r,c)")({
            m: method,
            q: method.resolvedRequestType.ctor,
            s: method.resolvedResponseType.ctor
        });
    }
    return rpcService;
};

},{"22":22,"23":23,"31":31,"37":37}],34:[function(require,module,exports){
"use strict";
module.exports = tokenize;

var delimRe        = /[\s{}=;:[\],'"()<>]/g,
    stringDoubleRe = /(?:"([^"\\]*(?:\\.[^"\\]*)*)")/g,
    stringSingleRe = /(?:'([^'\\]*(?:\\.[^'\\]*)*)')/g;

var setCommentRe = /^ *[*/]+ */,
    setCommentAltRe = /^\s*\*?\/*/,
    setCommentSplitRe = /\n/g,
    whitespaceRe = /\s/,
    unescapeRe = /\\(.?)/g;

var unescapeMap = {
    "0": "\0",
    "r": "\r",
    "n": "\n",
    "t": "\t"
};

/**
 * Unescapes a string.
 * @param {string} str String to unescape
 * @returns {string} Unescaped string
 * @property {Object.<string,string>} map Special characters map
 * @memberof tokenize
 */
function unescape(str) {
    return str.replace(unescapeRe, function($0, $1) {
        switch ($1) {
            case "\\":
            case "":
                return $1;
            default:
                return unescapeMap[$1] || "";
        }
    });
}

tokenize.unescape = unescape;

/**
 * Gets the next token and advances.
 * @typedef TokenizerHandleNext
 * @type {function}
 * @returns {string|null} Next token or `null` on eof
 */

/**
 * Peeks for the next token.
 * @typedef TokenizerHandlePeek
 * @type {function}
 * @returns {string|null} Next token or `null` on eof
 */

/**
 * Pushes a token back to the stack.
 * @typedef TokenizerHandlePush
 * @type {function}
 * @param {string} token Token
 * @returns {undefined}
 */

/**
 * Skips the next token.
 * @typedef TokenizerHandleSkip
 * @type {function}
 * @param {string} expected Expected token
 * @param {boolean} [optional=false] If optional
 * @returns {boolean} Whether the token matched
 * @throws {Error} If the token didn't match and is not optional
 */

/**
 * Gets the comment on the previous line or, alternatively, the line comment on the specified line.
 * @typedef TokenizerHandleCmnt
 * @type {function}
 * @param {number} [line] Line number
 * @returns {string|null} Comment text or `null` if none
 */

/**
 * Handle object returned from {@link tokenize}.
 * @interface ITokenizerHandle
 * @property {TokenizerHandleNext} next Gets the next token and advances (`null` on eof)
 * @property {TokenizerHandlePeek} peek Peeks for the next token (`null` on eof)
 * @property {TokenizerHandlePush} push Pushes a token back to the stack
 * @property {TokenizerHandleSkip} skip Skips a token, returns its presence and advances or, if non-optional and not present, throws
 * @property {TokenizerHandleCmnt} cmnt Gets the comment on the previous line or the line comment on the specified line, if any
 * @property {number} line Current line number
 */

/**
 * Tokenizes the given .proto source and returns an object with useful utility functions.
 * @param {string} source Source contents
 * @param {boolean} alternateCommentMode Whether we should activate alternate comment parsing mode.
 * @returns {ITokenizerHandle} Tokenizer handle
 */
function tokenize(source, alternateCommentMode) {
    /* eslint-disable callback-return */
    source = source.toString();

    var offset = 0,
        length = source.length,
        line = 1,
        commentType = null,
        commentText = null,
        commentLine = 0,
        commentLineEmpty = false;

    var stack = [];

    var stringDelim = null;

    /* istanbul ignore next */
    /**
     * Creates an error for illegal syntax.
     * @param {string} subject Subject
     * @returns {Error} Error created
     * @inner
     */
    function illegal(subject) {
        return Error("illegal " + subject + " (line " + line + ")");
    }

    /**
     * Reads a string till its end.
     * @returns {string} String read
     * @inner
     */
    function readString() {
        var re = stringDelim === "'" ? stringSingleRe : stringDoubleRe;
        re.lastIndex = offset - 1;
        var match = re.exec(source);
        if (!match)
            throw illegal("string");
        offset = re.lastIndex;
        push(stringDelim);
        stringDelim = null;
        return unescape(match[1]);
    }

    /**
     * Gets the character at `pos` within the source.
     * @param {number} pos Position
     * @returns {string} Character
     * @inner
     */
    function charAt(pos) {
        return source.charAt(pos);
    }

    /**
     * Sets the current comment text.
     * @param {number} start Start offset
     * @param {number} end End offset
     * @returns {undefined}
     * @inner
     */
    function setComment(start, end) {
        commentType = source.charAt(start++);
        commentLine = line;
        commentLineEmpty = false;
        var lookback;
        if (alternateCommentMode) {
            lookback = 2;  // alternate comment parsing: "//" or "/*"
        } else {
            lookback = 3;  // "///" or "/**"
        }
        var commentOffset = start - lookback,
            c;
        do {
            if (--commentOffset < 0 ||
                    (c = source.charAt(commentOffset)) === "\n") {
                commentLineEmpty = true;
                break;
            }
        } while (c === " " || c === "\t");
        var lines = source
            .substring(start, end)
            .split(setCommentSplitRe);
        for (var i = 0; i < lines.length; ++i)
            lines[i] = lines[i]
                .replace(alternateCommentMode ? setCommentAltRe : setCommentRe, "")
                .trim();
        commentText = lines
            .join("\n")
            .trim();
    }

    function isDoubleSlashCommentLine(startOffset) {
        var endOffset = findEndOfLine(startOffset);

        // see if remaining line matches comment pattern
        var lineText = source.substring(startOffset, endOffset);
        // look for 1 or 2 slashes since startOffset would already point past
        // the first slash that started the comment.
        var isComment = /^\s*\/{1,2}/.test(lineText);
        return isComment;
    }

    function findEndOfLine(cursor) {
        // find end of cursor's line
        var endOffset = cursor;
        while (endOffset < length && charAt(endOffset) !== "\n") {
            endOffset++;
        }
        return endOffset;
    }

    /**
     * Obtains the next token.
     * @returns {string|null} Next token or `null` on eof
     * @inner
     */
    function next() {
        if (stack.length > 0)
            return stack.shift();
        if (stringDelim)
            return readString();
        var repeat,
            prev,
            curr,
            start,
            isDoc;
        do {
            if (offset === length)
                return null;
            repeat = false;
            while (whitespaceRe.test(curr = charAt(offset))) {
                if (curr === "\n")
                    ++line;
                if (++offset === length)
                    return null;
            }

            if (charAt(offset) === "/") {
                if (++offset === length) {
                    throw illegal("comment");
                }
                if (charAt(offset) === "/") { // Line
                    if (!alternateCommentMode) {
                        // check for triple-slash comment
                        isDoc = charAt(start = offset + 1) === "/";

                        while (charAt(++offset) !== "\n") {
                            if (offset === length) {
                                return null;
                            }
                        }
                        ++offset;
                        if (isDoc) {
                            setComment(start, offset - 1);
                        }
                        ++line;
                        repeat = true;
                    } else {
                        // check for double-slash comments, consolidating consecutive lines
                        start = offset;
                        isDoc = false;
                        if (isDoubleSlashCommentLine(offset)) {
                            isDoc = true;
                            do {
                                offset = findEndOfLine(offset);
                                if (offset === length) {
                                    break;
                                }
                                offset++;
                            } while (isDoubleSlashCommentLine(offset));
                        } else {
                            offset = Math.min(length, findEndOfLine(offset) + 1);
                        }
                        if (isDoc) {
                            setComment(start, offset);
                        }
                        line++;
                        repeat = true;
                    }
                } else if ((curr = charAt(offset)) === "*") { /* Block */
                    // check for /** (regular comment mode) or /* (alternate comment mode)
                    start = offset + 1;
                    isDoc = alternateCommentMode || charAt(start) === "*";
                    do {
                        if (curr === "\n") {
                            ++line;
                        }
                        if (++offset === length) {
                            throw illegal("comment");
                        }
                        prev = curr;
                        curr = charAt(offset);
                    } while (prev !== "*" || curr !== "/");
                    ++offset;
                    if (isDoc) {
                        setComment(start, offset - 2);
                    }
                    repeat = true;
                } else {
                    return "/";
                }
            }
        } while (repeat);

        // offset !== length if we got here

        var end = offset;
        delimRe.lastIndex = 0;
        var delim = delimRe.test(charAt(end++));
        if (!delim)
            while (end < length && !delimRe.test(charAt(end)))
                ++end;
        var token = source.substring(offset, offset = end);
        if (token === "\"" || token === "'")
            stringDelim = token;
        return token;
    }

    /**
     * Pushes a token back to the stack.
     * @param {string} token Token
     * @returns {undefined}
     * @inner
     */
    function push(token) {
        stack.push(token);
    }

    /**
     * Peeks for the next token.
     * @returns {string|null} Token or `null` on eof
     * @inner
     */
    function peek() {
        if (!stack.length) {
            var token = next();
            if (token === null)
                return null;
            push(token);
        }
        return stack[0];
    }

    /**
     * Skips a token.
     * @param {string} expected Expected token
     * @param {boolean} [optional=false] Whether the token is optional
     * @returns {boolean} `true` when skipped, `false` if not
     * @throws {Error} When a required token is not present
     * @inner
     */
    function skip(expected, optional) {
        var actual = peek(),
            equals = actual === expected;
        if (equals) {
            next();
            return true;
        }
        if (!optional)
            throw illegal("token '" + actual + "', '" + expected + "' expected");
        return false;
    }

    /**
     * Gets a comment.
     * @param {number} [trailingLine] Line number if looking for a trailing comment
     * @returns {string|null} Comment text
     * @inner
     */
    function cmnt(trailingLine) {
        var ret = null;
        if (trailingLine === undefined) {
            if (commentLine === line - 1 && (alternateCommentMode || commentType === "*" || commentLineEmpty)) {
                ret = commentText;
            }
        } else {
            /* istanbul ignore else */
            if (commentLine < trailingLine) {
                peek();
            }
            if (commentLine === trailingLine && !commentLineEmpty && (alternateCommentMode || commentType === "/")) {
                ret = commentText;
            }
        }
        return ret;
    }

    return Object.defineProperty({
        next: next,
        peek: peek,
        push: push,
        skip: skip,
        cmnt: cmnt
    }, "line", {
        get: function() { return line; }
    });
    /* eslint-enable callback-return */
}

},{}],35:[function(require,module,exports){
"use strict";
module.exports = Type;

// extends Namespace
var Namespace = require(23);
((Type.prototype = Object.create(Namespace.prototype)).constructor = Type).className = "Type";

var Enum      = require(15),
    OneOf     = require(25),
    Field     = require(16),
    MapField  = require(20),
    Service   = require(33),
    Message   = require(21),
    Reader    = require(27),
    Writer    = require(42),
    util      = require(37),
    encoder   = require(14),
    decoder   = require(13),
    verifier  = require(40),
    converter = require(12),
    wrappers  = require(41);

/**
 * Constructs a new reflected message type instance.
 * @classdesc Reflected message type.
 * @extends NamespaceBase
 * @constructor
 * @param {string} name Message name
 * @param {Object.<string,*>} [options] Declared options
 */
function Type(name, options) {
    Namespace.call(this, name, options);

    /**
     * Message fields.
     * @type {Object.<string,Field>}
     */
    this.fields = {};  // toJSON, marker

    /**
     * Oneofs declared within this namespace, if any.
     * @type {Object.<string,OneOf>}
     */
    this.oneofs = undefined; // toJSON

    /**
     * Extension ranges, if any.
     * @type {number[][]}
     */
    this.extensions = undefined; // toJSON

    /**
     * Reserved ranges, if any.
     * @type {Array.<number[]|string>}
     */
    this.reserved = undefined; // toJSON

    /*?
     * Whether this type is a legacy group.
     * @type {boolean|undefined}
     */
    this.group = undefined; // toJSON

    /**
     * Cached fields by id.
     * @type {Object.<number,Field>|null}
     * @private
     */
    this._fieldsById = null;

    /**
     * Cached fields as an array.
     * @type {Field[]|null}
     * @private
     */
    this._fieldsArray = null;

    /**
     * Cached oneofs as an array.
     * @type {OneOf[]|null}
     * @private
     */
    this._oneofsArray = null;

    /**
     * Cached constructor.
     * @type {Constructor<{}>}
     * @private
     */
    this._ctor = null;
}

Object.defineProperties(Type.prototype, {

    /**
     * Message fields by id.
     * @name Type#fieldsById
     * @type {Object.<number,Field>}
     * @readonly
     */
    fieldsById: {
        get: function() {

            /* istanbul ignore if */
            if (this._fieldsById)
                return this._fieldsById;

            this._fieldsById = {};
            for (var names = Object.keys(this.fields), i = 0; i < names.length; ++i) {
                var field = this.fields[names[i]],
                    id = field.id;

                /* istanbul ignore if */
                if (this._fieldsById[id])
                    throw Error("duplicate id " + id + " in " + this);

                this._fieldsById[id] = field;
            }
            return this._fieldsById;
        }
    },

    /**
     * Fields of this message as an array for iteration.
     * @name Type#fieldsArray
     * @type {Field[]}
     * @readonly
     */
    fieldsArray: {
        get: function() {
            return this._fieldsArray || (this._fieldsArray = util.toArray(this.fields));
        }
    },

    /**
     * Oneofs of this message as an array for iteration.
     * @name Type#oneofsArray
     * @type {OneOf[]}
     * @readonly
     */
    oneofsArray: {
        get: function() {
            return this._oneofsArray || (this._oneofsArray = util.toArray(this.oneofs));
        }
    },

    /**
     * The registered constructor, if any registered, otherwise a generic constructor.
     * Assigning a function replaces the internal constructor. If the function does not extend {@link Message} yet, its prototype will be setup accordingly and static methods will be populated. If it already extends {@link Message}, it will just replace the internal constructor.
     * @name Type#ctor
     * @type {Constructor<{}>}
     */
    ctor: {
        get: function() {
            return this._ctor || (this.ctor = Type.generateConstructor(this)());
        },
        set: function(ctor) {

            // Ensure proper prototype
            var prototype = ctor.prototype;
            if (!(prototype instanceof Message)) {
                (ctor.prototype = new Message()).constructor = ctor;
                util.merge(ctor.prototype, prototype);
            }

            // Classes and messages reference their reflected type
            ctor.$type = ctor.prototype.$type = this;

            // Mix in static methods
            util.merge(ctor, Message, true);

            this._ctor = ctor;

            // Messages have non-enumerable default values on their prototype
            var i = 0;
            for (; i < /* initializes */ this.fieldsArray.length; ++i)
                this._fieldsArray[i].resolve(); // ensures a proper value

            // Messages have non-enumerable getters and setters for each virtual oneof field
            var ctorProperties = {};
            for (i = 0; i < /* initializes */ this.oneofsArray.length; ++i)
                ctorProperties[this._oneofsArray[i].resolve().name] = {
                    get: util.oneOfGetter(this._oneofsArray[i].oneof),
                    set: util.oneOfSetter(this._oneofsArray[i].oneof)
                };
            if (i)
                Object.defineProperties(ctor.prototype, ctorProperties);
        }
    }
});

/**
 * Generates a constructor function for the specified type.
 * @param {Type} mtype Message type
 * @returns {Codegen} Codegen instance
 */
Type.generateConstructor = function generateConstructor(mtype) {
    /* eslint-disable no-unexpected-multiline */
    var gen = util.codegen(["p"], mtype.name);
    // explicitly initialize mutable object/array fields so that these aren't just inherited from the prototype
    for (var i = 0, field; i < mtype.fieldsArray.length; ++i)
        if ((field = mtype._fieldsArray[i]).map) gen
            ("this%s={}", util.safeProp(field.name));
        else if (field.repeated) gen
            ("this%s=[]", util.safeProp(field.name));
    return gen
    ("if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)") // omit undefined or null
        ("this[ks[i]]=p[ks[i]]");
    /* eslint-enable no-unexpected-multiline */
};

function clearCache(type) {
    type._fieldsById = type._fieldsArray = type._oneofsArray = null;
    delete type.encode;
    delete type.decode;
    delete type.verify;
    return type;
}

/**
 * Message type descriptor.
 * @interface IType
 * @extends INamespace
 * @property {Object.<string,IOneOf>} [oneofs] Oneof descriptors
 * @property {Object.<string,IField>} fields Field descriptors
 * @property {number[][]} [extensions] Extension ranges
 * @property {number[][]} [reserved] Reserved ranges
 * @property {boolean} [group=false] Whether a legacy group or not
 */

/**
 * Creates a message type from a message type descriptor.
 * @param {string} name Message name
 * @param {IType} json Message type descriptor
 * @returns {Type} Created message type
 */
Type.fromJSON = function fromJSON(name, json) {
    var type = new Type(name, json.options);
    type.extensions = json.extensions;
    type.reserved = json.reserved;
    var names = Object.keys(json.fields),
        i = 0;
    for (; i < names.length; ++i)
        type.add(
            ( typeof json.fields[names[i]].keyType !== "undefined"
            ? MapField.fromJSON
            : Field.fromJSON )(names[i], json.fields[names[i]])
        );
    if (json.oneofs)
        for (names = Object.keys(json.oneofs), i = 0; i < names.length; ++i)
            type.add(OneOf.fromJSON(names[i], json.oneofs[names[i]]));
    if (json.nested)
        for (names = Object.keys(json.nested), i = 0; i < names.length; ++i) {
            var nested = json.nested[names[i]];
            type.add( // most to least likely
                ( nested.id !== undefined
                ? Field.fromJSON
                : nested.fields !== undefined
                ? Type.fromJSON
                : nested.values !== undefined
                ? Enum.fromJSON
                : nested.methods !== undefined
                ? Service.fromJSON
                : Namespace.fromJSON )(names[i], nested)
            );
        }
    if (json.extensions && json.extensions.length)
        type.extensions = json.extensions;
    if (json.reserved && json.reserved.length)
        type.reserved = json.reserved;
    if (json.group)
        type.group = true;
    if (json.comment)
        type.comment = json.comment;
    return type;
};

/**
 * Converts this message type to a message type descriptor.
 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
 * @returns {IType} Message type descriptor
 */
Type.prototype.toJSON = function toJSON(toJSONOptions) {
    var inherited = Namespace.prototype.toJSON.call(this, toJSONOptions);
    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
    return util.toObject([
        "options"    , inherited && inherited.options || undefined,
        "oneofs"     , Namespace.arrayToJSON(this.oneofsArray, toJSONOptions),
        "fields"     , Namespace.arrayToJSON(this.fieldsArray.filter(function(obj) { return !obj.declaringField; }), toJSONOptions) || {},
        "extensions" , this.extensions && this.extensions.length ? this.extensions : undefined,
        "reserved"   , this.reserved && this.reserved.length ? this.reserved : undefined,
        "group"      , this.group || undefined,
        "nested"     , inherited && inherited.nested || undefined,
        "comment"    , keepComments ? this.comment : undefined
    ]);
};

/**
 * @override
 */
Type.prototype.resolveAll = function resolveAll() {
    var fields = this.fieldsArray, i = 0;
    while (i < fields.length)
        fields[i++].resolve();
    var oneofs = this.oneofsArray; i = 0;
    while (i < oneofs.length)
        oneofs[i++].resolve();
    return Namespace.prototype.resolveAll.call(this);
};

/**
 * @override
 */
Type.prototype.get = function get(name) {
    return this.fields[name]
        || this.oneofs && this.oneofs[name]
        || this.nested && this.nested[name]
        || null;
};

/**
 * Adds a nested object to this type.
 * @param {ReflectionObject} object Nested object to add
 * @returns {Type} `this`
 * @throws {TypeError} If arguments are invalid
 * @throws {Error} If there is already a nested object with this name or, if a field, when there is already a field with this id
 */
Type.prototype.add = function add(object) {

    if (this.get(object.name))
        throw Error("duplicate name '" + object.name + "' in " + this);

    if (object instanceof Field && object.extend === undefined) {
        // NOTE: Extension fields aren't actual fields on the declaring type, but nested objects.
        // The root object takes care of adding distinct sister-fields to the respective extended
        // type instead.

        // avoids calling the getter if not absolutely necessary because it's called quite frequently
        if (this._fieldsById ? /* istanbul ignore next */ this._fieldsById[object.id] : this.fieldsById[object.id])
            throw Error("duplicate id " + object.id + " in " + this);
        if (this.isReservedId(object.id))
            throw Error("id " + object.id + " is reserved in " + this);
        if (this.isReservedName(object.name))
            throw Error("name '" + object.name + "' is reserved in " + this);

        if (object.parent)
            object.parent.remove(object);
        this.fields[object.name] = object;
        object.message = this;
        object.onAdd(this);
        return clearCache(this);
    }
    if (object instanceof OneOf) {
        if (!this.oneofs)
            this.oneofs = {};
        this.oneofs[object.name] = object;
        object.onAdd(this);
        return clearCache(this);
    }
    return Namespace.prototype.add.call(this, object);
};

/**
 * Removes a nested object from this type.
 * @param {ReflectionObject} object Nested object to remove
 * @returns {Type} `this`
 * @throws {TypeError} If arguments are invalid
 * @throws {Error} If `object` is not a member of this type
 */
Type.prototype.remove = function remove(object) {
    if (object instanceof Field && object.extend === undefined) {
        // See Type#add for the reason why extension fields are excluded here.

        /* istanbul ignore if */
        if (!this.fields || this.fields[object.name] !== object)
            throw Error(object + " is not a member of " + this);

        delete this.fields[object.name];
        object.parent = null;
        object.onRemove(this);
        return clearCache(this);
    }
    if (object instanceof OneOf) {

        /* istanbul ignore if */
        if (!this.oneofs || this.oneofs[object.name] !== object)
            throw Error(object + " is not a member of " + this);

        delete this.oneofs[object.name];
        object.parent = null;
        object.onRemove(this);
        return clearCache(this);
    }
    return Namespace.prototype.remove.call(this, object);
};

/**
 * Tests if the specified id is reserved.
 * @param {number} id Id to test
 * @returns {boolean} `true` if reserved, otherwise `false`
 */
Type.prototype.isReservedId = function isReservedId(id) {
    return Namespace.isReservedId(this.reserved, id);
};

/**
 * Tests if the specified name is reserved.
 * @param {string} name Name to test
 * @returns {boolean} `true` if reserved, otherwise `false`
 */
Type.prototype.isReservedName = function isReservedName(name) {
    return Namespace.isReservedName(this.reserved, name);
};

/**
 * Creates a new message of this type using the specified properties.
 * @param {Object.<string,*>} [properties] Properties to set
 * @returns {Message<{}>} Message instance
 */
Type.prototype.create = function create(properties) {
    return new this.ctor(properties);
};

/**
 * Sets up {@link Type#encode|encode}, {@link Type#decode|decode} and {@link Type#verify|verify}.
 * @returns {Type} `this`
 */
Type.prototype.setup = function setup() {
    // Sets up everything at once so that the prototype chain does not have to be re-evaluated
    // multiple times (V8, soft-deopt prototype-check).

    var fullName = this.fullName,
        types    = [];
    for (var i = 0; i < /* initializes */ this.fieldsArray.length; ++i)
        types.push(this._fieldsArray[i].resolve().resolvedType);

    // Replace setup methods with type-specific generated functions
    this.encode = encoder(this)({
        Writer : Writer,
        types  : types,
        util   : util
    });
    this.decode = decoder(this)({
        Reader : Reader,
        types  : types,
        util   : util
    });
    this.verify = verifier(this)({
        types : types,
        util  : util
    });
    this.fromObject = converter.fromObject(this)({
        types : types,
        util  : util
    });
    this.toObject = converter.toObject(this)({
        types : types,
        util  : util
    });

    // Inject custom wrappers for common types
    var wrapper = wrappers[fullName];
    if (wrapper) {
        var originalThis = Object.create(this);
        // if (wrapper.fromObject) {
            originalThis.fromObject = this.fromObject;
            this.fromObject = wrapper.fromObject.bind(originalThis);
        // }
        // if (wrapper.toObject) {
            originalThis.toObject = this.toObject;
            this.toObject = wrapper.toObject.bind(originalThis);
        // }
    }

    return this;
};

/**
 * Encodes a message of this type. Does not implicitly {@link Type#verify|verify} messages.
 * @param {Message<{}>|Object.<string,*>} message Message instance or plain object
 * @param {Writer} [writer] Writer to encode to
 * @returns {Writer} writer
 */
Type.prototype.encode = function encode_setup(message, writer) {
    return this.setup().encode(message, writer); // overrides this method
};

/**
 * Encodes a message of this type preceeded by its byte length as a varint. Does not implicitly {@link Type#verify|verify} messages.
 * @param {Message<{}>|Object.<string,*>} message Message instance or plain object
 * @param {Writer} [writer] Writer to encode to
 * @returns {Writer} writer
 */
Type.prototype.encodeDelimited = function encodeDelimited(message, writer) {
    return this.encode(message, writer && writer.len ? writer.fork() : writer).ldelim();
};

/**
 * Decodes a message of this type.
 * @param {Reader|Uint8Array} reader Reader or buffer to decode from
 * @param {number} [length] Length of the message, if known beforehand
 * @returns {Message<{}>} Decoded message
 * @throws {Error} If the payload is not a reader or valid buffer
 * @throws {util.ProtocolError<{}>} If required fields are missing
 */
Type.prototype.decode = function decode_setup(reader, length) {
    return this.setup().decode(reader, length); // overrides this method
};

/**
 * Decodes a message of this type preceeded by its byte length as a varint.
 * @param {Reader|Uint8Array} reader Reader or buffer to decode from
 * @returns {Message<{}>} Decoded message
 * @throws {Error} If the payload is not a reader or valid buffer
 * @throws {util.ProtocolError} If required fields are missing
 */
Type.prototype.decodeDelimited = function decodeDelimited(reader) {
    if (!(reader instanceof Reader))
        reader = Reader.create(reader);
    return this.decode(reader, reader.uint32());
};

/**
 * Verifies that field values are valid and that required fields are present.
 * @param {Object.<string,*>} message Plain object to verify
 * @returns {null|string} `null` if valid, otherwise the reason why it is not
 */
Type.prototype.verify = function verify_setup(message) {
    return this.setup().verify(message); // overrides this method
};

/**
 * Creates a new message of this type from a plain object. Also converts values to their respective internal types.
 * @param {Object.<string,*>} object Plain object to convert
 * @returns {Message<{}>} Message instance
 */
Type.prototype.fromObject = function fromObject(object) {
    return this.setup().fromObject(object);
};

/**
 * Conversion options as used by {@link Type#toObject} and {@link Message.toObject}.
 * @interface IConversionOptions
 * @property {Function} [longs] Long conversion type.
 * Valid values are `String` and `Number` (the global types).
 * Defaults to copy the present value, which is a possibly unsafe number without and a {@link Long} with a long library.
 * @property {Function} [enums] Enum value conversion type.
 * Only valid value is `String` (the global type).
 * Defaults to copy the present value, which is the numeric id.
 * @property {Function} [bytes] Bytes value conversion type.
 * Valid values are `Array` and (a base64 encoded) `String` (the global types).
 * Defaults to copy the present value, which usually is a Buffer under node and an Uint8Array in the browser.
 * @property {boolean} [defaults=false] Also sets default values on the resulting object
 * @property {boolean} [arrays=false] Sets empty arrays for missing repeated fields even if `defaults=false`
 * @property {boolean} [objects=false] Sets empty objects for missing map fields even if `defaults=false`
 * @property {boolean} [oneofs=false] Includes virtual oneof properties set to the present field's name, if any
 * @property {boolean} [json=false] Performs additional JSON compatibility conversions, i.e. NaN and Infinity to strings
 */

/**
 * Creates a plain object from a message of this type. Also converts values to other types if specified.
 * @param {Message<{}>} message Message instance
 * @param {IConversionOptions} [options] Conversion options
 * @returns {Object.<string,*>} Plain object
 */
Type.prototype.toObject = function toObject(message, options) {
    return this.setup().toObject(message, options);
};

/**
 * Decorator function as returned by {@link Type.d} (TypeScript).
 * @typedef TypeDecorator
 * @type {function}
 * @param {Constructor<T>} target Target constructor
 * @returns {undefined}
 * @template T extends Message<T>
 */

/**
 * Type decorator (TypeScript).
 * @param {string} [typeName] Type name, defaults to the constructor's name
 * @returns {TypeDecorator<T>} Decorator function
 * @template T extends Message<T>
 */
Type.d = function decorateType(typeName) {
    return function typeDecorator(target) {
        util.decorateType(target, typeName);
    };
};

},{"12":12,"13":13,"14":14,"15":15,"16":16,"20":20,"21":21,"23":23,"25":25,"27":27,"33":33,"37":37,"40":40,"41":41,"42":42}],36:[function(require,module,exports){
"use strict";

/**
 * Common type constants.
 * @namespace
 */
var types = exports;

var util = require(37);

var s = [
    "double",   // 0
    "float",    // 1
    "int32",    // 2
    "uint32",   // 3
    "sint32",   // 4
    "fixed32",  // 5
    "sfixed32", // 6
    "int64",    // 7
    "uint64",   // 8
    "sint64",   // 9
    "fixed64",  // 10
    "sfixed64", // 11
    "bool",     // 12
    "string",   // 13
    "bytes"     // 14
];

function bake(values, offset) {
    var i = 0, o = {};
    offset |= 0;
    while (i < values.length) o[s[i + offset]] = values[i++];
    return o;
}

/**
 * Basic type wire types.
 * @type {Object.<string,number>}
 * @const
 * @property {number} double=1 Fixed64 wire type
 * @property {number} float=5 Fixed32 wire type
 * @property {number} int32=0 Varint wire type
 * @property {number} uint32=0 Varint wire type
 * @property {number} sint32=0 Varint wire type
 * @property {number} fixed32=5 Fixed32 wire type
 * @property {number} sfixed32=5 Fixed32 wire type
 * @property {number} int64=0 Varint wire type
 * @property {number} uint64=0 Varint wire type
 * @property {number} sint64=0 Varint wire type
 * @property {number} fixed64=1 Fixed64 wire type
 * @property {number} sfixed64=1 Fixed64 wire type
 * @property {number} bool=0 Varint wire type
 * @property {number} string=2 Ldelim wire type
 * @property {number} bytes=2 Ldelim wire type
 */
types.basic = bake([
    /* double   */ 1,
    /* float    */ 5,
    /* int32    */ 0,
    /* uint32   */ 0,
    /* sint32   */ 0,
    /* fixed32  */ 5,
    /* sfixed32 */ 5,
    /* int64    */ 0,
    /* uint64   */ 0,
    /* sint64   */ 0,
    /* fixed64  */ 1,
    /* sfixed64 */ 1,
    /* bool     */ 0,
    /* string   */ 2,
    /* bytes    */ 2
]);

/**
 * Basic type defaults.
 * @type {Object.<string,*>}
 * @const
 * @property {number} double=0 Double default
 * @property {number} float=0 Float default
 * @property {number} int32=0 Int32 default
 * @property {number} uint32=0 Uint32 default
 * @property {number} sint32=0 Sint32 default
 * @property {number} fixed32=0 Fixed32 default
 * @property {number} sfixed32=0 Sfixed32 default
 * @property {number} int64=0 Int64 default
 * @property {number} uint64=0 Uint64 default
 * @property {number} sint64=0 Sint32 default
 * @property {number} fixed64=0 Fixed64 default
 * @property {number} sfixed64=0 Sfixed64 default
 * @property {boolean} bool=false Bool default
 * @property {string} string="" String default
 * @property {Array.<number>} bytes=Array(0) Bytes default
 * @property {null} message=null Message default
 */
types.defaults = bake([
    /* double   */ 0,
    /* float    */ 0,
    /* int32    */ 0,
    /* uint32   */ 0,
    /* sint32   */ 0,
    /* fixed32  */ 0,
    /* sfixed32 */ 0,
    /* int64    */ 0,
    /* uint64   */ 0,
    /* sint64   */ 0,
    /* fixed64  */ 0,
    /* sfixed64 */ 0,
    /* bool     */ false,
    /* string   */ "",
    /* bytes    */ util.emptyArray,
    /* message  */ null
]);

/**
 * Basic long type wire types.
 * @type {Object.<string,number>}
 * @const
 * @property {number} int64=0 Varint wire type
 * @property {number} uint64=0 Varint wire type
 * @property {number} sint64=0 Varint wire type
 * @property {number} fixed64=1 Fixed64 wire type
 * @property {number} sfixed64=1 Fixed64 wire type
 */
types.long = bake([
    /* int64    */ 0,
    /* uint64   */ 0,
    /* sint64   */ 0,
    /* fixed64  */ 1,
    /* sfixed64 */ 1
], 7);

/**
 * Allowed types for map keys with their associated wire type.
 * @type {Object.<string,number>}
 * @const
 * @property {number} int32=0 Varint wire type
 * @property {number} uint32=0 Varint wire type
 * @property {number} sint32=0 Varint wire type
 * @property {number} fixed32=5 Fixed32 wire type
 * @property {number} sfixed32=5 Fixed32 wire type
 * @property {number} int64=0 Varint wire type
 * @property {number} uint64=0 Varint wire type
 * @property {number} sint64=0 Varint wire type
 * @property {number} fixed64=1 Fixed64 wire type
 * @property {number} sfixed64=1 Fixed64 wire type
 * @property {number} bool=0 Varint wire type
 * @property {number} string=2 Ldelim wire type
 */
types.mapKey = bake([
    /* int32    */ 0,
    /* uint32   */ 0,
    /* sint32   */ 0,
    /* fixed32  */ 5,
    /* sfixed32 */ 5,
    /* int64    */ 0,
    /* uint64   */ 0,
    /* sint64   */ 0,
    /* fixed64  */ 1,
    /* sfixed64 */ 1,
    /* bool     */ 0,
    /* string   */ 2
], 2);

/**
 * Allowed types for packed repeated fields with their associated wire type.
 * @type {Object.<string,number>}
 * @const
 * @property {number} double=1 Fixed64 wire type
 * @property {number} float=5 Fixed32 wire type
 * @property {number} int32=0 Varint wire type
 * @property {number} uint32=0 Varint wire type
 * @property {number} sint32=0 Varint wire type
 * @property {number} fixed32=5 Fixed32 wire type
 * @property {number} sfixed32=5 Fixed32 wire type
 * @property {number} int64=0 Varint wire type
 * @property {number} uint64=0 Varint wire type
 * @property {number} sint64=0 Varint wire type
 * @property {number} fixed64=1 Fixed64 wire type
 * @property {number} sfixed64=1 Fixed64 wire type
 * @property {number} bool=0 Varint wire type
 */
types.packed = bake([
    /* double   */ 1,
    /* float    */ 5,
    /* int32    */ 0,
    /* uint32   */ 0,
    /* sint32   */ 0,
    /* fixed32  */ 5,
    /* sfixed32 */ 5,
    /* int64    */ 0,
    /* uint64   */ 0,
    /* sint64   */ 0,
    /* fixed64  */ 1,
    /* sfixed64 */ 1,
    /* bool     */ 0
]);

},{"37":37}],37:[function(require,module,exports){
"use strict";

/**
 * Various utility functions.
 * @namespace
 */
var util = module.exports = require(39);

var roots = require(30);

var Type, // cyclic
    Enum;

util.codegen = require(3);
util.fetch   = require(5);
util.path    = require(8);

/**
 * Node's fs module if available.
 * @type {Object.<string,*>}
 */
util.fs = util.inquire("fs");

/**
 * Converts an object's values to an array.
 * @param {Object.<string,*>} object Object to convert
 * @returns {Array.<*>} Converted array
 */
util.toArray = function toArray(object) {
    if (object) {
        var keys  = Object.keys(object),
            array = new Array(keys.length),
            index = 0;
        while (index < keys.length)
            array[index] = object[keys[index++]];
        return array;
    }
    return [];
};

/**
 * Converts an array of keys immediately followed by their respective value to an object, omitting undefined values.
 * @param {Array.<*>} array Array to convert
 * @returns {Object.<string,*>} Converted object
 */
util.toObject = function toObject(array) {
    var object = {},
        index  = 0;
    while (index < array.length) {
        var key = array[index++],
            val = array[index++];
        if (val !== undefined)
            object[key] = val;
    }
    return object;
};

var safePropBackslashRe = /\\/g,
    safePropQuoteRe     = /"/g;

/**
 * Tests whether the specified name is a reserved word in JS.
 * @param {string} name Name to test
 * @returns {boolean} `true` if reserved, otherwise `false`
 */
util.isReserved = function isReserved(name) {
    return /^(?:do|if|in|for|let|new|try|var|case|else|enum|eval|false|null|this|true|void|with|break|catch|class|const|super|throw|while|yield|delete|export|import|public|return|static|switch|typeof|default|extends|finally|package|private|continue|debugger|function|arguments|interface|protected|implements|instanceof)$/.test(name);
};

/**
 * Returns a safe property accessor for the specified property name.
 * @param {string} prop Property name
 * @returns {string} Safe accessor
 */
util.safeProp = function safeProp(prop) {
    if (!/^[$\w_]+$/.test(prop) || util.isReserved(prop))
        return "[\"" + prop.replace(safePropBackslashRe, "\\\\").replace(safePropQuoteRe, "\\\"") + "\"]";
    return "." + prop;
};

/**
 * Converts the first character of a string to upper case.
 * @param {string} str String to convert
 * @returns {string} Converted string
 */
util.ucFirst = function ucFirst(str) {
    return str.charAt(0).toUpperCase() + str.substring(1);
};

var camelCaseRe = /_([a-z])/g;

/**
 * Converts a string to camel case.
 * @param {string} str String to convert
 * @returns {string} Converted string
 */
util.camelCase = function camelCase(str) {
    return str.substring(0, 1)
         + str.substring(1)
               .replace(camelCaseRe, function($0, $1) { return $1.toUpperCase(); });
};

/**
 * Compares reflected fields by id.
 * @param {Field} a First field
 * @param {Field} b Second field
 * @returns {number} Comparison value
 */
util.compareFieldsById = function compareFieldsById(a, b) {
    return a.id - b.id;
};

/**
 * Decorator helper for types (TypeScript).
 * @param {Constructor<T>} ctor Constructor function
 * @param {string} [typeName] Type name, defaults to the constructor's name
 * @returns {Type} Reflected type
 * @template T extends Message<T>
 * @property {Root} root Decorators root
 */
util.decorateType = function decorateType(ctor, typeName) {

    /* istanbul ignore if */
    if (ctor.$type) {
        if (typeName && ctor.$type.name !== typeName) {
            util.decorateRoot.remove(ctor.$type);
            ctor.$type.name = typeName;
            util.decorateRoot.add(ctor.$type);
        }
        return ctor.$type;
    }

    /* istanbul ignore next */
    if (!Type)
        Type = require(35);

    var type = new Type(typeName || ctor.name);
    util.decorateRoot.add(type);
    type.ctor = ctor; // sets up .encode, .decode etc.
    Object.defineProperty(ctor, "$type", { value: type, enumerable: false });
    Object.defineProperty(ctor.prototype, "$type", { value: type, enumerable: false });
    return type;
};

var decorateEnumIndex = 0;

/**
 * Decorator helper for enums (TypeScript).
 * @param {Object} object Enum object
 * @returns {Enum} Reflected enum
 */
util.decorateEnum = function decorateEnum(object) {

    /* istanbul ignore if */
    if (object.$type)
        return object.$type;

    /* istanbul ignore next */
    if (!Enum)
        Enum = require(15);

    var enm = new Enum("Enum" + decorateEnumIndex++, object);
    util.decorateRoot.add(enm);
    Object.defineProperty(object, "$type", { value: enm, enumerable: false });
    return enm;
};

/**
 * Decorator root (TypeScript).
 * @name util.decorateRoot
 * @type {Root}
 * @readonly
 */
Object.defineProperty(util, "decorateRoot", {
    get: function() {
        return roots["decorated"] || (roots["decorated"] = new (require(29))());
    }
});

},{"15":15,"29":29,"3":3,"30":30,"35":35,"39":39,"5":5,"8":8}],38:[function(require,module,exports){
"use strict";
module.exports = LongBits;

var util = require(39);

/**
 * Constructs new long bits.
 * @classdesc Helper class for working with the low and high bits of a 64 bit value.
 * @memberof util
 * @constructor
 * @param {number} lo Low 32 bits, unsigned
 * @param {number} hi High 32 bits, unsigned
 */
function LongBits(lo, hi) {

    // note that the casts below are theoretically unnecessary as of today, but older statically
    // generated converter code might still call the ctor with signed 32bits. kept for compat.

    /**
     * Low bits.
     * @type {number}
     */
    this.lo = lo >>> 0;

    /**
     * High bits.
     * @type {number}
     */
    this.hi = hi >>> 0;
}

/**
 * Zero bits.
 * @memberof util.LongBits
 * @type {util.LongBits}
 */
var zero = LongBits.zero = new LongBits(0, 0);

zero.toNumber = function() { return 0; };
zero.zzEncode = zero.zzDecode = function() { return this; };
zero.length = function() { return 1; };

/**
 * Zero hash.
 * @memberof util.LongBits
 * @type {string}
 */
var zeroHash = LongBits.zeroHash = "\0\0\0\0\0\0\0\0";

/**
 * Constructs new long bits from the specified number.
 * @param {number} value Value
 * @returns {util.LongBits} Instance
 */
LongBits.fromNumber = function fromNumber(value) {
    if (value === 0)
        return zero;
    var sign = value < 0;
    if (sign)
        value = -value;
    var lo = value >>> 0,
        hi = (value - lo) / 4294967296 >>> 0;
    if (sign) {
        hi = ~hi >>> 0;
        lo = ~lo >>> 0;
        if (++lo > 4294967295) {
            lo = 0;
            if (++hi > 4294967295)
                hi = 0;
        }
    }
    return new LongBits(lo, hi);
};

/**
 * Constructs new long bits from a number, long or string.
 * @param {Long|number|string} value Value
 * @returns {util.LongBits} Instance
 */
LongBits.from = function from(value) {
    if (typeof value === "number")
        return LongBits.fromNumber(value);
    if (util.isString(value)) {
        /* istanbul ignore else */
        if (util.Long)
            value = util.Long.fromString(value);
        else
            return LongBits.fromNumber(parseInt(value, 10));
    }
    return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;
};

/**
 * Converts this long bits to a possibly unsafe JavaScript number.
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {number} Possibly unsafe number
 */
LongBits.prototype.toNumber = function toNumber(unsigned) {
    if (!unsigned && this.hi >>> 31) {
        var lo = ~this.lo + 1 >>> 0,
            hi = ~this.hi     >>> 0;
        if (!lo)
            hi = hi + 1 >>> 0;
        return -(lo + hi * 4294967296);
    }
    return this.lo + this.hi * 4294967296;
};

/**
 * Converts this long bits to a long.
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {Long} Long
 */
LongBits.prototype.toLong = function toLong(unsigned) {
    return util.Long
        ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned))
        /* istanbul ignore next */
        : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };
};

var charCodeAt = String.prototype.charCodeAt;

/**
 * Constructs new long bits from the specified 8 characters long hash.
 * @param {string} hash Hash
 * @returns {util.LongBits} Bits
 */
LongBits.fromHash = function fromHash(hash) {
    if (hash === zeroHash)
        return zero;
    return new LongBits(
        ( charCodeAt.call(hash, 0)
        | charCodeAt.call(hash, 1) << 8
        | charCodeAt.call(hash, 2) << 16
        | charCodeAt.call(hash, 3) << 24) >>> 0
    ,
        ( charCodeAt.call(hash, 4)
        | charCodeAt.call(hash, 5) << 8
        | charCodeAt.call(hash, 6) << 16
        | charCodeAt.call(hash, 7) << 24) >>> 0
    );
};

/**
 * Converts this long bits to a 8 characters long hash.
 * @returns {string} Hash
 */
LongBits.prototype.toHash = function toHash() {
    return String.fromCharCode(
        this.lo        & 255,
        this.lo >>> 8  & 255,
        this.lo >>> 16 & 255,
        this.lo >>> 24      ,
        this.hi        & 255,
        this.hi >>> 8  & 255,
        this.hi >>> 16 & 255,
        this.hi >>> 24
    );
};

/**
 * Zig-zag encodes this long bits.
 * @returns {util.LongBits} `this`
 */
LongBits.prototype.zzEncode = function zzEncode() {
    var mask =   this.hi >> 31;
    this.hi  = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
    this.lo  = ( this.lo << 1                   ^ mask) >>> 0;
    return this;
};

/**
 * Zig-zag decodes this long bits.
 * @returns {util.LongBits} `this`
 */
LongBits.prototype.zzDecode = function zzDecode() {
    var mask = -(this.lo & 1);
    this.lo  = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
    this.hi  = ( this.hi >>> 1                  ^ mask) >>> 0;
    return this;
};

/**
 * Calculates the length of this longbits when encoded as a varint.
 * @returns {number} Length
 */
LongBits.prototype.length = function length() {
    var part0 =  this.lo,
        part1 = (this.lo >>> 28 | this.hi << 4) >>> 0,
        part2 =  this.hi >>> 24;
    return part2 === 0
         ? part1 === 0
           ? part0 < 16384
             ? part0 < 128 ? 1 : 2
             : part0 < 2097152 ? 3 : 4
           : part1 < 16384
             ? part1 < 128 ? 5 : 6
             : part1 < 2097152 ? 7 : 8
         : part2 < 128 ? 9 : 10;
};

},{"39":39}],39:[function(require,module,exports){
"use strict";
var util = exports;

// used to return a Promise where callback is omitted
util.asPromise = require(1);

// converts to / from base64 encoded strings
util.base64 = require(2);

// base class of rpc.Service
util.EventEmitter = require(4);

// float handling accross browsers
util.float = require(6);

// requires modules optionally and hides the call from bundlers
util.inquire = require(7);

// converts to / from utf8 encoded strings
util.utf8 = require(10);

// provides a node-like buffer pool in the browser
util.pool = require(9);

// utility to work with the low and high bits of a 64 bit value
util.LongBits = require(38);

/**
 * An immuable empty array.
 * @memberof util
 * @type {Array.<*>}
 * @const
 */
util.emptyArray = Object.freeze ? Object.freeze([]) : /* istanbul ignore next */ []; // used on prototypes

/**
 * An immutable empty object.
 * @type {Object}
 * @const
 */
util.emptyObject = Object.freeze ? Object.freeze({}) : /* istanbul ignore next */ {}; // used on prototypes

/**
 * Whether running within node or not.
 * @memberof util
 * @type {boolean}
 * @const
 */
util.isNode = Boolean(global.process && global.process.versions && global.process.versions.node);

/**
 * Tests if the specified value is an integer.
 * @function
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is an integer
 */
util.isInteger = Number.isInteger || /* istanbul ignore next */ function isInteger(value) {
    return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
};

/**
 * Tests if the specified value is a string.
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is a string
 */
util.isString = function isString(value) {
    return typeof value === "string" || value instanceof String;
};

/**
 * Tests if the specified value is a non-null object.
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is a non-null object
 */
util.isObject = function isObject(value) {
    return value && typeof value === "object";
};

/**
 * Checks if a property on a message is considered to be present.
 * This is an alias of {@link util.isSet}.
 * @function
 * @param {Object} obj Plain object or message instance
 * @param {string} prop Property name
 * @returns {boolean} `true` if considered to be present, otherwise `false`
 */
util.isset =

/**
 * Checks if a property on a message is considered to be present.
 * @param {Object} obj Plain object or message instance
 * @param {string} prop Property name
 * @returns {boolean} `true` if considered to be present, otherwise `false`
 */
util.isSet = function isSet(obj, prop) {
    var value = obj[prop];
    if (value != null && obj.hasOwnProperty(prop)) // eslint-disable-line eqeqeq, no-prototype-builtins
        return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
    return false;
};

/**
 * Any compatible Buffer instance.
 * This is a minimal stand-alone definition of a Buffer instance. The actual type is that exported by node's typings.
 * @interface Buffer
 * @extends Uint8Array
 */

/**
 * Node's Buffer class if available.
 * @type {Constructor<Buffer>}
 */
util.Buffer = (function() {
    try {
        var Buffer = util.inquire("buffer").Buffer;
        // refuse to use non-node buffers if not explicitly assigned (perf reasons):
        return Buffer.prototype.utf8Write ? Buffer : /* istanbul ignore next */ null;
    } catch (e) {
        /* istanbul ignore next */
        return null;
    }
})();

// Internal alias of or polyfull for Buffer.from.
util._Buffer_from = null;

// Internal alias of or polyfill for Buffer.allocUnsafe.
util._Buffer_allocUnsafe = null;

/**
 * Creates a new buffer of whatever type supported by the environment.
 * @param {number|number[]} [sizeOrArray=0] Buffer size or number array
 * @returns {Uint8Array|Buffer} Buffer
 */
util.newBuffer = function newBuffer(sizeOrArray) {
    /* istanbul ignore next */
    return typeof sizeOrArray === "number"
        ? util.Buffer
            ? util._Buffer_allocUnsafe(sizeOrArray)
            : new util.Array(sizeOrArray)
        : util.Buffer
            ? util._Buffer_from(sizeOrArray)
            : typeof Uint8Array === "undefined"
                ? sizeOrArray
                : new Uint8Array(sizeOrArray);
};

/**
 * Array implementation used in the browser. `Uint8Array` if supported, otherwise `Array`.
 * @type {Constructor<Uint8Array>}
 */
util.Array = typeof Uint8Array !== "undefined" ? Uint8Array /* istanbul ignore next */ : Array;

/**
 * Any compatible Long instance.
 * This is a minimal stand-alone definition of a Long instance. The actual type is that exported by long.js.
 * @interface Long
 * @property {number} low Low bits
 * @property {number} high High bits
 * @property {boolean} unsigned Whether unsigned or not
 */

/**
 * Long.js's Long class if available.
 * @type {Constructor<Long>}
 */
util.Long = /* istanbul ignore next */ global.dcodeIO && /* istanbul ignore next */ global.dcodeIO.Long || util.inquire("long");

/**
 * Regular expression used to verify 2 bit (`bool`) map keys.
 * @type {RegExp}
 * @const
 */
util.key2Re = /^true|false|0|1$/;

/**
 * Regular expression used to verify 32 bit (`int32` etc.) map keys.
 * @type {RegExp}
 * @const
 */
util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;

/**
 * Regular expression used to verify 64 bit (`int64` etc.) map keys.
 * @type {RegExp}
 * @const
 */
util.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;

/**
 * Converts a number or long to an 8 characters long hash string.
 * @param {Long|number} value Value to convert
 * @returns {string} Hash
 */
util.longToHash = function longToHash(value) {
    return value
        ? util.LongBits.from(value).toHash()
        : util.LongBits.zeroHash;
};

/**
 * Converts an 8 characters long hash string to a long or number.
 * @param {string} hash Hash
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {Long|number} Original value
 */
util.longFromHash = function longFromHash(hash, unsigned) {
    var bits = util.LongBits.fromHash(hash);
    if (util.Long)
        return util.Long.fromBits(bits.lo, bits.hi, unsigned);
    return bits.toNumber(Boolean(unsigned));
};

/**
 * Merges the properties of the source object into the destination object.
 * @memberof util
 * @param {Object.<string,*>} dst Destination object
 * @param {Object.<string,*>} src Source object
 * @param {boolean} [ifNotSet=false] Merges only if the key is not already set
 * @returns {Object.<string,*>} Destination object
 */
function merge(dst, src, ifNotSet) { // used by converters
    for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)
        if (dst[keys[i]] === undefined || !ifNotSet)
            dst[keys[i]] = src[keys[i]];
    return dst;
}

util.merge = merge;

/**
 * Converts the first character of a string to lower case.
 * @param {string} str String to convert
 * @returns {string} Converted string
 */
util.lcFirst = function lcFirst(str) {
    return str.charAt(0).toLowerCase() + str.substring(1);
};

/**
 * Creates a custom error constructor.
 * @memberof util
 * @param {string} name Error name
 * @returns {Constructor<Error>} Custom error constructor
 */
function newError(name) {

    function CustomError(message, properties) {

        if (!(this instanceof CustomError))
            return new CustomError(message, properties);

        // Error.call(this, message);
        // ^ just returns a new error instance because the ctor can be called as a function

        Object.defineProperty(this, "message", { get: function() { return message; } });

        /* istanbul ignore next */
        if (Error.captureStackTrace) // node
            Error.captureStackTrace(this, CustomError);
        else
            Object.defineProperty(this, "stack", { value: (new Error()).stack || "" });

        if (properties)
            merge(this, properties);
    }

    (CustomError.prototype = Object.create(Error.prototype)).constructor = CustomError;

    Object.defineProperty(CustomError.prototype, "name", { get: function() { return name; } });

    CustomError.prototype.toString = function toString() {
        return this.name + ": " + this.message;
    };

    return CustomError;
}

util.newError = newError;

/**
 * Constructs a new protocol error.
 * @classdesc Error subclass indicating a protocol specifc error.
 * @memberof util
 * @extends Error
 * @template T extends Message<T>
 * @constructor
 * @param {string} message Error message
 * @param {Object.<string,*>} [properties] Additional properties
 * @example
 * try {
 *     MyMessage.decode(someBuffer); // throws if required fields are missing
 * } catch (e) {
 *     if (e instanceof ProtocolError && e.instance)
 *         console.log("decoded so far: " + JSON.stringify(e.instance));
 * }
 */
util.ProtocolError = newError("ProtocolError");

/**
 * So far decoded message instance.
 * @name util.ProtocolError#instance
 * @type {Message<T>}
 */

/**
 * A OneOf getter as returned by {@link util.oneOfGetter}.
 * @typedef OneOfGetter
 * @type {function}
 * @returns {string|undefined} Set field name, if any
 */

/**
 * Builds a getter for a oneof's present field name.
 * @param {string[]} fieldNames Field names
 * @returns {OneOfGetter} Unbound getter
 */
util.oneOfGetter = function getOneOf(fieldNames) {
    var fieldMap = {};
    for (var i = 0; i < fieldNames.length; ++i)
        fieldMap[fieldNames[i]] = 1;

    /**
     * @returns {string|undefined} Set field name, if any
     * @this Object
     * @ignore
     */
    return function() { // eslint-disable-line consistent-return
        for (var keys = Object.keys(this), i = keys.length - 1; i > -1; --i)
            if (fieldMap[keys[i]] === 1 && this[keys[i]] !== undefined && this[keys[i]] !== null)
                return keys[i];
    };
};

/**
 * A OneOf setter as returned by {@link util.oneOfSetter}.
 * @typedef OneOfSetter
 * @type {function}
 * @param {string|undefined} value Field name
 * @returns {undefined}
 */

/**
 * Builds a setter for a oneof's present field name.
 * @param {string[]} fieldNames Field names
 * @returns {OneOfSetter} Unbound setter
 */
util.oneOfSetter = function setOneOf(fieldNames) {

    /**
     * @param {string} name Field name
     * @returns {undefined}
     * @this Object
     * @ignore
     */
    return function(name) {
        for (var i = 0; i < fieldNames.length; ++i)
            if (fieldNames[i] !== name)
                delete this[fieldNames[i]];
    };
};

/**
 * Default conversion options used for {@link Message#toJSON} implementations.
 *
 * These options are close to proto3's JSON mapping with the exception that internal types like Any are handled just like messages. More precisely:
 *
 * - Longs become strings
 * - Enums become string keys
 * - Bytes become base64 encoded strings
 * - (Sub-)Messages become plain objects
 * - Maps become plain objects with all string keys
 * - Repeated fields become arrays
 * - NaN and Infinity for float and double fields become strings
 *
 * @type {IConversionOptions}
 * @see https://developers.google.com/protocol-buffers/docs/proto3?hl=en#json
 */
util.toJSONOptions = {
    longs: String,
    enums: String,
    bytes: String,
    json: true
};

util._configure = function() {
    var Buffer = util.Buffer;
    /* istanbul ignore if */
    if (!Buffer) {
        util._Buffer_from = util._Buffer_allocUnsafe = null;
        return;
    }
    // because node 4.x buffers are incompatible & immutable
    // see: https://github.com/dcodeIO/protobuf.js/pull/665
    util._Buffer_from = Buffer.from !== Uint8Array.from && Buffer.from ||
        /* istanbul ignore next */
        function Buffer_from(value, encoding) {
            return new Buffer(value, encoding);
        };
    util._Buffer_allocUnsafe = Buffer.allocUnsafe ||
        /* istanbul ignore next */
        function Buffer_allocUnsafe(size) {
            return new Buffer(size);
        };
};

},{"1":1,"10":10,"2":2,"38":38,"4":4,"6":6,"7":7,"9":9}],40:[function(require,module,exports){
"use strict";
module.exports = verifier;

var Enum      = require(15),
    util      = require(37);

function invalid(field, expected) {
    return field.name + ": " + expected + (field.repeated && expected !== "array" ? "[]" : field.map && expected !== "object" ? "{k:"+field.keyType+"}" : "") + " expected";
}

/**
 * Generates a partial value verifier.
 * @param {Codegen} gen Codegen instance
 * @param {Field} field Reflected field
 * @param {number} fieldIndex Field index
 * @param {string} ref Variable reference
 * @returns {Codegen} Codegen instance
 * @ignore
 */
function genVerifyValue(gen, field, fieldIndex, ref) {
    /* eslint-disable no-unexpected-multiline */
    if (field.resolvedType) {
        if (field.resolvedType instanceof Enum) { gen
            ("switch(%s){", ref)
                ("default:")
                    ("return%j", invalid(field, "enum value"));
            for (var keys = Object.keys(field.resolvedType.values), j = 0; j < keys.length; ++j) gen
                ("case %i:", field.resolvedType.values[keys[j]]);
            gen
                    ("break")
            ("}");
        } else {
            gen
            ("{")
                ("var e=types[%i].verify(%s);", fieldIndex, ref)
                ("if(e)")
                    ("return%j+e", field.name + ".")
            ("}");
        }
    } else {
        switch (field.type) {
            case "int32":
            case "uint32":
            case "sint32":
            case "fixed32":
            case "sfixed32": gen
                ("if(!util.isInteger(%s))", ref)
                    ("return%j", invalid(field, "integer"));
                break;
            case "int64":
            case "uint64":
            case "sint64":
            case "fixed64":
            case "sfixed64": gen
                ("if(!util.isInteger(%s)&&!(%s&&util.isInteger(%s.low)&&util.isInteger(%s.high)))", ref, ref, ref, ref)
                    ("return%j", invalid(field, "integer|Long"));
                break;
            case "float":
            case "double": gen
                ("if(typeof %s!==\"number\")", ref)
                    ("return%j", invalid(field, "number"));
                break;
            case "bool": gen
                ("if(typeof %s!==\"boolean\")", ref)
                    ("return%j", invalid(field, "boolean"));
                break;
            case "string": gen
                ("if(!util.isString(%s))", ref)
                    ("return%j", invalid(field, "string"));
                break;
            case "bytes": gen
                ("if(!(%s&&typeof %s.length===\"number\"||util.isString(%s)))", ref, ref, ref)
                    ("return%j", invalid(field, "buffer"));
                break;
        }
    }
    return gen;
    /* eslint-enable no-unexpected-multiline */
}

/**
 * Generates a partial key verifier.
 * @param {Codegen} gen Codegen instance
 * @param {Field} field Reflected field
 * @param {string} ref Variable reference
 * @returns {Codegen} Codegen instance
 * @ignore
 */
function genVerifyKey(gen, field, ref) {
    /* eslint-disable no-unexpected-multiline */
    switch (field.keyType) {
        case "int32":
        case "uint32":
        case "sint32":
        case "fixed32":
        case "sfixed32": gen
            ("if(!util.key32Re.test(%s))", ref)
                ("return%j", invalid(field, "integer key"));
            break;
        case "int64":
        case "uint64":
        case "sint64":
        case "fixed64":
        case "sfixed64": gen
            ("if(!util.key64Re.test(%s))", ref) // see comment above: x is ok, d is not
                ("return%j", invalid(field, "integer|Long key"));
            break;
        case "bool": gen
            ("if(!util.key2Re.test(%s))", ref)
                ("return%j", invalid(field, "boolean key"));
            break;
    }
    return gen;
    /* eslint-enable no-unexpected-multiline */
}

/**
 * Generates a verifier specific to the specified message type.
 * @param {Type} mtype Message type
 * @returns {Codegen} Codegen instance
 */
function verifier(mtype) {
    /* eslint-disable no-unexpected-multiline */

    var gen = util.codegen(["m"], mtype.name + "$verify")
    ("if(typeof m!==\"object\"||m===null)")
        ("return%j", "object expected");
    var oneofs = mtype.oneofsArray,
        seenFirstField = {};
    if (oneofs.length) gen
    ("var p={}");

    for (var i = 0; i < /* initializes */ mtype.fieldsArray.length; ++i) {
        var field = mtype._fieldsArray[i].resolve(),
            ref   = "m" + util.safeProp(field.name);

        if (field.optional) gen
        ("if(%s!=null&&m.hasOwnProperty(%j)){", ref, field.name); // !== undefined && !== null

        // map fields
        if (field.map) { gen
            ("if(!util.isObject(%s))", ref)
                ("return%j", invalid(field, "object"))
            ("var k=Object.keys(%s)", ref)
            ("for(var i=0;i<k.length;++i){");
                genVerifyKey(gen, field, "k[i]");
                genVerifyValue(gen, field, i, ref + "[k[i]]")
            ("}");

        // repeated fields
        } else if (field.repeated) { gen
            ("if(!Array.isArray(%s))", ref)
                ("return%j", invalid(field, "array"))
            ("for(var i=0;i<%s.length;++i){", ref);
                genVerifyValue(gen, field, i, ref + "[i]")
            ("}");

        // required or present fields
        } else {
            if (field.partOf) {
                var oneofProp = util.safeProp(field.partOf.name);
                if (seenFirstField[field.partOf.name] === 1) gen
            ("if(p%s===1)", oneofProp)
                ("return%j", field.partOf.name + ": multiple values");
                seenFirstField[field.partOf.name] = 1;
                gen
            ("p%s=1", oneofProp);
            }
            genVerifyValue(gen, field, i, ref);
        }
        if (field.optional) gen
        ("}");
    }
    return gen
    ("return null");
    /* eslint-enable no-unexpected-multiline */
}
},{"15":15,"37":37}],41:[function(require,module,exports){
"use strict";

/**
 * Wrappers for common types.
 * @type {Object.<string,IWrapper>}
 * @const
 */
var wrappers = exports;

var Message = require(21);

/**
 * From object converter part of an {@link IWrapper}.
 * @typedef WrapperFromObjectConverter
 * @type {function}
 * @param {Object.<string,*>} object Plain object
 * @returns {Message<{}>} Message instance
 * @this Type
 */

/**
 * To object converter part of an {@link IWrapper}.
 * @typedef WrapperToObjectConverter
 * @type {function}
 * @param {Message<{}>} message Message instance
 * @param {IConversionOptions} [options] Conversion options
 * @returns {Object.<string,*>} Plain object
 * @this Type
 */

/**
 * Common type wrapper part of {@link wrappers}.
 * @interface IWrapper
 * @property {WrapperFromObjectConverter} [fromObject] From object converter
 * @property {WrapperToObjectConverter} [toObject] To object converter
 */

// Custom wrapper for Any
wrappers[".google.protobuf.Any"] = {

    fromObject: function(object) {

        // unwrap value type if mapped
        if (object && object["@type"]) {
            var type = this.lookup(object["@type"]);
            /* istanbul ignore else */
            if (type) {
                // type_url does not accept leading "."
                var type_url = object["@type"].charAt(0) === "." ?
                    object["@type"].substr(1) : object["@type"];
                // type_url prefix is optional, but path seperator is required
                return this.create({
                    type_url: "/" + type_url,
                    value: type.encode(type.fromObject(object)).finish()
                });
            }
        }

        return this.fromObject(object);
    },

    toObject: function(message, options) {

        // decode value if requested and unmapped
        if (options && options.json && message.type_url && message.value) {
            // Only use fully qualified type name after the last '/'
            var name = message.type_url.substring(message.type_url.lastIndexOf("/") + 1);
            var type = this.lookup(name);
            /* istanbul ignore else */
            if (type)
                message = type.decode(message.value);
        }

        // wrap value if unmapped
        if (!(message instanceof this.ctor) && message instanceof Message) {
            var object = message.$type.toObject(message, options);
            object["@type"] = message.$type.fullName;
            return object;
        }

        return this.toObject(message, options);
    }
};

},{"21":21}],42:[function(require,module,exports){
"use strict";
module.exports = Writer;

var util      = require(39);

var BufferWriter; // cyclic

var LongBits  = util.LongBits,
    base64    = util.base64,
    utf8      = util.utf8;

/**
 * Constructs a new writer operation instance.
 * @classdesc Scheduled writer operation.
 * @constructor
 * @param {function(*, Uint8Array, number)} fn Function to call
 * @param {number} len Value byte length
 * @param {*} val Value to write
 * @ignore
 */
function Op(fn, len, val) {

    /**
     * Function to call.
     * @type {function(Uint8Array, number, *)}
     */
    this.fn = fn;

    /**
     * Value byte length.
     * @type {number}
     */
    this.len = len;

    /**
     * Next operation.
     * @type {Writer.Op|undefined}
     */
    this.next = undefined;

    /**
     * Value to write.
     * @type {*}
     */
    this.val = val; // type varies
}

/* istanbul ignore next */
function noop() {} // eslint-disable-line no-empty-function

/**
 * Constructs a new writer state instance.
 * @classdesc Copied writer state.
 * @memberof Writer
 * @constructor
 * @param {Writer} writer Writer to copy state from
 * @ignore
 */
function State(writer) {

    /**
     * Current head.
     * @type {Writer.Op}
     */
    this.head = writer.head;

    /**
     * Current tail.
     * @type {Writer.Op}
     */
    this.tail = writer.tail;

    /**
     * Current buffer length.
     * @type {number}
     */
    this.len = writer.len;

    /**
     * Next state.
     * @type {State|null}
     */
    this.next = writer.states;
}

/**
 * Constructs a new writer instance.
 * @classdesc Wire format writer using `Uint8Array` if available, otherwise `Array`.
 * @constructor
 */
function Writer() {

    /**
     * Current length.
     * @type {number}
     */
    this.len = 0;

    /**
     * Operations head.
     * @type {Object}
     */
    this.head = new Op(noop, 0, 0);

    /**
     * Operations tail
     * @type {Object}
     */
    this.tail = this.head;

    /**
     * Linked forked states.
     * @type {Object|null}
     */
    this.states = null;

    // When a value is written, the writer calculates its byte length and puts it into a linked
    // list of operations to perform when finish() is called. This both allows us to allocate
    // buffers of the exact required size and reduces the amount of work we have to do compared
    // to first calculating over objects and then encoding over objects. In our case, the encoding
    // part is just a linked list walk calling operations with already prepared values.
}

/**
 * Creates a new writer.
 * @function
 * @returns {BufferWriter|Writer} A {@link BufferWriter} when Buffers are supported, otherwise a {@link Writer}
 */
Writer.create = util.Buffer
    ? function create_buffer_setup() {
        return (Writer.create = function create_buffer() {
            return new BufferWriter();
        })();
    }
    /* istanbul ignore next */
    : function create_array() {
        return new Writer();
    };

/**
 * Allocates a buffer of the specified size.
 * @param {number} size Buffer size
 * @returns {Uint8Array} Buffer
 */
Writer.alloc = function alloc(size) {
    return new util.Array(size);
};

// Use Uint8Array buffer pool in the browser, just like node does with buffers
/* istanbul ignore else */
if (util.Array !== Array)
    Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);

/**
 * Pushes a new operation to the queue.
 * @param {function(Uint8Array, number, *)} fn Function to call
 * @param {number} len Value byte length
 * @param {number} val Value to write
 * @returns {Writer} `this`
 * @private
 */
Writer.prototype._push = function push(fn, len, val) {
    this.tail = this.tail.next = new Op(fn, len, val);
    this.len += len;
    return this;
};

function writeByte(val, buf, pos) {
    buf[pos] = val & 255;
}

function writeVarint32(val, buf, pos) {
    while (val > 127) {
        buf[pos++] = val & 127 | 128;
        val >>>= 7;
    }
    buf[pos] = val;
}

/**
 * Constructs a new varint writer operation instance.
 * @classdesc Scheduled varint writer operation.
 * @extends Op
 * @constructor
 * @param {number} len Value byte length
 * @param {number} val Value to write
 * @ignore
 */
function VarintOp(len, val) {
    this.len = len;
    this.next = undefined;
    this.val = val;
}

VarintOp.prototype = Object.create(Op.prototype);
VarintOp.prototype.fn = writeVarint32;

/**
 * Writes an unsigned 32 bit value as a varint.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.uint32 = function write_uint32(value) {
    // here, the call to this.push has been inlined and a varint specific Op subclass is used.
    // uint32 is by far the most frequently used operation and benefits significantly from this.
    this.len += (this.tail = this.tail.next = new VarintOp(
        (value = value >>> 0)
                < 128       ? 1
        : value < 16384     ? 2
        : value < 2097152   ? 3
        : value < 268435456 ? 4
        :                     5,
    value)).len;
    return this;
};

/**
 * Writes a signed 32 bit value as a varint.
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.int32 = function write_int32(value) {
    return value < 0
        ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) // 10 bytes per spec
        : this.uint32(value);
};

/**
 * Writes a 32 bit value as a varint, zig-zag encoded.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.sint32 = function write_sint32(value) {
    return this.uint32((value << 1 ^ value >> 31) >>> 0);
};

function writeVarint64(val, buf, pos) {
    while (val.hi) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
        val.hi >>>= 7;
    }
    while (val.lo > 127) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = val.lo >>> 7;
    }
    buf[pos++] = val.lo;
}

/**
 * Writes an unsigned 64 bit value as a varint.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.uint64 = function write_uint64(value) {
    var bits = LongBits.from(value);
    return this._push(writeVarint64, bits.length(), bits);
};

/**
 * Writes a signed 64 bit value as a varint.
 * @function
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.int64 = Writer.prototype.uint64;

/**
 * Writes a signed 64 bit value as a varint, zig-zag encoded.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.sint64 = function write_sint64(value) {
    var bits = LongBits.from(value).zzEncode();
    return this._push(writeVarint64, bits.length(), bits);
};

/**
 * Writes a boolish value as a varint.
 * @param {boolean} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.bool = function write_bool(value) {
    return this._push(writeByte, 1, value ? 1 : 0);
};

function writeFixed32(val, buf, pos) {
    buf[pos    ] =  val         & 255;
    buf[pos + 1] =  val >>> 8   & 255;
    buf[pos + 2] =  val >>> 16  & 255;
    buf[pos + 3] =  val >>> 24;
}

/**
 * Writes an unsigned 32 bit value as fixed 32 bits.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.fixed32 = function write_fixed32(value) {
    return this._push(writeFixed32, 4, value >>> 0);
};

/**
 * Writes a signed 32 bit value as fixed 32 bits.
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.sfixed32 = Writer.prototype.fixed32;

/**
 * Writes an unsigned 64 bit value as fixed 64 bits.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.fixed64 = function write_fixed64(value) {
    var bits = LongBits.from(value);
    return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
};

/**
 * Writes a signed 64 bit value as fixed 64 bits.
 * @function
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.sfixed64 = Writer.prototype.fixed64;

/**
 * Writes a float (32 bit).
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.float = function write_float(value) {
    return this._push(util.float.writeFloatLE, 4, value);
};

/**
 * Writes a double (64 bit float).
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.double = function write_double(value) {
    return this._push(util.float.writeDoubleLE, 8, value);
};

var writeBytes = util.Array.prototype.set
    ? function writeBytes_set(val, buf, pos) {
        buf.set(val, pos); // also works for plain array values
    }
    /* istanbul ignore next */
    : function writeBytes_for(val, buf, pos) {
        for (var i = 0; i < val.length; ++i)
            buf[pos + i] = val[i];
    };

/**
 * Writes a sequence of bytes.
 * @param {Uint8Array|string} value Buffer or base64 encoded string to write
 * @returns {Writer} `this`
 */
Writer.prototype.bytes = function write_bytes(value) {
    var len = value.length >>> 0;
    if (!len)
        return this._push(writeByte, 1, 0);
    if (util.isString(value)) {
        var buf = Writer.alloc(len = base64.length(value));
        base64.decode(value, buf, 0);
        value = buf;
    }
    return this.uint32(len)._push(writeBytes, len, value);
};

/**
 * Writes a string.
 * @param {string} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.string = function write_string(value) {
    var len = utf8.length(value);
    return len
        ? this.uint32(len)._push(utf8.write, len, value)
        : this._push(writeByte, 1, 0);
};

/**
 * Forks this writer's state by pushing it to a stack.
 * Calling {@link Writer#reset|reset} or {@link Writer#ldelim|ldelim} resets the writer to the previous state.
 * @returns {Writer} `this`
 */
Writer.prototype.fork = function fork() {
    this.states = new State(this);
    this.head = this.tail = new Op(noop, 0, 0);
    this.len = 0;
    return this;
};

/**
 * Resets this instance to the last state.
 * @returns {Writer} `this`
 */
Writer.prototype.reset = function reset() {
    if (this.states) {
        this.head   = this.states.head;
        this.tail   = this.states.tail;
        this.len    = this.states.len;
        this.states = this.states.next;
    } else {
        this.head = this.tail = new Op(noop, 0, 0);
        this.len  = 0;
    }
    return this;
};

/**
 * Resets to the last state and appends the fork state's current write length as a varint followed by its operations.
 * @returns {Writer} `this`
 */
Writer.prototype.ldelim = function ldelim() {
    var head = this.head,
        tail = this.tail,
        len  = this.len;
    this.reset().uint32(len);
    if (len) {
        this.tail.next = head.next; // skip noop
        this.tail = tail;
        this.len += len;
    }
    return this;
};

/**
 * Finishes the write operation.
 * @returns {Uint8Array} Finished buffer
 */
Writer.prototype.finish = function finish() {
    var head = this.head.next, // skip noop
        buf  = this.constructor.alloc(this.len),
        pos  = 0;
    while (head) {
        head.fn(head.val, buf, pos);
        pos += head.len;
        head = head.next;
    }
    // this.head = this.tail = null;
    return buf;
};

Writer._configure = function(BufferWriter_) {
    BufferWriter = BufferWriter_;
};

},{"39":39}],43:[function(require,module,exports){
"use strict";
module.exports = BufferWriter;

// extends Writer
var Writer = require(42);
(BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;

var util = require(39);

var Buffer = util.Buffer;

/**
 * Constructs a new buffer writer instance.
 * @classdesc Wire format writer using node buffers.
 * @extends Writer
 * @constructor
 */
function BufferWriter() {
    Writer.call(this);
}

/**
 * Allocates a buffer of the specified size.
 * @param {number} size Buffer size
 * @returns {Buffer} Buffer
 */
BufferWriter.alloc = function alloc_buffer(size) {
    return (BufferWriter.alloc = util._Buffer_allocUnsafe)(size);
};

var writeBytesBuffer = Buffer && Buffer.prototype instanceof Uint8Array && Buffer.prototype.set.name === "set"
    ? function writeBytesBuffer_set(val, buf, pos) {
        buf.set(val, pos); // faster than copy (requires node >= 4 where Buffers extend Uint8Array and set is properly inherited)
                           // also works for plain array values
    }
    /* istanbul ignore next */
    : function writeBytesBuffer_copy(val, buf, pos) {
        if (val.copy) // Buffer values
            val.copy(buf, pos, 0, val.length);
        else for (var i = 0; i < val.length;) // plain array values
            buf[pos++] = val[i++];
    };

/**
 * @override
 */
BufferWriter.prototype.bytes = function write_bytes_buffer(value) {
    if (util.isString(value))
        value = util._Buffer_from(value, "base64");
    var len = value.length >>> 0;
    this.uint32(len);
    if (len)
        this._push(writeBytesBuffer, len, value);
    return this;
};

function writeStringBuffer(val, buf, pos) {
    if (val.length < 40) // plain js is faster for short strings (probably due to redundant assertions)
        util.utf8.write(val, buf, pos);
    else
        buf.utf8Write(val, pos);
}

/**
 * @override
 */
BufferWriter.prototype.string = function write_string_buffer(value) {
    var len = Buffer.byteLength(value);
    this.uint32(len);
    if (len)
        this._push(writeStringBuffer, len, value);
    return this;
};


/**
 * Finishes the write operation.
 * @name BufferWriter#finish
 * @function
 * @returns {Buffer} Finished buffer
 */

},{"39":39,"42":42}]},{},[19])

})(
	typeof window==="object" && window
	|| typeof self==="object" && self
	|| this
);





// file: /bitrix/js/pull/protobuf/model.js
/*eslint-disable block-scoped-var, no-redeclare, no-control-regex, no-prototype-builtins*/
(function($protobuf) {
    "use strict";

    // Common aliases
    var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;

    // Exported root namespace
    var $root = $protobuf.roots["push-server"] || ($protobuf.roots["push-server"] = {});

    $root.RequestBatch = (function() {

        /**
         * Properties of a RequestBatch.
         * @exports IRequestBatch
         * @interface IRequestBatch
         * @property {Array.<Request>|null} [requests] RequestBatch requests
         */

        /**
         * Constructs a new RequestBatch.
         * @exports RequestBatch
         * @classdesc Represents a RequestBatch.
         * @implements IRequestBatch
         * @constructor
         * @param {IRequestBatch=} [properties] Properties to set
         */
        function RequestBatch(properties) {
            this.requests = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RequestBatch requests.
         * @member {Array.<Request>} requests
         * @memberof RequestBatch
         * @instance
         */
        RequestBatch.prototype.requests = $util.emptyArray;

        /**
         * Creates a new RequestBatch instance using the specified properties.
         * @function create
         * @memberof RequestBatch
         * @static
         * @param {IRequestBatch=} [properties] Properties to set
         * @returns {RequestBatch} RequestBatch instance
         */
        RequestBatch.create = function create(properties) {
            return new RequestBatch(properties);
        };

        /**
         * Encodes the specified RequestBatch message. Does not implicitly {@link RequestBatch.verify|verify} messages.
         * @function encode
         * @memberof RequestBatch
         * @static
         * @param {RequestBatch} message RequestBatch message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RequestBatch.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.requests != null && message.requests.length)
                for (var i = 0; i < message.requests.length; ++i)
                    $root.Request.encode(message.requests[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Decodes a RequestBatch message from the specified reader or buffer.
         * @function decode
         * @memberof RequestBatch
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RequestBatch} RequestBatch
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RequestBatch.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RequestBatch();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.requests && message.requests.length))
                        message.requests = [];
                    message.requests.push($root.Request.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return RequestBatch;
    })();

    $root.Request = (function() {

        /**
         * Properties of a Request.
         * @exports IRequest
         * @interface IRequest
         * @property {IncomingMessagesRequest|null} [incomingMessages] Request incomingMessages
         * @property {ChannelStatsRequest|null} [channelStats] Request channelStats
         * @property {ServerStatsRequest|null} [serverStats] Request serverStats
         */

        /**
         * Constructs a new Request.
         * @exports Request
         * @classdesc Represents a Request.
         * @implements IRequest
         * @constructor
         * @param {IRequest=} [properties] Properties to set
         */
        function Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Request incomingMessages.
         * @member {IncomingMessagesRequest|null|undefined} incomingMessages
         * @memberof Request
         * @instance
         */
        Request.prototype.incomingMessages = null;

        /**
         * Request channelStats.
         * @member {ChannelStatsRequest|null|undefined} channelStats
         * @memberof Request
         * @instance
         */
        Request.prototype.channelStats = null;

        /**
         * Request serverStats.
         * @member {ServerStatsRequest|null|undefined} serverStats
         * @memberof Request
         * @instance
         */
        Request.prototype.serverStats = null;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * Request command.
         * @member {"incomingMessages"|"channelStats"|"serverStats"|undefined} command
         * @memberof Request
         * @instance
         */
        Object.defineProperty(Request.prototype, "command", {
            get: $util.oneOfGetter($oneOfFields = ["incomingMessages", "channelStats", "serverStats"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new Request instance using the specified properties.
         * @function create
         * @memberof Request
         * @static
         * @param {IRequest=} [properties] Properties to set
         * @returns {Request} Request instance
         */
        Request.create = function create(properties) {
            return new Request(properties);
        };

        /**
         * Encodes the specified Request message. Does not implicitly {@link Request.verify|verify} messages.
         * @function encode
         * @memberof Request
         * @static
         * @param {Request} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.incomingMessages != null && message.hasOwnProperty("incomingMessages"))
                $root.IncomingMessagesRequest.encode(message.incomingMessages, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.channelStats != null && message.hasOwnProperty("channelStats"))
                $root.ChannelStatsRequest.encode(message.channelStats, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.serverStats != null && message.hasOwnProperty("serverStats"))
                $root.ServerStatsRequest.encode(message.serverStats, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Decodes a Request message from the specified reader or buffer.
         * @function decode
         * @memberof Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.incomingMessages = $root.IncomingMessagesRequest.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.channelStats = $root.ChannelStatsRequest.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.serverStats = $root.ServerStatsRequest.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return Request;
    })();

    $root.IncomingMessagesRequest = (function() {

        /**
         * Properties of an IncomingMessagesRequest.
         * @exports IIncomingMessagesRequest
         * @interface IIncomingMessagesRequest
         * @property {Array.<IncomingMessage>|null} [messages] IncomingMessagesRequest messages
         */

        /**
         * Constructs a new IncomingMessagesRequest.
         * @exports IncomingMessagesRequest
         * @classdesc Represents an IncomingMessagesRequest.
         * @implements IIncomingMessagesRequest
         * @constructor
         * @param {IIncomingMessagesRequest=} [properties] Properties to set
         */
        function IncomingMessagesRequest(properties) {
            this.messages = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IncomingMessagesRequest messages.
         * @member {Array.<IncomingMessage>} messages
         * @memberof IncomingMessagesRequest
         * @instance
         */
        IncomingMessagesRequest.prototype.messages = $util.emptyArray;

        /**
         * Creates a new IncomingMessagesRequest instance using the specified properties.
         * @function create
         * @memberof IncomingMessagesRequest
         * @static
         * @param {IIncomingMessagesRequest=} [properties] Properties to set
         * @returns {IncomingMessagesRequest} IncomingMessagesRequest instance
         */
        IncomingMessagesRequest.create = function create(properties) {
            return new IncomingMessagesRequest(properties);
        };

        /**
         * Encodes the specified IncomingMessagesRequest message. Does not implicitly {@link IncomingMessagesRequest.verify|verify} messages.
         * @function encode
         * @memberof IncomingMessagesRequest
         * @static
         * @param {IncomingMessagesRequest} message IncomingMessagesRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IncomingMessagesRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.messages != null && message.messages.length)
                for (var i = 0; i < message.messages.length; ++i)
                    $root.IncomingMessage.encode(message.messages[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Decodes an IncomingMessagesRequest message from the specified reader or buffer.
         * @function decode
         * @memberof IncomingMessagesRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {IncomingMessagesRequest} IncomingMessagesRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IncomingMessagesRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.IncomingMessagesRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.messages && message.messages.length))
                        message.messages = [];
                    message.messages.push($root.IncomingMessage.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return IncomingMessagesRequest;
    })();

    $root.IncomingMessage = (function() {

        /**
         * Properties of an IncomingMessage.
         * @exports IIncomingMessage
         * @interface IIncomingMessage
         * @property {Array.<Receiver>|null} [receivers] IncomingMessage receivers
         * @property {Sender|null} [sender] IncomingMessage sender
         * @property {string|null} [body] IncomingMessage body
         * @property {number|null} [expiry] IncomingMessage expiry
         * @property {string|null} [type] IncomingMessage type
         */

        /**
         * Constructs a new IncomingMessage.
         * @exports IncomingMessage
         * @classdesc Represents an IncomingMessage.
         * @implements IIncomingMessage
         * @constructor
         * @param {IIncomingMessage=} [properties] Properties to set
         */
        function IncomingMessage(properties) {
            this.receivers = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IncomingMessage receivers.
         * @member {Array.<Receiver>} receivers
         * @memberof IncomingMessage
         * @instance
         */
        IncomingMessage.prototype.receivers = $util.emptyArray;

        /**
         * IncomingMessage sender.
         * @member {Sender|null|undefined} sender
         * @memberof IncomingMessage
         * @instance
         */
        IncomingMessage.prototype.sender = null;

        /**
         * IncomingMessage body.
         * @member {string} body
         * @memberof IncomingMessage
         * @instance
         */
        IncomingMessage.prototype.body = "";

        /**
         * IncomingMessage expiry.
         * @member {number} expiry
         * @memberof IncomingMessage
         * @instance
         */
        IncomingMessage.prototype.expiry = 0;

        /**
         * IncomingMessage type.
         * @member {string} type
         * @memberof IncomingMessage
         * @instance
         */
        IncomingMessage.prototype.type = "";

        /**
         * Creates a new IncomingMessage instance using the specified properties.
         * @function create
         * @memberof IncomingMessage
         * @static
         * @param {IIncomingMessage=} [properties] Properties to set
         * @returns {IncomingMessage} IncomingMessage instance
         */
        IncomingMessage.create = function create(properties) {
            return new IncomingMessage(properties);
        };

        /**
         * Encodes the specified IncomingMessage message. Does not implicitly {@link IncomingMessage.verify|verify} messages.
         * @function encode
         * @memberof IncomingMessage
         * @static
         * @param {IncomingMessage} message IncomingMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IncomingMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.receivers != null && message.receivers.length)
                for (var i = 0; i < message.receivers.length; ++i)
                    $root.Receiver.encode(message.receivers[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.sender != null && message.hasOwnProperty("sender"))
                $root.Sender.encode(message.sender, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.body != null && message.hasOwnProperty("body"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.body);
            if (message.expiry != null && message.hasOwnProperty("expiry"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.expiry);
            if (message.type != null && message.hasOwnProperty("type"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.type);
            return writer;
        };

        /**
         * Decodes an IncomingMessage message from the specified reader or buffer.
         * @function decode
         * @memberof IncomingMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {IncomingMessage} IncomingMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IncomingMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.IncomingMessage();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.receivers && message.receivers.length))
                        message.receivers = [];
                    message.receivers.push($root.Receiver.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.sender = $root.Sender.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.body = reader.string();
                    break;
                case 4:
                    message.expiry = reader.uint32();
                    break;
                case 5:
                    message.type = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return IncomingMessage;
    })();

    $root.ChannelStatsRequest = (function() {

        /**
         * Properties of a ChannelStatsRequest.
         * @exports IChannelStatsRequest
         * @interface IChannelStatsRequest
         * @property {Array.<ChannelId>|null} [channels] ChannelStatsRequest channels
         */

        /**
         * Constructs a new ChannelStatsRequest.
         * @exports ChannelStatsRequest
         * @classdesc Represents a ChannelStatsRequest.
         * @implements IChannelStatsRequest
         * @constructor
         * @param {IChannelStatsRequest=} [properties] Properties to set
         */
        function ChannelStatsRequest(properties) {
            this.channels = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChannelStatsRequest channels.
         * @member {Array.<ChannelId>} channels
         * @memberof ChannelStatsRequest
         * @instance
         */
        ChannelStatsRequest.prototype.channels = $util.emptyArray;

        /**
         * Creates a new ChannelStatsRequest instance using the specified properties.
         * @function create
         * @memberof ChannelStatsRequest
         * @static
         * @param {IChannelStatsRequest=} [properties] Properties to set
         * @returns {ChannelStatsRequest} ChannelStatsRequest instance
         */
        ChannelStatsRequest.create = function create(properties) {
            return new ChannelStatsRequest(properties);
        };

        /**
         * Encodes the specified ChannelStatsRequest message. Does not implicitly {@link ChannelStatsRequest.verify|verify} messages.
         * @function encode
         * @memberof ChannelStatsRequest
         * @static
         * @param {ChannelStatsRequest} message ChannelStatsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelStatsRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.channels != null && message.channels.length)
                for (var i = 0; i < message.channels.length; ++i)
                    $root.ChannelId.encode(message.channels[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Decodes a ChannelStatsRequest message from the specified reader or buffer.
         * @function decode
         * @memberof ChannelStatsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ChannelStatsRequest} ChannelStatsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelStatsRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ChannelStatsRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.channels && message.channels.length))
                        message.channels = [];
                    message.channels.push($root.ChannelId.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return ChannelStatsRequest;
    })();

    $root.ChannelId = (function() {

        /**
         * Properties of a ChannelId.
         * @exports IChannelId
         * @interface IChannelId
         * @property {Uint8Array|null} [id] ChannelId id
         * @property {boolean|null} [isPrivate] ChannelId isPrivate
         * @property {Uint8Array|null} [signature] ChannelId signature
         */

        /**
         * Constructs a new ChannelId.
         * @exports ChannelId
         * @classdesc Represents a ChannelId.
         * @implements IChannelId
         * @constructor
         * @param {IChannelId=} [properties] Properties to set
         */
        function ChannelId(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChannelId id.
         * @member {Uint8Array} id
         * @memberof ChannelId
         * @instance
         */
        ChannelId.prototype.id = $util.newBuffer([]);

        /**
         * ChannelId isPrivate.
         * @member {boolean} isPrivate
         * @memberof ChannelId
         * @instance
         */
        ChannelId.prototype.isPrivate = false;

        /**
         * ChannelId signature.
         * @member {Uint8Array} signature
         * @memberof ChannelId
         * @instance
         */
        ChannelId.prototype.signature = $util.newBuffer([]);

        /**
         * Creates a new ChannelId instance using the specified properties.
         * @function create
         * @memberof ChannelId
         * @static
         * @param {IChannelId=} [properties] Properties to set
         * @returns {ChannelId} ChannelId instance
         */
        ChannelId.create = function create(properties) {
            return new ChannelId(properties);
        };

        /**
         * Encodes the specified ChannelId message. Does not implicitly {@link ChannelId.verify|verify} messages.
         * @function encode
         * @memberof ChannelId
         * @static
         * @param {ChannelId} message ChannelId message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelId.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && message.hasOwnProperty("id"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.id);
            if (message.isPrivate != null && message.hasOwnProperty("isPrivate"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.isPrivate);
            if (message.signature != null && message.hasOwnProperty("signature"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.signature);
            return writer;
        };

        /**
         * Decodes a ChannelId message from the specified reader or buffer.
         * @function decode
         * @memberof ChannelId
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ChannelId} ChannelId
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelId.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ChannelId();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.bytes();
                    break;
                case 2:
                    message.isPrivate = reader.bool();
                    break;
                case 3:
                    message.signature = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return ChannelId;
    })();

    $root.ServerStatsRequest = (function() {

        /**
         * Properties of a ServerStatsRequest.
         * @exports IServerStatsRequest
         * @interface IServerStatsRequest
         */

        /**
         * Constructs a new ServerStatsRequest.
         * @exports ServerStatsRequest
         * @classdesc Represents a ServerStatsRequest.
         * @implements IServerStatsRequest
         * @constructor
         * @param {IServerStatsRequest=} [properties] Properties to set
         */
        function ServerStatsRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new ServerStatsRequest instance using the specified properties.
         * @function create
         * @memberof ServerStatsRequest
         * @static
         * @param {IServerStatsRequest=} [properties] Properties to set
         * @returns {ServerStatsRequest} ServerStatsRequest instance
         */
        ServerStatsRequest.create = function create(properties) {
            return new ServerStatsRequest(properties);
        };

        /**
         * Encodes the specified ServerStatsRequest message. Does not implicitly {@link ServerStatsRequest.verify|verify} messages.
         * @function encode
         * @memberof ServerStatsRequest
         * @static
         * @param {ServerStatsRequest} message ServerStatsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServerStatsRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes a ServerStatsRequest message from the specified reader or buffer.
         * @function decode
         * @memberof ServerStatsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ServerStatsRequest} ServerStatsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServerStatsRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ServerStatsRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return ServerStatsRequest;
    })();

    $root.Sender = (function() {

        /**
         * Properties of a Sender.
         * @exports ISender
         * @interface ISender
         * @property {SenderType|null} [type] Sender type
         * @property {Uint8Array|null} [id] Sender id
         */

        /**
         * Constructs a new Sender.
         * @exports Sender
         * @classdesc Represents a Sender.
         * @implements ISender
         * @constructor
         * @param {ISender=} [properties] Properties to set
         */
        function Sender(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Sender type.
         * @member {SenderType} type
         * @memberof Sender
         * @instance
         */
        Sender.prototype.type = 0;

        /**
         * Sender id.
         * @member {Uint8Array} id
         * @memberof Sender
         * @instance
         */
        Sender.prototype.id = $util.newBuffer([]);

        /**
         * Creates a new Sender instance using the specified properties.
         * @function create
         * @memberof Sender
         * @static
         * @param {ISender=} [properties] Properties to set
         * @returns {Sender} Sender instance
         */
        Sender.create = function create(properties) {
            return new Sender(properties);
        };

        /**
         * Encodes the specified Sender message. Does not implicitly {@link Sender.verify|verify} messages.
         * @function encode
         * @memberof Sender
         * @static
         * @param {Sender} message Sender message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Sender.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && message.hasOwnProperty("type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            if (message.id != null && message.hasOwnProperty("id"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.id);
            return writer;
        };

        /**
         * Decodes a Sender message from the specified reader or buffer.
         * @function decode
         * @memberof Sender
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Sender} Sender
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Sender.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Sender();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                case 2:
                    message.id = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return Sender;
    })();

    /**
     * SenderType enum.
     * @exports SenderType
     * @enum {string}
     * @property {number} UNKNOWN=0 UNKNOWN value
     * @property {number} CLIENT=1 CLIENT value
     * @property {number} BACKEND=2 BACKEND value
     */
    $root.SenderType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "UNKNOWN"] = 0;
        values[valuesById[1] = "CLIENT"] = 1;
        values[valuesById[2] = "BACKEND"] = 2;
        return values;
    })();

    $root.Receiver = (function() {

        /**
         * Properties of a Receiver.
         * @exports IReceiver
         * @interface IReceiver
         * @property {Uint8Array|null} [id] Receiver id
         * @property {boolean|null} [isPrivate] Receiver isPrivate
         * @property {Uint8Array|null} [signature] Receiver signature
         */

        /**
         * Constructs a new Receiver.
         * @exports Receiver
         * @classdesc Represents a Receiver.
         * @implements IReceiver
         * @constructor
         * @param {IReceiver=} [properties] Properties to set
         */
        function Receiver(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Receiver id.
         * @member {Uint8Array} id
         * @memberof Receiver
         * @instance
         */
        Receiver.prototype.id = $util.newBuffer([]);

        /**
         * Receiver isPrivate.
         * @member {boolean} isPrivate
         * @memberof Receiver
         * @instance
         */
        Receiver.prototype.isPrivate = false;

        /**
         * Receiver signature.
         * @member {Uint8Array} signature
         * @memberof Receiver
         * @instance
         */
        Receiver.prototype.signature = $util.newBuffer([]);

        /**
         * Creates a new Receiver instance using the specified properties.
         * @function create
         * @memberof Receiver
         * @static
         * @param {IReceiver=} [properties] Properties to set
         * @returns {Receiver} Receiver instance
         */
        Receiver.create = function create(properties) {
            return new Receiver(properties);
        };

        /**
         * Encodes the specified Receiver message. Does not implicitly {@link Receiver.verify|verify} messages.
         * @function encode
         * @memberof Receiver
         * @static
         * @param {Receiver} message Receiver message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Receiver.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && message.hasOwnProperty("id"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.id);
            if (message.isPrivate != null && message.hasOwnProperty("isPrivate"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.isPrivate);
            if (message.signature != null && message.hasOwnProperty("signature"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.signature);
            return writer;
        };

        /**
         * Decodes a Receiver message from the specified reader or buffer.
         * @function decode
         * @memberof Receiver
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Receiver} Receiver
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Receiver.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Receiver();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.bytes();
                    break;
                case 2:
                    message.isPrivate = reader.bool();
                    break;
                case 3:
                    message.signature = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return Receiver;
    })();

    $root.ResponseBatch = (function() {

        /**
         * Properties of a ResponseBatch.
         * @exports IResponseBatch
         * @interface IResponseBatch
         * @property {Array.<Response>|null} [responses] ResponseBatch responses
         */

        /**
         * Constructs a new ResponseBatch.
         * @exports ResponseBatch
         * @classdesc Represents a ResponseBatch.
         * @implements IResponseBatch
         * @constructor
         * @param {IResponseBatch=} [properties] Properties to set
         */
        function ResponseBatch(properties) {
            this.responses = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ResponseBatch responses.
         * @member {Array.<Response>} responses
         * @memberof ResponseBatch
         * @instance
         */
        ResponseBatch.prototype.responses = $util.emptyArray;

        /**
         * Creates a new ResponseBatch instance using the specified properties.
         * @function create
         * @memberof ResponseBatch
         * @static
         * @param {IResponseBatch=} [properties] Properties to set
         * @returns {ResponseBatch} ResponseBatch instance
         */
        ResponseBatch.create = function create(properties) {
            return new ResponseBatch(properties);
        };

        /**
         * Encodes the specified ResponseBatch message. Does not implicitly {@link ResponseBatch.verify|verify} messages.
         * @function encode
         * @memberof ResponseBatch
         * @static
         * @param {ResponseBatch} message ResponseBatch message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResponseBatch.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.responses != null && message.responses.length)
                for (var i = 0; i < message.responses.length; ++i)
                    $root.Response.encode(message.responses[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Decodes a ResponseBatch message from the specified reader or buffer.
         * @function decode
         * @memberof ResponseBatch
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ResponseBatch} ResponseBatch
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResponseBatch.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ResponseBatch();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.responses && message.responses.length))
                        message.responses = [];
                    message.responses.push($root.Response.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return ResponseBatch;
    })();

    $root.Response = (function() {

        /**
         * Properties of a Response.
         * @exports IResponse
         * @interface IResponse
         * @property {OutgoingMessagesResponse|null} [outgoingMessages] Response outgoingMessages
         * @property {ChannelStatsResponse|null} [channelStats] Response channelStats
         * @property {JsonResponse|null} [serverStats] Response serverStats
         */

        /**
         * Constructs a new Response.
         * @exports Response
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response outgoingMessages.
         * @member {OutgoingMessagesResponse|null|undefined} outgoingMessages
         * @memberof Response
         * @instance
         */
        Response.prototype.outgoingMessages = null;

        /**
         * Response channelStats.
         * @member {ChannelStatsResponse|null|undefined} channelStats
         * @memberof Response
         * @instance
         */
        Response.prototype.channelStats = null;

        /**
         * Response serverStats.
         * @member {JsonResponse|null|undefined} serverStats
         * @memberof Response
         * @instance
         */
        Response.prototype.serverStats = null;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * Response command.
         * @member {"outgoingMessages"|"channelStats"|"serverStats"|undefined} command
         * @memberof Response
         * @instance
         */
        Object.defineProperty(Response.prototype, "command", {
            get: $util.oneOfGetter($oneOfFields = ["outgoingMessages", "channelStats", "serverStats"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof Response
         * @static
         * @param {IResponse=} [properties] Properties to set
         * @returns {Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link Response.verify|verify} messages.
         * @function encode
         * @memberof Response
         * @static
         * @param {Response} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.outgoingMessages != null && message.hasOwnProperty("outgoingMessages"))
                $root.OutgoingMessagesResponse.encode(message.outgoingMessages, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.channelStats != null && message.hasOwnProperty("channelStats"))
                $root.ChannelStatsResponse.encode(message.channelStats, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.serverStats != null && message.hasOwnProperty("serverStats"))
                $root.JsonResponse.encode(message.serverStats, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.outgoingMessages = $root.OutgoingMessagesResponse.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.channelStats = $root.ChannelStatsResponse.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.serverStats = $root.JsonResponse.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return Response;
    })();

    $root.OutgoingMessagesResponse = (function() {

        /**
         * Properties of an OutgoingMessagesResponse.
         * @exports IOutgoingMessagesResponse
         * @interface IOutgoingMessagesResponse
         * @property {Array.<OutgoingMessage>|null} [messages] OutgoingMessagesResponse messages
         */

        /**
         * Constructs a new OutgoingMessagesResponse.
         * @exports OutgoingMessagesResponse
         * @classdesc Represents an OutgoingMessagesResponse.
         * @implements IOutgoingMessagesResponse
         * @constructor
         * @param {IOutgoingMessagesResponse=} [properties] Properties to set
         */
        function OutgoingMessagesResponse(properties) {
            this.messages = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * OutgoingMessagesResponse messages.
         * @member {Array.<OutgoingMessage>} messages
         * @memberof OutgoingMessagesResponse
         * @instance
         */
        OutgoingMessagesResponse.prototype.messages = $util.emptyArray;

        /**
         * Creates a new OutgoingMessagesResponse instance using the specified properties.
         * @function create
         * @memberof OutgoingMessagesResponse
         * @static
         * @param {IOutgoingMessagesResponse=} [properties] Properties to set
         * @returns {OutgoingMessagesResponse} OutgoingMessagesResponse instance
         */
        OutgoingMessagesResponse.create = function create(properties) {
            return new OutgoingMessagesResponse(properties);
        };

        /**
         * Encodes the specified OutgoingMessagesResponse message. Does not implicitly {@link OutgoingMessagesResponse.verify|verify} messages.
         * @function encode
         * @memberof OutgoingMessagesResponse
         * @static
         * @param {OutgoingMessagesResponse} message OutgoingMessagesResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OutgoingMessagesResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.messages != null && message.messages.length)
                for (var i = 0; i < message.messages.length; ++i)
                    $root.OutgoingMessage.encode(message.messages[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Decodes an OutgoingMessagesResponse message from the specified reader or buffer.
         * @function decode
         * @memberof OutgoingMessagesResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {OutgoingMessagesResponse} OutgoingMessagesResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OutgoingMessagesResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.OutgoingMessagesResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.messages && message.messages.length))
                        message.messages = [];
                    message.messages.push($root.OutgoingMessage.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return OutgoingMessagesResponse;
    })();

    $root.OutgoingMessage = (function() {

        /**
         * Properties of an OutgoingMessage.
         * @exports IOutgoingMessage
         * @interface IOutgoingMessage
         * @property {Uint8Array|null} [id] OutgoingMessage id
         * @property {string|null} [body] OutgoingMessage body
         * @property {number|null} [expiry] OutgoingMessage expiry
         * @property {number|null} [created] OutgoingMessage created
         * @property {Sender|null} [sender] OutgoingMessage sender
         */

        /**
         * Constructs a new OutgoingMessage.
         * @exports OutgoingMessage
         * @classdesc Represents an OutgoingMessage.
         * @implements IOutgoingMessage
         * @constructor
         * @param {IOutgoingMessage=} [properties] Properties to set
         */
        function OutgoingMessage(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * OutgoingMessage id.
         * @member {Uint8Array} id
         * @memberof OutgoingMessage
         * @instance
         */
        OutgoingMessage.prototype.id = $util.newBuffer([]);

        /**
         * OutgoingMessage body.
         * @member {string} body
         * @memberof OutgoingMessage
         * @instance
         */
        OutgoingMessage.prototype.body = "";

        /**
         * OutgoingMessage expiry.
         * @member {number} expiry
         * @memberof OutgoingMessage
         * @instance
         */
        OutgoingMessage.prototype.expiry = 0;

        /**
         * OutgoingMessage created.
         * @member {number} created
         * @memberof OutgoingMessage
         * @instance
         */
        OutgoingMessage.prototype.created = 0;

        /**
         * OutgoingMessage sender.
         * @member {Sender|null|undefined} sender
         * @memberof OutgoingMessage
         * @instance
         */
        OutgoingMessage.prototype.sender = null;

        /**
         * Creates a new OutgoingMessage instance using the specified properties.
         * @function create
         * @memberof OutgoingMessage
         * @static
         * @param {IOutgoingMessage=} [properties] Properties to set
         * @returns {OutgoingMessage} OutgoingMessage instance
         */
        OutgoingMessage.create = function create(properties) {
            return new OutgoingMessage(properties);
        };

        /**
         * Encodes the specified OutgoingMessage message. Does not implicitly {@link OutgoingMessage.verify|verify} messages.
         * @function encode
         * @memberof OutgoingMessage
         * @static
         * @param {OutgoingMessage} message OutgoingMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OutgoingMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && message.hasOwnProperty("id"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.id);
            if (message.body != null && message.hasOwnProperty("body"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.body);
            if (message.expiry != null && message.hasOwnProperty("expiry"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.expiry);
            if (message.created != null && message.hasOwnProperty("created"))
                writer.uint32(/* id 4, wireType 5 =*/37).fixed32(message.created);
            if (message.sender != null && message.hasOwnProperty("sender"))
                $root.Sender.encode(message.sender, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            return writer;
        };

        /**
         * Decodes an OutgoingMessage message from the specified reader or buffer.
         * @function decode
         * @memberof OutgoingMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {OutgoingMessage} OutgoingMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OutgoingMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.OutgoingMessage();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.bytes();
                    break;
                case 2:
                    message.body = reader.string();
                    break;
                case 3:
                    message.expiry = reader.uint32();
                    break;
                case 4:
                    message.created = reader.fixed32();
                    break;
                case 5:
                    message.sender = $root.Sender.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return OutgoingMessage;
    })();

    $root.ChannelStatsResponse = (function() {

        /**
         * Properties of a ChannelStatsResponse.
         * @exports IChannelStatsResponse
         * @interface IChannelStatsResponse
         * @property {Array.<ChannelStats>|null} [channels] ChannelStatsResponse channels
         */

        /**
         * Constructs a new ChannelStatsResponse.
         * @exports ChannelStatsResponse
         * @classdesc Represents a ChannelStatsResponse.
         * @implements IChannelStatsResponse
         * @constructor
         * @param {IChannelStatsResponse=} [properties] Properties to set
         */
        function ChannelStatsResponse(properties) {
            this.channels = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChannelStatsResponse channels.
         * @member {Array.<ChannelStats>} channels
         * @memberof ChannelStatsResponse
         * @instance
         */
        ChannelStatsResponse.prototype.channels = $util.emptyArray;

        /**
         * Creates a new ChannelStatsResponse instance using the specified properties.
         * @function create
         * @memberof ChannelStatsResponse
         * @static
         * @param {IChannelStatsResponse=} [properties] Properties to set
         * @returns {ChannelStatsResponse} ChannelStatsResponse instance
         */
        ChannelStatsResponse.create = function create(properties) {
            return new ChannelStatsResponse(properties);
        };

        /**
         * Encodes the specified ChannelStatsResponse message. Does not implicitly {@link ChannelStatsResponse.verify|verify} messages.
         * @function encode
         * @memberof ChannelStatsResponse
         * @static
         * @param {ChannelStatsResponse} message ChannelStatsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelStatsResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.channels != null && message.channels.length)
                for (var i = 0; i < message.channels.length; ++i)
                    $root.ChannelStats.encode(message.channels[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Decodes a ChannelStatsResponse message from the specified reader or buffer.
         * @function decode
         * @memberof ChannelStatsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ChannelStatsResponse} ChannelStatsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelStatsResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ChannelStatsResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.channels && message.channels.length))
                        message.channels = [];
                    message.channels.push($root.ChannelStats.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return ChannelStatsResponse;
    })();

    $root.ChannelStats = (function() {

        /**
         * Properties of a ChannelStats.
         * @exports IChannelStats
         * @interface IChannelStats
         * @property {Uint8Array|null} [id] ChannelStats id
         * @property {boolean|null} [isPrivate] ChannelStats isPrivate
         * @property {boolean|null} [isOnline] ChannelStats isOnline
         */

        /**
         * Constructs a new ChannelStats.
         * @exports ChannelStats
         * @classdesc Represents a ChannelStats.
         * @implements IChannelStats
         * @constructor
         * @param {IChannelStats=} [properties] Properties to set
         */
        function ChannelStats(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChannelStats id.
         * @member {Uint8Array} id
         * @memberof ChannelStats
         * @instance
         */
        ChannelStats.prototype.id = $util.newBuffer([]);

        /**
         * ChannelStats isPrivate.
         * @member {boolean} isPrivate
         * @memberof ChannelStats
         * @instance
         */
        ChannelStats.prototype.isPrivate = false;

        /**
         * ChannelStats isOnline.
         * @member {boolean} isOnline
         * @memberof ChannelStats
         * @instance
         */
        ChannelStats.prototype.isOnline = false;

        /**
         * Creates a new ChannelStats instance using the specified properties.
         * @function create
         * @memberof ChannelStats
         * @static
         * @param {IChannelStats=} [properties] Properties to set
         * @returns {ChannelStats} ChannelStats instance
         */
        ChannelStats.create = function create(properties) {
            return new ChannelStats(properties);
        };

        /**
         * Encodes the specified ChannelStats message. Does not implicitly {@link ChannelStats.verify|verify} messages.
         * @function encode
         * @memberof ChannelStats
         * @static
         * @param {ChannelStats} message ChannelStats message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelStats.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && message.hasOwnProperty("id"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.id);
            if (message.isPrivate != null && message.hasOwnProperty("isPrivate"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.isPrivate);
            if (message.isOnline != null && message.hasOwnProperty("isOnline"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.isOnline);
            return writer;
        };

        /**
         * Decodes a ChannelStats message from the specified reader or buffer.
         * @function decode
         * @memberof ChannelStats
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ChannelStats} ChannelStats
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelStats.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ChannelStats();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.bytes();
                    break;
                case 2:
                    message.isPrivate = reader.bool();
                    break;
                case 3:
                    message.isOnline = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return ChannelStats;
    })();

    $root.JsonResponse = (function() {

        /**
         * Properties of a JsonResponse.
         * @exports IJsonResponse
         * @interface IJsonResponse
         * @property {string|null} [json] JsonResponse json
         */

        /**
         * Constructs a new JsonResponse.
         * @exports JsonResponse
         * @classdesc Represents a JsonResponse.
         * @implements IJsonResponse
         * @constructor
         * @param {IJsonResponse=} [properties] Properties to set
         */
        function JsonResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * JsonResponse json.
         * @member {string} json
         * @memberof JsonResponse
         * @instance
         */
        JsonResponse.prototype.json = "";

        /**
         * Creates a new JsonResponse instance using the specified properties.
         * @function create
         * @memberof JsonResponse
         * @static
         * @param {IJsonResponse=} [properties] Properties to set
         * @returns {JsonResponse} JsonResponse instance
         */
        JsonResponse.create = function create(properties) {
            return new JsonResponse(properties);
        };

        /**
         * Encodes the specified JsonResponse message. Does not implicitly {@link JsonResponse.verify|verify} messages.
         * @function encode
         * @memberof JsonResponse
         * @static
         * @param {JsonResponse} message JsonResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        JsonResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.json != null && message.hasOwnProperty("json"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.json);
            return writer;
        };

        /**
         * Decodes a JsonResponse message from the specified reader or buffer.
         * @function decode
         * @memberof JsonResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {JsonResponse} JsonResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        JsonResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.JsonResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.json = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return JsonResponse;
    })();

    return $root;
})(
	typeof window==="object" && typeof window.protobuf==='object' && window.protobuf
	|| typeof self==="object" && typeof self.protobuf==='object' && self.protobuf
	|| typeof protobuf==='object' && protobuf
);




// file: /bitrix/js/main/core/core_promise.js
;(function(window)
{
	/****************** ATTENTION *******************************
	 * Please do not use Bitrix CoreJS in this class.
	 * This class can be called on page without Bitrix Framework
	*************************************************************/

	if (!window.BX)
	{
		window.BX = {};
	}

	var BX = window.BX;

	BX.Promise = function(fn, ctx) // fn is future-reserved
	{
		this.state = null;
		this.value = null;
		this.reason = null;
		this.next = null;
		this.ctx = ctx || this;

		this.onFulfilled = [];
		this.onRejected = [];
	};
	BX.Promise.prototype.fulfill = function(value)
	{
		this.checkState();

		this.value = value;
		this.state = true;
		this.execute();
	};
	BX.Promise.prototype.reject = function(reason)
	{
		this.checkState();

		this.reason = reason;
		this.state = false;
		this.execute();
	};
	BX.Promise.prototype.then = function(onFulfilled, onRejected)
	{
		if(typeof (onFulfilled) == "function" || onFulfilled instanceof Function)
		{
			this.onFulfilled.push(onFulfilled);
		}
		if(typeof (onRejected) == "function" || onRejected instanceof Function)
		{
			this.onRejected.push(onRejected);
		}

		if(this.next === null)
		{
			this.next = new BX.Promise(null, this.ctx);
		}

		if(this.state !== null) // if promise was already resolved, execute immediately
		{
			this.execute();
		}

		return this.next;
	};

	BX.Promise.prototype.catch = function(onRejected)
	{
		if(typeof (onRejected) == "function" || onRejected instanceof Function)
		{
			this.onRejected.push(onRejected);
		}

		if(this.next === null)
		{
			this.next = new BX.Promise(null, this.ctx);
		}

		if(this.state !== null) // if promise was already resolved, execute immediately
		{
			this.execute();
		}

		return this.next;
	};

	BX.Promise.prototype.setAutoResolve = function(way, ms)
	{
		this.timer = setTimeout(function(){
			if(this.state === null)
			{
				this[way ? 'fulfill' : 'reject']();
			}
		}.bind(this), ms || 15);
	};
	BX.Promise.prototype.cancelAutoResolve = function()
	{
		clearTimeout(this.timer);
	};
	/**
	 * Resolve function. This function allows promise chaining, like ..then().then()...
	 * Typical usage:
	 *
	 * var p = new Promise();
	 *
	 * p.then(function(value){
	 *  return someValue; // next promise in the chain will be fulfilled with someValue
	 * }).then(function(value){
	 *
	 *  var p1 = new Promise();
	 *  *** some async code here, that eventually resolves p1 ***
	 *
	 *  return p1; // chain will resume when p1 resolved (fulfilled or rejected)
	 * }).then(function(value){
	 *
	 *  // you can also do
	 *  var e = new Error();
	 *  throw e;
	 *  // it will cause next promise to be rejected with e
	 *
	 *  return someOtherValue;
	 * }).then(function(value){
	 *  ...
	 * }, function(reason){
	 *  // promise was rejected with reason
	 * })...;
	 *
	 * p.fulfill('let`s start this chain');
	 *
	 * @param x
	 */
	BX.Promise.prototype.resolve = function(x)
	{
		var this_ = this;

		if(this === x)
		{
			this.reject(new TypeError('Promise cannot fulfill or reject itself')); // avoid recursion
		}
		// allow "pausing" promise chaining until promise x is fulfilled or rejected
		else if(x && x.toString() === "[object BX.Promise]")
		{
			x.then(function(value){
				this_.fulfill(value);
			}, function(reason){
				this_.reject(reason);
			});
		}
		else // auto-fulfill this promise
		{
			this.fulfill(x);
		}
	};

	BX.Promise.prototype.toString = function()
	{
		return "[object BX.Promise]";
	};

	BX.Promise.prototype.execute = function()
	{
		if(this.state === null)
		{
			//then() must not be called before BX.Promise resolve() happens
			return;
		}

		var value = undefined;
		var reason = undefined;
		var x = undefined;
		var k;
		if(this.state === true) // promise was fulfill()-ed
		{
			if(this.onFulfilled.length)
			{
				try
				{
					for(k = 0; k < this.onFulfilled.length; k++)
					{
						x = this.onFulfilled[k].apply(this.ctx, [this.value]);
						if(typeof x != 'undefined')
						{
							value = x;
						}
					}
				}
				catch(e)
				{
					if('console' in window)
					{
						console.dir(e);
					}

					if (typeof BX.debug !== 'undefined')
					{
						BX.debug(e);
					}

					reason = e; // reject next
				}
			}
			else
			{
				value = this.value; // resolve next
			}
		}
		else if(this.state === false) // promise was reject()-ed
		{
			if(this.onRejected.length)
			{
				try
				{
					for(k = 0; k < this.onRejected.length; k++)
					{
						x = this.onRejected[k].apply(this.ctx, [this.reason]);
						if(typeof x != 'undefined')
						{
							value = x;
						}
					}
				}
				catch(e)
				{
					if('console' in window)
					{
						console.dir(e);
					}

					if (typeof BX.debug !== 'undefined')
					{
						BX.debug(e);
					}

					reason = e; // reject next
				}
			}
			else
			{
				reason = this.reason; // reject next
			}
		}

		if(this.next !== null)
		{
			if(typeof reason != 'undefined')
			{
				this.next.reject(reason);
			}
			else if(typeof value != 'undefined')
			{
				this.next.resolve(value);
			}
		}
	};
	BX.Promise.prototype.checkState = function()
	{
		if(this.state !== null)
		{
			throw new Error('You can not do fulfill() or reject() multiple times');
		}
	};
})(window);





// file: /bitrix/js/rest/client/rest.client.js
'use strict';

;(function(){

	/************************ ATTENTION ***************************
	 * Please do not use Bitrix CoreJS in this class.            *
	 * This class can be called on page without Bitrix Framework *
	**************************************************************/

	if (!window.BX)
	{
		window.BX = {};
	}
	else if (window.BX.RestClient)
	{
		return;
	}

	var BX = window.BX;

	BX.RestClient = function (options)
	{
		options = options || {};

		this.endpoint = options.endpoint || '/rest';
		this.queryParams = options.queryParams || '';
		this.cors = options.cors === true;
	};

	BX.RestClient.prototype.callMethod = function(method, params, callback, sendCallback, logTag)
	{
		return ajax({
			method: method,
			data: params,
			callback: callback,
			sendCallback: sendCallback,
			logTag: logTag,
			endpoint: this.endpoint,
			queryParams: this.queryParams,
			cors: this.cors
		});
	};

	/*
	calls = [[method,params],[method,params]];
	calls = [{method:method,params:params},[method,params]];
	calls = {call_id:[method,params],...};
	*/
	BX.RestClient.prototype.callBatch = function(calls, callback, bHaltOnError, sendCallback, logTag)
	{
		var cmd = Utils.isArray(calls) ? [] : {};
		var cnt = 0;
		var cb = function(cmd) {
			ajax.batch(cmd, callback, bHaltOnError, sendCallback, this.endpoint, this.queryParams, this.cors, logTag);
		}.bind(this);

		for(var i in calls)
		{
			var method = null, params = null;

			if(!!calls[i] && calls.hasOwnProperty(i))
			{
				if(Utils.isArray(calls[i]))
				{
					method = calls[i][0];
					params = calls[i][1];
				}
				else if(!!calls[i].method)
				{
					method = calls[i].method;
					params = calls[i].params;
				}

				if(!!method)
				{
					cnt++;
					cmd[i] = [method, params];
				}
			}
		}

		if(cnt > 0)
		{
			var e = function(i)
			{
				return function(str)
				{
					cmd[i] = cmd[i][0] + '?' + str;
					if(--cnt <= 0)
						cb(cmd);
				}
			};

			for(var c in cmd)
			{
				if(cmd.hasOwnProperty(c))
				{
					ajax.prepareData(cmd[c][1], '', e(c));
				}
			}
		}
	};

	BX.RestClient.prototype.setEndpoint = function(url)
	{
		this.endpoint = url;
	};

	BX.RestClient.prototype.enableCorsRequest = function(value)
	{
		this.cors = value === true;
	};

	BX.RestClient.prototype.setQueryParams = function(params)
	{
		this.queryParams = params;
	};

	/* self init for bitrix env */
	if (typeof BX.namespace !== 'undefined')
	{
		var BXRest = new BX.RestClient();

		if (typeof BX.rest == 'undefined')
		{
			BX.rest = {};
		}

		BX.rest.callMethod = function (method, params, callback, sendCallback, logTag)
		{
			return BXRest.callMethod(method, params, callback, sendCallback, logTag);
		};

		/*
		calls = [[method,params],[method,params]];
		calls = [{method:method,params:params},[method,params]];
		calls = {call_id:[method,params],...};
		*/
		BX.rest.callBatch = function (calls, callback, bHaltOnError, sendCallback, logTag)
		{
			return BXRest.callBatch(calls, callback, bHaltOnError, sendCallback, logTag);
		};
	}

	var Utils = {
		isArray: function(item) {
			return item && Object.prototype.toString.call(item) == "[object Array]";
		},
		isFunction: function(item) {
			return item === null ? false : (typeof (item) == "function" || item instanceof Function);
		},
		isString: function(item) {
			return item === '' ? true : (item ? (typeof (item) == "string" || item instanceof String) : false);
		},
		isDomNode: function(item) {
			return item && typeof (item) == "object" && "nodeType" in item;
		},
		isDate: function(item) {
			return item && Object.prototype.toString.call(item) == "[object Date]";
		},
		buildQueryString: function(params)
		{
			var result = '';
			for (var key in params)
			{
				if (!params.hasOwnProperty(key))
				{
					continue;
				}
				var value = params[key];
				if(this.isArray(value))
				{
					value.forEach(function(valueElement, index)
					{
						result += encodeURIComponent(key + "[" + index + "]") + "=" + encodeURIComponent(valueElement) + "&";
					});
				}
				else
				{
					result += encodeURIComponent(key) + "=" + encodeURIComponent(value) + "&";
				}
			}

			if(result.length > 0)
			{
				result = result.substr(0, result.length - 1);
			}
			return result;
		},
		clone: function(obj, bCopyObj)
		{
			var _obj, i, l;
			if (bCopyObj !== false)
				bCopyObj = true;

			if (obj === null)
				return null;

			if (this.isDomNode(obj))
			{
				_obj = obj.cloneNode(bCopyObj);
			}
			else if (typeof obj == 'object')
			{
				if (this.isArray(obj))
				{
					_obj = [];
					for (i=0,l=obj.length;i<l;i++)
					{
						if (typeof obj[i] == "object" && bCopyObj)
							_obj[i] = this.clone(obj[i], bCopyObj);
						else
							_obj[i] = obj[i];
					}
				}
				else
				{
					_obj =  {};
					if (obj.constructor)
					{
						if (this.isDate(obj))
							_obj = new Date(obj);
						else
							_obj = new obj.constructor();
					}

					for (i in obj)
					{
						if (typeof obj[i] == "object" && bCopyObj)
							_obj[i] = this.clone(obj[i], bCopyObj);
						else
							_obj[i] = obj[i];
					}
				}

			}
			else
			{
				_obj = obj;
			}

			return _obj;
		}
	};

	var ajax = function(config)
	{
		var hasCallback = !!config.callback && Utils.isFunction(config.callback);
		var promise = typeof BX.Promise === 'undefined' || hasCallback? null: new BX.Promise();
		var sendCallback = config.sendCallback || function() {};
		var withoutRestoringCsrf = config.withoutRestoringCsrf || false;
		var loginAttempt = config.loginAttempt || 0;

		var xhr = ajax.xhr();

		var url = config.endpoint + '/' + ajax.escape(config.method) + '.json'+(config.logTag? '?logTag='+config.logTag: '');

		xhr.open('POST', url);
		xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');

		if (config.cors)
		{
			xhr.withCredentials = true;
		}

		var bRequestCompleted = false;

		// IE fix
		xhr.onprogress = function(){};
		xhr.ontimeout = function(){};
		xhr.timeout = 0;

		xhr.onload = function()
		{
			if(bRequestCompleted)
				return;

			xhr.onload = function() {};

			var bSuccess = ajax.isSuccess(xhr);

			var status = xhr.status;
			if(bSuccess)
			{
				var data = xhr.responseText;

				if(data.length > 0)
				{
					try
					{
						data = JSON.parse(data);
					}
					catch(e)
					{
						bSuccess = false;
					}
				}

				if (status == 401)
				{
					if (data.extended_error === 'user_not_authorized' && loginAttempt === 0)
					{
						if (data.sessid)
						{
							console.warn('BX.rest: csrf-token has expired, replace to a new token');
							BX.message({'bitrix_sessid': data.sessid});
						}

						if('BXDesktopSystem' in window)
						{
							console.warn('BX.rest: you are not authorized, trying to log in');
							config.loginAttempt = 1;
							BXDesktopSystem.Login({
								// todo: support auth failure callback in future (when it is ready)
								success: function()
								{
									console.warn('BX.rest: successfully logged in, repeating request');
									if (!hasCallback)
									{
										config.callback = function(result)
										{
											if (result.error())
											{
												promise.reject(result);
											}
											else
											{
												promise.fulfill(result);
											}
										}
									}
									ajax(config);
								}
							});
							return true;
						}
					}
					else if (data.sessid && !withoutRestoringCsrf)
					{
						BX.message({'bitrix_sessid': data.sessid});
						console.warn('BX.rest: your csrf-token has expired, send query with a new token');

						config.withoutRestoringCsrf = true;

						if (!hasCallback)
						{
							config.callback = function(result)
							{
								if (result.error())
								{
									promise.reject(result);
								}
								else
								{
									promise.fulfill(result);
								}
							}
						}
						ajax(config);

						return true;
					}
				}
				else if (status == 0)
				{
					data = {result: {}, error: "ERROR_NETWORK", error_description: "A network error occurred while the request was being executed."};
				}
				else
				{
					if (status == 200)
					{
						if (data.length <= 0)
						{
							data = {result: {}, error: "BLANK_ANSWER", error_description: "Empty answer with correct http code, network error possible."};
						}
					}
					else if (data.length <= 0)
					{
						data = {result: {}, error: "BLANK_ANSWER_WITH_ERROR_CODE", error_description: 'Empty answer with error http code: '+status};
					}
				}
			}

			xhr = null;
			if(bSuccess)
			{
				var res = new ajaxResult(data, config, status);
				if(hasCallback)
				{
					config.callback.apply(window, [res]);
				}
				else
				{
					if (res.error())
					{
						promise.reject(res);
					}
					else
					{
						promise.fulfill(res);
					}
				}
			}
			else
			{
				var res = new ajaxResult({
					error: "ERROR_UNEXPECTED_ANSWER",
					error_description: "Server returned an unexpected response.",
					ex: {}
				}, config, 0);
				if(hasCallback)
				{
					config.callback.apply(window, [res]);
				}
				else
				{
					promise.reject(res);
				}
			}
		};

		xhr.onerror = function(e)
		{
			var res = new ajaxResult({
				error: "ERROR_NETWORK",
				error_description: "A network error occurred while the request was being executed.",
				ex: e
			}, config, 0);
			if(hasCallback)
			{
				config.callback.apply(window, [res]);
			}
			else
			{
				promise.reject(res);
			}
		};

		var query_data = '';
		if (config.queryParams)
		{
			query_data = Utils.buildQueryString(config.queryParams);
		}
		else if (typeof BX.bitrix_sessid !== 'undefined')
		{
			query_data = 'sessid=' + BX.bitrix_sessid();
		}

		if(typeof config.start !== 'undefined')
		{
			query_data += '&start=' + parseInt(config.start);
		}

		if(!!config.data)
		{
			ajax.prepareData(config.data, '', function(res)
			{
				query_data += '&' + res;
				xhr.send(query_data);
				sendCallback(xhr);
			});
		}
		else
		{
			xhr.send(query_data);
			sendCallback(xhr);
		}

		return hasCallback || !promise? xhr: promise;
	};

	ajax.batch = function(calls, callback, bHaltOnError, sendCallback, endpoint, queryParams, cors, logTag)
	{
		return ajax({
			method: 'batch',
			data: {halt: !!bHaltOnError ? 1 : 0, cmd: calls},
			callback: function(res, config, status)
			{
				if(!callback)
				{
					return false;
				}

				var error = res.error();
				var data = res.data();
				var result = Utils.isArray(calls) ? [] : {};

				for(var i in calls)
				{
					if(!!calls[i] && calls.hasOwnProperty(i))
					{
						if(Utils.isString(calls[i]))
						{
							var q = calls[i].split('?');
						}
						else
						{
							q = [
								Utils.isArray(calls[i]) ? calls[i][0] : calls[i].method,
								Utils.isArray(calls[i]) ? calls[i][1] : calls[i].data
							];
						}

						if (
							data
							&& typeof data.result !== 'undefined'
							&& (
								typeof data.result[i] !== 'undefined'
								|| typeof data.result_error[i] !== 'undefined'
							)
						)
						{
							result[i] = new ajaxResult({
								result: typeof data.result[i] !== 'undefined' ? data.result[i] : {},
								error: data.result_error[i] || undefined,
								total: data.result_total[i],
								time: data.result_time[i],
								next: data.result_next[i]
							}, {
								method: q[0],
								data: q[1],
								callback: callback,
								endpoint: endpoint,
								queryParams: queryParams,
								cors: cors
							}, res.status);
						}
						else if (error)
						{
							result[i] = new ajaxResult({
								result: {},
								error: error.ex,
								total: 0
							}, {
								method: q[0],
								data: q[1],
								callback: callback,
								endpoint: endpoint,
								queryParams: queryParams,
								cors: cors
							}, res.status);
						}
					}
				}

				callback.apply(window, [result]);
			},
			sendCallback: sendCallback,
			endpoint: endpoint,
			queryParams: queryParams,
			cors: cors,
			logTag: logTag
		});
	};

	ajax.xhr = function()
	{
		return new XMLHttpRequest();
	};

	ajax.escape = function(str)
	{
		return encodeURIComponent(str);
	};

	ajax.prepareData = function(arData, prefix, callback)
	{
		var data = '', objects = [];
		if(Utils.isString(arData) || arData === null)
		{
			callback.call(document, arData || '');
		}
		else
		{
			for(var i in arData)
			{
				if(!arData.hasOwnProperty(i))
				{
					continue;
				}

				var name = ajax.escape(i);

				if(prefix)
					name = prefix + '[' + name + ']';

				if(typeof arData[i] === 'object')
				{
					if(Utils.isArray(arData[i]) && arData[i].length <= 0)
					{
						continue;
					}

					objects.push([name, arData[i]]);
				}
				else
				{
					if(data.length > 0)
					{
						data += '&';
					}

					if(typeof arData[i] === 'boolean')
					{
						data += name + '=' + (arData[i]? 1: 0);
					}
					else
					{
						data += name + '=' + ajax.escape(arData[i])
					}
				}
			}

			var cnt = objects.length;
			if(cnt > 0)
			{
				var cb = function(str)
				{
					data += (!!str ? '&' : '') + str;
					if(--cnt <= 0)
					{
						callback.call(document, data)
					}
				};

				var cnt1 = cnt;
				for(var i = 0; i < cnt1; i++)
				{
					if(Utils.isDomNode(objects[i][1]))
					{
						if(objects[i][1].tagName.toUpperCase() === 'INPUT' && objects[i][1].type === 'file')
						{
							if(fileReader.canUse())
							{
								fileReader(objects[i][1], (function(name)
								{
									return function(result)
									{
										if(Utils.isArray(result) && result.length > 0)
										{
											cb(name + '[0]=' + ajax.escape(result[0]) + '&' + name + '[1]=' + ajax.escape(result[1]));
										}
										else
										{
											cb(name + '=');
										}
									}
								})(objects[i][0]));
							}
						}
						else if(typeof objects[i][1].value !== 'undefined')
						{
							cb(objects[i][0] + '=' + ajax.escape(objects[i][1].value));
						}
						else
						{
							cb('');
						}
					}
					else if(Utils.isDate(objects[i][1]))
					{
						cb(objects[i][0] + '=' + ajax.escape(objects[i][1].toJSON()));
					}
					else if(Utils.isArray(objects[i][1]) && objects[i][1].length <= 0)
					{
						cb(objects[i][0] + '=');
					}
					else
					{
						ajax.prepareData(objects[i][1], objects[i][0], cb);
					}
				}
			}
			else
			{
				callback.call(document, data)
			}
		}
	};

	ajax.isSuccess = function(xhr)
	{
		return typeof xhr.status === 'undefined' || (xhr.status >= 200 && xhr.status < 300) || xhr.status === 304 || xhr.status >= 400 && xhr.status < 500 || xhr.status === 1223 || xhr.status === 0;
	};

	var ajaxResult = function(answer, query, status)
	{
		this.answer = answer;
		this.query = Utils.clone(query);
		this.status = status;

		if(typeof this.answer.next !== 'undefined')
		{
			this.answer.next = parseInt(this.answer.next);
		}

		if(typeof this.answer.error !== 'undefined')
		{
			this.answer.ex = new ajaxError(this.status, typeof this.answer.error === 'string' ? this.answer : this.answer.error)
		}
	};

	ajaxResult.prototype.data = function()
	{
		return this.answer.result;
	};

	ajaxResult.prototype.time = function()
	{
		return this.answer.time;
	};

	ajaxResult.prototype.error = function()
	{
		return this.answer.ex;
	};

	ajaxResult.prototype.error_description = function()
	{
		return this.answer.error_description;
	};

	ajaxResult.prototype.more = function()
	{
		return !isNaN(this.answer.next);
	};

	ajaxResult.prototype.total = function()
	{
		return parseInt(this.answer.total);
	};

	ajaxResult.prototype.next = function(cb)
	{
		if(this.more())
		{
			this.query.start = this.answer.next;

			if(!!cb && Utils.isFunction(cb))
			{
				this.query.callback = cb;
			}

			return ajax(this.query);
		}

		return false;
	};

	var ajaxError = function(status, ex)
	{
		this.status = status;
		this.ex = ex;
	};

	ajaxError.prototype.getError = function()
	{
		return this.ex;
	};

	ajaxError.prototype.getStatus = function()
	{
		return this.status;
	};

	ajaxError.prototype.toString = function()
	{
		return this.ex.error + (
			!!this.ex.error_description
				? ': ' + this.ex.error_description
				: ''
		) + ' (' + this.status + ')';
	};

	var arrayBufferToData = function(arrayBuffer)
	{
		var uint8 = new Uint8Array(arrayBuffer);
		var data = '';

		// TypedArray.prototype.forEach is not supported in some browsers as IE.
		if (typeof uint8.forEach === 'function')
		{
			uint8.forEach(function (value)
			{
				data += String.fromCharCode(value);
			});
		}
		else
		{
			var length = uint8.length;
			for (var i = 0; i < length; i += 1)
			{
				data += String.fromCharCode(uint8[i]);
			}
		}
		return btoa(data);
	};

	var fileReader = function(fileInput, cb)
	{
		if(fileReader.canUse())
		{
			var files = fileInput.files,
				len = 0,
				result = fileInput.multiple ? [] : null;

			for(var i = 0, f; f = files[i]; i++)
			{
				var reader = new window.FileReader();

				reader.BXFILENAME = files[i].name;

				reader.onload = function(e)
				{
					e = e || window.event;

					var res = [this.BXFILENAME, arrayBufferToData(e.target.result)];

					if(result === null)
						result = res;
					else
						result.push(res);

					if(--len <= 0)
					{
						cb(result);
					}
				};

				reader.readAsArrayBuffer(f);
			}
			len = i;
			if(len <= 0)
			{
				cb(result);
			}
		}
	};

	fileReader.canUse = function()
	{
		return !!window.FileReader;
	};

})();



// file: /bitrix/js/pull/client/pull.client.js
;(function ()
{
	/**
	 * Bitrix Push & Pull
	 * Pull client
	 *
	 * @package bitrix
	 * @subpackage pull
	 * @copyright 2001-2019 Bitrix
	 */

	/****************** ATTENTION *******************************
	 * Please do not use Bitrix CoreJS in this class.
	 * This class can be called on a page without Bitrix Framework
	 *************************************************************/

	if (!window.BX)
	{
		window.BX = {};
	}
	else if (window.BX.PullClient)
	{
		return;
	}
	else if (!window.BX.RestClient)
	{
		return;
	}

	const BX = window.BX;
	const protobuf = window.protobuf;

	const REVISION = 19; // api revision - check module/pull/include.php
	const LONG_POLLING_TIMEOUT = 60;
	const RESTORE_WEBSOCKET_TIMEOUT = 30 * 60;
	const CONFIG_TTL = 24 * 60 * 60;
	const CONFIG_CHECK_INTERVAL = 60000;
	const MAX_IDS_TO_STORE = 10;
	const OFFLINE_STATUS_DELAY = 5000;

	const LS_SESSION = "bx-pull-session";
	const LS_SESSION_CACHE_TIME = 20;

	const ConnectionType = {
		WebSocket: 'webSocket',
		LongPolling: 'longPolling'
	};

	const PullStatus = {
		Online: 'online',
		Offline: 'offline',
		Connecting: 'connect'
	};

	const SenderType = {
		Unknown: 0,
		Client: 1,
		Backend: 2
	};

	const SubscriptionType = {
		Server: 'server',
		Client: 'client',
		Online: 'online',
		Status: 'status',
		Revision: 'revision'
	};

	const CloseReasons = {
		NORMAL_CLOSURE: 1000,
		SERVER_DIE: 1001,
		CONFIG_REPLACED: 3000,
		CHANNEL_EXPIRED: 3001,
		SERVER_RESTARTED: 3002,
		CONFIG_EXPIRED: 3003,
		MANUAL: 3004,
		STUCK: 3005,
		WRONG_CHANNEL_ID: 4010,
	};

	const SystemCommands = {
		CHANNEL_EXPIRE: 'CHANNEL_EXPIRE',
		CONFIG_EXPIRE: 'CONFIG_EXPIRE',
		SERVER_RESTART: 'SERVER_RESTART'
	};

	const ServerMode = {
		Shared: 'shared',
		Personal: 'personal'
	};

	const EmptyConfig = {
		api: {},
		channels: {},
		publicChannels: {},
		server: {timeShift: 0},
		clientId: null,
		jwt: null,
	};

	// Protobuf message models
	const Response = protobuf.roots['push-server']['Response'];
	const ResponseBatch = protobuf.roots['push-server']['ResponseBatch'];
	const Request = protobuf.roots['push-server']['Request'];
	const RequestBatch = protobuf.roots['push-server']['RequestBatch'];
	const IncomingMessagesRequest = protobuf.roots['push-server']['IncomingMessagesRequest'];
	const IncomingMessage = protobuf.roots['push-server']['IncomingMessage'];
	const Receiver = protobuf.roots['push-server']['Receiver'];

	const JSON_RPC_VERSION = "2.0"
	const JSON_RPC_PING = "ping"
	const JSON_RPC_PONG = "pong"

	const PING_TIMEOUT = 10;

	const RpcError = {
		Parse: {code: -32700, message: "Parse error"},
		InvalidRequest: {code: -32600, message: "Invalid Request"},
		MethodNotFound: {code: -32601, message: "Method not found"},
		InvalidParams: {code: -32602, message: "Invalid params"},
		Internal: {code: -32603, message: "Internal error"},
	};

	const RpcMethod = {
		Publish: "publish",
		Subscribe: "subscribe",
	}

	const InternalChannel = {
		StatusChange: "internal:user_status",
	}

	class PullClient
	{
		constructor(params)
		{
			params = params || {};

			if (params.restApplication)
			{
				if (typeof params.configGetMethod === 'undefined')
				{
					params.configGetMethod = 'pull.application.config.get';
				}
				if (typeof params.skipCheckRevision === 'undefined')
				{
					params.skipCheckRevision = true;
				}
				if (typeof params.restApplication === 'string')
				{
					params.siteId = params.restApplication;
				}

				params.serverEnabled = true;
			}

			this._status = PullStatus.Offline;

			this.context = 'master';

			this.guestMode = params.guestMode ? params.guestMode : (typeof BX.message !== 'undefined' && BX.message.pull_guest_mode ? BX.message.pull_guest_mode === 'Y' : false);
			this.guestUserId = params.guestUserId ? params.guestUserId : (typeof BX.message !== 'undefined' && BX.message.pull_guest_user_id ? parseInt(BX.message.pull_guest_user_id, 10) : 0);
			if (this.guestMode && this.guestUserId)
			{
				this.userId = this.guestUserId;
			}
			else
			{
				this.userId = params.userId ? params.userId : (typeof BX.message !== 'undefined' && BX.message.USER_ID ? BX.message.USER_ID : 0);
			}

			this.siteId = params.siteId ? params.siteId : (typeof BX.message !== 'undefined' && BX.message.SITE_ID ? BX.message.SITE_ID : 'none');
			this.restClient = typeof params.restClient !== "undefined" ? params.restClient : new BX.RestClient(this.getRestClientOptions());

			this.enabled = typeof params.serverEnabled !== 'undefined' ? (params.serverEnabled === 'Y' || params.serverEnabled === true) : (typeof BX.message !== 'undefined' && BX.message.pull_server_enabled === 'Y');
			this.unloading = false;
			this.starting = false;
			this.debug = false;
			this.connectionAttempt = 0;
			this.connectionType = ConnectionType.WebSocket;
			this.reconnectTimeout = null;
			this.restartTimeout = null;
			this.restoreWebSocketTimeout = null;

			this.configGetMethod = typeof params.configGetMethod !== 'string' ? 'pull.config.get' : params.configGetMethod;
			this.getPublicListMethod = typeof params.getPublicListMethod !== 'string' ? 'pull.channel.public.list' : params.getPublicListMethod;

			this.skipStorageInit = params.skipStorageInit === true;

			this.skipCheckRevision = params.skipCheckRevision === true;

			this._subscribers = {};

			this.watchTagsQueue = {};
			this.watchUpdateInterval = 1740000;
			this.watchForceUpdateInterval = 5000;

			if (typeof params.configTimestamp !== 'undefined')
			{
				this.configTimestamp = params.configTimestamp;
			}
			else if (typeof BX.message !== 'undefined' && BX.message.pull_config_timestamp)
			{
				this.configTimestamp = BX.message.pull_config_timestamp;
			}
			else
			{
				this.configTimestamp = 0;
			}

			this.session = {
				mid: null,
				tag: null,
				time: null,
				history: {},
				lastMessageIds: [],
				messageCount: 0
			};

			this._connectors = {
				webSocket: null,
				longPolling: null
			};

			this.isSecure = document.location.href.indexOf('https') === 0;
			this.config = null;

			this.storage = null;

			if (this.userId && !this.skipStorageInit)
			{
				this.storage = new StorageManager({
					userId: this.userId,
					siteId: this.siteId
				});
			}

			this.sharedConfig = new SharedConfig({
				onWebSocketBlockChanged: this.onWebSocketBlockChanged.bind(this),
				storage: this.storage
			});
			this.channelManager = new ChannelManager({
				restClient: this.restClient,
				getPublicListMethod: this.getPublicListMethod
			});

			this.notificationPopup = null;

			// timers
			this.checkInterval = null;
			this.offlineTimeout = null;

			this.pingWaitTimeout = null;

			// manual stop workaround
			this.isManualDisconnect = false;

			this.loggingEnabled = this.sharedConfig.isLoggingEnabled();

			// bound event handlers
			this.onPingTimeoutHandler = this.onPingTimeout.bind(this);
		}

		get connector()
		{
			return this._connectors[this.connectionType];
		}

		get status()
		{
			return this._status;
		}

		set status(status)
		{
			if (this._status === status)
			{
				return;
			}

			this._status = status;
			if (this.offlineTimeout)
			{
				clearTimeout(this.offlineTimeout)
				this.offlineTimeout = null;
			}

			if (status === PullStatus.Offline)
			{
				this.sendPullStatusDelayed(status, OFFLINE_STATUS_DELAY);
			}
			else
			{
				this.sendPullStatus(status);
			}
		}

		/**
		 * Creates a subscription to incoming messages.
		 *
		 * @param {Object} params
		 * @param {string} [params.type] Subscription type (for possible values see SubscriptionType).
		 * @param {string} [params.moduleId] Name of the module.
		 * @param {Function} params.callback Function, that will be called for incoming messages.
		 * @returns {Function} - Unsubscribe callback function
		 */
		subscribe(params)
		{
			/**
			 * After modify this method, copy to follow scripts:
			 * mobile/install/mobileapp/mobile/extensions/bitrix/pull/client/events/extension.js
			 * mobile/install/js/mobile/pull/client/src/client.js
			 */

			if (!params)
			{
				console.error(Utils.getDateForLog() + ': Pull.subscribe: params for subscribe function is invalid. ');
				return function () {}
			}

			if (!Utils.isPlainObject(params))
			{
				return this.attachCommandHandler(params);
			}

			params = params || {};
			params.type = params.type || SubscriptionType.Server;
			params.command = params.command || null;

			if (params.type == SubscriptionType.Server || params.type == SubscriptionType.Client)
			{
				if (typeof (this._subscribers[params.type]) === 'undefined')
				{
					this._subscribers[params.type] = {};
				}
				if (typeof (this._subscribers[params.type][params.moduleId]) === 'undefined')
				{
					this._subscribers[params.type][params.moduleId] = {
						'callbacks': [],
						'commands': {},
					};
				}

				if (params.command)
				{
					if (typeof (this._subscribers[params.type][params.moduleId]['commands'][params.command]) === 'undefined')
					{
						this._subscribers[params.type][params.moduleId]['commands'][params.command] = [];
					}

					this._subscribers[params.type][params.moduleId]['commands'][params.command].push(params.callback);

					return function ()
					{
						this._subscribers[params.type][params.moduleId]['commands'][params.command] = this._subscribers[params.type][params.moduleId]['commands'][params.command].filter((element) =>
						{
							return element !== params.callback;
						});
					}.bind(this);
				}
				else
				{
					this._subscribers[params.type][params.moduleId]['callbacks'].push(params.callback);

					return function ()
					{
						this._subscribers[params.type][params.moduleId]['callbacks'] = this._subscribers[params.type][params.moduleId]['callbacks'].filter((element) =>
						{
							return element !== params.callback;
						});
					}.bind(this);
				}
			}
			else
			{
				if (typeof (this._subscribers[params.type]) === 'undefined')
				{
					this._subscribers[params.type] = [];
				}

				this._subscribers[params.type].push(params.callback);

				return function ()
				{
					this._subscribers[params.type] = this._subscribers[params.type].filter((element) =>
					{
						return element !== params.callback;
					});
				}.bind(this);
			}
		}

		attachCommandHandler(handler)
		{
			/**
			 * After modify this method, copy to follow scripts:
			 * mobile/install/mobileapp/mobile/extensions/bitrix/pull/client/events/extension.js
			 */
			if (typeof handler.getModuleId !== 'function' || typeof handler.getModuleId() !== 'string')
			{
				console.error(Utils.getDateForLog() + ': Pull.attachCommandHandler: result of handler.getModuleId() is not a string.');
				return function () {}
			}

			let type = SubscriptionType.Server;
			if (typeof handler.getSubscriptionType === 'function')
			{
				type = handler.getSubscriptionType();
			}

			return this.subscribe({
				type: type,
				moduleId: handler.getModuleId(),
				callback: function (data)
				{
					let method = null;

					if (typeof handler.getMap === 'function')
					{
						const mapping = handler.getMap();
						if (mapping && typeof mapping === 'object')
						{
							if (typeof mapping[data.command] === 'function')
							{
								method = mapping[data.command].bind(handler)
							}
							else if (typeof mapping[data.command] === 'string' && typeof handler[mapping[data.command]] === 'function')
							{
								method = handler[mapping[data.command]].bind(handler);
							}
						}
					}

					if (!method)
					{
						const methodName = 'handle' + data.command.charAt(0).toUpperCase() + data.command.slice(1);
						if (typeof handler[methodName] === 'function')
						{
							method = handler[methodName].bind(handler);
						}
					}

					if (method)
					{
						if (this.debug && this.context !== 'master')
						{
							console.warn(Utils.getDateForLog() + ': Pull.attachCommandHandler: receive command', data);
						}
						method(data.params, data.extra, data.command);
					}
				}.bind(this)
			});
		}

		/**
		 *
		 * @param params {Object}
		 * @returns {boolean}
		 */
		emit(params)
		{
			/**
			 * After modify this method, copy to follow scripts:
			 * mobile/install/mobileapp/mobile/extensions/bitrix/pull/client/events/extension.js
			 * mobile/install/js/mobile/pull/client/src/client.js
			 */
			params = params || {};

			if (params.type == SubscriptionType.Server || params.type == SubscriptionType.Client)
			{
				if (typeof (this._subscribers[params.type]) === 'undefined')
				{
					this._subscribers[params.type] = {};
				}
				if (typeof (this._subscribers[params.type][params.moduleId]) === 'undefined')
				{
					this._subscribers[params.type][params.moduleId] = {
						'callbacks': [],
						'commands': {},
					};
				}

				if (this._subscribers[params.type][params.moduleId]['callbacks'].length > 0)
				{
					this._subscribers[params.type][params.moduleId]['callbacks'].forEach(function (callback)
					{
						callback(params.data, {type: params.type, moduleId: params.moduleId});
					});
				}

				if (
					this._subscribers[params.type][params.moduleId]['commands'][params.data.command]
					&& this._subscribers[params.type][params.moduleId]['commands'][params.data.command].length > 0)
				{
					this._subscribers[params.type][params.moduleId]['commands'][params.data.command].forEach(function (callback)
					{
						callback(params.data.params, params.data.extra, params.data.command, {
							type: params.type,
							moduleId: params.moduleId
						});
					});
				}

				return true;
			}
			else
			{
				if (typeof (this._subscribers[params.type]) === 'undefined')
				{
					this._subscribers[params.type] = [];
				}

				if (this._subscribers[params.type].length <= 0)
				{
					return true;
				}

				this._subscribers[params.type].forEach(function (callback)
				{
					callback(params.data, {type: params.type});
				});

				return true;
			}
		}

		init()
		{
			this._connectors.webSocket = new WebSocketConnector({
				parent: this,
				onOpen: this.onWebSocketOpen.bind(this),
				onMessage: this.onIncomingMessage.bind(this),
				onDisconnect: this.onWebSocketDisconnect.bind(this),
				onError: this.onWebSocketError.bind(this)
			});

			this._connectors.longPolling = new LongPollingConnector({
				parent: this,
				onOpen: this.onLongPollingOpen.bind(this),
				onMessage: this.onIncomingMessage.bind(this),
				onDisconnect: this.onLongPollingDisconnect.bind(this),
				onError: this.onLongPollingError.bind(this)
			});

			this.connectionType = this.isWebSocketAllowed() ? ConnectionType.WebSocket : ConnectionType.LongPolling;

			window.addEventListener("beforeunload", this.onBeforeUnload.bind(this));
			window.addEventListener("offline", this.onOffline.bind(this));
			window.addEventListener("online", this.onOnline.bind(this));

			if (BX && BX.addCustomEvent)
			{
				BX.addCustomEvent("BXLinkOpened", this.connect.bind(this));
			}

			if (BX && BX.desktop)
			{
				BX.addCustomEvent("onDesktopReload", () =>
				{
					this.session.mid = null;
					this.session.tag = null;
					this.session.time = null;
				});

				BX.desktop.addCustomEvent("BXLoginSuccess", () => this.restart(1000, "Desktop login"));
			}

			this.jsonRpcAdapter = new JsonRpc({
				connector: this._connectors.webSocket,
				handlers: {
					"incoming.message": this.handleRpcIncomingMessage.bind(this),
				}
			});
		}

		start(config)
		{
			let allowConfigCaching = true;

			if (this.isConnected())
			{
				return Promise.resolve(true);
			}

			if (this.starting && this._startingPromise)
			{
				return this._startingPromise;
			}

			if (!this.userId && typeof (BX.message) !== 'undefined' && BX.message.USER_ID)
			{
				this.userId = BX.message.USER_ID;
				if (!this.storage)
				{
					this.storage = new StorageManager({
						userId: this.userId,
						siteId: this.siteId
					});
				}
			}
			if (this.siteId === 'none' && typeof (BX.message) !== 'undefined' && BX.message.SITE_ID)
			{
				this.siteId = BX.message.SITE_ID;
			}

			let skipReconnectToLastSession = false;
			if (Utils.isPlainObject(config))
			{
				if (typeof config.skipReconnectToLastSession !== 'undefined')
				{
					skipReconnectToLastSession = !!config.skipReconnectToLastSession;
					delete config.skipReconnectToLastSession;
				}
				this.config = config;
				allowConfigCaching = false;
			}

			if (!this.enabled)
			{
				return Promise.reject({
					ex: {error: 'PULL_DISABLED', error_description: 'Push & Pull server is disabled'}
				});
			}

			const now = (new Date()).getTime();
			let oldSession;
			if (!skipReconnectToLastSession && this.storage)
			{
				oldSession = this.storage.get(LS_SESSION);
			}
			if (Utils.isPlainObject(oldSession) && oldSession.hasOwnProperty('ttl') && oldSession.ttl >= now)
			{
				this.session.mid = oldSession.mid;
			}

			this.starting = true;
			return new Promise((resolve, reject) =>
			{
				this._startingPromise = {resolve, reject};
				this.loadConfig().then(
					(config) =>
					{
						this.setConfig(config, allowConfigCaching);
						this.init();
						this.updateWatch();
						this.startCheckConfig();
						this.connect().then(
							() => resolve(true),
							error => reject(error)
						);
					},
					(error) =>
					{
						this.starting = false;
						this.status = PullStatus.Offline;
						this.stopCheckConfig();
						console.error(Utils.getDateForLog() + ': Pull: could not read push-server config. ', error);
						reject(error);
					}
				);
			})
		}

		getRestClientOptions()
		{
			let result = {};

			if (this.guestMode && this.guestUserId !== 0)
			{
				result.queryParams = {
					pull_guest_id: this.guestUserId
				}
			}
			return result;
		}

		setLastMessageId(lastMessageId)
		{
			this.session.mid = lastMessageId;
		}

		/**
		 *
		 * @param {object[]} publicIds
		 * @param {integer} publicIds.user_id
		 * @param {string} publicIds.public_id
		 * @param {string} publicIds.signature
		 * @param {Date} publicIds.start
		 * @param {Date} publicIds.end
		 */
		setPublicIds(publicIds)
		{
			return this.channelManager.setPublicIds(publicIds);
		}

		/**
		 * Send single message to the specified users.
		 *
		 * @param {integer[]} users User ids of the message receivers.
		 * @param {string} moduleId Name of the module to receive message,
		 * @param {string} command Command name.
		 * @param {object} params Command parameters.
		 * @param {integer} [expiry] Message expiry time in seconds.
		 * @return {Promise}
		 */
		sendMessage(users, moduleId, command, params, expiry)
		{
			const message = {
				userList: users,
				body: {
					module_id: moduleId,
					command: command,
					params: params,
				},
				expiry: expiry
			};

			if (this.isJsonRpc())
			{
				return this.jsonRpcAdapter.executeOutgoingRpcCommand(RpcMethod.Publish, message)
			}
			else
			{
				return this.sendMessageBatch([message]);
			}
		}

		/**
		 * Send single message to the specified public channels.
		 *
		 * @param {string[]} publicChannels Public ids of the channels to receive message.
		 * @param {string} moduleId Name of the module to receive message,
		 * @param {string} command Command name.
		 * @param {object} params Command parameters.
		 * @param {integer} [expiry] Message expiry time in seconds.
		 * @return {Promise}
		 */
		sendMessageToChannels(publicChannels, moduleId, command, params, expiry)
		{
			const message = {
				channelList: publicChannels,
				body: {
					module_id: moduleId,
					command: command,
					params: params,
				},
				expiry: expiry
			};

			if (this.isJsonRpc())
			{
				return this.jsonRpcAdapter.executeOutgoingRpcCommand("publish", message)
			}
			else
			{
				return this.sendMessageBatch([message]);
			}
		}

		/**
		 * Sends batch of messages to the multiple public channels.
		 *
		 * @param {object[]} messageBatch Array of messages to send.
		 * @param  {int[]} messageBatch.userList User ids the message receivers.
		 * @param  {string[]|object[]} messageBatch.channelList Public ids of the channels to send messages.
		 * @param {string} messageBatch.moduleId Name of the module to receive message,
		 * @param {string} messageBatch.command Command name.
		 * @param {object} messageBatch.params Command parameters.
		 * @param {integer} [messageBatch.expiry] Message expiry time in seconds.
		 * @return void
		 */
		sendMessageBatch(messageBatch)
		{
			if (!this.isPublishingEnabled())
			{
				console.error('Client publishing is not supported or is disabled');
				return false;
			}

			if (this.isJsonRpc())
			{
				let rpcRequest = this.jsonRpcAdapter.createPublishRequest(messageBatch);
				return this.connector.send(JSON.stringify(rpcRequest));
			}
			else
			{
				let userIds = {};
				for (let i = 0; i < messageBatch.length; i++)
				{
					if (messageBatch[i].userList)
					{
						for (let j = 0; j < messageBatch[i].userList.length; j++)
						{
							userIds[messageBatch[i].userList[j]] = true;
						}
					}
				}
				this.channelManager.getPublicIds(Object.keys(userIds)).then((publicIds) =>
				{
					return this.connector.send(this.encodeMessageBatch(messageBatch, publicIds));
				})
			}
		}

		encodeMessageBatch(messageBatch, publicIds)
		{
			let messages = [];
			messageBatch.forEach(function (messageFields)
			{
				const messageBody = messageFields.body;

				let receivers;
				if (messageFields.userList)
				{
					receivers = this.createMessageReceivers(messageFields.userList, publicIds);
				}
				else
				{
					receivers = [];
				}

				if (messageFields.channelList)
				{
					if (!Utils.isArray(messageFields.channelList))
					{
						throw new Error('messageFields.publicChannels must be an array');
					}
					messageFields.channelList.forEach(function (publicChannel)
					{
						let publicId;
						let signature;
						if (typeof (publicChannel) === 'string' && publicChannel.includes('.'))
						{
							const fields = publicChannel.toString().split('.');
							publicId = fields[0];
							signature = fields[1];
						}
						else if (typeof (publicChannel) === 'object' && ('publicId' in publicChannel) && ('signature' in publicChannel))
						{
							publicId = publicChannel.publicId;
							signature = publicChannel.signature;
						}
						else
						{
							throw new Error('Public channel MUST be either a string, formatted like "{publicId}.{signature}" or an object with fields \'publicId\' and \'signature\'');
						}

						receivers.push(Receiver.create({
							id: this.encodeId(publicId),
							signature: this.encodeId(signature)
						}))
					}.bind(this))
				}

				const message = IncomingMessage.create({
					receivers: receivers,
					body: JSON.stringify(messageBody),
					expiry: messageFields.expiry || 0
				});
				messages.push(message);
			}, this);

			const requestBatch = RequestBatch.create({
				requests: [{
					incomingMessages: {
						messages: messages
					}
				}]
			});

			return RequestBatch.encode(requestBatch).finish();
		}

		createMessageReceivers(users, publicIds)
		{
			let result = [];
			for (let i = 0; i < users.length; i++)
			{
				let userId = users[i];
				if (!publicIds[userId] || !publicIds[userId].publicId)
				{
					throw new Error('Could not determine public id for user ' + userId);
				}

				result.push(Receiver.create({
					id: this.encodeId(publicIds[userId].publicId),
					signature: this.encodeId(publicIds[userId].signature)
				}))
			}
			return result;
		}

		subscribeUserStatusChange()
		{
			return this.executeSubscribeCommand([InternalChannel.StatusChange]);
		}

		executeSubscribeCommand(channelList)
		{
			return this.jsonRpcAdapter.executeOutgoingRpcCommand(RpcMethod.Subscribe, {channelList});
		}

		/**
		 * Returns "last seen" time in seconds for the users. Result format: Object{userId: int}
		 * If the user is currently connected - will return 0.
		 * If the user if offline - will return diff between current timestamp and last seen timestamp in seconds.
		 * If the user was never online - the record for user will be missing from the result object.
		 *
		 * @param {integer[]} userList Optional. If empty - returns all known to the server host users.
		 * @returns {Promise}
		 */
		getUsersLastSeen(userList)
		{
			return this.jsonRpcAdapter.executeOutgoingRpcCommand("getUsersLastSeen", {
				userList: userList
			});
		}

		/**
		 * Pings server. In case of success promise will be resolved, otherwise - rejected.
		 *
		 * @param {int} timeout Request timeout in seconds
		 * @returns {Promise}
		 */
		ping(timeout)
		{
			return this.jsonRpcAdapter.executeOutgoingRpcCommand("ping", {}, timeout);
		}

		/**
		 * Returns list channels that the connection is subscribed to.
		 *
		 * @returns {Promise}
		 */
		listChannels()
		{
			return this.jsonRpcAdapter.executeOutgoingRpcCommand("listChannels", {});
		}

		scheduleRestart(disconnectCode, disconnectReason, restartDelay)
		{
			clearTimeout(this.restartTimeout);
			if (!restartDelay || restartDelay < 1)
			{
				restartDelay = Math.ceil(Math.random() * 30) + 5;
			}

			this.restartTimeout = setTimeout(
				() => this.restart(disconnectCode, disconnectReason),
				restartDelay
			);
		}

		restart(disconnectCode, disconnectReason)
		{
			if (!disconnectCode)
			{
				disconnectCode = CloseReasons.NORMAL_CLOSURE;
			}
			clearTimeout(this.restartTimeout);
			console.warn(Utils.getDateForLog() + ': Pull: restarting with code ' + disconnectCode)
			this.disconnect(disconnectCode, disconnectReason);
			if (this.storage)
			{
				this.storage.remove('bx-pull-config');
			}
			this.config = null;

			this.loadConfig().then(
				(config) =>	{
					this.setConfig(config, true);
					this.updateWatch();
					this.startCheckConfig();
					this.connect().catch(error => console.error(error));
				},
				(error) => {
					console.error(Utils.getDateForLog() + ': Pull: could not read push-server config', error);
					this.status = PullStatus.Offline;

					clearTimeout(this.reconnectTimeout);
					if (error.status == 401 || error.status == 403)
					{
						this.stopCheckConfig();

						if (BX && BX.onCustomEvent)
						{
							BX.onCustomEvent(window, 'onPullError', ['AUTHORIZE_ERROR']);
						}
					}
				}
			);
		}

		loadConfig()
		{
			if (!this.config)
			{
				this.config = Object.assign({}, EmptyConfig);

				let config;
				if (this.storage)
				{
					config = this.storage.get('bx-pull-config');
				}
				if (this.isConfigActual(config) && this.checkRevision(config.api.revision_web))
				{
					return Promise.resolve(config);
				}
				else if (this.storage)
				{
					this.storage.remove('bx-pull-config')
				}
			}
			else if (this.isConfigActual(this.config) && this.checkRevision(this.config.api.revision_web))
			{
				return Promise.resolve(this.config);
			}
			else
			{
				this.config = Object.assign({}, EmptyConfig);
			}

			return new Promise((resolve, reject) =>
			{
				this.restClient.callMethod(this.configGetMethod, {'CACHE': 'N'}).then((response) =>
				{
					const data = response.data();
					let timeShift;

					timeShift = Math.floor((Utils.getTimestamp() - new Date(data.serverTime).getTime()) / 1000);
					delete data.serverTime;

					let config = Object.assign({}, data);
					config.server.timeShift = timeShift;

					resolve(config);
				}).catch((response) =>
				{
					const error = response.error();
					if (error.getError().error == "AUTHORIZE_ERROR" || error.getError().error == "WRONG_AUTH_TYPE")
					{
						error.status = 403;
					}
					reject(error);
				});
			})
		}

		isConfigActual(config)
		{
			if (!Utils.isPlainObject(config))
			{
				return false;
			}

			if (config.server.config_timestamp < this.configTimestamp)
			{
				return false;
			}

			const now = new Date();

			const channelCount = Object.keys(config.channels).length;
			if (channelCount === 0)
			{
				return false;
			}

			for (let channelType in config.channels)
			{
				if (!config.channels.hasOwnProperty(channelType))
				{
					continue;
				}

				const channel = config.channels[channelType];
				const channelEnd = new Date(channel.end);

				if (channelEnd < now)
				{
					return false;
				}
			}

			return true;
		}

		startCheckConfig()
		{
			if (this.checkInterval)
			{
				clearInterval(this.checkInterval);
			}

			this.checkInterval = setInterval(this.checkConfig.bind(this), CONFIG_CHECK_INTERVAL)
		}

		stopCheckConfig()
		{
			if (this.checkInterval)
			{
				clearInterval(this.checkInterval);
			}
			this.checkInterval = null;
		}

		checkConfig()
		{
			if (this.isConfigActual(this.config))
			{
				if (!this.checkRevision(this.config.api.revision_web))
				{
					return false;
				}
			}
			else
			{
				this.logToConsole("Stale config detected. Restarting");
				this.restart(CloseReasons.CONFIG_EXPIRED, "Config update required");
			}
		}

		setConfig(config, allowCaching)
		{
			for (let key in config)
			{
				if (config.hasOwnProperty(key) && this.config.hasOwnProperty(key))
				{
					this.config[key] = config[key];
				}
			}

			if (config.publicChannels)
			{
				this.setPublicIds(Utils.objectValues(config.publicChannels));
			}

			if (this.storage && allowCaching)
			{
				try
				{
					this.storage.set('bx-pull-config', config);
				} catch (e)
				{
					// try to delete the key "history" (landing site change history, see http://jabber.bx/view.php?id=136492)
					if (localStorage && localStorage.removeItem)
					{
						localStorage.removeItem('history');
					}
					console.error(Utils.getDateForLog() + " Pull: Could not cache config in local storage. Error: ", e);
				}
			}
		}

		isWebSocketSupported()
		{
			return typeof (window.WebSocket) !== "undefined";
		}

		isWebSocketAllowed()
		{
			if (this.sharedConfig.isWebSocketBlocked())
			{
				return false;
			}

			return this.isWebSocketEnabled();
		}

		isWebSocketEnabled()
		{
			if (!this.isWebSocketSupported())
			{
				return false;
			}

			return (this.config && this.config.server && this.config.server.websocket_enabled === true);
		}

		isPublishingSupported()
		{
			return this.getServerVersion() > 3;
		}

		isPublishingEnabled()
		{
			if (!this.isPublishingSupported())
			{
				return false;
			}

			return (this.config && this.config.server && this.config.server.publish_enabled === true);
		}

		isProtobufSupported()
		{
			return (this.getServerVersion() == 4 && !Utils.browser.IsIe());
		}

		isJsonRpc()
		{
			return (this.getServerVersion() >= 5);
		}

		isSharedMode()
		{
			return (this.getServerMode() == ServerMode.Shared)
		}

		disconnect(disconnectCode, disconnectReason)
		{
			if (this.connector)
			{
				this.isManualDisconnect = true;
				this.connector.disconnect(disconnectCode, disconnectReason);
			}
		}

		stop(disconnectCode, disconnectReason)
		{
			this.disconnect(disconnectCode, disconnectReason);
			this.stopCheckConfig();
		}

		reconnect(disconnectCode, disconnectReason, delay)
		{
			this.disconnect(disconnectCode, disconnectReason);

			delay = delay || 1;
			this.scheduleReconnect(delay);
		}

		restoreWebSocketConnection()
		{
			if (this.connectionType == ConnectionType.WebSocket)
			{
				return true;
			}

			this._connectors.webSocket.connect();
		}

		scheduleReconnect(connectionDelay)
		{
			if (!this.enabled)
			{
				return false;
			}

			if (!connectionDelay)
			{
				if (this.connectionAttempt > 3 && this.connectionType === ConnectionType.WebSocket && !this.sharedConfig.isLongPollingBlocked())
				{
					// Websocket seems to be closed by network filter. Trying to fallback to long polling
					this.sharedConfig.setWebSocketBlocked(true);
					this.connectionType = ConnectionType.LongPolling;
					this.connectionAttempt = 1;
					connectionDelay = 1;
				}
				else
				{
					connectionDelay = this.getConnectionAttemptDelay(this.connectionAttempt);
				}
			}
			if (this.reconnectTimeout)
			{
				clearTimeout(this.reconnectTimeout);
			}

			this.logToConsole('Pull: scheduling reconnection in ' + connectionDelay + ' seconds; attempt # ' + this.connectionAttempt);

			this.reconnectTimeout = setTimeout(
				() =>
				{
					this.connect().catch(error =>
					{
						console.error(error)
					})
				},
				connectionDelay * 1000);
		}

		scheduleRestoreWebSocketConnection()
		{
			this.logToConsole('Pull: scheduling restoration of websocket connection in ' + RESTORE_WEBSOCKET_TIMEOUT + ' seconds');

			if (this.restoreWebSocketTimeout)
			{
				return;
			}

			this.restoreWebSocketTimeout = setTimeout(() =>
			{
				this.restoreWebSocketTimeout = 0;
				this.restoreWebSocketConnection();
			}, RESTORE_WEBSOCKET_TIMEOUT * 1000);
		}

		/**
		 * @returns {Promise}
		 */
		connect()
		{
			if (!this.enabled)
			{
				return Promise.reject();
			}
			if (this.connector.connected)
			{
				return Promise.resolve();
			}

			if (this.reconnectTimeout)
			{
				clearTimeout(this.reconnectTimeout);
			}

			this.status = PullStatus.Connecting;
			this.connectionAttempt++;
			return new Promise((resolve, reject) =>
			{
				this._connectPromise = {resolve, reject}
				this.connector.connect();
			})
		}

		onIncomingMessage(message)
		{
			if (this.isJsonRpc())
			{
				(message === JSON_RPC_PING) ? this.onJsonRpcPing() : this.jsonRpcAdapter.parseJsonRpcMessage(message);
			}
			else
			{
				const events = this.extractMessages(message);
				this.handleIncomingEvents(events);
			}
		}

		handleRpcIncomingMessage(messageFields)
		{
			this.session.mid = messageFields.mid;
			let body = messageFields.body;

			if (!messageFields.body.extra)
			{
				body.extra = {};
			}
			body.extra.sender = messageFields.sender;

			if ("user_params" in messageFields && Utils.isPlainObject(messageFields.user_params))
			{
				Object.assign(body.params, messageFields.user_params)
			}

			if ("dictionary" in messageFields && Utils.isPlainObject(messageFields.dictionary))
			{
				Object.assign(body.params, messageFields.dictionary)
			}

			if (this.checkDuplicate(messageFields.mid))
			{
				this.addMessageToStat(body);
				this.trimDuplicates();
				this.broadcastMessage(body)
			}

			this.connector.send(`mack:${messageFields.mid}`)

			return {};
		}

		onJsonRpcPing()
		{
			this.updatePingWaitTimeout();
			this.connector.send(JSON_RPC_PONG)
		}

		handleIncomingEvents(events)
		{
			let messages = [];
			if (events.length === 0)
			{
				this.session.mid = null;
				return;
			}

			for (let i = 0; i < events.length; i++)
			{
				let event = events[i];
				this.updateSessionFromEvent(event);
				if (event.mid && !this.checkDuplicate(event.mid))
				{
					continue;
				}

				this.addMessageToStat(event.text);
				messages.push(event.text);
			}
			this.trimDuplicates();
			this.broadcastMessages(messages);
		}

		updateSessionFromEvent(event)
		{
			this.session.mid = event.mid || null;
			this.session.tag = event.tag || null;
			this.session.time = event.time || null;
		}

		checkDuplicate(mid)
		{
			if (this.session.lastMessageIds.includes(mid))
			{
				console.warn("Duplicate message " + mid + " skipped");
				return false;
			}
			else
			{
				this.session.lastMessageIds.push(mid);
				return true;
			}
		}

		trimDuplicates()
		{
			if (this.session.lastMessageIds.length > MAX_IDS_TO_STORE)
			{
				this.session.lastMessageIds = this.session.lastMessageIds.slice(-MAX_IDS_TO_STORE);
			}
		}

		addMessageToStat(message)
		{
			if (!this.session.history[message.module_id])
			{
				this.session.history[message.module_id] = {};
			}
			if (!this.session.history[message.module_id][message.command])
			{
				this.session.history[message.module_id][message.command] = 0;
			}
			this.session.history[message.module_id][message.command]++;

			this.session.messageCount++;
		}

		extractMessages(pullEvent)
		{
			if (pullEvent instanceof ArrayBuffer)
			{
				return this.extractProtobufMessages(pullEvent);
			}
			else if (Utils.isNotEmptyString(pullEvent))
			{
				return this.extractPlainTextMessages(pullEvent)
			}
		}

		extractProtobufMessages(pullEvent)
		{
			let result = [];
			try
			{
				let responseBatch = ResponseBatch.decode(new Uint8Array(pullEvent));
				for (let i = 0; i < responseBatch.responses.length; i++)
				{
					let response = responseBatch.responses[i];
					if (response.command != "outgoingMessages")
					{
						continue;
					}

					let messages = response.outgoingMessages.messages;
					for (let m = 0; m < messages.length; m++)
					{
						const message = messages[m];
						let messageFields;
						try
						{
							messageFields = JSON.parse(message.body)
						} catch (e)
						{
							console.error(Utils.getDateForLog() + ": Pull: Could not parse message body", e);
							continue;
						}

						if (!messageFields.extra)
						{
							messageFields.extra = {}
						}
						messageFields.extra.sender = {
							type: message.sender.type
						};

						if (message.sender.id instanceof Uint8Array)
						{
							messageFields.extra.sender.id = this.decodeId(message.sender.id)
						}

						const compatibleMessage = {
							mid: this.decodeId(message.id),
							text: messageFields
						};

						result.push(compatibleMessage);
					}
				}
			} catch (e)
			{
				console.error(Utils.getDateForLog() + ": Pull: Could not parse message", e)
			}
			return result;
		}

		extractPlainTextMessages(pullEvent)
		{
			let result = [];
			const dataArray = pullEvent.match(/#!NGINXNMS!#(.*?)#!NGINXNME!#/gm);
			if (dataArray === null)
			{
				text = "\n========= PULL ERROR ===========\n" +
					"Error type: parseResponse error parsing message\n" +
					"\n" +
					"Data string: " + pullEvent + "\n" +
					"================================\n\n";
				console.warn(text);
				return result;
			}
			for (let i = 0; i < dataArray.length; i++)
			{
				dataArray[i] = dataArray[i].substring(12, dataArray[i].length - 12);
				if (dataArray[i].length <= 0)
				{
					continue;
				}

				let data
				try
				{
					data = JSON.parse(dataArray[i])
				} catch (e)
				{
					continue;
				}

				result.push(data);
			}
			return result;
		}

		/**
		 * Converts message id from byte[] to string
		 * @param {Uint8Array} encodedId
		 * @return {string}
		 */
		decodeId(encodedId)
		{
			if (!(encodedId instanceof Uint8Array))
			{
				throw new Error("encodedId should be an instance of Uint8Array");
			}

			let result = "";
			for (let i = 0; i < encodedId.length; i++)
			{
				const hexByte = encodedId[i].toString(16);
				if (hexByte.length === 1)
				{
					result += '0';
				}
				result += hexByte;
			}
			return result;
		}

		/**
		 * Converts message id from hex-encoded string to byte[]
		 * @param {string} id Hex-encoded string.
		 * @return {Uint8Array}
		 */
		encodeId(id)
		{
			if (!id)
			{
				return new Uint8Array();
			}

			let result = [];
			for (let i = 0; i < id.length; i += 2)
			{
				result.push(parseInt(id.substr(i, 2), 16));
			}

			return new Uint8Array(result);
		}

		broadcastMessages(messages)
		{
			messages.forEach(message => this.broadcastMessage(message));
		}

		broadcastMessage(message)
		{
			const moduleId = message.module_id = message.module_id.toLowerCase();
			const command = message.command;

			if (!message.extra)
			{
				message.extra = {};
			}

			if (message.extra.server_time_unix)
			{
				message.extra.server_time_ago = ((Utils.getTimestamp() - (message.extra.server_time_unix * 1000)) / 1000) - (this.config.server.timeShift ? this.config.server.timeShift : 0);
				message.extra.server_time_ago = message.extra.server_time_ago > 0 ? message.extra.server_time_ago : 0;
			}

			this.logMessage(message);
			try
			{
				if (message.extra.sender && message.extra.sender.type === SenderType.Client)
				{
					if (typeof BX.onCustomEvent !== 'undefined')
					{
						BX.onCustomEvent(window, 'onPullClientEvent-' + moduleId, [command, message.params, message.extra], true);
						BX.onCustomEvent(window, 'onPullClientEvent', [moduleId, command, message.params, message.extra], true);
					}

					this.emit({
						type: SubscriptionType.Client,
						moduleId: moduleId,
						data: {
							command: command,
							params: Utils.clone(message.params),
							extra: Utils.clone(message.extra)
						}
					});
				}
				else if (moduleId === 'pull')
				{
					this.handleInternalPullEvent(command, message);
				}
				else if (moduleId == 'online')
				{
					if (message.extra.server_time_ago < 240)
					{
						if (typeof BX.onCustomEvent !== 'undefined')
						{
							BX.onCustomEvent(window, 'onPullOnlineEvent', [command, message.params, message.extra], true);
						}

						this.emit({
							type: SubscriptionType.Online,
							data: {
								command: command,
								params: Utils.clone(message.params),
								extra: Utils.clone(message.extra)
							}
						});
					}
				}
				else
				{
					if (typeof BX.onCustomEvent !== 'undefined')
					{
						BX.onCustomEvent(window, 'onPullEvent-' + moduleId, [command, message.params, message.extra], true);
						BX.onCustomEvent(window, 'onPullEvent', [moduleId, command, message.params, message.extra], true);
					}

					this.emit({
						type: SubscriptionType.Server,
						moduleId: moduleId,
						data: {
							command: command,
							params: Utils.clone(message.params),
							extra: Utils.clone(message.extra)
						}
					});
				}
			} catch (e)
			{
				if (typeof (console) == 'object')
				{
					console.warn(
						"\n========= PULL ERROR ===========\n" +
						"Error type: broadcastMessages execute error\n" +
						"Error event: ", e, "\n" +
						"Message: ", message, "\n" +
						"================================\n"
					);
					if (typeof BX.debug !== 'undefined')
					{
						BX.debug(e);
					}
				}
			}

			if (message.extra && message.extra.revision_web)
			{
				this.checkRevision(message.extra.revision_web);
			}
		}

		logToConsole(message, force)
		{
			if (this.loggingEnabled || force)
			{
				console.log(Utils.getDateForLog() + ': ' + message);
			}
		}

		logMessage(message)
		{
			if (!this.debug)
			{
				return;
			}

			if (message.extra.sender && message.extra.sender.type === SenderType.Client)
			{
				console.info('onPullClientEvent-' + message.module_id, message.command, message.params, message.extra);
			}
			else if (message.moduleId == 'online')
			{
				console.info('onPullOnlineEvent', message.command, message.params, message.extra);
			}
			else
			{
				console.info('onPullEvent', message.module_id, message.command, message.params, message.extra);
			}
		}

		onLongPollingOpen()
		{
			this.unloading = false;
			this.starting = false;
			this.connectionAttempt = 0;
			this.isManualDisconnect = false;
			this.status = PullStatus.Online;

			this.logToConsole('Pull: Long polling connection with push-server opened');
			if (this.isWebSocketEnabled())
			{
				this.scheduleRestoreWebSocketConnection();
			}
			if (this._connectPromise)
			{
				this._connectPromise.resolve();
			}
		}

		onWebSocketBlockChanged(e)
		{
			const isWebSocketBlocked = e.isWebSocketBlocked;

			if (isWebSocketBlocked && this.connectionType === ConnectionType.WebSocket && !this.isConnected())
			{
				clearTimeout(this.reconnectTimeout);

				this.connectionAttempt = 0;
				this.connectionType = ConnectionType.LongPolling;
				this.scheduleReconnect(1);
			}
			else if (!isWebSocketBlocked && this.connectionType === ConnectionType.LongPolling)
			{
				clearTimeout(this.reconnectTimeout);
				clearTimeout(this.restoreWebSocketTimeout);

				this.connectionAttempt = 0;
				this.connectionType = ConnectionType.WebSocket;
				this.scheduleReconnect(1);
			}
		}

		onWebSocketOpen()
		{
			this.unloading = false;
			this.starting = false;
			this.connectionAttempt = 0;
			this.isManualDisconnect = false;
			this.status = PullStatus.Online;
			this.sharedConfig.setWebSocketBlocked(false);

			// to prevent fallback to long polling in case of networking problems
			this.sharedConfig.setLongPollingBlocked(true);

			if (this.connectionType == ConnectionType.LongPolling)
			{
				this.connectionType = ConnectionType.WebSocket;
				this._connectors.longPolling.disconnect();
			}

			if (this.restoreWebSocketTimeout)
			{
				clearTimeout(this.restoreWebSocketTimeout);
				this.restoreWebSocketTimeout = null;
			}
			this.logToConsole('Pull: Websocket connection with push-server opened');
			if (this._connectPromise)
			{
				this._connectPromise.resolve();
			}
		}

		onWebSocketDisconnect(e)
		{
			if (this.connectionType === ConnectionType.WebSocket)
			{
				this.status = PullStatus.Offline;
			}

			if (!e)
			{
				e = {};
			}

			this.logToConsole('Pull: Websocket connection with push-server closed. Code: ' + e.code + ', reason: ' + e.reason, true);
			if (!this.isManualDisconnect)
			{
				if (e.code == CloseReasons.WRONG_CHANNEL_ID)
				{
					this.scheduleRestart(CloseReasons.WRONG_CHANNEL_ID, "restarting to reload config");
				}
				else
				{
					this.scheduleReconnect();
				}
			}

			// to prevent fallback to long polling in case of networking problems
			this.sharedConfig.setLongPollingBlocked(true);
			this.isManualDisconnect = false;

			this.clearPingWaitTimeout();
		}

		onWebSocketError(e)
		{
			this.starting = false;
			if (this.connectionType === ConnectionType.WebSocket)
			{
				this.status = PullStatus.Offline;
			}

			console.error(Utils.getDateForLog() + ": Pull: WebSocket connection error", e);
			this.scheduleReconnect();
			if (this._connectPromise)
			{
				this._connectPromise.reject();
			}

			this.clearPingWaitTimeout();
		}

		onLongPollingDisconnect(e)
		{
			if (this.connectionType === ConnectionType.LongPolling)
			{
				this.status = PullStatus.Offline;
			}

			if (!e)
			{
				e = {};
			}

			this.logToConsole('Pull: Long polling connection with push-server closed. Code: ' + e.code + ', reason: ' + e.reason);
			if (!this.isManualDisconnect)
			{
				this.scheduleReconnect();
			}
			this.isManualDisconnect = false;
			this.clearPingWaitTimeout();
		}

		onLongPollingError(e)
		{
			this.starting = false;
			if (this.connectionType === ConnectionType.LongPolling)
			{
				this.status = PullStatus.Offline;
			}
			console.error(Utils.getDateForLog() + ': Pull: Long polling connection error', e);
			this.scheduleReconnect();
			if (this._connectPromise)
			{
				this._connectPromise.reject();
			}
			this.clearPingWaitTimeout();
		}

		isConnected()
		{
			return this.connector ? this.connector.connected : false;
		}

		onBeforeUnload()
		{
			this.unloading = true;

			const session = Utils.clone(this.session);
			session.ttl = (new Date()).getTime() + LS_SESSION_CACHE_TIME * 1000;
			if (this.storage)
			{
				try
				{
					this.storage.set(LS_SESSION, JSON.stringify(session), LS_SESSION_CACHE_TIME);
				} catch (e)
				{
					console.error(Utils.getDateForLog() + " Pull: Could not save session info in local storage. Error: ", e);
				}
			}

			this.scheduleReconnect(15);
		}

		onOffline()
		{
			this.disconnect("1000", "offline");
		}

		onOnline()
		{
			this.connect();
		}

		handleInternalPullEvent(command, message)
		{
			switch (command.toUpperCase())
			{
				case SystemCommands.CHANNEL_EXPIRE:
				{
					if (message.params.action == 'reconnect')
					{
						this.config.channels[message.params.channel.type] = message.params.new_channel;
						this.logToConsole("Pull: new config for " + message.params.channel.type + " channel set:\n", this.config.channels[message.params.channel.type]);

						this.reconnect(CloseReasons.CONFIG_REPLACED, "config was replaced");
					}
					else
					{
						this.restart(CloseReasons.CHANNEL_EXPIRED, "channel expired");
					}
					break;
				}
				case SystemCommands.CONFIG_EXPIRE:
				{
					this.restart(CloseReasons.CONFIG_EXPIRED, "config expired");
					break;
				}
				case SystemCommands.SERVER_RESTART:
				{
					this.reconnect(CloseReasons.SERVER_RESTARTED, "server was restarted", 15);
					break;
				}
				default://
			}
		}

		checkRevision(serverRevision)
		{
			if (this.skipCheckRevision)
			{
				return true;
			}

			serverRevision = parseInt(serverRevision);
			if (serverRevision > 0 && serverRevision != REVISION)
			{
				this.enabled = false;
				if (typeof BX.message !== 'undefined')
				{
					this.showNotification(BX.message('PULL_OLD_REVISION'));
				}
				this.disconnect(CloseReasons.NORMAL_CLOSURE, 'check_revision');

				if (typeof BX.onCustomEvent !== 'undefined')
				{
					BX.onCustomEvent(window, 'onPullRevisionUp', [serverRevision, REVISION]);
				}

				this.emit({
					type: SubscriptionType.Revision,
					data: {
						server: serverRevision,
						client: REVISION
					}
				});

				this.logToConsole("Pull revision changed from " + REVISION + " to " + serverRevision + ". Reload required");

				return false;
			}
			return true;
		}

		showNotification(text)
		{
			if (this.notificationPopup || typeof BX.PopupWindow === 'undefined')
			{
				return;
			}

			this.notificationPopup = new BX.PopupWindow('bx-notifier-popup-confirm', null, {
				zIndex: 200,
				autoHide: false,
				closeByEsc: false,
				overlay: true,
				content: BX.create("div", {
					props: {className: "bx-messenger-confirm"},
					html: text
				}),
				buttons: [
					new BX.PopupWindowButton({
						text: BX.message('JS_CORE_WINDOW_CLOSE'),
						className: "popup-window-button-decline",
						events: {
							click: () =>
							{
								this.notificationPopup.close();
							}
						}
					})
				],
				events: {
					onPopupClose: function () //not arrow function; this should come from popup
					{
						this.destroy()
					},
					onPopupDestroy: () =>
					{
						this.notificationPopup = null;
					}
				}
			});
			this.notificationPopup.show();
		}

		getRevision()
		{
			return (this.config && this.config.api) ? this.config.api.revision_web : null;
		}

		getServerVersion()
		{
			return (this.config && this.config.server) ? this.config.server.version : 0;
		}

		getServerMode()
		{
			return (this.config && this.config.server) ? this.config.server.mode : null;
		}

		getConfig()
		{
			return this.config;
		}

		getDebugInfo()
		{
			if (!console || !console.info || !JSON || !JSON.stringify)
			{
				return false;
			}

			let configDump;
			if (this.config && this.config.channels)
			{
				configDump = "ChannelID: " + (this.config.channels.private ? this.config.channels.private.id : "n/a")  + "\n" +
					"ChannelDie: " + (this.config.channels.private ? this.config.channels.private.end : "n/a" ) + "\n" +
					("shared" in this.config.channels ? "ChannelDieShared: " + this.config.channels.shared.end : "");
			}
			else
			{
				configDump = "Config error: config is not loaded";
			}

			let websocketMode = "-";
			if (this._connectors.webSocket && this._connectors.webSocket.socket)
			{
				if (this.isJsonRpc())
				{
					websocketMode = "json-rpc"
				}
				else
				{
					websocketMode = (this._connectors.webSocket.socket.url.search("binaryMode=true") != -1 ? "protobuf" : "text")
				}
			}

			const watchTagsDump = JSON.stringify(this.watchTagsQueue);
			const text = "\n========= PULL DEBUG ===========\n" +
				"UserId: " + this.userId + " " + (this.userId > 0 ? '' : '(guest)') + "\n" +
				(this.guestMode && this.guestUserId !== 0 ? "Guest userId: " + this.guestUserId + "\n" : "") +
				"Browser online: " + (navigator.onLine ? 'Y' : 'N') + "\n" +
				"Connect: " + (this.isConnected() ? 'Y' : 'N') + "\n" +
				"Server type: " + (this.isSharedMode() ? 'cloud' : 'local') + "\n" +
				"WebSocket supported: " + (this.isWebSocketSupported() ? 'Y' : 'N') + "\n" +
				"WebSocket connected: " + (this._connectors.webSocket && this._connectors.webSocket.connected ? 'Y' : 'N') + "\n" +
				"WebSocket mode: " + websocketMode + "\n" +

				"Try connect: " + (this.reconnectTimeout ? 'Y' : 'N') + "\n" +
				"Try number: " + (this.connectionAttempt) + "\n" +
				"\n" +
				"Path: " + (this.connector ? this.connector.path : '-') + "\n" +
				configDump + "\n" +
				"\n" +
				"Last message: " + (this.session.mid > 0 ? this.session.mid : '-') + "\n" +
				"Session history: " + JSON.stringify(this.session.history) + "\n" +
				"Watch tags: " + (watchTagsDump == '{}' ? '-' : watchTagsDump) + "\n" +
				"================================\n";

			return console.info(text);
		}

		enableLogging(loggingFlag)
		{
			if (loggingFlag === undefined)
			{
				loggingFlag = true;
			}
			loggingFlag = loggingFlag === true;

			this.sharedConfig.setLoggingEnabled(loggingFlag);
			this.loggingEnabled = loggingFlag;
		}

		capturePullEvent(debugFlag)
		{
			if (debugFlag === undefined)
			{
				debugFlag = true;
			}

			this.debug = debugFlag;
		}

		getConnectionPath(connectionType)
		{
			let path;
			let params = {};

			switch (connectionType)
			{
				case ConnectionType.WebSocket:
					path = this.isSecure ? this.config.server.websocket_secure : this.config.server.websocket;
					break;
				case ConnectionType.LongPolling:
					path = this.isSecure ? this.config.server.long_pooling_secure : this.config.server.long_polling;
					break;
				default:
					throw new Error("Unknown connection type " + connectionType);
			}

			if (!Utils.isNotEmptyString(path))
			{
				return false;
			}

			if (typeof (this.config.jwt) == 'string' && this.config.jwt !== '')
			{
				params['token'] = this.config.jwt;
			}
			else
			{
				let channels = [];
				['private', 'shared'].forEach((type) =>
				{
					if (typeof this.config.channels[type] !== 'undefined')
					{
						channels.push(this.config.channels[type].id);
					}
				});
				if (channels.length === 0)
				{
					return false;
				}

				params['CHANNEL_ID'] = channels.join('/');
			}

			if (this.isJsonRpc())
			{
				params.jsonRpc = 'true';
			}
			else if (this.isProtobufSupported())
			{
				params.binaryMode = 'true';
			}

			if (this.isSharedMode())
			{
				if (!this.config.clientId)
				{
					throw new Error("Push-server is in shared mode, but clientId is not set");
				}
				params.clientId = this.config.clientId;
			}
			if (this.session.mid)
			{
				params.mid = this.session.mid;
			}
			if (this.session.tag)
			{
				params.tag = this.session.tag;
			}
			if (this.session.time)
			{
				params.time = this.session.time;
			}
			params.revision = REVISION;

			return path + '?' + Utils.buildQueryString(params);
		}

		getPublicationPath()
		{
			const path = this.isSecure ? this.config.server.publish_secure : this.config.server.publish;
			if (!path)
			{
				return '';
			}

			let channels = [];
			for (let type in this.config.channels)
			{
				if (!this.config.channels.hasOwnProperty(type))
				{
					continue;
				}
				channels.push(this.config.channels[type].id);
			}

			const params = {
				CHANNEL_ID: channels.join('/')
			};

			return path + '?' + Utils.buildQueryString(params);
		}

		/**
		 * Returns reconnect delay in seconds
		 * @param attemptNumber
		 * @return {number}
		 */
		getConnectionAttemptDelay(attemptNumber)
		{
			let result;
			if (attemptNumber < 1)
			{
				result = 0.5;
			}
			else if (attemptNumber < 3)
			{
				result = 15;
			}
			else if (attemptNumber < 5)
			{
				result = 45;
			}
			else if (attemptNumber < 10)
			{
				result = 600;
			}
			else
			{
				result = 3600;
			}

			return result + (result * Math.random() * 0.2);
		}

		sendPullStatusDelayed(status, delay)
		{
			if (this.offlineTimeout)
			{
				clearTimeout(this.offlineTimeout)
			}
			this.offlineTimeout = setTimeout(
				() =>
				{
					this.offlineTimeout = null;
					this.sendPullStatus(status);
				},
				delay
			)
		}

		sendPullStatus(status)
		{
			if (this.unloading)
			{
				return;
			}

			if (typeof BX.onCustomEvent !== 'undefined')
			{
				BX.onCustomEvent(window, 'onPullStatus', [status]);
			}

			this.emit({
				type: SubscriptionType.Status,
				data: {
					status: status
				}
			});
		}

		extendWatch(tag, force)
		{
			if (!tag || this.watchTagsQueue[tag])
			{
				return false;
			}

			this.watchTagsQueue[tag] = true;
			if (force)
			{
				this.updateWatch(force);
			}
		}

		updateWatch(force)
		{
			clearTimeout(this.watchUpdateTimeout);
			this.watchUpdateTimeout = setTimeout(() =>
			{
				const watchTags = Object.keys(this.watchTagsQueue);
				if (watchTags.length > 0)
				{
					this.restClient.callMethod('pull.watch.extend', {tags: watchTags}, (result) =>
					{
						if (result.error())
						{
							this.updateWatch();

							return false;
						}

						const updatedTags = result.data();

						for (let tagId in updatedTags)
						{
							if (updatedTags.hasOwnProperty(tagId) && !updatedTags[tagId])
							{
								this.clearWatch(tagId);
							}
						}
						this.updateWatch();
					})
				}
				else
				{
					this.updateWatch();
				}
			}, force ? this.watchForceUpdateInterval : this.watchUpdateInterval);
		}

		clearWatch(tagId)
		{
			delete this.watchTagsQueue[tagId];
		}

		updatePingWaitTimeout()
		{
			clearTimeout(this.pingWaitTimeout);
			this.pingWaitTimeout = setTimeout(this.onPingTimeoutHandler, PING_TIMEOUT * 2 * 1000)
		}

		clearPingWaitTimeout()
		{
			clearTimeout(this.pingWaitTimeout);
			this.pingWaitTimeout = null;
		}

		onPingTimeout()
		{
			this.pingWaitTimeout = null;
			if (!this.enabled || !this.isConnected())
			{
				return;
			}

			console.warn("No pings are received in " + PING_TIMEOUT * 2 + " seconds. Reconnecting")
			this.disconnect(CloseReasons.STUCK, "connection stuck");
			this.scheduleReconnect();
		}

		// old functions, not used anymore.
		setPrivateVar() {}

		returnPrivateVar() {}

		expireConfig() {}

		updateChannelID() {}

		tryConnect() {}

		tryConnectDelay() {}

		tryConnectSet() {}

		updateState() {}

		setUpdateStateStepCount() {}

		supportWebSocket()
		{
			return this.isWebSocketSupported();
		}

		isWebSoketConnected()
		{
			return this.isConnected() && this.connectionType == ConnectionType.WebSocket;
		}

		getPullServerStatus() {return this.isConnected()}

		closeConfirm()
		{
			if (this.notificationPopup)
			{
				this.notificationPopup.destroy();
			}
		}
	}

	class SharedConfig
	{
		constructor(params)
		{
			params = params || {};
			this.storage = params.storage || new StorageManager();

			this.ttl = 24 * 60 * 60;

			this.lsKeys = {
				websocketBlocked: 'bx-pull-websocket-blocked',
				longPollingBlocked: 'bx-pull-longpolling-blocked',
				loggingEnabled: 'bx-pull-logging-enabled'
			};

			this.callbacks = {
				onWebSocketBlockChanged: (Utils.isFunction(params.onWebSocketBlockChanged) ? params.onWebSocketBlockChanged : function () {})
			};

			if (this.storage)
			{
				window.addEventListener('storage', this.onLocalStorageSet.bind(this));
			}
		}

		onLocalStorageSet(params)
		{
			if (
				this.storage.compareKey(params.key, this.lsKeys.websocketBlocked)
				&& params.newValue != params.oldValue
			)
			{
				this.callbacks.onWebSocketBlockChanged({
					isWebSocketBlocked: this.isWebSocketBlocked()
				})
			}
		}

		isWebSocketBlocked()
		{
			if (!this.storage)
			{
				return false;
			}

			return this.storage.get(this.lsKeys.websocketBlocked, 0) > Utils.getTimestamp();
		}

		setWebSocketBlocked(isWebSocketBlocked)
		{
			if (!this.storage)
			{
				return false;
			}

			try
			{
				this.storage.set(this.lsKeys.websocketBlocked, (isWebSocketBlocked ? Utils.getTimestamp() + this.ttl : 0));
			} catch (e)
			{
				console.error(Utils.getDateForLog() + " Pull: Could not save WS_blocked flag in local storage. Error: ", e);
			}
		}

		isLongPollingBlocked()
		{
			if (!this.storage)
			{
				return false;
			}

			return this.storage.get(this.lsKeys.longPollingBlocked, 0) > Utils.getTimestamp();
		}

		setLongPollingBlocked(isLongPollingBlocked)
		{
			if (!this.storage)
			{
				return false;
			}

			try
			{
				this.storage.set(this.lsKeys.longPollingBlocked, (isLongPollingBlocked ? Utils.getTimestamp() + this.ttl : 0));
			} catch (e)
			{
				console.error(Utils.getDateForLog() + " Pull: Could not save LP_blocked flag in local storage. Error: ", e);
			}
		}

		isLoggingEnabled()
		{
			if (!this.storage)
			{
				return false;
			}

			return this.storage.get(this.lsKeys.loggingEnabled, 0) > Utils.getTimestamp();
		}

		setLoggingEnabled(isLoggingEnabled)
		{
			if (!this.storage)
			{
				return false;
			}

			try
			{
				this.storage.set(this.lsKeys.loggingEnabled, (isLoggingEnabled ? Utils.getTimestamp() + this.ttl : 0));
			} catch (e)
			{
				console.error("LocalStorage error: ", e);
				return false;
			}
		}
	}

	class AbstractConnector
	{
		_connected = false;
		connectionType = "";

		disconnectCode = '';
		disconnectReason = '';

		constructor(config)
		{
			this.parent = config.parent;
			this.callbacks = {
				onOpen: Utils.isFunction(config.onOpen) ? config.onOpen : function () {},
				onDisconnect: Utils.isFunction(config.onDisconnect) ? config.onDisconnect : function () {},
				onError: Utils.isFunction(config.onError) ? config.onError : function () {},
				onMessage: Utils.isFunction(config.onMessage) ? config.onMessage : function () {}
			};
		}

		get connected()
		{
			return this._connected
		}

		set connected(value)
		{
			if (value == this._connected)
			{
				return;
			}

			this._connected = value;

			if (this._connected)
			{
				this.callbacks.onOpen();
			}
			else
			{
				this.callbacks.onDisconnect({
					code: this.disconnectCode,
					reason: this.disconnectReason
				});
			}
		}

		get path()
		{
			return this.parent.getConnectionPath(this.connectionType);
		}
	}

	class WebSocketConnector extends AbstractConnector
	{
		constructor(config)
		{
			super(config)
			this.connectionType = ConnectionType.WebSocket;
			this.socket = null;

			this.onSocketOpenHandler = this.onSocketOpen.bind(this);
			this.onSocketCloseHandler = this.onSocketClose.bind(this);
			this.onSocketErrorHandler = this.onSocketError.bind(this);
			this.onSocketMessageHandler = this.onSocketMessage.bind(this);
		}

		connect()
		{
			if (this.socket)
			{
				if (this.socket.readyState === 1)
				{
					// already connected
					return true;
				}
				else
				{
					this.socket.removeEventListener('open', this.onSocketOpenHandler);
					this.socket.removeEventListener('close', this.onSocketCloseHandler);
					this.socket.removeEventListener('error', this.onSocketErrorHandler);
					this.socket.removeEventListener('message', this.onSocketMessageHandler);

					this.socket.close();
					this.socket = null;
				}
			}

			this.createSocket();
		}

		disconnect(code, message)
		{
			if (this.socket !== null)
			{
				this.socket.removeEventListener('open', this.onSocketOpenHandler);
				this.socket.removeEventListener('close', this.onSocketCloseHandler);
				this.socket.removeEventListener('error', this.onSocketErrorHandler);
				this.socket.removeEventListener('message', this.onSocketMessageHandler);

				this.socket.close(code, message);
			}
			this.socket = null;
			this.disconnectCode = code;
			this.disconnectReason = message;
			this.connected = false;
		}

		createSocket()
		{
			if (this.socket)
			{
				throw new Error("Socket already exists");
			}

			if (!this.path)
			{
				throw new Error("Websocket connection path is not defined");
			}

			this.socket = new WebSocket(this.path);
			this.socket.binaryType = 'arraybuffer';

			this.socket.addEventListener('open', this.onSocketOpenHandler);
			this.socket.addEventListener('close', this.onSocketCloseHandler);
			this.socket.addEventListener('error', this.onSocketErrorHandler);
			this.socket.addEventListener('message', this.onSocketMessageHandler);
		}

		/**
		 * Sends some data to the server via websocket connection.
		 * @param {ArrayBuffer} buffer Data to send.
		 * @return {boolean}
		 */
		send(buffer)
		{
			if (!this.socket || this.socket.readyState !== 1)
			{
				console.error(Utils.getDateForLog() + ": Pull: WebSocket is not connected");
				return false;
			}

			this.socket.send(buffer);
			return true;
		}

		onSocketOpen()
		{
			this.connected = true;
		}

		onSocketClose(e)
		{
			this.socket = null;
			this.disconnectCode = e.code;
			this.disconnectReason = e.reason;
			this.connected = false;
		}

		onSocketError(e)
		{
			this.callbacks.onError(e);
		}

		onSocketMessage(e)
		{
			this.callbacks.onMessage(e.data);
		}

		destroy()
		{
			if (this.socket)
			{
				this.socket.close();
				this.socket = null;
			}
		}
	}

	class LongPollingConnector extends AbstractConnector
	{
		constructor(config)
		{
			super(config);

			this.active = false;
			this.connectionType = ConnectionType.LongPolling;
			this.requestTimeout = null;
			this.failureTimeout = null;
			this.xhr = this.createXhr();
			this.requestAborted = false;
		}

		createXhr()
		{
			const result = new XMLHttpRequest();
			if (this.parent.isProtobufSupported() && !this.parent.isJsonRpc())
			{
				result.responseType = "arraybuffer";
			}
			result.addEventListener("readystatechange", this.onXhrReadyStateChange.bind(this));
			return result;
		}

		connect()
		{
			this.active = true;
			this.performRequest();
		}

		disconnect(code, reason)
		{
			this.active = false;

			if (this.failureTimeout)
			{
				clearTimeout(this.failureTimeout);
				this.failureTimeout = null;
			}
			if (this.requestTimeout)
			{
				clearTimeout(this.requestTimeout);
				this.requestTimeout = null;
			}

			if (this.xhr)
			{
				this.requestAborted = true;
				this.xhr.abort();
			}

			this.disconnectCode = code;
			this.disconnectReason = reason;
			this.connected = false;
		}

		performRequest()
		{
			if (!this.active)
			{
				return;
			}

			if (!this.path)
			{
				throw new Error("Long polling connection path is not defined");
			}
			if (this.xhr.readyState !== 0 && this.xhr.readyState !== 4)
			{
				return;
			}

			clearTimeout(this.failureTimeout);
			clearTimeout(this.requestTimeout);

			this.failureTimeout = setTimeout(() => { this.connected = true }, 5000);
			this.requestTimeout = setTimeout(this.onRequestTimeout.bind(this), LONG_POLLING_TIMEOUT * 1000);

			this.xhr.open("GET", this.path);
			this.xhr.send();
		}

		onRequestTimeout()
		{
			this.requestAborted = true;
			this.xhr.abort();
			this.performRequest();
		}

		onXhrReadyStateChange()
		{
			if (this.xhr.readyState === 4)
			{
				if (!this.requestAborted || this.xhr.status == 200)
				{
					this.onResponse(this.xhr.response);
				}
				this.requestAborted = false;
			}
		}

		/**
		 * Sends some data to the server via http request.
		 * @param {ArrayBuffer} buffer Data to send.
		 * @return {bool}
		 */
		send(buffer)
		{
			const path = this.parent.getPublicationPath();
			if (!path)
			{
				console.error(Utils.getDateForLog() + ": Pull: publication path is empty");
				return false;
			}

			let xhr = new XMLHttpRequest();
			xhr.open("POST", path);
			xhr.send(buffer);
		}

		onResponse(response)
		{
			if (this.failureTimeout)
			{
				clearTimeout(this.failureTimeout);
				this.failureTimeout = 0;
			}
			if (this.requestTimeout)
			{
				clearTimeout(this.requestTimeout);
				this.requestTimeout = 0;
			}

			if (this.xhr.status == 200)
			{
				this.connected = true;
				if (Utils.isNotEmptyString(response) || (response instanceof ArrayBuffer))
				{
					this.callbacks.onMessage(response);
				}
				else
				{
					this.parent.session.mid = null;
				}
				this.performRequest();
			}
			else if (this.xhr.status == 304)
			{
				this.connected = true;
				if (this.xhr.getResponseHeader("Expires") === "Thu, 01 Jan 1973 11:11:01 GMT")
				{
					const lastMessageId = this.xhr.getResponseHeader("Last-Message-Id");
					if (Utils.isNotEmptyString(lastMessageId))
					{
						this.parent.setLastMessageId(lastMessageId);
					}
				}
				this.performRequest();
			}
			else
			{
				this.callbacks.onError('Could not connect to the server');
				this.connected = false;
			}
		}
	}

	class ChannelManager
	{
		constructor(params)
		{
			this.publicIds = {};

			this.restClient = typeof params.restClient !== "undefined" ? params.restClient : BX.rest;

			this.getPublicListMethod = params.getPublicListMethod;
		}

		/**
		 *
		 * @param {Array} users Array of user ids.
		 * @return {Promise}
		 */
		getPublicIds(users)
		{
			const now = new Date();
			let result = {};
			let unknownUsers = [];

			for (let i = 0; i < users.length; i++)
			{
				const userId = users[i];
				if (this.publicIds[userId] && this.publicIds[userId]['end'] > now)
				{
					result[userId] = this.publicIds[userId];
				}
				else
				{
					unknownUsers.push(userId);
				}
			}

			if (unknownUsers.length === 0)
			{
				return Promise.resolve(result);
			}

			return new Promise((resolve) =>
			{
				this.restClient.callMethod(this.getPublicListMethod, {users: unknownUsers}).then((response) =>
				{
					if (response.error())
					{
						return resolve({});
					}

					const data = response.data();
					this.setPublicIds(Utils.objectValues(data));
					unknownUsers.forEach((userId) =>
					{
						result[userId] = this.publicIds[userId];
					});

					resolve(result);
				});
			})
		}

		/**
		 *
		 * @param {object[]} publicIds
		 * @param {integer} publicIds.user_id
		 * @param {string} publicIds.public_id
		 * @param {string} publicIds.signature
		 * @param {Date} publicIds.start
		 * @param {Date} publicIds.end
		 */
		setPublicIds(publicIds)
		{
			for (let i = 0; i < publicIds.length; i++)
			{
				const publicIdDescriptor = publicIds[i];
				const userId = publicIdDescriptor.user_id;
				this.publicIds[userId] = {
					userId: userId,
					publicId: publicIdDescriptor.public_id,
					signature: publicIdDescriptor.signature,
					start: new Date(publicIdDescriptor.start),
					end: new Date(publicIdDescriptor.end)
				}
			}
		};
	}

	class StorageManager
	{
		constructor(params)
		{
			params = params || {};

			this.userId = params.userId ? params.userId : (typeof BX.message !== 'undefined' && BX.message.USER_ID ? BX.message.USER_ID : 0);
			this.siteId = params.siteId ? params.siteId : (typeof BX.message !== 'undefined' && BX.message.SITE_ID ? BX.message.SITE_ID : 'none');
		}

		set(name, value)
		{
			if (typeof window.localStorage === 'undefined')
			{
				return false;
			}
			if (typeof value != 'string')
			{
				if (value)
				{
					value = JSON.stringify(value);
				}
			}
			return window.localStorage.setItem(this.getKey(name), value)
		}

		get(name, defaultValue)
		{
			if (typeof window.localStorage === 'undefined')
			{
				return defaultValue || null;
			}

			const result = window.localStorage.getItem(this.getKey(name));
			if (result === null)
			{
				return defaultValue || null;
			}

			return JSON.parse(result);
		}

		remove(name)
		{
			if (typeof window.localStorage === 'undefined')
			{
				return false;
			}
			return window.localStorage.removeItem(this.getKey(name));
		}

		getKey(name)
		{
			return 'bx-pull-' + this.userId + '-' + this.siteId + '-' + name;
		}

		compareKey(eventKey, userKey)
		{
			return eventKey === this.getKey(userKey);
		}
	}

	class JsonRpc
	{
		idCounter = 0;

		handlers = {};
		rpcResponseAwaiters = new Map();

		constructor(options)
		{
			this.connector = options.connector;
			if (Utils.isPlainObject(options.handlers))
			{
				for (let method in options.handlers)
				{
					this.handle(method, options.handlers[method]);
				}
			}
		}

		/**
		 * @param {string} method
		 * @param {function} handler
		 */
		handle(method, handler)
		{
			this.handlers[method] = handler;
		}

		/**
		 * Sends RPC command to the server.
		 *
		 * @param {string} method Method name
		 * @param {object} params
		 * @param {int} timeout
		 * @returns {Promise}
		 */
		executeOutgoingRpcCommand(method, params, timeout)
		{
			if (!timeout)
			{
				timeout = 5;
			}
			return new Promise((resolve, reject) =>
			{
				const request = this.createRequest(method, params);

				if (!this.connector.send(JSON.stringify(request)))
				{
					reject(new ErrorNotConnected('websocket is not connected'));
				}

				const t = setTimeout(() => {
					this.rpcResponseAwaiters.delete(request.id);
					reject(new ErrorTimeout('no response'));
				}, timeout * 1000);
				this.rpcResponseAwaiters.set(request.id, {resolve, reject, timeout: t});
			})
		}

		/**
		 * Executes array or rpc commands. Returns array of promises, each promise will be resolved individually.
		 *
		 * @param {JsonRpcRequest[]} batch
		 * @returns {Promise[]}
		 */
		executeOutgoingRpcBatch(batch)
		{
			let requests = [];
			let promises = [];
			batch.forEach(({method, params, id}) =>
			{
				const request = this.createRequest(method, params, id);
				requests.push(request);
				promises.push(new Promise((resolve, reject) => this.rpcResponseAwaiters.set(request.id, {
					resolve,
					reject
				})));
			});

			this.connector.send(JSON.stringify(requests));
			return promises;
		}

		processRpcResponse(response)
		{
			if ("id" in response && this.rpcResponseAwaiters.has(response.id))
			{
				const awaiter = this.rpcResponseAwaiters.get(response.id)
				if ("result" in response)
				{
					awaiter.resolve(response.result)
				}
				else if ("error" in response)
				{
					awaiter.reject(response.error)
				}
				else
				{
					awaiter.reject(new Error("wrong response structure"))
				}

				clearTimeout(awaiter.timeout)
				this.rpcResponseAwaiters.delete(response.id)
			}
			else
			{
				console.error("Received rpc response with unknown id", response)
			}
		}

		parseJsonRpcMessage(message)
		{
			let decoded
			try
			{
				decoded = JSON.parse(message);
			} catch (e)
			{
				console.error(Utils.getDateForLog() + ": Pull: Could not decode json rpc message", e);
			}

			if (Utils.isArray(decoded))
			{
				return this.executeIncomingRpcBatch(decoded);
			}
			else if (Utils.isJsonRpcRequest(decoded))
			{
				return this.executeIncomingRpcCommand(decoded);
			}
			else if (Utils.isJsonRpcResponse(decoded))
			{
				return this.processRpcResponse(decoded);
			}
			else
			{
				console.error(Utils.getDateForLog() + ": Pull: unknown rpc packet", decoded);
			}
		}

		/**
		 * Executes RPC command, received from the server
		 *
		 * @param {string} method
		 * @param {object} params
		 * @returns {object}
		 */
		executeIncomingRpcCommand({method, params})
		{
			if (method in this.handlers)
			{
				return this.handlers[method].call(this, params)
			}

			return {
				"error": RpcError.MethodNotFound
			}
		}

		executeIncomingRpcBatch(batch)
		{
			let result = [];
			for (let command of batch)
			{
				if ("jsonrpc" in command)
				{
					if ("method" in command)
					{
						let commandResult = this.executeIncomingRpcCommand(command)
						if (commandResult)
						{
							commandResult["jsonrpc"] = JSON_RPC_VERSION;
							commandResult["id"] = command["id"];

							result.push(commandResult)
						}
					}
					else
					{
						this.processRpcResponse(command)
					}
				}
				else
				{
					console.error(Utils.getDateForLog() + ": Pull: unknown rpc command in batch", command);
					result.push({
						"jsonrpc": "2.0",
						"error": RpcError.InvalidRequest,
					})
				}
			}

			return result;
		}

		nextId()
		{
			return ++this.idCounter;
		}

		createPublishRequest(messageBatch)
		{
			let result = messageBatch.map(message => this.createRequest('publish', message));

			if (result.length === 0)
			{
				return result[0]
			}

			return result;
		}

		createRequest(method, params, id)
		{
			if (!id)
			{
				id = this.nextId()
			}

			return {
				jsonrpc: JSON_RPC_VERSION,
				method: method,
				params: params,
				id: id
			}
		}
	}

	class ErrorNotConnected extends Error
	{
		constructor(message)
		{
			super(message);
			this.name = 'ErrorNotConnected';
		}
	}

	class ErrorTimeout extends Error
	{
		constructor(message)
		{
			super(message);
			this.name = 'ErrorTimeout';
		}
	}

	const Utils = {
		browser: {
			IsChrome: function ()
			{
				return navigator.userAgent.toLowerCase().indexOf('chrome') != -1;
			},
			IsFirefox: function ()
			{
				return navigator.userAgent.toLowerCase().indexOf('firefox') != -1;
			},
			IsIe: function ()
			{
				return navigator.userAgent.match(/(Trident\/|MSIE\/)/) !== null;
			}
		},
		getTimestamp: function ()
		{
			return (new Date()).getTime();
		},
		/**
		 * Reduces errors array to single string.
		 * @param {array} errors
		 * @return {string}
		 */
		errorsToString: function (errors)
		{
			if (!this.isArray(errors))
			{
				return "";
			}
			else
			{
				return errors.reduce(function (result, currentValue)
				{
					if (result != "")
					{
						result += "; ";
					}
					return result + currentValue.code + ": " + currentValue.message;
				}, "");
			}
		},
		isString: function (item)
		{
			return item === '' ? true : (item ? (typeof (item) == "string" || item instanceof String) : false);
		},
		isArray: function (item)
		{
			return item && Object.prototype.toString.call(item) == "[object Array]";
		},
		isFunction: function (item)
		{
			return item === null ? false : (typeof (item) == "function" || item instanceof Function);
		},
		isDomNode: function (item)
		{
			return item && typeof (item) == "object" && "nodeType" in item;
		},
		isDate: function (item)
		{
			return item && Object.prototype.toString.call(item) == "[object Date]";
		},
		isPlainObject: function (item)
		{
			if (!item || typeof (item) !== "object" || item.nodeType)
			{
				return false;
			}

			const hasProp = Object.prototype.hasOwnProperty;
			try
			{
				if (item.constructor && !hasProp.call(item, "constructor") && !hasProp.call(item.constructor.prototype, "isPrototypeOf"))
				{
					return false;
				}
			} catch (e)
			{
				return false;
			}

			let key;
			for (key in item)
			{
			}
			return typeof (key) === "undefined" || hasProp.call(item, key);
		},
		isNotEmptyString: function (item)
		{
			return this.isString(item) ? item.length > 0 : false;
		},
		isJsonRpcRequest: function (item)
		{
			return (
				typeof (item) === "object"
				&& item
				&& "jsonrpc" in item
				&& Utils.isNotEmptyString(item.jsonrpc)
				&& "method" in item
				&& Utils.isNotEmptyString(item.method)
			);
		},
		isJsonRpcResponse: function (item)
		{
			return (
				typeof (item) === "object"
				&& item
				&& "jsonrpc" in item
				&& Utils.isNotEmptyString(item.jsonrpc)
				&& "id" in item
				&& (
					"result" in item
					|| "error" in item
				)
			);

		},
		buildQueryString: function (params)
		{
			let result = '';
			for (let key in params)
			{
				if (!params.hasOwnProperty(key))
				{
					continue;
				}
				const value = params[key];
				if (Utils.isArray(value))
				{
					value.forEach((valueElement, index) =>
					{
						result += encodeURIComponent(key + "[" + index + "]") + "=" + encodeURIComponent(valueElement) + "&";
					});
				}
				else
				{
					result += encodeURIComponent(key) + "=" + encodeURIComponent(value) + "&";
				}
			}

			if (result.length > 0)
			{
				result = result.substr(0, result.length - 1);
			}

			return result;
		},
		objectValues: function values(obj)
		{
			let result = [];
			for (let key in obj)
			{
				if (obj.hasOwnProperty(key) && obj.propertyIsEnumerable(key))
				{
					result.push(obj[key]);
				}
			}
			return result;
		},
		clone: function (obj, bCopyObj)
		{
			let _obj, i, l;
			if (bCopyObj !== false)
			{
				bCopyObj = true;
			}

			if (obj === null)
			{
				return null;
			}

			if (this.isDomNode(obj))
			{
				_obj = obj.cloneNode(bCopyObj);
			}
			else if (typeof obj == 'object')
			{
				if (this.isArray(obj))
				{
					_obj = [];
					for (i = 0, l = obj.length; i < l; i++)
					{
						if (typeof obj[i] == "object" && bCopyObj)
						{
							_obj[i] = this.clone(obj[i], bCopyObj);
						}
						else
						{
							_obj[i] = obj[i];
						}
					}
				}
				else
				{
					_obj = {};
					if (obj.constructor)
					{
						if (this.isDate(obj))
						{
							_obj = new Date(obj);
						}
						else
						{
							_obj = new obj.constructor();
						}
					}

					for (i in obj)
					{
						if (!obj.hasOwnProperty(i))
						{
							continue;
						}
						if (typeof obj[i] == "object" && bCopyObj)
						{
							_obj[i] = this.clone(obj[i], bCopyObj);
						}
						else
						{
							_obj[i] = obj[i];
						}
					}
				}

			}
			else
			{
				_obj = obj;
			}

			return _obj;
		},

		getDateForLog: function ()
		{
			const d = new Date();

			return d.getFullYear() + "-" + Utils.lpad(d.getMonth(), 2, '0') + "-" + Utils.lpad(d.getDate(), 2, '0') + " " + Utils.lpad(d.getHours(), 2, '0') + ":" + Utils.lpad(d.getMinutes(), 2, '0');
		},

		lpad: function (str, length, chr)
		{
			str = str.toString();
			chr = chr || ' ';

			if (str.length > length)
			{
				return str;
			}

			let result = '';
			for (let i = 0; i < length - str.length; i++)
			{
				result += chr;
			}

			return result + str;
		}
	}

	if (
		typeof BX.namespace !== 'undefined'
		&& typeof BX.PULL === 'undefined'
	)
	{
		BX.PULL = new PullClient();
	}

	BX.PullClient = PullClient;
	BX.PullClient.PullStatus = PullStatus;
	BX.PullClient.SubscriptionType = SubscriptionType;
	BX.PullClient.CloseReasons = CloseReasons;
	BX.PullClient.StorageManager = StorageManager;
})();



// file: /bitrix/js/pull/component/status/dist/status.bundle.js
(function (exports,ui_designTokens,ui_vue,pull_client) {
	'use strict';

	/**
	 * Bitrix UI
	 * Pull connection status Vue component
	 *
	 * @package bitrix
	 * @subpackage pull
	 * @copyright 2001-2019 Bitrix
	 */
	ui_vue.WidgetBitrixVue.component('bx-pull-component-status', {
	  /**
	   * @emits 'reconnect' {} - work only with props.canReconnect = true
	   */
	  props: {
	    canReconnect: {
	      "default": false
	    }
	  },
	  data: function data() {
	    return {
	      status: pull_client.PullClient.PullStatus.Online,
	      showed: null
	    };
	  },
	  created: function created() {
	    var _this = this;

	    this.isMac = navigator.userAgent.toLowerCase().includes('macintosh');
	    this.setStatusTimeout = null;
	    this.hideTimeout = null;

	    this.pullUnSubscribe = function () {};

	    if (this.$Bitrix.PullClient.get()) {
	      this.subscribe();
	    }

	    this.$Bitrix.eventEmitter.subscribe(ui_vue.WidgetBitrixVue.events.pullClientChange, function () {
	      return _this.subscribe();
	    });
	    window.component = this;
	  },
	  beforeDestroy: function beforeDestroy() {
	    this.pullUnSubscribe();
	  },
	  methods: {
	    subscribe: function subscribe() {
	      var _this2 = this;

	      this.pullUnSubscribe();
	      this.pullUnSubscribe = this.$Bitrix.PullClient.get().subscribe({
	        type: pull_client.PullClient.SubscriptionType.Status,
	        callback: function callback(event) {
	          return _this2.statusChange(event.status);
	        }
	      });
	    },
	    reconnect: function reconnect() {
	      if (this.canReconnect) {
	        this.$emit('reconnect');
	      } else {
	        location.reload();
	      }
	    },
	    statusChange: function statusChange(status) {
	      var _this3 = this;

	      clearTimeout(this.setStatusTimeout);

	      if (this.status === status) {
	        return false;
	      }

	      var validStatus = [pull_client.PullClient.PullStatus.Online, pull_client.PullClient.PullStatus.Offline, pull_client.PullClient.PullStatus.Connecting];

	      if (validStatus.indexOf(status) < 0) {
	        return false;
	      }

	      var timeout = 500;

	      if (status === pull_client.PullClient.PullStatus.Connecting) {
	        timeout = 5000;
	      } else if (status === pull_client.PullClient.PullStatus.Offline) {
	        timeout = 2000;
	      }

	      this.setStatusTimeout = setTimeout(function () {
	        _this3.status = status;
	        _this3.showed = true;
	      }, timeout);
	      return true;
	    },
	    isMobile: function isMobile() {
	      return navigator.userAgent.toLowerCase().includes('android') || navigator.userAgent.toLowerCase().includes('webos') || navigator.userAgent.toLowerCase().includes('iphone') || navigator.userAgent.toLowerCase().includes('ipad') || navigator.userAgent.toLowerCase().includes('ipod') || navigator.userAgent.toLowerCase().includes('blackberry') || navigator.userAgent.toLowerCase().includes('windows phone');
	    }
	  },
	  watch: {
	    status: function status() {
	      var _this4 = this;

	      clearTimeout(this.hideTimeout);

	      if (this.status === pull_client.PullClient.PullStatus.Online) {
	        clearTimeout(this.hideTimeout);
	        this.hideTimeout = setTimeout(function () {
	          return _this4.showed = false;
	        }, 4000);
	      }
	    }
	  },
	  computed: {
	    connectionClass: function connectionClass() {
	      var result = '';

	      if (this.showed === true) {
	        result = "bx-pull-status-show";
	      } else if (this.showed === false) {
	        result = "bx-pull-status-hide";
	      }

	      if (this.status === pull_client.PullClient.PullStatus.Online) {
	        result += " bx-pull-status-online";
	      } else if (this.status === pull_client.PullClient.PullStatus.Offline) {
	        result += " bx-pull-status-offline";
	      } else if (this.status === pull_client.PullClient.PullStatus.Connecting) {
	        result += " bx-pull-status-connecting";
	      }

	      return result;
	    },
	    connectionText: function connectionText() {
	      var result = '';

	      if (this.status === pull_client.PullClient.PullStatus.Online) {
	        result = this.localize.BX_PULL_STATUS_ONLINE;
	      } else if (this.status === pull_client.PullClient.PullStatus.Offline) {
	        result = this.localize.BX_PULL_STATUS_OFFLINE;
	      } else if (this.status === pull_client.PullClient.PullStatus.Connecting) {
	        result = this.localize.BX_PULL_STATUS_CONNECTING;
	      }

	      return result;
	    },
	    button: function button() {
	      var hotkey = '';
	      var name = '';

	      if (this.canReconnect) {
	        name = this.localize.BX_PULL_STATUS_BUTTON_RECONNECT;
	      } else {
	        hotkey = this.isMac ? '&#8984;+R' : "Ctrl+R";
	        name = this.localize.BX_PULL_STATUS_BUTTON_RELOAD;
	      }

	      return {
	        title: name,
	        key: hotkey
	      };
	    },
	    localize: function localize() {
	      return ui_vue.WidgetBitrixVue.getFilteredPhrases('BX_PULL_STATUS_', this);
	    }
	  },
	  template: "\n\t\t<div v-if=\"!isMobile()\" :class=\"['bx-pull-status', connectionClass]\">\n\t\t\t<div class=\"bx-pull-status-wrap\">\n\t\t\t\t<span class=\"bx-pull-status-text\">{{connectionText}}</span>\n\t\t\t\t<span class=\"bx-pull-status-button\" @click=\"reconnect\">\n\t\t\t\t\t<span class=\"bx-pull-status-button-title\">{{button.title}}</span>\n\t\t\t\t\t<span class=\"bx-pull-status-button-key\" v-html=\"button.key\"></span>\n\t\t\t\t</span>\n\t\t\t</div>\n\t\t</div>\n\t"
	});

}((this.window = this.window || {}),BX,BX,BX));





// file: /bitrix/js/ui/progressbarjs/progressbar.js
/*!
  * ProgressBar.js v1.1.0
  * (c) 2016 Kimmo Brunfeldt
  * @license MIT
  *
  * GitHub: https://kimmobrunfeldt.github.io/progressbar.js
  */

/**
 * Modify list for integration with Bitrix Framework:
 * - removed integration with third-party package builders;
 * - export ProgressBarJS to BX scope to exclude possibility of conflict with third-party sites;
 * - add check variables before using them, for fix NaN bug, see tags: 09052020;
 * - add catch branch for correct work with error in Tweenable function, see tags: 10052020;
 */

(function(f){
    if (typeof window.BX === 'undefined')
	{
		window.BX = {};
	}
	window.BX.ProgressBarJs = f();
})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
/*! Shifty 2.8.0 - https://github.com/jeremyckahn/shifty */
!function(t,n){"object"==typeof exports&&"object"==typeof module?module.exports=n():"function"==typeof define&&define.amd?define("shifty",[],n):"object"==typeof exports?exports.shifty=n():t.shifty=n()}(window,function(){return function(t){var n={};function e(r){if(n[r])return n[r].exports;var i=n[r]={i:r,l:!1,exports:{}};return t[r].call(i.exports,i,i.exports,e),i.l=!0,i.exports}return e.m=t,e.c=n,e.d=function(t,n,r){e.o(t,n)||Object.defineProperty(t,n,{enumerable:!0,get:r})},e.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},e.t=function(t,n){if(1&n&&(t=e(t)),8&n)return t;if(4&n&&"object"==typeof t&&t&&t.__esModule)return t;var r=Object.create(null);if(e.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:t}),2&n&&"string"!=typeof t)for(var i in t)e.d(r,i,function(n){return t[n]}.bind(null,i));return r},e.n=function(t){var n=t&&t.__esModule?function(){return t.default}:function(){return t};return e.d(n,"a",n),n},e.o=function(t,n){return Object.prototype.hasOwnProperty.call(t,n)},e.p="",e(e.s=3)}([function(t,n,e){"use strict";(function(t){e.d(n,"e",function(){return d}),e.d(n,"c",function(){return y}),e.d(n,"b",function(){return _}),e.d(n,"a",function(){return g}),e.d(n,"d",function(){return w});var r=e(1);function i(t,n){for(var e=0;e<n.length;e++){var r=n[e];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}function u(t){return(u="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}function o(t){for(var n=1;n<arguments.length;n++){var e=null!=arguments[n]?arguments[n]:{},r=Object.keys(e);"function"==typeof Object.getOwnPropertySymbols&&(r=r.concat(Object.getOwnPropertySymbols(e).filter(function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.forEach(function(n){a(t,n,e[n])})}return t}function a(t,n,e){return n in t?Object.defineProperty(t,n,{value:e,enumerable:!0,configurable:!0,writable:!0}):t[n]=e,t}var c="undefined"!=typeof window?window:t,f=c.requestAnimationFrame||c.webkitRequestAnimationFrame||c.oRequestAnimationFrame||c.msRequestAnimationFrame||c.mozCancelRequestAnimationFrame&&c.mozRequestAnimationFrame||setTimeout,s=function(){},l=null,h=null,p=o({},r),d=function(t,n,e,r,i,u,o){var a=t<u?0:(t-u)/i;for(var c in n){var f=o[c],s=f.call?f:p[f],l=e[c];n[c]=l+(r[c]-l)*s(a)}return n},v=function(t,n){var e=t._attachment,r=t._currentState,i=t._delay,u=t._easing,o=t._originalState,a=t._duration,c=t._step,f=t._targetState,s=t._timestamp,l=s+i+a,h=n>l?l:n,p=a-(l-h);h>=l?(c(f,e,p),t.stop(!0)):(t._applyFilter("beforeTween"),h<s+i?(h=1,a=1,s=1):s+=i,d(h,r,o,f,a,s,u),t._applyFilter("afterTween"),c(r,e,p))},y=function(){for(var t=g.now(),n=l;n;){var e=n._next;v(n,t),n=e}},_=function(t){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"linear",e={},r=u(n);if("string"===r||"function"===r)for(var i in t)e[i]=n;else for(var o in t)e[o]=n[o]||"linear";return e},m=function(t){if(t===l)(l=t._next)?l._previous=null:h=null;else if(t===h)(h=t._previous)?h._next=null:l=null;else{var n=t._previous,e=t._next;n._next=e,e._previous=n}t._previous=t._next=null},g=function(){function t(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:void 0;!function(t,n){if(!(t instanceof n))throw new TypeError("Cannot call a class as a function")}(this,t),this._currentState=n,this._configured=!1,this._filters=[],this._timestamp=null,this._next=null,this._previous=null,e&&this.setConfig(e)}var n,e,r;return n=t,(e=[{key:"_applyFilter",value:function(t){var n=!0,e=!1,r=void 0;try{for(var i,u=this._filters[Symbol.iterator]();!(n=(i=u.next()).done);n=!0){var o=i.value[t];o&&o(this)}}catch(t){e=!0,r=t}finally{try{n||null==u.return||u.return()}finally{if(e)throw r}}}},{key:"tween",value:function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:void 0,e=this._attachment,r=this._configured;return!n&&r||this.setConfig(n),this._pausedAtTime=null,this._timestamp=t.now(),this._start(this.get(),e),this.resume()}},{key:"setConfig",value:function(){var n=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},r=e.attachment,i=e.delay,u=void 0===i?0:i,a=e.duration,c=void 0===a?500:a,f=e.easing,l=e.from,h=e.promise,p=void 0===h?Promise:h,d=e.start,v=void 0===d?s:d,y=e.step,m=void 0===y?s:y,g=e.to;this._configured=!0,this._attachment=r,this._isPlaying=!1,this._pausedAtTime=null,this._scheduleId=null,this._delay=u,this._start=v,this._step=m,this._duration=c,this._currentState=o({},l||this.get()),this._originalState=this.get(),this._targetState=o({},g||this.get());var w=this._currentState;this._targetState=o({},w,this._targetState),this._easing=_(w,f);var b=t.filters;for(var S in this._filters.length=0,b)b[S].doesApply(this)&&this._filters.push(b[S]);return this._applyFilter("tweenCreated"),this._promise=new p(function(t,e){n._resolve=t,n._reject=e}),this._promise.catch(s),this}},{key:"get",value:function(){return o({},this._currentState)}},{key:"set",value:function(t){this._currentState=t}},{key:"pause",value:function(){if(this._isPlaying)return this._pausedAtTime=t.now(),this._isPlaying=!1,m(this),this}},{key:"resume",value:function(){if(null===this._timestamp)return this.tween();if(this._isPlaying)return this._promise;var n=t.now();return this._pausedAtTime&&(this._timestamp+=n-this._pausedAtTime,this._pausedAtTime=null),this._isPlaying=!0,null===l?(l=this,h=this,function t(){l&&(f.call(c,t,1e3/60),y())}()):(this._previous=h,h._next=this,h=this),this._promise}},{key:"seek",value:function(n){n=Math.max(n,0);var e=t.now();return this._timestamp+n===0?this:(this._timestamp=e-n,this._isPlaying||v(this,e),this)}},{key:"stop",value:function(){var t=arguments.length>0&&void 0!==arguments[0]&&arguments[0],n=this._attachment,e=this._currentState,r=this._easing,i=this._originalState,u=this._targetState;if(this._isPlaying)return this._isPlaying=!1,m(this),t?(this._applyFilter("beforeTween"),d(1,e,i,u,1,0,r),this._applyFilter("afterTween"),this._applyFilter("afterTweenEnd"),this._resolve(e,n)):this._reject(e,n),this}},{key:"isPlaying",value:function(){return this._isPlaying}},{key:"setScheduleFunction",value:function(n){t.setScheduleFunction(n)}},{key:"dispose",value:function(){for(var t in this)delete this[t]}}])&&i(n.prototype,e),r&&i(n,r),t}();function w(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},n=new g,e=n.tween(t);return e.tweenable=n,e}g.setScheduleFunction=function(t){return f=t},g.formulas=p,g.filters={},g.now=Date.now||function(){return+new Date}}).call(this,e(2))},function(t,n,e){"use strict";e.r(n),e.d(n,"linear",function(){return r}),e.d(n,"easeInQuad",function(){return i}),e.d(n,"easeOutQuad",function(){return u}),e.d(n,"easeInOutQuad",function(){return o}),e.d(n,"easeInCubic",function(){return a}),e.d(n,"easeOutCubic",function(){return c}),e.d(n,"easeInOutCubic",function(){return f}),e.d(n,"easeInQuart",function(){return s}),e.d(n,"easeOutQuart",function(){return l}),e.d(n,"easeInOutQuart",function(){return h}),e.d(n,"easeInQuint",function(){return p}),e.d(n,"easeOutQuint",function(){return d}),e.d(n,"easeInOutQuint",function(){return v}),e.d(n,"easeInSine",function(){return y}),e.d(n,"easeOutSine",function(){return _}),e.d(n,"easeInOutSine",function(){return m}),e.d(n,"easeInExpo",function(){return g}),e.d(n,"easeOutExpo",function(){return w}),e.d(n,"easeInOutExpo",function(){return b}),e.d(n,"easeInCirc",function(){return S}),e.d(n,"easeOutCirc",function(){return O}),e.d(n,"easeInOutCirc",function(){return M}),e.d(n,"easeOutBounce",function(){return k}),e.d(n,"easeInBack",function(){return j}),e.d(n,"easeOutBack",function(){return P}),e.d(n,"easeInOutBack",function(){return x}),e.d(n,"elastic",function(){return T}),e.d(n,"swingFromTo",function(){return F}),e.d(n,"swingFrom",function(){return A}),e.d(n,"swingTo",function(){return E}),e.d(n,"bounce",function(){return I}),e.d(n,"bouncePast",function(){return C}),e.d(n,"easeFromTo",function(){return q}),e.d(n,"easeFrom",function(){return Q}),e.d(n,"easeTo",function(){return D});
/*!
 * All equations are adapted from Thomas Fuchs'
 * [Scripty2](https://github.com/madrobby/scripty2/blob/master/src/effects/transitions/penner.js).
 *
 * Based on Easing Equations (c) 2003 [Robert
 * Penner](http://www.robertpenner.com/), all rights reserved. This work is
 * [subject to terms](http://www.robertpenner.com/easing_terms_of_use.html).
 */
/*!
 *  TERMS OF USE - EASING EQUATIONS
 *  Open source under the BSD License.
 *  Easing Equations (c) 2003 Robert Penner, all rights reserved.
 */
var r=function(t){return t},i=function(t){return Math.pow(t,2)},u=function(t){return-(Math.pow(t-1,2)-1)},o=function(t){return(t/=.5)<1?.5*Math.pow(t,2):-.5*((t-=2)*t-2)},a=function(t){return Math.pow(t,3)},c=function(t){return Math.pow(t-1,3)+1},f=function(t){return(t/=.5)<1?.5*Math.pow(t,3):.5*(Math.pow(t-2,3)+2)},s=function(t){return Math.pow(t,4)},l=function(t){return-(Math.pow(t-1,4)-1)},h=function(t){return(t/=.5)<1?.5*Math.pow(t,4):-.5*((t-=2)*Math.pow(t,3)-2)},p=function(t){return Math.pow(t,5)},d=function(t){return Math.pow(t-1,5)+1},v=function(t){return(t/=.5)<1?.5*Math.pow(t,5):.5*(Math.pow(t-2,5)+2)},y=function(t){return 1-Math.cos(t*(Math.PI/2))},_=function(t){return Math.sin(t*(Math.PI/2))},m=function(t){return-.5*(Math.cos(Math.PI*t)-1)},g=function(t){return 0===t?0:Math.pow(2,10*(t-1))},w=function(t){return 1===t?1:1-Math.pow(2,-10*t)},b=function(t){return 0===t?0:1===t?1:(t/=.5)<1?.5*Math.pow(2,10*(t-1)):.5*(2-Math.pow(2,-10*--t))},S=function(t){return-(Math.sqrt(1-t*t)-1)},O=function(t){return Math.sqrt(1-Math.pow(t-1,2))},M=function(t){return(t/=.5)<1?-.5*(Math.sqrt(1-t*t)-1):.5*(Math.sqrt(1-(t-=2)*t)+1)},k=function(t){return t<1/2.75?7.5625*t*t:t<2/2.75?7.5625*(t-=1.5/2.75)*t+.75:t<2.5/2.75?7.5625*(t-=2.25/2.75)*t+.9375:7.5625*(t-=2.625/2.75)*t+.984375},j=function(t){var n=1.70158;return t*t*((n+1)*t-n)},P=function(t){var n=1.70158;return(t-=1)*t*((n+1)*t+n)+1},x=function(t){var n=1.70158;return(t/=.5)<1?t*t*((1+(n*=1.525))*t-n)*.5:.5*((t-=2)*t*((1+(n*=1.525))*t+n)+2)},T=function(t){return-1*Math.pow(4,-8*t)*Math.sin((6*t-1)*(2*Math.PI)/2)+1},F=function(t){var n=1.70158;return(t/=.5)<1?t*t*((1+(n*=1.525))*t-n)*.5:.5*((t-=2)*t*((1+(n*=1.525))*t+n)+2)},A=function(t){var n=1.70158;return t*t*((n+1)*t-n)},E=function(t){var n=1.70158;return(t-=1)*t*((n+1)*t+n)+1},I=function(t){return t<1/2.75?7.5625*t*t:t<2/2.75?7.5625*(t-=1.5/2.75)*t+.75:t<2.5/2.75?7.5625*(t-=2.25/2.75)*t+.9375:7.5625*(t-=2.625/2.75)*t+.984375},C=function(t){return t<1/2.75?7.5625*t*t:t<2/2.75?2-(7.5625*(t-=1.5/2.75)*t+.75):t<2.5/2.75?2-(7.5625*(t-=2.25/2.75)*t+.9375):2-(7.5625*(t-=2.625/2.75)*t+.984375)},q=function(t){return(t/=.5)<1?.5*Math.pow(t,4):-.5*((t-=2)*Math.pow(t,3)-2)},Q=function(t){return Math.pow(t,4)},D=function(t){return Math.pow(t,.25)}},function(t,n){var e;e=function(){return this}();try{e=e||new Function("return this")()}catch(t){"object"==typeof window&&(e=window)}t.exports=e},function(t,n,e){"use strict";e.r(n);var r={};e.r(r),e.d(r,"doesApply",function(){return x}),e.d(r,"tweenCreated",function(){return T}),e.d(r,"beforeTween",function(){return F}),e.d(r,"afterTween",function(){return A});var i,u,o=e(0),a=/(\d|-|\.)/,c=/([^\-0-9.]+)/g,f=/[0-9.-]+/g,s=(i=f.source,u=/,\s*/.source,new RegExp("rgb\\(".concat(i).concat(u).concat(i).concat(u).concat(i,"\\)"),"g")),l=/^.*\(/,h=/#([0-9]|[a-f]){3,6}/gi,p=function(t,n){return t.map(function(t,e){return"_".concat(n,"_").concat(e)})};function d(t){return parseInt(t,16)}var v=function(t){return"rgb(".concat((n=t,3===(n=n.replace(/#/,"")).length&&(n=(n=n.split(""))[0]+n[0]+n[1]+n[1]+n[2]+n[2]),[d(n.substr(0,2)),d(n.substr(2,2)),d(n.substr(4,2))]).join(","),")");var n},y=function(t,n,e){var r=n.match(t),i=n.replace(t,"VAL");return r&&r.forEach(function(t){return i=i.replace("VAL",e(t))}),i},_=function(t){for(var n in t){var e=t[n];"string"==typeof e&&e.match(h)&&(t[n]=y(h,e,v))}},m=function(t){var n=t.match(f).map(Math.floor),e=t.match(l)[0];return"".concat(e).concat(n.join(","),")")},g=function(t){return t.match(f)},w=function(t){var n,e,r={};for(var i in t){var u=t[i];"string"==typeof u&&(r[i]={formatString:(n=u,e=void 0,e=n.match(c),e?(1===e.length||n.charAt(0).match(a))&&e.unshift(""):e=["",""],e.join("VAL")),chunkNames:p(g(u),i)})}return r},b=function(t,n){var e=function(e){g(t[e]).forEach(function(r,i){return t[n[e].chunkNames[i]]=+r}),delete t[e]};for(var r in n)e(r)},S=function(t,n){var e={};return n.forEach(function(n){e[n]=t[n],delete t[n]}),e},O=function(t,n){return n.map(function(n){return t[n]})},M=function(t,n){return n.forEach(function(n){return t=t.replace("VAL",+n.toFixed(4))}),t},k=function(t,n){for(var e in n){var r=n[e],i=r.chunkNames,u=r.formatString,o=M(u,O(S(t,i),i));t[e]=y(s,o,m)}},j=function(t,n){var e=function(e){var r=n[e].chunkNames,i=t[e];if("string"==typeof i){var u=i.split(" "),o=u[u.length-1];r.forEach(function(n,e){return t[n]=u[e]||o})}else r.forEach(function(n){return t[n]=i});delete t[e]};for(var r in n)e(r)},P=function(t,n){for(var e in n){var r=n[e].chunkNames,i=t[r[0]];t[e]="string"==typeof i?r.map(function(n){var e=t[n];return delete t[n],e}).join(" "):i}},x=function(t){var n=t._currentState;return Object.keys(n).some(function(t){return"string"==typeof n[t]})};function T(t){var n=t._currentState;[n,t._originalState,t._targetState].forEach(_),t._tokenData=w(n)}function F(t){var n=t._currentState,e=t._originalState,r=t._targetState,i=t._easing,u=t._tokenData;j(i,u),[n,e,r].forEach(function(t){return b(t,u)})}function A(t){var n=t._currentState,e=t._originalState,r=t._targetState,i=t._easing,u=t._tokenData;[n,e,r].forEach(function(t){return k(t,u)}),P(i,u)}function E(t,n,e){return n in t?Object.defineProperty(t,n,{value:e,enumerable:!0,configurable:!0,writable:!0}):t[n]=e,t}var I=new o.a,C=o.a.filters,q=function(t,n,e,r){var i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,u=function(t){for(var n=1;n<arguments.length;n++){var e=null!=arguments[n]?arguments[n]:{},r=Object.keys(e);"function"==typeof Object.getOwnPropertySymbols&&(r=r.concat(Object.getOwnPropertySymbols(e).filter(function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.forEach(function(n){E(t,n,e[n])})}return t}({},t),a=Object(o.b)(t,r);for(var c in I._filters.length=0,I.set({}),I._currentState=u,I._originalState=t,I._targetState=n,I._easing=a,C)C[c].doesApply(I)&&I._filters.push(C[c]);I._applyFilter("tweenCreated"),I._applyFilter("beforeTween");var f=Object(o.e)(e,u,t,n,1,i,a);return I._applyFilter("afterTween"),f};function Q(t){return function(t){if(Array.isArray(t)){for(var n=0,e=new Array(t.length);n<t.length;n++)e[n]=t[n];return e}}(t)||function(t){if(Symbol.iterator in Object(t)||"[object Arguments]"===Object.prototype.toString.call(t))return Array.from(t)}(t)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance")}()}function D(t,n){for(var e=0;e<n.length;e++){var r=n[e];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}function B(t,n){if(!n.has(t))throw new TypeError("attempted to get private field on non-instance");var e=n.get(t);return e.get?e.get.call(t):e.value}var N=function(){function t(){!function(t,n){if(!(t instanceof n))throw new TypeError("Cannot call a class as a function")}(this,t),R.set(this,{writable:!0,value:[]});for(var n=arguments.length,e=new Array(n),r=0;r<n;r++)e[r]=arguments[r];e.forEach(this.add.bind(this))}var n,e,r;return n=t,(e=[{key:"add",value:function(t){return B(this,R).push(t),t}},{key:"remove",value:function(t){var n=B(this,R).indexOf(t);return~n&&B(this,R).splice(n,1),t}},{key:"empty",value:function(){return this.tweenables.map(this.remove.bind(this))}},{key:"isPlaying",value:function(){return B(this,R).some(function(t){return t.isPlaying()})}},{key:"play",value:function(){return B(this,R).forEach(function(t){return t.tween()}),this}},{key:"pause",value:function(){return B(this,R).forEach(function(t){return t.pause()}),this}},{key:"resume",value:function(){return B(this,R).forEach(function(t){return t.resume()}),this}},{key:"stop",value:function(t){return B(this,R).forEach(function(n){return n.stop(t)}),this}},{key:"tweenables",get:function(){return Q(B(this,R))}},{key:"promises",get:function(){return B(this,R).map(function(t){return t._promise})}}])&&D(n.prototype,e),r&&D(n,r),t}(),R=new WeakMap;function z(t,n,e,r,i,u){var o=0,a=0,c=0,f=0,s=0,l=0,h=function(t){return((o*t+a)*t+c)*t},p=function(t){return t>=0?t:0-t};return o=1-(c=3*n)-(a=3*(r-n)-c),f=1-(l=3*e)-(s=3*(i-e)-l),function(t,n){return e=function(t,n){var e,r,i,u,f,s,l;for(i=t,s=0;s<8;s++){if(u=h(i)-t,p(u)<n)return i;if(p(f=(3*o*(l=i)+2*a)*l+c)<1e-6)break;i-=u/f}if((i=t)<(e=0))return e;if(i>(r=1))return r;for(;e<r;){if(u=h(i),p(u-t)<n)return i;t>u?e=i:r=i,i=.5*(r-e)+e}return i}(t,n),((f*e+s)*e+l)*e;var e}(t,function(t){return 1/(200*t)}(u))}var L=function(t,n,e,r,i){var u=function(t,n,e,r){return function(i){return z(i,t,n,e,r,1)}}(n,e,r,i);return u.displayName=t,u.x1=n,u.y1=e,u.x2=r,u.y2=i,o.a.formulas[t]=u},V=function(t){return delete o.a.formulas[t]};e.d(n,"processTweens",function(){return o.c}),e.d(n,"Tweenable",function(){return o.a}),e.d(n,"tween",function(){return o.d}),e.d(n,"interpolate",function(){return q}),e.d(n,"Scene",function(){return N}),e.d(n,"setBezierFunction",function(){return L}),e.d(n,"unsetBezierFunction",function(){return V}),o.a.filters.token=r}])});

},{}],2:[function(require,module,exports){
// Circle shaped progress bar

var Shape = require('./shape');
var utils = require('./utils');

var Circle = function Circle(container, options) {
    // Use two arcs to form a circle
    // See this answer http://stackoverflow.com/a/10477334/1446092
    this._pathTemplate =
        'M 50,50 m 0,-{radius}' +
        ' a {radius},{radius} 0 1 1 0,{2radius}' +
        ' a {radius},{radius} 0 1 1 0,-{2radius}';

    this.containerAspectRatio = 1;

    Shape.apply(this, arguments);
};

Circle.prototype = new Shape();
Circle.prototype.constructor = Circle;

Circle.prototype._pathString = function _pathString(opts) {
    var widthOfWider = opts.strokeWidth;
    if (opts.trailWidth && opts.trailWidth > opts.strokeWidth) {
        widthOfWider = opts.trailWidth;
    }

    var r = 50 - widthOfWider / 2;

    return utils.render(this._pathTemplate, {
        radius: r,
        '2radius': r * 2
    });
};

Circle.prototype._trailString = function _trailString(opts) {
    return this._pathString(opts);
};

module.exports = Circle;

},{"./shape":7,"./utils":9}],3:[function(require,module,exports){
// Line shaped progress bar

var Shape = require('./shape');
var utils = require('./utils');

var Line = function Line(container, options) {
    this._pathTemplate = 'M 0,{center} L 100,{center}';
    Shape.apply(this, arguments);
};

Line.prototype = new Shape();
Line.prototype.constructor = Line;

Line.prototype._initializeSvg = function _initializeSvg(svg, opts) {
    svg.setAttribute('viewBox', '0 0 100 ' + opts.strokeWidth);
    svg.setAttribute('preserveAspectRatio', 'none');
};

Line.prototype._pathString = function _pathString(opts) {
    return utils.render(this._pathTemplate, {
        center: opts.strokeWidth / 2
    });
};

Line.prototype._trailString = function _trailString(opts) {
    return this._pathString(opts);
};

module.exports = Line;

},{"./shape":7,"./utils":9}],4:[function(require,module,exports){
module.exports = {
    // Higher level API, different shaped progress bars
    Line: require('./line'),
    Circle: require('./circle'),
    SemiCircle: require('./semicircle'),
    Square: require('./square'),

    // Lower level API to use any SVG path
    Path: require('./path'),

    // Base-class for creating new custom shapes
    // to be in line with the API of built-in shapes
    // Undocumented.
    Shape: require('./shape'),

    // Internal utils, undocumented.
    utils: require('./utils')
};

},{"./circle":2,"./line":3,"./path":5,"./semicircle":6,"./shape":7,"./square":8,"./utils":9}],5:[function(require,module,exports){
// Lower level API to animate any kind of svg path

var shifty = require('shifty');
var utils = require('./utils');

var Tweenable = shifty.Tweenable;

var EASING_ALIASES = {
    easeIn: 'easeInCubic',
    easeOut: 'easeOutCubic',
    easeInOut: 'easeInOutCubic'
};

var Path = function Path(path, opts) {
    // Throw a better error if not initialized with `new` keyword
    if (!(this instanceof Path)) {
        throw new Error('Constructor was called without new keyword');
    }

    // Default parameters for animation
    opts = utils.extend({
        delay: 0,
        duration: 800,
        easing: 'linear',
        from: {},
        to: {},
        step: function() {}
    }, opts);

    var element;
    if (utils.isString(path)) {
        element = document.querySelector(path);
    } else {
        element = path;
    }

    // Reveal .path as public attribute
    this.path = element;
    this._opts = opts;
    this._tweenable = null;

    // Set up the starting positions
    var length = this.path.getTotalLength();
    this.path.style.strokeDasharray = length + ' ' + length;
    this.set(0);
};

Path.prototype.value = function value() {
    var offset = this._getComputedDashOffset();
    var length = this.path.getTotalLength();

    var progress = 1 - offset / length;
    // Round number to prevent returning very small number like 1e-30, which
    // is practically 0
    return parseFloat(progress.toFixed(6), 10);
};

Path.prototype.set = function set(progress) {
    this.stop();

    this.path.style.strokeDashoffset = this._progressToOffset(progress);

    var step = this._opts.step;
    if (utils.isFunction(step)) {
        var easing = this._easing(this._opts.easing);
        var values = this._calculateTo(progress, easing);
        var reference = this._opts.shape || this;
        step(values, reference, this._opts.attachment);
    }
};

Path.prototype.stop = function stop() {
    this._stopTween();
    this.path.style.strokeDashoffset = this._getComputedDashOffset();
};

// Method introduced here:
// http://jakearchibald.com/2013/animated-line-drawing-svg/
Path.prototype.animate = function animate(progress, opts, cb) {
    opts = opts || {};

    if (utils.isFunction(opts)) {
        cb = opts;
        opts = {};
    }

    var passedOpts = utils.extend({}, opts);

    // Copy default opts to new object so defaults are not modified
    var defaultOpts = utils.extend({}, this._opts);
    opts = utils.extend(defaultOpts, opts);

    var shiftyEasing = this._easing(opts.easing);
    var values = this._resolveFromAndTo(progress, shiftyEasing, passedOpts);

    this.stop();

    // Trigger a layout so styles are calculated & the browser
    // picks up the starting position before animating
    this.path.getBoundingClientRect();

    var offset = this._getComputedDashOffset();
    var newOffset = this._progressToOffset(progress);

    var self = this;
    this._tweenable = new Tweenable();
    this._tweenable.tween({
        from: utils.extend({ offset: offset }, values.from),
        to: utils.extend({ offset: newOffset }, values.to),
        duration: opts.duration,
        delay: opts.delay,
        easing: shiftyEasing,
        step: function(state) {
            self.path.style.strokeDashoffset = state.offset;
            var reference = opts.shape || self;
            opts.step(state, reference, opts.attachment);
        }
    }).then(function(state) {
        if (utils.isFunction(cb)) {
            cb();
        }
    }).catch(function(error) {}); // tag 10052020
};

Path.prototype._getComputedDashOffset = function _getComputedDashOffset() {
    var computedStyle = window.getComputedStyle(this.path, null);
    // tag start 09052020
    var strokeDashOffset = computedStyle.getPropertyValue('stroke-dashoffset');
    return strokeDashOffset? parseFloat(strokeDashOffset, 10): 0;
    // tag end 09052020
};

Path.prototype._progressToOffset = function _progressToOffset(progress) {
    var length = this.path.getTotalLength();
    return length - progress * length;
};

// Resolves from and to values for animation.
Path.prototype._resolveFromAndTo = function _resolveFromAndTo(progress, easing, opts) {
    if (opts.from && opts.to) {
        return {
            from: opts.from,
            to: opts.to
        };
    }

    return {
        from: this._calculateFrom(easing),
        to: this._calculateTo(progress, easing)
    };
};

// Calculate `from` values from options passed at initialization
Path.prototype._calculateFrom = function _calculateFrom(easing) {
    return shifty.interpolate(this._opts.from, this._opts.to, this.value(), easing);
};

// Calculate `to` values from options passed at initialization
Path.prototype._calculateTo = function _calculateTo(progress, easing) {
    return shifty.interpolate(this._opts.from, this._opts.to, progress, easing);
};

Path.prototype._stopTween = function _stopTween() {
    if (this._tweenable !== null) {
        this._tweenable.stop();
        this._tweenable = null;
    }
};

Path.prototype._easing = function _easing(easing) {
    if (EASING_ALIASES.hasOwnProperty(easing)) {
        return EASING_ALIASES[easing];
    }

    return easing;
};

module.exports = Path;

},{"./utils":9,"shifty":1}],6:[function(require,module,exports){
// Semi-SemiCircle shaped progress bar

var Shape = require('./shape');
var Circle = require('./circle');
var utils = require('./utils');

var SemiCircle = function SemiCircle(container, options) {
    // Use one arc to form a SemiCircle
    // See this answer http://stackoverflow.com/a/10477334/1446092
    this._pathTemplate =
        'M 50,50 m -{radius},0' +
        ' a {radius},{radius} 0 1 1 {2radius},0';

    this.containerAspectRatio = 2;

    Shape.apply(this, arguments);
};

SemiCircle.prototype = new Shape();
SemiCircle.prototype.constructor = SemiCircle;

SemiCircle.prototype._initializeSvg = function _initializeSvg(svg, opts) {
    svg.setAttribute('viewBox', '0 0 100 50');
};

SemiCircle.prototype._initializeTextContainer = function _initializeTextContainer(
    opts,
    container,
    textContainer
) {
    if (opts.text.style) {
        // Reset top style
        textContainer.style.top = 'auto';
        textContainer.style.bottom = '0';

        if (opts.text.alignToBottom) {
            utils.setStyle(textContainer, 'transform', 'translate(-50%, 0)');
        } else {
            utils.setStyle(textContainer, 'transform', 'translate(-50%, 50%)');
        }
    }
};

// Share functionality with Circle, just have different path
SemiCircle.prototype._pathString = Circle.prototype._pathString;
SemiCircle.prototype._trailString = Circle.prototype._trailString;

module.exports = SemiCircle;

},{"./circle":2,"./shape":7,"./utils":9}],7:[function(require,module,exports){
// Base object for different progress bar shapes

var Path = require('./path');
var utils = require('./utils');

var DESTROYED_ERROR = 'Object is destroyed';

var Shape = function Shape(container, opts) {
    // Throw a better error if progress bars are not initialized with `new`
    // keyword
    if (!(this instanceof Shape)) {
        throw new Error('Constructor was called without new keyword');
    }

    // Prevent calling constructor without parameters so inheritance
    // works correctly. To understand, this is how Shape is inherited:
    //
    //   Line.prototype = new Shape();
    //
    // We just want to set the prototype for Line.
    if (arguments.length === 0) {
        return;
    }

    // Default parameters for progress bar creation
    this._opts = utils.extend({
        color: '#555',
        strokeWidth: 1.0,
        trailColor: null,
        trailWidth: null,
        fill: null,
        text: {
            style: {
                color: null,
                position: 'absolute',
                left: '50%',
                top: '50%',
                padding: 0,
                margin: 0,
                transform: {
                    prefix: true,
                    value: 'translate(-50%, -50%)'
                }
            },
            autoStyleContainer: true,
            alignToBottom: true,
            value: null,
            className: 'progressbar-text'
        },
        svgStyle: {
            display: 'block',
            width: '100%'
        },
        warnings: false
    }, opts, true);  // Use recursive extend

    // If user specifies e.g. svgStyle or text style, the whole object
    // should replace the defaults to make working with styles easier
    if (utils.isObject(opts) && opts.svgStyle !== undefined) {
        this._opts.svgStyle = opts.svgStyle;
    }
    if (utils.isObject(opts) && utils.isObject(opts.text) && opts.text.style !== undefined) {
        this._opts.text.style = opts.text.style;
    }

    var svgView = this._createSvgView(this._opts);

    var element;
    if (utils.isString(container)) {
        element = document.querySelector(container);
    } else {
        element = container;
    }

    if (!element) {
        throw new Error('Container does not exist: ' + container);
    }

    this._container = element;
    this._container.appendChild(svgView.svg);
    if (this._opts.warnings) {
        this._warnContainerAspectRatio(this._container);
    }

    if (this._opts.svgStyle) {
        utils.setStyles(svgView.svg, this._opts.svgStyle);
    }

    // Expose public attributes before Path initialization
    this.svg = svgView.svg;
    this.path = svgView.path;
    this.trail = svgView.trail;
    this.text = null;

    var newOpts = utils.extend({
        attachment: undefined,
        shape: this
    }, this._opts);
    this._progressPath = new Path(svgView.path, newOpts);

    if (utils.isObject(this._opts.text) && this._opts.text.value !== null) {
        this.setText(this._opts.text.value);
    }
};

Shape.prototype.animate = function animate(progress, opts, cb) {
    if (this._progressPath === null) {
        throw new Error(DESTROYED_ERROR);
    }

    this._progressPath.animate(progress, opts, cb);
};

Shape.prototype.stop = function stop() {
    if (this._progressPath === null) {
        throw new Error(DESTROYED_ERROR);
    }

    // Don't crash if stop is called inside step function
    if (this._progressPath === undefined) {
        return;
    }

    this._progressPath.stop();
};

Shape.prototype.pause = function pause() {
    if (this._progressPath === null) {
        throw new Error(DESTROYED_ERROR);
    }

    if (this._progressPath === undefined) {
        return;
    }

    if (!this._progressPath._tweenable) {
        // It seems that we can't pause this
        return;
    }

    this._progressPath._tweenable.pause();
};

Shape.prototype.resume = function resume() {
    if (this._progressPath === null) {
        throw new Error(DESTROYED_ERROR);
    }

    if (this._progressPath === undefined) {
        return;
    }

    if (!this._progressPath._tweenable) {
        // It seems that we can't resume this
        return;
    }

    this._progressPath._tweenable.resume();
};

Shape.prototype.destroy = function destroy() {
    if (this._progressPath === null) {
        throw new Error(DESTROYED_ERROR);
    }

    this.stop();
    this.svg.parentNode.removeChild(this.svg);
    this.svg = null;
    this.path = null;
    this.trail = null;
    this._progressPath = null;

    if (this.text !== null) {
        this.text.parentNode.removeChild(this.text);
        this.text = null;
    }
};

Shape.prototype.set = function set(progress) {
    if (this._progressPath === null) {
        throw new Error(DESTROYED_ERROR);
    }

    this._progressPath.set(progress);
};

Shape.prototype.value = function value() {
    if (this._progressPath === null) {
        throw new Error(DESTROYED_ERROR);
    }

    if (this._progressPath === undefined) {
        return 0;
    }

    return this._progressPath.value();
};

Shape.prototype.setText = function setText(newText) {
    if (this._progressPath === null) {
        throw new Error(DESTROYED_ERROR);
    }

    if (this.text === null) {
        // Create new text node
        this.text = this._createTextContainer(this._opts, this._container);
        this._container.appendChild(this.text);
    }

    // Remove previous text and add new
    if (utils.isObject(newText)) {
        utils.removeChildren(this.text);
        this.text.appendChild(newText);
    } else {
        this.text.innerHTML = newText;
    }
};

Shape.prototype._createSvgView = function _createSvgView(opts) {
    var svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    this._initializeSvg(svg, opts);

    var trailPath = null;
    // Each option listed in the if condition are 'triggers' for creating
    // the trail path
    if (opts.trailColor || opts.trailWidth) {
        trailPath = this._createTrail(opts);
        svg.appendChild(trailPath);
    }

    var path = this._createPath(opts);
    svg.appendChild(path);

    return {
        svg: svg,
        path: path,
        trail: trailPath
    };
};

Shape.prototype._initializeSvg = function _initializeSvg(svg, opts) {
    svg.setAttribute('viewBox', '0 0 100 100');
};

Shape.prototype._createPath = function _createPath(opts) {
    var pathString = this._pathString(opts);
    return this._createPathElement(pathString, opts);
};

Shape.prototype._createTrail = function _createTrail(opts) {
    // Create path string with original passed options
    var pathString = this._trailString(opts);

    // Prevent modifying original
    var newOpts = utils.extend({}, opts);

    // Defaults for parameters which modify trail path
    if (!newOpts.trailColor) {
        newOpts.trailColor = '#eee';
    }
    if (!newOpts.trailWidth) {
        newOpts.trailWidth = newOpts.strokeWidth;
    }

    newOpts.color = newOpts.trailColor;
    newOpts.strokeWidth = newOpts.trailWidth;

    // When trail path is set, fill must be set for it instead of the
    // actual path to prevent trail stroke from clipping
    newOpts.fill = null;

    return this._createPathElement(pathString, newOpts);
};

Shape.prototype._createPathElement = function _createPathElement(pathString, opts) {
    var path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    path.setAttribute('d', pathString);
    path.setAttribute('stroke', opts.color);
    path.setAttribute('stroke-width', opts.strokeWidth);

    if (opts.fill) {
        path.setAttribute('fill', opts.fill);
    } else {
        path.setAttribute('fill-opacity', '0');
    }

    return path;
};

Shape.prototype._createTextContainer = function _createTextContainer(opts, container) {
    var textContainer = document.createElement('div');
    textContainer.className = opts.text.className;

    var textStyle = opts.text.style;
    if (textStyle) {
        if (opts.text.autoStyleContainer) {
            container.style.position = 'relative';
        }

        utils.setStyles(textContainer, textStyle);
        // Default text color to progress bar's color
        if (!textStyle.color) {
            textContainer.style.color = opts.color;
        }
    }

    this._initializeTextContainer(opts, container, textContainer);
    return textContainer;
};

// Give custom shapes possibility to modify text element
Shape.prototype._initializeTextContainer = function(opts, container, element) {
    // By default, no-op
    // Custom shapes should respect API options, such as text.style
};

Shape.prototype._pathString = function _pathString(opts) {
    throw new Error('Override this function for each progress bar');
};

Shape.prototype._trailString = function _trailString(opts) {
    throw new Error('Override this function for each progress bar');
};

Shape.prototype._warnContainerAspectRatio = function _warnContainerAspectRatio(container) {
    if (!this.containerAspectRatio) {
        return;
    }

    var computedStyle = window.getComputedStyle(container, null);
    var width = parseFloat(computedStyle.getPropertyValue('width'), 10);
    var height = parseFloat(computedStyle.getPropertyValue('height'), 10);
    if (!utils.floatEquals(this.containerAspectRatio, width / height)) {
        console.warn(
            'Incorrect aspect ratio of container',
            '#' + container.id,
            'detected:',
            computedStyle.getPropertyValue('width') + '(width)',
            '/',
            computedStyle.getPropertyValue('height') + '(height)',
            '=',
            width / height
        );

        console.warn(
            'Aspect ratio of should be',
            this.containerAspectRatio
        );
    }
};

module.exports = Shape;

},{"./path":5,"./utils":9}],8:[function(require,module,exports){
// Square shaped progress bar
// Note: Square is not core part of API anymore. It's left here
//       for reference. square is not included to the progressbar
//       build anymore

var Shape = require('./shape');
var utils = require('./utils');

var Square = function Square(container, options) {
    this._pathTemplate =
        'M 0,{halfOfStrokeWidth}' +
        ' L {width},{halfOfStrokeWidth}' +
        ' L {width},{width}' +
        ' L {halfOfStrokeWidth},{width}' +
        ' L {halfOfStrokeWidth},{strokeWidth}';

    this._trailTemplate =
        'M {startMargin},{halfOfStrokeWidth}' +
        ' L {width},{halfOfStrokeWidth}' +
        ' L {width},{width}' +
        ' L {halfOfStrokeWidth},{width}' +
        ' L {halfOfStrokeWidth},{halfOfStrokeWidth}';

    Shape.apply(this, arguments);
};

Square.prototype = new Shape();
Square.prototype.constructor = Square;

Square.prototype._pathString = function _pathString(opts) {
    var w = 100 - opts.strokeWidth / 2;

    return utils.render(this._pathTemplate, {
        width: w,
        strokeWidth: opts.strokeWidth,
        halfOfStrokeWidth: opts.strokeWidth / 2
    });
};

Square.prototype._trailString = function _trailString(opts) {
    var w = 100 - opts.strokeWidth / 2;

    return utils.render(this._trailTemplate, {
        width: w,
        strokeWidth: opts.strokeWidth,
        halfOfStrokeWidth: opts.strokeWidth / 2,
        startMargin: opts.strokeWidth / 2 - opts.trailWidth / 2
    });
};

module.exports = Square;

},{"./shape":7,"./utils":9}],9:[function(require,module,exports){
// Utility functions

var PREFIXES = 'Webkit Moz O ms'.split(' ');
var FLOAT_COMPARISON_EPSILON = 0.001;

// Copy all attributes from source object to destination object.
// destination object is mutated.
function extend(destination, source, recursive) {
    destination = destination || {};
    source = source || {};
    recursive = recursive || false;

    for (var attrName in source) {
        if (source.hasOwnProperty(attrName)) {
            var destVal = destination[attrName];
            var sourceVal = source[attrName];
            if (recursive && isObject(destVal) && isObject(sourceVal)) {
                destination[attrName] = extend(destVal, sourceVal, recursive);
            } else {
                destination[attrName] = sourceVal;
            }
        }
    }

    return destination;
}

// Renders templates with given variables. Variables must be surrounded with
// braces without any spaces, e.g. {variable}
// All instances of variable placeholders will be replaced with given content
// Example:
// render('Hello, {message}!', {message: 'world'})
function render(template, vars) {
    var rendered = template;

    for (var key in vars) {
        if (vars.hasOwnProperty(key)) {
            var val = vars[key];
            var regExpString = '\\{' + key + '\\}';
            var regExp = new RegExp(regExpString, 'g');

            rendered = rendered.replace(regExp, val);
        }
    }

    return rendered;
}

function setStyle(element, style, value) {
    var elStyle = element.style;  // cache for performance

    for (var i = 0; i < PREFIXES.length; ++i) {
        var prefix = PREFIXES[i];
        elStyle[prefix + capitalize(style)] = value;
    }

    elStyle[style] = value;
}

function setStyles(element, styles) {
    forEachObject(styles, function(styleValue, styleName) {
        // Allow disabling some individual styles by setting them
        // to null or undefined
        if (styleValue === null || styleValue === undefined) {
            return;
        }

        // If style's value is {prefix: true, value: '50%'},
        // Set also browser prefixed styles
        if (isObject(styleValue) && styleValue.prefix === true) {
            setStyle(element, styleName, styleValue.value);
        } else {
            element.style[styleName] = styleValue;
        }
    });
}

function capitalize(text) {
    return text.charAt(0).toUpperCase() + text.slice(1);
}

function isString(obj) {
    return typeof obj === 'string' || obj instanceof String;
}

function isFunction(obj) {
    return typeof obj === 'function';
}

function isArray(obj) {
    return Object.prototype.toString.call(obj) === '[object Array]';
}

// Returns true if `obj` is object as in {a: 1, b: 2}, not if it's function or
// array
function isObject(obj) {
    if (isArray(obj)) {
        return false;
    }

    var type = typeof obj;
    return type === 'object' && !!obj;
}

function forEachObject(object, callback) {
    for (var key in object) {
        if (object.hasOwnProperty(key)) {
            var val = object[key];
            callback(val, key);
        }
    }
}

function floatEquals(a, b) {
    return Math.abs(a - b) < FLOAT_COMPARISON_EPSILON;
}

// https://coderwall.com/p/nygghw/don-t-use-innerhtml-to-empty-dom-elements
function removeChildren(el) {
    while (el.firstChild) {
        el.removeChild(el.firstChild);
    }
}

module.exports = {
    extend: extend,
    render: render,
    setStyle: setStyle,
    setStyles: setStyles,
    capitalize: capitalize,
    isString: isString,
    isFunction: isFunction,
    isObject: isObject,
    forEachObject: forEachObject,
    floatEquals: floatEquals,
    removeChildren: removeChildren
};

},{}]},{},[4])(4)
});



// file: /bitrix/js/ui/progressbarjs/uploader/dist/uploader.bundle.js
this.BX = this.BX || {};
(function (exports) {
	'use strict';

	var Uploader = /*#__PURE__*/function () {
	  function Uploader() {
	    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	    babelHelpers.classCallCheck(this, Uploader);
	    this.container = params.container;

	    if (this.container && typeof params.blurElement === 'undefined') {
	      params.blurElement = this.container.firstElementChild;
	    }

	    this.blurElement = params.blurElement;
	    this.direction = Uploader.direction[params.direction] ? params.direction : Uploader.direction.vertical;
	    params.sizes = params.sizes && babelHelpers["typeof"](params.sizes) === 'object' ? params.sizes : {};
	    this.sizes = {
	      circle: params.sizes.circle ? params.sizes.circle : 54,
	      progress: params.sizes.progress ? params.sizes.progress : 4,
	      margin: params.sizes.margin ? params.sizes.margin : 0
	    };
	    params.labels = params.labels && babelHelpers["typeof"](params.labels) === 'object' ? params.labels : {};
	    this.labels = {
	      loading: params.labels.loading ? params.labels.loading : '',
	      completed: params.labels.completed ? params.labels.completed : '',
	      canceled: params.labels.canceled ? params.labels.canceled : '',
	      cancelTitle: params.labels.cancelTitle ? params.labels.cancelTitle : '',
	      megabyte: params.labels.megabyte ? params.labels.megabyte : 'MB'
	    };
	    this.cancelCallback = typeof params.cancelCallback === 'function' ? params.cancelCallback : null;
	    this.destroyCallback = typeof params.destroyCallback === 'function' ? params.destroyCallback : null;
	    this.icon = Uploader.icon[params.icon] ? params.icon : !this.cancelCallback ? Uploader.icon.cloud : Uploader.icon.cancel;
	    this.inited = !!this.container;
	    this.destroing = false;
	  }

	  babelHelpers.createClass(Uploader, [{
	    key: "start",
	    value: function start() {
	      var _this = this;

	      if (!this.inited) {
	        return false;
	      }

	      clearTimeout(this.timeoutSetIcon);
	      clearTimeout(this.timeout);
	      this.active = true;
	      this.canceled = false;
	      this.cancelCallbackDisabled = false;
	      this.wrapper = document.createElement('div');
	      this.wrapper.classList.add('ui-file-progressbar-loader-wrapper');
	      this.wrapper.innerHTML = "\n\t\t\t<div class=\"ui-file-progressbar-loader\">\n\t\t\t\t<div class=\"ui-file-progressbar-icon\"></div>\n\t\t\t\t<div class=\"ui-file-progressbar-progress ui-file-progressbar-rotating\"></div>\n\t\t\t</div>\n\t\t\t<div class=\"ui-file-progressbar-label\">".concat(this.labels.loading, "</div>\n\t\t");
	      this.processLoader = this.wrapper.getElementsByClassName('ui-file-progressbar-loader')[0];
	      this.processLoaderIcon = this.wrapper.getElementsByClassName('ui-file-progressbar-icon')[0];
	      this.processStatus = this.wrapper.getElementsByClassName('ui-file-progressbar-progress')[0];
	      this.proccesLabel = this.wrapper.getElementsByClassName('ui-file-progressbar-label')[0];

	      if (this.direction === Uploader.direction.horizontal) {
	        this.wrapper.classList.add('ui-file-progressbar-loader-horizontal');
	      }

	      this.container.classList.add('ui-file-progressbar-container-relative');
	      this.container.insertBefore(this.wrapper, this.container.firstChild);

	      if (this.blurElement) {
	        this.blurElement.classList.add("ui-file-progressbar-item-blurred");
	      }

	      var processLoaderStyle = "width: ".concat(this.sizes.circle, "px; height: ").concat(this.sizes.circle, "px;");

	      if (this.sizes.margin) {
	        processLoaderStyle = processLoaderStyle + "margin: ".concat(this.sizes.margin, "px;");
	        this.proccesLabel.style = "margin: ".concat(this.sizes.margin, "px;");
	      }

	      this.processLoader.style = processLoaderStyle;

	      if (this.cancelCallback) {
	        this.processLoader.addEventListener('click', function (event) {
	          if (_this.cancelCallbackDisabled) {
	            return false;
	          }

	          _this.setProgress(0);

	          if (_this.labels.canceled) {
	            _this.setProgressTitle(_this.labels.canceled);
	          }

	          _this.canceled = event;
	          _this.active = false;
	          clearTimeout(_this.timeout);
	          _this.timeout = setTimeout(function () {
	            return _this.destroy();
	          }, 1000);
	          return true;
	        });

	        if (this.labels.cancelTitle) {
	          this.processLoader.title = this.labels.cancelTitle;
	        }
	      }

	      if (!this.labels.loading) {
	        this.setProgressTitleVisibility(false);
	      }

	      this.setIcon(this.icon, true);
	      this.bar = new BX.ProgressBarJs.Circle(this.processStatus, {
	        easing: "linear",
	        strokeWidth: this.sizes.progress,
	        color: '#ffffff',
	        from: {
	          color: '#ffffff'
	        },
	        to: {
	          color: '#ffffff'
	        },
	        step: function step(state, bar) {
	          if (bar.value() == 1) {
	            clearTimeout(_this.timeout);
	            _this.timeout = setTimeout(function () {
	              if (_this.labels.completed) {
	                _this.setProgressTitle(_this.labels.completed);
	              }

	              _this.setIcon(Uploader.icon.done);

	              clearTimeout(_this.timeout);
	              _this.timeout = setTimeout(function () {
	                return _this.destroy();
	              }, 1000);
	            }, 200);
	          }
	        }
	      });
	    }
	  }, {
	    key: "setCancelDisable",
	    value: function setCancelDisable() {
	      var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
	      this.cancelCallbackDisabled = !!value;

	      if (this.labels.cancelTitle) {
	        this.processLoader.title = this.cancelCallbackDisabled ? '' : this.labels.cancelTitle;
	      }
	    }
	  }, {
	    key: "setIcon",
	    value: function setIcon(icon) {
	      var _this2 = this;

	      var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
	      this.processLoaderIcon.style.transform = "scale(0)";
	      clearTimeout(this.timeoutSetIcon);
	      this.timeoutSetIcon = setTimeout(function () {
	        _this2.processLoaderIcon.classList.remove("ui-file-progressbar-cancel", "ui-file-progressbar-done", "ui-file-progressbar-cloud", "ui-file-progressbar-error");

	        if (icon === Uploader.icon.done) {
	          _this2.processLoaderIcon.classList.add("ui-file-progressbar-done");

	          _this2.processLoaderIcon.style.transform = "scale(1)";
	        } else if (icon === Uploader.icon.cancel) {
	          _this2.processLoaderIcon.classList.add("ui-file-progressbar-cancel");

	          _this2.processLoaderIcon.style.transform = "scale(1)";
	        } else if (icon === Uploader.icon.error) {
	          _this2.processLoaderIcon.classList.add("ui-file-progressbar-error");

	          _this2.processLoaderIcon.style.transform = "scale(1)";
	        } else {
	          _this2.processLoaderIcon.classList.add("ui-file-progressbar-cloud");

	          _this2.processLoaderIcon.style.transform = "scale(1)";
	        }
	      }, force ? 0 : 200);
	      return true;
	    }
	  }, {
	    key: "setProgress",
	    value: function setProgress(percent) {
	      if (!this.active || this.canceled) {
	        return false;
	      }

	      this.bar.animate(percent / 100, {
	        duration: 500
	      });
	    }
	  }, {
	    key: "setProgressTitle",
	    value: function setProgressTitle(text) {
	      if (!this.proccesLabel) {
	        return false;
	      }

	      this.proccesLabel.innerHTML = text;
	    }
	  }, {
	    key: "setProgressTitleVisibility",
	    value: function setProgressTitleVisibility(visible) {
	      if (!this.proccesLabel) {
	        return;
	      }

	      if (visible) {
	        if (this.direction === Uploader.direction.horizontal) {
	          this.wrapper.classList.add('ui-file-progressbar-loader-horizontal');
	        }

	        this.proccesLabel.style.display = 'block';
	      } else {
	        if (this.direction === Uploader.direction.horizontal) {
	          this.wrapper.classList.remove('ui-file-progressbar-loader-horizontal');
	        }

	        this.proccesLabel.style.display = 'none';
	      }
	    }
	  }, {
	    key: "setByteSent",
	    value: function setByteSent(sent, total) {
	      if (this.canceled) {
	        return false;
	      }

	      this.setProgressTitle((sent / 1024 / 1024).toFixed(2) + " " + this.labels.megabyte + " " + " / " + (total / 1024 / 1024).toFixed(2) + " " + this.labels.megabyte);
	    }
	  }, {
	    key: "destroy",
	    value: function destroy() {
	      var _this3 = this;

	      var animated = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
	      clearTimeout(this.timeoutSetIcon);
	      clearTimeout(this.timeout);

	      if (this.destroing) {
	        return true;
	      }

	      this.active = false;
	      this.destroing = true;
	      this.processLoader.style.transform = "scale(0)";

	      if (this.proccesLabel) {
	        this.proccesLabel.style.transform = "scale(0)";
	      }

	      if (this.bar) {
	        this.bar.destroy();
	      }

	      if (this.blurElement) {
	        this.blurElement.classList.remove("ui-file-progressbar-item-blurred");
	      }

	      if (this.canceled && !this.cancelCallbackDisabled) {
	        if (this.cancelCallback) {
	          this.cancelCallback(this.canceled);
	        }

	        this.canceled = false;
	      }

	      if (animated) {
	        this.timeout = setTimeout(function () {
	          return _this3.destroyFinally();
	        }, 400);
	      } else {
	        this.destroyFinally();
	      }
	    }
	  }, {
	    key: "destroyFinally",
	    value: function destroyFinally() {
	      if (this.container) {
	        this.container.classList.remove('ui-file-progressbar-container-relative');
	        this.container.removeChild(this.wrapper);
	      }

	      if (this.destroyCallback) {
	        this.destroyCallback();
	      }
	    }
	  }]);
	  return Uploader;
	}();
	Uploader.direction = {
	  horizontal: 'horizontal',
	  vertical: 'vertical'
	};
	Uploader.icon = {
	  cloud: 'cloud',
	  cancel: 'cancel',
	  error: 'error',
	  done: 'done'
	};

	exports.Uploader = Uploader;

}((this.BX.ProgressBarJs = this.BX.ProgressBarJs || {})));





// file: /bitrix/js/ui/dexie/dist/dexie3.bundle.js
this.BX = this.BX || {};
(function (exports) {
	'use strict';

	/*
	 * Dexie.js - a minimalistic wrapper for IndexedDB
	 * ===============================================
	 *
	 * By David Fahlander, david.fahlander@gmail.com
	 *
	 * Version 3.2.2, Wed Apr 27 2022
	 *
	 * https://dexie.org
	 *
	 * Apache License Version 2.0, January 2004, http://www.apache.org/licenses/
	 */

	/**
	 * Modify list for integration with Bitrix Framework:
	 * - removed integration with third-party package builders;
	 * - add check variables before using them, see tags: 28122018;
	 * - add alternative Promise check for Bitrix Cli, see tags: 02032020;
	 * - add export for work in Bitrix CoreJS extensions;
	 * - add export BX.Dexie for backward compatibility;
	 */

	/*! *****************************************************************************
	Copyright (c) Microsoft Corporation.
	Permission to use, copy, modify, and/or distribute this software for any
	purpose with or without fee is hereby granted.
	THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
	REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
	AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
	INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
	LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
	OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
	PERFORMANCE OF THIS SOFTWARE.
	***************************************************************************** */
	var _assign = function __assign() {
	  _assign = Object.assign || function __assign(t) {
	    for (var s, i = 1, n = arguments.length; i < n; i++) {
	      s = arguments[i];

	      for (var p in s) {
	        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
	      }
	    }

	    return t;
	  };

	  return _assign.apply(this, arguments);
	};

	function __spreadArray(to, from, pack) {
	  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
	    if (ar || !(i in from)) {
	      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
	      ar[i] = from[i];
	    }
	  }
	  return to.concat(ar || Array.prototype.slice.call(from));
	}

	var _global = typeof globalThis !== 'undefined' ? globalThis : typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : global;

	var keys = Object.keys;
	var isArray = Array.isArray;

	if (typeof Promise !== 'undefined' && !_global.Promise) {
	  _global.Promise = Promise;
	}

	function extend(obj, extension) {
	  if (babelHelpers["typeof"](extension) !== 'object') return obj;
	  keys(extension).forEach(function (key) {
	    obj[key] = extension[key];
	  });
	  return obj;
	}

	var getProto = Object.getPrototypeOf;
	var _hasOwn = {}.hasOwnProperty;

	function hasOwn(obj, prop) {
	  return _hasOwn.call(obj, prop);
	}

	function props(proto, extension) {
	  if (typeof extension === 'function') extension = extension(getProto(proto)); // tag start 28122018

	  if (babelHelpers["typeof"](extension) !== 'object') return; // tag end 28122018

	  (typeof Reflect === "undefined" ? keys : Reflect.ownKeys)(extension).forEach(function (key) {
	    setProp(proto, key, extension[key]);
	  });
	}

	var defineProperty = Object.defineProperty;

	function setProp(obj, prop, functionOrGetSet, options) {
	  defineProperty(obj, prop, extend(functionOrGetSet && hasOwn(functionOrGetSet, "get") && typeof functionOrGetSet.get === 'function' ? {
	    get: functionOrGetSet.get,
	    set: functionOrGetSet.set,
	    configurable: true
	  } : {
	    value: functionOrGetSet,
	    configurable: true,
	    writable: true
	  }, options));
	}

	function derive(Child) {
	  return {
	    from: function from(Parent) {
	      Child.prototype = Object.create(Parent.prototype);
	      setProp(Child.prototype, "constructor", Child);
	      return {
	        extend: props.bind(null, Child.prototype)
	      };
	    }
	  };
	}

	var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

	function getPropertyDescriptor(obj, prop) {
	  var pd = getOwnPropertyDescriptor(obj, prop);
	  var proto;
	  return pd || (proto = getProto(obj)) && getPropertyDescriptor(proto, prop);
	}

	var _slice = [].slice;

	function slice(args, start, end) {
	  return _slice.call(args, start, end);
	}

	function override(origFunc, overridedFactory) {
	  return overridedFactory(origFunc);
	}

	function assert(b) {
	  if (!b) throw new Error("Assertion Failed");
	}

	function asap$1(fn) {
	  if (_global.setImmediate) setImmediate(fn);else setTimeout(fn, 0);
	}

	function arrayToObject(array, extractor) {
	  return array.reduce(function (result, item, i) {
	    var nameAndValue = extractor(item, i);
	    if (nameAndValue) result[nameAndValue[0]] = nameAndValue[1];
	    return result;
	  }, {});
	}

	function tryCatch(fn, onerror, args) {
	  try {
	    fn.apply(null, args);
	  } catch (ex) {
	    onerror && onerror(ex);
	  }
	}

	function getByKeyPath(obj, keyPath) {
	  if (hasOwn(obj, keyPath)) return obj[keyPath];
	  if (!keyPath) return obj;

	  if (typeof keyPath !== 'string') {
	    var rv = [];

	    for (var i = 0, l = keyPath.length; i < l; ++i) {
	      var val = getByKeyPath(obj, keyPath[i]);
	      rv.push(val);
	    }

	    return rv;
	  }

	  var period = keyPath.indexOf('.');

	  if (period !== -1) {
	    var innerObj = obj[keyPath.substr(0, period)];
	    return innerObj === undefined ? undefined : getByKeyPath(innerObj, keyPath.substr(period + 1));
	  }

	  return undefined;
	}

	function setByKeyPath(obj, keyPath, value) {
	  if (!obj || keyPath === undefined) return;
	  if ('isFrozen' in Object && Object.isFrozen(obj)) return;

	  if (typeof keyPath !== 'string' && 'length' in keyPath) {
	    assert(typeof value !== 'string' && 'length' in value);

	    for (var i = 0, l = keyPath.length; i < l; ++i) {
	      setByKeyPath(obj, keyPath[i], value[i]);
	    }
	  } else {
	    var period = keyPath.indexOf('.');

	    if (period !== -1) {
	      var currentKeyPath = keyPath.substr(0, period);
	      var remainingKeyPath = keyPath.substr(period + 1);
	      if (remainingKeyPath === "") {
	        if (value === undefined) {
	          if (isArray(obj) && !isNaN(parseInt(currentKeyPath))) obj.splice(currentKeyPath, 1);else delete obj[currentKeyPath];
	        } else obj[currentKeyPath] = value;
	      } else {
	        var innerObj = obj[currentKeyPath];
	        if (!innerObj || !hasOwn(obj, currentKeyPath)) innerObj = obj[currentKeyPath] = {};
	        setByKeyPath(innerObj, remainingKeyPath, value);
	      }
	    } else {
	      if (value === undefined) {
	        if (isArray(obj) && !isNaN(parseInt(keyPath))) obj.splice(keyPath, 1);else delete obj[keyPath];
	      } else obj[keyPath] = value;
	    }
	  }
	}

	function delByKeyPath(obj, keyPath) {
	  if (typeof keyPath === 'string') setByKeyPath(obj, keyPath, undefined);else if ('length' in keyPath) [].map.call(keyPath, function (kp) {
	    setByKeyPath(obj, kp, undefined);
	  });
	}

	function shallowClone(obj) {
	  var rv = {};

	  for (var m in obj) {
	    if (hasOwn(obj, m)) rv[m] = obj[m];
	  }

	  return rv;
	}

	var concat = [].concat;

	function flatten(a) {
	  return concat.apply([], a);
	}

	var intrinsicTypeNames = "Boolean,String,Date,RegExp,Blob,File,FileList,FileSystemFileHandle,ArrayBuffer,DataView,Uint8ClampedArray,ImageBitmap,ImageData,Map,Set,CryptoKey".split(',').concat(flatten([8, 16, 32, 64].map(function (num) {
	  return ["Int", "Uint", "Float"].map(function (t) {
	    return t + num + "Array";
	  });
	}))).filter(function (t) {
	  return _global[t];
	});
	var intrinsicTypes = intrinsicTypeNames.map(function (t) {
	  return _global[t];
	});
	arrayToObject(intrinsicTypeNames, function (x) {
	  return [x, true];
	});
	var circularRefs = null;

	function deepClone(any) {
	  circularRefs = typeof WeakMap !== 'undefined' && new WeakMap();
	  var rv = innerDeepClone(any);
	  circularRefs = null;
	  return rv;
	}

	function innerDeepClone(any) {
	  if (!any || babelHelpers["typeof"](any) !== 'object') return any;
	  var rv = circularRefs && circularRefs.get(any);
	  if (rv) return rv;

	  if (isArray(any)) {
	    rv = [];
	    circularRefs && circularRefs.set(any, rv);

	    for (var i = 0, l = any.length; i < l; ++i) {
	      rv.push(innerDeepClone(any[i]));
	    }
	  } else if (intrinsicTypes.indexOf(any.constructor) >= 0) {
	    rv = any;
	  } else {
	    var proto = getProto(any);
	    rv = proto === Object.prototype ? {} : Object.create(proto);
	    circularRefs && circularRefs.set(any, rv);

	    for (var prop in any) {
	      if (hasOwn(any, prop)) {
	        rv[prop] = innerDeepClone(any[prop]);
	      }
	    }
	  }

	  return rv;
	}

	var toString = {}.toString;

	function toStringTag(o) {
	  return toString.call(o).slice(8, -1);
	}

	var iteratorSymbol = typeof Symbol !== 'undefined' ? Symbol.iterator : '@@iterator';
	var getIteratorOf = babelHelpers["typeof"](iteratorSymbol) === "symbol" ? function (x) {
	  var i;
	  return x != null && (i = x[iteratorSymbol]) && i.apply(x);
	} : function () {
	  return null;
	};
	var NO_CHAR_ARRAY = {};

	function getArrayOf(arrayLike) {
	  var i, a, x, it;

	  if (arguments.length === 1) {
	    if (isArray(arrayLike)) return arrayLike.slice();
	    if (this === NO_CHAR_ARRAY && typeof arrayLike === 'string') return [arrayLike];

	    if (it = getIteratorOf(arrayLike)) {
	      a = [];

	      while (x = it.next(), !x.done) {
	        a.push(x.value);
	      }

	      return a;
	    }

	    if (arrayLike == null) return [arrayLike];
	    i = arrayLike.length;

	    if (typeof i === 'number') {
	      a = new Array(i);

	      while (i--) {
	        a[i] = arrayLike[i];
	      }

	      return a;
	    }

	    return [arrayLike];
	  }

	  i = arguments.length;
	  a = new Array(i);

	  while (i--) {
	    a[i] = arguments[i];
	  }

	  return a;
	}

	var isAsyncFunction = typeof Symbol !== 'undefined' ? function (fn) {
	  return fn[Symbol.toStringTag] === 'AsyncFunction';
	} : function () {
	  return false;
	};
	var debug = typeof location !== 'undefined' && /^(http|https):\/\/(localhost|127\.0\.0\.1)/.test(location.href);

	function setDebug(value, filter) {
	  debug = value;
	  libraryFilter = filter;
	}

	var libraryFilter = function libraryFilter() {
	  return true;
	};

	var NEEDS_THROW_FOR_STACK = !new Error("").stack;

	function getErrorWithStack() {
	  if (NEEDS_THROW_FOR_STACK) try {
	    throw new Error();
	  } catch (e) {
	    return e;
	  }
	  return new Error();
	}

	function prettyStack(exception, numIgnoredFrames) {
	  var stack = exception.stack;
	  if (!stack) return "";
	  numIgnoredFrames = numIgnoredFrames || 0;
	  if (stack.indexOf(exception.name) === 0) numIgnoredFrames += (exception.name + exception.message).split('\n').length;
	  return stack.split('\n').slice(numIgnoredFrames).filter(libraryFilter).map(function (frame) {
	    return "\n" + frame;
	  }).join('');
	}

	var dexieErrorNames = ['Modify', 'Bulk', 'OpenFailed', 'VersionChange', 'Schema', 'Upgrade', 'InvalidTable', 'MissingAPI', 'NoSuchDatabase', 'InvalidArgument', 'SubTransaction', 'Unsupported', 'Internal', 'DatabaseClosed', 'PrematureCommit', 'ForeignAwait'];
	var idbDomErrorNames = ['Unknown', 'Constraint', 'Data', 'TransactionInactive', 'ReadOnly', 'Version', 'NotFound', 'InvalidState', 'InvalidAccess', 'Abort', 'Timeout', 'QuotaExceeded', 'Syntax', 'DataClone'];
	var errorList = dexieErrorNames.concat(idbDomErrorNames);
	var defaultTexts = {
	  VersionChanged: "Database version changed by other database connection",
	  DatabaseClosed: "Database has been closed",
	  Abort: "Transaction aborted",
	  TransactionInactive: "Transaction has already completed or failed",
	  MissingAPI: "IndexedDB API missing. Please visit https://tinyurl.com/y2uuvskb"
	};

	function DexieError(name, msg) {
	  this._e = getErrorWithStack();
	  this.name = name;
	  this.message = msg;
	}

	derive(DexieError).from(Error).extend({
	  stack: {
	    get: function get() {
	      return this._stack || (this._stack = this.name + ": " + this.message + prettyStack(this._e, 2));
	    }
	  },
	  toString: function toString() {
	    return this.name + ": " + this.message;
	  }
	});

	function getMultiErrorMessage(msg, failures) {
	  return msg + ". Errors: " + Object.keys(failures).map(function (key) {
	    return failures[key].toString();
	  }).filter(function (v, i, s) {
	    return s.indexOf(v) === i;
	  }).join('\n');
	}

	function ModifyError(msg, failures, successCount, failedKeys) {
	  this._e = getErrorWithStack();
	  this.failures = failures;
	  this.failedKeys = failedKeys;
	  this.successCount = successCount;
	  this.message = getMultiErrorMessage(msg, failures);
	}

	derive(ModifyError).from(DexieError);

	function BulkError(msg, failures) {
	  this._e = getErrorWithStack();
	  this.name = "BulkError";
	  this.failures = Object.keys(failures).map(function (pos) {
	    return failures[pos];
	  });
	  this.failuresByPos = failures;
	  this.message = getMultiErrorMessage(msg, failures);
	}

	derive(BulkError).from(DexieError);
	var errnames = errorList.reduce(function (obj, name) {
	  return obj[name] = name + "Error", obj;
	}, {});
	var BaseException = DexieError;
	var exceptions = errorList.reduce(function (obj, name) {
	  var fullName = name + "Error";

	  function DexieError(msgOrInner, inner) {
	    this._e = getErrorWithStack();
	    this.name = fullName;

	    if (!msgOrInner) {
	      this.message = defaultTexts[name] || fullName;
	      this.inner = null;
	    } else if (typeof msgOrInner === 'string') {
	      this.message = "" + msgOrInner + (!inner ? '' : '\n ' + inner);
	      this.inner = inner || null;
	    } else if (babelHelpers["typeof"](msgOrInner) === 'object') {
	      this.message = msgOrInner.name + " " + msgOrInner.message;
	      this.inner = msgOrInner;
	    }
	  }

	  derive(DexieError).from(BaseException);
	  obj[name] = DexieError;
	  return obj;
	}, {});
	exceptions.Syntax = SyntaxError;
	exceptions.Type = TypeError;
	exceptions.Range = RangeError;
	var exceptionMap = idbDomErrorNames.reduce(function (obj, name) {
	  obj[name + "Error"] = exceptions[name];
	  return obj;
	}, {});

	function mapError(domError, message) {
	  if (!domError || domError instanceof DexieError || domError instanceof TypeError || domError instanceof SyntaxError || !domError.name || !exceptionMap[domError.name]) return domError;
	  var rv = new exceptionMap[domError.name](message || domError.message, domError);

	  if ("stack" in domError) {
	    setProp(rv, "stack", {
	      get: function get() {
	        return this.inner.stack;
	      }
	    });
	  }

	  return rv;
	}

	var fullNameExceptions = errorList.reduce(function (obj, name) {
	  if (["Syntax", "Type", "Range"].indexOf(name) === -1) obj[name + "Error"] = exceptions[name];
	  return obj;
	}, {});
	fullNameExceptions.ModifyError = ModifyError;
	fullNameExceptions.DexieError = DexieError;
	fullNameExceptions.BulkError = BulkError;

	function nop() {}

	function mirror(val) {
	  return val;
	}

	function pureFunctionChain(f1, f2) {
	  if (f1 == null || f1 === mirror) return f2;
	  return function (val) {
	    return f2(f1(val));
	  };
	}

	function callBoth(on1, on2) {
	  return function () {
	    on1.apply(this, arguments);
	    on2.apply(this, arguments);
	  };
	}

	function hookCreatingChain(f1, f2) {
	  if (f1 === nop) return f2;
	  return function () {
	    var res = f1.apply(this, arguments);
	    if (res !== undefined) arguments[0] = res;
	    var onsuccess = this.onsuccess,
	        onerror = this.onerror;
	    this.onsuccess = null;
	    this.onerror = null;
	    var res2 = f2.apply(this, arguments);
	    if (onsuccess) this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;
	    if (onerror) this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;
	    return res2 !== undefined ? res2 : res;
	  };
	}

	function hookDeletingChain(f1, f2) {
	  if (f1 === nop) return f2;
	  return function () {
	    f1.apply(this, arguments);
	    var onsuccess = this.onsuccess,
	        onerror = this.onerror;
	    this.onsuccess = this.onerror = null;
	    f2.apply(this, arguments);
	    if (onsuccess) this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;
	    if (onerror) this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;
	  };
	}

	function hookUpdatingChain(f1, f2) {
	  if (f1 === nop) return f2;
	  return function (modifications) {
	    var res = f1.apply(this, arguments);
	    extend(modifications, res);
	    var onsuccess = this.onsuccess,
	        onerror = this.onerror;
	    this.onsuccess = null;
	    this.onerror = null;
	    var res2 = f2.apply(this, arguments);
	    if (onsuccess) this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;
	    if (onerror) this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;
	    return res === undefined ? res2 === undefined ? undefined : res2 : extend(res, res2);
	  };
	}

	function reverseStoppableEventChain(f1, f2) {
	  if (f1 === nop) return f2;
	  return function () {
	    if (f2.apply(this, arguments) === false) return false;
	    return f1.apply(this, arguments);
	  };
	}

	function promisableChain(f1, f2) {
	  if (f1 === nop) return f2;
	  return function () {
	    var res = f1.apply(this, arguments);

	    if (res && typeof res.then === 'function') {
	      var thiz = this,
	          i = arguments.length,
	          args = new Array(i);

	      while (i--) {
	        args[i] = arguments[i];
	      }

	      return res.then(function () {
	        return f2.apply(thiz, args);
	      });
	    }

	    return f2.apply(this, arguments);
	  };
	}

	var INTERNAL = {};

	var LONG_STACKS_CLIP_LIMIT = 100,
	    MAX_LONG_STACKS = 20,
	    ZONE_ECHO_LIMIT = 100,
	    _a$1 = typeof Promise === 'undefined' ? [] : function () {
	  var globalP = Promise.resolve();
	  if (typeof crypto === 'undefined' || !crypto.subtle) return [globalP, getProto(globalP), globalP];
	  var nativeP = crypto.subtle.digest("SHA-512", new Uint8Array([0]));
	  return [nativeP, getProto(nativeP), globalP];
	}(),
	    resolvedNativePromise = _a$1[0],
	    nativePromiseProto = _a$1[1],
	    resolvedGlobalPromise = _a$1[2],
	    nativePromiseThen = nativePromiseProto && nativePromiseProto.then;

	var NativePromise = resolvedNativePromise && resolvedNativePromise.constructor;
	var patchGlobalPromise = !!resolvedGlobalPromise;
	var stack_being_generated = false;
	var schedulePhysicalTick = resolvedGlobalPromise ? function () {
	  resolvedGlobalPromise.then(physicalTick);
	} : _global.setImmediate ? setImmediate.bind(null, physicalTick) : _global.MutationObserver ? function () {
	  var hiddenDiv = document.createElement("div");
	  new MutationObserver(function () {
	    physicalTick();
	    hiddenDiv = null;
	  }).observe(hiddenDiv, {
	    attributes: true
	  });
	  hiddenDiv.setAttribute('i', '1');
	} : function () {
	  setTimeout(physicalTick, 0);
	};

	var asap = function asap(callback, args) {
	  microtickQueue.push([callback, args]);

	  if (needsNewPhysicalTick) {
	    schedulePhysicalTick();
	    needsNewPhysicalTick = false;
	  }
	};

	var isOutsideMicroTick = true,
	    needsNewPhysicalTick = true,
	    unhandledErrors = [],
	    rejectingErrors = [],
	    currentFulfiller = null,
	    rejectionMapper = mirror;
	var globalPSD = {
	  id: 'global',
	  global: true,
	  ref: 0,
	  unhandleds: [],
	  onunhandled: globalError,
	  pgp: false,
	  env: {},
	  finalize: function finalize() {
	    this.unhandleds.forEach(function (uh) {
	      try {
	        globalError(uh[0], uh[1]);
	      } catch (e) {}
	    });
	  }
	};
	var PSD = globalPSD;
	var microtickQueue = [];
	var numScheduledCalls = 0;
	var tickFinalizers = [];

	function DexiePromise(fn) {
	  if (babelHelpers["typeof"](this) !== 'object') throw new TypeError('Promises must be constructed via new');
	  this._listeners = [];
	  this.onuncatched = nop;
	  this._lib = false;
	  var psd = this._PSD = PSD;

	  if (debug) {
	    this._stackHolder = getErrorWithStack();
	    this._prev = null;
	    this._numPrev = 0;
	  }

	  if (typeof fn !== 'function') {
	    if (fn !== INTERNAL) throw new TypeError('Not a function');
	    this._state = arguments[1];
	    this._value = arguments[2];
	    if (this._state === false) handleRejection(this, this._value);
	    return;
	  }

	  this._state = null;
	  this._value = null;
	  ++psd.ref;
	  executePromiseTask(this, fn);
	}

	var thenProp = {
	  get: function get() {
	    var psd = PSD,
	        microTaskId = totalEchoes;

	    function then(onFulfilled, onRejected) {
	      var _this = this;

	      var possibleAwait = !psd.global && (psd !== PSD || microTaskId !== totalEchoes);
	      var cleanup = possibleAwait && !decrementExpectedAwaits();
	      var rv = new DexiePromise(function (resolve, reject) {
	        propagateToListener(_this, new Listener(nativeAwaitCompatibleWrap(onFulfilled, psd, possibleAwait, cleanup), nativeAwaitCompatibleWrap(onRejected, psd, possibleAwait, cleanup), resolve, reject, psd));
	      });
	      debug && linkToPreviousPromise(rv, this);
	      return rv;
	    }

	    then.prototype = INTERNAL;
	    return then;
	  },
	  set: function set(value) {
	    setProp(this, 'then', value && value.prototype === INTERNAL ? thenProp : {
	      get: function get() {
	        return value;
	      },
	      set: thenProp.set
	    });
	  }
	};
	props(DexiePromise.prototype, {
	  then: thenProp,
	  _then: function _then(onFulfilled, onRejected) {
	    propagateToListener(this, new Listener(null, null, onFulfilled, onRejected, PSD));
	  },
	  "catch": function _catch(onRejected) {
	    if (arguments.length === 1) return this.then(null, onRejected);
	    var type = arguments[0],
	        handler = arguments[1];
	    return typeof type === 'function' ? this.then(null, function (err) {
	      return err instanceof type ? handler(err) : PromiseReject(err);
	    }) : this.then(null, function (err) {
	      return err && err.name === type ? handler(err) : PromiseReject(err);
	    });
	  },
	  "finally": function _finally(onFinally) {
	    return this.then(function (value) {
	      onFinally();
	      return value;
	    }, function (err) {
	      onFinally();
	      return PromiseReject(err);
	    });
	  },
	  stack: {
	    get: function get() {
	      if (this._stack) return this._stack;

	      try {
	        stack_being_generated = true;
	        var stacks = getStack(this, [], MAX_LONG_STACKS);
	        var stack = stacks.join("\nFrom previous: ");
	        if (this._state !== null) this._stack = stack;
	        return stack;
	      } finally {
	        stack_being_generated = false;
	      }
	    }
	  },
	  timeout: function timeout(ms, msg) {
	    var _this = this;

	    return ms < Infinity ? new DexiePromise(function (resolve, reject) {
	      var handle = setTimeout(function () {
	        return reject(new exceptions.Timeout(msg));
	      }, ms);

	      _this.then(resolve, reject)["finally"](clearTimeout.bind(null, handle));
	    }) : this;
	  }
	});
	if (typeof Symbol !== 'undefined' && Symbol.toStringTag) setProp(DexiePromise.prototype, Symbol.toStringTag, 'Dexie.Promise');
	globalPSD.env = snapShot();

	function Listener(onFulfilled, onRejected, resolve, reject, zone) {
	  this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;
	  this.onRejected = typeof onRejected === 'function' ? onRejected : null;
	  this.resolve = resolve;
	  this.reject = reject;
	  this.psd = zone;
	}

	props(DexiePromise, {
	  all: function all() {
	    var values = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);
	    return new DexiePromise(function (resolve, reject) {
	      if (values.length === 0) resolve([]);
	      var remaining = values.length;
	      values.forEach(function (a, i) {
	        return DexiePromise.resolve(a).then(function (x) {
	          values[i] = x;
	          if (! --remaining) resolve(values);
	        }, reject);
	      });
	    });
	  },
	  resolve: function resolve(value) {
	    if (value instanceof DexiePromise) return value;
	    if (value && typeof value.then === 'function') return new DexiePromise(function (resolve, reject) {
	      value.then(resolve, reject);
	    });
	    var rv = new DexiePromise(INTERNAL, true, value);
	    linkToPreviousPromise(rv, currentFulfiller);
	    return rv;
	  },
	  reject: PromiseReject,
	  race: function race() {
	    var values = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);
	    return new DexiePromise(function (resolve, reject) {
	      values.map(function (value) {
	        return DexiePromise.resolve(value).then(resolve, reject);
	      });
	    });
	  },
	  PSD: {
	    get: function get() {
	      return PSD;
	    },
	    set: function set(value) {
	      return PSD = value;
	    }
	  },
	  totalEchoes: {
	    get: function get() {
	      return totalEchoes;
	    }
	  },
	  newPSD: newScope,
	  usePSD: usePSD,
	  scheduler: {
	    get: function get() {
	      return asap;
	    },
	    set: function set(value) {
	      asap = value;
	    }
	  },
	  rejectionMapper: {
	    get: function get() {
	      return rejectionMapper;
	    },
	    set: function set(value) {
	      rejectionMapper = value;
	    }
	  },
	  follow: function follow(fn, zoneProps) {
	    return new DexiePromise(function (resolve, reject) {
	      return newScope(function (resolve, reject) {
	        var psd = PSD;
	        psd.unhandleds = [];
	        psd.onunhandled = reject;
	        psd.finalize = callBoth(function () {
	          var _this = this;

	          run_at_end_of_this_or_next_physical_tick(function () {
	            _this.unhandleds.length === 0 ? resolve() : reject(_this.unhandleds[0]);
	          });
	        }, psd.finalize);
	        fn();
	      }, zoneProps, resolve, reject);
	    });
	  }
	});

	if (NativePromise) {
	  if (NativePromise.allSettled) setProp(DexiePromise, "allSettled", function () {
	    var possiblePromises = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);
	    return new DexiePromise(function (resolve) {
	      if (possiblePromises.length === 0) resolve([]);
	      var remaining = possiblePromises.length;
	      var results = new Array(remaining);
	      possiblePromises.forEach(function (p, i) {
	        return DexiePromise.resolve(p).then(function (value) {
	          return results[i] = {
	            status: "fulfilled",
	            value: value
	          };
	        }, function (reason) {
	          return results[i] = {
	            status: "rejected",
	            reason: reason
	          };
	        }).then(function () {
	          return --remaining || resolve(results);
	        });
	      });
	    });
	  });
	  if (NativePromise.any && typeof AggregateError !== 'undefined') setProp(DexiePromise, "any", function () {
	    var possiblePromises = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);
	    return new DexiePromise(function (resolve, reject) {
	      if (possiblePromises.length === 0) reject(new AggregateError([]));
	      var remaining = possiblePromises.length;
	      var failures = new Array(remaining);
	      possiblePromises.forEach(function (p, i) {
	        return DexiePromise.resolve(p).then(function (value) {
	          return resolve(value);
	        }, function (failure) {
	          failures[i] = failure;
	          if (! --remaining) reject(new AggregateError(failures));
	        });
	      });
	    });
	  });
	}

	function executePromiseTask(promise, fn) {
	  try {
	    fn(function (value) {
	      if (promise._state !== null) return;
	      if (value === promise) throw new TypeError('A promise cannot be resolved with itself.');
	      var shouldExecuteTick = promise._lib && beginMicroTickScope();

	      if (value && typeof value.then === 'function') {
	        executePromiseTask(promise, function (resolve, reject) {
	          value instanceof DexiePromise ? value._then(resolve, reject) : value.then(resolve, reject);
	        });
	      } else {
	        promise._state = true;
	        promise._value = value;
	        propagateAllListeners(promise);
	      }

	      if (shouldExecuteTick) endMicroTickScope();
	    }, handleRejection.bind(null, promise));
	  } catch (ex) {
	    handleRejection(promise, ex);
	  }
	}

	function handleRejection(promise, reason) {
	  rejectingErrors.push(reason);
	  if (promise._state !== null) return;
	  var shouldExecuteTick = promise._lib && beginMicroTickScope();
	  reason = rejectionMapper(reason);
	  promise._state = false;
	  promise._value = reason;
	  debug && reason !== null && babelHelpers["typeof"](reason) === 'object' && !reason._promise && tryCatch(function () {
	    var origProp = getPropertyDescriptor(reason, "stack");
	    reason._promise = promise;
	    setProp(reason, "stack", {
	      get: function get() {
	        return stack_being_generated ? origProp && (origProp.get ? origProp.get.apply(reason) : origProp.value) : promise.stack;
	      }
	    });
	  });
	  addPossiblyUnhandledError(promise);
	  propagateAllListeners(promise);
	  if (shouldExecuteTick) endMicroTickScope();
	}

	function propagateAllListeners(promise) {
	  var listeners = promise._listeners;
	  promise._listeners = [];

	  for (var i = 0, len = listeners.length; i < len; ++i) {
	    propagateToListener(promise, listeners[i]);
	  }

	  var psd = promise._PSD;
	  --psd.ref || psd.finalize();

	  if (numScheduledCalls === 0) {
	    ++numScheduledCalls;
	    asap(function () {
	      if (--numScheduledCalls === 0) finalizePhysicalTick();
	    }, []);
	  }
	}

	function propagateToListener(promise, listener) {
	  if (promise._state === null) {
	    promise._listeners.push(listener);

	    return;
	  }

	  var cb = promise._state ? listener.onFulfilled : listener.onRejected;

	  if (cb === null) {
	    return (promise._state ? listener.resolve : listener.reject)(promise._value);
	  }

	  ++listener.psd.ref;
	  ++numScheduledCalls;
	  asap(callListener, [cb, promise, listener]);
	}

	function callListener(cb, promise, listener) {
	  try {
	    currentFulfiller = promise;
	    var ret,
	        value = promise._value;

	    if (promise._state) {
	      ret = cb(value);
	    } else {
	      if (rejectingErrors.length) rejectingErrors = [];
	      ret = cb(value);
	      if (rejectingErrors.indexOf(value) === -1) markErrorAsHandled(promise);
	    }

	    listener.resolve(ret);
	  } catch (e) {
	    listener.reject(e);
	  } finally {
	    currentFulfiller = null;
	    if (--numScheduledCalls === 0) finalizePhysicalTick();
	    --listener.psd.ref || listener.psd.finalize();
	  }
	}

	function getStack(promise, stacks, limit) {
	  if (stacks.length === limit) return stacks;
	  var stack = "";

	  if (promise._state === false) {
	    var failure = promise._value,
	        errorName,
	        message;

	    if (failure != null) {
	      errorName = failure.name || "Error";
	      message = failure.message || failure;
	      stack = prettyStack(failure, 0);
	    } else {
	      errorName = failure;
	      message = "";
	    }

	    stacks.push(errorName + (message ? ": " + message : "") + stack);
	  }

	  if (debug) {
	    stack = prettyStack(promise._stackHolder, 2);
	    if (stack && stacks.indexOf(stack) === -1) stacks.push(stack);
	    if (promise._prev) getStack(promise._prev, stacks, limit);
	  }

	  return stacks;
	}

	function linkToPreviousPromise(promise, prev) {
	  var numPrev = prev ? prev._numPrev + 1 : 0;

	  if (numPrev < LONG_STACKS_CLIP_LIMIT) {
	    promise._prev = prev;
	    promise._numPrev = numPrev;
	  }
	}

	function physicalTick() {
	  beginMicroTickScope() && endMicroTickScope();
	}

	function beginMicroTickScope() {
	  var wasRootExec = isOutsideMicroTick;
	  isOutsideMicroTick = false;
	  needsNewPhysicalTick = false;
	  return wasRootExec;
	}

	function endMicroTickScope() {
	  var callbacks, i, l;

	  do {
	    while (microtickQueue.length > 0) {
	      callbacks = microtickQueue;
	      microtickQueue = [];
	      l = callbacks.length;

	      for (i = 0; i < l; ++i) {
	        var item = callbacks[i];
	        item[0].apply(null, item[1]);
	      }
	    }
	  } while (microtickQueue.length > 0);

	  isOutsideMicroTick = true;
	  needsNewPhysicalTick = true;
	}

	function finalizePhysicalTick() {
	  var unhandledErrs = unhandledErrors;
	  unhandledErrors = [];
	  unhandledErrs.forEach(function (p) {
	    p._PSD.onunhandled.call(null, p._value, p);
	  });
	  var finalizers = tickFinalizers.slice(0);
	  var i = finalizers.length;

	  while (i) {
	    finalizers[--i]();
	  }
	}

	function run_at_end_of_this_or_next_physical_tick(fn) {
	  function finalizer() {
	    fn();
	    tickFinalizers.splice(tickFinalizers.indexOf(finalizer), 1);
	  }

	  tickFinalizers.push(finalizer);
	  ++numScheduledCalls;
	  asap(function () {
	    if (--numScheduledCalls === 0) finalizePhysicalTick();
	  }, []);
	}

	function addPossiblyUnhandledError(promise) {
	  if (!unhandledErrors.some(function (p) {
	    return p._value === promise._value;
	  })) unhandledErrors.push(promise);
	}

	function markErrorAsHandled(promise) {
	  var i = unhandledErrors.length;

	  while (i) {
	    if (unhandledErrors[--i]._value === promise._value) {
	      unhandledErrors.splice(i, 1);
	      return;
	    }
	  }
	}

	function PromiseReject(reason) {
	  return new DexiePromise(INTERNAL, false, reason);
	}

	function wrap(fn, errorCatcher) {
	  var psd = PSD;
	  return function () {
	    var wasRootExec = beginMicroTickScope(),
	        outerScope = PSD;

	    try {
	      switchToZone(psd, true);
	      return fn.apply(this, arguments);
	    } catch (e) {
	      errorCatcher && errorCatcher(e);
	    } finally {
	      switchToZone(outerScope, false);
	      if (wasRootExec) endMicroTickScope();
	    }
	  };
	}

	var task = {
	  awaits: 0,
	  echoes: 0,
	  id: 0
	};
	var taskCounter = 0;
	var zoneStack = [];
	var zoneEchoes = 0;
	var totalEchoes = 0;
	var zone_id_counter = 0;

	function newScope(fn, props, a1, a2) {
	  var parent = PSD,
	      psd = Object.create(parent);
	  psd.parent = parent;
	  psd.ref = 0;
	  psd.global = false;
	  psd.id = ++zone_id_counter;
	  var globalEnv = globalPSD.env;
	  psd.env = patchGlobalPromise ? {
	    Promise: DexiePromise,
	    PromiseProp: {
	      value: DexiePromise,
	      configurable: true,
	      writable: true
	    },
	    all: DexiePromise.all,
	    race: DexiePromise.race,
	    allSettled: DexiePromise.allSettled,
	    any: DexiePromise.any,
	    resolve: DexiePromise.resolve,
	    reject: DexiePromise.reject,
	    nthen: getPatchedPromiseThen(globalEnv.nthen, psd),
	    gthen: getPatchedPromiseThen(globalEnv.gthen, psd)
	  } : {};
	  if (props) extend(psd, props);
	  ++parent.ref;

	  psd.finalize = function () {
	    --this.parent.ref || this.parent.finalize();
	  };

	  var rv = usePSD(psd, fn, a1, a2);
	  if (psd.ref === 0) psd.finalize();
	  return rv;
	}

	function incrementExpectedAwaits() {
	  if (!task.id) task.id = ++taskCounter;
	  ++task.awaits;
	  task.echoes += ZONE_ECHO_LIMIT;
	  return task.id;
	}

	function decrementExpectedAwaits() {
	  if (!task.awaits) return false;
	  if (--task.awaits === 0) task.id = 0;
	  task.echoes = task.awaits * ZONE_ECHO_LIMIT;
	  return true;
	}

	if (('' + nativePromiseThen).indexOf('[native code]') === -1) {
	  incrementExpectedAwaits = decrementExpectedAwaits = nop;
	}

	function onPossibleParallellAsync(possiblePromise) {
	  if (task.echoes && possiblePromise && possiblePromise.constructor === NativePromise) {
	    incrementExpectedAwaits();
	    return possiblePromise.then(function (x) {
	      decrementExpectedAwaits();
	      return x;
	    }, function (e) {
	      decrementExpectedAwaits();
	      return rejection(e);
	    });
	  }

	  return possiblePromise;
	}

	function zoneEnterEcho(targetZone) {
	  ++totalEchoes;

	  if (!task.echoes || --task.echoes === 0) {
	    task.echoes = task.id = 0;
	  }

	  zoneStack.push(PSD);
	  switchToZone(targetZone, true);
	}

	function zoneLeaveEcho() {
	  var zone = zoneStack[zoneStack.length - 1];
	  zoneStack.pop();
	  switchToZone(zone, false);
	}

	function switchToZone(targetZone, bEnteringZone) {
	  var currentZone = PSD;

	  if (bEnteringZone ? task.echoes && (!zoneEchoes++ || targetZone !== PSD) : zoneEchoes && (! --zoneEchoes || targetZone !== PSD)) {
	    enqueueNativeMicroTask(bEnteringZone ? zoneEnterEcho.bind(null, targetZone) : zoneLeaveEcho);
	  }

	  if (targetZone === PSD) return;
	  PSD = targetZone;
	  if (currentZone === globalPSD) globalPSD.env = snapShot();

	  if (patchGlobalPromise) {
	    var GlobalPromise_1 = globalPSD.env.Promise;
	    var targetEnv = targetZone.env;
	    nativePromiseProto.then = targetEnv.nthen;
	    GlobalPromise_1.prototype.then = targetEnv.gthen;

	    if (currentZone.global || targetZone.global) {
	      Object.defineProperty(_global, 'Promise', targetEnv.PromiseProp);
	      GlobalPromise_1.all = targetEnv.all;
	      GlobalPromise_1.race = targetEnv.race;
	      GlobalPromise_1.resolve = targetEnv.resolve;
	      GlobalPromise_1.reject = targetEnv.reject;
	      if (targetEnv.allSettled) GlobalPromise_1.allSettled = targetEnv.allSettled;
	      if (targetEnv.any) GlobalPromise_1.any = targetEnv.any;
	    }
	  }
	}

	function snapShot() {
	  var GlobalPromise = _global.Promise || Promise; // tag 02032020

	  return patchGlobalPromise ? {
	    Promise: GlobalPromise,
	    PromiseProp: Object.getOwnPropertyDescriptor(_global, "Promise"),
	    all: GlobalPromise.all,
	    race: GlobalPromise.race,
	    allSettled: GlobalPromise.allSettled,
	    any: GlobalPromise.any,
	    resolve: GlobalPromise.resolve,
	    reject: GlobalPromise.reject,
	    nthen: nativePromiseProto.then,
	    gthen: GlobalPromise.prototype.then
	  } : {};
	}

	function usePSD(psd, fn, a1, a2, a3) {
	  var outerScope = PSD;

	  try {
	    switchToZone(psd, true);
	    return fn(a1, a2, a3);
	  } finally {
	    switchToZone(outerScope, false);
	  }
	}

	function enqueueNativeMicroTask(job) {
	  nativePromiseThen.call(resolvedNativePromise, job);
	}

	function nativeAwaitCompatibleWrap(fn, zone, possibleAwait, cleanup) {
	  return typeof fn !== 'function' ? fn : function () {
	    var outerZone = PSD;
	    if (possibleAwait) incrementExpectedAwaits();
	    switchToZone(zone, true);

	    try {
	      return fn.apply(this, arguments);
	    } finally {
	      switchToZone(outerZone, false);
	      if (cleanup) enqueueNativeMicroTask(decrementExpectedAwaits);
	    }
	  };
	}

	function getPatchedPromiseThen(origThen, zone) {
	  return function (onResolved, onRejected) {
	    return origThen.call(this, nativeAwaitCompatibleWrap(onResolved, zone), nativeAwaitCompatibleWrap(onRejected, zone));
	  };
	}

	var UNHANDLEDREJECTION = "unhandledrejection";

	function globalError(err, promise) {
	  var rv;

	  try {
	    rv = promise.onuncatched(err);
	  } catch (e) {}

	  if (rv !== false) try {
	    var event,
	        eventData = {
	      promise: promise,
	      reason: err
	    };

	    if (_global.document && document.createEvent) {
	      event = document.createEvent('Event');
	      event.initEvent(UNHANDLEDREJECTION, true, true);
	      extend(event, eventData);
	    } else if (_global.CustomEvent) {
	      event = new CustomEvent(UNHANDLEDREJECTION, {
	        detail: eventData
	      });
	      extend(event, eventData);
	    }

	    if (event && _global.dispatchEvent) {
	      dispatchEvent(event);
	      if (!_global.PromiseRejectionEvent && _global.onunhandledrejection) try {
	        _global.onunhandledrejection(event);
	      } catch (_) {}
	    }

	    if (debug && event && !event.defaultPrevented) {
	      console.warn("Unhandled rejection: " + (err.stack || err));
	    }
	  } catch (e) {}
	}

	var rejection = DexiePromise.reject;

	function tempTransaction(db, mode, storeNames, fn) {
	  if (!db.idbdb || !db._state.openComplete && !PSD.letThrough && !db._vip) {
	    if (db._state.openComplete) {
	      return rejection(new exceptions.DatabaseClosed(db._state.dbOpenError));
	    }

	    if (!db._state.isBeingOpened) {
	      if (!db._options.autoOpen) return rejection(new exceptions.DatabaseClosed());
	      db.open()["catch"](nop);
	    }

	    return db._state.dbReadyPromise.then(function () {
	      return tempTransaction(db, mode, storeNames, fn);
	    });
	  } else {
	    var trans = db._createTransaction(mode, storeNames, db._dbSchema);

	    try {
	      trans.create();
	      db._state.PR1398_maxLoop = 3;
	    } catch (ex) {
	      if (ex.name === errnames.InvalidState && db.isOpen() && --db._state.PR1398_maxLoop > 0) {
	        console.warn('Dexie: Need to reopen db');

	        db._close();

	        return db.open().then(function () {
	          return tempTransaction(db, mode, storeNames, fn);
	        });
	      }

	      return rejection(ex);
	    }

	    return trans._promise(mode, function (resolve, reject) {
	      return newScope(function () {
	        PSD.trans = trans;
	        return fn(resolve, reject, trans);
	      });
	    }).then(function (result) {
	      return trans._completion.then(function () {
	        return result;
	      });
	    });
	  }
	}

	var DEXIE_VERSION = '3.2.2';
	var maxString = String.fromCharCode(65535);
	var minKey = -Infinity;
	var INVALID_KEY_ARGUMENT = "Invalid key provided. Keys must be of type string, number, Date or Array<string | number | Date>.";
	var STRING_EXPECTED = "String expected.";
	var connections = [];
	var isIEOrEdge = typeof navigator !== 'undefined' && /(MSIE|Trident|Edge)/.test(navigator.userAgent);
	var hasIEDeleteObjectStoreBug = isIEOrEdge;
	var hangsOnDeleteLargeKeyRange = isIEOrEdge;

	var dexieStackFrameFilter = function dexieStackFrameFilter(frame) {
	  return !/(dexie\.js|dexie\.min\.js)/.test(frame);
	};

	var DBNAMES_DB = '__dbnames';
	var READONLY = 'readonly';
	var READWRITE = 'readwrite';

	function combine(filter1, filter2) {
	  return filter1 ? filter2 ? function () {
	    return filter1.apply(this, arguments) && filter2.apply(this, arguments);
	  } : filter1 : filter2;
	}

	var AnyRange = {
	  type: 3,
	  lower: -Infinity,
	  lowerOpen: false,
	  upper: [[]],
	  upperOpen: false
	};

	function workaroundForUndefinedPrimKey(keyPath) {
	  return typeof keyPath === "string" && !/\./.test(keyPath) ? function (obj) {
	    if (obj[keyPath] === undefined && keyPath in obj) {
	      obj = deepClone(obj);
	      delete obj[keyPath];
	    }

	    return obj;
	  } : function (obj) {
	    return obj;
	  };
	}

	var Table = function () {
	  function Table() {}

	  Table.prototype._trans = function (mode, fn, writeLocked) {
	    var trans = this._tx || PSD.trans;
	    var tableName = this.name;

	    function checkTableInTransaction(resolve, reject, trans) {
	      if (!trans.schema[tableName]) throw new exceptions.NotFound("Table " + tableName + " not part of transaction");
	      return fn(trans.idbtrans, trans);
	    }

	    var wasRootExec = beginMicroTickScope();

	    try {
	      return trans && trans.db === this.db ? trans === PSD.trans ? trans._promise(mode, checkTableInTransaction, writeLocked) : newScope(function () {
	        return trans._promise(mode, checkTableInTransaction, writeLocked);
	      }, {
	        trans: trans,
	        transless: PSD.transless || PSD
	      }) : tempTransaction(this.db, mode, [this.name], checkTableInTransaction);
	    } finally {
	      if (wasRootExec) endMicroTickScope();
	    }
	  };

	  Table.prototype.get = function (keyOrCrit, cb) {
	    var _this = this;

	    if (keyOrCrit && keyOrCrit.constructor === Object) return this.where(keyOrCrit).first(cb);
	    return this._trans('readonly', function (trans) {
	      return _this.core.get({
	        trans: trans,
	        key: keyOrCrit
	      }).then(function (res) {
	        return _this.hook.reading.fire(res);
	      });
	    }).then(cb);
	  };

	  Table.prototype.where = function (indexOrCrit) {
	    if (typeof indexOrCrit === 'string') return new this.db.WhereClause(this, indexOrCrit);
	    if (isArray(indexOrCrit)) return new this.db.WhereClause(this, "[" + indexOrCrit.join('+') + "]");
	    var keyPaths = keys(indexOrCrit);
	    if (keyPaths.length === 1) return this.where(keyPaths[0]).equals(indexOrCrit[keyPaths[0]]);
	    var compoundIndex = this.schema.indexes.concat(this.schema.primKey).filter(function (ix) {
	      return ix.compound && keyPaths.every(function (keyPath) {
	        return ix.keyPath.indexOf(keyPath) >= 0;
	      }) && ix.keyPath.every(function (keyPath) {
	        return keyPaths.indexOf(keyPath) >= 0;
	      });
	    })[0];
	    if (compoundIndex && this.db._maxKey !== maxString) return this.where(compoundIndex.name).equals(compoundIndex.keyPath.map(function (kp) {
	      return indexOrCrit[kp];
	    }));
	    if (!compoundIndex && debug) console.warn("The query " + JSON.stringify(indexOrCrit) + " on " + this.name + " would benefit of a " + ("compound index [" + keyPaths.join('+') + "]"));
	    var idxByName = this.schema.idxByName;
	    var idb = this.db._deps.indexedDB;

	    function equals(a, b) {
	      try {
	        return idb.cmp(a, b) === 0;
	      } catch (e) {
	        return false;
	      }
	    }

	    var _a = keyPaths.reduce(function (_a, keyPath) {
	      var prevIndex = _a[0],
	          prevFilterFn = _a[1];
	      var index = idxByName[keyPath];
	      var value = indexOrCrit[keyPath];
	      return [prevIndex || index, prevIndex || !index ? combine(prevFilterFn, index && index.multi ? function (x) {
	        var prop = getByKeyPath(x, keyPath);
	        return isArray(prop) && prop.some(function (item) {
	          return equals(value, item);
	        });
	      } : function (x) {
	        return equals(value, getByKeyPath(x, keyPath));
	      }) : prevFilterFn];
	    }, [null, null]),
	        idx = _a[0],
	        filterFunction = _a[1];

	    return idx ? this.where(idx.name).equals(indexOrCrit[idx.keyPath]).filter(filterFunction) : compoundIndex ? this.filter(filterFunction) : this.where(keyPaths).equals('');
	  };

	  Table.prototype.filter = function (filterFunction) {
	    return this.toCollection().and(filterFunction);
	  };

	  Table.prototype.count = function (thenShortcut) {
	    return this.toCollection().count(thenShortcut);
	  };

	  Table.prototype.offset = function (offset) {
	    return this.toCollection().offset(offset);
	  };

	  Table.prototype.limit = function (numRows) {
	    return this.toCollection().limit(numRows);
	  };

	  Table.prototype.each = function (callback) {
	    return this.toCollection().each(callback);
	  };

	  Table.prototype.toArray = function (thenShortcut) {
	    return this.toCollection().toArray(thenShortcut);
	  };

	  Table.prototype.toCollection = function () {
	    return new this.db.Collection(new this.db.WhereClause(this));
	  };

	  Table.prototype.orderBy = function (index) {
	    return new this.db.Collection(new this.db.WhereClause(this, isArray(index) ? "[" + index.join('+') + "]" : index));
	  };

	  Table.prototype.reverse = function () {
	    return this.toCollection().reverse();
	  };

	  Table.prototype.mapToClass = function (constructor) {
	    this.schema.mappedClass = constructor;

	    var readHook = function readHook(obj) {
	      if (!obj) return obj;
	      var res = Object.create(constructor.prototype);

	      for (var m in obj) {
	        if (hasOwn(obj, m)) try {
	          res[m] = obj[m];
	        } catch (_) {}
	      }

	      return res;
	    };

	    if (this.schema.readHook) {
	      this.hook.reading.unsubscribe(this.schema.readHook);
	    }

	    this.schema.readHook = readHook;
	    this.hook("reading", readHook);
	    return constructor;
	  };

	  Table.prototype.defineClass = function () {
	    function Class(content) {
	      extend(this, content);
	    }

	    return this.mapToClass(Class);
	  };

	  Table.prototype.add = function (obj, key) {
	    var _this = this;

	    var _a = this.schema.primKey,
	        auto = _a.auto,
	        keyPath = _a.keyPath;
	    var objToAdd = obj;

	    if (keyPath && auto) {
	      objToAdd = workaroundForUndefinedPrimKey(keyPath)(obj);
	    }

	    return this._trans('readwrite', function (trans) {
	      return _this.core.mutate({
	        trans: trans,
	        type: 'add',
	        keys: key != null ? [key] : null,
	        values: [objToAdd]
	      });
	    }).then(function (res) {
	      return res.numFailures ? DexiePromise.reject(res.failures[0]) : res.lastResult;
	    }).then(function (lastResult) {
	      if (keyPath) {
	        try {
	          setByKeyPath(obj, keyPath, lastResult);
	        } catch (_) {}
	      }

	      return lastResult;
	    });
	  };

	  Table.prototype.update = function (keyOrObject, modifications) {
	    if (babelHelpers["typeof"](keyOrObject) === 'object' && !isArray(keyOrObject)) {
	      var key = getByKeyPath(keyOrObject, this.schema.primKey.keyPath);
	      if (key === undefined) return rejection(new exceptions.InvalidArgument("Given object does not contain its primary key"));

	      try {
	        if (typeof modifications !== "function") {
	          keys(modifications).forEach(function (keyPath) {
	            setByKeyPath(keyOrObject, keyPath, modifications[keyPath]);
	          });
	        } else {
	          modifications(keyOrObject, {
	            value: keyOrObject,
	            primKey: key
	          });
	        }
	      } catch (_a) {}

	      return this.where(":id").equals(key).modify(modifications);
	    } else {
	      return this.where(":id").equals(keyOrObject).modify(modifications);
	    }
	  };

	  Table.prototype.put = function (obj, key) {
	    var _this = this;

	    var _a = this.schema.primKey,
	        auto = _a.auto,
	        keyPath = _a.keyPath;
	    var objToAdd = obj;

	    if (keyPath && auto) {
	      objToAdd = workaroundForUndefinedPrimKey(keyPath)(obj);
	    }

	    return this._trans('readwrite', function (trans) {
	      return _this.core.mutate({
	        trans: trans,
	        type: 'put',
	        values: [objToAdd],
	        keys: key != null ? [key] : null
	      });
	    }).then(function (res) {
	      return res.numFailures ? DexiePromise.reject(res.failures[0]) : res.lastResult;
	    }).then(function (lastResult) {
	      if (keyPath) {
	        try {
	          setByKeyPath(obj, keyPath, lastResult);
	        } catch (_) {}
	      }

	      return lastResult;
	    });
	  };

	  Table.prototype["delete"] = function (key) {
	    var _this = this;

	    return this._trans('readwrite', function (trans) {
	      return _this.core.mutate({
	        trans: trans,
	        type: 'delete',
	        keys: [key]
	      });
	    }).then(function (res) {
	      return res.numFailures ? DexiePromise.reject(res.failures[0]) : undefined;
	    });
	  };

	  Table.prototype.clear = function () {
	    var _this = this;

	    return this._trans('readwrite', function (trans) {
	      return _this.core.mutate({
	        trans: trans,
	        type: 'deleteRange',
	        range: AnyRange
	      });
	    }).then(function (res) {
	      return res.numFailures ? DexiePromise.reject(res.failures[0]) : undefined;
	    });
	  };

	  Table.prototype.bulkGet = function (keys) {
	    var _this = this;

	    return this._trans('readonly', function (trans) {
	      return _this.core.getMany({
	        keys: keys,
	        trans: trans
	      }).then(function (result) {
	        return result.map(function (res) {
	          return _this.hook.reading.fire(res);
	        });
	      });
	    });
	  };

	  Table.prototype.bulkAdd = function (objects, keysOrOptions, options) {
	    var _this = this;

	    var keys = Array.isArray(keysOrOptions) ? keysOrOptions : undefined;
	    options = options || (keys ? undefined : keysOrOptions);
	    var wantResults = options ? options.allKeys : undefined;
	    return this._trans('readwrite', function (trans) {
	      var _a = _this.schema.primKey,
	          auto = _a.auto,
	          keyPath = _a.keyPath;
	      if (keyPath && keys) throw new exceptions.InvalidArgument("bulkAdd(): keys argument invalid on tables with inbound keys");
	      if (keys && keys.length !== objects.length) throw new exceptions.InvalidArgument("Arguments objects and keys must have the same length");
	      var numObjects = objects.length;
	      var objectsToAdd = keyPath && auto ? objects.map(workaroundForUndefinedPrimKey(keyPath)) : objects;
	      return _this.core.mutate({
	        trans: trans,
	        type: 'add',
	        keys: keys,
	        values: objectsToAdd,
	        wantResults: wantResults
	      }).then(function (_a) {
	        var numFailures = _a.numFailures,
	            results = _a.results,
	            lastResult = _a.lastResult,
	            failures = _a.failures;
	        var result = wantResults ? results : lastResult;
	        if (numFailures === 0) return result;
	        throw new BulkError(_this.name + ".bulkAdd(): " + numFailures + " of " + numObjects + " operations failed", failures);
	      });
	    });
	  };

	  Table.prototype.bulkPut = function (objects, keysOrOptions, options) {
	    var _this = this;

	    var keys = Array.isArray(keysOrOptions) ? keysOrOptions : undefined;
	    options = options || (keys ? undefined : keysOrOptions);
	    var wantResults = options ? options.allKeys : undefined;
	    return this._trans('readwrite', function (trans) {
	      var _a = _this.schema.primKey,
	          auto = _a.auto,
	          keyPath = _a.keyPath;
	      if (keyPath && keys) throw new exceptions.InvalidArgument("bulkPut(): keys argument invalid on tables with inbound keys");
	      if (keys && keys.length !== objects.length) throw new exceptions.InvalidArgument("Arguments objects and keys must have the same length");
	      var numObjects = objects.length;
	      var objectsToPut = keyPath && auto ? objects.map(workaroundForUndefinedPrimKey(keyPath)) : objects;
	      return _this.core.mutate({
	        trans: trans,
	        type: 'put',
	        keys: keys,
	        values: objectsToPut,
	        wantResults: wantResults
	      }).then(function (_a) {
	        var numFailures = _a.numFailures,
	            results = _a.results,
	            lastResult = _a.lastResult,
	            failures = _a.failures;
	        var result = wantResults ? results : lastResult;
	        if (numFailures === 0) return result;
	        throw new BulkError(_this.name + ".bulkPut(): " + numFailures + " of " + numObjects + " operations failed", failures);
	      });
	    });
	  };

	  Table.prototype.bulkDelete = function (keys) {
	    var _this = this;

	    var numKeys = keys.length;
	    return this._trans('readwrite', function (trans) {
	      return _this.core.mutate({
	        trans: trans,
	        type: 'delete',
	        keys: keys
	      });
	    }).then(function (_a) {
	      var numFailures = _a.numFailures,
	          lastResult = _a.lastResult,
	          failures = _a.failures;
	      if (numFailures === 0) return lastResult;
	      throw new BulkError(_this.name + ".bulkDelete(): " + numFailures + " of " + numKeys + " operations failed", failures);
	    });
	  };

	  return Table;
	}();

	function Events(ctx) {
	  var evs = {};

	  var rv = function rv(eventName, subscriber) {
	    if (subscriber) {
	      var i = arguments.length,
	          args = new Array(i - 1);

	      while (--i) {
	        args[i - 1] = arguments[i];
	      }

	      evs[eventName].subscribe.apply(null, args);
	      return ctx;
	    } else if (typeof eventName === 'string') {
	      return evs[eventName];
	    }
	  };

	  rv.addEventType = add;

	  for (var i = 1, l = arguments.length; i < l; ++i) {
	    add(arguments[i]);
	  }

	  return rv;

	  function add(eventName, chainFunction, defaultFunction) {
	    if (babelHelpers["typeof"](eventName) === 'object') return addConfiguredEvents(eventName);
	    if (!chainFunction) chainFunction = reverseStoppableEventChain;
	    if (!defaultFunction) defaultFunction = nop;
	    var context = {
	      subscribers: [],
	      fire: defaultFunction,
	      subscribe: function subscribe(cb) {
	        if (context.subscribers.indexOf(cb) === -1) {
	          context.subscribers.push(cb);
	          context.fire = chainFunction(context.fire, cb);
	        }
	      },
	      unsubscribe: function unsubscribe(cb) {
	        context.subscribers = context.subscribers.filter(function (fn) {
	          return fn !== cb;
	        });
	        context.fire = context.subscribers.reduce(chainFunction, defaultFunction);
	      }
	    };
	    evs[eventName] = rv[eventName] = context;
	    return context;
	  }

	  function addConfiguredEvents(cfg) {
	    keys(cfg).forEach(function (eventName) {
	      var args = cfg[eventName];

	      if (isArray(args)) {
	        add(eventName, cfg[eventName][0], cfg[eventName][1]);
	      } else if (args === 'asap') {
	        var context = add(eventName, mirror, function fire() {
	          var i = arguments.length,
	              args = new Array(i);

	          while (i--) {
	            args[i] = arguments[i];
	          }

	          context.subscribers.forEach(function (fn) {
	            asap$1(function fireEvent() {
	              fn.apply(null, args);
	            });
	          });
	        });
	      } else throw new exceptions.InvalidArgument("Invalid event config");
	    });
	  }
	}

	function makeClassConstructor(prototype, constructor) {
	  derive(constructor).from({
	    prototype: prototype
	  });
	  return constructor;
	}

	function createTableConstructor(db) {
	  return makeClassConstructor(Table.prototype, function Table(name, tableSchema, trans) {
	    this.db = db;
	    this._tx = trans;
	    this.name = name;
	    this.schema = tableSchema;
	    this.hook = db._allTables[name] ? db._allTables[name].hook : Events(null, {
	      "creating": [hookCreatingChain, nop],
	      "reading": [pureFunctionChain, mirror],
	      "updating": [hookUpdatingChain, nop],
	      "deleting": [hookDeletingChain, nop]
	    });
	  });
	}

	function isPlainKeyRange(ctx, ignoreLimitFilter) {
	  return !(ctx.filter || ctx.algorithm || ctx.or) && (ignoreLimitFilter ? ctx.justLimit : !ctx.replayFilter);
	}

	function addFilter(ctx, fn) {
	  ctx.filter = combine(ctx.filter, fn);
	}

	function addReplayFilter(ctx, factory, isLimitFilter) {
	  var curr = ctx.replayFilter;
	  ctx.replayFilter = curr ? function () {
	    return combine(curr(), factory());
	  } : factory;
	  ctx.justLimit = isLimitFilter && !curr;
	}

	function addMatchFilter(ctx, fn) {
	  ctx.isMatch = combine(ctx.isMatch, fn);
	}

	function getIndexOrStore(ctx, coreSchema) {
	  if (ctx.isPrimKey) return coreSchema.primaryKey;
	  var index = coreSchema.getIndexByKeyPath(ctx.index);
	  if (!index) throw new exceptions.Schema("KeyPath " + ctx.index + " on object store " + coreSchema.name + " is not indexed");
	  return index;
	}

	function openCursor(ctx, coreTable, trans) {
	  var index = getIndexOrStore(ctx, coreTable.schema);
	  return coreTable.openCursor({
	    trans: trans,
	    values: !ctx.keysOnly,
	    reverse: ctx.dir === 'prev',
	    unique: !!ctx.unique,
	    query: {
	      index: index,
	      range: ctx.range
	    }
	  });
	}

	function iter(ctx, fn, coreTrans, coreTable) {
	  var filter = ctx.replayFilter ? combine(ctx.filter, ctx.replayFilter()) : ctx.filter;

	  if (!ctx.or) {
	    return iterate(openCursor(ctx, coreTable, coreTrans), combine(ctx.algorithm, filter), fn, !ctx.keysOnly && ctx.valueMapper);
	  } else {
	    var set_1 = {};

	    var union = function union(item, cursor, advance) {
	      if (!filter || filter(cursor, advance, function (result) {
	        return cursor.stop(result);
	      }, function (err) {
	        return cursor.fail(err);
	      })) {
	        var primaryKey = cursor.primaryKey;
	        var key = '' + primaryKey;
	        if (key === '[object ArrayBuffer]') key = '' + new Uint8Array(primaryKey);

	        if (!hasOwn(set_1, key)) {
	          set_1[key] = true;
	          fn(item, cursor, advance);
	        }
	      }
	    };

	    return Promise.all([ctx.or._iterate(union, coreTrans), iterate(openCursor(ctx, coreTable, coreTrans), ctx.algorithm, union, !ctx.keysOnly && ctx.valueMapper)]);
	  }
	}

	function iterate(cursorPromise, filter, fn, valueMapper) {
	  var mappedFn = valueMapper ? function (x, c, a) {
	    return fn(valueMapper(x), c, a);
	  } : fn;
	  var wrappedFn = wrap(mappedFn);
	  return cursorPromise.then(function (cursor) {
	    if (cursor) {
	      return cursor.start(function () {
	        var c = function c() {
	          return cursor["continue"]();
	        };

	        if (!filter || filter(cursor, function (advancer) {
	          return c = advancer;
	        }, function (val) {
	          cursor.stop(val);
	          c = nop;
	        }, function (e) {
	          cursor.fail(e);
	          c = nop;
	        })) wrappedFn(cursor.value, cursor, function (advancer) {
	          return c = advancer;
	        });
	        c();
	      });
	    }
	  });
	}

	function cmp(a, b) {
	  try {
	    var ta = type(a);
	    var tb = type(b);

	    if (ta !== tb) {
	      if (ta === 'Array') return 1;
	      if (tb === 'Array') return -1;
	      if (ta === 'binary') return 1;
	      if (tb === 'binary') return -1;
	      if (ta === 'string') return 1;
	      if (tb === 'string') return -1;
	      if (ta === 'Date') return 1;
	      if (tb !== 'Date') return NaN;
	      return -1;
	    }

	    switch (ta) {
	      case 'number':
	      case 'Date':
	      case 'string':
	        return a > b ? 1 : a < b ? -1 : 0;

	      case 'binary':
	        {
	          return compareUint8Arrays(getUint8Array(a), getUint8Array(b));
	        }

	      case 'Array':
	        return compareArrays(a, b);
	    }
	  } catch (_a) {}

	  return NaN;
	}

	function compareArrays(a, b) {
	  var al = a.length;
	  var bl = b.length;
	  var l = al < bl ? al : bl;

	  for (var i = 0; i < l; ++i) {
	    var res = cmp(a[i], b[i]);
	    if (res !== 0) return res;
	  }

	  return al === bl ? 0 : al < bl ? -1 : 1;
	}

	function compareUint8Arrays(a, b) {
	  var al = a.length;
	  var bl = b.length;
	  var l = al < bl ? al : bl;

	  for (var i = 0; i < l; ++i) {
	    if (a[i] !== b[i]) return a[i] < b[i] ? -1 : 1;
	  }

	  return al === bl ? 0 : al < bl ? -1 : 1;
	}

	function type(x) {
	  var t = babelHelpers["typeof"](x);
	  if (t !== 'object') return t;
	  if (ArrayBuffer.isView(x)) return 'binary';
	  var tsTag = toStringTag(x);
	  return tsTag === 'ArrayBuffer' ? 'binary' : tsTag;
	}

	function getUint8Array(a) {
	  if (a instanceof Uint8Array) return a;
	  if (ArrayBuffer.isView(a)) return new Uint8Array(a.buffer, a.byteOffset, a.byteLength);
	  return new Uint8Array(a);
	}

	var Collection = function () {
	  function Collection() {}

	  Collection.prototype._read = function (fn, cb) {
	    var ctx = this._ctx;
	    return ctx.error ? ctx.table._trans(null, rejection.bind(null, ctx.error)) : ctx.table._trans('readonly', fn).then(cb);
	  };

	  Collection.prototype._write = function (fn) {
	    var ctx = this._ctx;
	    return ctx.error ? ctx.table._trans(null, rejection.bind(null, ctx.error)) : ctx.table._trans('readwrite', fn, "locked");
	  };

	  Collection.prototype._addAlgorithm = function (fn) {
	    var ctx = this._ctx;
	    ctx.algorithm = combine(ctx.algorithm, fn);
	  };

	  Collection.prototype._iterate = function (fn, coreTrans) {
	    return iter(this._ctx, fn, coreTrans, this._ctx.table.core);
	  };

	  Collection.prototype.clone = function (props) {
	    var rv = Object.create(this.constructor.prototype),
	        ctx = Object.create(this._ctx);
	    if (props) extend(ctx, props);
	    rv._ctx = ctx;
	    return rv;
	  };

	  Collection.prototype.raw = function () {
	    this._ctx.valueMapper = null;
	    return this;
	  };

	  Collection.prototype.each = function (fn) {
	    var ctx = this._ctx;
	    return this._read(function (trans) {
	      return iter(ctx, fn, trans, ctx.table.core);
	    });
	  };

	  Collection.prototype.count = function (cb) {
	    var _this = this;

	    return this._read(function (trans) {
	      var ctx = _this._ctx;
	      var coreTable = ctx.table.core;

	      if (isPlainKeyRange(ctx, true)) {
	        return coreTable.count({
	          trans: trans,
	          query: {
	            index: getIndexOrStore(ctx, coreTable.schema),
	            range: ctx.range
	          }
	        }).then(function (count) {
	          return Math.min(count, ctx.limit);
	        });
	      } else {
	        var count = 0;
	        return iter(ctx, function () {
	          ++count;
	          return false;
	        }, trans, coreTable).then(function () {
	          return count;
	        });
	      }
	    }).then(cb);
	  };

	  Collection.prototype.sortBy = function (keyPath, cb) {
	    var parts = keyPath.split('.').reverse(),
	        lastPart = parts[0],
	        lastIndex = parts.length - 1;

	    function getval(obj, i) {
	      if (i) return getval(obj[parts[i]], i - 1);
	      return obj[lastPart];
	    }

	    var order = this._ctx.dir === "next" ? 1 : -1;

	    function sorter(a, b) {
	      var aVal = getval(a, lastIndex),
	          bVal = getval(b, lastIndex);
	      return aVal < bVal ? -order : aVal > bVal ? order : 0;
	    }

	    return this.toArray(function (a) {
	      return a.sort(sorter);
	    }).then(cb);
	  };

	  Collection.prototype.toArray = function (cb) {
	    var _this = this;

	    return this._read(function (trans) {
	      var ctx = _this._ctx;

	      if (ctx.dir === 'next' && isPlainKeyRange(ctx, true) && ctx.limit > 0) {
	        var valueMapper_1 = ctx.valueMapper;
	        var index = getIndexOrStore(ctx, ctx.table.core.schema);
	        return ctx.table.core.query({
	          trans: trans,
	          limit: ctx.limit,
	          values: true,
	          query: {
	            index: index,
	            range: ctx.range
	          }
	        }).then(function (_a) {
	          var result = _a.result;
	          return valueMapper_1 ? result.map(valueMapper_1) : result;
	        });
	      } else {
	        var a_1 = [];
	        return iter(ctx, function (item) {
	          return a_1.push(item);
	        }, trans, ctx.table.core).then(function () {
	          return a_1;
	        });
	      }
	    }, cb);
	  };

	  Collection.prototype.offset = function (offset) {
	    var ctx = this._ctx;
	    if (offset <= 0) return this;
	    ctx.offset += offset;

	    if (isPlainKeyRange(ctx)) {
	      addReplayFilter(ctx, function () {
	        var offsetLeft = offset;
	        return function (cursor, advance) {
	          if (offsetLeft === 0) return true;

	          if (offsetLeft === 1) {
	            --offsetLeft;
	            return false;
	          }

	          advance(function () {
	            cursor.advance(offsetLeft);
	            offsetLeft = 0;
	          });
	          return false;
	        };
	      });
	    } else {
	      addReplayFilter(ctx, function () {
	        var offsetLeft = offset;
	        return function () {
	          return --offsetLeft < 0;
	        };
	      });
	    }

	    return this;
	  };

	  Collection.prototype.limit = function (numRows) {
	    this._ctx.limit = Math.min(this._ctx.limit, numRows);
	    addReplayFilter(this._ctx, function () {
	      var rowsLeft = numRows;
	      return function (cursor, advance, resolve) {
	        if (--rowsLeft <= 0) advance(resolve);
	        return rowsLeft >= 0;
	      };
	    }, true);
	    return this;
	  };

	  Collection.prototype.until = function (filterFunction, bIncludeStopEntry) {
	    addFilter(this._ctx, function (cursor, advance, resolve) {
	      if (filterFunction(cursor.value)) {
	        advance(resolve);
	        return bIncludeStopEntry;
	      } else {
	        return true;
	      }
	    });
	    return this;
	  };

	  Collection.prototype.first = function (cb) {
	    return this.limit(1).toArray(function (a) {
	      return a[0];
	    }).then(cb);
	  };

	  Collection.prototype.last = function (cb) {
	    return this.reverse().first(cb);
	  };

	  Collection.prototype.filter = function (filterFunction) {
	    addFilter(this._ctx, function (cursor) {
	      return filterFunction(cursor.value);
	    });
	    addMatchFilter(this._ctx, filterFunction);
	    return this;
	  };

	  Collection.prototype.and = function (filter) {
	    return this.filter(filter);
	  };

	  Collection.prototype.or = function (indexName) {
	    return new this.db.WhereClause(this._ctx.table, indexName, this);
	  };

	  Collection.prototype.reverse = function () {
	    this._ctx.dir = this._ctx.dir === "prev" ? "next" : "prev";
	    if (this._ondirectionchange) this._ondirectionchange(this._ctx.dir);
	    return this;
	  };

	  Collection.prototype.desc = function () {
	    return this.reverse();
	  };

	  Collection.prototype.eachKey = function (cb) {
	    var ctx = this._ctx;
	    ctx.keysOnly = !ctx.isMatch;
	    return this.each(function (val, cursor) {
	      cb(cursor.key, cursor);
	    });
	  };

	  Collection.prototype.eachUniqueKey = function (cb) {
	    this._ctx.unique = "unique";
	    return this.eachKey(cb);
	  };

	  Collection.prototype.eachPrimaryKey = function (cb) {
	    var ctx = this._ctx;
	    ctx.keysOnly = !ctx.isMatch;
	    return this.each(function (val, cursor) {
	      cb(cursor.primaryKey, cursor);
	    });
	  };

	  Collection.prototype.keys = function (cb) {
	    var ctx = this._ctx;
	    ctx.keysOnly = !ctx.isMatch;
	    var a = [];
	    return this.each(function (item, cursor) {
	      a.push(cursor.key);
	    }).then(function () {
	      return a;
	    }).then(cb);
	  };

	  Collection.prototype.primaryKeys = function (cb) {
	    var ctx = this._ctx;

	    if (ctx.dir === 'next' && isPlainKeyRange(ctx, true) && ctx.limit > 0) {
	      return this._read(function (trans) {
	        var index = getIndexOrStore(ctx, ctx.table.core.schema);
	        return ctx.table.core.query({
	          trans: trans,
	          values: false,
	          limit: ctx.limit,
	          query: {
	            index: index,
	            range: ctx.range
	          }
	        });
	      }).then(function (_a) {
	        var result = _a.result;
	        return result;
	      }).then(cb);
	    }

	    ctx.keysOnly = !ctx.isMatch;
	    var a = [];
	    return this.each(function (item, cursor) {
	      a.push(cursor.primaryKey);
	    }).then(function () {
	      return a;
	    }).then(cb);
	  };

	  Collection.prototype.uniqueKeys = function (cb) {
	    this._ctx.unique = "unique";
	    return this.keys(cb);
	  };

	  Collection.prototype.firstKey = function (cb) {
	    return this.limit(1).keys(function (a) {
	      return a[0];
	    }).then(cb);
	  };

	  Collection.prototype.lastKey = function (cb) {
	    return this.reverse().firstKey(cb);
	  };

	  Collection.prototype.distinct = function () {
	    var ctx = this._ctx,
	        idx = ctx.index && ctx.table.schema.idxByName[ctx.index];
	    if (!idx || !idx.multi) return this;
	    var set = {};
	    addFilter(this._ctx, function (cursor) {
	      var strKey = cursor.primaryKey.toString();
	      var found = hasOwn(set, strKey);
	      set[strKey] = true;
	      return !found;
	    });
	    return this;
	  };

	  Collection.prototype.modify = function (changes) {
	    var _this = this;

	    var ctx = this._ctx;
	    return this._write(function (trans) {
	      var modifyer;

	      if (typeof changes === 'function') {
	        modifyer = changes;
	      } else {
	        var keyPaths = keys(changes);
	        var numKeys = keyPaths.length;

	        modifyer = function modifyer(item) {
	          var anythingModified = false;

	          for (var i = 0; i < numKeys; ++i) {
	            var keyPath = keyPaths[i],
	                val = changes[keyPath];

	            if (getByKeyPath(item, keyPath) !== val) {
	              setByKeyPath(item, keyPath, val);
	              anythingModified = true;
	            }
	          }

	          return anythingModified;
	        };
	      }

	      var coreTable = ctx.table.core;
	      var _a = coreTable.schema.primaryKey,
	          outbound = _a.outbound,
	          extractKey = _a.extractKey;
	      var limit = _this.db._options.modifyChunkSize || 200;
	      var totalFailures = [];
	      var successCount = 0;
	      var failedKeys = [];

	      var applyMutateResult = function applyMutateResult(expectedCount, res) {
	        var failures = res.failures,
	            numFailures = res.numFailures;
	        successCount += expectedCount - numFailures;

	        for (var _i = 0, _a = keys(failures); _i < _a.length; _i++) {
	          var pos = _a[_i];
	          totalFailures.push(failures[pos]);
	        }
	      };

	      return _this.clone().primaryKeys().then(function (keys) {
	        var nextChunk = function nextChunk(offset) {
	          var count = Math.min(limit, keys.length - offset);
	          return coreTable.getMany({
	            trans: trans,
	            keys: keys.slice(offset, offset + count),
	            cache: "immutable"
	          }).then(function (values) {
	            var addValues = [];
	            var putValues = [];
	            var putKeys = outbound ? [] : null;
	            var deleteKeys = [];

	            for (var i = 0; i < count; ++i) {
	              var origValue = values[i];
	              var ctx_1 = {
	                value: deepClone(origValue),
	                primKey: keys[offset + i]
	              };

	              if (modifyer.call(ctx_1, ctx_1.value, ctx_1) !== false) {
	                if (ctx_1.value == null) {
	                  deleteKeys.push(keys[offset + i]);
	                } else if (!outbound && cmp(extractKey(origValue), extractKey(ctx_1.value)) !== 0) {
	                  deleteKeys.push(keys[offset + i]);
	                  addValues.push(ctx_1.value);
	                } else {
	                  putValues.push(ctx_1.value);
	                  if (outbound) putKeys.push(keys[offset + i]);
	                }
	              }
	            }

	            var criteria = isPlainKeyRange(ctx) && ctx.limit === Infinity && (typeof changes !== 'function' || changes === deleteCallback) && {
	              index: ctx.index,
	              range: ctx.range
	            };
	            return Promise.resolve(addValues.length > 0 && coreTable.mutate({
	              trans: trans,
	              type: 'add',
	              values: addValues
	            }).then(function (res) {
	              for (var pos in res.failures) {
	                deleteKeys.splice(parseInt(pos), 1);
	              }

	              applyMutateResult(addValues.length, res);
	            })).then(function () {
	              return (putValues.length > 0 || criteria && babelHelpers["typeof"](changes) === 'object') && coreTable.mutate({
	                trans: trans,
	                type: 'put',
	                keys: putKeys,
	                values: putValues,
	                criteria: criteria,
	                changeSpec: typeof changes !== 'function' && changes
	              }).then(function (res) {
	                return applyMutateResult(putValues.length, res);
	              });
	            }).then(function () {
	              return (deleteKeys.length > 0 || criteria && changes === deleteCallback) && coreTable.mutate({
	                trans: trans,
	                type: 'delete',
	                keys: deleteKeys,
	                criteria: criteria
	              }).then(function (res) {
	                return applyMutateResult(deleteKeys.length, res);
	              });
	            }).then(function () {
	              return keys.length > offset + count && nextChunk(offset + limit);
	            });
	          });
	        };

	        return nextChunk(0).then(function () {
	          if (totalFailures.length > 0) throw new ModifyError("Error modifying one or more objects", totalFailures, successCount, failedKeys);
	          return keys.length;
	        });
	      });
	    });
	  };

	  Collection.prototype["delete"] = function () {
	    var ctx = this._ctx,
	        range = ctx.range;

	    if (isPlainKeyRange(ctx) && (ctx.isPrimKey && !hangsOnDeleteLargeKeyRange || range.type === 3)) {
	      return this._write(function (trans) {
	        var primaryKey = ctx.table.core.schema.primaryKey;
	        var coreRange = range;
	        return ctx.table.core.count({
	          trans: trans,
	          query: {
	            index: primaryKey,
	            range: coreRange
	          }
	        }).then(function (count) {
	          return ctx.table.core.mutate({
	            trans: trans,
	            type: 'deleteRange',
	            range: coreRange
	          }).then(function (_a) {
	            var failures = _a.failures;
	            _a.lastResult;
	            _a.results;
	            var numFailures = _a.numFailures;
	            if (numFailures) throw new ModifyError("Could not delete some values", Object.keys(failures).map(function (pos) {
	              return failures[pos];
	            }), count - numFailures);
	            return count - numFailures;
	          });
	        });
	      });
	    }

	    return this.modify(deleteCallback);
	  };

	  return Collection;
	}();

	var deleteCallback = function deleteCallback(value, ctx) {
	  return ctx.value = null;
	};

	function createCollectionConstructor(db) {
	  return makeClassConstructor(Collection.prototype, function Collection(whereClause, keyRangeGenerator) {
	    this.db = db;
	    var keyRange = AnyRange,
	        error = null;
	    if (keyRangeGenerator) try {
	      keyRange = keyRangeGenerator();
	    } catch (ex) {
	      error = ex;
	    }
	    var whereCtx = whereClause._ctx;
	    var table = whereCtx.table;
	    var readingHook = table.hook.reading.fire;
	    this._ctx = {
	      table: table,
	      index: whereCtx.index,
	      isPrimKey: !whereCtx.index || table.schema.primKey.keyPath && whereCtx.index === table.schema.primKey.name,
	      range: keyRange,
	      keysOnly: false,
	      dir: "next",
	      unique: "",
	      algorithm: null,
	      filter: null,
	      replayFilter: null,
	      justLimit: true,
	      isMatch: null,
	      offset: 0,
	      limit: Infinity,
	      error: error,
	      or: whereCtx.or,
	      valueMapper: readingHook !== mirror ? readingHook : null
	    };
	  });
	}

	function simpleCompare(a, b) {
	  return a < b ? -1 : a === b ? 0 : 1;
	}

	function simpleCompareReverse(a, b) {
	  return a > b ? -1 : a === b ? 0 : 1;
	}

	function fail(collectionOrWhereClause, err, T) {
	  var collection = collectionOrWhereClause instanceof WhereClause ? new collectionOrWhereClause.Collection(collectionOrWhereClause) : collectionOrWhereClause;
	  collection._ctx.error = T ? new T(err) : new TypeError(err);
	  return collection;
	}

	function emptyCollection(whereClause) {
	  return new whereClause.Collection(whereClause, function () {
	    return rangeEqual("");
	  }).limit(0);
	}

	function upperFactory(dir) {
	  return dir === "next" ? function (s) {
	    return s.toUpperCase();
	  } : function (s) {
	    return s.toLowerCase();
	  };
	}

	function lowerFactory(dir) {
	  return dir === "next" ? function (s) {
	    return s.toLowerCase();
	  } : function (s) {
	    return s.toUpperCase();
	  };
	}

	function nextCasing(key, lowerKey, upperNeedle, lowerNeedle, cmp, dir) {
	  var length = Math.min(key.length, lowerNeedle.length);
	  var llp = -1;

	  for (var i = 0; i < length; ++i) {
	    var lwrKeyChar = lowerKey[i];

	    if (lwrKeyChar !== lowerNeedle[i]) {
	      if (cmp(key[i], upperNeedle[i]) < 0) return key.substr(0, i) + upperNeedle[i] + upperNeedle.substr(i + 1);
	      if (cmp(key[i], lowerNeedle[i]) < 0) return key.substr(0, i) + lowerNeedle[i] + upperNeedle.substr(i + 1);
	      if (llp >= 0) return key.substr(0, llp) + lowerKey[llp] + upperNeedle.substr(llp + 1);
	      return null;
	    }

	    if (cmp(key[i], lwrKeyChar) < 0) llp = i;
	  }

	  if (length < lowerNeedle.length && dir === "next") return key + upperNeedle.substr(key.length);
	  if (length < key.length && dir === "prev") return key.substr(0, upperNeedle.length);
	  return llp < 0 ? null : key.substr(0, llp) + lowerNeedle[llp] + upperNeedle.substr(llp + 1);
	}

	function addIgnoreCaseAlgorithm(whereClause, match, needles, suffix) {
	  var upper,
	      lower,
	      compare,
	      upperNeedles,
	      lowerNeedles,
	      direction,
	      nextKeySuffix,
	      needlesLen = needles.length;

	  if (!needles.every(function (s) {
	    return typeof s === 'string';
	  })) {
	    return fail(whereClause, STRING_EXPECTED);
	  }

	  function initDirection(dir) {
	    upper = upperFactory(dir);
	    lower = lowerFactory(dir);
	    compare = dir === "next" ? simpleCompare : simpleCompareReverse;
	    var needleBounds = needles.map(function (needle) {
	      return {
	        lower: lower(needle),
	        upper: upper(needle)
	      };
	    }).sort(function (a, b) {
	      return compare(a.lower, b.lower);
	    });
	    upperNeedles = needleBounds.map(function (nb) {
	      return nb.upper;
	    });
	    lowerNeedles = needleBounds.map(function (nb) {
	      return nb.lower;
	    });
	    direction = dir;
	    nextKeySuffix = dir === "next" ? "" : suffix;
	  }

	  initDirection("next");
	  var c = new whereClause.Collection(whereClause, function () {
	    return createRange(upperNeedles[0], lowerNeedles[needlesLen - 1] + suffix);
	  });

	  c._ondirectionchange = function (direction) {
	    initDirection(direction);
	  };

	  var firstPossibleNeedle = 0;

	  c._addAlgorithm(function (cursor, advance, resolve) {
	    var key = cursor.key;
	    if (typeof key !== 'string') return false;
	    var lowerKey = lower(key);

	    if (match(lowerKey, lowerNeedles, firstPossibleNeedle)) {
	      return true;
	    } else {
	      var lowestPossibleCasing = null;

	      for (var i = firstPossibleNeedle; i < needlesLen; ++i) {
	        var casing = nextCasing(key, lowerKey, upperNeedles[i], lowerNeedles[i], compare, direction);
	        if (casing === null && lowestPossibleCasing === null) firstPossibleNeedle = i + 1;else if (lowestPossibleCasing === null || compare(lowestPossibleCasing, casing) > 0) {
	          lowestPossibleCasing = casing;
	        }
	      }

	      if (lowestPossibleCasing !== null) {
	        advance(function () {
	          cursor["continue"](lowestPossibleCasing + nextKeySuffix);
	        });
	      } else {
	        advance(resolve);
	      }

	      return false;
	    }
	  });

	  return c;
	}

	function createRange(lower, upper, lowerOpen, upperOpen) {
	  return {
	    type: 2,
	    lower: lower,
	    upper: upper,
	    lowerOpen: lowerOpen,
	    upperOpen: upperOpen
	  };
	}

	function rangeEqual(value) {
	  return {
	    type: 1,
	    lower: value,
	    upper: value
	  };
	}

	var WhereClause = function () {
	  function WhereClause() {}

	  Object.defineProperty(WhereClause.prototype, "Collection", {
	    get: function get() {
	      return this._ctx.table.db.Collection;
	    },
	    enumerable: false,
	    configurable: true
	  });

	  WhereClause.prototype.between = function (lower, upper, includeLower, includeUpper) {
	    includeLower = includeLower !== false;
	    includeUpper = includeUpper === true;

	    try {
	      if (this._cmp(lower, upper) > 0 || this._cmp(lower, upper) === 0 && (includeLower || includeUpper) && !(includeLower && includeUpper)) return emptyCollection(this);
	      return new this.Collection(this, function () {
	        return createRange(lower, upper, !includeLower, !includeUpper);
	      });
	    } catch (e) {
	      return fail(this, INVALID_KEY_ARGUMENT);
	    }
	  };

	  WhereClause.prototype.equals = function (value) {
	    if (value == null) return fail(this, INVALID_KEY_ARGUMENT);
	    return new this.Collection(this, function () {
	      return rangeEqual(value);
	    });
	  };

	  WhereClause.prototype.above = function (value) {
	    if (value == null) return fail(this, INVALID_KEY_ARGUMENT);
	    return new this.Collection(this, function () {
	      return createRange(value, undefined, true);
	    });
	  };

	  WhereClause.prototype.aboveOrEqual = function (value) {
	    if (value == null) return fail(this, INVALID_KEY_ARGUMENT);
	    return new this.Collection(this, function () {
	      return createRange(value, undefined, false);
	    });
	  };

	  WhereClause.prototype.below = function (value) {
	    if (value == null) return fail(this, INVALID_KEY_ARGUMENT);
	    return new this.Collection(this, function () {
	      return createRange(undefined, value, false, true);
	    });
	  };

	  WhereClause.prototype.belowOrEqual = function (value) {
	    if (value == null) return fail(this, INVALID_KEY_ARGUMENT);
	    return new this.Collection(this, function () {
	      return createRange(undefined, value);
	    });
	  };

	  WhereClause.prototype.startsWith = function (str) {
	    if (typeof str !== 'string') return fail(this, STRING_EXPECTED);
	    return this.between(str, str + maxString, true, true);
	  };

	  WhereClause.prototype.startsWithIgnoreCase = function (str) {
	    if (str === "") return this.startsWith(str);
	    return addIgnoreCaseAlgorithm(this, function (x, a) {
	      return x.indexOf(a[0]) === 0;
	    }, [str], maxString);
	  };

	  WhereClause.prototype.equalsIgnoreCase = function (str) {
	    return addIgnoreCaseAlgorithm(this, function (x, a) {
	      return x === a[0];
	    }, [str], "");
	  };

	  WhereClause.prototype.anyOfIgnoreCase = function () {
	    var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
	    if (set.length === 0) return emptyCollection(this);
	    return addIgnoreCaseAlgorithm(this, function (x, a) {
	      return a.indexOf(x) !== -1;
	    }, set, "");
	  };

	  WhereClause.prototype.startsWithAnyOfIgnoreCase = function () {
	    var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
	    if (set.length === 0) return emptyCollection(this);
	    return addIgnoreCaseAlgorithm(this, function (x, a) {
	      return a.some(function (n) {
	        return x.indexOf(n) === 0;
	      });
	    }, set, maxString);
	  };

	  WhereClause.prototype.anyOf = function () {
	    var _this = this;

	    var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
	    var compare = this._cmp;

	    try {
	      set.sort(compare);
	    } catch (e) {
	      return fail(this, INVALID_KEY_ARGUMENT);
	    }

	    if (set.length === 0) return emptyCollection(this);
	    var c = new this.Collection(this, function () {
	      return createRange(set[0], set[set.length - 1]);
	    });

	    c._ondirectionchange = function (direction) {
	      compare = direction === "next" ? _this._ascending : _this._descending;
	      set.sort(compare);
	    };

	    var i = 0;

	    c._addAlgorithm(function (cursor, advance, resolve) {
	      var key = cursor.key;

	      while (compare(key, set[i]) > 0) {
	        ++i;

	        if (i === set.length) {
	          advance(resolve);
	          return false;
	        }
	      }

	      if (compare(key, set[i]) === 0) {
	        return true;
	      } else {
	        advance(function () {
	          cursor["continue"](set[i]);
	        });
	        return false;
	      }
	    });

	    return c;
	  };

	  WhereClause.prototype.notEqual = function (value) {
	    return this.inAnyRange([[minKey, value], [value, this.db._maxKey]], {
	      includeLowers: false,
	      includeUppers: false
	    });
	  };

	  WhereClause.prototype.noneOf = function () {
	    var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
	    if (set.length === 0) return new this.Collection(this);

	    try {
	      set.sort(this._ascending);
	    } catch (e) {
	      return fail(this, INVALID_KEY_ARGUMENT);
	    }

	    var ranges = set.reduce(function (res, val) {
	      return res ? res.concat([[res[res.length - 1][1], val]]) : [[minKey, val]];
	    }, null);
	    ranges.push([set[set.length - 1], this.db._maxKey]);
	    return this.inAnyRange(ranges, {
	      includeLowers: false,
	      includeUppers: false
	    });
	  };

	  WhereClause.prototype.inAnyRange = function (ranges, options) {
	    var _this = this;

	    var cmp = this._cmp,
	        ascending = this._ascending,
	        descending = this._descending,
	        min = this._min,
	        max = this._max;
	    if (ranges.length === 0) return emptyCollection(this);

	    if (!ranges.every(function (range) {
	      return range[0] !== undefined && range[1] !== undefined && ascending(range[0], range[1]) <= 0;
	    })) {
	      return fail(this, "First argument to inAnyRange() must be an Array of two-value Arrays [lower,upper] where upper must not be lower than lower", exceptions.InvalidArgument);
	    }

	    var includeLowers = !options || options.includeLowers !== false;
	    var includeUppers = options && options.includeUppers === true;

	    function addRange(ranges, newRange) {
	      var i = 0,
	          l = ranges.length;

	      for (; i < l; ++i) {
	        var range = ranges[i];

	        if (cmp(newRange[0], range[1]) < 0 && cmp(newRange[1], range[0]) > 0) {
	          range[0] = min(range[0], newRange[0]);
	          range[1] = max(range[1], newRange[1]);
	          break;
	        }
	      }

	      if (i === l) ranges.push(newRange);
	      return ranges;
	    }

	    var sortDirection = ascending;

	    function rangeSorter(a, b) {
	      return sortDirection(a[0], b[0]);
	    }

	    var set;

	    try {
	      set = ranges.reduce(addRange, []);
	      set.sort(rangeSorter);
	    } catch (ex) {
	      return fail(this, INVALID_KEY_ARGUMENT);
	    }

	    var rangePos = 0;
	    var keyIsBeyondCurrentEntry = includeUppers ? function (key) {
	      return ascending(key, set[rangePos][1]) > 0;
	    } : function (key) {
	      return ascending(key, set[rangePos][1]) >= 0;
	    };
	    var keyIsBeforeCurrentEntry = includeLowers ? function (key) {
	      return descending(key, set[rangePos][0]) > 0;
	    } : function (key) {
	      return descending(key, set[rangePos][0]) >= 0;
	    };

	    function keyWithinCurrentRange(key) {
	      return !keyIsBeyondCurrentEntry(key) && !keyIsBeforeCurrentEntry(key);
	    }

	    var checkKey = keyIsBeyondCurrentEntry;
	    var c = new this.Collection(this, function () {
	      return createRange(set[0][0], set[set.length - 1][1], !includeLowers, !includeUppers);
	    });

	    c._ondirectionchange = function (direction) {
	      if (direction === "next") {
	        checkKey = keyIsBeyondCurrentEntry;
	        sortDirection = ascending;
	      } else {
	        checkKey = keyIsBeforeCurrentEntry;
	        sortDirection = descending;
	      }

	      set.sort(rangeSorter);
	    };

	    c._addAlgorithm(function (cursor, advance, resolve) {
	      var key = cursor.key;

	      while (checkKey(key)) {
	        ++rangePos;

	        if (rangePos === set.length) {
	          advance(resolve);
	          return false;
	        }
	      }

	      if (keyWithinCurrentRange(key)) {
	        return true;
	      } else if (_this._cmp(key, set[rangePos][1]) === 0 || _this._cmp(key, set[rangePos][0]) === 0) {
	        return false;
	      } else {
	        advance(function () {
	          if (sortDirection === ascending) cursor["continue"](set[rangePos][0]);else cursor["continue"](set[rangePos][1]);
	        });
	        return false;
	      }
	    });

	    return c;
	  };

	  WhereClause.prototype.startsWithAnyOf = function () {
	    var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);

	    if (!set.every(function (s) {
	      return typeof s === 'string';
	    })) {
	      return fail(this, "startsWithAnyOf() only works with strings");
	    }

	    if (set.length === 0) return emptyCollection(this);
	    return this.inAnyRange(set.map(function (str) {
	      return [str, str + maxString];
	    }));
	  };

	  return WhereClause;
	}();

	function createWhereClauseConstructor(db) {
	  return makeClassConstructor(WhereClause.prototype, function WhereClause(table, index, orCollection) {
	    this.db = db;
	    this._ctx = {
	      table: table,
	      index: index === ":id" ? null : index,
	      or: orCollection
	    };
	    var indexedDB = db._deps.indexedDB;
	    if (!indexedDB) throw new exceptions.MissingAPI();
	    this._cmp = this._ascending = indexedDB.cmp.bind(indexedDB);

	    this._descending = function (a, b) {
	      return indexedDB.cmp(b, a);
	    };

	    this._max = function (a, b) {
	      return indexedDB.cmp(a, b) > 0 ? a : b;
	    };

	    this._min = function (a, b) {
	      return indexedDB.cmp(a, b) < 0 ? a : b;
	    };

	    this._IDBKeyRange = db._deps.IDBKeyRange;
	  });
	}

	function eventRejectHandler(reject) {
	  return wrap(function (event) {
	    preventDefault(event);
	    reject(event.target.error);
	    return false;
	  });
	}

	function preventDefault(event) {
	  if (event.stopPropagation) event.stopPropagation();
	  if (event.preventDefault) event.preventDefault();
	}

	var DEXIE_STORAGE_MUTATED_EVENT_NAME = 'storagemutated';
	var STORAGE_MUTATED_DOM_EVENT_NAME = 'x-storagemutated-1';
	var globalEvents = Events(null, DEXIE_STORAGE_MUTATED_EVENT_NAME);

	var Transaction = function () {
	  function Transaction() {}

	  Transaction.prototype._lock = function () {
	    assert(!PSD.global);
	    ++this._reculock;
	    if (this._reculock === 1 && !PSD.global) PSD.lockOwnerFor = this;
	    return this;
	  };

	  Transaction.prototype._unlock = function () {
	    assert(!PSD.global);

	    if (--this._reculock === 0) {
	      if (!PSD.global) PSD.lockOwnerFor = null;

	      while (this._blockedFuncs.length > 0 && !this._locked()) {
	        var fnAndPSD = this._blockedFuncs.shift();

	        try {
	          usePSD(fnAndPSD[1], fnAndPSD[0]);
	        } catch (e) {}
	      }
	    }

	    return this;
	  };

	  Transaction.prototype._locked = function () {
	    return this._reculock && PSD.lockOwnerFor !== this;
	  };

	  Transaction.prototype.create = function (idbtrans) {
	    var _this = this;

	    if (!this.mode) return this;
	    var idbdb = this.db.idbdb;
	    var dbOpenError = this.db._state.dbOpenError;
	    assert(!this.idbtrans);

	    if (!idbtrans && !idbdb) {
	      switch (dbOpenError && dbOpenError.name) {
	        case "DatabaseClosedError":
	          throw new exceptions.DatabaseClosed(dbOpenError);

	        case "MissingAPIError":
	          throw new exceptions.MissingAPI(dbOpenError.message, dbOpenError);

	        default:
	          throw new exceptions.OpenFailed(dbOpenError);
	      }
	    }

	    if (!this.active) throw new exceptions.TransactionInactive();
	    assert(this._completion._state === null);
	    idbtrans = this.idbtrans = idbtrans || (this.db.core ? this.db.core.transaction(this.storeNames, this.mode, {
	      durability: this.chromeTransactionDurability
	    }) : idbdb.transaction(this.storeNames, this.mode, {
	      durability: this.chromeTransactionDurability
	    }));
	    idbtrans.onerror = wrap(function (ev) {
	      preventDefault(ev);

	      _this._reject(idbtrans.error);
	    });
	    idbtrans.onabort = wrap(function (ev) {
	      preventDefault(ev);
	      _this.active && _this._reject(new exceptions.Abort(idbtrans.error));
	      _this.active = false;

	      _this.on("abort").fire(ev);
	    });
	    idbtrans.oncomplete = wrap(function () {
	      _this.active = false;

	      _this._resolve();

	      if ('mutatedParts' in idbtrans) {
	        globalEvents.storagemutated.fire(idbtrans["mutatedParts"]);
	      }
	    });
	    return this;
	  };

	  Transaction.prototype._promise = function (mode, fn, bWriteLock) {
	    var _this = this;

	    if (mode === 'readwrite' && this.mode !== 'readwrite') return rejection(new exceptions.ReadOnly("Transaction is readonly"));
	    if (!this.active) return rejection(new exceptions.TransactionInactive());

	    if (this._locked()) {
	      return new DexiePromise(function (resolve, reject) {
	        _this._blockedFuncs.push([function () {
	          _this._promise(mode, fn, bWriteLock).then(resolve, reject);
	        }, PSD]);
	      });
	    } else if (bWriteLock) {
	      return newScope(function () {
	        var p = new DexiePromise(function (resolve, reject) {
	          _this._lock();

	          var rv = fn(resolve, reject, _this);
	          if (rv && rv.then) rv.then(resolve, reject);
	        });
	        p["finally"](function () {
	          return _this._unlock();
	        });
	        p._lib = true;
	        return p;
	      });
	    } else {
	      var p = new DexiePromise(function (resolve, reject) {
	        var rv = fn(resolve, reject, _this);
	        if (rv && rv.then) rv.then(resolve, reject);
	      });
	      p._lib = true;
	      return p;
	    }
	  };

	  Transaction.prototype._root = function () {
	    return this.parent ? this.parent._root() : this;
	  };

	  Transaction.prototype.waitFor = function (promiseLike) {
	    var root = this._root();

	    var promise = DexiePromise.resolve(promiseLike);

	    if (root._waitingFor) {
	      root._waitingFor = root._waitingFor.then(function () {
	        return promise;
	      });
	    } else {
	      root._waitingFor = promise;
	      root._waitingQueue = [];
	      var store = root.idbtrans.objectStore(root.storeNames[0]);

	      (function spin() {
	        ++root._spinCount;

	        while (root._waitingQueue.length) {
	          root._waitingQueue.shift()();
	        }

	        if (root._waitingFor) store.get(-Infinity).onsuccess = spin;
	      })();
	    }

	    var currentWaitPromise = root._waitingFor;
	    return new DexiePromise(function (resolve, reject) {
	      promise.then(function (res) {
	        return root._waitingQueue.push(wrap(resolve.bind(null, res)));
	      }, function (err) {
	        return root._waitingQueue.push(wrap(reject.bind(null, err)));
	      })["finally"](function () {
	        if (root._waitingFor === currentWaitPromise) {
	          root._waitingFor = null;
	        }
	      });
	    });
	  };

	  Transaction.prototype.abort = function () {
	    if (this.active) {
	      this.active = false;
	      if (this.idbtrans) this.idbtrans.abort();

	      this._reject(new exceptions.Abort());
	    }
	  };

	  Transaction.prototype.table = function (tableName) {
	    var memoizedTables = this._memoizedTables || (this._memoizedTables = {});
	    if (hasOwn(memoizedTables, tableName)) return memoizedTables[tableName];
	    var tableSchema = this.schema[tableName];

	    if (!tableSchema) {
	      throw new exceptions.NotFound("Table " + tableName + " not part of transaction");
	    }

	    var transactionBoundTable = new this.db.Table(tableName, tableSchema, this);
	    transactionBoundTable.core = this.db.core.table(tableName);
	    memoizedTables[tableName] = transactionBoundTable;
	    return transactionBoundTable;
	  };

	  return Transaction;
	}();

	function createTransactionConstructor(db) {
	  return makeClassConstructor(Transaction.prototype, function Transaction(mode, storeNames, dbschema, chromeTransactionDurability, parent) {
	    var _this = this;

	    this.db = db;
	    this.mode = mode;
	    this.storeNames = storeNames;
	    this.schema = dbschema;
	    this.chromeTransactionDurability = chromeTransactionDurability;
	    this.idbtrans = null;
	    this.on = Events(this, "complete", "error", "abort");
	    this.parent = parent || null;
	    this.active = true;
	    this._reculock = 0;
	    this._blockedFuncs = [];
	    this._resolve = null;
	    this._reject = null;
	    this._waitingFor = null;
	    this._waitingQueue = null;
	    this._spinCount = 0;
	    this._completion = new DexiePromise(function (resolve, reject) {
	      _this._resolve = resolve;
	      _this._reject = reject;
	    });

	    this._completion.then(function () {
	      _this.active = false;

	      _this.on.complete.fire();
	    }, function (e) {
	      var wasActive = _this.active;
	      _this.active = false;

	      _this.on.error.fire(e);

	      _this.parent ? _this.parent._reject(e) : wasActive && _this.idbtrans && _this.idbtrans.abort();
	      return rejection(e);
	    });
	  });
	}

	function createIndexSpec(name, keyPath, unique, multi, auto, compound, isPrimKey) {
	  return {
	    name: name,
	    keyPath: keyPath,
	    unique: unique,
	    multi: multi,
	    auto: auto,
	    compound: compound,
	    src: (unique && !isPrimKey ? '&' : '') + (multi ? '*' : '') + (auto ? "++" : "") + nameFromKeyPath(keyPath)
	  };
	}

	function nameFromKeyPath(keyPath) {
	  return typeof keyPath === 'string' ? keyPath : keyPath ? '[' + [].join.call(keyPath, '+') + ']' : "";
	}

	function createTableSchema(name, primKey, indexes) {
	  return {
	    name: name,
	    primKey: primKey,
	    indexes: indexes,
	    mappedClass: null,
	    idxByName: arrayToObject(indexes, function (index) {
	      return [index.name, index];
	    })
	  };
	}

	function safariMultiStoreFix(storeNames) {
	  return storeNames.length === 1 ? storeNames[0] : storeNames;
	}

	var _getMaxKey = function getMaxKey(IdbKeyRange) {
	  try {
	    IdbKeyRange.only([[]]);

	    _getMaxKey = function getMaxKey() {
	      return [[]];
	    };

	    return [[]];
	  } catch (e) {
	    _getMaxKey = function getMaxKey() {
	      return maxString;
	    };

	    return maxString;
	  }
	};

	function getKeyExtractor(keyPath) {
	  if (keyPath == null) {
	    return function () {
	      return undefined;
	    };
	  } else if (typeof keyPath === 'string') {
	    return getSinglePathKeyExtractor(keyPath);
	  } else {
	    return function (obj) {
	      return getByKeyPath(obj, keyPath);
	    };
	  }
	}

	function getSinglePathKeyExtractor(keyPath) {
	  var split = keyPath.split('.');

	  if (split.length === 1) {
	    return function (obj) {
	      return obj[keyPath];
	    };
	  } else {
	    return function (obj) {
	      return getByKeyPath(obj, keyPath);
	    };
	  }
	}

	function arrayify(arrayLike) {
	  return [].slice.call(arrayLike);
	}

	var _id_counter = 0;

	function getKeyPathAlias(keyPath) {
	  return keyPath == null ? ":id" : typeof keyPath === 'string' ? keyPath : "[" + keyPath.join('+') + "]";
	}

	function createDBCore(db, IdbKeyRange, tmpTrans) {
	  function extractSchema(db, trans) {
	    var tables = arrayify(db.objectStoreNames);
	    return {
	      schema: {
	        name: db.name,
	        tables: tables.map(function (table) {
	          return trans.objectStore(table);
	        }).map(function (store) {
	          var keyPath = store.keyPath,
	              autoIncrement = store.autoIncrement;
	          var compound = isArray(keyPath);
	          var outbound = keyPath == null;
	          var indexByKeyPath = {};
	          var result = {
	            name: store.name,
	            primaryKey: {
	              name: null,
	              isPrimaryKey: true,
	              outbound: outbound,
	              compound: compound,
	              keyPath: keyPath,
	              autoIncrement: autoIncrement,
	              unique: true,
	              extractKey: getKeyExtractor(keyPath)
	            },
	            indexes: arrayify(store.indexNames).map(function (indexName) {
	              return store.index(indexName);
	            }).map(function (index) {
	              var name = index.name,
	                  unique = index.unique,
	                  multiEntry = index.multiEntry,
	                  keyPath = index.keyPath;
	              var compound = isArray(keyPath);
	              var result = {
	                name: name,
	                compound: compound,
	                keyPath: keyPath,
	                unique: unique,
	                multiEntry: multiEntry,
	                extractKey: getKeyExtractor(keyPath)
	              };
	              indexByKeyPath[getKeyPathAlias(keyPath)] = result;
	              return result;
	            }),
	            getIndexByKeyPath: function getIndexByKeyPath(keyPath) {
	              return indexByKeyPath[getKeyPathAlias(keyPath)];
	            }
	          };
	          indexByKeyPath[":id"] = result.primaryKey;

	          if (keyPath != null) {
	            indexByKeyPath[getKeyPathAlias(keyPath)] = result.primaryKey;
	          }

	          return result;
	        })
	      },
	      hasGetAll: tables.length > 0 && 'getAll' in trans.objectStore(tables[0]) && !(typeof navigator !== 'undefined' && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604)
	    };
	  }

	  function makeIDBKeyRange(range) {
	    if (range.type === 3) return null;
	    if (range.type === 4) throw new Error("Cannot convert never type to IDBKeyRange");
	    var lower = range.lower,
	        upper = range.upper,
	        lowerOpen = range.lowerOpen,
	        upperOpen = range.upperOpen;
	    var idbRange = lower === undefined ? upper === undefined ? null : IdbKeyRange.upperBound(upper, !!upperOpen) : upper === undefined ? IdbKeyRange.lowerBound(lower, !!lowerOpen) : IdbKeyRange.bound(lower, upper, !!lowerOpen, !!upperOpen);
	    return idbRange;
	  }

	  function createDbCoreTable(tableSchema) {
	    var tableName = tableSchema.name;

	    function mutate(_a) {
	      var trans = _a.trans,
	          type = _a.type,
	          keys = _a.keys,
	          values = _a.values,
	          range = _a.range;
	      return new Promise(function (resolve, reject) {
	        resolve = wrap(resolve);
	        var store = trans.objectStore(tableName);
	        var outbound = store.keyPath == null;
	        var isAddOrPut = type === "put" || type === "add";
	        if (!isAddOrPut && type !== 'delete' && type !== 'deleteRange') throw new Error("Invalid operation type: " + type);
	        var length = (keys || values || {
	          length: 1
	        }).length;

	        if (keys && values && keys.length !== values.length) {
	          throw new Error("Given keys array must have same length as given values array.");
	        }

	        if (length === 0) return resolve({
	          numFailures: 0,
	          failures: {},
	          results: [],
	          lastResult: undefined
	        });
	        var req;
	        var reqs = [];
	        var failures = [];
	        var numFailures = 0;

	        var errorHandler = function errorHandler(event) {
	          ++numFailures;
	          preventDefault(event);
	        };

	        if (type === 'deleteRange') {
	          if (range.type === 4) return resolve({
	            numFailures: numFailures,
	            failures: failures,
	            results: [],
	            lastResult: undefined
	          });
	          if (range.type === 3) reqs.push(req = store.clear());else reqs.push(req = store["delete"](makeIDBKeyRange(range)));
	        } else {
	          var _a = isAddOrPut ? outbound ? [values, keys] : [values, null] : [keys, null],
	              args1 = _a[0],
	              args2 = _a[1];

	          if (isAddOrPut) {
	            for (var i = 0; i < length; ++i) {
	              reqs.push(req = args2 && args2[i] !== undefined ? store[type](args1[i], args2[i]) : store[type](args1[i]));
	              req.onerror = errorHandler;
	            }
	          } else {
	            for (var i = 0; i < length; ++i) {
	              reqs.push(req = store[type](args1[i]));
	              req.onerror = errorHandler;
	            }
	          }
	        }

	        var done = function done(event) {
	          var lastResult = event.target.result;
	          reqs.forEach(function (req, i) {
	            return req.error != null && (failures[i] = req.error);
	          });
	          resolve({
	            numFailures: numFailures,
	            failures: failures,
	            results: type === "delete" ? keys : reqs.map(function (req) {
	              return req.result;
	            }),
	            lastResult: lastResult
	          });
	        };

	        req.onerror = function (event) {
	          errorHandler(event);
	          done(event);
	        };

	        req.onsuccess = done;
	      });
	    }

	    function openCursor(_a) {
	      var trans = _a.trans,
	          values = _a.values,
	          query = _a.query,
	          reverse = _a.reverse,
	          unique = _a.unique;
	      return new Promise(function (resolve, reject) {
	        resolve = wrap(resolve);
	        var index = query.index,
	            range = query.range;
	        var store = trans.objectStore(tableName);
	        var source = index.isPrimaryKey ? store : store.index(index.name);
	        var direction = reverse ? unique ? "prevunique" : "prev" : unique ? "nextunique" : "next";
	        var req = values || !('openKeyCursor' in source) ? source.openCursor(makeIDBKeyRange(range), direction) : source.openKeyCursor(makeIDBKeyRange(range), direction);
	        req.onerror = eventRejectHandler(reject);
	        req.onsuccess = wrap(function (ev) {
	          var cursor = req.result;

	          if (!cursor) {
	            resolve(null);
	            return;
	          }

	          cursor.___id = ++_id_counter;
	          cursor.done = false;

	          var _cursorContinue = cursor["continue"].bind(cursor);

	          var _cursorContinuePrimaryKey = cursor.continuePrimaryKey;
	          if (_cursorContinuePrimaryKey) _cursorContinuePrimaryKey = _cursorContinuePrimaryKey.bind(cursor);

	          var _cursorAdvance = cursor.advance.bind(cursor);

	          var doThrowCursorIsNotStarted = function doThrowCursorIsNotStarted() {
	            throw new Error("Cursor not started");
	          };

	          var doThrowCursorIsStopped = function doThrowCursorIsStopped() {
	            throw new Error("Cursor not stopped");
	          };

	          cursor.trans = trans;
	          cursor.stop = cursor["continue"] = cursor.continuePrimaryKey = cursor.advance = doThrowCursorIsNotStarted;
	          cursor.fail = wrap(reject);

	          cursor.next = function () {
	            var _this = this;

	            var gotOne = 1;
	            return this.start(function () {
	              return gotOne-- ? _this["continue"]() : _this.stop();
	            }).then(function () {
	              return _this;
	            });
	          };

	          cursor.start = function (callback) {
	            var iterationPromise = new Promise(function (resolveIteration, rejectIteration) {
	              resolveIteration = wrap(resolveIteration);
	              req.onerror = eventRejectHandler(rejectIteration);
	              cursor.fail = rejectIteration;

	              cursor.stop = function (value) {
	                cursor.stop = cursor["continue"] = cursor.continuePrimaryKey = cursor.advance = doThrowCursorIsStopped;
	                resolveIteration(value);
	              };
	            });

	            var guardedCallback = function guardedCallback() {
	              if (req.result) {
	                try {
	                  callback();
	                } catch (err) {
	                  cursor.fail(err);
	                }
	              } else {
	                cursor.done = true;

	                cursor.start = function () {
	                  throw new Error("Cursor behind last entry");
	                };

	                cursor.stop();
	              }
	            };

	            req.onsuccess = wrap(function (ev) {
	              req.onsuccess = guardedCallback;
	              guardedCallback();
	            });
	            cursor["continue"] = _cursorContinue;
	            cursor.continuePrimaryKey = _cursorContinuePrimaryKey;
	            cursor.advance = _cursorAdvance;
	            guardedCallback();
	            return iterationPromise;
	          };

	          resolve(cursor);
	        }, reject);
	      });
	    }

	    function query(hasGetAll) {
	      return function (request) {
	        return new Promise(function (resolve, reject) {
	          resolve = wrap(resolve);
	          var trans = request.trans,
	              values = request.values,
	              limit = request.limit,
	              query = request.query;
	          var nonInfinitLimit = limit === Infinity ? undefined : limit;
	          var index = query.index,
	              range = query.range;
	          var store = trans.objectStore(tableName);
	          var source = index.isPrimaryKey ? store : store.index(index.name);
	          var idbKeyRange = makeIDBKeyRange(range);
	          if (limit === 0) return resolve({
	            result: []
	          });

	          if (hasGetAll) {
	            var req = values ? source.getAll(idbKeyRange, nonInfinitLimit) : source.getAllKeys(idbKeyRange, nonInfinitLimit);

	            req.onsuccess = function (event) {
	              return resolve({
	                result: event.target.result
	              });
	            };

	            req.onerror = eventRejectHandler(reject);
	          } else {
	            var count_1 = 0;
	            var req_1 = values || !('openKeyCursor' in source) ? source.openCursor(idbKeyRange) : source.openKeyCursor(idbKeyRange);
	            var result_1 = [];

	            req_1.onsuccess = function (event) {
	              var cursor = req_1.result;
	              if (!cursor) return resolve({
	                result: result_1
	              });
	              result_1.push(values ? cursor.value : cursor.primaryKey);
	              if (++count_1 === limit) return resolve({
	                result: result_1
	              });
	              cursor["continue"]();
	            };

	            req_1.onerror = eventRejectHandler(reject);
	          }
	        });
	      };
	    }

	    return {
	      name: tableName,
	      schema: tableSchema,
	      mutate: mutate,
	      getMany: function getMany(_a) {
	        var trans = _a.trans,
	            keys = _a.keys;
	        return new Promise(function (resolve, reject) {
	          resolve = wrap(resolve);
	          var store = trans.objectStore(tableName);
	          var length = keys.length;
	          var result = new Array(length);
	          var keyCount = 0;
	          var callbackCount = 0;
	          var req;

	          var successHandler = function successHandler(event) {
	            var req = event.target;
	            if ((result[req._pos] = req.result) != null) ;
	            if (++callbackCount === keyCount) resolve(result);
	          };

	          var errorHandler = eventRejectHandler(reject);

	          for (var i = 0; i < length; ++i) {
	            var key = keys[i];

	            if (key != null) {
	              req = store.get(keys[i]);
	              req._pos = i;
	              req.onsuccess = successHandler;
	              req.onerror = errorHandler;
	              ++keyCount;
	            }
	          }

	          if (keyCount === 0) resolve(result);
	        });
	      },
	      get: function get(_a) {
	        var trans = _a.trans,
	            key = _a.key;
	        return new Promise(function (resolve, reject) {
	          resolve = wrap(resolve);
	          var store = trans.objectStore(tableName);
	          var req = store.get(key);

	          req.onsuccess = function (event) {
	            return resolve(event.target.result);
	          };

	          req.onerror = eventRejectHandler(reject);
	        });
	      },
	      query: query(hasGetAll),
	      openCursor: openCursor,
	      count: function count(_a) {
	        var query = _a.query,
	            trans = _a.trans;
	        var index = query.index,
	            range = query.range;
	        return new Promise(function (resolve, reject) {
	          var store = trans.objectStore(tableName);
	          var source = index.isPrimaryKey ? store : store.index(index.name);
	          var idbKeyRange = makeIDBKeyRange(range);
	          var req = idbKeyRange ? source.count(idbKeyRange) : source.count();
	          req.onsuccess = wrap(function (ev) {
	            return resolve(ev.target.result);
	          });
	          req.onerror = eventRejectHandler(reject);
	        });
	      }
	    };
	  }

	  var _a = extractSchema(db, tmpTrans),
	      schema = _a.schema,
	      hasGetAll = _a.hasGetAll;

	  var tables = schema.tables.map(function (tableSchema) {
	    return createDbCoreTable(tableSchema);
	  });
	  var tableMap = {};
	  tables.forEach(function (table) {
	    return tableMap[table.name] = table;
	  });
	  return {
	    stack: "dbcore",
	    transaction: db.transaction.bind(db),
	    table: function table(name) {
	      var result = tableMap[name];
	      if (!result) throw new Error("Table '" + name + "' not found");
	      return tableMap[name];
	    },
	    MIN_KEY: -Infinity,
	    MAX_KEY: _getMaxKey(IdbKeyRange),
	    schema: schema
	  };
	}

	function createMiddlewareStack(stackImpl, middlewares) {
	  return middlewares.reduce(function (down, _a) {
	    var create = _a.create;
	    return _assign(_assign({}, down), create(down));
	  }, stackImpl);
	}

	function createMiddlewareStacks(middlewares, idbdb, _a, tmpTrans) {
	  var IDBKeyRange = _a.IDBKeyRange;
	  _a.indexedDB;
	  var dbcore = createMiddlewareStack(createDBCore(idbdb, IDBKeyRange, tmpTrans), middlewares.dbcore);
	  return {
	    dbcore: dbcore
	  };
	}

	function generateMiddlewareStacks(_a, tmpTrans) {
	  var db = _a._novip;
	  var idbdb = tmpTrans.db;
	  var stacks = createMiddlewareStacks(db._middlewares, idbdb, db._deps, tmpTrans);
	  db.core = stacks.dbcore;
	  db.tables.forEach(function (table) {
	    var tableName = table.name;

	    if (db.core.schema.tables.some(function (tbl) {
	      return tbl.name === tableName;
	    })) {
	      table.core = db.core.table(tableName);

	      if (db[tableName] instanceof db.Table) {
	        db[tableName].core = table.core;
	      }
	    }
	  });
	}

	function setApiOnPlace(_a, objs, tableNames, dbschema) {
	  var db = _a._novip;
	  tableNames.forEach(function (tableName) {
	    var schema = dbschema[tableName];
	    objs.forEach(function (obj) {
	      var propDesc = getPropertyDescriptor(obj, tableName);

	      if (!propDesc || "value" in propDesc && propDesc.value === undefined) {
	        if (obj === db.Transaction.prototype || obj instanceof db.Transaction) {
	          setProp(obj, tableName, {
	            get: function get() {
	              return this.table(tableName);
	            },
	            set: function set(value) {
	              defineProperty(this, tableName, {
	                value: value,
	                writable: true,
	                configurable: true,
	                enumerable: true
	              });
	            }
	          });
	        } else {
	          obj[tableName] = new db.Table(tableName, schema);
	        }
	      }
	    });
	  });
	}

	function removeTablesApi(_a, objs) {
	  var db = _a._novip;
	  objs.forEach(function (obj) {
	    for (var key in obj) {
	      if (obj[key] instanceof db.Table) delete obj[key];
	    }
	  });
	}

	function lowerVersionFirst(a, b) {
	  return a._cfg.version - b._cfg.version;
	}

	function runUpgraders(db, oldVersion, idbUpgradeTrans, reject) {
	  var globalSchema = db._dbSchema;

	  var trans = db._createTransaction('readwrite', db._storeNames, globalSchema);

	  trans.create(idbUpgradeTrans);

	  trans._completion["catch"](reject);

	  var rejectTransaction = trans._reject.bind(trans);

	  var transless = PSD.transless || PSD;
	  newScope(function () {
	    PSD.trans = trans;
	    PSD.transless = transless;

	    if (oldVersion === 0) {
	      keys(globalSchema).forEach(function (tableName) {
	        createTable(idbUpgradeTrans, tableName, globalSchema[tableName].primKey, globalSchema[tableName].indexes);
	      });
	      generateMiddlewareStacks(db, idbUpgradeTrans);
	      DexiePromise.follow(function () {
	        return db.on.populate.fire(trans);
	      })["catch"](rejectTransaction);
	    } else updateTablesAndIndexes(db, oldVersion, trans, idbUpgradeTrans)["catch"](rejectTransaction);
	  });
	}

	function updateTablesAndIndexes(_a, oldVersion, trans, idbUpgradeTrans) {
	  var db = _a._novip;
	  var queue = [];
	  var versions = db._versions;
	  var globalSchema = db._dbSchema = buildGlobalSchema(db, db.idbdb, idbUpgradeTrans);
	  var anyContentUpgraderHasRun = false;
	  var versToRun = versions.filter(function (v) {
	    return v._cfg.version >= oldVersion;
	  });
	  versToRun.forEach(function (version) {
	    queue.push(function () {
	      var oldSchema = globalSchema;
	      var newSchema = version._cfg.dbschema;
	      adjustToExistingIndexNames(db, oldSchema, idbUpgradeTrans);
	      adjustToExistingIndexNames(db, newSchema, idbUpgradeTrans);
	      globalSchema = db._dbSchema = newSchema;
	      var diff = getSchemaDiff(oldSchema, newSchema);
	      diff.add.forEach(function (tuple) {
	        createTable(idbUpgradeTrans, tuple[0], tuple[1].primKey, tuple[1].indexes);
	      });
	      diff.change.forEach(function (change) {
	        if (change.recreate) {
	          throw new exceptions.Upgrade("Not yet support for changing primary key");
	        } else {
	          var store_1 = idbUpgradeTrans.objectStore(change.name);
	          change.add.forEach(function (idx) {
	            return addIndex(store_1, idx);
	          });
	          change.change.forEach(function (idx) {
	            store_1.deleteIndex(idx.name);
	            addIndex(store_1, idx);
	          });
	          change.del.forEach(function (idxName) {
	            return store_1.deleteIndex(idxName);
	          });
	        }
	      });
	      var contentUpgrade = version._cfg.contentUpgrade;

	      if (contentUpgrade && version._cfg.version > oldVersion) {
	        generateMiddlewareStacks(db, idbUpgradeTrans);
	        trans._memoizedTables = {};
	        anyContentUpgraderHasRun = true;
	        var upgradeSchema_1 = shallowClone(newSchema);
	        diff.del.forEach(function (table) {
	          upgradeSchema_1[table] = oldSchema[table];
	        });
	        removeTablesApi(db, [db.Transaction.prototype]);
	        setApiOnPlace(db, [db.Transaction.prototype], keys(upgradeSchema_1), upgradeSchema_1);
	        trans.schema = upgradeSchema_1;
	        var contentUpgradeIsAsync_1 = isAsyncFunction(contentUpgrade);

	        if (contentUpgradeIsAsync_1) {
	          incrementExpectedAwaits();
	        }

	        var returnValue_1;
	        var promiseFollowed = DexiePromise.follow(function () {
	          returnValue_1 = contentUpgrade(trans);

	          if (returnValue_1) {
	            if (contentUpgradeIsAsync_1) {
	              var decrementor = decrementExpectedAwaits.bind(null, null);
	              returnValue_1.then(decrementor, decrementor);
	            }
	          }
	        });
	        return returnValue_1 && typeof returnValue_1.then === 'function' ? DexiePromise.resolve(returnValue_1) : promiseFollowed.then(function () {
	          return returnValue_1;
	        });
	      }
	    });
	    queue.push(function (idbtrans) {
	      if (!anyContentUpgraderHasRun || !hasIEDeleteObjectStoreBug) {
	        var newSchema = version._cfg.dbschema;
	        deleteRemovedTables(newSchema, idbtrans);
	      }

	      removeTablesApi(db, [db.Transaction.prototype]);
	      setApiOnPlace(db, [db.Transaction.prototype], db._storeNames, db._dbSchema);
	      trans.schema = db._dbSchema;
	    });
	  });

	  function runQueue() {
	    return queue.length ? DexiePromise.resolve(queue.shift()(trans.idbtrans)).then(runQueue) : DexiePromise.resolve();
	  }

	  return runQueue().then(function () {
	    createMissingTables(globalSchema, idbUpgradeTrans);
	  });
	}

	function getSchemaDiff(oldSchema, newSchema) {
	  var diff = {
	    del: [],
	    add: [],
	    change: []
	  };
	  var table;

	  for (table in oldSchema) {
	    if (!newSchema[table]) diff.del.push(table);
	  }

	  for (table in newSchema) {
	    var oldDef = oldSchema[table],
	        newDef = newSchema[table];

	    if (!oldDef) {
	      diff.add.push([table, newDef]);
	    } else {
	      var change = {
	        name: table,
	        def: newDef,
	        recreate: false,
	        del: [],
	        add: [],
	        change: []
	      };

	      if ('' + (oldDef.primKey.keyPath || '') !== '' + (newDef.primKey.keyPath || '') || oldDef.primKey.auto !== newDef.primKey.auto && !isIEOrEdge) {
	        change.recreate = true;
	        diff.change.push(change);
	      } else {
	        var oldIndexes = oldDef.idxByName;
	        var newIndexes = newDef.idxByName;
	        var idxName = void 0;

	        for (idxName in oldIndexes) {
	          if (!newIndexes[idxName]) change.del.push(idxName);
	        }

	        for (idxName in newIndexes) {
	          var oldIdx = oldIndexes[idxName],
	              newIdx = newIndexes[idxName];
	          if (!oldIdx) change.add.push(newIdx);else if (oldIdx.src !== newIdx.src) change.change.push(newIdx);
	        }

	        if (change.del.length > 0 || change.add.length > 0 || change.change.length > 0) {
	          diff.change.push(change);
	        }
	      }
	    }
	  }

	  return diff;
	}

	function createTable(idbtrans, tableName, primKey, indexes) {
	  var store = idbtrans.db.createObjectStore(tableName, primKey.keyPath ? {
	    keyPath: primKey.keyPath,
	    autoIncrement: primKey.auto
	  } : {
	    autoIncrement: primKey.auto
	  });
	  indexes.forEach(function (idx) {
	    return addIndex(store, idx);
	  });
	  return store;
	}

	function createMissingTables(newSchema, idbtrans) {
	  keys(newSchema).forEach(function (tableName) {
	    if (!idbtrans.db.objectStoreNames.contains(tableName)) {
	      createTable(idbtrans, tableName, newSchema[tableName].primKey, newSchema[tableName].indexes);
	    }
	  });
	}

	function deleteRemovedTables(newSchema, idbtrans) {
	  [].slice.call(idbtrans.db.objectStoreNames).forEach(function (storeName) {
	    return newSchema[storeName] == null && idbtrans.db.deleteObjectStore(storeName);
	  });
	}

	function addIndex(store, idx) {
	  store.createIndex(idx.name, idx.keyPath, {
	    unique: idx.unique,
	    multiEntry: idx.multi
	  });
	}

	function buildGlobalSchema(db, idbdb, tmpTrans) {
	  var globalSchema = {};
	  var dbStoreNames = slice(idbdb.objectStoreNames, 0);
	  dbStoreNames.forEach(function (storeName) {
	    var store = tmpTrans.objectStore(storeName);
	    var keyPath = store.keyPath;
	    var primKey = createIndexSpec(nameFromKeyPath(keyPath), keyPath || "", false, false, !!store.autoIncrement, keyPath && typeof keyPath !== "string", true);
	    var indexes = [];

	    for (var j = 0; j < store.indexNames.length; ++j) {
	      var idbindex = store.index(store.indexNames[j]);
	      keyPath = idbindex.keyPath;
	      var index = createIndexSpec(idbindex.name, keyPath, !!idbindex.unique, !!idbindex.multiEntry, false, keyPath && typeof keyPath !== "string", false);
	      indexes.push(index);
	    }

	    globalSchema[storeName] = createTableSchema(storeName, primKey, indexes);
	  });
	  return globalSchema;
	}

	function readGlobalSchema(_a, idbdb, tmpTrans) {
	  var db = _a._novip;
	  db.verno = idbdb.version / 10;
	  var globalSchema = db._dbSchema = buildGlobalSchema(db, idbdb, tmpTrans);
	  db._storeNames = slice(idbdb.objectStoreNames, 0);
	  setApiOnPlace(db, [db._allTables], keys(globalSchema), globalSchema);
	}

	function verifyInstalledSchema(db, tmpTrans) {
	  var installedSchema = buildGlobalSchema(db, db.idbdb, tmpTrans);
	  var diff = getSchemaDiff(installedSchema, db._dbSchema);
	  return !(diff.add.length || diff.change.some(function (ch) {
	    return ch.add.length || ch.change.length;
	  }));
	}

	function adjustToExistingIndexNames(_a, schema, idbtrans) {
	  var db = _a._novip;
	  var storeNames = idbtrans.db.objectStoreNames;

	  for (var i = 0; i < storeNames.length; ++i) {
	    var storeName = storeNames[i];
	    var store = idbtrans.objectStore(storeName);
	    db._hasGetAll = 'getAll' in store;

	    for (var j = 0; j < store.indexNames.length; ++j) {
	      var indexName = store.indexNames[j];
	      var keyPath = store.index(indexName).keyPath;
	      var dexieName = typeof keyPath === 'string' ? keyPath : "[" + slice(keyPath).join('+') + "]";

	      if (schema[storeName]) {
	        var indexSpec = schema[storeName].idxByName[dexieName];

	        if (indexSpec) {
	          indexSpec.name = indexName;
	          delete schema[storeName].idxByName[dexieName];
	          schema[storeName].idxByName[indexName] = indexSpec;
	        }
	      }
	    }
	  }

	  if (typeof navigator !== 'undefined' && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && _global.WorkerGlobalScope && _global instanceof _global.WorkerGlobalScope && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604) {
	    db._hasGetAll = false;
	  }
	}

	function parseIndexSyntax(primKeyAndIndexes) {
	  return primKeyAndIndexes.split(',').map(function (index, indexNum) {
	    index = index.trim();
	    var name = index.replace(/([&*]|\+\+)/g, "");
	    var keyPath = /^\[/.test(name) ? name.match(/^\[(.*)\]$/)[1].split('+') : name;
	    return createIndexSpec(name, keyPath || null, /\&/.test(index), /\*/.test(index), /\+\+/.test(index), isArray(keyPath), indexNum === 0);
	  });
	}

	var Version = function () {
	  function Version() {}

	  Version.prototype._parseStoresSpec = function (stores, outSchema) {
	    keys(stores).forEach(function (tableName) {
	      if (stores[tableName] !== null) {
	        var indexes = parseIndexSyntax(stores[tableName]);
	        var primKey = indexes.shift();
	        if (primKey.multi) throw new exceptions.Schema("Primary key cannot be multi-valued");
	        indexes.forEach(function (idx) {
	          if (idx.auto) throw new exceptions.Schema("Only primary key can be marked as autoIncrement (++)");
	          if (!idx.keyPath) throw new exceptions.Schema("Index must have a name and cannot be an empty string");
	        });
	        outSchema[tableName] = createTableSchema(tableName, primKey, indexes);
	      }
	    });
	  };

	  Version.prototype.stores = function (stores) {
	    var db = this.db;
	    this._cfg.storesSource = this._cfg.storesSource ? extend(this._cfg.storesSource, stores) : stores;
	    var versions = db._versions;
	    var storesSpec = {};
	    var dbschema = {};
	    versions.forEach(function (version) {
	      extend(storesSpec, version._cfg.storesSource);
	      dbschema = version._cfg.dbschema = {};

	      version._parseStoresSpec(storesSpec, dbschema);
	    });
	    db._dbSchema = dbschema;
	    removeTablesApi(db, [db._allTables, db, db.Transaction.prototype]);
	    setApiOnPlace(db, [db._allTables, db, db.Transaction.prototype, this._cfg.tables], keys(dbschema), dbschema);
	    db._storeNames = keys(dbschema);
	    return this;
	  };

	  Version.prototype.upgrade = function (upgradeFunction) {
	    this._cfg.contentUpgrade = promisableChain(this._cfg.contentUpgrade || nop, upgradeFunction);
	    return this;
	  };

	  return Version;
	}();

	function createVersionConstructor(db) {
	  return makeClassConstructor(Version.prototype, function Version(versionNumber) {
	    this.db = db;
	    this._cfg = {
	      version: versionNumber,
	      storesSource: null,
	      dbschema: {},
	      tables: {},
	      contentUpgrade: null
	    };
	  });
	}

	function getDbNamesTable(indexedDB, IDBKeyRange) {
	  var dbNamesDB = indexedDB["_dbNamesDB"];

	  if (!dbNamesDB) {
	    dbNamesDB = indexedDB["_dbNamesDB"] = new Dexie$1(DBNAMES_DB, {
	      addons: [],
	      indexedDB: indexedDB,
	      IDBKeyRange: IDBKeyRange
	    });
	    dbNamesDB.version(1).stores({
	      dbnames: "name"
	    });
	  }

	  return dbNamesDB.table("dbnames");
	}

	function hasDatabasesNative(indexedDB) {
	  return indexedDB && typeof indexedDB.databases === "function";
	}

	function _getDatabaseNames(_a) {
	  var indexedDB = _a.indexedDB,
	      IDBKeyRange = _a.IDBKeyRange;
	  return hasDatabasesNative(indexedDB) ? Promise.resolve(indexedDB.databases()).then(function (infos) {
	    return infos.map(function (info) {
	      return info.name;
	    }).filter(function (name) {
	      return name !== DBNAMES_DB;
	    });
	  }) : getDbNamesTable(indexedDB, IDBKeyRange).toCollection().primaryKeys();
	}

	function _onDatabaseCreated(_a, name) {
	  var indexedDB = _a.indexedDB,
	      IDBKeyRange = _a.IDBKeyRange;
	  !hasDatabasesNative(indexedDB) && name !== DBNAMES_DB && getDbNamesTable(indexedDB, IDBKeyRange).put({
	    name: name
	  })["catch"](nop);
	}

	function _onDatabaseDeleted(_a, name) {
	  var indexedDB = _a.indexedDB,
	      IDBKeyRange = _a.IDBKeyRange;
	  !hasDatabasesNative(indexedDB) && name !== DBNAMES_DB && getDbNamesTable(indexedDB, IDBKeyRange)["delete"](name)["catch"](nop);
	}

	function vip(fn) {
	  return newScope(function () {
	    PSD.letThrough = true;
	    return fn();
	  });
	}

	function idbReady() {
	  var isSafari = !navigator.userAgentData && /Safari\//.test(navigator.userAgent) && !/Chrom(e|ium)\//.test(navigator.userAgent);
	  if (!isSafari || !indexedDB.databases) return Promise.resolve();
	  var intervalId;
	  return new Promise(function (resolve) {
	    var tryIdb = function tryIdb() {
	      return indexedDB.databases()["finally"](resolve);
	    };

	    intervalId = setInterval(tryIdb, 100);
	    tryIdb();
	  })["finally"](function () {
	    return clearInterval(intervalId);
	  });
	}

	function dexieOpen(db) {
	  var state = db._state;
	  var indexedDB = db._deps.indexedDB;
	  if (state.isBeingOpened || db.idbdb) return state.dbReadyPromise.then(function () {
	    return state.dbOpenError ? rejection(state.dbOpenError) : db;
	  });
	  debug && (state.openCanceller._stackHolder = getErrorWithStack());
	  state.isBeingOpened = true;
	  state.dbOpenError = null;
	  state.openComplete = false;
	  var openCanceller = state.openCanceller;

	  function throwIfCancelled() {
	    if (state.openCanceller !== openCanceller) throw new exceptions.DatabaseClosed('db.open() was cancelled');
	  }

	  var resolveDbReady = state.dbReadyResolve,
	      upgradeTransaction = null,
	      wasCreated = false;
	  return DexiePromise.race([openCanceller, (typeof navigator === 'undefined' ? DexiePromise.resolve() : idbReady()).then(function () {
	    return new DexiePromise(function (resolve, reject) {
	      throwIfCancelled();
	      if (!indexedDB) throw new exceptions.MissingAPI();
	      var dbName = db.name;
	      var req = state.autoSchema ? indexedDB.open(dbName) : indexedDB.open(dbName, Math.round(db.verno * 10));
	      if (!req) throw new exceptions.MissingAPI();
	      req.onerror = eventRejectHandler(reject);
	      req.onblocked = wrap(db._fireOnBlocked);
	      req.onupgradeneeded = wrap(function (e) {
	        upgradeTransaction = req.transaction;

	        if (state.autoSchema && !db._options.allowEmptyDB) {
	          req.onerror = preventDefault;
	          upgradeTransaction.abort();
	          req.result.close();
	          var delreq = indexedDB.deleteDatabase(dbName);
	          delreq.onsuccess = delreq.onerror = wrap(function () {
	            reject(new exceptions.NoSuchDatabase("Database " + dbName + " doesnt exist"));
	          });
	        } else {
	          upgradeTransaction.onerror = eventRejectHandler(reject);
	          var oldVer = e.oldVersion > Math.pow(2, 62) ? 0 : e.oldVersion;
	          wasCreated = oldVer < 1;
	          db._novip.idbdb = req.result;
	          runUpgraders(db, oldVer / 10, upgradeTransaction, reject);
	        }
	      }, reject);
	      req.onsuccess = wrap(function () {
	        upgradeTransaction = null;
	        var idbdb = db._novip.idbdb = req.result;
	        var objectStoreNames = slice(idbdb.objectStoreNames);
	        if (objectStoreNames.length > 0) try {
	          var tmpTrans = idbdb.transaction(safariMultiStoreFix(objectStoreNames), 'readonly');
	          if (state.autoSchema) readGlobalSchema(db, idbdb, tmpTrans);else {
	            adjustToExistingIndexNames(db, db._dbSchema, tmpTrans);

	            if (!verifyInstalledSchema(db, tmpTrans)) {
	              console.warn("Dexie SchemaDiff: Schema was extended without increasing the number passed to db.version(). Some queries may fail.");
	            }
	          }
	          generateMiddlewareStacks(db, tmpTrans);
	        } catch (e) {}
	        connections.push(db);
	        idbdb.onversionchange = wrap(function (ev) {
	          state.vcFired = true;
	          db.on("versionchange").fire(ev);
	        });
	        idbdb.onclose = wrap(function (ev) {
	          db.on("close").fire(ev);
	        });
	        if (wasCreated) _onDatabaseCreated(db._deps, dbName);
	        resolve();
	      }, reject);
	    });
	  })]).then(function () {
	    throwIfCancelled();
	    state.onReadyBeingFired = [];
	    return DexiePromise.resolve(vip(function () {
	      return db.on.ready.fire(db.vip);
	    })).then(function fireRemainders() {
	      if (state.onReadyBeingFired.length > 0) {
	        var remainders_1 = state.onReadyBeingFired.reduce(promisableChain, nop);
	        state.onReadyBeingFired = [];
	        return DexiePromise.resolve(vip(function () {
	          return remainders_1(db.vip);
	        })).then(fireRemainders);
	      }
	    });
	  })["finally"](function () {
	    state.onReadyBeingFired = null;
	    state.isBeingOpened = false;
	  }).then(function () {
	    return db;
	  })["catch"](function (err) {
	    state.dbOpenError = err;

	    try {
	      upgradeTransaction && upgradeTransaction.abort();
	    } catch (_a) {}

	    if (openCanceller === state.openCanceller) {
	      db._close();
	    }

	    return rejection(err);
	  })["finally"](function () {
	    state.openComplete = true;
	    resolveDbReady();
	  });
	}

	function awaitIterator(iterator) {
	  var callNext = function callNext(result) {
	    return iterator.next(result);
	  },
	      doThrow = function doThrow(error) {
	    return iterator["throw"](error);
	  },
	      onSuccess = step(callNext),
	      onError = step(doThrow);

	  function step(getNext) {
	    return function (val) {
	      var next = getNext(val),
	          value = next.value;
	      return next.done ? value : !value || typeof value.then !== 'function' ? isArray(value) ? Promise.all(value).then(onSuccess, onError) : onSuccess(value) : value.then(onSuccess, onError);
	    };
	  }

	  return step(callNext)();
	}

	function extractTransactionArgs(mode, _tableArgs_, scopeFunc) {
	  var i = arguments.length;
	  if (i < 2) throw new exceptions.InvalidArgument("Too few arguments");
	  var args = new Array(i - 1);

	  while (--i) {
	    args[i - 1] = arguments[i];
	  }

	  scopeFunc = args.pop();
	  var tables = flatten(args);
	  return [mode, tables, scopeFunc];
	}

	function enterTransactionScope(db, mode, storeNames, parentTransaction, scopeFunc) {
	  return DexiePromise.resolve().then(function () {
	    var transless = PSD.transless || PSD;

	    var trans = db._createTransaction(mode, storeNames, db._dbSchema, parentTransaction);

	    var zoneProps = {
	      trans: trans,
	      transless: transless
	    };

	    if (parentTransaction) {
	      trans.idbtrans = parentTransaction.idbtrans;
	    } else {
	      try {
	        trans.create();
	        db._state.PR1398_maxLoop = 3;
	      } catch (ex) {
	        if (ex.name === errnames.InvalidState && db.isOpen() && --db._state.PR1398_maxLoop > 0) {
	          console.warn('Dexie: Need to reopen db');

	          db._close();

	          return db.open().then(function () {
	            return enterTransactionScope(db, mode, storeNames, null, scopeFunc);
	          });
	        }

	        return rejection(ex);
	      }
	    }

	    var scopeFuncIsAsync = isAsyncFunction(scopeFunc);

	    if (scopeFuncIsAsync) {
	      incrementExpectedAwaits();
	    }

	    var returnValue;
	    var promiseFollowed = DexiePromise.follow(function () {
	      returnValue = scopeFunc.call(trans, trans);

	      if (returnValue) {
	        if (scopeFuncIsAsync) {
	          var decrementor = decrementExpectedAwaits.bind(null, null);
	          returnValue.then(decrementor, decrementor);
	        } else if (typeof returnValue.next === 'function' && typeof returnValue["throw"] === 'function') {
	          returnValue = awaitIterator(returnValue);
	        }
	      }
	    }, zoneProps);
	    return (returnValue && typeof returnValue.then === 'function' ? DexiePromise.resolve(returnValue).then(function (x) {
	      return trans.active ? x : rejection(new exceptions.PrematureCommit("Transaction committed too early. See http://bit.ly/2kdckMn"));
	    }) : promiseFollowed.then(function () {
	      return returnValue;
	    })).then(function (x) {
	      if (parentTransaction) trans._resolve();
	      return trans._completion.then(function () {
	        return x;
	      });
	    })["catch"](function (e) {
	      trans._reject(e);

	      return rejection(e);
	    });
	  });
	}

	function pad(a, value, count) {
	  var result = isArray(a) ? a.slice() : [a];

	  for (var i = 0; i < count; ++i) {
	    result.push(value);
	  }

	  return result;
	}

	function createVirtualIndexMiddleware(down) {
	  return _assign(_assign({}, down), {
	    table: function table(tableName) {
	      var table = down.table(tableName);
	      var schema = table.schema;
	      var indexLookup = {};
	      var allVirtualIndexes = [];

	      function addVirtualIndexes(keyPath, keyTail, lowLevelIndex) {
	        var keyPathAlias = getKeyPathAlias(keyPath);
	        var indexList = indexLookup[keyPathAlias] = indexLookup[keyPathAlias] || [];
	        var keyLength = keyPath == null ? 0 : typeof keyPath === 'string' ? 1 : keyPath.length;
	        var isVirtual = keyTail > 0;

	        var virtualIndex = _assign(_assign({}, lowLevelIndex), {
	          isVirtual: isVirtual,
	          keyTail: keyTail,
	          keyLength: keyLength,
	          extractKey: getKeyExtractor(keyPath),
	          unique: !isVirtual && lowLevelIndex.unique
	        });

	        indexList.push(virtualIndex);

	        if (!virtualIndex.isPrimaryKey) {
	          allVirtualIndexes.push(virtualIndex);
	        }

	        if (keyLength > 1) {
	          var virtualKeyPath = keyLength === 2 ? keyPath[0] : keyPath.slice(0, keyLength - 1);
	          addVirtualIndexes(virtualKeyPath, keyTail + 1, lowLevelIndex);
	        }

	        indexList.sort(function (a, b) {
	          return a.keyTail - b.keyTail;
	        });
	        return virtualIndex;
	      }

	      var primaryKey = addVirtualIndexes(schema.primaryKey.keyPath, 0, schema.primaryKey);
	      indexLookup[":id"] = [primaryKey];

	      for (var _i = 0, _a = schema.indexes; _i < _a.length; _i++) {
	        var index = _a[_i];
	        addVirtualIndexes(index.keyPath, 0, index);
	      }

	      function findBestIndex(keyPath) {
	        var result = indexLookup[getKeyPathAlias(keyPath)];
	        return result && result[0];
	      }

	      function translateRange(range, keyTail) {
	        return {
	          type: range.type === 1 ? 2 : range.type,
	          lower: pad(range.lower, range.lowerOpen ? down.MAX_KEY : down.MIN_KEY, keyTail),
	          lowerOpen: true,
	          upper: pad(range.upper, range.upperOpen ? down.MIN_KEY : down.MAX_KEY, keyTail),
	          upperOpen: true
	        };
	      }

	      function translateRequest(req) {
	        var index = req.query.index;
	        return index.isVirtual ? _assign(_assign({}, req), {
	          query: {
	            index: index,
	            range: translateRange(req.query.range, index.keyTail)
	          }
	        }) : req;
	      }

	      var result = _assign(_assign({}, table), {
	        schema: _assign(_assign({}, schema), {
	          primaryKey: primaryKey,
	          indexes: allVirtualIndexes,
	          getIndexByKeyPath: findBestIndex
	        }),
	        count: function count(req) {
	          return table.count(translateRequest(req));
	        },
	        query: function query(req) {
	          return table.query(translateRequest(req));
	        },
	        openCursor: function openCursor(req) {
	          var _a = req.query.index,
	              keyTail = _a.keyTail,
	              isVirtual = _a.isVirtual,
	              keyLength = _a.keyLength;
	          if (!isVirtual) return table.openCursor(req);

	          function createVirtualCursor(cursor) {
	            function _continue(key) {
	              key != null ? cursor["continue"](pad(key, req.reverse ? down.MAX_KEY : down.MIN_KEY, keyTail)) : req.unique ? cursor["continue"](cursor.key.slice(0, keyLength).concat(req.reverse ? down.MIN_KEY : down.MAX_KEY, keyTail)) : cursor["continue"]();
	            }

	            var virtualCursor = Object.create(cursor, {
	              "continue": {
	                value: _continue
	              },
	              continuePrimaryKey: {
	                value: function value(key, primaryKey) {
	                  cursor.continuePrimaryKey(pad(key, down.MAX_KEY, keyTail), primaryKey);
	                }
	              },
	              primaryKey: {
	                get: function get() {
	                  return cursor.primaryKey;
	                }
	              },
	              key: {
	                get: function get() {
	                  var key = cursor.key;
	                  return keyLength === 1 ? key[0] : key.slice(0, keyLength);
	                }
	              },
	              value: {
	                get: function get() {
	                  return cursor.value;
	                }
	              }
	            });
	            return virtualCursor;
	          }

	          return table.openCursor(translateRequest(req)).then(function (cursor) {
	            return cursor && createVirtualCursor(cursor);
	          });
	        }
	      });

	      return result;
	    }
	  });
	}

	var virtualIndexMiddleware = {
	  stack: "dbcore",
	  name: "VirtualIndexMiddleware",
	  level: 1,
	  create: createVirtualIndexMiddleware
	};

	function getObjectDiff(a, b, rv, prfx) {
	  rv = rv || {};
	  prfx = prfx || '';
	  keys(a).forEach(function (prop) {
	    if (!hasOwn(b, prop)) {
	      rv[prfx + prop] = undefined;
	    } else {
	      var ap = a[prop],
	          bp = b[prop];

	      if (babelHelpers["typeof"](ap) === 'object' && babelHelpers["typeof"](bp) === 'object' && ap && bp) {
	        var apTypeName = toStringTag(ap);
	        var bpTypeName = toStringTag(bp);

	        if (apTypeName !== bpTypeName) {
	          rv[prfx + prop] = b[prop];
	        } else if (apTypeName === 'Object') {
	          getObjectDiff(ap, bp, rv, prfx + prop + '.');
	        } else if (ap !== bp) {
	          rv[prfx + prop] = b[prop];
	        }
	      } else if (ap !== bp) rv[prfx + prop] = b[prop];
	    }
	  });
	  keys(b).forEach(function (prop) {
	    if (!hasOwn(a, prop)) {
	      rv[prfx + prop] = b[prop];
	    }
	  });
	  return rv;
	}

	function getEffectiveKeys(primaryKey, req) {
	  if (req.type === 'delete') return req.keys;
	  return req.keys || req.values.map(primaryKey.extractKey);
	}

	var hooksMiddleware = {
	  stack: "dbcore",
	  name: "HooksMiddleware",
	  level: 2,
	  create: function create(downCore) {
	    return _assign(_assign({}, downCore), {
	      table: function table(tableName) {
	        var downTable = downCore.table(tableName);
	        var primaryKey = downTable.schema.primaryKey;

	        var tableMiddleware = _assign(_assign({}, downTable), {
	          mutate: function mutate(req) {
	            var dxTrans = PSD.trans;
	            var _a = dxTrans.table(tableName).hook,
	                deleting = _a.deleting,
	                creating = _a.creating,
	                updating = _a.updating;

	            switch (req.type) {
	              case 'add':
	                if (creating.fire === nop) break;
	                return dxTrans._promise('readwrite', function () {
	                  return addPutOrDelete(req);
	                }, true);

	              case 'put':
	                if (creating.fire === nop && updating.fire === nop) break;
	                return dxTrans._promise('readwrite', function () {
	                  return addPutOrDelete(req);
	                }, true);

	              case 'delete':
	                if (deleting.fire === nop) break;
	                return dxTrans._promise('readwrite', function () {
	                  return addPutOrDelete(req);
	                }, true);

	              case 'deleteRange':
	                if (deleting.fire === nop) break;
	                return dxTrans._promise('readwrite', function () {
	                  return deleteRange(req);
	                }, true);
	            }

	            return downTable.mutate(req);

	            function addPutOrDelete(req) {
	              var dxTrans = PSD.trans;
	              var keys = req.keys || getEffectiveKeys(primaryKey, req);
	              if (!keys) throw new Error("Keys missing");
	              req = req.type === 'add' || req.type === 'put' ? _assign(_assign({}, req), {
	                keys: keys
	              }) : _assign({}, req);
	              if (req.type !== 'delete') req.values = __spreadArray([], req.values, true);
	              if (req.keys) req.keys = __spreadArray([], req.keys, true);
	              return getExistingValues(downTable, req, keys).then(function (existingValues) {
	                var contexts = keys.map(function (key, i) {
	                  var existingValue = existingValues[i];
	                  var ctx = {
	                    onerror: null,
	                    onsuccess: null
	                  };

	                  if (req.type === 'delete') {
	                    deleting.fire.call(ctx, key, existingValue, dxTrans);
	                  } else if (req.type === 'add' || existingValue === undefined) {
	                    var generatedPrimaryKey = creating.fire.call(ctx, key, req.values[i], dxTrans);

	                    if (key == null && generatedPrimaryKey != null) {
	                      key = generatedPrimaryKey;
	                      req.keys[i] = key;

	                      if (!primaryKey.outbound) {
	                        setByKeyPath(req.values[i], primaryKey.keyPath, key);
	                      }
	                    }
	                  } else {
	                    var objectDiff = getObjectDiff(existingValue, req.values[i]);
	                    var additionalChanges_1 = updating.fire.call(ctx, objectDiff, key, existingValue, dxTrans);

	                    if (additionalChanges_1) {
	                      var requestedValue_1 = req.values[i];
	                      Object.keys(additionalChanges_1).forEach(function (keyPath) {
	                        if (hasOwn(requestedValue_1, keyPath)) {
	                          requestedValue_1[keyPath] = additionalChanges_1[keyPath];
	                        } else {
	                          setByKeyPath(requestedValue_1, keyPath, additionalChanges_1[keyPath]);
	                        }
	                      });
	                    }
	                  }

	                  return ctx;
	                });
	                return downTable.mutate(req).then(function (_a) {
	                  var failures = _a.failures,
	                      results = _a.results,
	                      numFailures = _a.numFailures,
	                      lastResult = _a.lastResult;

	                  for (var i = 0; i < keys.length; ++i) {
	                    var primKey = results ? results[i] : keys[i];
	                    var ctx = contexts[i];

	                    if (primKey == null) {
	                      ctx.onerror && ctx.onerror(failures[i]);
	                    } else {
	                      ctx.onsuccess && ctx.onsuccess(req.type === 'put' && existingValues[i] ? req.values[i] : primKey);
	                    }
	                  }

	                  return {
	                    failures: failures,
	                    results: results,
	                    numFailures: numFailures,
	                    lastResult: lastResult
	                  };
	                })["catch"](function (error) {
	                  contexts.forEach(function (ctx) {
	                    return ctx.onerror && ctx.onerror(error);
	                  });
	                  return Promise.reject(error);
	                });
	              });
	            }

	            function deleteRange(req) {
	              return deleteNextChunk(req.trans, req.range, 10000);
	            }

	            function deleteNextChunk(trans, range, limit) {
	              return downTable.query({
	                trans: trans,
	                values: false,
	                query: {
	                  index: primaryKey,
	                  range: range
	                },
	                limit: limit
	              }).then(function (_a) {
	                var result = _a.result;
	                return addPutOrDelete({
	                  type: 'delete',
	                  keys: result,
	                  trans: trans
	                }).then(function (res) {
	                  if (res.numFailures > 0) return Promise.reject(res.failures[0]);

	                  if (result.length < limit) {
	                    return {
	                      failures: [],
	                      numFailures: 0,
	                      lastResult: undefined
	                    };
	                  } else {
	                    return deleteNextChunk(trans, _assign(_assign({}, range), {
	                      lower: result[result.length - 1],
	                      lowerOpen: true
	                    }), limit);
	                  }
	                });
	              });
	            }
	          }
	        });

	        return tableMiddleware;
	      }
	    });
	  }
	};

	function getExistingValues(table, req, effectiveKeys) {
	  return req.type === "add" ? Promise.resolve([]) : table.getMany({
	    trans: req.trans,
	    keys: effectiveKeys,
	    cache: "immutable"
	  });
	}

	function getFromTransactionCache(keys, cache, clone) {
	  try {
	    if (!cache) return null;
	    if (cache.keys.length < keys.length) return null;
	    var result = [];

	    for (var i = 0, j = 0; i < cache.keys.length && j < keys.length; ++i) {
	      if (cmp(cache.keys[i], keys[j]) !== 0) continue;
	      result.push(clone ? deepClone(cache.values[i]) : cache.values[i]);
	      ++j;
	    }

	    return result.length === keys.length ? result : null;
	  } catch (_a) {
	    return null;
	  }
	}

	var cacheExistingValuesMiddleware = {
	  stack: "dbcore",
	  level: -1,
	  create: function create(core) {
	    return {
	      table: function table(tableName) {
	        var table = core.table(tableName);
	        return _assign(_assign({}, table), {
	          getMany: function getMany(req) {
	            if (!req.cache) {
	              return table.getMany(req);
	            }

	            var cachedResult = getFromTransactionCache(req.keys, req.trans["_cache"], req.cache === "clone");

	            if (cachedResult) {
	              return DexiePromise.resolve(cachedResult);
	            }

	            return table.getMany(req).then(function (res) {
	              req.trans["_cache"] = {
	                keys: req.keys,
	                values: req.cache === "clone" ? deepClone(res) : res
	              };
	              return res;
	            });
	          },
	          mutate: function mutate(req) {
	            if (req.type !== "add") req.trans["_cache"] = null;
	            return table.mutate(req);
	          }
	        });
	      }
	    };
	  }
	};

	var _a;

	function isEmptyRange(node) {
	  return !("from" in node);
	}

	var RangeSet = function RangeSet(fromOrTree, to) {
	  if (this) {
	    extend(this, arguments.length ? {
	      d: 1,
	      from: fromOrTree,
	      to: arguments.length > 1 ? to : fromOrTree
	    } : {
	      d: 0
	    });
	  } else {
	    var rv = new RangeSet();

	    if (fromOrTree && "d" in fromOrTree) {
	      extend(rv, fromOrTree);
	    }

	    return rv;
	  }
	};

	props(RangeSet.prototype, (_a = {
	  add: function add(rangeSet) {
	    mergeRanges(this, rangeSet);
	    return this;
	  },
	  addKey: function addKey(key) {
	    addRange(this, key, key);
	    return this;
	  },
	  addKeys: function addKeys(keys) {
	    var _this = this;

	    keys.forEach(function (key) {
	      return addRange(_this, key, key);
	    });
	    return this;
	  }
	}, _a[iteratorSymbol] = function () {
	  return getRangeSetIterator(this);
	}, _a));

	function addRange(target, from, to) {
	  var diff = cmp(from, to);
	  if (isNaN(diff)) return;
	  if (diff > 0) throw RangeError();
	  if (isEmptyRange(target)) return extend(target, {
	    from: from,
	    to: to,
	    d: 1
	  });
	  var left = target.l;
	  var right = target.r;

	  if (cmp(to, target.from) < 0) {
	    left ? addRange(left, from, to) : target.l = {
	      from: from,
	      to: to,
	      d: 1,
	      l: null,
	      r: null
	    };
	    return rebalance(target);
	  }

	  if (cmp(from, target.to) > 0) {
	    right ? addRange(right, from, to) : target.r = {
	      from: from,
	      to: to,
	      d: 1,
	      l: null,
	      r: null
	    };
	    return rebalance(target);
	  }

	  if (cmp(from, target.from) < 0) {
	    target.from = from;
	    target.l = null;
	    target.d = right ? right.d + 1 : 1;
	  }

	  if (cmp(to, target.to) > 0) {
	    target.to = to;
	    target.r = null;
	    target.d = target.l ? target.l.d + 1 : 1;
	  }

	  var rightWasCutOff = !target.r;

	  if (left && !target.l) {
	    mergeRanges(target, left);
	  }

	  if (right && rightWasCutOff) {
	    mergeRanges(target, right);
	  }
	}

	function mergeRanges(target, newSet) {
	  function _addRangeSet(target, _a) {
	    var from = _a.from,
	        to = _a.to,
	        l = _a.l,
	        r = _a.r;
	    addRange(target, from, to);
	    if (l) _addRangeSet(target, l);
	    if (r) _addRangeSet(target, r);
	  }

	  if (!isEmptyRange(newSet)) _addRangeSet(target, newSet);
	}

	function rangesOverlap(rangeSet1, rangeSet2) {
	  var i1 = getRangeSetIterator(rangeSet2);
	  var nextResult1 = i1.next();
	  if (nextResult1.done) return false;
	  var a = nextResult1.value;
	  var i2 = getRangeSetIterator(rangeSet1);
	  var nextResult2 = i2.next(a.from);
	  var b = nextResult2.value;

	  while (!nextResult1.done && !nextResult2.done) {
	    if (cmp(b.from, a.to) <= 0 && cmp(b.to, a.from) >= 0) return true;
	    cmp(a.from, b.from) < 0 ? a = (nextResult1 = i1.next(b.from)).value : b = (nextResult2 = i2.next(a.from)).value;
	  }

	  return false;
	}

	function getRangeSetIterator(node) {
	  var state = isEmptyRange(node) ? null : {
	    s: 0,
	    n: node
	  };
	  return {
	    next: function next(key) {
	      var keyProvided = arguments.length > 0;

	      while (state) {
	        switch (state.s) {
	          case 0:
	            state.s = 1;

	            if (keyProvided) {
	              while (state.n.l && cmp(key, state.n.from) < 0) {
	                state = {
	                  up: state,
	                  n: state.n.l,
	                  s: 1
	                };
	              }
	            } else {
	              while (state.n.l) {
	                state = {
	                  up: state,
	                  n: state.n.l,
	                  s: 1
	                };
	              }
	            }

	          case 1:
	            state.s = 2;
	            if (!keyProvided || cmp(key, state.n.to) <= 0) return {
	              value: state.n,
	              done: false
	            };

	          case 2:
	            if (state.n.r) {
	              state.s = 3;
	              state = {
	                up: state,
	                n: state.n.r,
	                s: 0
	              };
	              continue;
	            }

	          case 3:
	            state = state.up;
	        }
	      }

	      return {
	        done: true
	      };
	    }
	  };
	}

	function rebalance(target) {
	  var _a, _b;

	  var diff = (((_a = target.r) === null || _a === void 0 ? void 0 : _a.d) || 0) - (((_b = target.l) === null || _b === void 0 ? void 0 : _b.d) || 0);
	  var r = diff > 1 ? "r" : diff < -1 ? "l" : "";

	  if (r) {
	    var l = r === "r" ? "l" : "r";

	    var rootClone = _assign({}, target);

	    var oldRootRight = target[r];
	    target.from = oldRootRight.from;
	    target.to = oldRootRight.to;
	    target[r] = oldRootRight[r];
	    rootClone[r] = oldRootRight[l];
	    target[l] = rootClone;
	    rootClone.d = computeDepth(rootClone);
	  }

	  target.d = computeDepth(target);
	}

	function computeDepth(_a) {
	  var r = _a.r,
	      l = _a.l;
	  return (r ? l ? Math.max(r.d, l.d) : r.d : l ? l.d : 0) + 1;
	}

	var observabilityMiddleware = {
	  stack: "dbcore",
	  level: 0,
	  create: function create(core) {
	    var dbName = core.schema.name;
	    var FULL_RANGE = new RangeSet(core.MIN_KEY, core.MAX_KEY);
	    return _assign(_assign({}, core), {
	      table: function table(tableName) {
	        var table = core.table(tableName);
	        var schema = table.schema;
	        var primaryKey = schema.primaryKey;
	        var extractKey = primaryKey.extractKey,
	            outbound = primaryKey.outbound;

	        var tableClone = _assign(_assign({}, table), {
	          mutate: function mutate(req) {
	            var trans = req.trans;
	            var mutatedParts = trans.mutatedParts || (trans.mutatedParts = {});

	            var getRangeSet = function getRangeSet(indexName) {
	              var part = "idb://" + dbName + "/" + tableName + "/" + indexName;
	              return mutatedParts[part] || (mutatedParts[part] = new RangeSet());
	            };

	            var pkRangeSet = getRangeSet("");
	            var delsRangeSet = getRangeSet(":dels");
	            var type = req.type;

	            var _a = req.type === "deleteRange" ? [req.range] : req.type === "delete" ? [req.keys] : req.values.length < 50 ? [[], req.values] : [],
	                keys = _a[0],
	                newObjs = _a[1];

	            var oldCache = req.trans["_cache"];
	            return table.mutate(req).then(function (res) {
	              if (isArray(keys)) {
	                if (type !== "delete") keys = res.results;
	                pkRangeSet.addKeys(keys);
	                var oldObjs = getFromTransactionCache(keys, oldCache);

	                if (!oldObjs && type !== "add") {
	                  delsRangeSet.addKeys(keys);
	                }

	                if (oldObjs || newObjs) {
	                  trackAffectedIndexes(getRangeSet, schema, oldObjs, newObjs);
	                }
	              } else if (keys) {
	                var range = {
	                  from: keys.lower,
	                  to: keys.upper
	                };
	                delsRangeSet.add(range);
	                pkRangeSet.add(range);
	              } else {
	                pkRangeSet.add(FULL_RANGE);
	                delsRangeSet.add(FULL_RANGE);
	                schema.indexes.forEach(function (idx) {
	                  return getRangeSet(idx.name).add(FULL_RANGE);
	                });
	              }

	              return res;
	            });
	          }
	        });

	        var getRange = function getRange(_a) {
	          var _b, _c;

	          var _d = _a.query,
	              index = _d.index,
	              range = _d.range;
	          return [index, new RangeSet((_b = range.lower) !== null && _b !== void 0 ? _b : core.MIN_KEY, (_c = range.upper) !== null && _c !== void 0 ? _c : core.MAX_KEY)];
	        };

	        var readSubscribers = {
	          get: function get(req) {
	            return [primaryKey, new RangeSet(req.key)];
	          },
	          getMany: function getMany(req) {
	            return [primaryKey, new RangeSet().addKeys(req.keys)];
	          },
	          count: getRange,
	          query: getRange,
	          openCursor: getRange
	        };
	        keys(readSubscribers).forEach(function (method) {
	          tableClone[method] = function (req) {
	            var subscr = PSD.subscr;

	            if (subscr) {
	              var getRangeSet = function getRangeSet(indexName) {
	                var part = "idb://" + dbName + "/" + tableName + "/" + indexName;
	                return subscr[part] || (subscr[part] = new RangeSet());
	              };

	              var pkRangeSet_1 = getRangeSet("");
	              var delsRangeSet_1 = getRangeSet(":dels");

	              var _a = readSubscribers[method](req),
	                  queriedIndex = _a[0],
	                  queriedRanges = _a[1];

	              getRangeSet(queriedIndex.name || "").add(queriedRanges);

	              if (!queriedIndex.isPrimaryKey) {
	                if (method === "count") {
	                  delsRangeSet_1.add(FULL_RANGE);
	                } else {
	                  var keysPromise_1 = method === "query" && outbound && req.values && table.query(_assign(_assign({}, req), {
	                    values: false
	                  }));
	                  return table[method].apply(this, arguments).then(function (res) {
	                    if (method === "query") {
	                      if (outbound && req.values) {
	                        return keysPromise_1.then(function (_a) {
	                          var resultingKeys = _a.result;
	                          pkRangeSet_1.addKeys(resultingKeys);
	                          return res;
	                        });
	                      }

	                      var pKeys = req.values ? res.result.map(extractKey) : res.result;

	                      if (req.values) {
	                        pkRangeSet_1.addKeys(pKeys);
	                      } else {
	                        delsRangeSet_1.addKeys(pKeys);
	                      }
	                    } else if (method === "openCursor") {
	                      var cursor_1 = res;
	                      var wantValues_1 = req.values;
	                      return cursor_1 && Object.create(cursor_1, {
	                        key: {
	                          get: function get() {
	                            delsRangeSet_1.addKey(cursor_1.primaryKey);
	                            return cursor_1.key;
	                          }
	                        },
	                        primaryKey: {
	                          get: function get() {
	                            var pkey = cursor_1.primaryKey;
	                            delsRangeSet_1.addKey(pkey);
	                            return pkey;
	                          }
	                        },
	                        value: {
	                          get: function get() {
	                            wantValues_1 && pkRangeSet_1.addKey(cursor_1.primaryKey);
	                            return cursor_1.value;
	                          }
	                        }
	                      });
	                    }

	                    return res;
	                  });
	                }
	              }
	            }

	            return table[method].apply(this, arguments);
	          };
	        });
	        return tableClone;
	      }
	    });
	  }
	};

	function trackAffectedIndexes(getRangeSet, schema, oldObjs, newObjs) {
	  function addAffectedIndex(ix) {
	    var rangeSet = getRangeSet(ix.name || "");

	    function extractKey(obj) {
	      return obj != null ? ix.extractKey(obj) : null;
	    }

	    var addKeyOrKeys = function addKeyOrKeys(key) {
	      return ix.multiEntry && isArray(key) ? key.forEach(function (key) {
	        return rangeSet.addKey(key);
	      }) : rangeSet.addKey(key);
	    };

	    (oldObjs || newObjs).forEach(function (_, i) {
	      var oldKey = oldObjs && extractKey(oldObjs[i]);
	      var newKey = newObjs && extractKey(newObjs[i]);

	      if (cmp(oldKey, newKey) !== 0) {
	        if (oldKey != null) addKeyOrKeys(oldKey);
	        if (newKey != null) addKeyOrKeys(newKey);
	      }
	    });
	  }

	  schema.indexes.forEach(addAffectedIndex);
	}

	var Dexie$1 = function () {
	  function Dexie(name, options) {
	    var _this = this;

	    this._middlewares = {};
	    this.verno = 0;
	    var deps = Dexie.dependencies;
	    this._options = options = _assign({
	      addons: Dexie.addons,
	      autoOpen: true,
	      indexedDB: deps.indexedDB,
	      IDBKeyRange: deps.IDBKeyRange
	    }, options);
	    this._deps = {
	      indexedDB: options.indexedDB,
	      IDBKeyRange: options.IDBKeyRange
	    };
	    var addons = options.addons;
	    this._dbSchema = {};
	    this._versions = [];
	    this._storeNames = [];
	    this._allTables = {};
	    this.idbdb = null;
	    this._novip = this;
	    var state = {
	      dbOpenError: null,
	      isBeingOpened: false,
	      onReadyBeingFired: null,
	      openComplete: false,
	      dbReadyResolve: nop,
	      dbReadyPromise: null,
	      cancelOpen: nop,
	      openCanceller: null,
	      autoSchema: true,
	      PR1398_maxLoop: 3
	    };
	    state.dbReadyPromise = new DexiePromise(function (resolve) {
	      state.dbReadyResolve = resolve;
	    });
	    state.openCanceller = new DexiePromise(function (_, reject) {
	      state.cancelOpen = reject;
	    });
	    this._state = state;
	    this.name = name;
	    this.on = Events(this, "populate", "blocked", "versionchange", "close", {
	      ready: [promisableChain, nop]
	    });
	    this.on.ready.subscribe = override(this.on.ready.subscribe, function (subscribe) {
	      return function (subscriber, bSticky) {
	        Dexie.vip(function () {
	          var state = _this._state;

	          if (state.openComplete) {
	            if (!state.dbOpenError) DexiePromise.resolve().then(subscriber);
	            if (bSticky) subscribe(subscriber);
	          } else if (state.onReadyBeingFired) {
	            state.onReadyBeingFired.push(subscriber);
	            if (bSticky) subscribe(subscriber);
	          } else {
	            subscribe(subscriber);
	            var db_1 = _this;
	            if (!bSticky) subscribe(function unsubscribe() {
	              db_1.on.ready.unsubscribe(subscriber);
	              db_1.on.ready.unsubscribe(unsubscribe);
	            });
	          }
	        });
	      };
	    });
	    this.Collection = createCollectionConstructor(this);
	    this.Table = createTableConstructor(this);
	    this.Transaction = createTransactionConstructor(this);
	    this.Version = createVersionConstructor(this);
	    this.WhereClause = createWhereClauseConstructor(this);
	    this.on("versionchange", function (ev) {
	      if (ev.newVersion > 0) console.warn("Another connection wants to upgrade database '" + _this.name + "'. Closing db now to resume the upgrade.");else console.warn("Another connection wants to delete database '" + _this.name + "'. Closing db now to resume the delete request.");

	      _this.close();
	    });
	    this.on("blocked", function (ev) {
	      if (!ev.newVersion || ev.newVersion < ev.oldVersion) console.warn("Dexie.delete('" + _this.name + "') was blocked");else console.warn("Upgrade '" + _this.name + "' blocked by other connection holding version " + ev.oldVersion / 10);
	    });
	    this._maxKey = _getMaxKey(options.IDBKeyRange);

	    this._createTransaction = function (mode, storeNames, dbschema, parentTransaction) {
	      return new _this.Transaction(mode, storeNames, dbschema, _this._options.chromeTransactionDurability, parentTransaction);
	    };

	    this._fireOnBlocked = function (ev) {
	      _this.on("blocked").fire(ev);

	      connections.filter(function (c) {
	        return c.name === _this.name && c !== _this && !c._state.vcFired;
	      }).map(function (c) {
	        return c.on("versionchange").fire(ev);
	      });
	    };

	    this.use(virtualIndexMiddleware);
	    this.use(hooksMiddleware);
	    this.use(observabilityMiddleware);
	    this.use(cacheExistingValuesMiddleware);
	    this.vip = Object.create(this, {
	      _vip: {
	        value: true
	      }
	    });
	    addons.forEach(function (addon) {
	      return addon(_this);
	    });
	  }

	  Dexie.prototype.version = function (versionNumber) {
	    if (isNaN(versionNumber) || versionNumber < 0.1) throw new exceptions.Type("Given version is not a positive number");
	    versionNumber = Math.round(versionNumber * 10) / 10;
	    if (this.idbdb || this._state.isBeingOpened) throw new exceptions.Schema("Cannot add version when database is open");
	    this.verno = Math.max(this.verno, versionNumber);
	    var versions = this._versions;
	    var versionInstance = versions.filter(function (v) {
	      return v._cfg.version === versionNumber;
	    })[0];
	    if (versionInstance) return versionInstance;
	    versionInstance = new this.Version(versionNumber);
	    versions.push(versionInstance);
	    versions.sort(lowerVersionFirst);
	    versionInstance.stores({});
	    this._state.autoSchema = false;
	    return versionInstance;
	  };

	  Dexie.prototype._whenReady = function (fn) {
	    var _this = this;

	    return this.idbdb && (this._state.openComplete || PSD.letThrough || this._vip) ? fn() : new DexiePromise(function (resolve, reject) {
	      if (_this._state.openComplete) {
	        return reject(new exceptions.DatabaseClosed(_this._state.dbOpenError));
	      }

	      if (!_this._state.isBeingOpened) {
	        if (!_this._options.autoOpen) {
	          reject(new exceptions.DatabaseClosed());
	          return;
	        }

	        _this.open()["catch"](nop);
	      }

	      _this._state.dbReadyPromise.then(resolve, reject);
	    }).then(fn);
	  };

	  Dexie.prototype.use = function (_a) {
	    var stack = _a.stack,
	        create = _a.create,
	        level = _a.level,
	        name = _a.name;
	    if (name) this.unuse({
	      stack: stack,
	      name: name
	    });
	    var middlewares = this._middlewares[stack] || (this._middlewares[stack] = []);
	    middlewares.push({
	      stack: stack,
	      create: create,
	      level: level == null ? 10 : level,
	      name: name
	    });
	    middlewares.sort(function (a, b) {
	      return a.level - b.level;
	    });
	    return this;
	  };

	  Dexie.prototype.unuse = function (_a) {
	    var stack = _a.stack,
	        name = _a.name,
	        create = _a.create;

	    if (stack && this._middlewares[stack]) {
	      this._middlewares[stack] = this._middlewares[stack].filter(function (mw) {
	        return create ? mw.create !== create : name ? mw.name !== name : false;
	      });
	    }

	    return this;
	  };

	  Dexie.prototype.open = function () {
	    return dexieOpen(this);
	  };

	  Dexie.prototype._close = function () {
	    var state = this._state;
	    var idx = connections.indexOf(this);
	    if (idx >= 0) connections.splice(idx, 1);

	    if (this.idbdb) {
	      try {
	        this.idbdb.close();
	      } catch (e) {}

	      this._novip.idbdb = null;
	    }

	    state.dbReadyPromise = new DexiePromise(function (resolve) {
	      state.dbReadyResolve = resolve;
	    });
	    state.openCanceller = new DexiePromise(function (_, reject) {
	      state.cancelOpen = reject;
	    });
	  };

	  Dexie.prototype.close = function () {
	    this._close();

	    var state = this._state;
	    this._options.autoOpen = false;
	    state.dbOpenError = new exceptions.DatabaseClosed();
	    if (state.isBeingOpened) state.cancelOpen(state.dbOpenError);
	  };

	  Dexie.prototype["delete"] = function () {
	    var _this = this;

	    var hasArguments = arguments.length > 0;
	    var state = this._state;
	    return new DexiePromise(function (resolve, reject) {
	      var doDelete = function doDelete() {
	        _this.close();

	        var req = _this._deps.indexedDB.deleteDatabase(_this.name);

	        req.onsuccess = wrap(function () {
	          _onDatabaseDeleted(_this._deps, _this.name);

	          resolve();
	        });
	        req.onerror = eventRejectHandler(reject);
	        req.onblocked = _this._fireOnBlocked;
	      };

	      if (hasArguments) throw new exceptions.InvalidArgument("Arguments not allowed in db.delete()");

	      if (state.isBeingOpened) {
	        state.dbReadyPromise.then(doDelete);
	      } else {
	        doDelete();
	      }
	    });
	  };

	  Dexie.prototype.backendDB = function () {
	    return this.idbdb;
	  };

	  Dexie.prototype.isOpen = function () {
	    return this.idbdb !== null;
	  };

	  Dexie.prototype.hasBeenClosed = function () {
	    var dbOpenError = this._state.dbOpenError;
	    return dbOpenError && dbOpenError.name === 'DatabaseClosed';
	  };

	  Dexie.prototype.hasFailed = function () {
	    return this._state.dbOpenError !== null;
	  };

	  Dexie.prototype.dynamicallyOpened = function () {
	    return this._state.autoSchema;
	  };

	  Object.defineProperty(Dexie.prototype, "tables", {
	    get: function get() {
	      var _this = this;

	      return keys(this._allTables).map(function (name) {
	        return _this._allTables[name];
	      });
	    },
	    enumerable: false,
	    configurable: true
	  });

	  Dexie.prototype.transaction = function () {
	    var args = extractTransactionArgs.apply(this, arguments);
	    return this._transaction.apply(this, args);
	  };

	  Dexie.prototype._transaction = function (mode, tables, scopeFunc) {
	    var _this = this;

	    var parentTransaction = PSD.trans;
	    if (!parentTransaction || parentTransaction.db !== this || mode.indexOf('!') !== -1) parentTransaction = null;
	    var onlyIfCompatible = mode.indexOf('?') !== -1;
	    mode = mode.replace('!', '').replace('?', '');
	    var idbMode, storeNames;

	    try {
	      storeNames = tables.map(function (table) {
	        var storeName = table instanceof _this.Table ? table.name : table;
	        if (typeof storeName !== 'string') throw new TypeError("Invalid table argument to Dexie.transaction(). Only Table or String are allowed");
	        return storeName;
	      });
	      if (mode == "r" || mode === READONLY) idbMode = READONLY;else if (mode == "rw" || mode == READWRITE) idbMode = READWRITE;else throw new exceptions.InvalidArgument("Invalid transaction mode: " + mode);

	      if (parentTransaction) {
	        if (parentTransaction.mode === READONLY && idbMode === READWRITE) {
	          if (onlyIfCompatible) {
	            parentTransaction = null;
	          } else throw new exceptions.SubTransaction("Cannot enter a sub-transaction with READWRITE mode when parent transaction is READONLY");
	        }

	        if (parentTransaction) {
	          storeNames.forEach(function (storeName) {
	            if (parentTransaction && parentTransaction.storeNames.indexOf(storeName) === -1) {
	              if (onlyIfCompatible) {
	                parentTransaction = null;
	              } else throw new exceptions.SubTransaction("Table " + storeName + " not included in parent transaction.");
	            }
	          });
	        }

	        if (onlyIfCompatible && parentTransaction && !parentTransaction.active) {
	          parentTransaction = null;
	        }
	      }
	    } catch (e) {
	      return parentTransaction ? parentTransaction._promise(null, function (_, reject) {
	        reject(e);
	      }) : rejection(e);
	    }

	    var enterTransaction = enterTransactionScope.bind(null, this, idbMode, storeNames, parentTransaction, scopeFunc);
	    return parentTransaction ? parentTransaction._promise(idbMode, enterTransaction, "lock") : PSD.trans ? usePSD(PSD.transless, function () {
	      return _this._whenReady(enterTransaction);
	    }) : this._whenReady(enterTransaction);
	  };

	  Dexie.prototype.table = function (tableName) {
	    if (!hasOwn(this._allTables, tableName)) {
	      throw new exceptions.InvalidTable("Table " + tableName + " does not exist");
	    }

	    return this._allTables[tableName];
	  };

	  return Dexie;
	}();

	var symbolObservable = typeof Symbol !== "undefined" && "observable" in Symbol ? Symbol.observable : "@@observable";

	var Observable = function () {
	  function Observable(subscribe) {
	    this._subscribe = subscribe;
	  }

	  Observable.prototype.subscribe = function (x, error, complete) {
	    return this._subscribe(!x || typeof x === "function" ? {
	      next: x,
	      error: error,
	      complete: complete
	    } : x);
	  };

	  Observable.prototype[symbolObservable] = function () {
	    return this;
	  };

	  return Observable;
	}();

	function extendObservabilitySet(target, newSet) {
	  keys(newSet).forEach(function (part) {
	    var rangeSet = target[part] || (target[part] = new RangeSet());
	    mergeRanges(rangeSet, newSet[part]);
	  });
	  return target;
	}

	function liveQuery(querier) {
	  return new Observable(function (observer) {
	    var scopeFuncIsAsync = isAsyncFunction(querier);

	    function execute(subscr) {
	      if (scopeFuncIsAsync) {
	        incrementExpectedAwaits();
	      }

	      var exec = function exec() {
	        return newScope(querier, {
	          subscr: subscr,
	          trans: null
	        });
	      };

	      var rv = PSD.trans ? usePSD(PSD.transless, exec) : exec();

	      if (scopeFuncIsAsync) {
	        rv.then(decrementExpectedAwaits, decrementExpectedAwaits);
	      }

	      return rv;
	    }

	    var closed = false;
	    var accumMuts = {};
	    var currentObs = {};
	    var subscription = {
	      get closed() {
	        return closed;
	      },

	      unsubscribe: function unsubscribe() {
	        closed = true;
	        globalEvents.storagemutated.unsubscribe(mutationListener);
	      }
	    };
	    observer.start && observer.start(subscription);
	    var querying = false,
	        startedListening = false;

	    function shouldNotify() {
	      return keys(currentObs).some(function (key) {
	        return accumMuts[key] && rangesOverlap(accumMuts[key], currentObs[key]);
	      });
	    }

	    var mutationListener = function mutationListener(parts) {
	      extendObservabilitySet(accumMuts, parts);

	      if (shouldNotify()) {
	        doQuery();
	      }
	    };

	    var doQuery = function doQuery() {
	      if (querying || closed) return;
	      accumMuts = {};
	      var subscr = {};
	      var ret = execute(subscr);

	      if (!startedListening) {
	        globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, mutationListener);
	        startedListening = true;
	      }

	      querying = true;
	      Promise.resolve(ret).then(function (result) {
	        querying = false;
	        if (closed) return;

	        if (shouldNotify()) {
	          doQuery();
	        } else {
	          accumMuts = {};
	          currentObs = subscr;
	          observer.next && observer.next(result);
	        }
	      }, function (err) {
	        querying = false;
	        observer.error && observer.error(err);
	        subscription.unsubscribe();
	      });
	    };

	    doQuery();
	    return subscription;
	  });
	}

	var domDeps;

	try {
	  domDeps = {
	    indexedDB: _global.indexedDB || _global.mozIndexedDB || _global.webkitIndexedDB || _global.msIndexedDB,
	    IDBKeyRange: _global.IDBKeyRange || _global.webkitIDBKeyRange
	  };
	} catch (e) {
	  domDeps = {
	    indexedDB: null,
	    IDBKeyRange: null
	  };
	}

	var Dexie = Dexie$1;
	props(Dexie, _assign(_assign({}, fullNameExceptions), {
	  "delete": function _delete(databaseName) {
	    var db = new Dexie(databaseName, {
	      addons: []
	    });
	    return db["delete"]();
	  },
	  exists: function exists(name) {
	    return new Dexie(name, {
	      addons: []
	    }).open().then(function (db) {
	      db.close();
	      return true;
	    })["catch"]('NoSuchDatabaseError', function () {
	      return false;
	    });
	  },
	  getDatabaseNames: function getDatabaseNames(cb) {
	    try {
	      return _getDatabaseNames(Dexie.dependencies).then(cb);
	    } catch (_a) {
	      return rejection(new exceptions.MissingAPI());
	    }
	  },
	  defineClass: function defineClass() {
	    function Class(content) {
	      extend(this, content);
	    }

	    return Class;
	  },
	  ignoreTransaction: function ignoreTransaction(scopeFunc) {
	    return PSD.trans ? usePSD(PSD.transless, scopeFunc) : scopeFunc();
	  },
	  vip: vip,
	  async: function async(generatorFn) {
	    return function () {
	      try {
	        var rv = awaitIterator(generatorFn.apply(this, arguments));
	        if (!rv || typeof rv.then !== 'function') return DexiePromise.resolve(rv);
	        return rv;
	      } catch (e) {
	        return rejection(e);
	      }
	    };
	  },
	  spawn: function spawn(generatorFn, args, thiz) {
	    try {
	      var rv = awaitIterator(generatorFn.apply(thiz, args || []));
	      if (!rv || typeof rv.then !== 'function') return DexiePromise.resolve(rv);
	      return rv;
	    } catch (e) {
	      return rejection(e);
	    }
	  },
	  currentTransaction: {
	    get: function get() {
	      return PSD.trans || null;
	    }
	  },
	  waitFor: function waitFor(promiseOrFunction, optionalTimeout) {
	    var promise = DexiePromise.resolve(typeof promiseOrFunction === 'function' ? Dexie.ignoreTransaction(promiseOrFunction) : promiseOrFunction).timeout(optionalTimeout || 60000);
	    return PSD.trans ? PSD.trans.waitFor(promise) : promise;
	  },
	  Promise: DexiePromise,
	  debug: {
	    get: function get() {
	      return debug;
	    },
	    set: function set(value) {
	      setDebug(value, value === 'dexie' ? function () {
	        return true;
	      } : dexieStackFrameFilter);
	    }
	  },
	  derive: derive,
	  extend: extend,
	  props: props,
	  override: override,
	  Events: Events,
	  on: globalEvents,
	  liveQuery: liveQuery,
	  extendObservabilitySet: extendObservabilitySet,
	  getByKeyPath: getByKeyPath,
	  setByKeyPath: setByKeyPath,
	  delByKeyPath: delByKeyPath,
	  shallowClone: shallowClone,
	  deepClone: deepClone,
	  getObjectDiff: getObjectDiff,
	  cmp: cmp,
	  asap: asap$1,
	  minKey: minKey,
	  addons: [],
	  connections: connections,
	  errnames: errnames,
	  dependencies: domDeps,
	  semVer: DEXIE_VERSION,
	  version: DEXIE_VERSION.split('.').map(function (n) {
	    return parseInt(n);
	  }).reduce(function (p, c, i) {
	    return p + c / Math.pow(10, i * 2);
	  })
	}));
	Dexie.maxKey = _getMaxKey(Dexie.dependencies.IDBKeyRange);

	if (typeof dispatchEvent !== 'undefined' && typeof addEventListener !== 'undefined') {
	  globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, function (updatedParts) {
	    if (!propagatingLocally) {
	      var event_1;

	      if (isIEOrEdge) {
	        event_1 = document.createEvent('CustomEvent');
	        event_1.initCustomEvent(STORAGE_MUTATED_DOM_EVENT_NAME, true, true, updatedParts);
	      } else {
	        event_1 = new CustomEvent(STORAGE_MUTATED_DOM_EVENT_NAME, {
	          detail: updatedParts
	        });
	      }

	      propagatingLocally = true;
	      dispatchEvent(event_1);
	      propagatingLocally = false;
	    }
	  });
	  addEventListener(STORAGE_MUTATED_DOM_EVENT_NAME, function (_a) {
	    var detail = _a.detail;

	    if (!propagatingLocally) {
	      propagateLocally(detail);
	    }
	  });
	}

	function propagateLocally(updateParts) {
	  var wasMe = propagatingLocally;

	  try {
	    propagatingLocally = true;
	    globalEvents.storagemutated.fire(updateParts);
	  } finally {
	    propagatingLocally = wasMe;
	  }
	}

	var propagatingLocally = false;

	if (typeof BroadcastChannel !== 'undefined') {
	  var bc_1 = new BroadcastChannel(STORAGE_MUTATED_DOM_EVENT_NAME);
	  globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, function (changedParts) {
	    if (!propagatingLocally) {
	      bc_1.postMessage(changedParts);
	    }
	  });

	  bc_1.onmessage = function (ev) {
	    if (ev.data) propagateLocally(ev.data);
	  };
	} else if (typeof self !== 'undefined' && typeof navigator !== 'undefined') {
	  globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, function (changedParts) {
	    try {
	      if (!propagatingLocally) {
	        if (typeof localStorage !== 'undefined') {
	          localStorage.setItem(STORAGE_MUTATED_DOM_EVENT_NAME, JSON.stringify({
	            trig: Math.random(),
	            changedParts: changedParts
	          }));
	        }

	        if (babelHelpers["typeof"](self['clients']) === 'object') {
	          __spreadArray([], self['clients'].matchAll({
	            includeUncontrolled: true
	          }), true).forEach(function (client) {
	            return client.postMessage({
	              type: STORAGE_MUTATED_DOM_EVENT_NAME,
	              changedParts: changedParts
	            });
	          });
	        }
	      }
	    } catch (_a) {}
	  });

	  if (typeof addEventListener !== 'undefined') {
	    addEventListener('storage', function (ev) {
	      if (ev.key === STORAGE_MUTATED_DOM_EVENT_NAME) {
	        var data = JSON.parse(ev.newValue);
	        if (data) propagateLocally(data.changedParts);
	      }
	    });
	  }

	  var swContainer = self.document && navigator.serviceWorker;

	  if (swContainer) {
	    swContainer.addEventListener('message', propagateMessageLocally);
	  }
	}

	function propagateMessageLocally(_a) {
	  var data = _a.data;

	  if (data && data.type === STORAGE_MUTATED_DOM_EVENT_NAME) {
	    propagateLocally(data.changedParts);
	  }
	}

	DexiePromise.rejectionMapper = mapError;
	setDebug(debug, dexieStackFrameFilter); // backward compatibility with Dexie 2 usages

	window.BX.Dexie = Dexie$1;

	exports.Dexie = Dexie$1;
	exports.liveQuery = liveQuery;
	exports.RangeSet = RangeSet;
	exports.mergeRanges = mergeRanges;
	exports.rangesOverlap = rangesOverlap;

}((this.BX.Dexie3 = this.BX.Dexie3 || {})));





// file: /bitrix/js/main/md5/dist/md5.bundle.js
(function (exports) {
  'use strict';

  /**
   * [js-md5]{@link https://github.com/emn178/js-md5}
   *
   * @namespace md5
   * @version 0.7.3
   * @author Chen, Yi-Cyuan [emn178@gmail.com]
   * @copyright Chen, Yi-Cyuan 2014-2017
   * @license MIT
   */

  /**
   * Modify list for integration with Bitrix Framework:
   * - removed integration with third-party package builders;
   * - add import & export for work in Bitrix CoreJS extensions;
   */

  /**
   * @method md5
   * @description Md5 hash function, export to global in browsers.
   * @param {String|Array|Uint8Array|ArrayBuffer} message message to hash
   * @returns {String} md5 hashes
   * @example
   * md5(''); // d41d8cd98f00b204e9800998ecf8427e
   * md5('The quick brown fox jumps over the lazy dog'); // 9e107d9d372bb6826bd81d3542a419d6
   * md5('The quick brown fox jumps over the lazy dog.'); // e4d909c290d0fb1ca068ffaddf22cbd0
   *
   * // It also supports UTF-8 encoding
   * md5('??'); // a7bac2239fcdcb3a067903d8077c4a07
   *
   * // It also supports byte `Array`, `Uint8Array`, `ArrayBuffer`
   * md5([]); // d41d8cd98f00b204e9800998ecf8427e
   * md5(new Uint8Array([])); // d41d8cd98f00b204e9800998ecf8427e
   */
  var md5 = function () {

    var ERROR = 'input is invalid type';
    var WINDOW = (typeof window === "undefined" ? "undefined" : babelHelpers.typeof(window)) === 'object';
    var root = WINDOW ? window : {};

    if (root.JS_MD5_NO_WINDOW) {
      WINDOW = false;
    }

    var WEB_WORKER = !WINDOW && (typeof self === "undefined" ? "undefined" : babelHelpers.typeof(self)) === 'object';
    var NODE_JS = !root.JS_MD5_NO_NODE_JS && (typeof process === "undefined" ? "undefined" : babelHelpers.typeof(process)) === 'object' && process.versions && process.versions.node;

    if (NODE_JS) {
      root = global;
    } else if (WEB_WORKER) {
      root = self;
    }

    var COMMON_JS = !root.JS_MD5_NO_COMMON_JS && (typeof module === "undefined" ? "undefined" : babelHelpers.typeof(module)) === 'object' && module.exports;
    var AMD = typeof define === 'function' && define.amd;
    var ARRAY_BUFFER = !root.JS_MD5_NO_ARRAY_BUFFER && typeof ArrayBuffer !== 'undefined';
    var HEX_CHARS = '0123456789abcdef'.split('');
    var EXTRA = [128, 32768, 8388608, -2147483648];
    var SHIFT = [0, 8, 16, 24];
    var OUTPUT_TYPES = ['hex', 'array', 'digest', 'buffer', 'arrayBuffer', 'base64'];
    var BASE64_ENCODE_CHAR = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');
    var blocks = [],
        buffer8;

    if (ARRAY_BUFFER) {
      var buffer = new ArrayBuffer(68);
      buffer8 = new Uint8Array(buffer);
      blocks = new Uint32Array(buffer);
    }

    if (root.JS_MD5_NO_NODE_JS || !Array.isArray) {
      Array.isArray = function (obj) {
        return Object.prototype.toString.call(obj) === '[object Array]';
      };
    }

    if (ARRAY_BUFFER && (root.JS_MD5_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
      ArrayBuffer.isView = function (obj) {
        return babelHelpers.typeof(obj) === 'object' && obj.buffer && obj.buffer.constructor === ArrayBuffer;
      };
    }
    /**
     * @method hex
     * @memberof md5
     * @description Output hash as hex string
     * @param {String|Array|Uint8Array|ArrayBuffer} message message to hash
     * @returns {String} Hex string
     * @example
     * md5.hex('The quick brown fox jumps over the lazy dog');
     * // equal to
     * md5('The quick brown fox jumps over the lazy dog');
     */

    /**
     * @method digest
     * @memberof md5
     * @description Output hash as bytes array
     * @param {String|Array|Uint8Array|ArrayBuffer} message message to hash
     * @returns {Array} Bytes array
     * @example
     * md5.digest('The quick brown fox jumps over the lazy dog');
     */

    /**
     * @method array
     * @memberof md5
     * @description Output hash as bytes array
     * @param {String|Array|Uint8Array|ArrayBuffer} message message to hash
     * @returns {Array} Bytes array
     * @example
     * md5.array('The quick brown fox jumps over the lazy dog');
     */

    /**
     * @method arrayBuffer
     * @memberof md5
     * @description Output hash as ArrayBuffer
     * @param {String|Array|Uint8Array|ArrayBuffer} message message to hash
     * @returns {ArrayBuffer} ArrayBuffer
     * @example
     * md5.arrayBuffer('The quick brown fox jumps over the lazy dog');
     */

    /**
     * @method buffer
     * @deprecated This maybe confuse with Buffer in node.js. Please use arrayBuffer instead.
     * @memberof md5
     * @description Output hash as ArrayBuffer
     * @param {String|Array|Uint8Array|ArrayBuffer} message message to hash
     * @returns {ArrayBuffer} ArrayBuffer
     * @example
     * md5.buffer('The quick brown fox jumps over the lazy dog');
     */

    /**
     * @method base64
     * @memberof md5
     * @description Output hash as base64 string
     * @param {String|Array|Uint8Array|ArrayBuffer} message message to hash
     * @returns {String} base64 string
     * @example
     * md5.base64('The quick brown fox jumps over the lazy dog');
     */


    var createOutputMethod = function createOutputMethod(outputType) {
      return function (message) {
        return new Md5(true).update(message)[outputType]();
      };
    };
    /**
     * @method create
     * @memberof md5
     * @description Create Md5 object
     * @returns {Md5} Md5 object.
     * @example
     * var hash = md5.create();
     */

    /**
     * @method update
     * @memberof md5
     * @description Create and update Md5 object
     * @param {String|Array|Uint8Array|ArrayBuffer} message message to hash
     * @returns {Md5} Md5 object.
     * @example
     * var hash = md5.update('The quick brown fox jumps over the lazy dog');
     * // equal to
     * var hash = md5.create();
     * hash.update('The quick brown fox jumps over the lazy dog');
     */


    var createMethod = function createMethod() {
      var method = createOutputMethod('hex');

      if (NODE_JS) {
        method = nodeWrap(method);
      }

      method.create = function () {
        return new Md5();
      };

      method.update = function (message) {
        return method.create().update(message);
      };

      for (var i = 0; i < OUTPUT_TYPES.length; ++i) {
        var type = OUTPUT_TYPES[i];
        method[type] = createOutputMethod(type);
      }

      return method;
    };

    var nodeWrap = function nodeWrap(method) {
      var crypto = eval("require('crypto')");
      var Buffer = eval("require('buffer').Buffer");

      var nodeMethod = function nodeMethod(message) {
        if (typeof message === 'string') {
          return crypto.createHash('md5').update(message, 'utf8').digest('hex');
        } else {
          if (message === null || message === undefined) {
            throw ERROR;
          } else if (message.constructor === ArrayBuffer) {
            message = new Uint8Array(message);
          }
        }

        if (Array.isArray(message) || ArrayBuffer.isView(message) || message.constructor === Buffer) {
          return crypto.createHash('md5').update(new Buffer(message)).digest('hex');
        } else {
          return method(message);
        }
      };

      return nodeMethod;
    };
    /**
     * Md5 class
     * @class Md5
     * @description This is internal class.
     * @see {@link md5.create}
     */


    function Md5(sharedMemory) {
      if (sharedMemory) {
        blocks[0] = blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
        this.blocks = blocks;
        this.buffer8 = buffer8;
      } else {
        if (ARRAY_BUFFER) {
          var buffer = new ArrayBuffer(68);
          this.buffer8 = new Uint8Array(buffer);
          this.blocks = new Uint32Array(buffer);
        } else {
          this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        }
      }

      this.h0 = this.h1 = this.h2 = this.h3 = this.start = this.bytes = this.hBytes = 0;
      this.finalized = this.hashed = false;
      this.first = true;
    }
    /**
     * @method update
     * @memberof Md5
     * @instance
     * @description Update hash
     * @param {String|Array|Uint8Array|ArrayBuffer} message message to hash
     * @returns {Md5} Md5 object.
     * @see {@link md5.update}
     */


    Md5.prototype.update = function (message) {
      if (this.finalized) {
        return;
      }

      var notString,
          type = babelHelpers.typeof(message);

      if (type !== 'string') {
        if (type === 'object') {
          if (message === null) {
            throw ERROR;
          } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {
            message = new Uint8Array(message);
          } else if (!Array.isArray(message)) {
            if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {
              throw ERROR;
            }
          }
        } else {
          throw ERROR;
        }

        notString = true;
      }

      var code,
          index = 0,
          i,
          length = message.length,
          blocks = this.blocks;
      var buffer8 = this.buffer8;

      while (index < length) {
        if (this.hashed) {
          this.hashed = false;
          blocks[0] = blocks[16];
          blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
        }

        if (notString) {
          if (ARRAY_BUFFER) {
            for (i = this.start; index < length && i < 64; ++index) {
              buffer8[i++] = message[index];
            }
          } else {
            for (i = this.start; index < length && i < 64; ++index) {
              blocks[i >> 2] |= message[index] << SHIFT[i++ & 3];
            }
          }
        } else {
          if (ARRAY_BUFFER) {
            for (i = this.start; index < length && i < 64; ++index) {
              code = message.charCodeAt(index);

              if (code < 0x80) {
                buffer8[i++] = code;
              } else if (code < 0x800) {
                buffer8[i++] = 0xc0 | code >> 6;
                buffer8[i++] = 0x80 | code & 0x3f;
              } else if (code < 0xd800 || code >= 0xe000) {
                buffer8[i++] = 0xe0 | code >> 12;
                buffer8[i++] = 0x80 | code >> 6 & 0x3f;
                buffer8[i++] = 0x80 | code & 0x3f;
              } else {
                code = 0x10000 + ((code & 0x3ff) << 10 | message.charCodeAt(++index) & 0x3ff);
                buffer8[i++] = 0xf0 | code >> 18;
                buffer8[i++] = 0x80 | code >> 12 & 0x3f;
                buffer8[i++] = 0x80 | code >> 6 & 0x3f;
                buffer8[i++] = 0x80 | code & 0x3f;
              }
            }
          } else {
            for (i = this.start; index < length && i < 64; ++index) {
              code = message.charCodeAt(index);

              if (code < 0x80) {
                blocks[i >> 2] |= code << SHIFT[i++ & 3];
              } else if (code < 0x800) {
                blocks[i >> 2] |= (0xc0 | code >> 6) << SHIFT[i++ & 3];
                blocks[i >> 2] |= (0x80 | code & 0x3f) << SHIFT[i++ & 3];
              } else if (code < 0xd800 || code >= 0xe000) {
                blocks[i >> 2] |= (0xe0 | code >> 12) << SHIFT[i++ & 3];
                blocks[i >> 2] |= (0x80 | code >> 6 & 0x3f) << SHIFT[i++ & 3];
                blocks[i >> 2] |= (0x80 | code & 0x3f) << SHIFT[i++ & 3];
              } else {
                code = 0x10000 + ((code & 0x3ff) << 10 | message.charCodeAt(++index) & 0x3ff);
                blocks[i >> 2] |= (0xf0 | code >> 18) << SHIFT[i++ & 3];
                blocks[i >> 2] |= (0x80 | code >> 12 & 0x3f) << SHIFT[i++ & 3];
                blocks[i >> 2] |= (0x80 | code >> 6 & 0x3f) << SHIFT[i++ & 3];
                blocks[i >> 2] |= (0x80 | code & 0x3f) << SHIFT[i++ & 3];
              }
            }
          }
        }

        this.lastByteIndex = i;
        this.bytes += i - this.start;

        if (i >= 64) {
          this.start = i - 64;
          this.hash();
          this.hashed = true;
        } else {
          this.start = i;
        }
      }

      if (this.bytes > 4294967295) {
        this.hBytes += this.bytes / 4294967296 << 0;
        this.bytes = this.bytes % 4294967296;
      }

      return this;
    };

    Md5.prototype.finalize = function () {
      if (this.finalized) {
        return;
      }

      this.finalized = true;
      var blocks = this.blocks,
          i = this.lastByteIndex;
      blocks[i >> 2] |= EXTRA[i & 3];

      if (i >= 56) {
        if (!this.hashed) {
          this.hash();
        }

        blocks[0] = blocks[16];
        blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
      }

      blocks[14] = this.bytes << 3;
      blocks[15] = this.hBytes << 3 | this.bytes >>> 29;
      this.hash();
    };

    Md5.prototype.hash = function () {
      var a,
          b,
          c,
          d,
          bc,
          da,
          blocks = this.blocks;

      if (this.first) {
        a = blocks[0] - 680876937;
        a = (a << 7 | a >>> 25) - 271733879 << 0;
        d = (-1732584194 ^ a & 2004318071) + blocks[1] - 117830708;
        d = (d << 12 | d >>> 20) + a << 0;
        c = (-271733879 ^ d & (a ^ -271733879)) + blocks[2] - 1126478375;
        c = (c << 17 | c >>> 15) + d << 0;
        b = (a ^ c & (d ^ a)) + blocks[3] - 1316259209;
        b = (b << 22 | b >>> 10) + c << 0;
      } else {
        a = this.h0;
        b = this.h1;
        c = this.h2;
        d = this.h3;
        a += (d ^ b & (c ^ d)) + blocks[0] - 680876936;
        a = (a << 7 | a >>> 25) + b << 0;
        d += (c ^ a & (b ^ c)) + blocks[1] - 389564586;
        d = (d << 12 | d >>> 20) + a << 0;
        c += (b ^ d & (a ^ b)) + blocks[2] + 606105819;
        c = (c << 17 | c >>> 15) + d << 0;
        b += (a ^ c & (d ^ a)) + blocks[3] - 1044525330;
        b = (b << 22 | b >>> 10) + c << 0;
      }

      a += (d ^ b & (c ^ d)) + blocks[4] - 176418897;
      a = (a << 7 | a >>> 25) + b << 0;
      d += (c ^ a & (b ^ c)) + blocks[5] + 1200080426;
      d = (d << 12 | d >>> 20) + a << 0;
      c += (b ^ d & (a ^ b)) + blocks[6] - 1473231341;
      c = (c << 17 | c >>> 15) + d << 0;
      b += (a ^ c & (d ^ a)) + blocks[7] - 45705983;
      b = (b << 22 | b >>> 10) + c << 0;
      a += (d ^ b & (c ^ d)) + blocks[8] + 1770035416;
      a = (a << 7 | a >>> 25) + b << 0;
      d += (c ^ a & (b ^ c)) + blocks[9] - 1958414417;
      d = (d << 12 | d >>> 20) + a << 0;
      c += (b ^ d & (a ^ b)) + blocks[10] - 42063;
      c = (c << 17 | c >>> 15) + d << 0;
      b += (a ^ c & (d ^ a)) + blocks[11] - 1990404162;
      b = (b << 22 | b >>> 10) + c << 0;
      a += (d ^ b & (c ^ d)) + blocks[12] + 1804603682;
      a = (a << 7 | a >>> 25) + b << 0;
      d += (c ^ a & (b ^ c)) + blocks[13] - 40341101;
      d = (d << 12 | d >>> 20) + a << 0;
      c += (b ^ d & (a ^ b)) + blocks[14] - 1502002290;
      c = (c << 17 | c >>> 15) + d << 0;
      b += (a ^ c & (d ^ a)) + blocks[15] + 1236535329;
      b = (b << 22 | b >>> 10) + c << 0;
      a += (c ^ d & (b ^ c)) + blocks[1] - 165796510;
      a = (a << 5 | a >>> 27) + b << 0;
      d += (b ^ c & (a ^ b)) + blocks[6] - 1069501632;
      d = (d << 9 | d >>> 23) + a << 0;
      c += (a ^ b & (d ^ a)) + blocks[11] + 643717713;
      c = (c << 14 | c >>> 18) + d << 0;
      b += (d ^ a & (c ^ d)) + blocks[0] - 373897302;
      b = (b << 20 | b >>> 12) + c << 0;
      a += (c ^ d & (b ^ c)) + blocks[5] - 701558691;
      a = (a << 5 | a >>> 27) + b << 0;
      d += (b ^ c & (a ^ b)) + blocks[10] + 38016083;
      d = (d << 9 | d >>> 23) + a << 0;
      c += (a ^ b & (d ^ a)) + blocks[15] - 660478335;
      c = (c << 14 | c >>> 18) + d << 0;
      b += (d ^ a & (c ^ d)) + blocks[4] - 405537848;
      b = (b << 20 | b >>> 12) + c << 0;
      a += (c ^ d & (b ^ c)) + blocks[9] + 568446438;
      a = (a << 5 | a >>> 27) + b << 0;
      d += (b ^ c & (a ^ b)) + blocks[14] - 1019803690;
      d = (d << 9 | d >>> 23) + a << 0;
      c += (a ^ b & (d ^ a)) + blocks[3] - 187363961;
      c = (c << 14 | c >>> 18) + d << 0;
      b += (d ^ a & (c ^ d)) + blocks[8] + 1163531501;
      b = (b << 20 | b >>> 12) + c << 0;
      a += (c ^ d & (b ^ c)) + blocks[13] - 1444681467;
      a = (a << 5 | a >>> 27) + b << 0;
      d += (b ^ c & (a ^ b)) + blocks[2] - 51403784;
      d = (d << 9 | d >>> 23) + a << 0;
      c += (a ^ b & (d ^ a)) + blocks[7] + 1735328473;
      c = (c << 14 | c >>> 18) + d << 0;
      b += (d ^ a & (c ^ d)) + blocks[12] - 1926607734;
      b = (b << 20 | b >>> 12) + c << 0;
      bc = b ^ c;
      a += (bc ^ d) + blocks[5] - 378558;
      a = (a << 4 | a >>> 28) + b << 0;
      d += (bc ^ a) + blocks[8] - 2022574463;
      d = (d << 11 | d >>> 21) + a << 0;
      da = d ^ a;
      c += (da ^ b) + blocks[11] + 1839030562;
      c = (c << 16 | c >>> 16) + d << 0;
      b += (da ^ c) + blocks[14] - 35309556;
      b = (b << 23 | b >>> 9) + c << 0;
      bc = b ^ c;
      a += (bc ^ d) + blocks[1] - 1530992060;
      a = (a << 4 | a >>> 28) + b << 0;
      d += (bc ^ a) + blocks[4] + 1272893353;
      d = (d << 11 | d >>> 21) + a << 0;
      da = d ^ a;
      c += (da ^ b) + blocks[7] - 155497632;
      c = (c << 16 | c >>> 16) + d << 0;
      b += (da ^ c) + blocks[10] - 1094730640;
      b = (b << 23 | b >>> 9) + c << 0;
      bc = b ^ c;
      a += (bc ^ d) + blocks[13] + 681279174;
      a = (a << 4 | a >>> 28) + b << 0;
      d += (bc ^ a) + blocks[0] - 358537222;
      d = (d << 11 | d >>> 21) + a << 0;
      da = d ^ a;
      c += (da ^ b) + blocks[3] - 722521979;
      c = (c << 16 | c >>> 16) + d << 0;
      b += (da ^ c) + blocks[6] + 76029189;
      b = (b << 23 | b >>> 9) + c << 0;
      bc = b ^ c;
      a += (bc ^ d) + blocks[9] - 640364487;
      a = (a << 4 | a >>> 28) + b << 0;
      d += (bc ^ a) + blocks[12] - 421815835;
      d = (d << 11 | d >>> 21) + a << 0;
      da = d ^ a;
      c += (da ^ b) + blocks[15] + 530742520;
      c = (c << 16 | c >>> 16) + d << 0;
      b += (da ^ c) + blocks[2] - 995338651;
      b = (b << 23 | b >>> 9) + c << 0;
      a += (c ^ (b | ~d)) + blocks[0] - 198630844;
      a = (a << 6 | a >>> 26) + b << 0;
      d += (b ^ (a | ~c)) + blocks[7] + 1126891415;
      d = (d << 10 | d >>> 22) + a << 0;
      c += (a ^ (d | ~b)) + blocks[14] - 1416354905;
      c = (c << 15 | c >>> 17) + d << 0;
      b += (d ^ (c | ~a)) + blocks[5] - 57434055;
      b = (b << 21 | b >>> 11) + c << 0;
      a += (c ^ (b | ~d)) + blocks[12] + 1700485571;
      a = (a << 6 | a >>> 26) + b << 0;
      d += (b ^ (a | ~c)) + blocks[3] - 1894986606;
      d = (d << 10 | d >>> 22) + a << 0;
      c += (a ^ (d | ~b)) + blocks[10] - 1051523;
      c = (c << 15 | c >>> 17) + d << 0;
      b += (d ^ (c | ~a)) + blocks[1] - 2054922799;
      b = (b << 21 | b >>> 11) + c << 0;
      a += (c ^ (b | ~d)) + blocks[8] + 1873313359;
      a = (a << 6 | a >>> 26) + b << 0;
      d += (b ^ (a | ~c)) + blocks[15] - 30611744;
      d = (d << 10 | d >>> 22) + a << 0;
      c += (a ^ (d | ~b)) + blocks[6] - 1560198380;
      c = (c << 15 | c >>> 17) + d << 0;
      b += (d ^ (c | ~a)) + blocks[13] + 1309151649;
      b = (b << 21 | b >>> 11) + c << 0;
      a += (c ^ (b | ~d)) + blocks[4] - 145523070;
      a = (a << 6 | a >>> 26) + b << 0;
      d += (b ^ (a | ~c)) + blocks[11] - 1120210379;
      d = (d << 10 | d >>> 22) + a << 0;
      c += (a ^ (d | ~b)) + blocks[2] + 718787259;
      c = (c << 15 | c >>> 17) + d << 0;
      b += (d ^ (c | ~a)) + blocks[9] - 343485551;
      b = (b << 21 | b >>> 11) + c << 0;

      if (this.first) {
        this.h0 = a + 1732584193 << 0;
        this.h1 = b - 271733879 << 0;
        this.h2 = c - 1732584194 << 0;
        this.h3 = d + 271733878 << 0;
        this.first = false;
      } else {
        this.h0 = this.h0 + a << 0;
        this.h1 = this.h1 + b << 0;
        this.h2 = this.h2 + c << 0;
        this.h3 = this.h3 + d << 0;
      }
    };
    /**
     * @method hex
     * @memberof Md5
     * @instance
     * @description Output hash as hex string
     * @returns {String} Hex string
     * @see {@link md5.hex}
     * @example
     * hash.hex();
     */


    Md5.prototype.hex = function () {
      this.finalize();
      var h0 = this.h0,
          h1 = this.h1,
          h2 = this.h2,
          h3 = this.h3;
      return HEX_CHARS[h0 >> 4 & 0x0F] + HEX_CHARS[h0 & 0x0F] + HEX_CHARS[h0 >> 12 & 0x0F] + HEX_CHARS[h0 >> 8 & 0x0F] + HEX_CHARS[h0 >> 20 & 0x0F] + HEX_CHARS[h0 >> 16 & 0x0F] + HEX_CHARS[h0 >> 28 & 0x0F] + HEX_CHARS[h0 >> 24 & 0x0F] + HEX_CHARS[h1 >> 4 & 0x0F] + HEX_CHARS[h1 & 0x0F] + HEX_CHARS[h1 >> 12 & 0x0F] + HEX_CHARS[h1 >> 8 & 0x0F] + HEX_CHARS[h1 >> 20 & 0x0F] + HEX_CHARS[h1 >> 16 & 0x0F] + HEX_CHARS[h1 >> 28 & 0x0F] + HEX_CHARS[h1 >> 24 & 0x0F] + HEX_CHARS[h2 >> 4 & 0x0F] + HEX_CHARS[h2 & 0x0F] + HEX_CHARS[h2 >> 12 & 0x0F] + HEX_CHARS[h2 >> 8 & 0x0F] + HEX_CHARS[h2 >> 20 & 0x0F] + HEX_CHARS[h2 >> 16 & 0x0F] + HEX_CHARS[h2 >> 28 & 0x0F] + HEX_CHARS[h2 >> 24 & 0x0F] + HEX_CHARS[h3 >> 4 & 0x0F] + HEX_CHARS[h3 & 0x0F] + HEX_CHARS[h3 >> 12 & 0x0F] + HEX_CHARS[h3 >> 8 & 0x0F] + HEX_CHARS[h3 >> 20 & 0x0F] + HEX_CHARS[h3 >> 16 & 0x0F] + HEX_CHARS[h3 >> 28 & 0x0F] + HEX_CHARS[h3 >> 24 & 0x0F];
    };
    /**
     * @method toString
     * @memberof Md5
     * @instance
     * @description Output hash as hex string
     * @returns {String} Hex string
     * @see {@link md5.hex}
     * @example
     * hash.toString();
     */


    Md5.prototype.toString = Md5.prototype.hex;
    /**
     * @method digest
     * @memberof Md5
     * @instance
     * @description Output hash as bytes array
     * @returns {Array} Bytes array
     * @see {@link md5.digest}
     * @example
     * hash.digest();
     */

    Md5.prototype.digest = function () {
      this.finalize();
      var h0 = this.h0,
          h1 = this.h1,
          h2 = this.h2,
          h3 = this.h3;
      return [h0 & 0xFF, h0 >> 8 & 0xFF, h0 >> 16 & 0xFF, h0 >> 24 & 0xFF, h1 & 0xFF, h1 >> 8 & 0xFF, h1 >> 16 & 0xFF, h1 >> 24 & 0xFF, h2 & 0xFF, h2 >> 8 & 0xFF, h2 >> 16 & 0xFF, h2 >> 24 & 0xFF, h3 & 0xFF, h3 >> 8 & 0xFF, h3 >> 16 & 0xFF, h3 >> 24 & 0xFF];
    };
    /**
     * @method array
     * @memberof Md5
     * @instance
     * @description Output hash as bytes array
     * @returns {Array} Bytes array
     * @see {@link md5.array}
     * @example
     * hash.array();
     */


    Md5.prototype.array = Md5.prototype.digest;
    /**
     * @method arrayBuffer
     * @memberof Md5
     * @instance
     * @description Output hash as ArrayBuffer
     * @returns {ArrayBuffer} ArrayBuffer
     * @see {@link md5.arrayBuffer}
     * @example
     * hash.arrayBuffer();
     */

    Md5.prototype.arrayBuffer = function () {
      this.finalize();
      var buffer = new ArrayBuffer(16);
      var blocks = new Uint32Array(buffer);
      blocks[0] = this.h0;
      blocks[1] = this.h1;
      blocks[2] = this.h2;
      blocks[3] = this.h3;
      return buffer;
    };
    /**
     * @method buffer
     * @deprecated This maybe confuse with Buffer in node.js. Please use arrayBuffer instead.
     * @memberof Md5
     * @instance
     * @description Output hash as ArrayBuffer
     * @returns {ArrayBuffer} ArrayBuffer
     * @see {@link md5.buffer}
     * @example
     * hash.buffer();
     */


    Md5.prototype.buffer = Md5.prototype.arrayBuffer;
    /**
     * @method base64
     * @memberof Md5
     * @instance
     * @description Output hash as base64 string
     * @returns {String} base64 string
     * @see {@link md5.base64}
     * @example
     * hash.base64();
     */

    Md5.prototype.base64 = function () {
      var v1,
          v2,
          v3,
          base64Str = '',
          bytes = this.array();

      for (var i = 0; i < 15;) {
        v1 = bytes[i++];
        v2 = bytes[i++];
        v3 = bytes[i++];
        base64Str += BASE64_ENCODE_CHAR[v1 >>> 2] + BASE64_ENCODE_CHAR[(v1 << 4 | v2 >>> 4) & 63] + BASE64_ENCODE_CHAR[(v2 << 2 | v3 >>> 6) & 63] + BASE64_ENCODE_CHAR[v3 & 63];
      }

      v1 = bytes[i];
      base64Str += BASE64_ENCODE_CHAR[v1 >>> 2] + BASE64_ENCODE_CHAR[v1 << 4 & 63] + '==';
      return base64Str;
    };

    return createMethod();
  }();

  exports.md5 = md5;

}((this.BX = this.BX || {})));





// file: /bitrix/js/ui/vue/vuex/dist/vuex.bundle.js
;(function() {

	if (
		typeof this.BX !== 'undefined'
		&& typeof this.BX.WidgetVuex !== 'undefined'
	)
	{
		var currentVersion = '3.6.2';

		if (this.BX.WidgetVuex.version !== currentVersion)
		{
			console.warn('BX.WidgetVuex already loaded. Loaded: ' + this.BX.WidgetVuex.version + ', Skipped: ' + currentVersion + '. Version differences may cause errors!');
		}

		return;
	}

(function (exports,ui_vue,ui_dexie,main_md5) {
	'use strict';

	/**
	 * Bitrix Vuex wrapper
	 * IndexedDB driver for Vuex Builder
	 *
	 * @package bitrix
	 * @subpackage ui
	 * @copyright 2001-2019 Bitrix
	 */
	var VuexBuilderDatabaseIndexedDB = /*#__PURE__*/function () {
	  function VuexBuilderDatabaseIndexedDB() {
	    var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	    babelHelpers.classCallCheck(this, VuexBuilderDatabaseIndexedDB);
	    this.siteId = config.siteId || 'default';
	    this.userId = config.userId || 0;
	    this.storage = config.storage || 'default';
	    this.name = config.name || '';
	    this.code = (window.md5 || main_md5.md5)(this.siteId + '/' + this.userId + '/' + this.storage + '/' + this.name);
	    this.db = new ui_dexie.Dexie('bx-vuex-model');
	    this.db.version(1).stores({
	      data: "code, value"
	    });
	  }

	  babelHelpers.createClass(VuexBuilderDatabaseIndexedDB, [{
	    key: "get",
	    value: function get() {
	      var _this = this;

	      return new Promise(function (resolve, reject) {
	        _this.db.data.where('code').equals(_this.code).first().then(function (data) {
	          resolve(data ? data.value : null);
	        }, function (error) {
	          reject(error);
	        });
	      });
	    }
	  }, {
	    key: "set",
	    value: function set(value) {
	      var _this2 = this;

	      return new Promise(function (resolve, reject) {
	        _this2.db.data.put({
	          code: _this2.code,
	          value: value
	        }).then(function (data) {
	          resolve(true);
	        }, function (error) {
	          reject(error);
	        });
	      });
	    }
	  }, {
	    key: "clear",
	    value: function clear() {
	      var _this3 = this;

	      return new Promise(function (resolve, reject) {
	        _this3.db.data["delete"](_this3.code).then(function (data) {
	          resolve(true);
	        }, function (error) {
	          reject(error);
	        });
	      });
	    }
	  }]);
	  return VuexBuilderDatabaseIndexedDB;
	}();

	/**
	 * Bitrix Vuex wrapper
	 * LocalStorage driver for Vuex Builder
	 *
	 * @package bitrix
	 * @subpackage ui
	 * @copyright 2001-2019 Bitrix
	 */
	var VuexBuilderDatabaseLocalStorage = /*#__PURE__*/function () {
	  function VuexBuilderDatabaseLocalStorage() {
	    var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	    babelHelpers.classCallCheck(this, VuexBuilderDatabaseLocalStorage);
	    this.siteId = config.siteId || 'default';
	    this.userId = config.userId || 0;
	    this.storage = config.storage || 'default';
	    this.name = config.name || '';
	    this.enabled = false;

	    if (typeof window.localStorage !== 'undefined') {
	      try {
	        window.localStorage.setItem('__bx_test_ls_feature__', 'ok');

	        if (window.localStorage.getItem('__bx_test_ls_feature__') === 'ok') {
	          window.localStorage.removeItem('__bx_test_ls_feature__');
	          this.enabled = true;
	        }
	      } catch (e) {}
	    }

	    this.code = 'bx-vuex-' + (window.md5 || main_md5.md5)(this.siteId + '/' + this.userId + '/' + this.storage + '/' + this.name);
	  }

	  babelHelpers.createClass(VuexBuilderDatabaseLocalStorage, [{
	    key: "get",
	    value: function get() {
	      var _this = this;

	      return new Promise(function (resolve, reject) {
	        if (!_this.enabled) {
	          resolve(null);
	          return true;
	        }

	        var result = window.localStorage.getItem(_this.code);

	        if (typeof result !== "string") {
	          resolve(null);
	          return true;
	        }

	        try {
	          resolve(_this.prepareValueAfterGet(JSON.parse(result)));
	        } catch (error) {
	          reject(error);
	        }
	      });
	    }
	  }, {
	    key: "set",
	    value: function set(value) {
	      var _this2 = this;

	      return new Promise(function (resolve, reject) {
	        if (_this2.enabled) {
	          window.localStorage.setItem(_this2.code, JSON.stringify(_this2.prepareValueBeforeSet(value)));
	        }

	        resolve(true);
	      });
	    }
	  }, {
	    key: "clear",
	    value: function clear() {
	      var _this3 = this;

	      return new Promise(function (resolve, reject) {
	        if (_this3.enabled) {
	          window.localStorage.removeItem(_this3.code);
	        }

	        resolve(true);
	      });
	    }
	    /**
	     * @private
	     */

	  }, {
	    key: "prepareValueAfterGet",
	    value: function prepareValueAfterGet(value) {
	      var _this4 = this;

	      if (value instanceof Array) {
	        value = value.map(function (element) {
	          return _this4.prepareValueAfterGet(element);
	        });
	      } else if (value instanceof Date) ; else if (value && babelHelpers["typeof"](value) === 'object') {
	        for (var index in value) {
	          if (value.hasOwnProperty(index)) {
	            value[index] = this.prepareValueAfterGet(value[index]);
	          }
	        }
	      } else if (typeof value === 'string') {
	        if (value.startsWith('#DT#')) {
	          value = new Date(value.substring(4));
	        }
	      }

	      return value;
	    }
	    /**
	     * @private
	     */

	  }, {
	    key: "prepareValueBeforeSet",
	    value: function prepareValueBeforeSet(value) {
	      var _this5 = this;

	      if (value instanceof Array) {
	        value = value.map(function (element) {
	          return _this5.prepareValueBeforeSet(element);
	        });
	      } else if (value instanceof Date) {
	        value = '#DT#' + value.toISOString();
	      } else if (value && babelHelpers["typeof"](value) === 'object') {
	        for (var index in value) {
	          if (value.hasOwnProperty(index)) {
	            value[index] = this.prepareValueBeforeSet(value[index]);
	          }
	        }
	      }

	      return value;
	    }
	  }]);
	  return VuexBuilderDatabaseLocalStorage;
	}();

	/**
	 * Bitrix Vuex wrapper
	 * BitrixMobile ApplicationStorage driver for Vuex Builder
	 *
	 * @package bitrix
	 * @subpackage ui
	 * @copyright 2001-2019 Bitrix
	 */
	var VuexBuilderDatabaseJnSharedStorage = /*#__PURE__*/function () {
	  function VuexBuilderDatabaseJnSharedStorage() {
	    var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	    babelHelpers.classCallCheck(this, VuexBuilderDatabaseJnSharedStorage);
	    this.siteId = config.siteId || 'default';
	    this.userId = config.userId || 0;
	    this.storage = config.storage || 'default';
	    this.name = config.name || '';
	    this.code = (window.md5 || main_md5.md5)(this.siteId + '/' + this.userId + '/' + this.storage + '/' + this.name);

	    if (!this.isJnContext() && typeof ApplicationStorage === 'undefined') {
	      console.error('ApplicationStorage is not defined, load "webcomponent/storage" extension.');
	    }
	  }

	  babelHelpers.createClass(VuexBuilderDatabaseJnSharedStorage, [{
	    key: "get",
	    value: function get() {
	      var _this = this;

	      return new Promise(function (resolve, reject) {
	        if (_this.isJnContext()) {
	          var result = Application.sharedStorage.get(_this.code);
	          resolve(result ? result : null);
	        } else if (typeof ApplicationStorage !== 'undefined') {
	          ApplicationStorage.get(_this.code, null).then(function (data) {
	            return resolve(_this.prepareValueAfterGet(JSON.parse(data)));
	          });
	        } else {
	          resolve(null);
	        }
	      });
	    }
	  }, {
	    key: "set",
	    value: function set(value) {
	      var _this2 = this;

	      return new Promise(function (resolve, reject) {
	        if (_this2.isJnContext()) {
	          Application.sharedStorage().set(_this2.code, JSON.stringify(_this2.prepareValueBeforeSet(value)));
	          resolve();
	        } else if (typeof ApplicationStorage !== 'undefined') {
	          ApplicationStorage.set(_this2.code, JSON.stringify(_this2.prepareValueBeforeSet(value))).then(function (data) {
	            return resolve();
	          });
	        } else {
	          resolve();
	        }
	      });
	    }
	  }, {
	    key: "clear",
	    value: function clear() {
	      return this.set(null);
	    }
	    /**
	     * @private
	     */

	  }, {
	    key: "isJnContext",
	    value: function isJnContext() {
	      return typeof env !== 'undefined';
	    }
	    /**
	     * @private
	     */

	  }, {
	    key: "prepareValueAfterGet",
	    value: function prepareValueAfterGet(value) {
	      var _this3 = this;

	      if (value instanceof Array) {
	        value = value.map(function (element) {
	          return _this3.prepareValueAfterGet(element);
	        });
	      } else if (value instanceof Date) ; else if (value && babelHelpers["typeof"](value) === 'object') {
	        for (var index in value) {
	          if (value.hasOwnProperty(index)) {
	            value[index] = this.prepareValueAfterGet(value[index]);
	          }
	        }
	      } else if (typeof value === 'string') {
	        if (value.startsWith('#DT#')) {
	          value = new Date(value.substring(4));
	        }
	      }

	      return value;
	    }
	    /**
	     * @private
	     */

	  }, {
	    key: "prepareValueBeforeSet",
	    value: function prepareValueBeforeSet(value) {
	      var _this4 = this;

	      if (value instanceof Array) {
	        value = value.map(function (element) {
	          return _this4.prepareValueBeforeSet(element);
	        });
	      } else if (value instanceof Date) {
	        value = '#DT#' + value.toISOString();
	      } else if (value && babelHelpers["typeof"](value) === 'object') {
	        for (var index in value) {
	          if (value.hasOwnProperty(index)) {
	            value[index] = this.prepareValueBeforeSet(value[index]);
	          }
	        }
	      }

	      return value;
	    }
	  }]);
	  return VuexBuilderDatabaseJnSharedStorage;
	}();

	/**
	 * Bitrix Vuex wrapper
	 * Interface Vuex model (Vuex builder model)
	 *
	 * @package bitrix
	 * @subpackage ui
	 * @copyright 2001-2019 Bitrix
	 */
	var VuexBuilderModel$$1 = /*#__PURE__*/function () {
	  babelHelpers.createClass(VuexBuilderModel$$1, [{
	    key: "getName",

	    /**
	     * Get name of model
	     *
	     * @override
	     *
	     * @returns {String}
	     */
	    value: function getName() {
	      return '';
	    }
	    /**
	     * Get default state
	     *
	    	 * @override
	     *
	     * @returns {Object}
	     */

	  }, {
	    key: "getState",
	    value: function getState() {
	      return {};
	    }
	    /**
	     * Get default element state for models with collection.
	     *
	    	 * @override
	     *
	     * @returns {Object}
	     */

	  }, {
	    key: "getElementState",
	    value: function getElementState() {
	      return {};
	    }
	    /**
	     * Get object containing fields to exclude during the save to database.
	     *
	    	 * @override
	     *
	     * @returns {Object}
	     */

	  }, {
	    key: "getStateSaveException",
	    value: function getStateSaveException() {
	      return undefined;
	    }
	    /**
	     * Get getters
	     *
	    	 * @override
	     *
	     * @returns {Object}
	     */

	  }, {
	    key: "getGetters",
	    value: function getGetters() {
	      return {};
	    }
	    /**
	     * Get actions
	     *
	    	 * @override
	     *
	     * @returns {Object}
	     */

	  }, {
	    key: "getActions",
	    value: function getActions() {
	      return {};
	    }
	    /**
	     * Get mutations
	     *
	    	 * @override
	     *
	     * @returns {Object}
	     */

	  }, {
	    key: "getMutations",
	    value: function getMutations() {
	      return {};
	    }
	    /**
	     * Method for validation and sanitizing input fields before save in model
	     *
	     * @override
	     *
	     * @param fields {Object}
	     * @param options {Object}
	     *
	     * @returns {Object} - Sanitizing fields
	     */

	  }, {
	    key: "validate",
	    value: function validate(fields) {
	      return {};
	    }
	    /**
	     * Set external variable.
	     *
	     * @param variables {Object}
	     * @returns {VuexBuilderModel}
	     */

	  }, {
	    key: "setVariables",
	    value: function setVariables() {
	      var variables = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	      if (!(babelHelpers["typeof"](variables) === 'object' && variables)) {
	        this.logger('error', 'VuexBuilderModel.setVars: passed variables is not a Object', store);
	        return this;
	      }

	      this.variables = variables;
	      return this;
	    }
	  }, {
	    key: "getVariable",
	    value: function getVariable(name) {
	      var defaultValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

	      if (!name) {
	        return defaultValue;
	      }

	      var nameParts = name.toString().split('.');

	      if (nameParts.length === 1) {
	        return this.variables[nameParts[0]];
	      }

	      var result;
	      var variables = Object.assign({}, this.variables);

	      for (var i = 0; i < nameParts.length; i++) {
	        if (typeof variables[nameParts[i]] !== 'undefined') {
	          variables = result = variables[nameParts[i]];
	        } else {
	          result = defaultValue;
	          break;
	        }
	      }

	      return result;
	    }
	    /**
	     * Get namespace
	     *
	     * @returns {String}
	     */

	  }, {
	    key: "getNamespace",
	    value: function getNamespace() {
	      return this.namespace ? this.namespace : this.getName();
	    }
	    /**
	     * Set namespace
	     *
	     * @param name {String}
	     *
	     * @returns {VuexBuilderModel}
	     */

	  }, {
	    key: "setNamespace",
	    value: function setNamespace(name) {
	      this.namespace = name.toString();
	      this.databaseConfig.name = this.namespace;
	      return this;
	    }
	    /**
	     * Set database config for model or disable this feature.
	     *
	     * @param active {boolean}
	     * @param config {{name: String, siteId: String, userId: Number, type: VuexBuilder.DatabaseType}}
	     *
	     * @returns {VuexBuilderModel}
	     */

	  }, {
	    key: "useDatabase",
	    value: function useDatabase(active) {
	      var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	      this.databaseConfig.active = !!active;
	      var updateDriver = this.db === null;

	      if (config.type) {
	        this.databaseConfig.type = config.type.toString();
	        updateDriver = true;
	      }

	      if (config.storage) {
	        this.databaseConfig.storage = config.storage.toString();
	      }

	      if (config.siteId) {
	        this.databaseConfig.siteId = config.siteId.toString();
	      }

	      if (config.userId) {
	        this.databaseConfig.userId = config.userId;
	      }

	      if (typeof config.timeout === 'number') {
	        this.databaseConfig.timeout = config.timeout;
	      }

	      if (!this.databaseConfig.active && this.db !== null) {
	        this.databaseConfig.type = null;
	        updateDriver = true;
	      }

	      if (updateDriver) {
	        if (this.databaseConfig.type === VuexBuilder$$1.DatabaseType.indexedDb) {
	          this.db = new VuexBuilderDatabaseIndexedDB(this.databaseConfig);
	        } else if (this.databaseConfig.type === VuexBuilder$$1.DatabaseType.localStorage) {
	          this.db = new VuexBuilderDatabaseLocalStorage(this.databaseConfig);
	        } else if (this.databaseConfig.type === VuexBuilder$$1.DatabaseType.jnSharedStorage) {
	          this.db = new VuexBuilderDatabaseJnSharedStorage(this.databaseConfig);
	        } else {
	          this.db = null;
	        }
	      }

	      return this;
	    }
	    /**
	     * @returns {VuexBuilderModel}
	     * @deprecated
	     */

	  }, {
	    key: "useNamespace",
	    value: function useNamespace(active) {
	      if (ui_vue.WidgetBitrixVue.developerMode) {
	        if (active) {
	          console.warn('VuexBuilderModel: Method `useNamespace` is deprecated, please remove this call.');
	        } else {
	          console.error('VuexBuilderModel: Method `useNamespace` is deprecated, using VuexBuilder without namespaces is no longer supported.');
	        }
	      }

	      return this;
	    }
	    /**
	     * @returns {Promise}
	     * @deprecated use getModule instead.
	     */

	  }, {
	    key: "getStore",
	    value: function getStore() {
	      return this.getModule();
	    }
	    /**
	     * Get Vuex module.
	     *
	     * @returns {Promise}
	     */

	  }, {
	    key: "getModule",
	    value: function getModule() {
	      var _this = this;

	      return new Promise(function (resolve, reject) {
	        var namespace = _this.namespace ? _this.namespace : _this.getName();

	        if (!namespace) {
	          _this.logger('error', 'VuexBuilderModel.getStore: current model can not be run in Vuex modules mode', _this.getState());

	          reject();
	        }

	        if (_this.db) {
	          _this._getStoreFromDatabase().then(function (state) {
	            return resolve({
	              namespace: namespace,
	              module: _this._createStore(state)
	            });
	          });
	        } else {
	          resolve({
	            namespace: namespace,
	            module: _this._createStore(_this.getState())
	          });
	        }
	      });
	    }
	    /**
	     * Get default state of Vuex module.
	     *
	     * @returns {Object}
	     */

	  }, {
	    key: "getModuleWithDefaultState",
	    value: function getModuleWithDefaultState() {
	      var namespace = this.namespace ? this.namespace : this.getName();

	      if (!namespace) {
	        this.logger('error', 'VuexBuilderModel.getStore: current model can not be run in Vuex modules mode', this.getState());
	        return null;
	      }

	      return {
	        namespace: namespace,
	        module: this._createStore(this.getState())
	      };
	    }
	    /**
	     * Get timeout for save to database
	     *
	    	 * @override
	     *
	     * @returns {number}
	     */

	  }, {
	    key: "getSaveTimeout",
	    value: function getSaveTimeout() {
	      return 150;
	    }
	    /**
	     * Get timeout for load from database
	     *
	     * @override
	     *
	     * @returns {number|boolean}
	     */

	  }, {
	    key: "getLoadTimeout",
	    value: function getLoadTimeout() {
	      return 1000;
	    }
	    /**
	     * Get state after load from database
	     *
	    	 * @param state {Object}
	     *
	     * @override
	     *
	     * @returns {Object}
	     */

	  }, {
	    key: "getLoadedState",
	    value: function getLoadedState() {
	      var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	      return state;
	    }
	    /**
	     * Save current state after change state to database
	     *
	    	 * @param state {Object|function}
	     *
	     * @returns {Promise}
	     */

	  }, {
	    key: "saveState",
	    value: function saveState() {
	      var _this2 = this;

	      var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	      if (!this.isSaveAvailable()) {
	        return true;
	      }

	      this.lastSaveState = state;

	      if (this.saveStateTimeout) {
	        this.logger('log', 'VuexModel.saveState: wait save...', this.getName());
	        return true;
	      }

	      this.logger('log', 'VuexModel.saveState: start saving', this.getName());
	      var timeout = this.getSaveTimeout();

	      if (typeof this.databaseConfig.timeout === 'number') {
	        timeout = this.databaseConfig.timeout;
	      }

	      this.saveStateTimeout = setTimeout(function () {
	        _this2.logger('log', 'VuexModel.saveState: saved!', _this2.getName());

	        var lastState = _this2.lastSaveState;

	        if (typeof lastState === 'function') {
	          lastState = lastState();

	          if (babelHelpers["typeof"](lastState) !== 'object' || !lastState) {
	            return false;
	          }
	        }

	        _this2.db.set(_this2.cloneState(lastState, _this2.getStateSaveException()));

	        _this2.lastState = null;
	        _this2.saveStateTimeout = null;
	      }, timeout);
	      return true;
	    }
	    /**
	     * Reset current store to default state
	     **
	     * @returns {Promise}
	     */

	  }, {
	    key: "clearState",
	    value: function clearState() {
	      if (this.store) {
	        this.store.commit(this.getNamespace() + '/' + 'vuexBuilderModelClearState');
	        return true;
	      }

	      return this.saveState(this.getState());
	    }
	    /**
	     * Clear database only, store state does not change
	     **
	     * @returns {Promise}
	     */

	  }, {
	    key: "clearDatabase",
	    value: function clearDatabase() {
	      if (!this.isSaveAvailable()) {
	        return true;
	      }

	      this.db.clear();
	      return true;
	    }
	  }, {
	    key: "isSaveAvailable",
	    value: function isSaveAvailable() {
	      return this.db && this.databaseConfig.active;
	    }
	  }, {
	    key: "isSaveNeeded",
	    value: function isSaveNeeded(payload) {
	      if (!this.isSaveAvailable()) {
	        return false;
	      }

	      var checkFunction = function checkFunction(payload) {
	        var filter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

	        if (!filter) {
	          return true;
	        }

	        for (var field in payload) {
	          if (!payload.hasOwnProperty(field)) {
	            continue;
	          }

	          if (typeof filter[field] === 'undefined') {
	            return true;
	          } else if (babelHelpers["typeof"](filter[field]) === 'object' && filter[field]) {
	            var result = checkFunction(payload[field], filter[field]);

	            if (result) {
	              return true;
	            }
	          }
	        }

	        return false;
	      };

	      return checkFunction(payload, this.getStateSaveException());
	    }
	    /**
	     * Create new instance of model.
	     */

	  }], [{
	    key: "create",

	    /**
	     * Create new instance of model.
	     *
	     * @returns {VuexBuilderModel}
	     */
	    value: function create() {
	      return new this();
	    }
	  }]);

	  function VuexBuilderModel$$1() {
	    babelHelpers.classCallCheck(this, VuexBuilderModel$$1);
	    this.databaseConfig = {
	      type: VuexBuilder$$1.DatabaseType.indexedDb,
	      active: null,
	      storage: 'default',
	      name: this.getName(),
	      siteId: 'default',
	      userId: 0,
	      timeout: null
	    };
	    this.db = null;
	    this.store = null;
	    this.namespace = null;
	    this.variables = {};
	  }

	  babelHelpers.createClass(VuexBuilderModel$$1, [{
	    key: "setStore",
	    value: function setStore(store) {
	      if (!(store instanceof index.Store)) {
	        this.logger('error', 'VuexBuilderModel.setStore: passed store is not a Vuex.Store', store);
	        return this;
	      }

	      this.store = store;
	      return this;
	    }
	  }, {
	    key: "_getStoreFromDatabase",
	    value: function _getStoreFromDatabase() {
	      var _this3 = this;

	      clearTimeout(this.cacheTimeout);
	      return new Promise(function (resolve) {
	        var loadTimeout = _this3.getLoadTimeout();

	        if (loadTimeout !== false && typeof loadTimeout === 'number') {
	          _this3.cacheTimeout = setTimeout(function () {
	            _this3.logger('warn', 'VuexModel.getStoreFromDatabase: Cache loading timeout', _this3.getName());

	            resolve(_this3.getState());
	          }, loadTimeout);
	        } else {
	          _this3.cacheTimeout = null;
	        }

	        _this3.db.get().then(function (cache) {
	          clearTimeout(_this3.cacheTimeout);
	          cache = _this3.getLoadedState(cache ? cache : {});

	          var state = _this3.getState();

	          if (cache) {
	            state = _this3._mergeState(state, cache);
	          }

	          resolve(state);
	        }, function (error) {
	          clearTimeout(_this3.cacheTimeout);
	          resolve(_this3.getState());
	        });
	      });
	    }
	  }, {
	    key: "_mergeState",
	    value: function _mergeState(currentState, newState) {
	      for (var key in currentState) {
	        if (!currentState.hasOwnProperty(key)) {
	          continue;
	        }

	        if (typeof newState[key] === 'undefined') {
	          newState[key] = currentState[key];
	        } else if (!(newState[key] instanceof Array) && babelHelpers["typeof"](newState[key]) === 'object' && newState[key] && babelHelpers["typeof"](currentState[key]) === 'object' && currentState[key]) {
	          newState[key] = Object.assign({}, currentState[key], newState[key]);
	        }
	      }

	      return newState;
	    }
	  }, {
	    key: "_createStore",
	    value: function _createStore(state) {
	      var _this4 = this;

	      var result = {
	        namespaced: true,
	        state: state,
	        getters: this.getGetters(),
	        actions: this.getActions(),
	        mutations: this.getMutations()
	      };

	      result.mutations.vuexBuilderModelClearState = function (state) {
	        state = Object.assign(state, _this4.getState());

	        _this4.saveState(state);
	      };

	      return result;
	    }
	    /**
	     * Utils. Convert Object to Array
	     * @param object
	     * @returns {Array}
	     */

	  }, {
	    key: "cloneState",

	    /**
	     * Clone state without observers
	     * @param element {object}
	     * @param exceptions {object}
	     */
	    value: function cloneState(element) {
	      var _this5 = this;

	      var exceptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
	      var result;

	      if (element instanceof Array) {
	        result = [].concat(element.map(function (element) {
	          return _this5.cloneState(element);
	        }));
	      } else if (element instanceof Date) {
	        result = new Date(element.toISOString());
	      } else if (babelHelpers["typeof"](element) === 'object' && element) {
	        result = {};

	        for (var param in element) {
	          if (!element.hasOwnProperty(param)) {
	            continue;
	          }

	          if (typeof exceptions === 'undefined' || typeof exceptions[param] === 'undefined') {
	            result[param] = this.cloneState(element[param]);
	          } else if (babelHelpers["typeof"](exceptions[param]) === 'object' && exceptions[param]) {
	            result[param] = this.cloneState(element[param], exceptions[param]);
	          }
	        }
	      } else {
	        result = element;
	      }

	      return result;
	    }
	  }, {
	    key: "logger",
	    value: function logger(type) {
	      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	        args[_key - 1] = arguments[_key];
	      }

	      if (type === 'error') {
	        var _console;

	        (_console = console).error.apply(_console, args);

	        return undefined;
	      } else if (typeof BX.WidgetVueDevTools === 'undefined') {
	        return undefined;
	      }

	      if (type === 'log') {
	        var _console2;

	        (_console2 = console).log.apply(_console2, args);
	      } else if (type === 'info') {
	        var _console3;

	        (_console3 = console).info.apply(_console3, args);
	      } else if (type === 'warn') {
	        var _console4;

	        (_console4 = console).warn.apply(_console4, args);
	      }
	    }
	  }], [{
	    key: "convertToArray",
	    value: function convertToArray(object) {
	      var result = [];

	      for (var i in object) {
	        if (object.hasOwnProperty(i)) {
	          result.push(object[i]);
	        }
	      }

	      return result;
	    }
	  }]);
	  return VuexBuilderModel$$1;
	}();

	/**
	 * Bitrix Vuex wrapper
	 * Vuex builder
	 *
	 * @package bitrix
	 * @subpackage ui
	 * @copyright 2001-2019 Bitrix
	 */
	var DatabaseType = Object.freeze({
	  indexedDb: 'indexedDb',
	  localStorage: 'localStorage',
	  jnSharedStorage: 'jnSharedStorage'
	});
	var VuexBuilder$$1 = /*#__PURE__*/function () {
	  babelHelpers.createClass(VuexBuilder$$1, null, [{
	    key: "create",

	    /**
	     * @deprecated use init() method.
	     * @returns {VuexBuilder}
	     */
	    value: function create() {
	      if (ui_vue.WidgetBitrixVue.developerMode) {
	        console.warn('VuexBuilder: Method VuexBuilder.create is deprecated, use VuexBuilder.init instead.');
	      }

	      return new this();
	    }
	    /**
	     * Create new instance of builder and initialize Vuex store
	     *
	     * @param store {Vuex}
	     *
	     * @returns {VuexBuilder}
	     */

	  }, {
	    key: "init",
	    value: function init(store) {
	      if (store) {
	        if (!(store instanceof index.Store)) {
	          console.warn('VuexBuilder.init: passed store is not a Vuex.Store', store);
	          return new this();
	        }
	      }

	      return new this(store);
	    }
	  }]);

	  function VuexBuilder$$1(store) {
	    babelHelpers.classCallCheck(this, VuexBuilder$$1);
	    this.models = [];
	    this.databaseConfig = {
	      name: null,
	      type: null,
	      siteId: null,
	      userId: null,
	      timeout: null
	    };
	    this.store = store;
	    this.builded = false;
	  }
	  /**
	   * Add Vuex module.
	   *
	   * @param model {VuexBuilderModel}
	   *
	   * @returns {VuexBuilder}
	   */


	  babelHelpers.createClass(VuexBuilder$$1, [{
	    key: "addModel",
	    value: function addModel(model) {
	      if (this.builded) {
	        return this;
	      }

	      if (!(model instanceof VuexBuilderModel$$1)) {
	        console.error('BX.WidgetVuexBuilder.addModel: passed model is not a BX.WidgetVuexBuilderModel', model, name);
	        return this;
	      }

	      this.models.push(model);
	      return this;
	    }
	    /**
	     * Add dynamic Vuex module.
	     *
	     * @param model {VuexBuilderModel}
	     *
	     * @returns {Promise}
	     */

	  }, {
	    key: "addDynamicModel",
	    value: function addDynamicModel(model) {
	      var _this = this;

	      if (!(model instanceof VuexBuilderModel$$1)) {
	        return new Promise(function (resolve, reject) {
	          console.error('BX.WidgetVuexBuilder.addDynamicModel: passed model is not a BX.WidgetVuexBuilderModel', model);
	          reject('MODEL_ERROR');
	        });
	      }

	      if (this.store.hasModule(model.getNamespace()) || this.models.find(function (stored) {
	        return stored.getNamespace() === model.getNamespace();
	      })) {
	        return new Promise(function (resolve, reject) {
	          console.error('BX.WidgetVuexBuilder.addDynamicModel: model `' + model.getNamespace() + '` was not added because it is already registered.');
	          reject('DUPLICATE_MODEL');
	        });
	      }

	      this.models.push(model);

	      if (this.databaseConfig.active && model.databaseConfig.active !== false) {
	        model.useDatabase(true, this.databaseConfig);
	      } else {
	        model.useDatabase(false);
	      }

	      model.setStore(this.store);
	      var promise = model.getModule();
	      return new Promise(function (resolve, reject) {
	        promise.then(function (result) {
	          _this.store.registerModule(result.namespace, result.module);

	          resolve();
	        }, function (error) {
	          console.error('BX.WidgetVuexBuilder.addDynamicModel: storage was not created due to runtime errors.', error ? error : '');
	          reject('ERROR_IN_MODEL');
	        });
	      });
	    }
	    /**
	     * Remove dynamic Vuex module.
	     *
	     * @param namespace {string}
	     *
	     * @returns {VuexBuilder}
	     */

	  }, {
	    key: "removeDynamicModel",
	    value: function removeDynamicModel(namespace) {
	      if (!this.builded) {
	        console.error('BX.WidgetVuexBuilder.removeDynamicModel: you cannot use the method until builder is built.');
	        return this;
	      }

	      if (!this.store.hasModule(namespace)) {
	        console.error('BX.WidgetVuexBuilder.removeDynamicModel: module `' + namespace + '` not registered.');
	        return this;
	      }

	      this.models = this.models.filter(function (stored) {
	        return stored.getNamespace() !== namespace;
	      });
	      this.store.unregisterModule(namespace);
	      return this;
	    }
	    /**
	     * @returns {VuexBuilder}
	     * @deprecated
	     */

	  }, {
	    key: "useNamespace",
	    value: function useNamespace(active) {
	      if (ui_vue.WidgetBitrixVue.developerMode) {
	        if (active) {
	          console.warn('VuexBuilder: Method `useNamespace` is deprecated, please remove this call.');
	        } else {
	          console.error('VuexBuilder: Method `useNamespace` is deprecated, using VuexBuilder without namespaces is no longer supported.');
	        }
	      }

	      return this;
	    }
	    /**
	     * Set database config for all models (except models with "no database" option).
	     *
	     * @param config {{name: String, siteId: String, userId: Number, type: DatabaseType}}
	     * @returns {VuexBuilder}
	     */

	  }, {
	    key: "setDatabaseConfig",
	    value: function setDatabaseConfig() {
	      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	      if (!(babelHelpers["typeof"](config) === 'object' && config)) {
	        return this;
	      }

	      this.databaseConfig.active = true;
	      this.databaseConfig.storage = config.name;
	      this.databaseConfig.type = config.type || this.databaseConfig.type;
	      this.databaseConfig.siteId = config.siteId || this.databaseConfig.siteId;
	      this.databaseConfig.userId = config.userId || this.databaseConfig.userId;
	      this.databaseConfig.timeout = typeof config.timeout !== 'undefined' ? config.timeout : this.databaseConfig.timeout;
	      return this;
	    }
	  }, {
	    key: "clearModelState",
	    value: function clearModelState() {
	      var callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

	      if (!this.builded) {
	        return new Promise(function (resolve, reject) {
	          console.error('BX.WidgetVuexBuilder.clearModelState: you cannot use the method until builder is built.');

	          if (typeof callback !== 'function') {
	            reject('BUILDER_NOT_BUILD');
	          }
	        });
	      }

	      var results = [];
	      this.models.forEach(function (model) {
	        results.push(model.clearState());
	      });
	      return new Promise(function (resolve, reject) {
	        Promise.all(results).then(function (stores) {
	          resolve(true);

	          if (typeof callback === 'function') {
	            callback(true);
	          }
	        }, function (error) {
	          console.error('BX.WidgetVuexBuilder.clearModelState: storage was not clear due to runtime errors.', error ? error : '');

	          if (typeof callback !== 'function') {
	            reject('ERROR_WHILE_CLEARING');
	          }
	        });
	      });
	    }
	  }, {
	    key: "clearDatabase",
	    value: function clearDatabase() {
	      if (!this.builded) {
	        return new Promise(function (resolve, reject) {
	          console.error('BX.WidgetVuexBuilder.clearModelState: you cannot use the method until builder is built.');
	          reject('BUILDER_NOT_BUILD');
	        });
	      }

	      this.models.forEach(function (model) {
	        return model.clearDatabase();
	      });
	      return new Promise(function (resolve, reject) {
	        return resolve(true);
	      });
	    }
	    /**
	     * Build Vuex Store asynchronously
	     *
	     * @param callback {Function|null}
	     * @returns {Promise<any>}
	     */

	  }, {
	    key: "build",
	    value: function build() {
	      var _this2 = this;

	      var callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

	      if (this.builded) {
	        return this;
	      }

	      var promises = [];

	      if (!this.store) {
	        this.store = index.createStore();
	      }

	      this.models.forEach(function (model) {
	        if (_this2.databaseConfig.active && model.databaseConfig.active !== false) {
	          model.useDatabase(true, _this2.databaseConfig);
	        }

	        model.setStore(_this2.store);
	        promises.push(model.getModule());
	      });
	      return new Promise(function (resolve, reject) {
	        Promise.all(promises).then(function (modules) {
	          modules.forEach(function (result) {
	            _this2.store.registerModule(result.namespace, result.module);
	          });
	          var result = {
	            store: _this2.store,
	            models: _this2.models,
	            builder: _this2
	          };
	          _this2.builded = true;

	          if (typeof callback === 'function') {
	            callback(result);
	          }

	          resolve(result);
	        }, function (error) {
	          console.error('BX.WidgetVuexBuilder.create: storage was not created due to runtime errors.', error ? error : '');

	          if (typeof callback !== 'function') {
	            reject('ERROR_IN_MODEL');
	          }
	        });
	      });
	    }
	    /**
	     * Build Vuex Store synchronously
	     *
	     * @returns {Object<any>}
	     */

	  }, {
	    key: "syncBuild",
	    value: function syncBuild() {
	      var _this3 = this;

	      if (this.builded) {
	        return {
	          store: this.store,
	          models: this.models,
	          builder: this
	        };
	      }

	      if (!this.store) {
	        this.store = index.createStore();
	      }

	      if (this.databaseConfig.active) {
	        if (ui_vue.WidgetBitrixVue.developerMode) {
	          console.error('VuexBuilder: Method `syncBuild` creates storage in synchronous mode, the database does not work in this mode.');
	        }

	        this.databaseConfig.active = false;
	      }

	      this.models.forEach(function (model) {
	        model.useDatabase(false);
	        model.setStore(_this3.store);

	        var _model$getModuleWithD = model.getModuleWithDefaultState(),
	            namespace = _model$getModuleWithD.namespace,
	            module = _model$getModuleWithD.module;

	        _this3.store.registerModule(namespace, module);
	      });
	      this.builded = true;
	      return {
	        store: this.store,
	        models: this.models,
	        builder: this
	      };
	    }
	  }]);
	  return VuexBuilder$$1;
	}();
	VuexBuilder$$1.DatabaseType = DatabaseType;

	/*!
	 * vuex v3.6.2
	 * (c) 2021 Evan You
	 * @license MIT
	 *
	 * @source: https://cdn.jsdelivr.net/npm/vuex@3.6.2/dist/vuex.esm.browser.js
	 */

	function applyMixin(Vue) {
	  var version = Number(Vue.version.split('.')[0]);

	  if (version >= 2) {
	    Vue.mixin({
	      beforeCreate: vuexInit
	    });
	  } else {
	    // override init and inject vuex init procedure
	    // for 1.x backwards compatibility.
	    var _init = Vue.prototype._init;

	    Vue.prototype._init = function () {
	      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	      options.init = options.init ? [vuexInit].concat(options.init) : vuexInit;

	      _init.call(this, options);
	    };
	  }
	  /**
	   * Vuex init hook, injected into each instances init hooks list.
	   */


	  function vuexInit() {
	    var options = this.$options; // store injection

	    if (options.store) {
	      this.$store = typeof options.store === 'function' ? options.store() : options.store;
	    } else if (options.parent && options.parent.$store) {
	      this.$store = options.parent.$store;
	    }
	  }
	}

	var target = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : {};
	var devtoolHook = target.__VUE_DEVTOOLS_GLOBAL_HOOK__;

	function devtoolPlugin(store) {
	  if (!devtoolHook) return;
	  store._devtoolHook = devtoolHook;
	  devtoolHook.emit('vuex:init', store);
	  devtoolHook.on('vuex:travel-to-state', function (targetState) {
	    store.replaceState(targetState);
	  });
	  store.subscribe(function (mutation, state) {
	    devtoolHook.emit('vuex:mutation', mutation, state);
	  }, {
	    prepend: true
	  });
	  store.subscribeAction(function (action, state) {
	    devtoolHook.emit('vuex:action', action, state);
	  }, {
	    prepend: true
	  });
	}
	/**
	 * Get the first item that pass the test
	 * by second argument function
	 *
	 * @param {Array} list
	 * @param {Function} f
	 * @return {*}
	 */


	function find(list, f) {
	  return list.filter(f)[0];
	}
	/**
	 * Deep copy the given object considering circular structure.
	 * This function caches all nested objects and its copies.
	 * If it detects circular structure, use cached copy to avoid infinite loop.
	 *
	 * @param {*} obj
	 * @param {Array<Object>} cache
	 * @return {*}
	 */


	function deepCopy(obj) {
	  var cache = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

	  // just return if obj is immutable value
	  if (obj === null || babelHelpers["typeof"](obj) !== 'object') {
	    return obj;
	  } // if obj is hit, it is in circular structure


	  var hit = find(cache, function (c) {
	    return c.original === obj;
	  });

	  if (hit) {
	    return hit.copy;
	  }

	  var copy = Array.isArray(obj) ? [] : {}; // put the copy into cache at first
	  // because we want to refer it in recursive deepCopy

	  cache.push({
	    original: obj,
	    copy: copy
	  });
	  Object.keys(obj).forEach(function (key) {
	    copy[key] = deepCopy(obj[key], cache);
	  });
	  return copy;
	}
	/**
	 * forEach for object
	 */


	function forEachValue(obj, fn) {
	  Object.keys(obj).forEach(function (key) {
	    return fn(obj[key], key);
	  });
	}

	function isObject(obj) {
	  return obj !== null && babelHelpers["typeof"](obj) === 'object';
	}

	function isPromise(val) {
	  return val && typeof val.then === 'function';
	}

	function assert(condition, msg) {
	  if (!condition) throw new Error("[vuex] ".concat(msg));
	}

	function partial(fn, arg) {
	  return function () {
	    return fn(arg);
	  };
	} // Base data struct for store's module, package with some attribute and method


	var Module = /*#__PURE__*/function () {
	  function Module(rawModule, runtime) {
	    babelHelpers.classCallCheck(this, Module);
	    this.runtime = runtime; // Store some children item

	    this._children = Object.create(null); // Store the origin module object which passed by programmer

	    this._rawModule = rawModule;
	    var rawState = rawModule.state; // Store the origin module's state

	    this.state = (typeof rawState === 'function' ? rawState() : rawState) || {};
	  }

	  babelHelpers.createClass(Module, [{
	    key: "addChild",
	    value: function addChild(key, module) {
	      this._children[key] = module;
	    }
	  }, {
	    key: "removeChild",
	    value: function removeChild(key) {
	      delete this._children[key];
	    }
	  }, {
	    key: "getChild",
	    value: function getChild(key) {
	      return this._children[key];
	    }
	  }, {
	    key: "hasChild",
	    value: function hasChild(key) {
	      return key in this._children;
	    }
	  }, {
	    key: "update",
	    value: function update(rawModule) {
	      this._rawModule.namespaced = rawModule.namespaced;

	      if (rawModule.actions) {
	        this._rawModule.actions = rawModule.actions;
	      }

	      if (rawModule.mutations) {
	        this._rawModule.mutations = rawModule.mutations;
	      }

	      if (rawModule.getters) {
	        this._rawModule.getters = rawModule.getters;
	      }
	    }
	  }, {
	    key: "forEachChild",
	    value: function forEachChild(fn) {
	      forEachValue(this._children, fn);
	    }
	  }, {
	    key: "forEachGetter",
	    value: function forEachGetter(fn) {
	      if (this._rawModule.getters) {
	        forEachValue(this._rawModule.getters, fn);
	      }
	    }
	  }, {
	    key: "forEachAction",
	    value: function forEachAction(fn) {
	      if (this._rawModule.actions) {
	        forEachValue(this._rawModule.actions, fn);
	      }
	    }
	  }, {
	    key: "forEachMutation",
	    value: function forEachMutation(fn) {
	      if (this._rawModule.mutations) {
	        forEachValue(this._rawModule.mutations, fn);
	      }
	    }
	  }, {
	    key: "namespaced",
	    get: function get() {
	      return !!this._rawModule.namespaced;
	    }
	  }]);
	  return Module;
	}();

	var ModuleCollection = /*#__PURE__*/function () {
	  function ModuleCollection(rawRootModule) {
	    babelHelpers.classCallCheck(this, ModuleCollection);
	    // register root module (Vuex.Store options)
	    this.register([], rawRootModule, false);
	  }

	  babelHelpers.createClass(ModuleCollection, [{
	    key: "get",
	    value: function get(path) {
	      return path.reduce(function (module, key) {
	        return module.getChild(key);
	      }, this.root);
	    }
	  }, {
	    key: "getNamespace",
	    value: function getNamespace(path) {
	      var module = this.root;
	      return path.reduce(function (namespace, key) {
	        module = module.getChild(key);
	        return namespace + (module.namespaced ? key + '/' : '');
	      }, '');
	    }
	  }, {
	    key: "update",
	    value: function update(rawRootModule) {
	      _update([], this.root, rawRootModule);
	    }
	  }, {
	    key: "register",
	    value: function register(path, rawModule) {
	      var _this = this;

	      var runtime = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
	      {
	        assertRawModule(path, rawModule);
	      }
	      var newModule = new Module(rawModule, runtime);

	      if (path.length === 0) {
	        this.root = newModule;
	      } else {
	        var parent = this.get(path.slice(0, -1));
	        parent.addChild(path[path.length - 1], newModule);
	      } // register nested modules


	      if (rawModule.modules) {
	        forEachValue(rawModule.modules, function (rawChildModule, key) {
	          _this.register(path.concat(key), rawChildModule, runtime);
	        });
	      }
	    }
	  }, {
	    key: "unregister",
	    value: function unregister(path) {
	      var parent = this.get(path.slice(0, -1));
	      var key = path[path.length - 1];
	      var child = parent.getChild(key);

	      if (!child) {
	        {
	          console.warn("[vuex] trying to unregister module '".concat(key, "', which is ") + "not registered");
	        }
	        return;
	      }

	      if (!child.runtime) {
	        return;
	      }

	      parent.removeChild(key);
	    }
	  }, {
	    key: "isRegistered",
	    value: function isRegistered(path) {
	      var parent = this.get(path.slice(0, -1));
	      var key = path[path.length - 1];

	      if (parent) {
	        return parent.hasChild(key);
	      }

	      return false;
	    }
	  }]);
	  return ModuleCollection;
	}();

	function _update(path, targetModule, newModule) {
	  {
	    assertRawModule(path, newModule);
	  } // update target module

	  targetModule.update(newModule); // update nested modules

	  if (newModule.modules) {
	    for (var key in newModule.modules) {
	      if (!targetModule.getChild(key)) {
	        {
	          console.warn("[vuex] trying to add a new module '".concat(key, "' on hot reloading, ") + 'manual reload is needed');
	        }
	        return;
	      }

	      _update(path.concat(key), targetModule.getChild(key), newModule.modules[key]);
	    }
	  }
	}

	var functionAssert = {
	  assert: function assert(value) {
	    return typeof value === 'function';
	  },
	  expected: 'function'
	};
	var objectAssert = {
	  assert: function assert(value) {
	    return typeof value === 'function' || babelHelpers["typeof"](value) === 'object' && typeof value.handler === 'function';
	  },
	  expected: 'function or object with "handler" function'
	};
	var assertTypes = {
	  getters: functionAssert,
	  mutations: functionAssert,
	  actions: objectAssert
	};

	function assertRawModule(path, rawModule) {
	  Object.keys(assertTypes).forEach(function (key) {
	    if (!rawModule[key]) return;
	    var assertOptions = assertTypes[key];
	    forEachValue(rawModule[key], function (value, type) {
	      assert(assertOptions.assert(value), makeAssertionMessage(path, key, type, value, assertOptions.expected));
	    });
	  });
	}

	function makeAssertionMessage(path, key, type, value, expected) {
	  var buf = "".concat(key, " should be ").concat(expected, " but \"").concat(key, ".").concat(type, "\"");

	  if (path.length > 0) {
	    buf += " in module \"".concat(path.join('.'), "\"");
	  }

	  buf += " is ".concat(JSON.stringify(value), ".");
	  return buf;
	}

	var Store = /*#__PURE__*/function () {
	  function Store() {
	    var _this2 = this;

	    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	    babelHelpers.classCallCheck(this, Store);

	    // Auto install if it is not done yet and `window` has `Vue`.
	    // To allow users to avoid auto-installation in some cases,
	    // this code should be placed here. See #731
	    if (!ui_vue.WidgetVueVendor && typeof window !== 'undefined' && window.Vue) {
	      install(window.Vue);
	    }

	    {
	      assert(ui_vue.WidgetVueVendor, "must call Vue.use(Vuex) before creating a store instance.");
	      assert(typeof Promise !== 'undefined', "vuex requires a Promise polyfill in this browser.");
	      assert(this instanceof Store, "store must be called with the new operator.");
	    }
	    var _options$plugins = options.plugins,
	        plugins = _options$plugins === void 0 ? [] : _options$plugins,
	        _options$strict = options.strict,
	        strict = _options$strict === void 0 ? false : _options$strict; // store internal state

	    this._committing = false;
	    this._actions = Object.create(null);
	    this._actionSubscribers = [];
	    this._mutations = Object.create(null);
	    this._wrappedGetters = Object.create(null);
	    this._modules = new ModuleCollection(options);
	    this._modulesNamespaceMap = Object.create(null);
	    this._subscribers = [];
	    this._watcherVM = new ui_vue.WidgetVueVendor();
	    this._makeLocalGettersCache = Object.create(null); // bind commit and dispatch to self

	    var store = this;
	    var dispatch = this.dispatch,
	        commit = this.commit;

	    this.dispatch = function boundDispatch(type, payload) {
	      return dispatch.call(store, type, payload);
	    };

	    this.commit = function boundCommit(type, payload, options) {
	      return commit.call(store, type, payload, options);
	    }; // strict mode


	    this.strict = strict;
	    var state = this._modules.root.state; // init root module.
	    // this also recursively registers all sub-modules
	    // and collects all module getters inside this._wrappedGetters

	    installModule(this, state, [], this._modules.root); // initialize the store vm, which is responsible for the reactivity
	    // (also registers _wrappedGetters as computed properties)

	    resetStoreVM(this, state); // apply plugins

	    plugins.forEach(function (plugin) {
	      return plugin(_this2);
	    });
	    var useDevtools = options.devtools !== undefined ? options.devtools : ui_vue.WidgetVueVendor.config.devtools;

	    if (useDevtools) {
	      devtoolPlugin(this);
	    }
	  }

	  babelHelpers.createClass(Store, [{
	    key: "commit",
	    value: function commit(_type, _payload, _options) {
	      var _this3 = this;

	      // check object-style commit
	      var _unifyObjectStyle = unifyObjectStyle(_type, _payload, _options),
	          type = _unifyObjectStyle.type,
	          payload = _unifyObjectStyle.payload,
	          options = _unifyObjectStyle.options;

	      var mutation = {
	        type: type,
	        payload: payload
	      };
	      var entry = this._mutations[type];

	      if (!entry) {
	        {
	          console.error("[vuex] unknown mutation type: ".concat(type));
	        }
	        return;
	      }

	      this._withCommit(function () {
	        entry.forEach(function commitIterator(handler) {
	          handler(payload);
	        });
	      });

	      this._subscribers.slice() // shallow copy to prevent iterator invalidation if subscriber synchronously calls unsubscribe
	      .forEach(function (sub) {
	        return sub(mutation, _this3.state);
	      });

	      if (options && options.silent) {
	        console.warn("[vuex] mutation type: ".concat(type, ". Silent option has been removed. ") + 'Use the filter functionality in the vue-devtools');
	      }
	    }
	  }, {
	    key: "dispatch",
	    value: function dispatch(_type, _payload) {
	      var _this4 = this;

	      // check object-style dispatch
	      var _unifyObjectStyle2 = unifyObjectStyle(_type, _payload),
	          type = _unifyObjectStyle2.type,
	          payload = _unifyObjectStyle2.payload;

	      var action = {
	        type: type,
	        payload: payload
	      };
	      var entry = this._actions[type];

	      if (!entry) {
	        {
	          console.error("[vuex] unknown action type: ".concat(type));
	        }
	        return;
	      }

	      try {
	        this._actionSubscribers.slice() // shallow copy to prevent iterator invalidation if subscriber synchronously calls unsubscribe
	        .filter(function (sub) {
	          return sub.before;
	        }).forEach(function (sub) {
	          return sub.before(action, _this4.state);
	        });
	      } catch (e) {
	        {
	          console.warn("[vuex] error in before action subscribers: ");
	          console.error(e);
	        }
	      }

	      var result = entry.length > 1 ? Promise.all(entry.map(function (handler) {
	        return handler(payload);
	      })) : entry[0](payload);
	      return new Promise(function (resolve, reject) {
	        result.then(function (res) {
	          try {
	            _this4._actionSubscribers.filter(function (sub) {
	              return sub.after;
	            }).forEach(function (sub) {
	              return sub.after(action, _this4.state);
	            });
	          } catch (e) {
	            {
	              console.warn("[vuex] error in after action subscribers: ");
	              console.error(e);
	            }
	          }

	          resolve(res);
	        }, function (error) {
	          try {
	            _this4._actionSubscribers.filter(function (sub) {
	              return sub.error;
	            }).forEach(function (sub) {
	              return sub.error(action, _this4.state, error);
	            });
	          } catch (e) {
	            {
	              console.warn("[vuex] error in error action subscribers: ");
	              console.error(e);
	            }
	          }

	          reject(error);
	        });
	      });
	    }
	  }, {
	    key: "subscribe",
	    value: function subscribe(fn, options) {
	      return genericSubscribe(fn, this._subscribers, options);
	    }
	  }, {
	    key: "subscribeAction",
	    value: function subscribeAction(fn, options) {
	      var subs = typeof fn === 'function' ? {
	        before: fn
	      } : fn;
	      return genericSubscribe(subs, this._actionSubscribers, options);
	    }
	  }, {
	    key: "watch",
	    value: function watch(getter, cb, options) {
	      var _this5 = this;

	      {
	        assert(typeof getter === 'function', "store.watch only accepts a function.");
	      }
	      return this._watcherVM.$watch(function () {
	        return getter(_this5.state, _this5.getters);
	      }, cb, options);
	    }
	  }, {
	    key: "replaceState",
	    value: function replaceState(state) {
	      var _this6 = this;

	      this._withCommit(function () {
	        _this6._vm._data.$$state = state;
	      });
	    }
	  }, {
	    key: "registerModule",
	    value: function registerModule(path, rawModule) {
	      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
	      if (typeof path === 'string') path = [path];
	      {
	        assert(Array.isArray(path), "module path must be a string or an Array.");
	        assert(path.length > 0, 'cannot register the root module by using registerModule.');
	      }

	      this._modules.register(path, rawModule);

	      installModule(this, this.state, path, this._modules.get(path), options.preserveState); // reset store to update getters...

	      resetStoreVM(this, this.state);
	    }
	  }, {
	    key: "unregisterModule",
	    value: function unregisterModule(path) {
	      var _this7 = this;

	      if (typeof path === 'string') path = [path];
	      {
	        assert(Array.isArray(path), "module path must be a string or an Array.");
	      }

	      this._modules.unregister(path);

	      this._withCommit(function () {
	        var parentState = getNestedState(_this7.state, path.slice(0, -1));
	        ui_vue.WidgetVueVendor["delete"](parentState, path[path.length - 1]);
	      });

	      resetStore(this);
	    }
	  }, {
	    key: "hasModule",
	    value: function hasModule(path) {
	      if (typeof path === 'string') path = [path];
	      {
	        assert(Array.isArray(path), "module path must be a string or an Array.");
	      }
	      return this._modules.isRegistered(path);
	    }
	  }, {
	    key: "hotUpdate",
	    value: function hotUpdate(newOptions) {
	      this._modules.update(newOptions);

	      resetStore(this, true);
	    }
	  }, {
	    key: "_withCommit",
	    value: function _withCommit(fn) {
	      var committing = this._committing;
	      this._committing = true;
	      fn();
	      this._committing = committing;
	    }
	  }, {
	    key: "state",
	    get: function get() {
	      return this._vm._data.$$state;
	    },
	    set: function set(v) {
	      {
	        assert(false, "use store.replaceState() to explicit replace store state.");
	      }
	    }
	  }]);
	  return Store;
	}();

	function genericSubscribe(fn, subs, options) {
	  if (subs.indexOf(fn) < 0) {
	    options && options.prepend ? subs.unshift(fn) : subs.push(fn);
	  }

	  return function () {
	    var i = subs.indexOf(fn);

	    if (i > -1) {
	      subs.splice(i, 1);
	    }
	  };
	}

	function resetStore(store, hot) {
	  store._actions = Object.create(null);
	  store._mutations = Object.create(null);
	  store._wrappedGetters = Object.create(null);
	  store._modulesNamespaceMap = Object.create(null);
	  var state = store.state; // init all modules

	  installModule(store, state, [], store._modules.root, true); // reset vm

	  resetStoreVM(store, state, hot);
	}

	function resetStoreVM(store, state, hot) {
	  var oldVm = store._vm; // bind store public getters

	  store.getters = {}; // reset local getters cache

	  store._makeLocalGettersCache = Object.create(null);
	  var wrappedGetters = store._wrappedGetters;
	  var computed = {};
	  forEachValue(wrappedGetters, function (fn, key) {
	    // use computed to leverage its lazy-caching mechanism
	    // direct inline function use will lead to closure preserving oldVm.
	    // using partial to return function with only arguments preserved in closure environment.
	    computed[key] = partial(fn, store);
	    Object.defineProperty(store.getters, key, {
	      get: function get() {
	        return store._vm[key];
	      },
	      enumerable: true // for local getters

	    });
	  }); // use a Vue instance to store the state tree
	  // suppress warnings just in case the user has added
	  // some funky global mixins

	  var silent = ui_vue.WidgetVueVendor.config.silent;
	  ui_vue.WidgetVueVendor.config.silent = true;
	  store._vm = new ui_vue.WidgetVueVendor({
	    data: {
	      $$state: state
	    },
	    computed: computed
	  });
	  ui_vue.WidgetVueVendor.config.silent = silent; // enable strict mode for new vm

	  if (store.strict) {
	    enableStrictMode(store);
	  }

	  if (oldVm) {
	    if (hot) {
	      // dispatch changes in all subscribed watchers
	      // to force getter re-evaluation for hot reloading.
	      store._withCommit(function () {
	        oldVm._data.$$state = null;
	      });
	    }

	    ui_vue.WidgetVueVendor.nextTick(function () {
	      return oldVm.$destroy();
	    });
	  }
	}

	function installModule(store, rootState, path, module, hot) {
	  var isRoot = !path.length;

	  var namespace = store._modules.getNamespace(path); // register in namespace map


	  if (module.namespaced) {
	    if (store._modulesNamespaceMap[namespace] && true) {
	      console.error("[vuex] duplicate namespace ".concat(namespace, " for the namespaced module ").concat(path.join('/')));
	    }

	    store._modulesNamespaceMap[namespace] = module;
	  } // set state


	  if (!isRoot && !hot) {
	    var parentState = getNestedState(rootState, path.slice(0, -1));
	    var moduleName = path[path.length - 1];

	    store._withCommit(function () {
	      {
	        if (moduleName in parentState) {
	          console.warn("[vuex] state field \"".concat(moduleName, "\" was overridden by a module with the same name at \"").concat(path.join('.'), "\""));
	        }
	      }
	      ui_vue.WidgetVueVendor.set(parentState, moduleName, module.state);
	    });
	  }

	  var local = module.context = makeLocalContext(store, namespace, path);
	  module.forEachMutation(function (mutation, key) {
	    var namespacedType = namespace + key;
	    registerMutation(store, namespacedType, mutation, local);
	  });
	  module.forEachAction(function (action, key) {
	    var type = action.root ? key : namespace + key;
	    var handler = action.handler || action;
	    registerAction(store, type, handler, local);
	  });
	  module.forEachGetter(function (getter, key) {
	    var namespacedType = namespace + key;
	    registerGetter(store, namespacedType, getter, local);
	  });
	  module.forEachChild(function (child, key) {
	    installModule(store, rootState, path.concat(key), child, hot);
	  });
	}
	/**
	 * make localized dispatch, commit, getters and state
	 * if there is no namespace, just use root ones
	 */


	function makeLocalContext(store, namespace, path) {
	  var noNamespace = namespace === '';
	  var local = {
	    dispatch: noNamespace ? store.dispatch : function (_type, _payload, _options) {
	      var args = unifyObjectStyle(_type, _payload, _options);
	      var payload = args.payload,
	          options = args.options;
	      var type = args.type;

	      if (!options || !options.root) {
	        type = namespace + type;

	        if (!store._actions[type]) {
	          console.error("[vuex] unknown local action type: ".concat(args.type, ", global type: ").concat(type));
	          return;
	        }
	      }

	      return store.dispatch(type, payload);
	    },
	    commit: noNamespace ? store.commit : function (_type, _payload, _options) {
	      var args = unifyObjectStyle(_type, _payload, _options);
	      var payload = args.payload,
	          options = args.options;
	      var type = args.type;

	      if (!options || !options.root) {
	        type = namespace + type;

	        if (!store._mutations[type]) {
	          console.error("[vuex] unknown local mutation type: ".concat(args.type, ", global type: ").concat(type));
	          return;
	        }
	      }

	      store.commit(type, payload, options);
	    }
	  }; // getters and state object must be gotten lazily
	  // because they will be changed by vm update

	  Object.defineProperties(local, {
	    getters: {
	      get: noNamespace ? function () {
	        return store.getters;
	      } : function () {
	        return makeLocalGetters(store, namespace);
	      }
	    },
	    state: {
	      get: function get() {
	        return getNestedState(store.state, path);
	      }
	    }
	  });
	  return local;
	}

	function makeLocalGetters(store, namespace) {
	  if (!store._makeLocalGettersCache[namespace]) {
	    var gettersProxy = {};
	    var splitPos = namespace.length;
	    Object.keys(store.getters).forEach(function (type) {
	      // skip if the target getter is not match this namespace
	      if (type.slice(0, splitPos) !== namespace) return; // extract local getter type

	      var localType = type.slice(splitPos); // Add a port to the getters proxy.
	      // Define as getter property because
	      // we do not want to evaluate the getters in this time.

	      Object.defineProperty(gettersProxy, localType, {
	        get: function get() {
	          return store.getters[type];
	        },
	        enumerable: true
	      });
	    });
	    store._makeLocalGettersCache[namespace] = gettersProxy;
	  }

	  return store._makeLocalGettersCache[namespace];
	}

	function registerMutation(store, type, handler, local) {
	  var entry = store._mutations[type] || (store._mutations[type] = []);
	  entry.push(function wrappedMutationHandler(payload) {
	    handler.call(store, local.state, payload);
	  });
	}

	function registerAction(store, type, handler, local) {
	  var entry = store._actions[type] || (store._actions[type] = []);
	  entry.push(function wrappedActionHandler(payload) {
	    var res = handler.call(store, {
	      dispatch: local.dispatch,
	      commit: local.commit,
	      getters: local.getters,
	      state: local.state,
	      rootGetters: store.getters,
	      rootState: store.state
	    }, payload);

	    if (!isPromise(res)) {
	      res = Promise.resolve(res);
	    }

	    if (store._devtoolHook) {
	      return res["catch"](function (err) {
	        store._devtoolHook.emit('vuex:error', err);

	        throw err;
	      });
	    } else {
	      return res;
	    }
	  });
	}

	function registerGetter(store, type, rawGetter, local) {
	  if (store._wrappedGetters[type]) {
	    {
	      console.error("[vuex] duplicate getter key: ".concat(type));
	    }
	    return;
	  }

	  store._wrappedGetters[type] = function wrappedGetter(store) {
	    return rawGetter(local.state, // local state
	    local.getters, // local getters
	    store.state, // root state
	    store.getters // root getters
	    );
	  };
	}

	function enableStrictMode(store) {
	  store._vm.$watch(function () {
	    return this._data.$$state;
	  }, function () {
	    {
	      assert(store._committing, "do not mutate vuex store state outside mutation handlers.");
	    }
	  }, {
	    deep: true,
	    sync: true
	  });
	}

	function getNestedState(state, path) {
	  return path.reduce(function (state, key) {
	    return state[key];
	  }, state);
	}

	function unifyObjectStyle(type, payload, options) {
	  if (isObject(type) && type.type) {
	    options = payload;
	    payload = type;
	    type = type.type;
	  }

	  {
	    assert(typeof type === 'string', "expects string as the type, but found ".concat(babelHelpers["typeof"](type), "."));
	  }
	  return {
	    type: type,
	    payload: payload,
	    options: options
	  };
	}

	function install(_Vue) {
	  applyMixin(_Vue);
	}
	/**
	 * Reduce the code which written in Vue.js for getting the state.
	 * @param {String} [namespace] - Module's namespace
	 * @param {Object|Array} states # Object's item can be a function which accept state and getters for param, you can do something for state and getters in it.
	 * @param {Object}
	 */


	var mapState = normalizeNamespace(function (namespace, states) {
	  var res = {};

	  if (!isValidMap(states)) {
	    console.error('[vuex] mapState: mapper parameter must be either an Array or an Object');
	  }

	  normalizeMap(states).forEach(function (_ref) {
	    var key = _ref.key,
	        val = _ref.val;

	    res[key] = function mappedState() {
	      var state = this.$store.state;
	      var getters = this.$store.getters;

	      if (namespace) {
	        var module = getModuleByNamespace(this.$store, 'mapState', namespace);

	        if (!module) {
	          return;
	        }

	        state = module.context.state;
	        getters = module.context.getters;
	      }

	      return typeof val === 'function' ? val.call(this, state, getters) : state[val];
	    }; // mark vuex getter for devtools


	    res[key].vuex = true;
	  });
	  return res;
	});
	/**
	 * Reduce the code which written in Vue.js for committing the mutation
	 * @param {String} [namespace] - Module's namespace
	 * @param {Object|Array} mutations # Object's item can be a function which accept `commit` function as the first param, it can accept another params. You can commit mutation and do any other things in this function. specially, You need to pass anthor params from the mapped function.
	 * @return {Object}
	 */

	var mapMutations = normalizeNamespace(function (namespace, mutations) {
	  var res = {};

	  if (!isValidMap(mutations)) {
	    console.error('[vuex] mapMutations: mapper parameter must be either an Array or an Object');
	  }

	  normalizeMap(mutations).forEach(function (_ref2) {
	    var key = _ref2.key,
	        val = _ref2.val;

	    res[key] = function mappedMutation() {
	      // Get the commit method from store
	      var commit = this.$store.commit;

	      if (namespace) {
	        var module = getModuleByNamespace(this.$store, 'mapMutations', namespace);

	        if (!module) {
	          return;
	        }

	        commit = module.context.commit;
	      }

	      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
	        args[_key] = arguments[_key];
	      }

	      return typeof val === 'function' ? val.apply(this, [commit].concat(args)) : commit.apply(this.$store, [val].concat(args));
	    };
	  });
	  return res;
	});
	/**
	 * Reduce the code which written in Vue.js for getting the getters
	 * @param {String} [namespace] - Module's namespace
	 * @param {Object|Array} getters
	 * @return {Object}
	 */

	var mapGetters = normalizeNamespace(function (namespace, getters) {
	  var res = {};

	  if (!isValidMap(getters)) {
	    console.error('[vuex] mapGetters: mapper parameter must be either an Array or an Object');
	  }

	  normalizeMap(getters).forEach(function (_ref3) {
	    var key = _ref3.key,
	        val = _ref3.val;
	    // The namespace has been mutated by normalizeNamespace
	    val = namespace + val;

	    res[key] = function mappedGetter() {
	      if (namespace && !getModuleByNamespace(this.$store, 'mapGetters', namespace)) {
	        return;
	      }

	      if (!(val in this.$store.getters)) {
	        console.error("[vuex] unknown getter: ".concat(val));
	        return;
	      }

	      return this.$store.getters[val];
	    }; // mark vuex getter for devtools


	    res[key].vuex = true;
	  });
	  return res;
	});
	/**
	 * Reduce the code which written in Vue.js for dispatch the action
	 * @param {String} [namespace] - Module's namespace
	 * @param {Object|Array} actions # Object's item can be a function which accept `dispatch` function as the first param, it can accept anthor params. You can dispatch action and do any other things in this function. specially, You need to pass anthor params from the mapped function.
	 * @return {Object}
	 */

	var mapActions = normalizeNamespace(function (namespace, actions) {
	  var res = {};

	  if (!isValidMap(actions)) {
	    console.error('[vuex] mapActions: mapper parameter must be either an Array or an Object');
	  }

	  normalizeMap(actions).forEach(function (_ref4) {
	    var key = _ref4.key,
	        val = _ref4.val;

	    res[key] = function mappedAction() {
	      // get dispatch function from store
	      var dispatch = this.$store.dispatch;

	      if (namespace) {
	        var module = getModuleByNamespace(this.$store, 'mapActions', namespace);

	        if (!module) {
	          return;
	        }

	        dispatch = module.context.dispatch;
	      }

	      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
	        args[_key2] = arguments[_key2];
	      }

	      return typeof val === 'function' ? val.apply(this, [dispatch].concat(args)) : dispatch.apply(this.$store, [val].concat(args));
	    };
	  });
	  return res;
	});
	/**
	 * Rebinding namespace param for mapXXX function in special scoped, and return them by simple object
	 * @param {String} namespace
	 * @return {Object}
	 */

	var createNamespacedHelpers = function createNamespacedHelpers(namespace) {
	  return {
	    mapState: mapState.bind(null, namespace),
	    mapGetters: mapGetters.bind(null, namespace),
	    mapMutations: mapMutations.bind(null, namespace),
	    mapActions: mapActions.bind(null, namespace)
	  };
	};
	/**
	 * Normalize the map
	 * normalizeMap([1, 2, 3]) => [ { key: 1, val: 1 }, { key: 2, val: 2 }, { key: 3, val: 3 } ]
	 * normalizeMap({a: 1, b: 2, c: 3}) => [ { key: 'a', val: 1 }, { key: 'b', val: 2 }, { key: 'c', val: 3 } ]
	 * @param {Array|Object} map
	 * @return {Object}
	 */


	function normalizeMap(map) {
	  if (!isValidMap(map)) {
	    return [];
	  }

	  return Array.isArray(map) ? map.map(function (key) {
	    return {
	      key: key,
	      val: key
	    };
	  }) : Object.keys(map).map(function (key) {
	    return {
	      key: key,
	      val: map[key]
	    };
	  });
	}
	/**
	 * Validate whether given map is valid or not
	 * @param {*} map
	 * @return {Boolean}
	 */


	function isValidMap(map) {
	  return Array.isArray(map) || isObject(map);
	}
	/**
	 * Return a function expect two param contains namespace and map. it will normalize the namespace and then the param's function will handle the new namespace and the map.
	 * @param {Function} fn
	 * @return {Function}
	 */


	function normalizeNamespace(fn) {
	  return function (namespace, map) {
	    if (typeof namespace !== 'string') {
	      map = namespace;
	      namespace = '';
	    } else if (namespace.charAt(namespace.length - 1) !== '/') {
	      namespace += '/';
	    }

	    return fn(namespace, map);
	  };
	}
	/**
	 * Search a special module from store by namespace. if module not exist, print error message.
	 * @param {Object} store
	 * @param {String} helper
	 * @param {String} namespace
	 * @return {Object}
	 */


	function getModuleByNamespace(store, helper, namespace) {
	  var module = store._modulesNamespaceMap[namespace];

	  if (!module) {
	    console.error("[vuex] module namespace not found in ".concat(helper, "(): ").concat(namespace));
	  }

	  return module;
	} // Credits: borrowed code from fcomb/redux-logger


	function createLogger() {
	  var _ref5 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	      _ref5$collapsed = _ref5.collapsed,
	      collapsed = _ref5$collapsed === void 0 ? true : _ref5$collapsed,
	      _ref5$filter = _ref5.filter,
	      filter = _ref5$filter === void 0 ? function (mutation, stateBefore, stateAfter) {
	    return true;
	  } : _ref5$filter,
	      _ref5$transformer = _ref5.transformer,
	      transformer = _ref5$transformer === void 0 ? function (state) {
	    return state;
	  } : _ref5$transformer,
	      _ref5$mutationTransfo = _ref5.mutationTransformer,
	      mutationTransformer = _ref5$mutationTransfo === void 0 ? function (mut) {
	    return mut;
	  } : _ref5$mutationTransfo,
	      _ref5$actionFilter = _ref5.actionFilter,
	      actionFilter = _ref5$actionFilter === void 0 ? function (action, state) {
	    return true;
	  } : _ref5$actionFilter,
	      _ref5$actionTransform = _ref5.actionTransformer,
	      actionTransformer = _ref5$actionTransform === void 0 ? function (act) {
	    return act;
	  } : _ref5$actionTransform,
	      _ref5$logMutations = _ref5.logMutations,
	      logMutations = _ref5$logMutations === void 0 ? true : _ref5$logMutations,
	      _ref5$logActions = _ref5.logActions,
	      logActions = _ref5$logActions === void 0 ? true : _ref5$logActions,
	      _ref5$logger = _ref5.logger,
	      logger = _ref5$logger === void 0 ? console : _ref5$logger;

	  return function (store) {
	    var prevState = deepCopy(store.state);

	    if (typeof logger === 'undefined') {
	      return;
	    }

	    if (logMutations) {
	      store.subscribe(function (mutation, state) {
	        var nextState = deepCopy(state);

	        if (filter(mutation, prevState, nextState)) {
	          var formattedTime = getFormattedTime();
	          var formattedMutation = mutationTransformer(mutation);
	          var message = "mutation ".concat(mutation.type).concat(formattedTime);
	          startMessage(logger, message, collapsed);
	          logger.log('%c prev state', 'color: #9E9E9E; font-weight: bold', transformer(prevState));
	          logger.log('%c mutation', 'color: #03A9F4; font-weight: bold', formattedMutation);
	          logger.log('%c next state', 'color: #4CAF50; font-weight: bold', transformer(nextState));
	          endMessage(logger);
	        }

	        prevState = nextState;
	      });
	    }

	    if (logActions) {
	      store.subscribeAction(function (action, state) {
	        if (actionFilter(action, state)) {
	          var formattedTime = getFormattedTime();
	          var formattedAction = actionTransformer(action);
	          var message = "action ".concat(action.type).concat(formattedTime);
	          startMessage(logger, message, collapsed);
	          logger.log('%c action', 'color: #03A9F4; font-weight: bold', formattedAction);
	          endMessage(logger);
	        }
	      });
	    }
	  };
	}

	function startMessage(logger, message, collapsed) {
	  var startMessage = collapsed ? logger.groupCollapsed : logger.group; // render

	  try {
	    startMessage.call(logger, message);
	  } catch (e) {
	    logger.log(message);
	  }
	}

	function endMessage(logger) {
	  try {
	    logger.groupEnd();
	  } catch (e) {
	    logger.log('-- log end --');
	  }
	}

	function getFormattedTime() {
	  var time = new Date();
	  return " @ ".concat(pad(time.getHours(), 2), ":").concat(pad(time.getMinutes(), 2), ":").concat(pad(time.getSeconds(), 2), ".").concat(pad(time.getMilliseconds(), 3));
	}

	function repeat(str, times) {
	  return new Array(times + 1).join(str);
	}

	function pad(num, maxLength) {
	  return repeat('0', maxLength - num.toString().length) + num;
	}

	var index = {
	  Store: Store,
	  install: install,
	  version: '3.6.2',
	  mapState: mapState,
	  mapMutations: mapMutations,
	  mapGetters: mapGetters,
	  mapActions: mapActions,
	  createNamespacedHelpers: createNamespacedHelpers,
	  createLogger: createLogger
	}; // origin-end

	index.store = function (params) {
	  return new Store(params);
	};

	index.createStore = function (params) {
	  return new Store(params);
	};

	ui_vue.WidgetVueVendor.use(index);

	exports.WidgetVuexBuilder = VuexBuilder$$1;
	exports.WidgetVuexBuilderModel = VuexBuilderModel$$1;
	exports.WidgetVuex = index;
	exports.WidgetVuexVendorV3 = index;
	exports.WidgetVuexVendor = index;

}((this.BX = this.BX || {}),BX,BX.Dexie3,BX));



})();




// file: /bitrix/js/im/lib/logger/dist/logger.bundle.js
this.BX = this.BX || {};
this.BX.Messenger = this.BX.Messenger || {};
(function (exports) {
	'use strict';

	function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
	function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { babelHelpers.defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
	function _classPrivateFieldInitSpec(obj, privateMap, value) { _checkPrivateRedeclaration(obj, privateMap); privateMap.set(obj, value); }
	function _checkPrivateRedeclaration(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError("Cannot initialize the same private elements twice on an object"); } }
	var _types = /*#__PURE__*/new WeakMap();
	var _config = /*#__PURE__*/new WeakMap();
	var _custom = /*#__PURE__*/new WeakMap();
	/**
	 * Bitrix Messenger
	 * Logger class
	 *
	 * @package bitrix
	 * @subpackage im
	 * @copyright 2001-2019 Bitrix
	 */
	var Logger = /*#__PURE__*/function () {
	  function Logger() {
	    babelHelpers.classCallCheck(this, Logger);
	    _classPrivateFieldInitSpec(this, _types, {
	      writable: true,
	      value: {}
	    });
	    _classPrivateFieldInitSpec(this, _config, {
	      writable: true,
	      value: {}
	    });
	    _classPrivateFieldInitSpec(this, _custom, {
	      writable: true,
	      value: {}
	    });
	    babelHelpers.classPrivateFieldSet(this, _types, {
	      desktop: true,
	      log: false,
	      info: false,
	      warn: false,
	      error: true,
	      trace: true
	    });
	    babelHelpers.classPrivateFieldSet(this, _config, babelHelpers.classPrivateFieldGet(this, _types));
	    this.__load();
	  }
	  babelHelpers.createClass(Logger, [{
	    key: "setConfig",
	    value: function setConfig(types) {
	      for (var type in types) {
	        if (types.hasOwnProperty(type) && typeof babelHelpers.classPrivateFieldGet(this, _types)[type] !== 'undefined') {
	          babelHelpers.classPrivateFieldGet(this, _types)[type] = !!types[type];
	          babelHelpers.classPrivateFieldGet(this, _config)[type] = !!types[type];
	        }
	      }
	      this.__load();
	    }
	  }, {
	    key: "enable",
	    value: function enable(type) {
	      if (typeof babelHelpers.classPrivateFieldGet(this, _types)[type] === 'undefined') {
	        return false;
	      }
	      babelHelpers.classPrivateFieldGet(this, _types)[type] = true;
	      babelHelpers.classPrivateFieldGet(this, _custom)[type] = true;
	      this.__save();
	      return true;
	    }
	  }, {
	    key: "disable",
	    value: function disable(type) {
	      if (typeof babelHelpers.classPrivateFieldGet(this, _types)[type] === 'undefined') {
	        return false;
	      }
	      babelHelpers.classPrivateFieldGet(this, _types)[type] = false;
	      babelHelpers.classPrivateFieldGet(this, _custom)[type] = false;
	      this.__save();
	      return true;
	    }
	  }, {
	    key: "isEnabled",
	    value: function isEnabled(type) {
	      return babelHelpers.classPrivateFieldGet(this, _types)[type] === true;
	    }
	  }, {
	    key: "desktop",
	    value: function desktop() {
	      if (this.isEnabled('desktop')) {
	        var _console;
	        for (var _len = arguments.length, params = new Array(_len), _key = 0; _key < _len; _key++) {
	          params[_key] = arguments[_key];
	        }
	        (_console = console).log.apply(_console, [].concat(babelHelpers.toConsumableArray(this.__getStyles('desktop')), params));
	      }
	    }
	  }, {
	    key: "log",
	    value: function log() {
	      if (this.isEnabled('log')) {
	        var _console2;
	        for (var _len2 = arguments.length, params = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
	          params[_key2] = arguments[_key2];
	        }
	        (_console2 = console).log.apply(_console2, [].concat(babelHelpers.toConsumableArray(this.__getStyles('log')), params));
	      }
	    }
	  }, {
	    key: "info",
	    value: function info() {
	      if (this.isEnabled('info')) {
	        var _console3;
	        for (var _len3 = arguments.length, params = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
	          params[_key3] = arguments[_key3];
	        }
	        (_console3 = console).info.apply(_console3, [].concat(babelHelpers.toConsumableArray(this.__getStyles('info')), params));
	      }
	    }
	  }, {
	    key: "warn",
	    value: function warn() {
	      if (this.isEnabled('warn')) {
	        var _console4;
	        for (var _len4 = arguments.length, params = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
	          params[_key4] = arguments[_key4];
	        }
	        (_console4 = console).warn.apply(_console4, [].concat(babelHelpers.toConsumableArray(this.__getStyles('warn')), params));
	      }
	    }
	  }, {
	    key: "error",
	    value: function error() {
	      if (this.isEnabled('error')) {
	        var _console5;
	        for (var _len5 = arguments.length, params = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
	          params[_key5] = arguments[_key5];
	        }
	        (_console5 = console).error.apply(_console5, [].concat(babelHelpers.toConsumableArray(this.__getStyles('error')), params));
	      }
	    }
	  }, {
	    key: "trace",
	    value: function trace() {
	      if (this.isEnabled('trace')) {
	        var _console6;
	        (_console6 = console).trace.apply(_console6, arguments);
	      }
	    }
	  }, {
	    key: "__save",
	    value: function __save() {
	      if (typeof window.localStorage !== 'undefined') {
	        try {
	          var custom = {};
	          for (var type in babelHelpers.classPrivateFieldGet(this, _custom)) {
	            if (babelHelpers.classPrivateFieldGet(this, _custom).hasOwnProperty(type) && babelHelpers.classPrivateFieldGet(this, _config)[type] !== babelHelpers.classPrivateFieldGet(this, _custom)[type]) {
	              custom[type] = !!babelHelpers.classPrivateFieldGet(this, _custom)[type];
	            }
	          }
	          console.warn(JSON.stringify(custom));
	          window.localStorage.setItem('bx-messenger-logger', JSON.stringify(custom));
	        } catch (e) {}
	      }
	    }
	  }, {
	    key: "__load",
	    value: function __load() {
	      if (typeof window.localStorage !== 'undefined') {
	        try {
	          var custom = window.localStorage.getItem('bx-messenger-logger');
	          if (typeof custom === 'string') {
	            babelHelpers.classPrivateFieldSet(this, _custom, JSON.parse(custom));
	            babelHelpers.classPrivateFieldSet(this, _types, _objectSpread(_objectSpread({}, babelHelpers.classPrivateFieldGet(this, _types)), babelHelpers.classPrivateFieldGet(this, _custom)));
	          }
	        } catch (e) {}
	      }
	    }
	  }, {
	    key: "__getStyles",
	    value: function __getStyles() {
	      var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'all';
	      var styles = {
	        'desktop': ["%cDESKTOP", "color: white; font-style: italic; background-color: #29619b; padding: 0 6\px"],
	        'log': ["%cLOG", "color: #2a323b; font-style: italic; background-color: #ccc; padding: 0 6\px"],
	        'info': ["%cINFO", "color: #fff; font-style: italic; background-color: #6b7f96; padding: 0 6\px"],
	        'warn': ["%cWARNING", "color: white; font-style: italic; padding: 0 6\px; border: 1px solid #f0a74f"],
	        'error': ["%cERROR", "color: white; font-style: italic; padding: 0 6\px; border: 1px solid #8a3232"]
	      };
	      if (type === 'all') {
	        return styles;
	      }
	      if (styles[type]) {
	        return styles[type];
	      }
	      return [];
	    }
	  }, {
	    key: "__getRemoveString",
	    value: function __getRemoveString() {
	      var styles = this.__getStyles();
	      var result = [];
	      for (var type in styles) {
	        if (styles.hasOwnProperty(type)) {
	          result.push(styles[type][1]);
	        }
	      }
	      return result;
	    }
	  }]);
	  return Logger;
	}();
	var logger = new Logger();

	exports.Logger = logger;

}((this.BX.Messenger.Lib = this.BX.Messenger.Lib || {})));





// file: /bitrix/js/im/const/dist/registry.bundle.js
this.BX = this.BX || {};
this.BX.Messenger = this.BX.Messenger || {};
(function (exports) {
	'use strict';

	/**
	 * Bitrix Messenger
	 * Date constants
	 *
	 * @package bitrix
	 * @subpackage im
	 * @copyright 2001-2020 Bitrix
	 */

	var DateFormat = Object.freeze({
	  groupTitle: 'groupTitle',
	  message: 'message',
	  recentTitle: 'recentTitle',
	  recentLinesTitle: 'recentLinesTitle',
	  readedTitle: 'readedTitle',
	  "default": 'default',
	  vacationTitle: 'vacationTitle'
	});

	/**
	 * Bitrix Messenger
	 * Device constants
	 *
	 * @package bitrix
	 * @subpackage im
	 * @copyright 2001-2020 Bitrix
	 */

	var DeviceType = Object.freeze({
	  mobile: 'mobile',
	  desktop: 'desktop'
	});
	var DeviceOrientation = Object.freeze({
	  horizontal: 'horizontal',
	  portrait: 'portrait'
	});

	/**
	 * Bitrix Messenger
	 * Common constants
	 *
	 * @package bitrix
	 * @subpackage im
	 * @copyright 2001-2020 Bitrix
	 */

	var MutationType = Object.freeze({
	  none: 'none',
	  add: 'delete',
	  update: 'update',
	  "delete": 'delete',
	  set: 'set',
	  setAfter: 'after',
	  setBefore: 'before'
	});
	var StorageLimit = Object.freeze({
	  dialogues: 50,
	  messages: 100
	});

	/**
	 * Bitrix Messenger
	 * Device constants
	 *
	 * @package bitrix
	 * @subpackage im
	 * @copyright 2001-2020 Bitrix
	 */

	var RestMethod = Object.freeze({
	  imMessageAdd: 'im.message.add',
	  imMessageUpdate: 'im.message.update',
	  imMessageDelete: 'im.message.delete',
	  imMessageLike: 'im.message.like',
	  imMessageCommand: 'im.message.command',
	  imMessageShare: 'im.message.share',
	  imChatGet: 'im.chat.get',
	  imChatLeave: 'im.chat.leave',
	  imChatMute: 'im.chat.mute',
	  imChatParentJoin: 'im.chat.parent.join',
	  imDialogGet: 'im.dialog.get',
	  imDialogMessagesGet: 'im.dialog.messages.get',
	  imDialogRead: 'im.dialog.read',
	  imDialogUnread: 'im.dialog.unread',
	  imDialogWriting: 'im.dialog.writing',
	  imUserGet: 'im.user.get',
	  imUserListGet: 'im.user.list.get',
	  imDiskFolderGet: 'im.disk.folder.get',
	  imDiskFileUpload: 'disk.folder.uploadfile',
	  imDiskFileCommit: 'im.disk.file.commit',
	  mobileBrowserConstGet: 'mobile.browser.const.get',
	  imRecentGet: 'im.recent.get',
	  imRecentList: 'im.recent.list',
	  imCallGetCallLimits: 'im.call.getCallLimits',
	  imNotifyGet: 'im.notify.get',
	  imNotifySchemaGet: 'im.notify.schema.get'
	});
	var RestMethodHandler = Object.freeze({
	  imChatGet: 'im.chat.get',
	  imMessageAdd: 'im.message.add',
	  imDialogRead: 'im.dialog.read',
	  imDialogMessagesGet: 'im.dialog.messages.get',
	  imDialogMessagesGetInit: 'im.dialog.messages.get.init',
	  imDialogMessagesGetUnread: 'im.dialog.messages.get.unread',
	  imDiskFolderGet: 'im.disk.folder.get',
	  imDiskFileUpload: 'disk.folder.uploadfile',
	  imDiskFileCommit: 'im.disk.file.commit',
	  imUserGet: 'im.user.get',
	  imUserListGet: 'im.user.list.get',
	  mobileBrowserConstGet: 'mobile.browser.const.get',
	  imRecentGet: 'im.recent.get',
	  imRecentList: 'im.recent.list',
	  imCallGetCallLimits: 'im.call.getCallLimits',
	  imNotifyGet: 'im.notify.get',
	  imNotifySchemaGet: 'im.notify.schema.get'
	});

	/**
	 * Bitrix Messenger
	 * Event names constants
	 *
	 * @package bitrix
	 * @subpackage im
	 * @copyright 2001-2020 Bitrix
	 */

	var EventType = Object.freeze({
	  dialog: {
	    open: 'IM.Dialog:open',
	    newMessage: 'EventType.dialog.newMessage',
	    scrollOnStart: 'IM.Dialog:scrollOnStart',
	    scrollToBottom: 'IM.Dialog:scrollToBottom',
	    readVisibleMessages: 'IM.Dialog.readVisibleMessages',
	    requestUnread: 'IM.Dialog.requestUnread',
	    readMessage: 'IM.Dialog:readMessage',
	    quoteMessage: 'IM.Dialog:quoteMessage',
	    clickOnCommand: 'IM.Dialog:clickOnCommand',
	    clickOnMention: 'IM.Dialog:clickOnMention',
	    clickOnUserName: 'IM.Dialog:clickOnUserName',
	    clickOnMessageMenu: 'IM.Dialog:clickOnMessageMenu',
	    clickOnMessageRetry: 'IM.Dialog:clickOnMessageRetry',
	    doubleClickOnMessage: 'IM.Dialog:doubleClickOnMessage',
	    clickOnUploadCancel: 'IM.Dialog:clickOnUploadCancel',
	    clickOnReadList: 'IM.Dialog:clickOnReadList',
	    setMessageReaction: 'IM.Dialog:setMessageReaction',
	    openMessageReactionList: 'IM.Dialog:openMessageReactionList',
	    clickOnKeyboardButton: 'IM.Dialog:clickOnKeyboardButton',
	    clickOnChatTeaser: 'IM.Dialog:clickOnChatTeaser',
	    clickOnDialog: 'IM.Dialog:clickOnDialog',
	    quotePanelClose: 'IM.Dialog:quotePanelClose',
	    beforeMobileKeyboard: 'IM.Dialog:beforeMobileKeyboard',
	    messagesSet: 'IM.Dialog:messagesSet'
	  },
	  textarea: {
	    focus: 'IM.Textarea:focus',
	    setFocus: 'IM.Textarea:setFocus',
	    blur: 'IM.Textarea:blur',
	    setBlur: 'IM.Textarea:setBlur',
	    keyUp: 'IM.Textarea:keyUp',
	    edit: 'IM.Textarea:edit',
	    insertText: 'IM.Textarea:insertText',
	    sendMessage: 'IM.Textarea:sendMessage',
	    fileSelected: 'IM.Textarea:fileSelected',
	    startWriting: 'IM.Textarea:startWriting',
	    stopWriting: 'IM.Textarea:stopWriting',
	    appButtonClick: 'IM.Textarea:appButtonClick'
	  },
	  uploader: {
	    addMessageWithFile: 'IM.Uploader:addMessageWithFile'
	  },
	  conference: {
	    setPasswordFocus: 'IM.Conference:setPasswordFocus',
	    hideSmiles: 'IM.Conference:hideSmiles',
	    requestPermissions: 'IM.Conference:requestPermissions',
	    waitForStart: 'IM.Conference:waitForStart',
	    userRenameFocus: 'IM.Conference:userRenameFocus',
	    userRenameBlur: 'IM.Conference:userRenameBlur'
	  },
	  notification: {
	    updateState: 'IM.Notifications:restoreConnection'
	  },
	  mobile: {
	    textarea: {
	      setText: 'IM.Mobile.Textarea:setText',
	      setFocus: 'IM.Mobile.Textarea:setFocus'
	    },
	    openUserList: 'IM.Mobile:openUserList'
	  }
	});

	/**
	 * Bitrix Messenger
	 * Event names constants
	 *
	 * @package bitrix
	 * @subpackage im
	 * @copyright 2001-2020 Bitrix
	 */

	var DialogType = Object.freeze({
	  "private": 'private',
	  chat: 'chat',
	  open: 'open',
	  call: 'call',
	  crm: 'crm'
	});
	var DialogCrmType = Object.freeze({
	  lead: 'lead',
	  company: 'company',
	  contact: 'contact',
	  deal: 'deal',
	  none: 'none'
	});
	var DialogReferenceClassName = Object.freeze({
	  listBody: 'bx-im-dialog-list',
	  listItem: 'bx-im-dialog-list-item-reference',
	  listItemName: 'bx-im-dialog-list-item-name-reference',
	  listItemBody: 'bx-im-dialog-list-item-content-reference',
	  listUnreadLoader: 'bx-im-dialog-list-unread-loader-reference'
	});
	var DialogTemplateType = Object.freeze({
	  message: 'message',
	  delimiter: 'delimiter',
	  group: 'group',
	  historyLoader: 'historyLoader',
	  unreadLoader: 'unreadLoader',
	  button: 'button',
	  placeholder: 'placeholder'
	});
	var DialogState = Object.freeze({
	  loading: 'loading',
	  empty: 'empty',
	  show: 'show'
	});

	/**
	 * Bitrix Messenger
	 * File constants
	 *
	 * @package bitrix
	 * @subpackage im
	 * @copyright 2001-2020 Bitrix
	 */

	var FileStatus = Object.freeze({
	  upload: 'upload',
	  wait: 'wait',
	  done: 'done',
	  error: 'error'
	});
	var FileType = Object.freeze({
	  image: 'image',
	  video: 'video',
	  audio: 'audio',
	  file: 'file'
	});

	/**
	 * Bitrix Messenger
	 * Message constants
	 *
	 * @package bitrix
	 * @subpackage im
	 * @copyright 2001-2020 Bitrix
	 */

	var MessageType = Object.freeze({
	  self: 'self',
	  opponent: 'opponent',
	  system: 'system'
	});

	/**
	 * Bitrix Messenger
	 * Conference constants
	 *
	 * @package bitrix
	 * @subpackage im
	 * @copyright 2001-2020 Bitrix
	 */

	var ConferenceFieldState = Object.freeze({
	  view: 'view',
	  edit: 'edit',
	  create: 'create'
	});
	var ConferenceStateType = Object.freeze({
	  preparation: 'preparation',
	  call: 'call'
	});
	var ConferenceErrorCode = Object.freeze({
	  userLimitReached: 'userLimitReached',
	  detectIntranetUser: 'detectIntranetUser',
	  bitrix24only: 'bitrix24only',
	  kickedFromCall: 'kickedFromCall',
	  unsupportedBrowser: 'unsupportedBrowser',
	  missingMicrophone: 'missingMicrophone',
	  unsafeConnection: 'unsafeConnection',
	  wrongAlias: 'wrongAlias',
	  notStarted: 'notStarted',
	  finished: 'finished',
	  userLeftCall: 'userLeftCall',
	  noSignalFromCamera: 'noSignalFromCamera'
	});
	var ConferenceRightPanelMode = Object.freeze({
	  hidden: 'hidden',
	  chat: 'chat',
	  users: 'users',
	  split: 'split'
	});

	//BX.Call.UserState sync
	var ConferenceUserState = Object.freeze({
	  Idle: 'Idle',
	  Busy: 'Busy',
	  Calling: 'Calling',
	  Unavailable: 'Unavailable',
	  Declined: 'Declined',
	  Ready: 'Ready',
	  Connecting: 'Connecting',
	  Connected: 'Connected',
	  Failed: 'Failed'
	});

	/**
	 * Bitrix Messenger
	 * Recent list constants
	 *
	 * @package bitrix
	 * @subpackage im
	 * @copyright 2001-2020 Bitrix
	 */

	var ChatTypes = {
	  chat: 'chat',
	  open: 'open',
	  user: 'user',
	  notification: 'notification'
	};
	var TemplateTypes = {
	  item: 'item',
	  placeholder: 'placeholder'
	};
	var RecentSection = {
	  general: 'general',
	  pinned: 'pinned'
	};
	var MessageStatus = {
	  received: 'received',
	  delivered: 'delivered',
	  error: 'error'
	};

	var NotificationTypesCodes = Object.freeze({
	  confirm: 1,
	  simple: 3,
	  placeholder: 5
	});

	exports.DateFormat = DateFormat;
	exports.DeviceType = DeviceType;
	exports.DeviceOrientation = DeviceOrientation;
	exports.MutationType = MutationType;
	exports.StorageLimit = StorageLimit;
	exports.RestMethod = RestMethod;
	exports.RestMethodHandler = RestMethodHandler;
	exports.EventType = EventType;
	exports.DialogType = DialogType;
	exports.DialogCrmType = DialogCrmType;
	exports.DialogReferenceClassName = DialogReferenceClassName;
	exports.DialogTemplateType = DialogTemplateType;
	exports.DialogState = DialogState;
	exports.FileStatus = FileStatus;
	exports.FileType = FileType;
	exports.MessageType = MessageType;
	exports.ConferenceFieldState = ConferenceFieldState;
	exports.ConferenceStateType = ConferenceStateType;
	exports.ConferenceErrorCode = ConferenceErrorCode;
	exports.ConferenceRightPanelMode = ConferenceRightPanelMode;
	exports.ConferenceUserState = ConferenceUserState;
	exports.ChatTypes = ChatTypes;
	exports.TemplateTypes = TemplateTypes;
	exports.RecentSection = RecentSection;
	exports.MessageStatus = MessageStatus;
	exports.NotificationTypesCodes = NotificationTypesCodes;

}((this.BX.Messenger.Const = this.BX.Messenger.Const || {})));





// file: /bitrix/js/main/date/main.date.js
this.BX = this.BX || {};
(function (exports,main_core) {
	'use strict';

	function convertBitrixFormat(format) {
	  if (!main_core.Type.isStringFilled(format)) {
	    return '';
	  }
	  return format.replace('YYYY', 'Y') // 1999
	  .replace('MMMM', 'F') // January - December
	  .replace('MM', 'm') // 01 - 12
	  .replace('M', 'M') // Jan - Dec
	  .replace('DD', 'd') // 01 - 31
	  .replace('G', 'g') //  1 - 12
	  .replace(/GG/i, 'G') //  0 - 23
	  .replace('H', 'h') // 01 - 12
	  .replace(/HH/i, 'H') // 00 - 24
	  .replace('MI', 'i') // 00 - 59
	  .replace('SS', 's') // 00 - 59
	  .replace('TT', 'A') // AM - PM
	  .replace('T', 'a'); // am - pm
	}

	const formatsCache = new main_core.Cache.MemoryCache();

	/**
	 * Returns culture-specific datetime format by code.
	 * The full list with examples can be found in config.php of this extension in ['settings']['formats'].
	 * All formats are compatible with this.format() without any additional transformations.
	 *
	 * @param code
	 * @returns {string|null}
	 */
	function getFormat(code) {
	  return formatsCache.remember(`main.date.format.${code}`, () => {
	    let format = main_core.Extension.getSettings('main.date').get(`formats.${code}`);
	    if (main_core.Type.isStringFilled(format) && (code === 'FORMAT_DATE' || code === 'FORMAT_DATETIME')) {
	      format = convertBitrixFormat(format);
	    }
	    return format;
	  });
	}

	/**
	 * @memberOf BX.Main
	 * @alias Date
	 */
	let DateTimeFormat = /*#__PURE__*/function () {
	  function DateTimeFormat() {
	    babelHelpers.classCallCheck(this, DateTimeFormat);
	  }
	  babelHelpers.createClass(DateTimeFormat, null, [{
	    key: "isAmPmMode",
	    value: function isAmPmMode(returnConst) {
	      if (returnConst === true) {
	        return this._getMessage('AMPM_MODE');
	      }
	      return this._getMessage('AMPM_MODE') !== false;
	    }
	  }, {
	    key: "convertToUTC",
	    value: function convertToUTC(date) {
	      if (!main_core.Type.isDate(date)) {
	        return null;
	      }
	      return new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()));
	    }
	    /**
	     * Function creates and returns Javascript Date() object from server timestamp regardless of local browser (system) timezone.
	     * For example can be used to convert timestamp from some exact date on server to the JS Date object with the same value.
	     *
	     * @param timestamp - timestamp in seconds
	     * @returns {Date}
	     */
	  }, {
	    key: "getNewDate",
	    value: function getNewDate(timestamp) {
	      return new Date(this.getBrowserTimestamp(timestamp));
	    }
	    /**
	     * Function transforms server timestamp (in sec) to javascript timestamp (calculated depend on local browser timezone offset). Returns timestamp in milliseconds.
	     * Also see BX.Main.Date.getNewDate description.
	     *
	     * @param timestamp - timestamp in seconds
	     * @returns {number}
	     */
	  }, {
	    key: "getBrowserTimestamp",
	    value: function getBrowserTimestamp(timestamp) {
	      timestamp = parseInt(timestamp, 10);
	      const browserOffset = new Date(timestamp * 1000).getTimezoneOffset() * 60;
	      return (parseInt(timestamp, 10) + parseInt(this._getMessage('SERVER_TZ_OFFSET')) + browserOffset) * 1000;
	    }
	    /**
	     * Function transforms local browser timestamp (in ms) to server timestamp (calculated depend on local browser timezone offset). Returns timestamp in seconds.
	     *
	     * @param timestamp - timestamp in milliseconds
	     * @returns {number}
	     */
	  }, {
	    key: "getServerTimestamp",
	    value: function getServerTimestamp(timestamp) {
	      timestamp = parseInt(timestamp, 10);
	      const browserOffset = new Date(timestamp).getTimezoneOffset() * 60;
	      return Math.round(timestamp / 1000 - (parseInt(this._getMessage('SERVER_TZ_OFFSET'), 10) + parseInt(browserOffset, 10)));
	    }
	  }, {
	    key: "formatLastActivityDate",
	    value: function formatLastActivityDate(timestamp, now, utc) {
	      const ampm = this.isAmPmMode(true);
	      const timeFormat = ampm === this.AM_PM_MODE.LOWER ? 'g:i a' : ampm === this.AM_PM_MODE.UPPER ? 'g:i A' : 'H:i';
	      const format = [['tomorrow', '#01#' + timeFormat], ['now', '#02#'], ['todayFuture', '#03#' + timeFormat], ['yesterday', '#04#' + timeFormat], ['-', this.convertBitrixFormat(this._getMessage('FORMAT_DATETIME')).replace(/:s/g, '')], ['s60', 'sago'], ['i60', 'iago'], ['H5', 'Hago'], ['H24', '#03#' + timeFormat], ['d31', 'dago'], ['m12>1', 'mago'], ['m12>0', 'dago'], ['', '#05#']];
	      let formattedDate = this.format(format, timestamp, now, utc);
	      let match = null;
	      if ((match = /^#(\d+)#(.*)/.exec(formattedDate)) != null) {
	        switch (match[1]) {
	          case '01':
	            formattedDate = this._getMessage('FD_LAST_SEEN_TOMORROW').replace('#TIME#', match[2]);
	            break;
	          case '02':
	            formattedDate = this._getMessage('FD_LAST_SEEN_NOW');
	            break;
	          case '03':
	            formattedDate = this._getMessage('FD_LAST_SEEN_TODAY').replace('#TIME#', match[2]);
	            break;
	          case '04':
	            formattedDate = this._getMessage('FD_LAST_SEEN_YESTERDAY').replace('#TIME#', match[2]);
	            break;
	          case '05':
	            formattedDate = this._getMessage('FD_LAST_SEEN_MORE_YEAR');
	            break;
	          default:
	            formattedDate = match[2];
	            break;
	        }
	      }
	      return formattedDate;
	    }
	    /**
	     * The method is designed to replace the localization storage on sites without Bitrix Framework.
	     * It gets overloaded with custom implementation:
	     *
	     * const CustomDate = Object.create(BX.Main.Date);
	     * CustomDate._getMessage = () => ...new implementation...;
	     *
	     * This class should get messages only via this method.
	     * Otherwise, the class won't work on sites without Bitrix Framework.
	     *
	     * @param message
	     * @returns {*}
	     * @private
	     */
	  }, {
	    key: "_getMessage",
	    value: function _getMessage(message) {
	      return main_core.Loc.getMessage(message);
	    }
	    /**
	     * The method used to parse date from string by given format.
	     *
	     * @param {string} str - date in given format
	     * @param {boolean} isUTC - is date in UTC
	     * @param {string} formatDate - format of the date without time
	     * @param {string} formatDatetime - format of the date with time
	     * @returns {Date|null} - returns Date object if string was parsed or null
	     */
	  }, {
	    key: "parse",
	    value: function parse(str, isUTC, formatDate, formatDatetime) {
	      if (main_core.Type.isStringFilled(str)) {
	        if (!formatDate) {
	          formatDate = this._getMessage('FORMAT_DATE');
	        }
	        if (!formatDatetime) {
	          formatDatetime = this._getMessage('FORMAT_DATETIME');
	        }
	        let regMonths = '';
	        for (let i = 1; i <= 12; i++) {
	          regMonths = regMonths + '|' + this._getMessage('MON_' + i);
	        }
	        const expr = new RegExp('([0-9]+|[a-z]+' + regMonths + ')', 'ig');
	        const aDate = str.match(expr);
	        let aFormat = formatDate.match(/(DD|MI|MMMM|MM|M|YYYY)/ig);
	        const aDateArgs = [];
	        const aFormatArgs = [];
	        const aResult = {};
	        if (!aDate) {
	          return null;
	        }
	        if (aDate.length > aFormat.length) {
	          aFormat = formatDatetime.match(/(DD|MI|MMMM|MM|M|YYYY|HH|H|SS|TT|T|GG|G)/ig);
	        }
	        for (let i = 0, cnt = aDate.length; i < cnt; i++) {
	          if (aDate[i].trim() !== '') {
	            aDateArgs[aDateArgs.length] = aDate[i];
	          }
	        }
	        for (let i = 0, cnt = aFormat.length; i < cnt; i++) {
	          if (aFormat[i].trim() !== '') {
	            aFormatArgs[aFormatArgs.length] = aFormat[i];
	          }
	        }
	        let m = aFormatArgs.findIndex(item => item === 'MMMM');
	        if (m > 0) {
	          aDateArgs[m] = this.getMonthIndex(aDateArgs[m]);
	          aFormatArgs[m] = 'MM';
	        } else {
	          m = aFormatArgs.findIndex(item => item === 'M');
	          if (m > 0) {
	            aDateArgs[m] = this.getMonthIndex(aDateArgs[m]);
	            aFormatArgs[m] = 'MM';
	          }
	        }
	        for (let i = 0, cnt = aFormatArgs.length; i < cnt; i++) {
	          const k = aFormatArgs[i].toUpperCase();
	          aResult[k] = k === 'T' || k === 'TT' ? aDateArgs[i] : parseInt(aDateArgs[i], 10);
	        }
	        if (aResult['DD'] > 0 && aResult['MM'] > 0 && aResult['YYYY'] > 0) {
	          const d = new Date();
	          if (isUTC) {
	            d.setUTCDate(1);
	            d.setUTCFullYear(aResult['YYYY']);
	            d.setUTCMonth(aResult['MM'] - 1);
	            d.setUTCDate(aResult['DD']);
	            d.setUTCHours(0, 0, 0, 0);
	          } else {
	            d.setDate(1);
	            d.setFullYear(aResult['YYYY']);
	            d.setMonth(aResult['MM'] - 1);
	            d.setDate(aResult['DD']);
	            d.setHours(0, 0, 0, 0);
	          }
	          if ((!isNaN(aResult['HH']) || !isNaN(aResult['GG']) || !isNaN(aResult['H']) || !isNaN(aResult['G'])) && !isNaN(aResult['MI'])) {
	            if (!isNaN(aResult['H']) || !isNaN(aResult['G'])) {
	              const bPM = (aResult['T'] || aResult['TT'] || 'am').toUpperCase() === 'PM',
	                h = parseInt(aResult['H'] || aResult['G'] || 0, 10);
	              if (bPM) {
	                aResult['HH'] = h + (h === 12 ? 0 : 12);
	              } else {
	                aResult['HH'] = h < 12 ? h : 0;
	              }
	            } else {
	              aResult['HH'] = parseInt(aResult['HH'] || aResult['GG'] || 0, 10);
	            }
	            if (isNaN(aResult['SS'])) {
	              aResult['SS'] = 0;
	            }
	            if (isUTC) {
	              d.setUTCHours(aResult['HH'], aResult['MI'], aResult['SS']);
	            } else {
	              d.setHours(aResult['HH'], aResult['MI'], aResult['SS']);
	            }
	          }
	          return d;
	        }
	      }
	      return null;
	    }
	  }, {
	    key: "getMonthIndex",
	    value: function getMonthIndex(month) {
	      const q = month.toUpperCase();
	      const wordMonthCut = ['jan', 'feb', 'mar', 'apr', 'may', 'jun', 'jul', 'aug', 'sep', 'oct', 'nov', 'dec'];
	      const wordMonth = ['january', 'february', 'march', 'april', 'may', 'june', 'july', 'august', 'september', 'october', 'november', 'december'];
	      for (let i = 1; i <= 12; i++) {
	        if (q === this._getMessage('MON_' + i).toUpperCase() || q === this._getMessage('MONTH_' + i).toUpperCase() || q === wordMonthCut[i - 1].toUpperCase() || q === wordMonth[i - 1].toUpperCase()) {
	          return i;
	        }
	      }
	      return month;
	    }
	  }, {
	    key: "format",
	    value: function format(_format, timestamp, now, utc) {
	      /*
	      PHP to Javascript:
	      	time() = new Date()
	      	mktime(...) = new Date(...)
	      	gmmktime(...) = new Date(Date.UTC(...))
	      	mktime(0,0,0, 1, 1, 1970) != 0          new Date(1970,0,1).getTime() != 0
	      	gmmktime(0,0,0, 1, 1, 1970) == 0        new Date(Date.UTC(1970,0,1)).getTime() == 0
	      	date('d.m.Y H:i:s') = BX.Main.Date.format('d.m.Y H:i:s')
	      	gmdate('d.m.Y H:i:s') = BX.Main.Date.format('d.m.Y H:i:s', null, null, true);
	      */
	      const date = main_core.Type.isDate(timestamp) ? new Date(timestamp.getTime()) : main_core.Type.isNumber(timestamp) ? new Date(timestamp * 1000) : new Date();
	      const nowDate = main_core.Type.isDate(now) ? new Date(now.getTime()) : main_core.Type.isNumber(now) ? new Date(now * 1000) : new Date();
	      const isUTC = !!utc;
	      // used in hoisting inner functions, like _formatDateInterval
	      const thisDateTimeFormat = this;
	      if (main_core.Type.isArray(_format)) {
	        return _formatDateInterval(_format, date, nowDate, isUTC);
	      } else {
	        if (!main_core.Type.isStringFilled(_format)) {
	          return '';
	        }
	      }
	      const replaceMap = (_format.match(/{{([^{}]*)}}/g) || []).map(x => {
	        return (x.match(/[^{}]+/) || [''])[0];
	      });
	      if (replaceMap.length > 0) {
	        replaceMap.forEach((element, index) => {
	          _format = _format.replace('{{' + element + '}}', '{{' + index + '}}');
	        });
	      }
	      const formatRegex = /\\?(sago|iago|isago|Hago|dago|mago|Yago|sdiff|idiff|Hdiff|ddiff|mdiff|Ydiff|sshort|ishort|Hshort|dshort|mhort|Yshort|yesterday|today|tommorow|tomorrow|[a-z])/gi;
	      const dateFormats = {
	        d: () => {
	          // Day of the month 01 to 31
	          return getDate(date).toString().padStart(2, '0');
	        },
	        D: () => {
	          //Mon through Sun
	          return this._getMessage('DOW_' + getDay(date));
	        },
	        j: () => {
	          //Day of the month 1 to 31
	          return getDate(date);
	        },
	        l: () => {
	          //Sunday through Saturday
	          return this._getMessage('DAY_OF_WEEK_' + getDay(date));
	        },
	        N: () => {
	          //1 (for Monday) through 7 (for Sunday)
	          return getDay(date) || 7;
	        },
	        S: () => {
	          //st, nd, rd or th. Works well with j
	          if (getDate(date) % 10 == 1 && getDate(date) != 11) {
	            return 'st';
	          } else if (getDate(date) % 10 == 2 && getDate(date) != 12) {
	            return 'nd';
	          } else if (getDate(date) % 10 == 3 && getDate(date) != 13) {
	            return 'rd';
	          } else {
	            return 'th';
	          }
	        },
	        w: () => {
	          //0 (for Sunday) through 6 (for Saturday)
	          return getDay(date);
	        },
	        z: () => {
	          //0 through 365
	          const firstDay = new Date(getFullYear(date), 0, 1);
	          const currentDay = new Date(getFullYear(date), getMonth(date), getDate(date));
	          return Math.ceil((currentDay - firstDay) / (24 * 3600 * 1000));
	        },
	        W: () => {
	          //ISO-8601 week number of year
	          const newDate = new Date(date.getTime());
	          const dayNumber = (getDay(date) + 6) % 7;
	          setDate(newDate, getDate(newDate) - dayNumber + 3);
	          const firstThursday = newDate.getTime();
	          setMonth(newDate, 0, 1);
	          if (getDay(newDate) != 4) {
	            setMonth(newDate, 0, 1 + (4 - getDay(newDate) + 7) % 7);
	          }
	          const weekNumber = 1 + Math.ceil((firstThursday - newDate) / (7 * 24 * 3600 * 1000));
	          return weekNumber.toString().padStart(2, '0');
	        },
	        F: () => {
	          //January through December
	          return this._getMessage('MONTH_' + (getMonth(date) + 1) + '_S');
	        },
	        f: () => {
	          //January through December
	          return this._getMessage('MONTH_' + (getMonth(date) + 1));
	        },
	        m: () => {
	          //Numeric representation of a month 01 through 12
	          return (getMonth(date) + 1).toString().padStart(2, '0');
	        },
	        M: () => {
	          //A short textual representation of a month, three letters Jan through Dec
	          return this._getMessage('MON_' + (getMonth(date) + 1));
	        },
	        n: () => {
	          //Numeric representation of a month 1 through 12
	          return getMonth(date) + 1;
	        },
	        t: () => {
	          //Number of days in the given month 28 through 31
	          const lastMonthDay = isUTC ? new Date(Date.UTC(getFullYear(date), getMonth(date) + 1, 0)) : new Date(getFullYear(date), getMonth(date) + 1, 0);
	          return getDate(lastMonthDay);
	        },
	        L: () => {
	          //1 if it is a leap year, 0 otherwise.
	          const year = getFullYear(date);
	          return year % 4 == 0 && year % 100 != 0 || year % 400 == 0 ? 1 : 0;
	        },
	        o: () => {
	          //ISO-8601 year number
	          const correctDate = new Date(date.getTime());
	          setDate(correctDate, getDate(correctDate) - (getDay(date) + 6) % 7 + 3);
	          return getFullYear(correctDate);
	        },
	        Y: () => {
	          //A full numeric representation of a year, 4 digits
	          return getFullYear(date);
	        },
	        y: () => {
	          //A two digit representation of a year
	          return getFullYear(date).toString().slice(2);
	        },
	        a: () => {
	          //am or pm
	          return getHours(date) > 11 ? 'pm' : 'am';
	        },
	        A: () => {
	          //AM or PM
	          return getHours(date) > 11 ? 'PM' : 'AM';
	        },
	        B: () => {
	          //000 through 999
	          const swatch = (date.getUTCHours() + 1) % 24 + date.getUTCMinutes() / 60 + date.getUTCSeconds() / 3600;
	          return Math.floor(swatch * 1000 / 24).toString().padStart(3, '0');
	        },
	        g: () => {
	          //12-hour format of an hour without leading zeros 1 through 12
	          return getHours(date) % 12 || 12;
	        },
	        G: () => {
	          //24-hour format of an hour without leading zeros 0 through 23
	          return getHours(date);
	        },
	        h: () => {
	          //12-hour format of an hour with leading zeros 01 through 12
	          return (getHours(date) % 12 || 12).toString().padStart(2, '0');
	        },
	        H: () => {
	          //24-hour format of an hour with leading zeros 00 through 23
	          return getHours(date).toString().padStart(2, '0');
	        },
	        i: () => {
	          //Minutes with leading zeros 00 to 59
	          return getMinutes(date).toString().padStart(2, '0');
	        },
	        s: () => {
	          //Seconds, with leading zeros 00 through 59
	          return getSeconds(date).toString().padStart(2, '0');
	        },
	        u: () => {
	          //Microseconds
	          return (getMilliseconds(date) * 1000).toString().padStart(6, '0');
	        },
	        e: () => {
	          if (isUTC) {
	            return 'UTC';
	          }
	          return '';
	        },
	        I: () => {
	          if (isUTC) {
	            return 0;
	          }

	          //Whether or not the date is in daylight saving time 1 if Daylight Saving Time, 0 otherwise
	          const firstJanuary = new Date(getFullYear(date), 0, 1);
	          const firstJanuaryUTC = Date.UTC(getFullYear(date), 0, 1);
	          const firstJuly = new Date(getFullYear(date), 6, 0);
	          const firstJulyUTC = Date.UTC(getFullYear(date), 6, 0);
	          return 0 + (firstJanuary - firstJanuaryUTC !== firstJuly - firstJulyUTC);
	        },
	        O: () => {
	          if (isUTC) {
	            return '+0000';
	          }

	          //Difference to Greenwich time (GMT) in hours +0200
	          const timezoneOffset = date.getTimezoneOffset();
	          const timezoneOffsetAbs = Math.abs(timezoneOffset);
	          return (timezoneOffset > 0 ? '-' : '+') + (Math.floor(timezoneOffsetAbs / 60) * 100 + timezoneOffsetAbs % 60).toString().padStart(4, '0');
	        },
	        //this method references 'O' method of the same object, arrow function is not suitable here
	        P: function () {
	          if (isUTC) {
	            return '+00:00';
	          }

	          //Difference to Greenwich time (GMT) with colon between hours and minutes +02:00
	          const difference = this.O();
	          return difference.substr(0, 3) + ':' + difference.substr(3);
	        },
	        Z: () => {
	          if (isUTC) {
	            return 0;
	          }
	          //Timezone offset in seconds. The offset for timezones west of UTC is always negative,
	          //and for those east of UTC is always positive.
	          return -date.getTimezoneOffset() * 60;
	        },
	        c: () => {
	          //ISO 8601 date
	          return 'Y-m-d\\TH:i:sP'.replace(formatRegex, _replaceDateFormat);
	        },
	        r: () => {
	          //RFC 2822 formatted date
	          return 'D, d M Y H:i:s O'.replace(formatRegex, _replaceDateFormat);
	        },
	        U: () => {
	          //Seconds since the Unix Epoch
	          return Math.floor(date.getTime() / 1000);
	        },
	        sago: () => {
	          return _formatDateMessage(intval((nowDate - date) / 1000), {
	            '0': 'FD_SECOND_AGO_0',
	            '1': 'FD_SECOND_AGO_1',
	            '10_20': 'FD_SECOND_AGO_10_20',
	            'MOD_1': 'FD_SECOND_AGO_MOD_1',
	            'MOD_2_4': 'FD_SECOND_AGO_MOD_2_4',
	            'MOD_OTHER': 'FD_SECOND_AGO_MOD_OTHER'
	          });
	        },
	        sdiff: () => {
	          return _formatDateMessage(intval((nowDate - date) / 1000), {
	            '0': 'FD_SECOND_DIFF_0',
	            '1': 'FD_SECOND_DIFF_1',
	            '10_20': 'FD_SECOND_DIFF_10_20',
	            'MOD_1': 'FD_SECOND_DIFF_MOD_1',
	            'MOD_2_4': 'FD_SECOND_DIFF_MOD_2_4',
	            'MOD_OTHER': 'FD_SECOND_DIFF_MOD_OTHER'
	          });
	        },
	        sshort: () => {
	          return this._getMessage('FD_SECOND_SHORT').replace(/#VALUE#/g, intval((nowDate - date) / 1000));
	        },
	        iago: () => {
	          return _formatDateMessage(intval((nowDate - date) / 60 / 1000), {
	            '0': 'FD_MINUTE_AGO_0',
	            '1': 'FD_MINUTE_AGO_1',
	            '10_20': 'FD_MINUTE_AGO_10_20',
	            'MOD_1': 'FD_MINUTE_AGO_MOD_1',
	            'MOD_2_4': 'FD_MINUTE_AGO_MOD_2_4',
	            'MOD_OTHER': 'FD_MINUTE_AGO_MOD_OTHER'
	          });
	        },
	        idiff: () => {
	          return _formatDateMessage(intval((nowDate - date) / 60 / 1000), {
	            '0': 'FD_MINUTE_DIFF_0',
	            '1': 'FD_MINUTE_DIFF_1',
	            '10_20': 'FD_MINUTE_DIFF_10_20',
	            'MOD_1': 'FD_MINUTE_DIFF_MOD_1',
	            'MOD_2_4': 'FD_MINUTE_DIFF_MOD_2_4',
	            'MOD_OTHER': 'FD_MINUTE_DIFF_MOD_OTHER'
	          });
	        },
	        isago: () => {
	          const minutesAgo = intval((nowDate - date) / 60 / 1000);
	          let result = _formatDateMessage(minutesAgo, {
	            '0': 'FD_MINUTE_0',
	            '1': 'FD_MINUTE_1',
	            '10_20': 'FD_MINUTE_10_20',
	            'MOD_1': 'FD_MINUTE_MOD_1',
	            'MOD_2_4': 'FD_MINUTE_MOD_2_4',
	            'MOD_OTHER': 'FD_MINUTE_MOD_OTHER'
	          });
	          result += ' ';
	          const secondsAgo = intval((nowDate - date) / 1000) - minutesAgo * 60;
	          result += _formatDateMessage(secondsAgo, {
	            '0': 'FD_SECOND_AGO_0',
	            '1': 'FD_SECOND_AGO_1',
	            '10_20': 'FD_SECOND_AGO_10_20',
	            'MOD_1': 'FD_SECOND_AGO_MOD_1',
	            'MOD_2_4': 'FD_SECOND_AGO_MOD_2_4',
	            'MOD_OTHER': 'FD_SECOND_AGO_MOD_OTHER'
	          });
	          return result;
	        },
	        ishort: () => {
	          return this._getMessage('FD_MINUTE_SHORT').replace(/#VALUE#/g, intval((nowDate - date) / 60 / 1000));
	        },
	        Hago: () => {
	          return _formatDateMessage(intval((nowDate - date) / 60 / 60 / 1000), {
	            '0': 'FD_HOUR_AGO_0',
	            '1': 'FD_HOUR_AGO_1',
	            '10_20': 'FD_HOUR_AGO_10_20',
	            'MOD_1': 'FD_HOUR_AGO_MOD_1',
	            'MOD_2_4': 'FD_HOUR_AGO_MOD_2_4',
	            'MOD_OTHER': 'FD_HOUR_AGO_MOD_OTHER'
	          });
	        },
	        Hdiff: () => {
	          return _formatDateMessage(intval((nowDate - date) / 60 / 60 / 1000), {
	            '0': 'FD_HOUR_DIFF_0',
	            '1': 'FD_HOUR_DIFF_1',
	            '10_20': 'FD_HOUR_DIFF_10_20',
	            'MOD_1': 'FD_HOUR_DIFF_MOD_1',
	            'MOD_2_4': 'FD_HOUR_DIFF_MOD_2_4',
	            'MOD_OTHER': 'FD_HOUR_DIFF_MOD_OTHER'
	          });
	        },
	        Hshort: () => {
	          return this._getMessage('FD_HOUR_SHORT').replace(/#VALUE#/g, intval((nowDate - date) / 60 / 60 / 1000));
	        },
	        yesterday: () => {
	          return this._getMessage('FD_YESTERDAY');
	        },
	        today: () => {
	          return this._getMessage('FD_TODAY');
	        },
	        tommorow: () => {
	          return this._getMessage('FD_TOMORROW');
	        },
	        tomorrow: () => {
	          return this._getMessage('FD_TOMORROW');
	        },
	        dago: () => {
	          return _formatDateMessage(intval((nowDate - date) / 60 / 60 / 24 / 1000), {
	            '0': 'FD_DAY_AGO_0',
	            '1': 'FD_DAY_AGO_1',
	            '10_20': 'FD_DAY_AGO_10_20',
	            'MOD_1': 'FD_DAY_AGO_MOD_1',
	            'MOD_2_4': 'FD_DAY_AGO_MOD_2_4',
	            'MOD_OTHER': 'FD_DAY_AGO_MOD_OTHER'
	          });
	        },
	        ddiff: () => {
	          return _formatDateMessage(intval((nowDate - date) / 60 / 60 / 24 / 1000), {
	            '0': 'FD_DAY_DIFF_0',
	            '1': 'FD_DAY_DIFF_1',
	            '10_20': 'FD_DAY_DIFF_10_20',
	            'MOD_1': 'FD_DAY_DIFF_MOD_1',
	            'MOD_2_4': 'FD_DAY_DIFF_MOD_2_4',
	            'MOD_OTHER': 'FD_DAY_DIFF_MOD_OTHER'
	          });
	        },
	        dshort: () => {
	          return this._getMessage('FD_DAY_SHORT').replace(/#VALUE#/g, intval((nowDate - date) / 60 / 60 / 24 / 1000));
	        },
	        mago: () => {
	          return _formatDateMessage(intval((nowDate - date) / 60 / 60 / 24 / 31 / 1000), {
	            '0': 'FD_MONTH_AGO_0',
	            '1': 'FD_MONTH_AGO_1',
	            '10_20': 'FD_MONTH_AGO_10_20',
	            'MOD_1': 'FD_MONTH_AGO_MOD_1',
	            'MOD_2_4': 'FD_MONTH_AGO_MOD_2_4',
	            'MOD_OTHER': 'FD_MONTH_AGO_MOD_OTHER'
	          });
	        },
	        mdiff: () => {
	          return _formatDateMessage(intval((nowDate - date) / 60 / 60 / 24 / 31 / 1000), {
	            '0': 'FD_MONTH_DIFF_0',
	            '1': 'FD_MONTH_DIFF_1',
	            '10_20': 'FD_MONTH_DIFF_10_20',
	            'MOD_1': 'FD_MONTH_DIFF_MOD_1',
	            'MOD_2_4': 'FD_MONTH_DIFF_MOD_2_4',
	            'MOD_OTHER': 'FD_MONTH_DIFF_MOD_OTHER'
	          });
	        },
	        mshort: () => {
	          return this._getMessage('FD_MONTH_SHORT').replace(/#VALUE#/g, intval((nowDate - date) / 60 / 60 / 24 / 31 / 1000));
	        },
	        Yago: () => {
	          return _formatDateMessage(intval((nowDate - date) / 60 / 60 / 24 / 365 / 1000), {
	            '0': 'FD_YEARS_AGO_0',
	            '1': 'FD_YEARS_AGO_1',
	            '10_20': 'FD_YEARS_AGO_10_20',
	            'MOD_1': 'FD_YEARS_AGO_MOD_1',
	            'MOD_2_4': 'FD_YEARS_AGO_MOD_2_4',
	            'MOD_OTHER': 'FD_YEARS_AGO_MOD_OTHER'
	          });
	        },
	        Ydiff: () => {
	          return _formatDateMessage(intval((nowDate - date) / 60 / 60 / 24 / 365 / 1000), {
	            '0': 'FD_YEARS_DIFF_0',
	            '1': 'FD_YEARS_DIFF_1',
	            '10_20': 'FD_YEARS_DIFF_10_20',
	            'MOD_1': 'FD_YEARS_DIFF_MOD_1',
	            'MOD_2_4': 'FD_YEARS_DIFF_MOD_2_4',
	            'MOD_OTHER': 'FD_YEARS_DIFF_MOD_OTHER'
	          });
	        },
	        Yshort: () => {
	          return _formatDateMessage(intval((nowDate - date) / 60 / 60 / 24 / 365 / 1000), {
	            '0': 'FD_YEARS_SHORT_0',
	            '1': 'FD_YEARS_SHORT_1',
	            '10_20': 'FD_YEARS_SHORT_10_20',
	            'MOD_1': 'FD_YEARS_SHORT_MOD_1',
	            'MOD_2_4': 'FD_YEARS_SHORT_MOD_2_4',
	            'MOD_OTHER': 'FD_YEARS_SHORT_MOD_OTHER'
	          });
	        },
	        x: () => {
	          const ampm = this.isAmPmMode(true);
	          const timeFormat = ampm === this.AM_PM_MODE.LOWER ? 'g:i a' : ampm === this.AM_PM_MODE.UPPER ? 'g:i A' : 'H:i';
	          return this.format([['tomorrow', 'tomorrow, ' + timeFormat], ['-', this.convertBitrixFormat(this._getMessage('FORMAT_DATETIME')).replace(/:s/g, '')], ['s', 'sago'], ['i', 'iago'], ['today', 'today, ' + timeFormat], ['yesterday', 'yesterday, ' + timeFormat], ['', this.convertBitrixFormat(this._getMessage('FORMAT_DATETIME')).replace(/:s/g, '')]], date, nowDate, isUTC);
	        },
	        X: () => {
	          const ampm = this.isAmPmMode(true);
	          const timeFormat = ampm === this.AM_PM_MODE.LOWER ? 'g:i a' : ampm === this.AM_PM_MODE.UPPER ? 'g:i A' : 'H:i';
	          const day = this.format([['tomorrow', 'tomorrow'], ['-', this.convertBitrixFormat(this._getMessage('FORMAT_DATE'))], ['today', 'today'], ['yesterday', 'yesterday'], ['', this.convertBitrixFormat(this._getMessage('FORMAT_DATE'))]], date, nowDate, isUTC);
	          const time = this.format([['tomorrow', timeFormat], ['today', timeFormat], ['yesterday', timeFormat], ['', '']], date, nowDate, isUTC);
	          if (time.length > 0) {
	            return this._getMessage('FD_DAY_AT_TIME').replace(/#DAY#/g, day).replace(/#TIME#/g, time);
	          } else {
	            return day;
	          }
	        },
	        Q: () => {
	          const daysAgo = intval((nowDate - date) / 60 / 60 / 24 / 1000);
	          if (daysAgo == 0) {
	            return this._getMessage('FD_DAY_DIFF_1').replace(/#VALUE#/g, 1);
	          } else {
	            return this.format([['d', 'ddiff'], ['m', 'mdiff'], ['', 'Ydiff']], date, nowDate);
	          }
	        }
	      };
	      let cutZeroTime = false;
	      if (_format[0] && _format[0] == '^') {
	        cutZeroTime = true;
	        _format = _format.substr(1);
	      }
	      let result = _format.replace(formatRegex, _replaceDateFormat);
	      if (cutZeroTime) {
	        /* 	15.04.12 13:00:00 => 15.04.12 13:00
	        	00:01:00 => 00:01
	        	4 may 00:00:00 => 4 may
	        	01-01-12 00:00 => 01-01-12
	        */

	        result = result.replace(/\s*00:00:00\s*/g, '').replace(/(\d\d:\d\d)(:00)/g, '$1').replace(/(\s*00:00\s*)(?!:)/g, '');
	      }
	      if (replaceMap.length > 0) {
	        replaceMap.forEach(function (element, index) {
	          result = result.replace('{{' + index + '}}', element);
	        });
	      }
	      return result;
	      function _formatDateInterval(formats, date, nowDate, isUTC) {
	        const secondsAgo = intval((nowDate - date) / 1000);
	        for (let i = 0; i < formats.length; i++) {
	          const formatInterval = formats[i][0];
	          const formatValue = formats[i][1];
	          let match = null;
	          if (formatInterval == 's') {
	            if (secondsAgo < 60) {
	              return thisDateTimeFormat.format(formatValue, date, nowDate, isUTC);
	            }
	          } else if ((match = /^s(\d+)\>?(\d+)?/.exec(formatInterval)) != null) {
	            if (match[1] && match[2]) {
	              if (secondsAgo < match[1] && secondsAgo > match[2]) {
	                return thisDateTimeFormat.format(formatValue, date, nowDate, isUTC);
	              }
	            } else if (secondsAgo < match[1]) {
	              return thisDateTimeFormat.format(formatValue, date, nowDate, isUTC);
	            }
	          } else if (formatInterval == 'i') {
	            if (secondsAgo < 60 * 60) {
	              return thisDateTimeFormat.format(formatValue, date, nowDate, isUTC);
	            }
	          } else if ((match = /^i(\d+)\>?(\d+)?/.exec(formatInterval)) != null) {
	            if (match[1] && match[2]) {
	              if (secondsAgo < match[1] * 60 && secondsAgo > match[2] * 60) {
	                return thisDateTimeFormat.format(formatValue, date, nowDate, isUTC);
	              }
	            } else if (secondsAgo < match[1] * 60) {
	              return thisDateTimeFormat.format(formatValue, date, nowDate, isUTC);
	            }
	          } else if (formatInterval == 'H') {
	            if (secondsAgo < 24 * 60 * 60) {
	              return thisDateTimeFormat.format(formatValue, date, nowDate, isUTC);
	            }
	          } else if ((match = /^H(\d+)\>?(\d+)?/.exec(formatInterval)) != null) {
	            if (match[1] && match[2]) {
	              if (secondsAgo < match[1] * 60 * 60 && secondsAgo > match[2] * 60 * 60) {
	                return thisDateTimeFormat.format(formatValue, date, nowDate, isUTC);
	              }
	            } else if (secondsAgo < match[1] * 60 * 60) {
	              return thisDateTimeFormat.format(formatValue, date, nowDate, isUTC);
	            }
	          } else if (formatInterval == 'd') {
	            if (secondsAgo < 31 * 24 * 60 * 60) {
	              return thisDateTimeFormat.format(formatValue, date, nowDate, isUTC);
	            }
	          } else if ((match = /^d(\d+)\>?(\d+)?/.exec(formatInterval)) != null) {
	            if (match[1] && match[2]) {
	              if (secondsAgo < match[1] * 24 * 60 * 60 && secondsAgo > match[2] * 24 * 60 * 60) {
	                return thisDateTimeFormat.format(formatValue, date, nowDate, isUTC);
	              }
	            } else if (secondsAgo < match[1] * 24 * 60 * 60) {
	              return thisDateTimeFormat.format(formatValue, date, nowDate, isUTC);
	            }
	          } else if (formatInterval == 'm') {
	            if (secondsAgo < 365 * 24 * 60 * 60) {
	              return thisDateTimeFormat.format(formatValue, date, nowDate, isUTC);
	            }
	          } else if ((match = /^m(\d+)\>?(\d+)?/.exec(formatInterval)) != null) {
	            if (match[1] && match[2]) {
	              if (secondsAgo < match[1] * 31 * 24 * 60 * 60 && secondsAgo > match[2] * 31 * 24 * 60 * 60) {
	                return thisDateTimeFormat.format(formatValue, date, nowDate, isUTC);
	              }
	            } else if (secondsAgo < match[1] * 31 * 24 * 60 * 60) {
	              return thisDateTimeFormat.format(formatValue, date, nowDate, isUTC);
	            }
	          } else if (formatInterval == 'now') {
	            if (date.getTime() == nowDate.getTime()) {
	              return thisDateTimeFormat.format(formatValue, date, nowDate, isUTC);
	            }
	          } else if (formatInterval == 'today') {
	            const year = getFullYear(nowDate);
	            const month = getMonth(nowDate);
	            const day = getDate(nowDate);
	            const todayStart = isUTC ? new Date(Date.UTC(year, month, day, 0, 0, 0, 0)) : new Date(year, month, day, 0, 0, 0, 0);
	            const todayEnd = isUTC ? new Date(Date.UTC(year, month, day + 1, 0, 0, 0, 0)) : new Date(year, month, day + 1, 0, 0, 0, 0);
	            if (date >= todayStart && date < todayEnd) {
	              return thisDateTimeFormat.format(formatValue, date, nowDate, isUTC);
	            }
	          } else if (formatInterval == 'todayFuture') {
	            const year = getFullYear(nowDate);
	            const month = getMonth(nowDate);
	            const day = getDate(nowDate);
	            const todayStart = nowDate.getTime();
	            const todayEnd = isUTC ? new Date(Date.UTC(year, month, day + 1, 0, 0, 0, 0)) : new Date(year, month, day + 1, 0, 0, 0, 0);
	            if (date >= todayStart && date < todayEnd) {
	              return thisDateTimeFormat.format(formatValue, date, nowDate, isUTC);
	            }
	          } else if (formatInterval == 'yesterday') {
	            const year = getFullYear(nowDate);
	            const month = getMonth(nowDate);
	            const day = getDate(nowDate);
	            const yesterdayStart = isUTC ? new Date(Date.UTC(year, month, day - 1, 0, 0, 0, 0)) : new Date(year, month, day - 1, 0, 0, 0, 0);
	            const yesterdayEnd = isUTC ? new Date(Date.UTC(year, month, day, 0, 0, 0, 0)) : new Date(year, month, day, 0, 0, 0, 0);
	            if (date >= yesterdayStart && date < yesterdayEnd) {
	              return thisDateTimeFormat.format(formatValue, date, nowDate, isUTC);
	            }
	          } else if (formatInterval == 'tommorow' || formatInterval == 'tomorrow') {
	            const year = getFullYear(nowDate);
	            const month = getMonth(nowDate);
	            const day = getDate(nowDate);
	            const tomorrowStart = isUTC ? new Date(Date.UTC(year, month, day + 1, 0, 0, 0, 0)) : new Date(year, month, day + 1, 0, 0, 0, 0);
	            const tomorrowEnd = isUTC ? new Date(Date.UTC(year, month, day + 2, 0, 0, 0, 0)) : new Date(year, month, day + 2, 0, 0, 0, 0);
	            if (date >= tomorrowStart && date < tomorrowEnd) {
	              return thisDateTimeFormat.format(formatValue, date, nowDate, isUTC);
	            }
	          } else if (formatInterval == '-') {
	            if (secondsAgo < 0) {
	              return thisDateTimeFormat.format(formatValue, date, nowDate, isUTC);
	            }
	          }
	        }

	        //return formats.length > 0 ? thisDateTimeFormat.format(formats.pop()[1], date, nowDate, isUTC) : '';
	        return formats.length > 0 ? thisDateTimeFormat.format(formats[formats.length - 1][1], date, nowDate, isUTC) : '';
	      }
	      function getFullYear(date) {
	        return isUTC ? date.getUTCFullYear() : date.getFullYear();
	      }
	      function getDate(date) {
	        return isUTC ? date.getUTCDate() : date.getDate();
	      }
	      function getMonth(date) {
	        return isUTC ? date.getUTCMonth() : date.getMonth();
	      }
	      function getHours(date) {
	        return isUTC ? date.getUTCHours() : date.getHours();
	      }
	      function getMinutes(date) {
	        return isUTC ? date.getUTCMinutes() : date.getMinutes();
	      }
	      function getSeconds(date) {
	        return isUTC ? date.getUTCSeconds() : date.getSeconds();
	      }
	      function getMilliseconds(date) {
	        return isUTC ? date.getUTCMilliseconds() : date.getMilliseconds();
	      }
	      function getDay(date) {
	        return isUTC ? date.getUTCDay() : date.getDay();
	      }
	      function setDate(date, dayValue) {
	        return isUTC ? date.setUTCDate(dayValue) : date.setDate(dayValue);
	      }
	      function setMonth(date, monthValue, dayValue) {
	        return isUTC ? date.setUTCMonth(monthValue, dayValue) : date.setMonth(monthValue, dayValue);
	      }
	      function _formatDateMessage(value, messages) {
	        const val = value < 100 ? Math.abs(value) : Math.abs(value % 100);
	        const dec = val % 10;
	        let message = '';
	        if (val == 0) {
	          message = thisDateTimeFormat._getMessage(messages['0']);
	        } else if (val == 1) {
	          message = thisDateTimeFormat._getMessage(messages['1']);
	        } else if (val >= 10 && val <= 20) {
	          message = thisDateTimeFormat._getMessage(messages['10_20']);
	        } else if (dec == 1) {
	          message = thisDateTimeFormat._getMessage(messages['MOD_1']);
	        } else if (2 <= dec && dec <= 4) {
	          message = thisDateTimeFormat._getMessage(messages['MOD_2_4']);
	        } else {
	          message = thisDateTimeFormat._getMessage(messages['MOD_OTHER']);
	        }
	        return message.replace(/#VALUE#/g, value);
	      }
	      function _replaceDateFormat(match, matchFull) {
	        if (dateFormats[match]) {
	          return dateFormats[match]();
	        } else {
	          return matchFull;
	        }
	      }
	      function intval(number) {
	        return number >= 0 ? Math.floor(number) : Math.ceil(number);
	      }
	    }
	  }]);
	  return DateTimeFormat;
	}();
	babelHelpers.defineProperty(DateTimeFormat, "AM_PM_MODE", {
	  UPPER: 1,
	  LOWER: 2,
	  NONE: false
	});
	babelHelpers.defineProperty(DateTimeFormat, "convertBitrixFormat", convertBitrixFormat);
	babelHelpers.defineProperty(DateTimeFormat, "getFormat", getFormat);

	const cache = new main_core.Cache.MemoryCache();

	/**
	 * @memberOf BX.Main.Timezone
	 *
	 * WARNING! Don't use this class or any classes from Timezone namespace on sites without Bitrix Framework.
	 * It is not designed to handle this case and will definitely break.
	 */
	const Offset = {
	  get SERVER_TO_UTC() {
	    return cache.remember('SERVER_TO_UTC', () => {
	      return main_core.Text.toInteger(main_core.Loc.getMessage('SERVER_TZ_OFFSET'));
	    });
	  },
	  get USER_TO_SERVER() {
	    return cache.remember('USER_TO_SERVER', () => {
	      return main_core.Text.toInteger(main_core.Loc.getMessage('USER_TZ_OFFSET'));
	    });
	  },
	  // Date returns timezone offset in minutes by default, change it to seconds
	  // Also offset is negative in UTC+ timezones and positive in UTC- timezones.
	  // By convention Bitrix uses the opposite approach, so change offset sign.
	  get BROWSER_TO_UTC() {
	    return cache.remember('BROWSER_TO_UTC', () => {
	      return main_core.Text.toInteger(new Date().getTimezoneOffset() * 60);
	    });
	  }
	};
	Object.freeze(Offset);

	function _classStaticPrivateMethodGet(receiver, classConstructor, method) { _classCheckPrivateStaticAccess(receiver, classConstructor); return method; }
	function _classCheckPrivateStaticAccess(receiver, classConstructor) { if (receiver !== classConstructor) { throw new TypeError("Private static access of wrong provenance"); } }

	/**
	 * @memberOf BX.Main.Timezone
	 *
	 * WARNING! Don't use this class or any classes from Timezone namespace on sites without Bitrix Framework.
	 * It is not designed to handle this case and will definitely break.
	 */
	let BrowserTime = /*#__PURE__*/function () {
	  function BrowserTime() {
	    babelHelpers.classCallCheck(this, BrowserTime);
	  }
	  babelHelpers.createClass(BrowserTime, null, [{
	    key: "getTimestamp",
	    /**
	     * Returns timestamp with current time in browser timezone.
	     *
	     * @returns {number} timestamp in seconds
	     */
	    value: function getTimestamp() {
	      return Math.round(Date.now() / 1000);
	    }
	    /**
	     * Returns Date object with current time in browser timezone.
	     *
	     * @returns {Date}
	     */
	  }, {
	    key: "getDate",
	    value: function getDate() {
	      return new Date(this.getTimestamp() * 1000);
	    }
	    /**
	     * Converts timestamp in browser timezone to timestamp in user timezone.
	     *
	     * @param browserTimestamp timestamp in browser timezone in seconds
	     * @returns {number} timestamp in user timezone in seconds
	     */
	  }, {
	    key: "toUser",
	    value: function toUser(browserTimestamp) {
	      return main_core.Text.toInteger(browserTimestamp) + Offset.USER_TO_SERVER;
	    }
	    /**
	     * Converts timestamp in browser timezone to timestamp in server timezone.
	     *
	     * @param browserTimestamp timestamp in browser timezone in seconds
	     * @returns {number} timestamp in server timezone in seconds
	     */
	  }, {
	    key: "toServer",
	    value: function toServer(browserTimestamp) {
	      return _classStaticPrivateMethodGet(this, BrowserTime, _toUTC).call(this, browserTimestamp) + Offset.SERVER_TO_UTC;
	    }
	  }]);
	  return BrowserTime;
	}();
	function _toUTC(browserTimestamp) {
	  return main_core.Text.toInteger(browserTimestamp) - Offset.BROWSER_TO_UTC;
	}

	/**
	 * @memberOf BX.Main.Timezone
	 *
	 * WARNING! Don't use this class or any classes from Timezone namespace on sites without Bitrix Framework.
	 * It is not designed to handle this case and will definitely break.
	 *
	 * ATTENTION! In Bitrix user timezone !== browser timezone. Users can change their timezone from their profile settings
	 * and the timezone will be different from browser timezone.
	 */
	let UserTime = /*#__PURE__*/function () {
	  function UserTime() {
	    babelHelpers.classCallCheck(this, UserTime);
	  }
	  babelHelpers.createClass(UserTime, null, [{
	    key: "getTimestamp",
	    /**
	     * Returns timestamp with current time in user timezone.
	     *
	     * @returns {number} timestamp in seconds
	     */
	    value: function getTimestamp() {
	      return BrowserTime.toUser(BrowserTime.getTimestamp());
	    }
	    /**
	     * Returns Date object with current time in user timezone. If you need to get 'now' in a user's perspective,
	     * use this method instead of 'new Date()'.
	     *
	     * Note that 'getTimezoneOffset' will not return correct user timezone, its always returns browser offset
	     *
	     * @returns {Date}
	     */
	  }, {
	    key: "getDate",
	    value: function getDate() {
	      return new Date(this.getTimestamp() * 1000);
	    }
	    /**
	     * Converts timestamp in user timezone to timestamp in browser timezone.
	     *
	     * @param userTimestamp timestamp in user timezone in seconds
	     * @returns {number} timestamp in browser timezone in seconds
	     */
	  }, {
	    key: "toBrowser",
	    value: function toBrowser(userTimestamp) {
	      return main_core.Text.toInteger(userTimestamp) + Offset.BROWSER_TO_UTC - Offset.SERVER_TO_UTC - Offset.USER_TO_SERVER;
	    }
	    /**
	     * Converts timestamp in user timezone to timestamp in server timezone.
	     *
	     * @param userTimestamp timestamp in user timezone in seconds
	     * @returns {number} timestamp in server timezone in seconds
	     */
	  }, {
	    key: "toServer",
	    value: function toServer(userTimestamp) {
	      return main_core.Text.toInteger(userTimestamp) - Offset.USER_TO_SERVER;
	    }
	  }]);
	  return UserTime;
	}();

	/**
	 * @memberOf BX.Main.Timezone
	 *
	 * WARNING! Don't use this class or any classes from Timezone namespace on sites without Bitrix Framework.
	 * It is not designed to handle this case and will definitely break.
	 */
	let ServerTime = /*#__PURE__*/function () {
	  function ServerTime() {
	    babelHelpers.classCallCheck(this, ServerTime);
	  }
	  babelHelpers.createClass(ServerTime, null, [{
	    key: "getTimestamp",
	    /**
	     * Returns timestamp with current time in server timezone.
	     *
	     * @returns {number} timestamp in seconds
	     */
	    value: function getTimestamp() {
	      return BrowserTime.toServer(BrowserTime.getTimestamp());
	    }
	    /**
	     * Returns Date object with current time in server timezone.
	     *
	     * Note that 'getTimezoneOffset' will not return correct server timezone, its always returns browser offset
	     *
	     * @returns {Date}
	     */
	  }, {
	    key: "getDate",
	    value: function getDate() {
	      return new Date(this.getTimestamp() * 1000);
	    }
	    /**
	     * Converts timestamp in server timezone to timestamp in user timezone.
	     *
	     * @param serverTimestamp timestamp in server timezone in seconds
	     * @returns {number} timestamp in user timezone in seconds
	     */
	  }, {
	    key: "toUser",
	    value: function toUser(serverTimestamp) {
	      return main_core.Text.toInteger(serverTimestamp) + Offset.USER_TO_SERVER;
	    }
	    /**
	     * Converts timestamp in server timezone to timestamp in browser timezone.
	     *
	     * @param serverTimestamp timestamp in server timezone in seconds
	     * @returns {number} timestamp in browser timezone in seconds
	     */
	  }, {
	    key: "toBrowser",
	    value: function toBrowser(serverTimestamp) {
	      return main_core.Text.toInteger(serverTimestamp) + Offset.BROWSER_TO_UTC - Offset.SERVER_TO_UTC;
	    }
	  }]);
	  return ServerTime;
	}();

	//compatibility alias
	const Date$1 = DateTimeFormat;
	const Timezone = Object.freeze({
	  Offset,
	  BrowserTime,
	  UserTime,
	  ServerTime
	});

	exports.DateTimeFormat = DateTimeFormat;
	exports.Date = Date$1;
	exports.Timezone = Timezone;

}((this.BX.Main = this.BX.Main || {}),BX));





// file: /bitrix/js/im/lib/utils/dist/utils.bundle.js
this.BX = this.BX || {};
this.BX.Messenger = this.BX.Messenger || {};
(function (exports,im_const) {
	'use strict';

	/**
	 * Bitrix Messenger
	 * Utils
	 *
	 * @package bitrix
	 * @subpackage im
	 * @copyright 2001-2019 Bitrix
	 */
	var Utils = {
	  browser: {
	    isSafari: function isSafari() {
	      if (this.isChrome()) {
	        return false;
	      }
	      if (!navigator.userAgent.toLowerCase().includes('safari')) {
	        return false;
	      }
	      return !this.isSafariBased();
	    },
	    isSafariBased: function isSafariBased() {
	      if (!navigator.userAgent.toLowerCase().includes('applewebkit')) {
	        return false;
	      }
	      return navigator.userAgent.toLowerCase().includes('yabrowser') || navigator.userAgent.toLowerCase().includes('yaapp_ios_browser') || navigator.userAgent.toLowerCase().includes('crios');
	    },
	    isChrome: function isChrome() {
	      return navigator.userAgent.toLowerCase().includes('chrome');
	    },
	    isFirefox: function isFirefox() {
	      return navigator.userAgent.toLowerCase().includes('firefox');
	    },
	    isIe: function isIe() {
	      return navigator.userAgent.match(/(Trident\/|MSIE\/)/) !== null;
	    },
	    findParent: function findParent(item, findTag) {
	      var isHtmlElement = findTag instanceof HTMLElement;
	      if (!findTag || typeof findTag !== 'string' && !isHtmlElement) {
	        return null;
	      }
	      for (; item && item !== document; item = item.parentNode) {
	        if (typeof findTag === 'string') {
	          if (item.classList.contains(findTag)) {
	            return item;
	          }
	        } else if (isHtmlElement) {
	          if (item === findTag) {
	            return item;
	          }
	        }
	      }
	      return null;
	    }
	  },
	  platform: {
	    isMac: function isMac() {
	      return navigator.userAgent.toLowerCase().includes('macintosh');
	    },
	    isLinux: function isLinux() {
	      return navigator.userAgent.toLowerCase().includes('linux');
	    },
	    isWindows: function isWindows() {
	      return navigator.userAgent.toLowerCase().includes('windows') || !this.isMac() && !this.isLinux();
	    },
	    isBitrixMobile: function isBitrixMobile() {
	      return navigator.userAgent.toLowerCase().includes('bitrixmobile');
	    },
	    isBitrixDesktop: function isBitrixDesktop() {
	      return navigator.userAgent.toLowerCase().includes('bitrixdesktop');
	    },
	    getDesktopVersion: function getDesktopVersion() {
	      if (typeof this.getDesktopVersionStatic !== 'undefined') {
	        return this.getDesktopVersionStatic;
	      }
	      if (typeof BXDesktopSystem === 'undefined') {
	        return 0;
	      }
	      var version = BXDesktopSystem.GetProperty('versionParts');
	      this.getDesktopVersionStatic = version[3];
	      return this.getDesktopVersionStatic;
	    },
	    isDesktopFeatureEnabled: function isDesktopFeatureEnabled(code) {
	      if (typeof BXDesktopSystem === 'undefined') {
	        return false;
	      }
	      if (typeof BXDesktopSystem.FeatureEnabled !== 'function') {
	        return false;
	      }
	      return !!BXDesktopSystem.FeatureEnabled(code);
	    },
	    isMobile: function isMobile() {
	      return this.isAndroid() || this.isIos() || this.isBitrixMobile();
	    },
	    isIos: function isIos() {
	      return navigator.userAgent.toLowerCase().includes('iphone') || navigator.userAgent.toLowerCase().includes('ipad');
	    },
	    getIosVersion: function getIosVersion() {
	      if (!this.isIos()) {
	        return null;
	      }
	      var matches = navigator.userAgent.toLowerCase().match(/(iphone|ipad)(.+)(OS\s([0-9]+)([_.]([0-9]+))?)/i);
	      if (!matches || !matches[4]) {
	        return null;
	      }
	      return parseFloat(matches[4] + '.' + (matches[6] ? matches[6] : 0));
	    },
	    isAndroid: function isAndroid() {
	      return navigator.userAgent.toLowerCase().includes('android');
	    },
	    openNewPage: function openNewPage(url) {
	      if (!url) {
	        return false;
	      }
	      if (this.isBitrixMobile()) {
	        if (typeof BX.MobileTools !== 'undefined') {
	          var openWidget = BX.MobileTools.resolveOpenFunction(url);
	          if (openWidget) {
	            openWidget();
	            return true;
	          }
	        }
	        app.openNewPage(url);
	      } else {
	        window.open(url, '_blank');
	      }
	      return true;
	    }
	  },
	  device: {
	    isDesktop: function isDesktop() {
	      return !this.isMobile();
	    },
	    isMobile: function isMobile() {
	      if (typeof this.isMobileStatic !== 'undefined') {
	        return this.isMobileStatic;
	      }
	      this.isMobileStatic = navigator.userAgent.toLowerCase().includes('android') || navigator.userAgent.toLowerCase().includes('webos') || navigator.userAgent.toLowerCase().includes('iphone') || navigator.userAgent.toLowerCase().includes('ipad') || navigator.userAgent.toLowerCase().includes('ipod') || navigator.userAgent.toLowerCase().includes('blackberry') || navigator.userAgent.toLowerCase().includes('windows phone');
	      return this.isMobileStatic;
	    },
	    orientationHorizontal: 'horizontal',
	    orientationPortrait: 'portrait',
	    getOrientation: function getOrientation() {
	      if (!this.isMobile()) {
	        return this.orientationHorizontal;
	      }
	      return Math.abs(window.orientation) === 0 ? this.orientationPortrait : this.orientationHorizontal;
	    }
	  },
	  types: {
	    isString: function isString(item) {
	      return item === '' ? true : item ? typeof item == "string" || item instanceof String : false;
	    },
	    isArray: function isArray(item) {
	      return item && Object.prototype.toString.call(item) == "[object Array]";
	    },
	    isFunction: function isFunction(item) {
	      return item === null ? false : typeof item == "function" || item instanceof Function;
	    },
	    isDomNode: function isDomNode(item) {
	      return item && babelHelpers["typeof"](item) == "object" && "nodeType" in item;
	    },
	    isDate: function isDate(item) {
	      return item && Object.prototype.toString.call(item) == "[object Date]";
	    },
	    isPlainObject: function isPlainObject(item) {
	      if (!item || babelHelpers["typeof"](item) !== "object" || item.nodeType) {
	        return false;
	      }
	      var hasProp = Object.prototype.hasOwnProperty;
	      try {
	        if (item.constructor && !hasProp.call(item, "constructor") && !hasProp.call(item.constructor.prototype, "isPrototypeOf")) {
	          return false;
	        }
	      } catch (e) {
	        return false;
	      }
	      var key;
	      return typeof key === "undefined" || hasProp.call(item, key);
	    },
	    isUuidV4: function isUuidV4(uuid) {
	      if (!this.isString(uuid)) {
	        return false;
	      }
	      var uuidV4pattern = new RegExp(/^[0-9A-F]{8}-[0-9A-F]{4}-4[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i);
	      return uuid.search(uuidV4pattern) === 0;
	    }
	  },
	  dialog: {
	    getChatIdByDialogId: function getChatIdByDialogId(dialogId) {
	      if (!this.isChatId(dialogId)) {
	        return 0;
	      }
	      return parseInt(dialogId.toString().substr(4));
	    },
	    isChatId: function isChatId(dialogId) {
	      return dialogId.toString().startsWith('chat');
	    },
	    isEmptyDialogId: function isEmptyDialogId(dialogId) {
	      if (!dialogId) {
	        return true;
	      }
	      if (typeof dialogId === "string") {
	        if (dialogId === 'chat0' || dialogId === "0") {
	          return true;
	        }
	      }
	      return false;
	    }
	  },
	  text: {
	    quote: function quote(text, params) {
	      var files = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
	      var localize = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
	      if (typeof text !== 'string') {
	        return text.toString();
	      }
	      if (!localize) {
	        localize = BX.message;
	      }
	      text = text.replace(/\[USER=([0-9]{1,})](.*?)\[\/USER]/ig, function (whole, userId, text) {
	        return text;
	      });
	      text = text.replace(/\[CHAT=(imol\|)?([0-9]{1,})](.*?)[\/CHAT]/ig, function (whole, imol, chatId, text) {
	        return text;
	      });
	      text = text.replace(/\[CALL(?:=(.+?))?](.+?)?\[\/CALL]/ig, function (whole, command, text) {
	        return text ? text : command;
	      });
	      text = text.replace(/\[ATTACH=([0-9]{1,})]/ig, function (whole, command, text) {
	        return command === 10000 ? '' : '[' + localize['IM_UTILS_TEXT_ATTACH'] + '] ';
	      });
	      text = text.replace(/\[RATING=([1-5]{1})]/ig, function (whole, rating) {
	        return '[' + localize.IM_F_RATING + '] ';
	      });
	      text = text.replace(/&nbsp;/ig, " ");
	      text = text.replace(/\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D([\s\S]*?)\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D/gmi, "[" + localize["IM_UTILS_TEXT_QUOTE"] + "]");
	      text = text.replace(/^(>>(.*)\n)/gi, "[" + localize["IM_UTILS_TEXT_QUOTE"] + "]\n");
	      if (params && params.FILE_ID && params.FILE_ID.length > 0) {
	        var filesText = [];
	        params.FILE_ID.forEach(function (fileId) {
	          if (files[fileId].type === 'image') {
	            filesText.push(localize['IM_UTILS_TEXT_IMAGE']);
	          } else if (files[fileId].type === 'audio') {
	            filesText.push(localize['IM_UTILS_TEXT_AUDIO']);
	          } else if (files[fileId].type === 'video') {
	            filesText.push(localize['IM_UTILS_TEXT_VIDEO']);
	          } else {
	            filesText.push(files[fileId].name);
	          }
	        });
	        if (filesText.length <= 0) {
	          filesText.push(localize['IM_UTILS_TEXT_FILE']);
	        }
	        text = filesText.join('\n') + text;
	      } else if (params && params.ATTACH && params.ATTACH.length > 0) {
	        text = '[' + localize['IM_UTILS_TEXT_ATTACH'] + ']\n' + text;
	      }
	      if (text.length <= 0) {
	        text = localize['IM_UTILS_TEXT_DELETED'];
	      }
	      return text.trim();
	    },
	    purify: function purify(text, params) {
	      var files = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
	      var localize = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
	      if (typeof text !== 'string') {
	        return text.toString();
	      }
	      if (!localize) {
	        localize = BX.message;
	      }
	      text = text.trim();
	      if (text.startsWith('/me')) {
	        text = text.substr(4);
	      } else if (text.startsWith('/loud')) {
	        text = text.substr(6);
	      }
	      text = text.replace(/<br><br \/>/ig, '<br />');
	      text = text.replace(/<br \/><br>/ig, '<br />');
	      var codeReplacement = [];
	      text = text.replace(/\[CODE\](<br \/>)?([\s\S]*?)\[\/CODE\]/ig, function (whole, br, text) {
	        var id = codeReplacement.length;
	        codeReplacement.push(text);
	        return '####REPLACEMENT_CODE_' + id + '####';
	      });
	      text = text.replace(/\[PUT(?:=(?:.+?))?\](?:.+?)?\[\/PUT]/ig, function (match) {
	        return match.replace(/\[PUT(?:=(.+))?\](.+?)?\[\/PUT]/ig, function (whole, command, text) {
	          return text ? text : command;
	        });
	      });
	      text = text.replace(/\[SEND(?:=(?:.+?))?\](?:.+?)?\[\/SEND]/ig, function (match) {
	        return match.replace(/\[SEND(?:=(.+))?\](.+?)?\[\/SEND]/ig, function (whole, command, text) {
	          return text ? text : command;
	        });
	      });
	      text = text.replace(/\[[buis]](.*?)\[\/[buis]]/ig, '$1');
	      text = text.replace(/\[url](.*?)\[\/url]/ig, '$1');
	      text = text.replace(/\[RATING=([1-5]{1})]/ig, function () {
	        return '[' + localize['IM_UTILS_TEXT_RATING'] + '] ';
	      });
	      text = text.replace(/\[ATTACH=([0-9]{1,})]/ig, function () {
	        return '[' + localize['IM_UTILS_TEXT_ATTACH'] + '] ';
	      });
	      text = text.replace(/\[USER=([0-9]+)( REPLACE)?](.*?)](.*?)\[\/USER]/ig, '$3');
	      text = text.replace(/\[CHAT=([0-9]{1,})](.*?)\[\/CHAT]/ig, '$2');
	      text = text.replace(/\[context=(chat\d+|\d+:\d+)\/(\d+)](.*?)\[\/context]/gi, function (whole, dialogId, messageId, message) {
	        return message;
	      });
	      text = text.replace(/\[SEND(?:=(?:.+?))?\](.+?)?\[\/SEND]/ig, '$1');
	      text = text.replace(/\[PUT(?:=(?:.+?))?\](.+?)?\[\/PUT]/ig, '$1');
	      text = text.replace(/\[CALL=(.*?)](.*?)\[\/CALL\]/ig, '$2');
	      text = text.replace(/\[PCH=([0-9]{1,})](.*?)\[\/PCH]/ig, '$2');
	      text = text.replace(/\[size=(\d+)](.*?)\[\/size]/ig, '$2');
	      text = text.replace(/\[color=#([0-9a-f]{3}|[0-9a-f]{6})](.*?)\[\/color]/ig, '$2');
	      text = text.replace(/<img.*?data-code="([^"]*)".*?>/ig, '$1');
	      text = text.replace(/<span.*?title="([^"]*)".*?>.*?<\/span>/ig, '($1)');
	      text = text.replace(/<img.*?title="([^"]*)".*?>/ig, '($1)');
	      text = text.replace(/\[ATTACH=([0-9]{1,})]/ig, function (whole, command, text) {
	        return command === 10000 ? '' : '[' + localize['IM_UTILS_TEXT_ATTACH'] + '] ';
	      });
	      text = text.replace(/<s>([^"]*)<\/s>/ig, ' ');
	      text = text.replace(/\[s]([^"]*)\[\/s]/ig, ' ');
	      text = text.replace(/\[icon=([^\]]*)]/ig, function (whole) {
	        var title = whole.match(/title=(.*[^\s\]])/i);
	        if (title && title[1]) {
	          title = title[1];
	          if (title.indexOf('width=') > -1) {
	            title = title.substr(0, title.indexOf('width='));
	          }
	          if (title.indexOf('height=') > -1) {
	            title = title.substr(0, title.indexOf('height='));
	          }
	          if (title.indexOf('size=') > -1) {
	            title = title.substr(0, title.indexOf('size='));
	          }
	          if (title) {
	            title = '(' + title.trim() + ')';
	          }
	        } else {
	          title = '(' + localize['IM_UTILS_TEXT_ICON'] + ')';
	        }
	        return title;
	      });
	      codeReplacement.forEach(function (element, index) {
	        text = text.replace('####REPLACEMENT_CODE_' + index + '####', element);
	      });
	      text = text.replace(/\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D([\s\S]*?)\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D\x2D/gmi, "[" + localize["IM_UTILS_TEXT_QUOTE"] + "] ");
	      text = text.replace(/^(>>(.*)(\n)?)/gmi, "[" + localize["IM_UTILS_TEXT_QUOTE"] + "] ");
	      text = text.replace(/<\/?[^>]+>/gi, '');
	      if (params && params.FILE_ID && params.FILE_ID.length > 0) {
	        var filesText = [];
	        if (babelHelpers["typeof"](files) === 'object') {
	          params.FILE_ID.forEach(function (fileId) {
	            if (typeof files[fileId] === 'undefined') ; else if (files[fileId].type === 'image') {
	              filesText.push(localize['IM_UTILS_TEXT_IMAGE']);
	            } else if (files[fileId].type === 'audio') {
	              filesText.push(localize['IM_UTILS_TEXT_AUDIO']);
	            } else if (files[fileId].type === 'video') {
	              filesText.push(localize['IM_UTILS_TEXT_VIDEO']);
	            } else {
	              filesText.push(files[fileId].name);
	            }
	          });
	        }
	        if (filesText.length <= 0) {
	          filesText.push(localize['IM_UTILS_TEXT_FILE']);
	        }
	        text = filesText.join(' ') + text;
	      } else if (params && (params.WITH_ATTACH || params.ATTACH && params.ATTACH.length > 0)) {
	        text = '[' + localize['IM_UTILS_TEXT_ATTACH'] + '] ' + text;
	      } else if (params && params.WITH_FILE) {
	        text = '[' + localize['IM_UTILS_TEXT_FILE'] + '] ' + text;
	      }
	      if (text.length <= 0) {
	        text = localize['IM_UTILS_TEXT_DELETED'];
	      }
	      return text.replace('\n', ' ').trim();
	    },
	    decode: function decode() {
	      var text = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
	      if (!text) {
	        return text;
	      }
	      var enableBigSmile = true;
	      text = text.toString().trim();
	      text = Utils.text.htmlspecialchars(text);
	      if (text.startsWith('/me')) {
	        text = "<i>".concat(text.substr(4), "</i>");
	      } else if (text.startsWith('/loud')) {
	        text = "<b>".concat(text.substr(6), "</b>");
	      }
	      var quoteSign = "&gt;&gt;";
	      if (text.indexOf(quoteSign) >= 0) {
	        var textPrepare = text.split("\n");
	        for (var i = 0; i < textPrepare.length; i++) {
	          if (textPrepare[i].startsWith(quoteSign)) {
	            textPrepare[i] = textPrepare[i].replace(quoteSign, '<div class="bx-im-message-content-quote"><div class="bx-im-message-content-quote-wrap">');
	            while (++i < textPrepare.length && textPrepare[i].startsWith(quoteSign)) {
	              textPrepare[i] = textPrepare[i].replace(quoteSign, '');
	            }
	            textPrepare[i - 1] += '</div></div><br>';
	          }
	        }
	        text = textPrepare.join("<br />");
	      }
	      text = text.replace(/\n/gi, '<br />');
	      text = text.replace(/\t/gi, '&nbsp;&nbsp;&nbsp;&nbsp;');
	      text = this.decodeBbCode(text, enableBigSmile);
	      text = text.replace(/------------------------------------------------------<br \/>(.*?)\[(.*?)\](?: #(?:(?:chat)?\d+|\d+:\d+)\/\d+)?<br \/>(.*?)------------------------------------------------------(<br \/>)?/g, function (whole, p1, p2, p3, p4, offset) {
	        return (offset > 0 ? '<br>' : '') + "<div class=\"bx-im-message-content-quote\"><div class=\"bx-im-message-content-quote-wrap\"><div class=\"bx-im-message-content-quote-name\"><span class=\"bx-im-message-content-quote-name-text\">" + p1 + "</span><span class=\"bx-im-message-content-quote-name-time\">" + p2 + "</span></div>" + p3 + "</div></div><br />";
	      });
	      text = text.replace(/------------------------------------------------------<br \/>(.*?)------------------------------------------------------(<br \/>)?/g, function (whole, p1, p2, p3, offset) {
	        return (offset > 0 ? '<br>' : '') + "<div class=\"bx-im-message-content-quote\"><div class=\"bx-im-message-content-quote-wrap\">" + p1 + "</div></div><br />";
	      });
	      var changed = false;
	      text = text.replace(/(.)?((https|http):\/\/([\S]+)\.(jpg|jpeg|png|gif|webp)(\?[\S]+)?)/ig, function (whole, letter, url, offset) {
	        if (letter && !['>', ']'].includes(letter) || !url.match(/(\.(jpg|jpeg|png|gif|webp)\?|\.(jpg|jpeg|png|gif|webp)$)/i) || url.toLowerCase().indexOf("/docs/pub/") > 0 || url.toLowerCase().indexOf("logout=yes") > 0) {
	          return whole;
	        } else {
	          changed = true;
	          return (letter ? letter : '') + '<span class="bx-im-element-file-image"><img src="' + url + '" class="bx-im-element-file-image-source-text" onerror="Utils.hideErrorImage(this)"></span>';
	        }
	      });
	      if (changed) {
	        text = text.replace(/<\/span>(\n?)<\/a>(\n?)<br(\s\/?)>/ig, '</span></a>').replace(/<\/span>(\n?)(\n?)<br(\s\/?)>/ig, '</span>');
	      }
	      {
	        text = text.replace(/^(\s*<img\s+src=[^>]+?data-code=[^>]+?data-definition="UHD"[^>]+?style="width:)(\d+)(px[^>]+?height:)(\d+)(px[^>]+?class="bx-smile"\s*\/?>\s*)$/, function doubleSmileSize(match, start, width, middle, height, end) {
	          return start + parseInt(width, 10) * 1.7 + middle + parseInt(height, 10) * 1.7 + end;
	        });
	      }
	      if (text.substr(-6) == '<br />') {
	        text = text.substr(0, text.length - 6);
	      }
	      text = text.replace(/<br><br \/>/ig, '<br />');
	      text = text.replace(/<br \/><br>/ig, '<br />');
	      return text;
	    },
	    decodeBbCode: function decodeBbCode(text) {
	      var enableBigSmile = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
	      var putReplacement = [];
	      text = text.replace(/\[PUT(?:=(.+?))?\](.+?)?\[\/PUT\]/ig, function (whole) {
	        var id = putReplacement.length;
	        putReplacement.push(whole);
	        return '####REPLACEMENT_PUT_' + id + '####';
	      });
	      var sendReplacement = [];
	      text = text.replace(/\[SEND(?:=(.+?))?\](.+?)?\[\/SEND\]/ig, function (whole) {
	        var id = sendReplacement.length;
	        sendReplacement.push(whole);
	        return '####REPLACEMENT_SEND_' + id + '####';
	      });
	      var codeReplacement = [];
	      text = text.replace(/\[CODE\]\n?([\s\S]*?)\[\/CODE\]/ig, function (whole, text) {
	        var id = codeReplacement.length;
	        codeReplacement.push(text);
	        return '####REPLACEMENT_CODE_' + id + '####';
	      });
	      text = text.replace(/\[url=([^\]]+)\](.*?)\[\/url\]/ig, function (whole, link, text) {
	        var tag = document.createElement('a');
	        tag.href = Utils.text.htmlspecialcharsback(link);
	        tag.target = '_blank';
	        tag.text = Utils.text.htmlspecialcharsback(text);
	        var allowList = ["http:", "https:", "ftp:", "file:", "tel:", "callto:", "mailto:", "skype:", "viber:"];
	        if (allowList.indexOf(tag.protocol) <= -1) {
	          return whole;
	        }
	        return tag.outerHTML;
	      });
	      text = text.replace(/\[url\]([^\]]+)\[\/url\]/ig, function (whole, link) {
	        link = Utils.text.htmlspecialcharsback(link);
	        var tag = document.createElement('a');
	        tag.href = link;
	        tag.target = '_blank';
	        tag.text = link;
	        var allowList = ["http:", "https:", "ftp:", "file:", "tel:", "callto:", "mailto:", "skype:", "viber:"];
	        if (allowList.indexOf(tag.protocol) <= -1) {
	          return whole;
	        }
	        return tag.outerHTML;
	      });
	      text = text.replace(/\[size=(\d+)](.*?)\[\/size]/ig, function (whole, number, text) {
	        return '<span style="font-size: ' + number + 'px">' + text + '</span>';
	      });
	      text = text.replace(/\[color=#([0-9a-f]{3}|[0-9a-f]{6})](.*?)\[\/color]/ig, function (whole, hex, text) {
	        return '<span style="color: #' + hex + '">' + text + '</span>';
	      });
	      text = text.replace(/\[LIKE\]/ig, '<span class="bx-smile bx-im-smile-like"></span>');
	      text = text.replace(/\[DISLIKE\]/ig, '<span class="bx-smile bx-im-smile-dislike"></span>');
	      text = text.replace(/\[BR\]/ig, '<br/>');
	      text = text.replace(/\[([buis])\](.*?)\[(\/[buis])\]/ig, function (whole, open, inner, close) {
	        return '<' + open + '>' + inner + '<' + close + '>';
	      }); // TODO tag USER
	      text = text.replace(/\[USER=([0-9]+)( REPLACE)?](.*?)\[\/USER]/ig, function (whole, userId, replace, userName) {
	        if (replace) {
	          var user = BX.Messenger.Application.Core.controller.store.getters['users/get'](userId);
	          if (user) {
	            userName = Utils.text.htmlspecialchars(user.name);
	          } else if (!userName) {
	            userName = 'User ' + userId;
	          }
	        }
	        return '<span class="bx-im-mention" data-type="USER" data-value="' + userId + '">' + userName + '</span>';
	      });
	      text = text.replace(/\[CHAT=(imol\|)?([0-9]{1,})\](.*?)\[\/CHAT\]/ig, function (whole, openlines, chatId, inner) {
	        return openlines ? inner : '<span class="bx-im-mention" data-type="CHAT" data-value="chat' + chatId + '">' + inner + '</span>';
	      }); // TODO tag CHAT

	      text = text.replace(/\[context=(chat\d+|\d+:\d+)\/(\d+)](.*?)\[\/context]/gi, function (whole, dialogId, messageId, message) {
	        return message;
	      });
	      text = text.replace(/\[CALL(?:=(.+?))?\](.+?)?\[\/CALL\]/ig, function (whole, number, text) {
	        return '<span class="bx-im-mention" data-type="CALL" data-value="' + Utils.text.htmlspecialchars(number) + '">' + text + '</span>';
	      }); // TODO tag CHAT

	      text = text.replace(/\[PCH=([0-9]{1,})\](.*?)\[\/PCH\]/ig, function (whole, historyId, text) {
	        return text;
	      }); // TODO tag PCH

	      var textElementSize = 0;
	      if (enableBigSmile) {
	        textElementSize = text.replace(/\[icon\=([^\]]*)\]/ig, '').trim().length;
	      }
	      text = text.replace(/\[icon\=([^\]]*)\]/ig, function (whole) {
	        var url = whole.match(/icon\=(\S+[^\s.,> )\];\'\"!?])/i);
	        if (url && url[1]) {
	          url = url[1];
	        } else {
	          return '';
	        }
	        var attrs = {
	          'src': url,
	          'border': 0
	        };
	        var size = whole.match(/size\=(\d+)/i);
	        if (size && size[1]) {
	          attrs['width'] = size[1];
	          attrs['height'] = size[1];
	        } else {
	          var width = whole.match(/width\=(\d+)/i);
	          if (width && width[1]) {
	            attrs['width'] = width[1];
	          }
	          var height = whole.match(/height\=(\d+)/i);
	          if (height && height[1]) {
	            attrs['height'] = height[1];
	          }
	          if (attrs['width'] && !attrs['height']) {
	            attrs['height'] = attrs['width'];
	          } else if (attrs['height'] && !attrs['width']) {
	            attrs['width'] = attrs['height'];
	          } else if (attrs['height'] && attrs['width']) ; else {
	            attrs['width'] = 20;
	            attrs['height'] = 20;
	          }
	        }
	        attrs['width'] = attrs['width'] > 100 ? 100 : attrs['width'];
	        attrs['height'] = attrs['height'] > 100 ? 100 : attrs['height'];
	        if (enableBigSmile && textElementSize === 0 && attrs['width'] === attrs['height'] && attrs['width'] === 20) {
	          attrs['width'] = 40;
	          attrs['height'] = 40;
	        }
	        var title = whole.match(/title\=(.*[^\s\]])/i);
	        if (title && title[1]) {
	          title = title[1];
	          if (title.indexOf('width=') > -1) {
	            title = title.substr(0, title.indexOf('width='));
	          }
	          if (title.indexOf('height=') > -1) {
	            title = title.substr(0, title.indexOf('height='));
	          }
	          if (title.indexOf('size=') > -1) {
	            title = title.substr(0, title.indexOf('size='));
	          }
	          if (title) {
	            attrs['title'] = Utils.text.htmlspecialchars(title).trim();
	            attrs['alt'] = attrs['title'];
	          }
	        }
	        var attributes = '';
	        for (var name in attrs) {
	          if (attrs.hasOwnProperty(name)) {
	            attributes += name + '="' + attrs[name] + '" ';
	          }
	        }
	        return '<img class="bx-smile bx-icon" ' + attributes + '>';
	      });
	      sendReplacement.forEach(function (value, index) {
	        text = text.replace('####REPLACEMENT_SEND_' + index + '####', value);
	      });
	      text = text.replace(/\[SEND(?:=(?:.+?))?\](?:.+?)?\[\/SEND]/ig, function (match) {
	        return match.replace(/\[SEND(?:=(.+))?\](.+?)?\[\/SEND]/ig, function (whole, command, text) {
	          var html = '';
	          text = text ? text : command;
	          command = (command ? command : text).replace('<br />', '\n');
	          if (text) {
	            text = text.replace(/<([\w]+)[^>]*>(.*?)<\\1>/i, "$2", text);
	            text = text.replace(/\[([\w]+)[^\]]*\](.*?)\[\/\1\]/i, "$2", text);
	            command = command.split('####REPLACEMENT_PUT_').join('####REPLACEMENT_SP_');
	            html = '<!--IM_COMMAND_START-->' + '<span class="bx-im-message-command-wrap">' + '<span class="bx-im-message-command" data-entity="send">' + text + '</span>' + '<span class="bx-im-message-command-data">' + command + '</span>' + '</span>' + '<!--IM_COMMAND_END-->';
	          } else {
	            html = text;
	          }
	          return html;
	        });
	      });
	      putReplacement.forEach(function (value, index) {
	        text = text.replace('####REPLACEMENT_PUT_' + index + '####', value);
	      });
	      text = text.replace(/\[PUT(?:=(?:.+?))?\](?:.+?)?\[\/PUT]/ig, function (match) {
	        return match.replace(/\[PUT(?:=(.+))?\](.+?)?\[\/PUT]/ig, function (whole, command, text) {
	          var html = '';
	          text = text ? text : command;
	          command = (command ? command : text).replace('<br />', '\n');
	          if (text) {
	            text = text.replace(/<([\w]+)[^>]*>(.*?)<\/\1>/i, "$2", text);
	            text = text.replace(/\[([\w]+)[^\]]*\](.*?)\[\/\1\]/i, "$2", text);
	            html = '<!--IM_COMMAND_START-->' + '<span class="bx-im-message-command-wrap">' + '<span class="bx-im-message-command" data-entity="put">' + text + '</span>' + '<span class="bx-im-message-command-data">' + command + '</span>' + '</span>' + '<!--IM_COMMAND_END-->';
	          } else {
	            html = text;
	          }
	          return html;
	        });
	      });
	      codeReplacement.forEach(function (code, index) {
	        text = text.replace('####REPLACEMENT_CODE_' + index + '####', '<div class="bx-im-message-content-code">' + code + '</div>');
	      });
	      if (sendReplacement.length > 0) {
	        do {
	          sendReplacement.forEach(function (value, index) {
	            text = text.replace('####REPLACEMENT_SEND_' + index + '####', value);
	          });
	        } while (text.includes('####REPLACEMENT_SEND_'));
	      }
	      text = text.split('####REPLACEMENT_SP_').join('####REPLACEMENT_PUT_');
	      if (putReplacement.length > 0) {
	        do {
	          putReplacement.forEach(function (value, index) {
	            text = text.replace('####REPLACEMENT_PUT_' + index + '####', value);
	          });
	        } while (text.includes('####REPLACEMENT_PUT_'));
	      }
	      return text;
	    },
	    htmlspecialchars: function htmlspecialchars(text) {
	      if (typeof text !== 'string') {
	        return text;
	      }
	      return text.replace(/&/g, '&amp;').replace(/"/g, '&quot;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
	    },
	    htmlspecialcharsback: function htmlspecialcharsback(text) {
	      if (typeof text !== 'string') {
	        return text;
	      }
	      return text.replace(/\&quot;/g, '"').replace(/&#039;/g, "'").replace(/\&lt;/g, '<').replace(/\&gt;/g, '>').replace(/\&amp;/g, '&').replace(/\&nbsp;/g, ' ');
	    },
	    getLocalizeForNumber: function getLocalizeForNumber(phrase, number) {
	      var language = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'en';
	      var localize = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
	      if (!localize) {
	        localize = BX.message;
	      }
	      var pluralFormType = 1;
	      number = parseInt(number);
	      if (number < 0) {
	        number = number * -1;
	      }
	      if (language) {
	        switch (language) {
	          case 'de':
	          case 'en':
	            pluralFormType = number !== 1 ? 1 : 0;
	            break;
	          case 'ru':
	          case 'ua':
	            pluralFormType = number % 10 === 1 && number % 100 !== 11 ? 0 : number % 10 >= 2 && number % 10 <= 4 && (number % 100 < 10 || number % 100 >= 20) ? 1 : 2;
	            break;
	        }
	      }
	      return localize[phrase + '_PLURAL_' + pluralFormType];
	    }
	  },
	  date: {
	    getFormatType: function getFormatType() {
	      var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : im_const.DateFormat["default"];
	      var localize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
	      if (!localize) {
	        localize = BX.message;
	      }
	      var format = [];
	      if (type === im_const.DateFormat.groupTitle) {
	        format = [["tommorow", "tommorow"], ["today", "today"], ["yesterday", "yesterday"], ["", localize["IM_UTILS_FORMAT_DATE"]]];
	      } else if (type === im_const.DateFormat.message) {
	        format = [["", localize["IM_UTILS_FORMAT_TIME"]]];
	      } else if (type === im_const.DateFormat.recentTitle) {
	        format = [["tommorow", "today"], ["today", "today"], ["yesterday", "yesterday"], ["", localize["IM_UTILS_FORMAT_DATE_RECENT"]]];
	      } else if (type === im_const.DateFormat.recentLinesTitle) {
	        format = [["tommorow", "tommorow"], ["today", "today"], ["yesterday", "yesterday"], ["", localize["IM_UTILS_FORMAT_DATE_RECENT"]]];
	      } else if (type === im_const.DateFormat.readedTitle) {
	        format = [["tommorow", "tommorow, " + localize["IM_UTILS_FORMAT_TIME"]], ["today", "today, " + localize["IM_UTILS_FORMAT_TIME"]], ["yesterday", "yesterday, " + localize["IM_UTILS_FORMAT_TIME"]], ["", localize["IM_UTILS_FORMAT_READED"]]];
	      } else if (type === im_const.DateFormat.vacationTitle) {
	        format = [["", localize["IM_UTILS_FORMAT_DATE_SHORT"]]];
	      } else {
	        format = [["tommorow", "tommorow, " + localize["IM_UTILS_FORMAT_TIME"]], ["today", "today, " + localize["IM_UTILS_FORMAT_TIME"]], ["yesterday", "yesterday, " + localize["IM_UTILS_FORMAT_TIME"]], ["", localize["IM_UTILS_FORMAT_DATE_TIME"]]];
	      }
	      return format;
	    },
	    getDateFunction: function getDateFunction() {
	      var localize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
	      if (this.dateFormatFunction) {
	        return this.dateFormatFunction;
	      }
	      this.dateFormatFunction = Object.create(BX.Main.Date);
	      if (localize) {
	        this.dateFormatFunction._getMessage = function (phrase) {
	          return localize[phrase];
	        };
	      }
	      return this.dateFormatFunction;
	    },
	    format: function format(timestamp) {
	      var format = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
	      var localize = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
	      if (!format) {
	        format = this.getFormatType(im_const.DateFormat["default"], localize);
	      }
	      return this.getDateFunction(localize).format(format, timestamp);
	    },
	    cast: function cast(date) {
	      var def = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Date();
	      var result = def;
	      if (date instanceof Date) {
	        result = date;
	      } else if (typeof date === "string") {
	        result = new Date(date);
	      } else if (typeof date === "number") {
	        result = new Date(date * 1000);
	      }
	      if (result instanceof Date && Number.isNaN(result.getTime())) {
	        result = def;
	      }
	      return result;
	    }
	  },
	  object: {
	    countKeys: function countKeys(obj) {
	      var result = 0;
	      for (var i in obj) {
	        if (obj.hasOwnProperty(i)) {
	          result++;
	        }
	      }
	      return result;
	    }
	  },
	  user: {
	    getLastDateText: function getLastDateText(params) {
	      var localize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
	      if (!params) {
	        return '';
	      }
	      var dateFunction = Utils.date.getDateFunction(localize);
	      if (!localize) {
	        localize = BX.message || {};
	      }
	      var text = '';
	      var online = {};
	      if (params.bot || params.network) {
	        text = '';
	      } else if (params.absent && !this.isMobileActive(params, localize)) {
	        online = this.getOnlineStatus(params, localize);
	        text = localize['IM_STATUS_VACATION_TITLE'].replace('#DATE#', dateFunction.format(Utils.date.getFormatType(im_const.DateFormat.vacationTitle, localize), params.absent.getTime() / 1000));
	        if (online.isOnline && params.idle) {
	          text = localize['IM_STATUS_AWAY_TITLE'].replace('#TIME#', this.getIdleText(params, localize)) + '. ' + text;
	        } else if (online.isOnline && !online.lastSeenText) {
	          text = online.statusText + '. ' + text;
	        } else if (online.lastSeenText) {
	          if (!Utils.platform.isMobile()) {
	            text = text + '. ' + localize['IM_LAST_SEEN_' + (params.gender === 'F' ? 'F' : 'M')].replace('#POSITION#', text).replace('#LAST_SEEN#', online.lastSeenText);
	          }
	        }
	      } else if (params.lastActivityDate) {
	        online = this.getOnlineStatus(params, localize);
	        if (online.isOnline && params.idle && !this.isMobileActive(params, localize)) {
	          text = localize['IM_STATUS_AWAY_TITLE'].replace('#TIME#', this.getIdleText(params, localize));
	        } else if (online.isOnline && !online.lastSeenText) {
	          if (Utils.platform.isMobile() && this.isMobileActive(params, localize)) {
	            text = localize['IM_STATUS_MOBILE'];
	          } else {
	            text = online.statusText;
	          }
	        } else if (online.lastSeenText) {
	          if (Utils.platform.isMobile()) {
	            text = localize['IM_LAST_SEEN_SHORT_' + (params.gender === 'F' ? 'F' : 'M')].replace('#LAST_SEEN#', online.lastSeenText);
	          } else {
	            text = localize['IM_LAST_SEEN_' + (params.gender === 'F' ? 'F' : 'M')].replace('#POSITION#', text).replace('#LAST_SEEN#', online.lastSeenText);
	          }
	        }
	      }
	      return text;
	    },
	    getIdleText: function getIdleText(params) {
	      var localize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
	      if (!params) {
	        return '';
	      }
	      if (!params.idle) {
	        return '';
	      }
	      return Utils.date.getDateFunction(localize).format([["s60", "sdiff"], ["i60", "idiff"], ["H24", "Hdiff"], ["", "ddiff"]], params.idle);
	    },
	    getOnlineStatus: function getOnlineStatus(params) {
	      var localize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
	      var result = {
	        'isOnline': false,
	        'status': 'offline',
	        'statusText': localize ? localize.IM_STATUS_OFFLINE : 'offline',
	        'lastSeen': params.lastActivityDate,
	        'lastSeenText': ''
	      };
	      if (!params.lastActivityDate || params.lastActivityDate.getTime() === 0) {
	        return result;
	      }
	      var date = new Date();
	      result.isOnline = date.getTime() - params.lastActivityDate.getTime() <= this.getOnlineLimit(localize) * 1000;
	      result.status = result.isOnline ? params.status : 'offline';
	      result.statusText = localize && localize['IM_STATUS_' + result.status.toUpperCase()] ? localize['IM_STATUS_' + result.status.toUpperCase()] : result.status;
	      if (localize && params.lastActivityDate.getTime() > 0 && date.getTime() - params.lastActivityDate.getTime() > 300 * 1000) {
	        result.lastSeenText = Utils.date.getDateFunction(localize).formatLastActivityDate(params.lastActivityDate);
	      }
	      return result;
	    },
	    isMobileActive: function isMobileActive(params) {
	      var localize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
	      if (!params) {
	        return false;
	      }
	      if (!localize) {
	        localize = BX.message || {};
	      }
	      return params.mobileLastDate && new Date() - params.mobileLastDate < this.getOnlineLimit(localize) * 1000 && params.lastActivityDate - params.mobileLastDate < 300 * 1000;
	    },
	    getOnlineLimit: function getOnlineLimit() {
	      var localize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
	      if (!localize) {
	        localize = BX.message || {};
	      }
	      return localize.LIMIT_ONLINE ? parseInt(localize.LIMIT_ONLINE) : 15 * 60;
	    }
	  },
	  isDarkColor: function isDarkColor(hex) {
	    if (!hex || !hex.match(/^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/)) {
	      return false;
	    }
	    if (hex.length === 4) {
	      hex = hex.replace(/#([A-Fa-f0-9])/gi, "$1$1");
	    } else {
	      hex = hex.replace(/#([A-Fa-f0-9])/gi, "$1");
	    }
	    hex = hex.toLowerCase();
	    var darkColor = ["#17a3ea", "#00aeef", "#00c4fb", "#47d1e2", "#75d900", "#ffab00", "#ff5752", "#468ee5", "#1eae43"];
	    if (darkColor.includes('#' + hex)) {
	      return true;
	    }
	    var bigint = parseInt(hex, 16);
	    var red = bigint >> 16 & 255;
	    var green = bigint >> 8 & 255;
	    var blue = bigint & 255;
	    var brightness = (red * 299 + green * 587 + blue * 114) / 1000;
	    return brightness < 128;
	  },
	  hashCode: function hashCode() {
	    var string = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
	    var hash = 0;
	    if (babelHelpers["typeof"](string) === 'object' && string) {
	      string = JSON.stringify(string);
	    } else if (typeof string !== 'string') {
	      string = string.toString();
	    }
	    if (typeof string !== 'string') {
	      return hash;
	    }
	    for (var i = 0; i < string.length; i++) {
	      var _char = string.charCodeAt(i);
	      hash = (hash << 5) - hash + _char;
	      hash = hash & hash;
	    }
	    return hash;
	  },
	  hideErrorImage: function hideErrorImage(element) {
	    if (element.parentNode) {
	      element.parentNode.innerHTML = '<a href="' + encodeURI(element.src) + '" target="_blank">' + element.src + '</a>';
	    }
	    return true;
	  },
	  /**
	   * The method compares versions, and returns - 0 if they are the same, 1 if version1 is greater, -1 if version1 is less
	   *
	   * @param version1
	   * @param version2
	   * @returns {number|NaN}
	   */
	  versionCompare: function versionCompare(version1, version2) {
	    var isNumberRegExp = /^([\d+\.]+)$/;
	    if (!isNumberRegExp.test(version1) || !isNumberRegExp.test(version2)) {
	      return NaN;
	    }
	    version1 = version1.toString().split('.');
	    version2 = version2.toString().split('.');
	    if (version1.length < version2.length) {
	      while (version1.length < version2.length) {
	        version1.push(0);
	      }
	    } else if (version2.length < version1.length) {
	      while (version2.length < version1.length) {
	        version2.push(0);
	      }
	    }
	    for (var i = 0; i < version1.length; i++) {
	      if (version1[i] > version2[i]) {
	        return 1;
	      } else if (version1[i] < version2[i]) {
	        return -1;
	      }
	    }
	    return 0;
	  },
	  /**
	   * Throttle function. Callback will be executed no more than 'wait' period (in ms).
	   *
	   * @param callback
	   * @param wait
	   * @param context
	   * @returns {Function}
	   */
	  throttle: function throttle(callback, wait) {
	    var context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this;
	    var timeout = null;
	    var callbackArgs = null;
	    var nextCallback = function nextCallback() {
	      callback.apply(context, callbackArgs);
	      timeout = null;
	    };
	    return function () {
	      if (!timeout) {
	        callbackArgs = arguments;
	        timeout = setTimeout(nextCallback, wait);
	      }
	    };
	  },
	  /**
	   * Debounce function. Callback will be executed if it hast been called for longer than 'wait' period (in ms).
	   *
	   * @param callback
	   * @param wait
	   * @param context
	   * @returns {Function}
	   */
	  debounce: function debounce(callback, wait) {
	    var context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this;
	    var timeout = null;
	    var callbackArgs = null;
	    var nextCallback = function nextCallback() {
	      callback.apply(context, callbackArgs);
	    };
	    return function () {
	      callbackArgs = arguments;
	      clearTimeout(timeout);
	      timeout = setTimeout(nextCallback, wait);
	    };
	  },
	  getLogTrackingParams: function getLogTrackingParams() {
	    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	    var result = [];
	    var _params$name = params.name,
	      name = _params$name === void 0 ? 'tracking' : _params$name,
	      _params$data = params.data,
	      data = _params$data === void 0 ? [] : _params$data,
	      _params$dialog = params.dialog,
	      dialog = _params$dialog === void 0 ? null : _params$dialog,
	      _params$message = params.message,
	      message = _params$message === void 0 ? null : _params$message,
	      _params$files = params.files,
	      files = _params$files === void 0 ? null : _params$files;
	    name = encodeURIComponent(name);
	    if (data && !(data instanceof Array) && babelHelpers["typeof"](data) === 'object') {
	      var dataArray = [];
	      for (var _name in data) {
	        if (data.hasOwnProperty(_name)) {
	          dataArray.push(encodeURIComponent(_name) + "=" + encodeURIComponent(data[_name]));
	        }
	      }
	      data = dataArray;
	    } else if (!data instanceof Array) {
	      data = [];
	    }
	    if (dialog) {
	      result.push('timType=' + dialog.type);
	      if (dialog.type === 'lines') {
	        result.push('timLinesType=' + dialog.entityId.split('|')[0]);
	      }
	    }
	    if (files) {
	      var type = 'file';
	      if (files instanceof Array && files[0]) {
	        type = files[0].type;
	      } else {
	        type = files.type;
	      }
	      result.push('timMessageType=' + type);
	    } else if (message) {
	      result.push('timMessageType=text');
	    }
	    if (this.platform.isBitrixMobile()) {
	      result.push('timDevice=bitrixMobile');
	    } else if (this.platform.isBitrixDesktop()) {
	      result.push('timDevice=bitrixDesktop');
	    } else if (this.platform.isIos() || this.platform.isAndroid()) {
	      result.push('timDevice=mobile');
	    } else {
	      result.push('timDevice=web');
	    }
	    return name + (data.length ? '&' + data.join('&') : '') + (result.length ? '&' + result.join('&') : '');
	  }
	};

	exports.Utils = Utils;

}((this.BX.Messenger.Lib = this.BX.Messenger.Lib || {}),BX.Messenger.Const));





// file: /bitrix/js/im/model/dist/registry.bundle.js
this.BX = this.BX || {};
this.BX.Messenger = this.BX.Messenger || {};
(function (exports,im_lib_logger,main_core_events,im_lib_utils,ui_vue,ui_vue_vuex,main_core,im_const) {
	'use strict';

	/**
	 * Bitrix Messenger
	 * Application model (Vuex Builder model)
	 *
	 * @package bitrix
	 * @subpackage im
	 * @copyright 2001-2020 Bitrix
	 */
	var ApplicationModel = /*#__PURE__*/function (_VuexBuilderModel) {
	  babelHelpers.inherits(ApplicationModel, _VuexBuilderModel);
	  function ApplicationModel() {
	    babelHelpers.classCallCheck(this, ApplicationModel);
	    return babelHelpers.possibleConstructorReturn(this, babelHelpers.getPrototypeOf(ApplicationModel).apply(this, arguments));
	  }
	  babelHelpers.createClass(ApplicationModel, [{
	    key: "getName",
	    value: function getName() {
	      return 'application';
	    }
	  }, {
	    key: "getState",
	    value: function getState() {
	      return {
	        common: {
	          host: this.getVariable('common.host', location.protocol + '//' + location.host),
	          siteId: this.getVariable('common.siteId', 'default'),
	          userId: this.getVariable('common.userId', 0),
	          languageId: this.getVariable('common.languageId', 'en')
	        },
	        dialog: {
	          dialogId: this.getVariable('dialog.dialogId', '0'),
	          chatId: this.getVariable('dialog.chatId', 0),
	          diskFolderId: this.getVariable('dialog.diskFolderId', 0),
	          messageLimit: this.getVariable('dialog.messageLimit', 20),
	          enableReadMessages: this.getVariable('dialog.enableReadMessages', true),
	          messageExtraCount: 0
	        },
	        disk: {
	          enabled: false,
	          maxFileSize: 5242880
	        },
	        call: {
	          serverEnabled: false,
	          maxParticipants: 24
	        },
	        mobile: {
	          keyboardShow: false
	        },
	        device: {
	          type: this.getVariable('device.type', im_const.DeviceType.desktop),
	          orientation: this.getVariable('device.orientation', im_const.DeviceOrientation.portrait)
	        },
	        options: {
	          quoteEnable: this.getVariable('options.quoteEnable', true),
	          quoteFromRight: this.getVariable('options.quoteFromRight', true),
	          autoplayVideo: this.getVariable('options.autoplayVideo', true),
	          darkBackground: this.getVariable('options.darkBackground', false),
	          showSmiles: false
	        },
	        error: {
	          active: false,
	          code: '',
	          description: ''
	        }
	      };
	    }
	  }, {
	    key: "getStateSaveException",
	    value: function getStateSaveException() {
	      return Object.assign({
	        common: this.getVariable('saveException.common', null),
	        dialog: this.getVariable('saveException.dialog', null),
	        mobile: this.getVariable('saveException.mobile', null),
	        device: this.getVariable('saveException.device', null),
	        error: this.getVariable('saveException.error', null)
	      });
	    }
	  }, {
	    key: "getActions",
	    value: function getActions() {
	      var _this = this;
	      return {
	        set: function set(store, payload) {
	          store.commit('set', _this.validate(payload));
	        },
	        showSmiles: function showSmiles(store, payload) {
	          store.commit('showSmiles');
	        },
	        hideSmiles: function hideSmiles(store, payload) {
	          store.commit('hideSmiles');
	        }
	      };
	    }
	  }, {
	    key: "getMutations",
	    value: function getMutations() {
	      var _this2 = this;
	      return {
	        set: function set(state, payload) {
	          var hasChange = false;
	          for (var group in payload) {
	            if (!payload.hasOwnProperty(group)) {
	              continue;
	            }
	            for (var field in payload[group]) {
	              if (!payload[group].hasOwnProperty(field)) {
	                continue;
	              }
	              state[group][field] = payload[group][field];
	              hasChange = true;
	            }
	          }
	          if (hasChange && _this2.isSaveNeeded(payload)) {
	            _this2.saveState(state);
	          }
	        },
	        increaseDialogExtraCount: function increaseDialogExtraCount(state) {
	          var payload = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	          var _payload$count = payload.count,
	            count = _payload$count === void 0 ? 1 : _payload$count;
	          state.dialog.messageExtraCount += count;
	        },
	        decreaseDialogExtraCount: function decreaseDialogExtraCount(state) {
	          var payload = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	          var _payload$count2 = payload.count,
	            count = _payload$count2 === void 0 ? 1 : _payload$count2;
	          var newCounter = state.dialog.messageExtraCount - count;
	          if (newCounter <= 0) {
	            newCounter = 0;
	          }
	          state.dialog.messageExtraCount = newCounter;
	        },
	        clearDialogExtraCount: function clearDialogExtraCount(state) {
	          state.dialog.messageExtraCount = 0;
	        },
	        showSmiles: function showSmiles(state) {
	          state.options.showSmiles = true;
	        },
	        hideSmiles: function hideSmiles(state) {
	          state.options.showSmiles = false;
	        }
	      };
	    }
	  }, {
	    key: "validate",
	    value: function validate(fields) {
	      var result = {};
	      if (babelHelpers["typeof"](fields.common) === 'object' && fields.common) {
	        result.common = {};
	        if (typeof fields.common.userId === 'number') {
	          result.common.userId = fields.common.userId;
	        }
	        if (typeof fields.common.languageId === 'string') {
	          result.common.languageId = fields.common.languageId;
	        }
	      }
	      if (babelHelpers["typeof"](fields.dialog) === 'object' && fields.dialog) {
	        result.dialog = {};
	        if (typeof fields.dialog.dialogId === 'number') {
	          result.dialog.dialogId = fields.dialog.dialogId.toString();
	          result.dialog.chatId = 0;
	        } else if (typeof fields.dialog.dialogId === 'string') {
	          result.dialog.dialogId = fields.dialog.dialogId;
	          if (typeof fields.dialog.chatId !== 'number') {
	            var chatId = fields.dialog.dialogId;
	            if (chatId.startsWith('chat')) {
	              chatId = fields.dialog.dialogId.substr(4);
	            }
	            chatId = parseInt(chatId);
	            result.dialog.chatId = !isNaN(chatId) ? chatId : 0;
	            fields.dialog.chatId = result.dialog.chatId;
	          }
	        }
	        if (typeof fields.dialog.chatId === 'number') {
	          result.dialog.chatId = fields.dialog.chatId;
	        }
	        if (typeof fields.dialog.diskFolderId === 'number') {
	          result.dialog.diskFolderId = fields.dialog.diskFolderId;
	        }
	        if (typeof fields.dialog.messageLimit === 'number') {
	          result.dialog.messageLimit = fields.dialog.messageLimit;
	        }
	        if (typeof fields.dialog.messageExtraCount === 'number') {
	          result.dialog.messageExtraCount = fields.dialog.messageExtraCount;
	        }
	        if (typeof fields.dialog.enableReadMessages === 'boolean') {
	          result.dialog.enableReadMessages = fields.dialog.enableReadMessages;
	        }
	      }
	      if (babelHelpers["typeof"](fields.disk) === 'object' && fields.disk) {
	        result.disk = {};
	        if (typeof fields.disk.enabled === 'boolean') {
	          result.disk.enabled = fields.disk.enabled;
	        }
	        if (typeof fields.disk.maxFileSize === 'number') {
	          result.disk.maxFileSize = fields.disk.maxFileSize;
	        }
	      }
	      if (babelHelpers["typeof"](fields.call) === 'object' && fields.call) {
	        result.call = {};
	        if (typeof fields.call.serverEnabled === 'boolean') {
	          result.call.serverEnabled = fields.call.serverEnabled;
	        }
	        if (typeof fields.call.maxParticipants === 'number') {
	          result.call.maxParticipants = fields.call.maxParticipants;
	        }
	      }
	      if (babelHelpers["typeof"](fields.mobile) === 'object' && fields.mobile) {
	        result.mobile = {};
	        if (typeof fields.mobile.keyboardShow === 'boolean') {
	          result.mobile.keyboardShow = fields.mobile.keyboardShow;
	        }
	      }
	      if (babelHelpers["typeof"](fields.device) === 'object' && fields.device) {
	        result.device = {};
	        if (typeof fields.device.type === 'string' && typeof im_const.DeviceType[fields.device.type] !== 'undefined') {
	          result.device.type = fields.device.type;
	        }
	        if (typeof fields.device.orientation === 'string' && typeof im_const.DeviceOrientation[fields.device.orientation] !== 'undefined') {
	          result.device.orientation = fields.device.orientation;
	        }
	      }
	      if (babelHelpers["typeof"](fields.error) === 'object' && fields.error) {
	        if (typeof fields.error.active === 'boolean') {
	          result.error = {
	            active: fields.error.active,
	            code: fields.error.code.toString() || '',
	            description: fields.error.description.toString() || ''
	          };
	        }
	      }
	      return result;
	    }
	  }]);
	  return ApplicationModel;
	}(ui_vue_vuex.WidgetVuexBuilderModel);

	/**
	 * Bitrix Messenger
	 * Call Application model (Vuex Builder model)
	 *
	 * @package bitrix
	 * @subpackage im
	 * @copyright 2001-2020 Bitrix
	 */
	var ConferenceModel = /*#__PURE__*/function (_VuexBuilderModel) {
	  babelHelpers.inherits(ConferenceModel, _VuexBuilderModel);
	  function ConferenceModel() {
	    babelHelpers.classCallCheck(this, ConferenceModel);
	    return babelHelpers.possibleConstructorReturn(this, babelHelpers.getPrototypeOf(ConferenceModel).apply(this, arguments));
	  }
	  babelHelpers.createClass(ConferenceModel, [{
	    key: "getName",
	    value: function getName() {
	      return 'conference';
	    }
	  }, {
	    key: "getState",
	    value: function getState() {
	      return {
	        common: {
	          inited: false,
	          passChecked: true,
	          showChat: false,
	          userCount: 0,
	          messageCount: 0,
	          userInCallCount: 0,
	          state: im_const.ConferenceStateType.preparation,
	          callEnded: false,
	          showSmiles: false,
	          error: '',
	          conferenceTitle: '',
	          alias: '',
	          permissionsRequested: false,
	          conferenceStarted: null,
	          conferenceStartDate: null,
	          joinWithVideo: null,
	          userReadyToJoin: false,
	          isBroadcast: false,
	          users: [],
	          usersInCall: [],
	          presenters: [],
	          rightPanelMode: im_const.ConferenceRightPanelMode.hidden
	        },
	        user: {
	          id: -1,
	          hash: ''
	        }
	      };
	    }
	  }, {
	    key: "getActions",
	    value: function getActions() {
	      return {
	        showChat: function showChat(store, payload) {
	          if (typeof payload.newState !== 'boolean') {
	            return false;
	          }
	          store.commit('showChat', payload);
	        },
	        changeRightPanelMode: function changeRightPanelMode(store, payload) {
	          if (!im_const.ConferenceRightPanelMode[payload.mode]) {
	            return false;
	          }
	          store.commit('changeRightPanelMode', payload);
	        },
	        setPermissionsRequested: function setPermissionsRequested(store, payload) {
	          if (typeof payload.status !== 'boolean') {
	            return false;
	          }
	          store.commit('setPermissionsRequested', payload);
	        },
	        setPresenters: function setPresenters(store, payload) {
	          if (!Array.isArray(payload.presenters)) {
	            payload.presenters = [payload.presenters];
	          }
	          store.commit('setPresenters', payload);
	        },
	        setUsers: function setUsers(store, payload) {
	          if (!Array.isArray(payload.users)) {
	            payload.users = [payload.users];
	          }
	          store.commit('setUsers', payload);
	        },
	        removeUsers: function removeUsers(store, payload) {
	          if (!Array.isArray(payload.users)) {
	            payload.users = [payload.users];
	          }
	          store.commit('removeUsers', payload);
	        },
	        setUsersInCall: function setUsersInCall(store, payload) {
	          if (!Array.isArray(payload.users)) {
	            payload.users = [payload.users];
	          }
	          store.commit('setUsersInCall', payload);
	        },
	        removeUsersInCall: function removeUsersInCall(store, payload) {
	          if (!Array.isArray(payload.users)) {
	            payload.users = [payload.users];
	          }
	          store.commit('removeUsersInCall', payload);
	        },
	        setConferenceTitle: function setConferenceTitle(store, payload) {
	          if (typeof payload.conferenceTitle !== 'string') {
	            return false;
	          }
	          store.commit('setConferenceTitle', payload);
	        },
	        setBroadcastMode: function setBroadcastMode(store, payload) {
	          if (typeof payload.broadcastMode !== 'boolean') {
	            return false;
	          }
	          store.commit('setBroadcastMode', payload);
	        }
	      };
	    }
	  }, {
	    key: "getMutations",
	    value: function getMutations() {
	      var _this = this;
	      return {
	        common: function common(state, payload) {
	          if (typeof payload.inited === 'boolean') {
	            state.common.inited = payload.inited;
	          }
	          if (typeof payload.passChecked === 'boolean') {
	            state.common.passChecked = payload.passChecked;
	          }
	          if (typeof payload.userCount === 'number' || typeof payload.userCount === 'string') {
	            state.common.userCount = parseInt(payload.userCount);
	          }
	          if (typeof payload.messageCount === 'number' || typeof payload.messageCount === 'string') {
	            state.common.messageCount = parseInt(payload.messageCount);
	          }
	          if (typeof payload.userInCallCount === 'number' || typeof payload.userInCallCount === 'string') {
	            state.common.userInCallCount = parseInt(payload.userInCallCount);
	          }
	          if (typeof payload.componentError === 'string') {
	            state.common.componentError = payload.componentError;
	          }
	          if (typeof payload.isBroadcast === 'boolean') {
	            state.common.isBroadcast = payload.isBroadcast;
	          }
	          if (Array.isArray(payload.presenters)) {
	            state.common.presenters = payload.presenters;
	          }
	        },
	        user: function user(state, payload) {
	          if (typeof payload.id === 'number') {
	            state.user.id = payload.id;
	          }
	          if (typeof payload.hash === 'string' && payload.hash !== state.user.hash) {
	            state.user.hash = payload.hash;
	          }
	          if (_this.isSaveNeeded({
	            user: payload
	          })) {
	            _this.saveState(state);
	          }
	        },
	        showChat: function showChat(state, _ref) {
	          var newState = _ref.newState;
	          state.common.showChat = newState;
	        },
	        changeRightPanelMode: function changeRightPanelMode(state, _ref2) {
	          var mode = _ref2.mode;
	          state.common.rightPanelMode = mode;
	        },
	        setPermissionsRequested: function setPermissionsRequested(state, payload) {
	          state.common.permissionsRequested = payload.status;
	        },
	        startCall: function startCall(state, payload) {
	          state.common.state = im_const.ConferenceStateType.call;
	          state.common.callEnded = false;
	        },
	        endCall: function endCall(state, payload) {
	          state.common.state = im_const.ConferenceStateType.preparation;
	          state.common.callEnded = true;
	        },
	        returnToPreparation: function returnToPreparation(state, payload) {
	          state.common.state = im_const.ConferenceStateType.preparation;
	        },
	        toggleSmiles: function toggleSmiles(state, payload) {
	          state.common.showSmiles = !state.common.showSmiles;
	        },
	        setError: function setError(state, payload) {
	          if (typeof payload.errorCode === 'string') {
	            state.common.error = payload.errorCode;
	          }
	        },
	        setConferenceTitle: function setConferenceTitle(state, payload) {
	          state.common.conferenceTitle = payload.conferenceTitle;
	        },
	        setBroadcastMode: function setBroadcastMode(state, payload) {
	          state.common.isBroadcast = payload.broadcastMode;
	        },
	        setAlias: function setAlias(state, payload) {
	          if (typeof payload.alias === 'string') {
	            state.common.alias = payload.alias;
	          }
	        },
	        setJoinType: function setJoinType(state, payload) {
	          if (typeof payload.joinWithVideo === 'boolean') {
	            state.common.joinWithVideo = payload.joinWithVideo;
	          }
	        },
	        setConferenceStatus: function setConferenceStatus(state, payload) {
	          if (typeof payload.conferenceStarted === 'boolean') {
	            state.common.conferenceStarted = payload.conferenceStarted;
	          }
	        },
	        setConferenceStartDate: function setConferenceStartDate(state, payload) {
	          if (payload.conferenceStartDate instanceof Date) {
	            state.common.conferenceStartDate = payload.conferenceStartDate;
	          }
	        },
	        setUserReadyToJoin: function setUserReadyToJoin(state, payload) {
	          state.common.userReadyToJoin = true;
	        },
	        setPresenters: function setPresenters(state, payload) {
	          if (payload.replace) {
	            state.common.presenters = payload.presenters;
	          } else {
	            payload.presenters.forEach(function (presenter) {
	              presenter = parseInt(presenter);
	              if (!state.common.presenters.includes(presenter)) {
	                state.common.presenters.push(presenter);
	              }
	            });
	          }
	        },
	        setUsers: function setUsers(state, payload) {
	          payload.users.forEach(function (user) {
	            user = parseInt(user);
	            if (!state.common.users.includes(user)) {
	              state.common.users.push(user);
	            }
	          });
	        },
	        removeUsers: function removeUsers(state, payload) {
	          state.common.users = state.common.users.filter(function (user) {
	            return !payload.users.includes(parseInt(user));
	          });
	        },
	        setUsersInCall: function setUsersInCall(state, payload) {
	          payload.users.forEach(function (user) {
	            user = parseInt(user);
	            if (!state.common.usersInCall.includes(user)) {
	              state.common.usersInCall.push(user);
	            }
	          });
	        },
	        removeUsersInCall: function removeUsersInCall(state, payload) {
	          state.common.usersInCall = state.common.usersInCall.filter(function (user) {
	            return !payload.users.includes(parseInt(user));
	          });
	        }
	      };
	    }
	  }, {
	    key: "getStateSaveException",
	    value: function getStateSaveException() {
	      return {
	        common: {
	          inited: null,
	          state: null,
	          showSmiles: null,
	          userCount: null,
	          messageCount: null,
	          userInCallCount: null,
	          error: null,
	          conferenceTitle: null,
	          alias: null,
	          conferenceStarted: null,
	          conferenceStartDate: null,
	          joinWithVideo: null,
	          userReadyToJoin: null,
	          rightPanelMode: null,
	          presenters: null,
	          users: null
	        }
	      };
	    }
	  }]);
	  return ConferenceModel;
	}(ui_vue_vuex.WidgetVuexBuilderModel);

	function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }
	function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
	function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
	var IntersectionType = {
	  empty: 'empty',
	  equal: 'equal',
	  none: 'none',
	  found: 'found',
	  foundReverse: 'foundReverse'
	};
	var MessagesModel = /*#__PURE__*/function (_VuexBuilderModel) {
	  babelHelpers.inherits(MessagesModel, _VuexBuilderModel);
	  function MessagesModel() {
	    babelHelpers.classCallCheck(this, MessagesModel);
	    return babelHelpers.possibleConstructorReturn(this, babelHelpers.getPrototypeOf(MessagesModel).apply(this, arguments));
	  }
	  babelHelpers.createClass(MessagesModel, [{
	    key: "getName",
	    value: function getName() {
	      return 'messages';
	    }
	  }, {
	    key: "getState",
	    value: function getState() {
	      return {
	        created: 0,
	        collection: {},
	        mutationType: {},
	        saveMessageList: {},
	        saveFileList: {},
	        saveUserList: {},
	        host: this.getVariable('host', location.protocol + '//' + location.host)
	      };
	    }
	  }, {
	    key: "getElementState",
	    value: function getElementState() {
	      return {
	        templateId: 0,
	        templateType: 'message',
	        placeholderType: 0,
	        id: 0,
	        chatId: 0,
	        authorId: 0,
	        date: new Date(),
	        text: "",
	        textConverted: "",
	        params: {
	          TYPE: 'default',
	          COMPONENT_ID: 'bx-im-view-message'
	        },
	        push: false,
	        unread: false,
	        sending: false,
	        error: false,
	        retry: false,
	        blink: false
	      };
	    }
	  }, {
	    key: "getGetters",
	    value: function getGetters() {
	      var _this = this;
	      return {
	        getMutationType: function getMutationType(state) {
	          return function (chatId) {
	            if (!state.mutationType[chatId]) {
	              return {
	                initialType: im_const.MutationType.none,
	                appliedType: im_const.MutationType.none
	              };
	            }
	            return state.mutationType[chatId];
	          };
	        },
	        getLastId: function getLastId(state) {
	          return function (chatId) {
	            if (!state.collection[chatId] || state.collection[chatId].length <= 0) {
	              return null;
	            }
	            var lastId = 0;
	            for (var i = 0; i < state.collection[chatId].length; i++) {
	              var element = state.collection[chatId][i];
	              if (element.push || element.sending || element.id.toString().startsWith('temporary')) {
	                continue;
	              }
	              if (lastId < element.id) {
	                lastId = element.id;
	              }
	            }
	            return lastId ? lastId : null;
	          };
	        },
	        getMessage: function getMessage(state) {
	          return function (chatId, messageId) {
	            if (!state.collection[chatId] || state.collection[chatId].length <= 0) {
	              return null;
	            }
	            for (var index = state.collection[chatId].length - 1; index >= 0; index--) {
	              if (state.collection[chatId][index].id === messageId) {
	                return state.collection[chatId][index];
	              }
	            }
	            return null;
	          };
	        },
	        get: function get(state) {
	          return function (chatId) {
	            if (!state.collection[chatId] || state.collection[chatId].length <= 0) {
	              return [];
	            }
	            return state.collection[chatId];
	          };
	        },
	        getBlank: function getBlank(state) {
	          return function (params) {
	            return _this.getElementState();
	          };
	        },
	        getSaveFileList: function getSaveFileList(state) {
	          return function (params) {
	            return state.saveFileList;
	          };
	        },
	        getSaveUserList: function getSaveUserList(state) {
	          return function (params) {
	            return state.saveUserList;
	          };
	        }
	      };
	    }
	  }, {
	    key: "getActions",
	    value: function getActions() {
	      var _this2 = this;
	      return {
	        add: function add(store, payload) {
	          var result = _this2.validate(Object.assign({}, payload));
	          result.params = Object.assign({}, _this2.getElementState().params, result.params);
	          if (payload.id) {
	            if (store.state.collection[payload.chatId]) {
	              var countMessages = store.state.collection[payload.chatId].length - 1;
	              for (var index = countMessages; index >= 0; index--) {
	                var message = store.state.collection[payload.chatId][index];
	                if (message.templateId === payload.id) {
	                  return;
	                }
	              }
	            }
	            result.id = payload.id;
	          } else {
	            result.id = 'temporary' + new Date().getTime() + store.state.created;
	          }
	          result.templateId = result.id;
	          result.unread = false;
	          store.commit('add', Object.assign({}, _this2.getElementState(), result));
	          if (payload.sending !== false) {
	            store.dispatch('actionStart', {
	              id: result.id,
	              chatId: result.chatId
	            });
	          }
	          return result.id;
	        },
	        actionStart: function actionStart(store, payload) {
	          if (/^\d+$/.test(payload.id)) {
	            payload.id = parseInt(payload.id);
	          }
	          payload.chatId = parseInt(payload.chatId);
	          ui_vue.WidgetVue.nextTick(function () {
	            store.commit('update', {
	              id: payload.id,
	              chatId: payload.chatId,
	              fields: {
	                sending: true
	              }
	            });
	          });
	        },
	        actionError: function actionError(store, payload) {
	          if (/^\d+$/.test(payload.id)) {
	            payload.id = parseInt(payload.id);
	          }
	          payload.chatId = parseInt(payload.chatId);
	          ui_vue.WidgetVue.nextTick(function () {
	            store.commit('update', {
	              id: payload.id,
	              chatId: payload.chatId,
	              fields: {
	                sending: false,
	                error: true,
	                retry: payload.retry !== false
	              }
	            });
	          });
	        },
	        actionFinish: function actionFinish(store, payload) {
	          if (/^\d+$/.test(payload.id)) {
	            payload.id = parseInt(payload.id);
	          }
	          payload.chatId = parseInt(payload.chatId);
	          ui_vue.WidgetVue.nextTick(function () {
	            store.commit('update', {
	              id: payload.id,
	              chatId: payload.chatId,
	              fields: {
	                sending: false,
	                error: false,
	                retry: false
	              }
	            });
	          });
	        },
	        set: function set(store, payload) {
	          if (payload instanceof Array) {
	            payload = payload.map(function (message) {
	              return _this2.prepareMessage(message, {
	                host: store.state.host
	              });
	            });
	          } else {
	            var result = _this2.prepareMessage(payload, {
	              host: store.state.host
	            });
	            (payload = []).push(result);
	          }
	          store.commit('set', {
	            insertType: im_const.MutationType.set,
	            data: payload
	          });
	          return 'set is done';
	        },
	        addPlaceholders: function addPlaceholders(store, payload) {
	          if (payload.placeholders instanceof Array) {
	            payload.placeholders = payload.placeholders.map(function (message) {
	              return _this2.prepareMessage(message, {
	                host: store.state.host
	              });
	            });
	          } else {
	            return false;
	          }
	          var insertType = payload.requestMode === 'history' ? im_const.MutationType.setBefore : im_const.MutationType.setAfter;
	          if (insertType === im_const.MutationType.setBefore) {
	            payload.placeholders = payload.placeholders.reverse();
	          }
	          store.commit('set', {
	            insertType: insertType,
	            data: payload.placeholders
	          });
	          return payload.placeholders[0].id;
	        },
	        clearPlaceholders: function clearPlaceholders(store, payload) {
	          store.commit('clearPlaceholders', payload);
	        },
	        updatePlaceholders: function updatePlaceholders(store, payload) {
	          if (payload.data instanceof Array) {
	            payload.data = payload.data.map(function (message) {
	              return _this2.prepareMessage(message, {
	                host: store.state.host
	              });
	            });
	          } else {
	            return false;
	          }
	          store.commit('updatePlaceholders', payload);
	          return true;
	        },
	        setAfter: function setAfter(store, payload) {
	          if (payload instanceof Array) {
	            payload = payload.map(function (message) {
	              return _this2.prepareMessage(message);
	            });
	          } else {
	            var result = _this2.prepareMessage(payload);
	            (payload = []).push(result);
	          }
	          store.commit('set', {
	            insertType: im_const.MutationType.setAfter,
	            data: payload
	          });
	        },
	        setBefore: function setBefore(store, payload) {
	          if (payload instanceof Array) {
	            payload = payload.map(function (message) {
	              return _this2.prepareMessage(message);
	            });
	          } else {
	            var result = _this2.prepareMessage(payload);
	            (payload = []).push(result);
	          }
	          store.commit('set', {
	            insertType: im_const.MutationType.setBefore,
	            data: payload
	          });
	        },
	        update: function update(store, payload) {
	          if (/^\d+$/.test(payload.id)) {
	            payload.id = parseInt(payload.id);
	          }
	          if (/^\d+$/.test(payload.chatId)) {
	            payload.chatId = parseInt(payload.chatId);
	          }
	          store.commit('initCollection', {
	            chatId: payload.chatId
	          });
	          if (!store.state.collection[payload.chatId]) {
	            return false;
	          }
	          var index = store.state.collection[payload.chatId].findIndex(function (el) {
	            return el.id === payload.id;
	          });
	          if (index < 0) {
	            return false;
	          }
	          var result = _this2.validate(Object.assign({}, payload.fields));
	          if (result.params) {
	            result.params = Object.assign({}, _this2.getElementState().params, store.state.collection[payload.chatId][index].params, result.params);
	          }
	          store.commit('update', {
	            id: payload.id,
	            chatId: payload.chatId,
	            index: index,
	            fields: result
	          });
	          if (payload.fields.blink) {
	            setTimeout(function () {
	              store.commit('update', {
	                id: payload.id,
	                chatId: payload.chatId,
	                fields: {
	                  blink: false
	                }
	              });
	            }, 1000);
	          }
	          return true;
	        },
	        "delete": function _delete(store, payload) {
	          if (!(payload.id instanceof Array)) {
	            payload.id = [payload.id];
	          }
	          payload.id = payload.id.map(function (id) {
	            if (/^\d+$/.test(id)) {
	              id = parseInt(id);
	            }
	            return id;
	          });
	          store.commit('delete', {
	            chatId: payload.chatId,
	            elements: payload.id
	          });
	          return true;
	        },
	        clear: function clear(store, payload) {
	          payload.chatId = parseInt(payload.chatId);
	          if (payload.keepPlaceholders) {
	            store.commit('clearMessages', {
	              chatId: payload.chatId
	            });
	          } else {
	            store.commit('clear', {
	              chatId: payload.chatId
	            });
	          }
	          return true;
	        },
	        applyMutationType: function applyMutationType(store, payload) {
	          payload.chatId = parseInt(payload.chatId);
	          store.commit('applyMutationType', {
	            chatId: payload.chatId
	          });
	          return true;
	        },
	        readMessages: function readMessages(store, payload) {
	          payload.readId = parseInt(payload.readId) || 0;
	          payload.chatId = parseInt(payload.chatId);
	          if (typeof store.state.collection[payload.chatId] === 'undefined') {
	            return {
	              count: 0
	            };
	          }
	          var count = 0;
	          for (var index = store.state.collection[payload.chatId].length - 1; index >= 0; index--) {
	            var element = store.state.collection[payload.chatId][index];
	            if (!element.unread) continue;
	            if (payload.readId === 0 || element.id <= payload.readId) {
	              count++;
	            }
	          }
	          store.commit('readMessages', {
	            chatId: payload.chatId,
	            readId: payload.readId
	          });
	          return {
	            count: count
	          };
	        },
	        unreadMessages: function unreadMessages(store, payload) {
	          payload.unreadId = parseInt(payload.unreadId) || 0;
	          payload.chatId = parseInt(payload.chatId);
	          if (typeof store.state.collection[payload.chatId] === 'undefined' || !payload.unreadId) {
	            return {
	              count: 0
	            };
	          }
	          var count = 0;
	          for (var index = store.state.collection[payload.chatId].length - 1; index >= 0; index--) {
	            var element = store.state.collection[payload.chatId][index];
	            if (element.unread) continue;
	            if (element.id >= payload.unreadId) {
	              count++;
	            }
	          }
	          store.commit('unreadMessages', {
	            chatId: payload.chatId,
	            unreadId: payload.unreadId
	          });
	          return {
	            count: count
	          };
	        }
	      };
	    }
	  }, {
	    key: "getMutations",
	    value: function getMutations() {
	      var _this3 = this;
	      return {
	        initCollection: function initCollection(state, payload) {
	          return _this3.initCollection(state, payload);
	        },
	        add: function add(state, payload) {
	          _this3.initCollection(state, {
	            chatId: payload.chatId
	          });
	          state.collection[payload.chatId].push(payload);
	          state.saveMessageList[payload.chatId].push(payload.id);
	          state.created += 1;
	          state.collection[payload.chatId].sort(function (a, b) {
	            return a.id - b.id;
	          });
	          _this3.saveState(state, payload.chatId);
	          im_lib_logger.Logger.warn('Messages model: saving state after add');
	        },
	        clearPlaceholders: function clearPlaceholders(state, payload) {
	          if (!state.collection[payload.chatId]) {
	            return false;
	          }
	          state.collection[payload.chatId] = state.collection[payload.chatId].filter(function (element) {
	            return !element.id.toString().startsWith('placeholder');
	          });
	        },
	        updatePlaceholders: function updatePlaceholders(state, payload) {
	          var firstPlaceholderId = "placeholder".concat(payload.firstMessage);
	          var firstPlaceholderIndex = state.collection[payload.chatId].findIndex(function (message) {
	            return message.id === firstPlaceholderId;
	          });
	          // Logger.warn('firstPlaceholderIndex', firstPlaceholderIndex);
	          if (firstPlaceholderIndex >= 0) {
	            var _state$collection$pay;
	            // Logger.warn('before delete', state.collection[payload.chatId].length, [...state.collection[payload.chatId]]);
	            state.collection[payload.chatId].splice(firstPlaceholderIndex, payload.amount);
	            // Logger.warn('after delete', state.collection[payload.chatId].length, [...state.collection[payload.chatId]]);
	            (_state$collection$pay = state.collection[payload.chatId]).splice.apply(_state$collection$pay, [firstPlaceholderIndex, 0].concat(babelHelpers.toConsumableArray(payload.data)));
	            // Logger.warn('after add', state.collection[payload.chatId].length, [...state.collection[payload.chatId]]);
	          }

	          state.collection[payload.chatId].sort(function (a, b) {
	            return a.id - b.id;
	          });
	          im_lib_logger.Logger.warn('Messages model: saving state after updating placeholders');
	          _this3.saveState(state, payload.chatId);
	        },
	        set: function set(state, payload) {
	          im_lib_logger.Logger.warn('Messages model: set mutation', payload);
	          var chats = [];
	          var chatsSave = [];
	          var isPush = false;
	          payload.data = MessagesModel.getPayloadWithTempMessages(state, payload);
	          var initialType = payload.insertType;
	          if (payload.insertType === im_const.MutationType.set) {
	            payload.insertType = im_const.MutationType.setAfter;
	            var elements = {};
	            payload.data.forEach(function (element) {
	              if (!elements[element.chatId]) {
	                elements[element.chatId] = [];
	              }
	              elements[element.chatId].push(element.id);
	            });
	            var _loop = function _loop(chatId) {
	              if (!elements.hasOwnProperty(chatId)) return "continue";
	              _this3.initCollection(state, {
	                chatId: chatId
	              });
	              im_lib_logger.Logger.warn('Messages model: messages before adding from request - ', state.collection[chatId].length);
	              if (state.saveMessageList[chatId].length > elements[chatId].length || elements[chatId].length < im_const.StorageLimit.messages) {
	                state.collection[chatId] = state.collection[chatId].filter(function (element) {
	                  return elements[chatId].includes(element.id);
	                });
	                state.saveMessageList[chatId] = state.saveMessageList[chatId].filter(function (id) {
	                  return elements[chatId].includes(id);
	                });
	              }
	              im_lib_logger.Logger.warn('Messages model: cache length', state.saveMessageList[chatId].length);
	              var intersection = _this3.manageCacheBeforeSet(babelHelpers.toConsumableArray(state.saveMessageList[chatId].reverse()), elements[chatId]);
	              im_lib_logger.Logger.warn('Messages model: set intersection with cache', intersection);
	              if (intersection.type === IntersectionType.none) {
	                if (intersection.foundElements.length > 0) {
	                  state.collection[chatId] = state.collection[chatId].filter(function (element) {
	                    return !intersection.foundElements.includes(element.id);
	                  });
	                  state.saveMessageList[chatId] = state.saveMessageList[chatId].filter(function (id) {
	                    return !intersection.foundElements.includes(id);
	                  });
	                }
	                im_lib_logger.Logger.warn('Messages model: no intersection - removing cache');
	                _this3.removeIntersectionCacheElements = state.collection[chatId].map(function (element) {
	                  return element.id;
	                });
	                state.collection[chatId] = state.collection[chatId].filter(function (element) {
	                  return !_this3.removeIntersectionCacheElements.includes(element.id);
	                });
	                state.saveMessageList[chatId] = state.saveMessageList[chatId].filter(function (id) {
	                  return !_this3.removeIntersectionCacheElements.includes(id);
	                });
	                _this3.removeIntersectionCacheElements = [];
	              } else if (intersection.type === IntersectionType.foundReverse) {
	                im_lib_logger.Logger.warn('Messages model: found reverse intersection');
	                payload.insertType = im_const.MutationType.setBefore;
	                payload.data = payload.data.reverse();
	              }
	            };
	            for (var chatId in elements) {
	              var _ret = _loop(chatId);
	              if (_ret === "continue") continue;
	            }
	          }
	          im_lib_logger.Logger.warn('Messages model: adding messages to model', payload.data);
	          var _iterator = _createForOfIteratorHelper(payload.data),
	            _step;
	          try {
	            var _loop2 = function _loop2() {
	              var element = _step.value;
	              _this3.initCollection(state, {
	                chatId: element.chatId
	              });
	              var index = state.collection[element.chatId].findIndex(function (localMessage) {
	                if (MessagesModel.isTemporaryMessage(localMessage)) {
	                  return localMessage.templateId === element.templateId;
	                }
	                return localMessage.id === element.id;
	              });
	              if (index > -1) {
	                state.collection[element.chatId][index] = Object.assign(state.collection[element.chatId][index], element);
	              } else if (payload.insertType === im_const.MutationType.setBefore) {
	                state.collection[element.chatId].unshift(element);
	              } else if (payload.insertType === im_const.MutationType.setAfter) {
	                state.collection[element.chatId].push(element);
	              }
	              chats.push(element.chatId);
	              if (_this3.store.getters['dialogues/canSaveChat'] && _this3.store.getters['dialogues/canSaveChat'](element.chatId)) {
	                chatsSave.push(element.chatId);
	              }
	            };
	            for (_iterator.s(); !(_step = _iterator.n()).done;) {
	              _loop2();
	            }
	          } catch (err) {
	            _iterator.e(err);
	          } finally {
	            _iterator.f();
	          }
	          chats = babelHelpers.toConsumableArray(new Set(chats));
	          chatsSave = babelHelpers.toConsumableArray(new Set(chatsSave));
	          isPush = payload.data.every(function (element) {
	            return element.push === true;
	          });
	          im_lib_logger.Logger.warn('Is it fake push message?', isPush);
	          chats.forEach(function (chatId) {
	            state.collection[chatId].sort(function (a, b) {
	              return a.id - b.id;
	            });
	            if (!isPush) {
	              //send event that messages are ready and we can start reading etc
	              im_lib_logger.Logger.warn('setting messagesSet = true for chatId = ', chatId);
	              setTimeout(function () {
	                main_core_events.EventEmitter.emit(im_const.EventType.dialog.messagesSet, {
	                  chatId: chatId
	                });
	                main_core_events.EventEmitter.emit(im_const.EventType.dialog.readVisibleMessages, {
	                  chatId: chatId
	                });
	              }, 100);
	            }
	          });
	          if (initialType !== im_const.MutationType.setBefore) {
	            chatsSave.forEach(function (chatId) {
	              im_lib_logger.Logger.warn('Messages model: saving state after set');
	              _this3.saveState(state, chatId);
	            });
	          }
	        },
	        update: function update(state, payload) {
	          _this3.initCollection(state, {
	            chatId: payload.chatId
	          });
	          var index = -1;
	          if (typeof payload.index !== 'undefined' && state.collection[payload.chatId][payload.index]) {
	            index = payload.index;
	          } else {
	            index = state.collection[payload.chatId].findIndex(function (el) {
	              return el.id === payload.id;
	            });
	          }
	          if (index >= 0) {
	            var isSaveState = state.saveMessageList[payload.chatId].includes(state.collection[payload.chatId][index].id) || payload.fields.id && !payload.fields.id.toString().startsWith('temporary') && state.collection[payload.chatId][index].id.toString().startsWith('temporary');
	            state.collection[payload.chatId][index] = Object.assign(state.collection[payload.chatId][index], payload.fields);
	            if (isSaveState) {
	              im_lib_logger.Logger.warn('Messages model: saving state after update');
	              _this3.saveState(state, payload.chatId);
	            }
	          }
	        },
	        "delete": function _delete(state, payload) {
	          _this3.initCollection(state, {
	            chatId: payload.chatId
	          });
	          state.collection[payload.chatId] = state.collection[payload.chatId].filter(function (element) {
	            return !payload.elements.includes(element.id);
	          });
	          if (state.saveMessageList[payload.chatId].length > 0) {
	            var _iterator2 = _createForOfIteratorHelper(payload.elements),
	              _step2;
	            try {
	              for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
	                var id = _step2.value;
	                if (state.saveMessageList[payload.chatId].includes(id)) {
	                  im_lib_logger.Logger.warn('Messages model: saving state after delete');
	                  _this3.saveState(state, payload.chatId);
	                  break;
	                }
	              }
	            } catch (err) {
	              _iterator2.e(err);
	            } finally {
	              _iterator2.f();
	            }
	          }
	        },
	        clear: function clear(state, payload) {
	          _this3.initCollection(state, {
	            chatId: payload.chatId
	          });
	          state.collection[payload.chatId] = [];
	          state.saveMessageList[payload.chatId] = [];
	        },
	        clearMessages: function clearMessages(state, payload) {
	          _this3.initCollection(state, {
	            chatId: payload.chatId
	          });
	          state.collection[payload.chatId] = state.collection[payload.chatId].filter(function (element) {
	            return element.id.toString().startsWith('placeholder');
	          });
	          state.saveMessageList[payload.chatId] = [];
	        },
	        applyMutationType: function applyMutationType(state, payload) {
	          if (typeof state.mutationType[payload.chatId] === 'undefined') {
	            ui_vue.WidgetVue.set(state.mutationType, payload.chatId, {
	              applied: false,
	              initialType: im_const.MutationType.none,
	              appliedType: im_const.MutationType.none,
	              scrollStickToTop: 0,
	              scrollMessageId: 0
	            });
	          }
	          state.mutationType[payload.chatId].applied = true;
	        },
	        readMessages: function readMessages(state, payload) {
	          _this3.initCollection(state, {
	            chatId: payload.chatId
	          });
	          var saveNeeded = false;
	          for (var index = state.collection[payload.chatId].length - 1; index >= 0; index--) {
	            var element = state.collection[payload.chatId][index];
	            if (!element.unread) continue;
	            if (payload.readId === 0 || element.id <= payload.readId) {
	              state.collection[payload.chatId][index] = Object.assign(state.collection[payload.chatId][index], {
	                unread: false
	              });
	              saveNeeded = true;
	            }
	          }
	          if (saveNeeded) {
	            im_lib_logger.Logger.warn('Messages model: saving state after reading');
	            _this3.saveState(state, payload.chatId);
	          }
	        },
	        unreadMessages: function unreadMessages(state, payload) {
	          _this3.initCollection(state, {
	            chatId: payload.chatId
	          });
	          var saveNeeded = false;
	          for (var index = state.collection[payload.chatId].length - 1; index >= 0; index--) {
	            var element = state.collection[payload.chatId][index];
	            if (element.unread) continue;
	            if (element.id >= payload.unreadId) {
	              state.collection[payload.chatId][index] = Object.assign(state.collection[payload.chatId][index], {
	                unread: true
	              });
	              saveNeeded = true;
	            }
	          }
	          if (saveNeeded) {
	            im_lib_logger.Logger.warn('Messages model: saving state after unreading');
	            _this3.saveState(state, payload.chatId);
	            _this3.updateSubordinateStates();
	          }
	        }
	      };
	    }
	  }, {
	    key: "initCollection",
	    value: function initCollection(state, payload) {
	      if (typeof payload.chatId === 'undefined') {
	        return false;
	      }
	      if (typeof payload.chatId === 'undefined' || typeof state.collection[payload.chatId] !== 'undefined') {
	        return true;
	      }
	      ui_vue.WidgetVue.set(state.collection, payload.chatId, payload.messages ? [].concat(payload.messages) : []);
	      ui_vue.WidgetVue.set(state.saveMessageList, payload.chatId, []);
	      ui_vue.WidgetVue.set(state.saveFileList, payload.chatId, []);
	      ui_vue.WidgetVue.set(state.saveUserList, payload.chatId, []);
	      return true;
	    }
	  }, {
	    key: "prepareMessage",
	    value: function prepareMessage(message) {
	      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	      var result = this.validate(Object.assign({}, message), options);
	      result.params = Object.assign({}, this.getElementState().params, result.params);
	      if (!result.templateId) {
	        result.templateId = result.id;
	      }
	      return Object.assign({}, this.getElementState(), result);
	    }
	  }, {
	    key: "manageCacheBeforeSet",
	    value: function manageCacheBeforeSet(cache, elements) {
	      var recursive = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
	      im_lib_logger.Logger.warn('manageCacheBeforeSet', cache, elements);
	      var result = {
	        type: IntersectionType.empty,
	        foundElements: [],
	        noneElements: []
	      };
	      if (!cache || cache.length <= 0) {
	        return result;
	      }
	      var _iterator3 = _createForOfIteratorHelper(elements),
	        _step3;
	      try {
	        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
	          var id = _step3.value;
	          if (cache.includes(id)) {
	            if (result.type === IntersectionType.empty) {
	              result.type = IntersectionType.found;
	            }
	            result.foundElements.push(id);
	          } else {
	            if (result.type === IntersectionType.empty) {
	              result.type = IntersectionType.none;
	            }
	            result.noneElements.push(id);
	          }
	        }
	      } catch (err) {
	        _iterator3.e(err);
	      } finally {
	        _iterator3.f();
	      }
	      if (result.type === IntersectionType.found && cache.length === elements.length && result.foundElements.length === elements.length) {
	        result.type = IntersectionType.equal;
	      } else if (result.type === IntersectionType.none && !recursive && result.foundElements.length > 0) {
	        var reverseResult = this.manageCacheBeforeSet(cache.reverse(), elements.reverse(), true);
	        if (reverseResult.type === IntersectionType.found) {
	          reverseResult.type = IntersectionType.foundReverse;
	          return reverseResult;
	        }
	      }
	      return result;
	    }
	  }, {
	    key: "updateSaveLists",
	    value: function updateSaveLists(state, chatId) {
	      if (!this.isSaveAvailable()) {
	        return true;
	      }
	      if (!chatId || !this.store.getters['dialogues/canSaveChat'] || !this.store.getters['dialogues/canSaveChat'](chatId)) {
	        return false;
	      }
	      this.initCollection(state, {
	        chatId: chatId
	      });
	      var count = 0;
	      var saveMessageList = [];
	      var saveFileList = [];
	      var saveUserList = [];
	      var dialog = this.store.getters['dialogues/getByChatId'](chatId);
	      if (dialog && dialog.type === 'private') {
	        saveUserList.push(parseInt(dialog.dialogId));
	      }
	      var readCounter = 0;
	      for (var index = state.collection[chatId].length - 1; index >= 0; index--) {
	        if (state.collection[chatId][index].id.toString().startsWith('temporary')) {
	          continue;
	        }
	        if (!state.collection[chatId][index].unread) {
	          readCounter++;
	        }
	        if (count >= im_const.StorageLimit.messages && readCounter >= 50) {
	          break;
	        }
	        saveMessageList.unshift(state.collection[chatId][index].id);
	        count++;
	      }
	      saveMessageList = saveMessageList.slice(0, im_const.StorageLimit.messages);
	      state.collection[chatId].filter(function (element) {
	        return saveMessageList.includes(element.id);
	      }).forEach(function (element) {
	        if (element.authorId > 0) {
	          saveUserList.push(element.authorId);
	        }
	        if (element.params.FILE_ID instanceof Array) {
	          saveFileList = element.params.FILE_ID.concat(saveFileList);
	        }
	      });
	      state.saveMessageList[chatId] = saveMessageList;
	      state.saveFileList[chatId] = babelHelpers.toConsumableArray(new Set(saveFileList));
	      state.saveUserList[chatId] = babelHelpers.toConsumableArray(new Set(saveUserList));
	      return true;
	    }
	  }, {
	    key: "getSaveTimeout",
	    value: function getSaveTimeout() {
	      return 150;
	    }
	  }, {
	    key: "saveState",
	    value: function saveState(state, chatId) {
	      if (!this.updateSaveLists(state, chatId)) {
	        return false;
	      }
	      babelHelpers.get(babelHelpers.getPrototypeOf(MessagesModel.prototype), "saveState", this).call(this, function () {
	        var storedState = {
	          collection: {},
	          saveMessageList: {},
	          saveUserList: {},
	          saveFileList: {}
	        };
	        var _loop3 = function _loop3(chatId) {
	          if (!state.saveMessageList.hasOwnProperty(chatId)) {
	            return "continue";
	          }
	          if (!state.collection[chatId]) {
	            return "continue";
	          }
	          if (!storedState.collection[chatId]) {
	            storedState.collection[chatId] = [];
	          }
	          state.collection[chatId].filter(function (element) {
	            return state.saveMessageList[chatId].includes(element.id);
	          }).forEach(function (element) {
	            if (element.templateType !== 'placeholder') {
	              storedState.collection[chatId].push(element);
	            }
	          });
	          im_lib_logger.Logger.warn('Cache after updating', storedState.collection[chatId]);
	          storedState.saveMessageList[chatId] = state.saveMessageList[chatId];
	          storedState.saveFileList[chatId] = state.saveFileList[chatId];
	          storedState.saveUserList[chatId] = state.saveUserList[chatId];
	        };
	        for (var _chatId in state.saveMessageList) {
	          var _ret2 = _loop3(_chatId);
	          if (_ret2 === "continue") continue;
	        }
	        return storedState;
	      });
	    }
	  }, {
	    key: "updateSubordinateStates",
	    value: function updateSubordinateStates() {
	      this.store.dispatch('users/saveState');
	      this.store.dispatch('files/saveState');
	    }
	  }, {
	    key: "validate",
	    value: function validate(fields, options) {
	      var result = {};
	      if (typeof fields.id === "number") {
	        result.id = fields.id;
	      } else if (typeof fields.id === "string") {
	        if (fields.id.startsWith('temporary') || fields.id.startsWith('placeholder') || im_lib_utils.Utils.types.isUuidV4(fields.id)) {
	          result.id = fields.id;
	        } else {
	          result.id = parseInt(fields.id);
	        }
	      }
	      if (typeof fields.uuid === "string") {
	        result.templateId = fields.uuid;
	      } else if (typeof fields.templateId === "number") {
	        result.templateId = fields.templateId;
	      } else if (typeof fields.templateId === "string") {
	        if (fields.templateId.startsWith('temporary') || im_lib_utils.Utils.types.isUuidV4(fields.templateId)) {
	          result.templateId = fields.templateId;
	        } else {
	          result.templateId = parseInt(fields.templateId);
	        }
	      }
	      if (typeof fields.templateType === "string") {
	        result.templateType = fields.templateType;
	      }
	      if (typeof fields.placeholderType === "number") {
	        result.placeholderType = fields.placeholderType;
	      }
	      if (typeof fields.chat_id !== 'undefined') {
	        fields.chatId = fields.chat_id;
	      }
	      if (typeof fields.chatId === "number" || typeof fields.chatId === "string") {
	        result.chatId = parseInt(fields.chatId);
	      }
	      if (typeof fields.date !== "undefined") {
	        result.date = im_lib_utils.Utils.date.cast(fields.date);
	      }

	      // previous P&P format
	      if (typeof fields.textLegacy === "string" || typeof fields.textLegacy === "number") {
	        if (typeof fields.text === "string" || typeof fields.text === "number") {
	          result.text = fields.text.toString();
	        }
	        result.textConverted = this.convertToHtml({
	          text: fields.textLegacy.toString(),
	          isConverted: true
	        });
	        if (typeof fields.text === "string" || typeof fields.text === "number") {
	          result.text = fields.text;
	        }
	      } else
	        // modern format
	        {
	          if (typeof fields.text_converted !== 'undefined') {
	            fields.textConverted = fields.text_converted;
	          }
	          if (typeof fields.textConverted === "string" || typeof fields.textConverted === "number") {
	            result.textConverted = fields.textConverted.toString();
	          }
	          if (typeof fields.text === "string" || typeof fields.text === "number") {
	            result.text = fields.text.toString();
	            var isConverted = typeof result.textConverted !== 'undefined';
	            result.textConverted = this.convertToHtml({
	              text: isConverted ? result.textConverted : result.text,
	              isConverted: isConverted
	            });
	          }
	        }
	      if (typeof fields.senderId !== 'undefined') {
	        fields.authorId = fields.senderId;
	      } else if (typeof fields.author_id !== 'undefined') {
	        fields.authorId = fields.author_id;
	      }
	      if (typeof fields.authorId === "number" || typeof fields.authorId === "string") {
	        if (fields.system === true || fields.system === 'Y') {
	          result.authorId = 0;
	        } else {
	          result.authorId = parseInt(fields.authorId);
	        }
	      }
	      if (babelHelpers["typeof"](fields.params) === "object" && fields.params !== null) {
	        var params = this.validateParams(fields.params, options);
	        if (params) {
	          result.params = params;
	        }
	      }
	      if (typeof fields.push === "boolean") {
	        result.push = fields.push;
	      }
	      if (typeof fields.sending === "boolean") {
	        result.sending = fields.sending;
	      }
	      if (typeof fields.unread === "boolean") {
	        result.unread = fields.unread;
	      }
	      if (typeof fields.blink === "boolean") {
	        result.blink = fields.blink;
	      }
	      if (typeof fields.error === "boolean" || typeof fields.error === "string") {
	        result.error = fields.error;
	      }
	      if (typeof fields.retry === "boolean") {
	        result.retry = fields.retry;
	      }
	      return result;
	    }
	  }, {
	    key: "validateParams",
	    value: function validateParams(params, options) {
	      var result = {};
	      try {
	        for (var field in params) {
	          if (!params.hasOwnProperty(field)) {
	            continue;
	          }
	          if (field === 'COMPONENT_ID') {
	            if (typeof params[field] === "string" && BX.WidgetVue.isComponent(params[field])) {
	              result[field] = params[field];
	            }
	          } else if (field === 'LIKE') {
	            if (params[field] instanceof Array) {
	              result['REACTION'] = {
	                like: params[field].map(function (element) {
	                  return parseInt(element);
	                })
	              };
	            }
	          } else if (field === 'CHAT_LAST_DATE') {
	            result[field] = im_lib_utils.Utils.date.cast(params[field]);
	          } else if (field === 'AVATAR') {
	            if (params[field]) {
	              result[field] = params[field].startsWith('http') ? params[field] : options.host + params[field];
	            }
	          } else if (field === 'NAME') {
	            if (params[field]) {
	              result[field] = params[field];
	            }
	          } else if (field === 'LINK_ACTIVE') {
	            if (params[field]) {
	              result[field] = params[field].map(function (userId) {
	                return parseInt(userId);
	              });
	            }
	          } else if (field === 'ATTACH') {
	            result[field] = params[field];
	          } else {
	            result[field] = params[field];
	          }
	        }
	      } catch (e) {}
	      var hasResultElements = false;
	      for (var _field in result) {
	        if (!result.hasOwnProperty(_field)) {
	          continue;
	        }
	        hasResultElements = true;
	        break;
	      }
	      return hasResultElements ? result : null;
	    }
	  }, {
	    key: "convertToHtml",
	    value: function convertToHtml() {
	      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	      var _params$quote = params.quote,
	        quote = _params$quote === void 0 ? true : _params$quote,
	        _params$image = params.image,
	        image = _params$image === void 0 ? true : _params$image,
	        _params$text = params.text,
	        text = _params$text === void 0 ? '' : _params$text,
	        _params$isConverted = params.isConverted,
	        isConverted = _params$isConverted === void 0 ? false : _params$isConverted,
	        _params$enableBigSmil = params.enableBigSmile,
	        enableBigSmile = _params$enableBigSmil === void 0 ? true : _params$enableBigSmil;
	      text = text.trim();
	      if (!isConverted) {
	        text = text.replace(/&/g, '&amp;').replace(/"/g, '&quot;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
	      }
	      if (text.startsWith('/me')) {
	        text = "<i>".concat(text.substr(4), "</i>");
	      } else if (text.startsWith('/loud')) {
	        text = "<b>".concat(text.substr(6), "</b>");
	      }
	      var quoteSign = "&gt;&gt;";
	      if (quote && text.indexOf(quoteSign) >= 0) {
	        var textPrepare = text.split(isConverted ? "<br />" : "\n");
	        for (var i = 0; i < textPrepare.length; i++) {
	          if (textPrepare[i].startsWith(quoteSign)) {
	            textPrepare[i] = textPrepare[i].replace(quoteSign, '<div class="bx-im-message-content-quote"><div class="bx-im-message-content-quote-wrap">');
	            while (++i < textPrepare.length && textPrepare[i].startsWith(quoteSign)) {
	              textPrepare[i] = textPrepare[i].replace(quoteSign, '');
	            }
	            textPrepare[i - 1] += '</div></div><br>';
	          }
	        }
	        text = textPrepare.join("<br />");
	      }
	      text = text.replace(/\n/gi, '<br />');
	      text = text.replace(/\t/gi, '&nbsp;&nbsp;&nbsp;&nbsp;');

	      //text = this.decodeBbCode(text, false, enableBigSmile);
	      text = im_lib_utils.Utils.text.decodeBbCode(text, enableBigSmile);
	      if (quote) {
	        text = text.replace(/------------------------------------------------------<br \/>(.*?)\[(.*?)\](?: #(?:(?:chat)?\d+|\d+:\d+)\/\d+)?<br \/>(.*?)------------------------------------------------------(<br \/>)?/g, function (whole, p1, p2, p3, p4, offset) {
	          return (offset > 0 ? '<br>' : '') + "<div class=\"bx-im-message-content-quote\"><div class=\"bx-im-message-content-quote-wrap\"><div class=\"bx-im-message-content-quote-name\"><span class=\"bx-im-message-content-quote-name-text\">" + p1 + "</span><span class=\"bx-im-message-content-quote-name-time\">" + p2 + "</span></div>" + p3 + "</div></div><br />";
	        });
	        text = text.replace(/------------------------------------------------------<br \/>(.*?)------------------------------------------------------(<br \/>)?/g, function (whole, p1, p2, p3, offset) {
	          return (offset > 0 ? '<br>' : '') + "<div class=\"bx-im-message-content-quote\"><div class=\"bx-im-message-content-quote-wrap\">" + p1 + "</div></div><br />";
	        });
	      }
	      if (image) {
	        var changed = false;
	        text = text.replace(/<a(.*?)>(http[s]{0,1}:\/\/.*?)<\/a>/ig, function (whole, aInner, text, offset) {
	          if (!text.match(/(\.(jpg|jpeg|png|gif|webp)\?|\.(jpg|jpeg|png|gif|webp)$)/i) || text.indexOf("/docs/pub/") > 0 || text.indexOf("logout=yes") > 0) {
	            return whole;
	          } else {
	            changed = true;
	            return (offset > 0 ? '<br />' : '') + '<a' + aInner + ' target="_blank" class="bx-im-element-file-image"><img src="' + text + '" class="bx-im-element-file-image-source-text" onerror="BX.Messenger.Model.MessagesModel.hideErrorImage(this)"></a></span>';
	          }
	        });
	        if (changed) {
	          text = text.replace(/<\/span>(\n?)<br(\s\/?)>/ig, '</span>').replace(/<br(\s\/?)>(\n?)<br(\s\/?)>(\n?)<span/ig, '<br /><span');
	        }
	      }
	      if (enableBigSmile) {
	        text = text.replace(/^(\s*<img\s+src=[^>]+?data-code=[^>]+?data-definition="UHD"[^>]+?style="width:)(\d+)(px[^>]+?height:)(\d+)(px[^>]+?class="bx-smile"\s*\/?>\s*)$/, function doubleSmileSize(match, start, width, middle, height, end) {
	          return start + parseInt(width, 10) * 1.7 + middle + parseInt(height, 10) * 1.7 + end;
	        });
	      }
	      if (text.substr(-6) == '<br />') {
	        text = text.substr(0, text.length - 6);
	      }
	      text = text.replace(/<br><br \/>/ig, '<br />');
	      text = text.replace(/<br \/><br>/ig, '<br />');
	      return text;
	    }
	  }, {
	    key: "decodeBbCode",
	    value: function decodeBbCode(text) {
	      var textOnly = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
	      var enableBigSmile = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
	      return MessagesModel.decodeBbCode({
	        text: text,
	        textOnly: textOnly,
	        enableBigSmile: enableBigSmile
	      });
	    }
	  }, {
	    key: "decodeAttach",
	    value: function decodeAttach(item) {
	      var _this4 = this;
	      if (Array.isArray(item)) {
	        item.forEach(function (arrayElement) {
	          arrayElement = _this4.decodeAttach(arrayElement);
	        });
	      } else if (babelHelpers["typeof"](item) === 'object' && item !== null) {
	        for (var prop in item) {
	          if (item.hasOwnProperty(prop)) {
	            item[prop] = this.decodeAttach(item[prop]);
	          }
	        }
	      } else {
	        if (typeof item === 'string') {
	          item = im_lib_utils.Utils.text.htmlspecialcharsback(item);
	        }
	      }
	      return item;
	    }
	  }], [{
	    key: "decodeBbCode",
	    value: function decodeBbCode() {
	      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	      var text = params.text,
	        _params$textOnly = params.textOnly,
	        textOnly = _params$textOnly === void 0 ? false : _params$textOnly,
	        _params$enableBigSmil2 = params.enableBigSmile,
	        enableBigSmile = _params$enableBigSmil2 === void 0 ? true : _params$enableBigSmil2;
	      var putReplacement = [];
	      text = text.replace(/\[PUT(?:=(.+?))?\](.+?)?\[\/PUT\]/ig, function (whole) {
	        var id = putReplacement.length;
	        putReplacement.push(whole);
	        return '####REPLACEMENT_PUT_' + id + '####';
	      });
	      var sendReplacement = [];
	      text = text.replace(/\[SEND(?:=(.+?))?\](.+?)?\[\/SEND\]/ig, function (whole) {
	        var id = sendReplacement.length;
	        sendReplacement.push(whole);
	        return '####REPLACEMENT_SEND_' + id + '####';
	      });
	      var codeReplacement = [];
	      text = text.replace(/\[CODE\]\n?([\s\S]*?)\[\/CODE\]/ig, function (whole, text) {
	        var id = codeReplacement.length;
	        codeReplacement.push(text);
	        return '####REPLACEMENT_CODE_' + id + '####';
	      });
	      text = text.replace(/\[url=([^\]]+)\](.*?)\[\/url\]/ig, function (whole, link, text) {
	        var tag = document.createElement('a');
	        tag.href = im_lib_utils.Utils.text.htmlspecialcharsback(link);
	        tag.target = '_blank';
	        tag.text = im_lib_utils.Utils.text.htmlspecialcharsback(text);
	        var allowList = ["http:", "https:", "ftp:", "file:", "tel:", "callto:", "mailto:", "skype:", "viber:"];
	        if (allowList.indexOf(tag.protocol) <= -1) {
	          return whole;
	        }
	        return tag.outerHTML;
	      });
	      text = text.replace(/\[url\]([^\]]+)\[\/url\]/ig, function (whole, link) {
	        link = im_lib_utils.Utils.text.htmlspecialcharsback(link);
	        var tag = document.createElement('a');
	        tag.href = link;
	        tag.target = '_blank';
	        tag.text = link;
	        var allowList = ["http:", "https:", "ftp:", "file:", "tel:", "callto:", "mailto:", "skype:", "viber:"];
	        if (allowList.indexOf(tag.protocol) <= -1) {
	          return whole;
	        }
	        return tag.outerHTML;
	      });
	      text = text.replace(/\[LIKE\]/ig, '<span class="bx-smile bx-im-smile-like"></span>');
	      text = text.replace(/\[DISLIKE\]/ig, '<span class="bx-smile bx-im-smile-dislike"></span>');
	      text = text.replace(/\[BR\]/ig, '<br/>');
	      text = text.replace(/\[([buis])\](.*?)\[(\/[buis])\]/ig, function (whole, open, inner, close) {
	        return '<' + open + '>' + inner + '<' + close + '>';
	      }); // TODO tag USER

	      // this code needs to be ported to im/install/js/im/view/message/body/src/body.js:229
	      text = text.replace(/\[CHAT=(imol\|)?([0-9]{1,})\](.*?)\[\/CHAT\]/ig, function (whole, openlines, chatId, inner) {
	        return openlines ? inner : '<span class="bx-im-mention" data-type="CHAT" data-value="chat' + chatId + '">' + inner + '</span>';
	      }); // TODO tag CHAT
	      text = text.replace(/\[CALL(?:=(.+?))?\](.+?)?\[\/CALL\]/ig, function (whole, number, text) {
	        return '<span class="bx-im-mention" data-type="CALL" data-value="' + im_lib_utils.Utils.text.htmlspecialchars(number) + '">' + text + '</span>';
	      }); // TODO tag CHAT

	      text = text.replace(/\[PCH=([0-9]{1,})\](.*?)\[\/PCH\]/ig, function (whole, historyId, text) {
	        return text;
	      }); // TODO tag PCH

	      var textElementSize = 0;
	      if (enableBigSmile) {
	        textElementSize = text.replace(/\[icon\=([^\]]*)\]/ig, '').trim().length;
	      }
	      text = text.replace(/\[icon\=([^\]]*)\]/ig, function (whole) {
	        var url = whole.match(/icon\=(\S+[^\s.,> )\];\'\"!?])/i);
	        if (url && url[1]) {
	          url = url[1];
	        } else {
	          return '';
	        }
	        var attrs = {
	          'src': url,
	          'border': 0
	        };
	        var size = whole.match(/size\=(\d+)/i);
	        if (size && size[1]) {
	          attrs['width'] = size[1];
	          attrs['height'] = size[1];
	        } else {
	          var width = whole.match(/width\=(\d+)/i);
	          if (width && width[1]) {
	            attrs['width'] = width[1];
	          }
	          var height = whole.match(/height\=(\d+)/i);
	          if (height && height[1]) {
	            attrs['height'] = height[1];
	          }
	          if (attrs['width'] && !attrs['height']) {
	            attrs['height'] = attrs['width'];
	          } else if (attrs['height'] && !attrs['width']) {
	            attrs['width'] = attrs['height'];
	          } else if (attrs['height'] && attrs['width']) ; else {
	            attrs['width'] = 20;
	            attrs['height'] = 20;
	          }
	        }
	        attrs['width'] = attrs['width'] > 100 ? 100 : attrs['width'];
	        attrs['height'] = attrs['height'] > 100 ? 100 : attrs['height'];
	        if (enableBigSmile && textElementSize === 0 && attrs['width'] === attrs['height'] && attrs['width'] === 20) {
	          attrs['width'] = 40;
	          attrs['height'] = 40;
	        }
	        var title = whole.match(/title\=(.*[^\s\]])/i);
	        if (title && title[1]) {
	          title = title[1];
	          if (title.indexOf('width=') > -1) {
	            title = title.substr(0, title.indexOf('width='));
	          }
	          if (title.indexOf('height=') > -1) {
	            title = title.substr(0, title.indexOf('height='));
	          }
	          if (title.indexOf('size=') > -1) {
	            title = title.substr(0, title.indexOf('size='));
	          }
	          if (title) {
	            attrs['title'] = im_lib_utils.Utils.text.htmlspecialchars(title).trim();
	            attrs['alt'] = attrs['title'];
	          }
	        }
	        var attributes = '';
	        for (var name in attrs) {
	          if (attrs.hasOwnProperty(name)) {
	            attributes += name + '="' + attrs[name] + '" ';
	          }
	        }
	        return '<img class="bx-smile bx-icon" ' + attributes + '>';
	      });
	      sendReplacement.forEach(function (value, index) {
	        text = text.replace('####REPLACEMENT_SEND_' + index + '####', value);
	      });
	      text = text.replace(/\[SEND(?:=(?:.+?))?\](?:.+?)?\[\/SEND]/ig, function (match) {
	        return match.replace(/\[SEND(?:=(.+))?\](.+?)?\[\/SEND]/ig, function (whole, command, text) {
	          var html = '';
	          text = text ? text : command;
	          command = (command ? command : text).replace('<br />', '\n');
	          if (!textOnly && text) {
	            text = text.replace(/<([\w]+)[^>]*>(.*?)<\\1>/i, "$2", text);
	            text = text.replace(/\[([\w]+)[^\]]*\](.*?)\[\/\1\]/i, "$2", text);
	            command = command.split('####REPLACEMENT_PUT_').join('####REPLACEMENT_SP_');
	            html = '<!--IM_COMMAND_START-->' + '<span class="bx-im-message-command-wrap">' + '<span class="bx-im-message-command" data-entity="send">' + text + '</span>' + '<span class="bx-im-message-command-data">' + command + '</span>' + '</span>' + '<!--IM_COMMAND_END-->';
	          } else {
	            html = text;
	          }
	          return html;
	        });
	      });
	      putReplacement.forEach(function (value, index) {
	        text = text.replace('####REPLACEMENT_PUT_' + index + '####', value);
	      });
	      text = text.replace(/\[PUT(?:=(?:.+?))?\](?:.+?)?\[\/PUT]/ig, function (match) {
	        return match.replace(/\[PUT(?:=(.+))?\](.+?)?\[\/PUT]/ig, function (whole, command, text) {
	          var html = '';
	          text = text ? text : command;
	          command = (command ? command : text).replace('<br />', '\n');
	          if (!textOnly && text) {
	            text = text.replace(/<([\w]+)[^>]*>(.*?)<\/\1>/i, "$2", text);
	            text = text.replace(/\[([\w]+)[^\]]*\](.*?)\[\/\1\]/i, "$2", text);
	            html = '<!--IM_COMMAND_START-->' + '<span class="bx-im-message-command-wrap">' + '<span class="bx-im-message-command" data-entity="put">' + text + '</span>' + '<span class="bx-im-message-command-data">' + command + '</span>' + '</span>' + '<!--IM_COMMAND_END-->';
	          } else {
	            html = text;
	          }
	          return html;
	        });
	      });
	      codeReplacement.forEach(function (code, index) {
	        text = text.replace('####REPLACEMENT_CODE_' + index + '####', !textOnly ? '<div class="bx-im-message-content-code">' + code + '</div>' : code);
	      });
	      if (sendReplacement.length > 0) {
	        do {
	          sendReplacement.forEach(function (value, index) {
	            text = text.replace('####REPLACEMENT_SEND_' + index + '####', value);
	          });
	        } while (text.includes('####REPLACEMENT_SEND_'));
	      }
	      text = text.split('####REPLACEMENT_SP_').join('####REPLACEMENT_PUT_');
	      if (putReplacement.length > 0) {
	        do {
	          putReplacement.forEach(function (value, index) {
	            text = text.replace('####REPLACEMENT_PUT_' + index + '####', value);
	          });
	        } while (text.includes('####REPLACEMENT_PUT_'));
	      }
	      return text;
	    }
	  }, {
	    key: "hideErrorImage",
	    value: function hideErrorImage(element) {
	      if (element.parentNode && element.parentNode) {
	        element.parentNode.innerHTML = '<a href="' + element.src + '" target="_blank">' + element.src + '</a>';
	      }
	      return true;
	    }
	  }, {
	    key: "isTemporaryMessage",
	    value: function isTemporaryMessage(element) {
	      return element.id && (im_lib_utils.Utils.types.isUuidV4(element.id) || element.id.toString().startsWith('temporary'));
	    }
	  }, {
	    key: "getPayloadWithTempMessages",
	    value: function getPayloadWithTempMessages(state, payload) {
	      var payloadData = babelHelpers.toConsumableArray(payload.data);
	      if (!im_lib_utils.Utils.platform.isBitrixMobile()) {
	        return payloadData;
	      }
	      if (!payload.data || payload.data.length <= 0) {
	        return payloadData;
	      }

	      // consider that in the payload we have messages only for one chat, so we get the value from the first message.
	      var payloadChatId = payload.data[0].chatId;
	      if (!state.collection[payloadChatId]) {
	        return payloadData;
	      }
	      state.collection[payloadChatId].forEach(function (message) {
	        if (MessagesModel.isTemporaryMessage(message) && !MessagesModel.existsInPayload(payload, message.templateId) && MessagesModel.doesTaskExist(message)) {
	          payloadData.push(message);
	        }
	      });
	      return payloadData;
	    }
	  }, {
	    key: "existsInPayload",
	    value: function existsInPayload(payload, templateId) {
	      return payload.data.find(function (payloadMessage) {
	        return payloadMessage.templateId === templateId;
	      });
	    }
	  }, {
	    key: "doesTaskExist",
	    value: function doesTaskExist(message) {
	      if (Array.isArray(message.params.FILE_ID)) {
	        var foundUploadTasks = false;
	        message.params.FILE_ID.forEach(function (fileId) {
	          if (!foundUploadTasks) {
	            foundUploadTasks = window.imDialogUploadTasks.find(function (task) {
	              return task.taskId.split('|')[1] === fileId;
	            });
	          }
	        });
	        return !!foundUploadTasks;
	      }
	      if (message.templateId) {
	        var foundMessageTask = window.imDialogMessagesTasks.find(function (task) {
	          return task.taskId.split('|')[1] === message.templateId;
	        });
	        return !!foundMessageTask;
	      }
	      return false;
	    }
	  }]);
	  return MessagesModel;
	}(ui_vue_vuex.WidgetVuexBuilderModel);

	function _createForOfIteratorHelper$1(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$1(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }
	function _unsupportedIterableToArray$1(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$1(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$1(o, minLen); }
	function _arrayLikeToArray$1(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
	var DialoguesModel = /*#__PURE__*/function (_VuexBuilderModel) {
	  babelHelpers.inherits(DialoguesModel, _VuexBuilderModel);
	  function DialoguesModel() {
	    babelHelpers.classCallCheck(this, DialoguesModel);
	    return babelHelpers.possibleConstructorReturn(this, babelHelpers.getPrototypeOf(DialoguesModel).apply(this, arguments));
	  }
	  babelHelpers.createClass(DialoguesModel, [{
	    key: "getName",
	    value: function getName() {
	      return 'dialogues';
	    }
	  }, {
	    key: "getState",
	    value: function getState() {
	      return {
	        host: this.getVariable('host', location.protocol + '//' + location.host),
	        collection: {},
	        saveDialogList: [],
	        saveChatList: []
	      };
	    }
	  }, {
	    key: "getStateSaveException",
	    value: function getStateSaveException() {
	      return {
	        host: null
	      };
	    }
	  }, {
	    key: "getElementStateSaveException",
	    value: function getElementStateSaveException() {
	      return {
	        writingList: null,
	        quoteId: null
	      };
	    }
	  }, {
	    key: "getElementState",
	    value: function getElementState() {
	      return {
	        dialogId: '0',
	        chatId: 0,
	        counter: 0,
	        userCounter: 0,
	        messageCount: 0,
	        unreadId: 0,
	        lastMessageId: 0,
	        managerList: [],
	        readedList: [],
	        writingList: [],
	        muteList: [],
	        textareaMessage: "",
	        quoteId: 0,
	        editId: 0,
	        init: false,
	        name: "",
	        owner: 0,
	        extranet: false,
	        avatar: "",
	        color: "#17A3EA",
	        type: "chat",
	        entityType: "",
	        entityId: "",
	        entityData1: "",
	        entityData2: "",
	        entityData3: "",
	        dateCreate: new Date(),
	        restrictions: {
	          avatar: true,
	          extend: true,
	          leave: true,
	          leaveOwner: true,
	          rename: true,
	          send: true,
	          userList: true,
	          mute: true,
	          call: true
	        },
	        "public": {
	          code: '',
	          link: ''
	        }
	      };
	    }
	  }, {
	    key: "getGetters",
	    value: function getGetters() {
	      var _this = this;
	      return {
	        get: function get(state) {
	          return function (dialogId) {
	            if (!state.collection[dialogId]) {
	              return null;
	            }
	            return state.collection[dialogId];
	          };
	        },
	        getByChatId: function getByChatId(state) {
	          return function (chatId) {
	            chatId = parseInt(chatId);
	            for (var dialogId in state.collection) {
	              if (!state.collection.hasOwnProperty(dialogId)) {
	                continue;
	              }
	              if (state.collection[dialogId].chatId === chatId) {
	                return state.collection[dialogId];
	              }
	            }
	            return null;
	          };
	        },
	        getBlank: function getBlank(state) {
	          return function (params) {
	            return _this.getElementState();
	          };
	        },
	        getQuoteId: function getQuoteId(state) {
	          return function (dialogId) {
	            if (!state.collection[dialogId]) {
	              return 0;
	            }
	            return state.collection[dialogId].quoteId;
	          };
	        },
	        getEditId: function getEditId(state) {
	          return function (dialogId) {
	            if (!state.collection[dialogId]) {
	              return 0;
	            }
	            return state.collection[dialogId].editId;
	          };
	        },
	        canSaveChat: function canSaveChat(state) {
	          return function (chatId) {
	            if (/^\d+$/.test(chatId)) {
	              chatId = parseInt(chatId);
	            }
	            return state.saveChatList.includes(parseInt(chatId));
	          };
	        },
	        canSaveDialog: function canSaveDialog(state) {
	          return function (dialogId) {
	            return state.saveDialogList.includes(dialogId.toString());
	          };
	        },
	        isPrivateDialog: function isPrivateDialog(state) {
	          return function (dialogId) {
	            dialogId = dialogId.toString();
	            return state.collection[dialogId.toString()] && state.collection[dialogId].type === 'private';
	          };
	        }
	      };
	    }
	  }, {
	    key: "getActions",
	    value: function getActions() {
	      var _this2 = this;
	      return {
	        set: function set(store, payload) {
	          if (payload instanceof Array) {
	            payload = payload.map(function (dialog) {
	              return Object.assign({}, _this2.validate(Object.assign({}, dialog), {
	                host: store.state.host
	              }), {
	                init: true
	              });
	            });
	          } else {
	            var result = [];
	            result.push(Object.assign({}, _this2.validate(Object.assign({}, payload), {
	              host: store.state.host
	            }), {
	              init: true
	            }));
	            payload = result;
	          }
	          store.commit('set', payload);
	        },
	        update: function update(store, payload) {
	          if (typeof store.state.collection[payload.dialogId] === 'undefined' || store.state.collection[payload.dialogId].init === false) {
	            return true;
	          }
	          store.commit('update', {
	            dialogId: payload.dialogId,
	            fields: _this2.validate(Object.assign({}, payload.fields), {
	              host: store.state.host
	            })
	          });
	          return true;
	        },
	        "delete": function _delete(store, payload) {
	          store.commit('delete', payload.dialogId);
	          return true;
	        },
	        updateWriting: function updateWriting(store, payload) {
	          if (typeof store.state.collection[payload.dialogId] === 'undefined' || store.state.collection[payload.dialogId].init === false) {
	            return true;
	          }
	          var index = store.state.collection[payload.dialogId].writingList.findIndex(function (el) {
	            return el.userId === payload.userId;
	          });
	          if (payload.action) {
	            if (index >= 0) {
	              return true;
	            } else {
	              var writingList = [].concat(store.state.collection[payload.dialogId].writingList);
	              writingList.unshift({
	                userId: payload.userId,
	                userName: payload.userName
	              });
	              store.commit('update', {
	                actionName: 'updateWriting/1',
	                dialogId: payload.dialogId,
	                fields: _this2.validate({
	                  writingList: writingList
	                }, {
	                  host: store.state.host
	                })
	              });
	            }
	          } else {
	            if (index >= 0) {
	              var _writingList = store.state.collection[payload.dialogId].writingList.filter(function (el) {
	                return el.userId !== payload.userId;
	              });
	              store.commit('update', {
	                actionName: 'updateWriting/2',
	                dialogId: payload.dialogId,
	                fields: _this2.validate({
	                  writingList: _writingList
	                }, {
	                  host: store.state.host
	                })
	              });
	              return true;
	            } else {
	              return true;
	            }
	          }
	          return false;
	        },
	        updateReaded: function updateReaded(store, payload) {
	          if (typeof store.state.collection[payload.dialogId] === 'undefined' || store.state.collection[payload.dialogId].init === false) {
	            return true;
	          }
	          var readedList = store.state.collection[payload.dialogId].readedList.filter(function (el) {
	            return el.userId !== payload.userId;
	          });
	          if (payload.action) {
	            readedList.push({
	              userId: payload.userId,
	              userName: payload.userName || '',
	              messageId: payload.messageId,
	              date: payload.date || new Date()
	            });
	          }
	          store.commit('update', {
	            actionName: 'updateReaded',
	            dialogId: payload.dialogId,
	            fields: _this2.validate({
	              readedList: readedList
	            }, {
	              host: store.state.host
	            })
	          });
	          return false;
	        },
	        increaseCounter: function increaseCounter(store, payload) {
	          var _store$rootState$appl;
	          if (typeof store.state.collection[payload.dialogId] === 'undefined' || store.state.collection[payload.dialogId].init === false) {
	            return true;
	          }
	          var counter = store.state.collection[payload.dialogId].counter;
	          if (counter === 100) {
	            return true;
	          }
	          var increasedCounter = counter + payload.count;
	          if (increasedCounter > 100) {
	            increasedCounter = 100;
	          }
	          var userId = (_store$rootState$appl = store.rootState.application) === null || _store$rootState$appl === void 0 ? void 0 : _store$rootState$appl.common.userId;
	          var dialogMuted = userId && store.state.collection[payload.dialogId].muteList.includes(userId);
	          store.commit('update', {
	            actionName: 'increaseCounter',
	            dialogId: payload.dialogId,
	            dialogMuted: dialogMuted,
	            fields: {
	              counter: increasedCounter,
	              previousCounter: counter
	            }
	          });
	          return false;
	        },
	        decreaseCounter: function decreaseCounter(store, payload) {
	          if (typeof store.state.collection[payload.dialogId] === 'undefined' || store.state.collection[payload.dialogId].init === false) {
	            return true;
	          }
	          var counter = store.state.collection[payload.dialogId].counter;
	          if (counter === 100) {
	            return true;
	          }
	          var decreasedCounter = counter - payload.count;
	          if (decreasedCounter < 0) {
	            decreasedCounter = 0;
	          }
	          var unreadId = payload.unreadId > store.state.collection[payload.dialogId].unreadId ? payload.unreadId : store.state.collection[payload.dialogId].unreadId;
	          if (store.state.collection[payload.dialogId].unreadId !== unreadId || store.state.collection[payload.dialogId].counter !== decreasedCounter) {
	            var _store$rootState$appl2;
	            var previousCounter = store.state.collection[payload.dialogId].counter;
	            if (decreasedCounter === 0) {
	              unreadId = 0;
	            }
	            var userId = (_store$rootState$appl2 = store.rootState.application) === null || _store$rootState$appl2 === void 0 ? void 0 : _store$rootState$appl2.common.userId;
	            var dialogMuted = userId && store.state.collection[payload.dialogId].muteList.includes(userId);
	            store.commit('update', {
	              actionName: 'decreaseCounter',
	              dialogId: payload.dialogId,
	              dialogMuted: dialogMuted,
	              fields: {
	                counter: decreasedCounter,
	                previousCounter: previousCounter,
	                unreadId: unreadId
	              }
	            });
	          }
	          return false;
	        },
	        increaseMessageCounter: function increaseMessageCounter(store, payload) {
	          if (typeof store.state.collection[payload.dialogId] === 'undefined' || store.state.collection[payload.dialogId].init === false) {
	            return true;
	          }
	          var currentCounter = store.state.collection[payload.dialogId].messageCount;
	          store.commit('update', {
	            actionName: 'increaseMessageCount',
	            dialogId: payload.dialogId,
	            fields: {
	              messageCount: currentCounter + payload.count
	            }
	          });
	        },
	        saveDialog: function saveDialog(store, payload) {
	          if (typeof store.state.collection[payload.dialogId] === 'undefined' || store.state.collection[payload.dialogId].init === false) {
	            return true;
	          }
	          store.commit('saveDialog', {
	            dialogId: payload.dialogId,
	            chatId: payload.chatId
	          });
	          return false;
	        }
	      };
	    }
	  }, {
	    key: "getMutations",
	    value: function getMutations() {
	      var _this3 = this;
	      return {
	        initCollection: function initCollection(state, payload) {
	          _this3.initCollection(state, payload);
	        },
	        saveDialog: function saveDialog(state, payload) {
	          // TODO if payload.dialogId is IMOL, skip update this flag
	          if (!(payload.chatId > 0 && payload.dialogId.length > 0)) {
	            return false;
	          }
	          var saveDialogList = state.saveDialogList.filter(function (element) {
	            return element !== payload.dialogId;
	          });
	          saveDialogList.unshift(payload.dialogId);
	          saveDialogList = saveDialogList.slice(0, im_const.StorageLimit.dialogues);
	          if (state.saveDialogList.join(',') === saveDialogList.join(',')) {
	            return true;
	          }
	          state.saveDialogList = saveDialogList;
	          var saveChatList = state.saveChatList.filter(function (element) {
	            return element !== payload.chatId;
	          });
	          saveChatList.unshift(payload.chatId);
	          state.saveChatList = saveChatList.slice(0, im_const.StorageLimit.dialogues);
	          _this3.saveState(state);
	        },
	        set: function set(state, payload) {
	          var _iterator = _createForOfIteratorHelper$1(payload),
	            _step;
	          try {
	            for (_iterator.s(); !(_step = _iterator.n()).done;) {
	              var element = _step.value;
	              _this3.initCollection(state, {
	                dialogId: element.dialogId
	              });
	              state.collection[element.dialogId] = Object.assign(_this3.getElementState(), state.collection[element.dialogId], element);
	            }

	            // TODO if payload.dialogId is IMOL, skip update cache
	          } catch (err) {
	            _iterator.e(err);
	          } finally {
	            _iterator.f();
	          }
	          _this3.saveState(state);
	        },
	        update: function update(state, payload) {
	          _this3.initCollection(state, payload);
	          state.collection[payload.dialogId] = Object.assign(state.collection[payload.dialogId], payload.fields);

	          // TODO if payload.dialogId is IMOL, skip update cache
	          _this3.saveState(state);
	        },
	        "delete": function _delete(state, payload) {
	          delete state.collection[payload.dialogId];

	          // TODO if payload.dialogId is IMOL, skip update cache
	          _this3.saveState(state);
	        }
	      };
	    }
	  }, {
	    key: "initCollection",
	    value: function initCollection(state, payload) {
	      if (typeof state.collection[payload.dialogId] !== 'undefined') {
	        return true;
	      }
	      ui_vue.WidgetVue.set(state.collection, payload.dialogId, this.getElementState());
	      if (payload.fields) {
	        state.collection[payload.dialogId] = Object.assign(state.collection[payload.dialogId], this.validate(Object.assign({}, payload.fields), {
	          host: state.host
	        }));
	      }
	      return true;
	    }
	  }, {
	    key: "getSaveTimeout",
	    value: function getSaveTimeout() {
	      return 100;
	    }
	  }, {
	    key: "saveState",
	    value: function saveState() {
	      var _this4 = this;
	      var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	      if (!this.isSaveAvailable()) {
	        return true;
	      }
	      babelHelpers.get(babelHelpers.getPrototypeOf(DialoguesModel.prototype), "saveState", this).call(this, function () {
	        var storedState = {
	          collection: {},
	          saveDialogList: [].concat(state.saveDialogList),
	          saveChatList: [].concat(state.saveChatList)
	        };
	        state.saveDialogList.forEach(function (dialogId) {
	          if (!state.collection[dialogId]) return false;
	          storedState.collection[dialogId] = Object.assign(_this4.getElementState(), _this4.cloneState(state.collection[dialogId], _this4.getElementStateSaveException()));
	        });
	        return storedState;
	      });
	    }
	  }, {
	    key: "validate",
	    value: function validate(fields) {
	      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	      var result = {};
	      options.host = options.host || this.getState().host;
	      if (typeof fields.dialog_id !== 'undefined') {
	        fields.dialogId = fields.dialog_id;
	      }
	      if (typeof fields.dialogId === "number" || typeof fields.dialogId === "string") {
	        result.dialogId = fields.dialogId.toString();
	      }
	      if (typeof fields.chat_id !== 'undefined') {
	        fields.chatId = fields.chat_id;
	      } else if (typeof fields.id !== 'undefined') {
	        fields.chatId = fields.id;
	      }
	      if (typeof fields.chatId === "number" || typeof fields.chatId === "string") {
	        result.chatId = parseInt(fields.chatId);
	      }
	      if (typeof fields.quoteId === "number") {
	        result.quoteId = parseInt(fields.quoteId);
	      }
	      if (typeof fields.editId === "number") {
	        result.editId = parseInt(fields.editId);
	      }
	      if (typeof fields.counter === "number" || typeof fields.counter === "string") {
	        result.counter = parseInt(fields.counter);
	      }
	      if (typeof fields.user_counter === "number" || typeof fields.user_counter === "string") {
	        result.userCounter = parseInt(fields.user_counter);
	      }
	      if (typeof fields.userCounter === "number" || typeof fields.userCounter === "string") {
	        result.userCounter = parseInt(fields.userCounter);
	      }
	      if (typeof fields.message_count === "number" || typeof fields.message_count === "string") {
	        result.messageCount = parseInt(fields.message_count);
	      }
	      if (typeof fields.messageCount === "number" || typeof fields.messageCount === "string") {
	        result.messageCount = parseInt(fields.messageCount);
	      }
	      if (typeof fields.unread_id !== 'undefined') {
	        fields.unreadId = fields.unread_id;
	      }
	      if (typeof fields.unreadId === "number" || typeof fields.unreadId === "string") {
	        result.unreadId = parseInt(fields.unreadId);
	      }
	      if (typeof fields.last_message_id !== 'undefined') {
	        fields.lastMessageId = fields.last_message_id;
	      }
	      if (typeof fields.lastMessageId === "number" || typeof fields.lastMessageId === "string") {
	        result.lastMessageId = parseInt(fields.lastMessageId);
	      }
	      if (typeof fields.readed_list !== 'undefined') {
	        fields.readedList = fields.readed_list;
	      }
	      if (typeof fields.readedList !== 'undefined') {
	        result.readedList = [];
	        if (fields.readedList instanceof Array) {
	          fields.readedList.forEach(function (element) {
	            var record = {};
	            if (typeof element.user_id !== 'undefined') {
	              element.userId = element.user_id;
	            }
	            if (typeof element.user_name !== 'undefined') {
	              element.userName = element.user_name;
	            }
	            if (typeof element.message_id !== 'undefined') {
	              element.messageId = element.message_id;
	            }
	            if (!element.userId || !element.userName || !element.messageId) {
	              return false;
	            }
	            record.userId = parseInt(element.userId);
	            record.userName = element.userName.toString();
	            record.messageId = parseInt(element.messageId);
	            record.date = im_lib_utils.Utils.date.cast(element.date);
	            result.readedList.push(record);
	          });
	        }
	      }
	      if (typeof fields.writing_list !== 'undefined') {
	        fields.writingList = fields.writing_list;
	      }
	      if (typeof fields.writingList !== 'undefined') {
	        result.writingList = [];
	        if (fields.writingList instanceof Array) {
	          fields.writingList.forEach(function (element) {
	            var record = {};
	            if (!element.userId) {
	              return false;
	            }
	            record.userId = parseInt(element.userId);
	            record.userName = im_lib_utils.Utils.text.htmlspecialcharsback(element.userName);
	            result.writingList.push(record);
	          });
	        }
	      }
	      if (typeof fields.manager_list !== 'undefined') {
	        fields.managerList = fields.manager_list;
	      }
	      if (typeof fields.managerList !== 'undefined') {
	        result.managerList = [];
	        if (fields.managerList instanceof Array) {
	          fields.managerList.forEach(function (userId) {
	            userId = parseInt(userId);
	            if (userId > 0) {
	              result.managerList.push(userId);
	            }
	          });
	        }
	      }
	      if (typeof fields.mute_list !== 'undefined') {
	        fields.muteList = fields.mute_list;
	      }
	      if (typeof fields.muteList !== 'undefined') {
	        result.muteList = [];
	        if (fields.muteList instanceof Array) {
	          fields.muteList.forEach(function (userId) {
	            userId = parseInt(userId);
	            if (userId > 0) {
	              result.muteList.push(userId);
	            }
	          });
	        } else if (babelHelpers["typeof"](fields.muteList) === 'object') {
	          Object.entries(fields.muteList).forEach(function (entry) {
	            if (entry[1] === true) {
	              var userId = parseInt(entry[0]);
	              if (userId > 0) {
	                result.muteList.push(userId);
	              }
	            }
	          });
	        }
	      }
	      if (typeof fields.textareaMessage !== 'undefined') {
	        result.textareaMessage = fields.textareaMessage.toString();
	      }
	      if (typeof fields.title !== 'undefined') {
	        fields.name = fields.title;
	      }
	      if (typeof fields.name === "string" || typeof fields.name === "number") {
	        result.name = im_lib_utils.Utils.text.htmlspecialcharsback(fields.name.toString());
	      }
	      if (typeof fields.owner !== 'undefined') {
	        fields.ownerId = fields.owner;
	      }
	      if (typeof fields.ownerId === "number" || typeof fields.ownerId === "string") {
	        result.ownerId = parseInt(fields.ownerId);
	      }
	      if (typeof fields.extranet === "boolean") {
	        result.extranet = fields.extranet;
	      }
	      if (typeof fields.avatar === 'string') {
	        var avatar;
	        if (!fields.avatar || fields.avatar.endsWith('/js/im/images/blank.gif')) {
	          avatar = '';
	        } else if (fields.avatar.startsWith('http')) {
	          avatar = fields.avatar;
	        } else {
	          avatar = options.host + fields.avatar;
	        }
	        if (avatar) {
	          result.avatar = encodeURI(avatar);
	        }
	      }
	      if (typeof fields.color === "string") {
	        result.color = fields.color.toString();
	      }
	      if (typeof fields.type === "string") {
	        result.type = fields.type.toString();
	      }
	      if (typeof fields.entity_type !== 'undefined') {
	        fields.entityType = fields.entity_type;
	      }
	      if (typeof fields.entityType === "string") {
	        result.entityType = fields.entityType.toString();
	      }
	      if (typeof fields.entity_id !== 'undefined') {
	        fields.entityId = fields.entity_id;
	      }
	      if (typeof fields.entityId === "string" || typeof fields.entityId === "number") {
	        result.entityId = fields.entityId.toString();
	      }
	      if (typeof fields.entity_data_1 !== 'undefined') {
	        fields.entityData1 = fields.entity_data_1;
	      }
	      if (typeof fields.entityData1 === "string") {
	        result.entityData1 = fields.entityData1.toString();
	      }
	      if (typeof fields.entity_data_2 !== 'undefined') {
	        fields.entityData2 = fields.entity_data_2;
	      }
	      if (typeof fields.entityData2 === "string") {
	        result.entityData2 = fields.entityData2.toString();
	      }
	      if (typeof fields.entity_data_3 !== 'undefined') {
	        fields.entityData3 = fields.entity_data_3;
	      }
	      if (typeof fields.entityData3 === "string") {
	        result.entityData3 = fields.entityData3.toString();
	      }
	      if (typeof fields.date_create !== 'undefined') {
	        fields.dateCreate = fields.date_create;
	      }
	      if (typeof fields.dateCreate !== "undefined") {
	        result.dateCreate = im_lib_utils.Utils.date.cast(fields.dateCreate);
	      }
	      if (typeof fields.dateLastOpen !== "undefined") {
	        result.dateLastOpen = im_lib_utils.Utils.date.cast(fields.dateLastOpen);
	      }
	      if (babelHelpers["typeof"](fields.restrictions) === 'object' && fields.restrictions) {
	        result.restrictions = {};
	        if (typeof fields.restrictions.avatar === 'boolean') {
	          result.restrictions.avatar = fields.restrictions.avatar;
	        }
	        if (typeof fields.restrictions.extend === 'boolean') {
	          result.restrictions.extend = fields.restrictions.extend;
	        }
	        if (typeof fields.restrictions.leave === 'boolean') {
	          result.restrictions.leave = fields.restrictions.leave;
	        }
	        if (typeof fields.restrictions.leave_owner === 'boolean') {
	          result.restrictions.leaveOwner = fields.restrictions.leave_owner;
	        }
	        if (typeof fields.restrictions.rename === 'boolean') {
	          result.restrictions.rename = fields.restrictions.rename;
	        }
	        if (typeof fields.restrictions.send === 'boolean') {
	          result.restrictions.send = fields.restrictions.send;
	        }
	        if (typeof fields.restrictions.user_list === 'boolean') {
	          result.restrictions.userList = fields.restrictions.user_list;
	        }
	        if (typeof fields.restrictions.mute === 'boolean') {
	          result.restrictions.mute = fields.restrictions.mute;
	        }
	        if (typeof fields.restrictions.call === 'boolean') {
	          result.restrictions.call = fields.restrictions.call;
	        }
	      }
	      if (babelHelpers["typeof"](fields["public"]) === 'object' && fields["public"]) {
	        result["public"] = {};
	        if (typeof fields["public"].code === 'string') {
	          result["public"].code = fields["public"].code;
	        }
	        if (typeof fields["public"].link === 'string') {
	          result["public"].link = fields["public"].link;
	        }
	      }
	      return result;
	    }
	  }]);
	  return DialoguesModel;
	}(ui_vue_vuex.WidgetVuexBuilderModel);

	function _createForOfIteratorHelper$2(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$2(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }
	function _unsupportedIterableToArray$2(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$2(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$2(o, minLen); }
	function _arrayLikeToArray$2(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
	var UsersModel = /*#__PURE__*/function (_VuexBuilderModel) {
	  babelHelpers.inherits(UsersModel, _VuexBuilderModel);
	  function UsersModel() {
	    babelHelpers.classCallCheck(this, UsersModel);
	    return babelHelpers.possibleConstructorReturn(this, babelHelpers.getPrototypeOf(UsersModel).apply(this, arguments));
	  }
	  babelHelpers.createClass(UsersModel, [{
	    key: "getName",
	    value: function getName() {
	      return 'users';
	    }
	  }, {
	    key: "getState",
	    value: function getState() {
	      this.startOnlineCheckInterval();
	      return {
	        host: this.getVariable('host', location.protocol + '//' + location.host),
	        collection: {},
	        onlineList: [],
	        mobileOnlineList: [],
	        absentList: []
	      };
	    }
	  }, {
	    key: "getElementState",
	    value: function getElementState() {
	      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	      var _params$id = params.id,
	        id = _params$id === void 0 ? 0 : _params$id,
	        _params$name = params.name,
	        name = _params$name === void 0 ? this.getVariable('default.name', '') : _params$name,
	        _params$firstName = params.firstName,
	        firstName = _params$firstName === void 0 ? this.getVariable('default.name', '') : _params$firstName,
	        _params$lastName = params.lastName,
	        lastName = _params$lastName === void 0 ? '' : _params$lastName;
	      return {
	        id: id,
	        name: name,
	        firstName: firstName,
	        lastName: lastName,
	        workPosition: "",
	        color: "#048bd0",
	        avatar: "",
	        gender: "M",
	        birthday: false,
	        isBirthday: false,
	        extranet: false,
	        network: false,
	        bot: false,
	        connector: false,
	        externalAuthId: "default",
	        status: "online",
	        idle: false,
	        lastActivityDate: false,
	        mobileLastDate: false,
	        isOnline: false,
	        isMobileOnline: false,
	        absent: false,
	        isAbsent: false,
	        departments: [],
	        phones: {
	          workPhone: "",
	          personalMobile: "",
	          personalPhone: "",
	          innerPhone: ""
	        },
	        init: false
	      };
	    }
	  }, {
	    key: "getGetters",
	    value: function getGetters() {
	      var _this = this;
	      return {
	        get: function get(state) {
	          return function (userId) {
	            var getTemporary = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
	            userId = parseInt(userId);
	            if (userId <= 0) {
	              if (getTemporary) {
	                userId = 0;
	              } else {
	                return null;
	              }
	            }
	            if (!getTemporary && (!state.collection[userId] || !state.collection[userId].init)) {
	              return null;
	            }
	            if (!state.collection[userId]) {
	              return _this.getElementState({
	                id: userId
	              });
	            }
	            return state.collection[userId];
	          };
	        },
	        getBlank: function getBlank(state) {
	          return function (params) {
	            return _this.getElementState(params);
	          };
	        },
	        getList: function getList(state) {
	          return function (userList) {
	            var result = [];
	            if (!Array.isArray(userList)) {
	              return null;
	            }
	            userList.forEach(function (id) {
	              if (state.collection[id]) {
	                result.push(state.collection[id]);
	              } else {
	                result.push(_this.getElementState({
	                  id: id
	                }));
	              }
	            });
	            return result;
	          };
	        }
	      };
	    }
	  }, {
	    key: "getActions",
	    value: function getActions() {
	      var _this2 = this;
	      return {
	        set: function set(store, payload) {
	          if (payload instanceof Array) {
	            payload = payload.map(function (user) {
	              return Object.assign({}, _this2.getElementState(), _this2.validate(Object.assign({}, user), {
	                host: store.state.host
	              }), {
	                init: true
	              });
	            });
	          } else {
	            var result = [];
	            result.push(Object.assign({}, _this2.getElementState(), _this2.validate(Object.assign({}, payload), {
	              host: store.state.host
	            }), {
	              init: true
	            }));
	            payload = result;
	          }
	          store.commit('set', payload);
	        },
	        update: function update(store, payload) {
	          payload.id = parseInt(payload.id);
	          if (typeof store.state.collection[payload.id] === 'undefined' || store.state.collection[payload.id].init === false) {
	            return true;
	          }
	          store.commit('update', {
	            id: payload.id,
	            fields: _this2.validate(Object.assign({}, payload.fields), {
	              host: store.state.host
	            })
	          });
	          return true;
	        },
	        "delete": function _delete(store, payload) {
	          store.commit('delete', payload.id);
	          return true;
	        },
	        saveState: function saveState(store, payload) {
	          store.commit('saveState', {});
	          return true;
	        }
	      };
	    }
	  }, {
	    key: "getMutations",
	    value: function getMutations() {
	      var _this3 = this;
	      return {
	        set: function set(state, payload) {
	          var _iterator = _createForOfIteratorHelper$2(payload),
	            _step;
	          try {
	            var _loop = function _loop() {
	              var element = _step.value;
	              _this3.initCollection(state, {
	                id: element.id
	              });
	              state.collection[element.id] = Object.assign(state.collection[element.id], element);
	              var status = im_lib_utils.Utils.user.getOnlineStatus(element);
	              if (status.isOnline) {
	                state.collection[element.id].isOnline = true;
	                _this3.addToOnlineList(state, element.id);
	              }
	              var mobileStatus = im_lib_utils.Utils.user.isMobileActive(element);
	              if (mobileStatus) {
	                state.collection[element.id].isMobileOnline = true;
	                _this3.addToMobileOnlineList(state, element.id);
	              }
	              if (element.birthday) {
	                var today = im_lib_utils.Utils.date.format(new Date(), "d-m");
	                if (element.birthday === today) {
	                  state.collection[element.id].isBirthday = true;
	                  var timeToNextMidnight = _this3.getTimeToNextMidnight();
	                  setTimeout(function () {
	                    state.collection[element.id].isBirthday = false;
	                  }, timeToNextMidnight);
	                }
	              }
	              if (element.absent) {
	                element.isAbsent = true;
	                if (!state.absentList.includes(element.id)) {
	                  _this3.addToAbsentList(state, element.id);
	                  var _timeToNextMidnight = _this3.getTimeToNextMidnight();
	                  var timeToNextDay = 1000 * 60 * 60 * 24;
	                  setTimeout(function () {
	                    setInterval(function () {
	                      return _this3.startAbsentCheckInterval(state);
	                    }, timeToNextDay);
	                  }, _timeToNextMidnight);
	                }
	              }
	              _this3.saveState(state);
	            };
	            for (_iterator.s(); !(_step = _iterator.n()).done;) {
	              _loop();
	            }
	          } catch (err) {
	            _iterator.e(err);
	          } finally {
	            _iterator.f();
	          }
	        },
	        update: function update(state, payload) {
	          _this3.initCollection(state, payload);
	          if (typeof payload.fields.lastActivityDate !== 'undefined' && state.collection[payload.id].lastActivityDate) {
	            var lastActivityDate = state.collection[payload.id].lastActivityDate.getTime();
	            var newActivityDate = payload.fields.lastActivityDate.getTime();
	            if (newActivityDate > lastActivityDate) {
	              var status = im_lib_utils.Utils.user.getOnlineStatus(payload.fields);
	              if (status.isOnline) {
	                state.collection[payload.id].isOnline = true;
	                _this3.addToOnlineList(state, payload.fields.id);
	              }
	            }
	          }
	          if (typeof payload.fields.mobileLastDate !== 'undefined' && state.collection[payload.id].mobileLastDate !== payload.fields.mobileLastDate) {
	            var mobileStatus = im_lib_utils.Utils.user.isMobileActive(payload.fields);
	            if (mobileStatus) {
	              state.collection[payload.id].isMobileOnline = true;
	              _this3.addToMobileOnlineList(state, payload.fields.id);
	            }
	          }
	          state.collection[payload.id] = Object.assign(state.collection[payload.id], payload.fields);
	          _this3.saveState(state);
	        },
	        "delete": function _delete(state, payload) {
	          delete state.collection[payload.id];
	          _this3.saveState(state);
	        },
	        saveState: function saveState(state, payload) {
	          _this3.saveState(state);
	        }
	      };
	    }
	  }, {
	    key: "initCollection",
	    value: function initCollection(state, payload) {
	      if (typeof state.collection[payload.id] !== 'undefined') {
	        return true;
	      }
	      ui_vue.WidgetVue.set(state.collection, payload.id, this.getElementState());
	      return true;
	    }
	  }, {
	    key: "getSaveUserList",
	    value: function getSaveUserList() {
	      if (!this.db) {
	        return [];
	      }
	      if (!this.store.getters['messages/getSaveUserList']) {
	        return [];
	      }
	      var list = this.store.getters['messages/getSaveUserList']();
	      if (!list) {
	        return [];
	      }
	      return list;
	    }
	  }, {
	    key: "getSaveTimeout",
	    value: function getSaveTimeout() {
	      return 250;
	    }
	  }, {
	    key: "saveState",
	    value: function saveState(state) {
	      var _this4 = this;
	      if (!this.isSaveAvailable()) {
	        return false;
	      }
	      babelHelpers.get(babelHelpers.getPrototypeOf(UsersModel.prototype), "saveState", this).call(this, function () {
	        var list = _this4.getSaveUserList();
	        if (!list) {
	          return false;
	        }
	        var storedState = {
	          collection: {}
	        };
	        var exceptionList = {
	          absent: true,
	          idle: true,
	          mobileLastDate: true,
	          lastActivityDate: true
	        };
	        for (var chatId in list) {
	          if (!list.hasOwnProperty(chatId)) {
	            continue;
	          }
	          list[chatId].forEach(function (userId) {
	            if (!state.collection[userId]) {
	              return false;
	            }
	            storedState.collection[userId] = _this4.cloneState(state.collection[userId], exceptionList);
	          });
	        }
	        return storedState;
	      });
	    }
	  }, {
	    key: "validate",
	    value: function validate(fields) {
	      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	      var result = {};
	      options.host = options.host || this.getState().host;
	      if (typeof fields.id === "number" || typeof fields.id === "string") {
	        result.id = parseInt(fields.id);
	      }
	      if (typeof fields.first_name !== "undefined") {
	        fields.firstName = im_lib_utils.Utils.text.htmlspecialcharsback(fields.first_name);
	      }
	      if (typeof fields.last_name !== "undefined") {
	        fields.lastName = im_lib_utils.Utils.text.htmlspecialcharsback(fields.last_name);
	      }
	      if (typeof fields.name === "string" || typeof fields.name === "number") {
	        fields.name = im_lib_utils.Utils.text.htmlspecialcharsback(fields.name.toString());
	        result.name = fields.name;
	      }
	      if (typeof fields.firstName === "string" || typeof fields.firstName === "number") {
	        result.firstName = im_lib_utils.Utils.text.htmlspecialcharsback(fields.firstName.toString());
	      }
	      if (typeof fields.lastName === "string" || typeof fields.lastName === "number") {
	        result.lastName = im_lib_utils.Utils.text.htmlspecialcharsback(fields.lastName.toString());
	      }
	      if (typeof fields.work_position !== "undefined") {
	        fields.workPosition = fields.work_position;
	      }
	      if (typeof fields.workPosition === "string" || typeof fields.workPosition === "number") {
	        result.workPosition = fields.workPosition.toString();
	      }
	      if (typeof fields.color === "string") {
	        result.color = fields.color;
	      }
	      if (typeof fields.avatar === 'string') {
	        var avatar;
	        if (!fields.avatar || fields.avatar.endsWith('/js/im/images/blank.gif')) {
	          avatar = '';
	        } else if (fields.avatar.startsWith('http')) {
	          avatar = fields.avatar;
	        } else {
	          avatar = options.host + fields.avatar;
	        }
	        if (avatar) {
	          result.avatar = encodeURI(avatar);
	        }
	      }
	      if (typeof fields.gender !== 'undefined') {
	        result.gender = fields.gender === 'F' ? 'F' : 'M';
	      }
	      if (typeof fields.birthday === "string") {
	        result.birthday = fields.birthday;
	      }
	      if (typeof fields.extranet === "boolean") {
	        result.extranet = fields.extranet;
	      }
	      if (typeof fields.network === "boolean") {
	        result.network = fields.network;
	      }
	      if (typeof fields.bot === "boolean") {
	        result.bot = fields.bot;
	      }
	      if (typeof fields.connector === "boolean") {
	        result.connector = fields.connector;
	      }
	      if (typeof fields.external_auth_id !== "undefined") {
	        fields.externalAuthId = fields.external_auth_id;
	      }
	      if (typeof fields.externalAuthId === "string" && fields.externalAuthId) {
	        result.externalAuthId = fields.externalAuthId;
	      }
	      if (typeof fields.status === "string") {
	        result.status = fields.status;
	      }
	      if (typeof fields.idle !== "undefined") {
	        result.idle = im_lib_utils.Utils.date.cast(fields.idle, false);
	      }
	      if (typeof fields.last_activity_date !== "undefined") {
	        fields.lastActivityDate = fields.last_activity_date;
	      }
	      if (typeof fields.lastActivityDate !== "undefined") {
	        result.lastActivityDate = im_lib_utils.Utils.date.cast(fields.lastActivityDate, false);
	      }
	      if (typeof fields.mobile_last_date !== "undefined") {
	        fields.mobileLastDate = fields.mobile_last_date;
	      }
	      if (typeof fields.mobileLastDate !== "undefined") {
	        result.mobileLastDate = im_lib_utils.Utils.date.cast(fields.mobileLastDate, false);
	      }
	      if (typeof fields.absent !== "undefined") {
	        result.absent = im_lib_utils.Utils.date.cast(fields.absent, false);
	      }
	      if (typeof fields.departments !== 'undefined') {
	        result.departments = [];
	        if (fields.departments instanceof Array) {
	          fields.departments.forEach(function (departmentId) {
	            departmentId = parseInt(departmentId);
	            if (departmentId > 0) {
	              result.departments.push(departmentId);
	            }
	          });
	        }
	      }
	      if (babelHelpers["typeof"](fields.phones) === 'object' && fields.phones) {
	        result.phones = {};
	        if (typeof fields.phones.work_phone !== "undefined") {
	          fields.phones.workPhone = fields.phones.work_phone;
	        }
	        if (typeof fields.phones.workPhone === 'string' || typeof fields.phones.workPhone === 'number') {
	          result.phones.workPhone = fields.phones.workPhone.toString();
	        }
	        if (typeof fields.phones.personal_mobile !== "undefined") {
	          fields.phones.personalMobile = fields.phones.personal_mobile;
	        }
	        if (typeof fields.phones.personalMobile === 'string' || typeof fields.phones.personalMobile === 'number') {
	          result.phones.personalMobile = fields.phones.personalMobile.toString();
	        }
	        if (typeof fields.phones.personal_phone !== "undefined") {
	          fields.phones.personalPhone = fields.phones.personal_phone;
	        }
	        if (typeof fields.phones.personalPhone === 'string' || typeof fields.phones.personalPhone === 'number') {
	          result.phones.personalPhone = fields.phones.personalPhone.toString();
	        }
	        if (typeof fields.phones.inner_phone !== "undefined") {
	          fields.phones.innerPhone = fields.phones.inner_phone;
	        }
	        if (typeof fields.phones.innerPhone === 'string' || typeof fields.phones.innerPhone === 'number') {
	          result.phones.innerPhone = fields.phones.innerPhone.toString();
	        }
	      }
	      return result;
	    }
	  }, {
	    key: "addToOnlineList",
	    value: function addToOnlineList(state, id) {
	      if (!state.onlineList.includes(id)) {
	        state.onlineList.push(id);
	      }
	    }
	  }, {
	    key: "addToMobileOnlineList",
	    value: function addToMobileOnlineList(state, id) {
	      if (!state.mobileOnlineList.includes(id)) {
	        state.mobileOnlineList.push(id);
	      }
	    }
	  }, {
	    key: "addToAbsentList",
	    value: function addToAbsentList(state, id) {
	      if (!state.absentList.includes(id)) {
	        state.absentList.push(id);
	      }
	    }
	  }, {
	    key: "getTimeToNextMidnight",
	    value: function getTimeToNextMidnight() {
	      var nextMidnight = new Date(new Date().setHours(24, 0, 0)).getTime();
	      return nextMidnight - new Date();
	    }
	  }, {
	    key: "startAbsentCheckInterval",
	    value: function startAbsentCheckInterval(state) {
	      var _iterator2 = _createForOfIteratorHelper$2(state.absentList),
	        _step2;
	      try {
	        var _loop2 = function _loop2() {
	          var userId = _step2.value;
	          var user = state.collection[userId];
	          if (!user) {
	            return "continue";
	          }
	          var currentTime = new Date().getTime();
	          var absentEnd = new Date(state.collection[userId].absent).getTime();
	          if (absentEnd <= currentTime) {
	            state.absentList = state.absentList.filter(function (element) {
	              return element !== userId;
	            });
	            user.isAbsent = false;
	          }
	        };
	        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
	          var _ret = _loop2();
	          if (_ret === "continue") continue;
	        }
	      } catch (err) {
	        _iterator2.e(err);
	      } finally {
	        _iterator2.f();
	      }
	    }
	  }, {
	    key: "startOnlineCheckInterval",
	    value: function startOnlineCheckInterval() {
	      var _this5 = this;
	      var intervalTime = 60000;
	      setInterval(function () {
	        var _iterator3 = _createForOfIteratorHelper$2(_this5.store.state.users.onlineList),
	          _step3;
	        try {
	          var _loop3 = function _loop3() {
	            var userId = _step3.value;
	            var user = _this5.store.state.users.collection[userId];
	            if (!user) {
	              return "continue";
	            }
	            var status = im_lib_utils.Utils.user.getOnlineStatus(user);
	            if (status.isOnline) {
	              user.isOnline = true;
	            } else {
	              user.isOnline = false;
	              _this5.store.state.users.onlineList = _this5.store.state.users.onlineList.filter(function (element) {
	                return element !== userId;
	              });
	            }
	          };
	          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
	            var _ret2 = _loop3();
	            if (_ret2 === "continue") continue;
	          }
	        } catch (err) {
	          _iterator3.e(err);
	        } finally {
	          _iterator3.f();
	        }
	        var _iterator4 = _createForOfIteratorHelper$2(_this5.store.state.users.mobileOnlineList),
	          _step4;
	        try {
	          var _loop4 = function _loop4() {
	            var userId = _step4.value;
	            var user = _this5.store.state.users.collection[userId];
	            if (!user) {
	              return "continue";
	            }
	            var mobileStatus = im_lib_utils.Utils.user.isMobileActive(user);
	            if (mobileStatus) {
	              user.isMobileOnline = true;
	            } else {
	              user.isMobileOnline = false;
	              _this5.store.state.users.mobileOnlineList = _this5.store.state.users.mobileOnlineList.filter(function (element) {
	                return element !== userId;
	              });
	            }
	          };
	          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
	            var _ret3 = _loop4();
	            if (_ret3 === "continue") continue;
	          }
	        } catch (err) {
	          _iterator4.e(err);
	        } finally {
	          _iterator4.f();
	        }
	      }, intervalTime);
	    }
	  }]);
	  return UsersModel;
	}(ui_vue_vuex.WidgetVuexBuilderModel);

	function _createForOfIteratorHelper$3(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$3(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }
	function _unsupportedIterableToArray$3(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$3(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$3(o, minLen); }
	function _arrayLikeToArray$3(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
	var FilesModel = /*#__PURE__*/function (_VuexBuilderModel) {
	  babelHelpers.inherits(FilesModel, _VuexBuilderModel);
	  function FilesModel() {
	    babelHelpers.classCallCheck(this, FilesModel);
	    return babelHelpers.possibleConstructorReturn(this, babelHelpers.getPrototypeOf(FilesModel).apply(this, arguments));
	  }
	  babelHelpers.createClass(FilesModel, [{
	    key: "getName",
	    value: function getName() {
	      return 'files';
	    }
	  }, {
	    key: "getState",
	    value: function getState() {
	      return {
	        created: 0,
	        host: this.getVariable('host', location.protocol + '//' + location.host),
	        collection: {},
	        index: {}
	      };
	    }
	  }, {
	    key: "getElementState",
	    value: function getElementState() {
	      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	      var _params$id = params.id,
	        id = _params$id === void 0 ? 0 : _params$id,
	        _params$chatId = params.chatId,
	        chatId = _params$chatId === void 0 ? 0 : _params$chatId,
	        _params$name = params.name,
	        name = _params$name === void 0 ? this.getVariable('default.name', '') : _params$name;
	      return {
	        id: id,
	        chatId: chatId,
	        name: name,
	        templateId: id,
	        date: new Date(),
	        type: 'file',
	        extension: "",
	        icon: "empty",
	        size: 0,
	        image: false,
	        status: im_const.FileStatus.done,
	        progress: 100,
	        authorId: 0,
	        authorName: "",
	        urlPreview: "",
	        urlShow: "",
	        urlDownload: "",
	        init: false,
	        viewerAttrs: {}
	      };
	    }
	  }, {
	    key: "getGetters",
	    value: function getGetters() {
	      var _this = this;
	      return {
	        get: function get(state) {
	          return function (chatId, fileId) {
	            var getTemporary = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
	            if (!chatId || !fileId) {
	              return null;
	            }
	            if (!state.index[chatId] || !state.index[chatId][fileId]) {
	              return null;
	            }
	            if (!getTemporary && !state.index[chatId][fileId].init) {
	              return null;
	            }
	            return state.index[chatId][fileId];
	          };
	        },
	        getList: function getList(state) {
	          return function (chatId) {
	            if (!state.index[chatId]) {
	              return null;
	            }
	            return state.index[chatId];
	          };
	        },
	        getBlank: function getBlank(state) {
	          return function (params) {
	            return _this.getElementState(params);
	          };
	        }
	      };
	    }
	  }, {
	    key: "getActions",
	    value: function getActions() {
	      var _this2 = this;
	      return {
	        add: function add(store, payload) {
	          var result = _this2.validate(Object.assign({}, payload), {
	            host: store.state.host
	          });
	          if (payload.id) {
	            result.id = payload.id;
	          } else {
	            result.id = 'temporary' + new Date().getTime() + store.state.created;
	          }
	          result.templateId = result.id;
	          result.init = true;
	          store.commit('add', Object.assign({}, _this2.getElementState(), result));
	          return result.id;
	        },
	        set: function set(store, payload) {
	          if (payload instanceof Array) {
	            payload = payload.map(function (file) {
	              var result = _this2.validate(Object.assign({}, file), {
	                host: store.state.host
	              });
	              result.templateId = result.id;
	              return Object.assign({}, _this2.getElementState(), result, {
	                init: true
	              });
	            });
	          } else {
	            var result = _this2.validate(Object.assign({}, payload), {
	              host: store.state.host
	            });
	            result.templateId = result.id;
	            payload = [];
	            payload.push(Object.assign({}, _this2.getElementState(), result, {
	              init: true
	            }));
	          }
	          store.commit('set', {
	            insertType: im_const.MutationType.setAfter,
	            data: payload
	          });
	        },
	        setBefore: function setBefore(store, payload) {
	          if (payload instanceof Array) {
	            payload = payload.map(function (file) {
	              var result = _this2.validate(Object.assign({}, file), {
	                host: store.state.host
	              });
	              result.templateId = result.id;
	              return Object.assign({}, _this2.getElementState(), result, {
	                init: true
	              });
	            });
	          } else {
	            var result = _this2.validate(Object.assign({}, payload), {
	              host: store.state.host
	            });
	            result.templateId = result.id;
	            payload = [];
	            payload.push(Object.assign({}, _this2.getElementState(), result, {
	              init: true
	            }));
	          }
	          store.commit('set', {
	            actionName: 'setBefore',
	            insertType: im_const.MutationType.setBefore,
	            data: payload
	          });
	        },
	        update: function update(store, payload) {
	          var result = _this2.validate(Object.assign({}, payload.fields), {
	            host: store.state.host
	          });
	          store.commit('initCollection', {
	            chatId: payload.chatId
	          });
	          var index = store.state.collection[payload.chatId].findIndex(function (el) {
	            return el.id === payload.id;
	          });
	          if (index < 0) {
	            return false;
	          }
	          store.commit('update', {
	            id: payload.id,
	            chatId: payload.chatId,
	            index: index,
	            fields: result
	          });
	          if (payload.fields.blink) {
	            setTimeout(function () {
	              store.commit('update', {
	                id: payload.id,
	                chatId: payload.chatId,
	                fields: {
	                  blink: false
	                }
	              });
	            }, 1000);
	          }
	          return true;
	        },
	        "delete": function _delete(store, payload) {
	          store.commit('delete', {
	            id: payload.id,
	            chatId: payload.chatId
	          });
	          return true;
	        },
	        saveState: function saveState(store, payload) {
	          store.commit('saveState', {});
	          return true;
	        }
	      };
	    }
	  }, {
	    key: "getMutations",
	    value: function getMutations() {
	      var _this3 = this;
	      return {
	        initCollection: function initCollection(state, payload) {
	          _this3.initCollection(state, payload);
	        },
	        add: function add(state, payload) {
	          _this3.initCollection(state, payload);
	          state.collection[payload.chatId].push(payload);
	          state.index[payload.chatId][payload.id] = payload;
	          state.created += 1;
	          _this3.saveState(state);
	        },
	        set: function set(state, payload) {
	          var _iterator = _createForOfIteratorHelper$3(payload.data),
	            _step;
	          try {
	            var _loop = function _loop() {
	              var element = _step.value;
	              _this3.initCollection(state, {
	                chatId: element.chatId
	              });
	              var index = state.collection[element.chatId].findIndex(function (el) {
	                return el.id === element.id;
	              });
	              if (index > -1) {
	                delete element.templateId;
	                state.collection[element.chatId][index] = Object.assign(state.collection[element.chatId][index], element);
	              } else if (payload.insertType === im_const.MutationType.setBefore) {
	                state.collection[element.chatId].unshift(element);
	              } else {
	                state.collection[element.chatId].push(element);
	              }
	              state.index[element.chatId][element.id] = element;
	              _this3.saveState(state);
	            };
	            for (_iterator.s(); !(_step = _iterator.n()).done;) {
	              _loop();
	            }
	          } catch (err) {
	            _iterator.e(err);
	          } finally {
	            _iterator.f();
	          }
	        },
	        update: function update(state, payload) {
	          _this3.initCollection(state, payload);
	          var index = -1;
	          if (typeof payload.index !== 'undefined' && state.collection[payload.chatId][payload.index]) {
	            index = payload.index;
	          } else {
	            index = state.collection[payload.chatId].findIndex(function (el) {
	              return el.id === payload.id;
	            });
	          }
	          if (index >= 0) {
	            delete payload.fields.templateId;
	            var element = Object.assign(state.collection[payload.chatId][index], payload.fields);
	            state.collection[payload.chatId][index] = element;
	            state.index[payload.chatId][element.id] = element;
	            _this3.saveState(state);
	          }
	        },
	        "delete": function _delete(state, payload) {
	          _this3.initCollection(state, payload);
	          state.collection[payload.chatId] = state.collection[payload.chatId].filter(function (element) {
	            return element.id !== payload.id;
	          });
	          delete state.index[payload.chatId][payload.id];
	          _this3.saveState(state);
	        },
	        saveState: function saveState(state, payload) {
	          _this3.saveState(state);
	        }
	      };
	    }
	  }, {
	    key: "initCollection",
	    value: function initCollection(state, payload) {
	      if (typeof state.collection[payload.chatId] !== 'undefined') {
	        return true;
	      }
	      ui_vue.WidgetVue.set(state.collection, payload.chatId, []);
	      ui_vue.WidgetVue.set(state.index, payload.chatId, {});
	      return true;
	    }
	  }, {
	    key: "getLoadedState",
	    value: function getLoadedState(state) {
	      if (!state || babelHelpers["typeof"](state) !== 'object') {
	        return state;
	      }
	      if (babelHelpers["typeof"](state.collection) !== 'object') {
	        return state;
	      }
	      state.index = {};
	      var _loop2 = function _loop2(chatId) {
	        if (!state.collection.hasOwnProperty(chatId)) {
	          return "continue";
	        }
	        state.index[chatId] = {};
	        state.collection[chatId].filter(function (file) {
	          return file != null;
	        }).forEach(function (file) {
	          state.index[chatId][file.id] = file;
	        });
	      };
	      for (var chatId in state.collection) {
	        var _ret = _loop2(chatId);
	        if (_ret === "continue") continue;
	      }
	      return state;
	    }
	  }, {
	    key: "getSaveFileList",
	    value: function getSaveFileList() {
	      if (!this.db) {
	        return [];
	      }
	      if (!this.store.getters['messages/getSaveFileList']) {
	        return [];
	      }
	      var list = this.store.getters['messages/getSaveFileList']();
	      if (!list) {
	        return [];
	      }
	      return list;
	    }
	  }, {
	    key: "getSaveTimeout",
	    value: function getSaveTimeout() {
	      return 250;
	    }
	  }, {
	    key: "saveState",
	    value: function saveState(state) {
	      var _this4 = this;
	      if (!this.isSaveAvailable()) {
	        return false;
	      }
	      babelHelpers.get(babelHelpers.getPrototypeOf(FilesModel.prototype), "saveState", this).call(this, function () {
	        var list = _this4.getSaveFileList();
	        if (!list) {
	          return false;
	        }
	        var storedState = {
	          collection: {}
	        };
	        var _loop3 = function _loop3(chatId) {
	          if (!list.hasOwnProperty(chatId)) {
	            return "continue";
	          }
	          list[chatId].forEach(function (fileId) {
	            if (!state.index[chatId]) {
	              return false;
	            }
	            if (!state.index[chatId][fileId]) {
	              return false;
	            }
	            if (!storedState.collection[chatId]) {
	              storedState.collection[chatId] = [];
	            }
	            storedState.collection[chatId].push(state.index[chatId][fileId]);
	          });
	        };
	        for (var chatId in list) {
	          var _ret2 = _loop3(chatId);
	          if (_ret2 === "continue") continue;
	        }
	        return storedState;
	      });
	    }
	  }, {
	    key: "validate",
	    value: function validate(fields) {
	      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	      var result = {};
	      options.host = options.host || this.getState().host;
	      if (typeof fields.id === "number") {
	        result.id = fields.id;
	      } else if (typeof fields.id === "string") {
	        if (fields.id.startsWith('temporary')) {
	          result.id = fields.id;
	        } else {
	          result.id = parseInt(fields.id);
	        }
	      }
	      if (typeof fields.templateId === "number") {
	        result.templateId = fields.templateId;
	      } else if (typeof fields.templateId === "string") {
	        if (fields.templateId.startsWith('temporary')) {
	          result.templateId = fields.templateId;
	        } else {
	          result.templateId = parseInt(fields.templateId);
	        }
	      }
	      if (typeof fields.chatId === "number" || typeof fields.chatId === "string") {
	        result.chatId = parseInt(fields.chatId);
	      }
	      if (typeof fields.date !== "undefined") {
	        result.date = im_lib_utils.Utils.date.cast(fields.date);
	      }
	      if (typeof fields.type === "string") {
	        result.type = fields.type;
	      }
	      if (typeof fields.extension === "string") {
	        result.extension = fields.extension.toString();
	        if (result.type === 'image') {
	          result.icon = 'img';
	        } else if (result.type === 'video') {
	          result.icon = 'mov';
	        } else {
	          result.icon = FilesModel.getIconType(result.extension);
	        }
	      }
	      if (typeof fields.name === "string" || typeof fields.name === "number") {
	        result.name = fields.name.toString();
	      }
	      if (typeof fields.size === "number" || typeof fields.size === "string") {
	        result.size = parseInt(fields.size);
	      }
	      if (typeof fields.image === 'boolean') {
	        result.image = false;
	      } else if (babelHelpers["typeof"](fields.image) === 'object' && fields.image) {
	        result.image = {
	          width: 0,
	          height: 0
	        };
	        if (typeof fields.image.width === "string" || typeof fields.image.width === "number") {
	          result.image.width = parseInt(fields.image.width);
	        }
	        if (typeof fields.image.height === "string" || typeof fields.image.height === "number") {
	          result.image.height = parseInt(fields.image.height);
	        }
	        if (result.image.width <= 0 || result.image.height <= 0) {
	          result.image = false;
	        }
	      }
	      if (typeof fields.status === "string" && typeof im_const.FileStatus[fields.status] !== 'undefined') {
	        result.status = fields.status;
	      }
	      if (typeof fields.progress === "number" || typeof fields.progress === "string") {
	        result.progress = parseInt(fields.progress);
	      }
	      if (typeof fields.authorId === "number" || typeof fields.authorId === "string") {
	        result.authorId = parseInt(fields.authorId);
	      }
	      if (typeof fields.authorName === "string" || typeof fields.authorName === "number") {
	        result.authorName = fields.authorName.toString();
	      }
	      if (typeof fields.urlPreview === 'string') {
	        if (!fields.urlPreview || fields.urlPreview.startsWith('http') || fields.urlPreview.startsWith('bx') || fields.urlPreview.startsWith('file') || fields.urlPreview.startsWith('blob')) {
	          result.urlPreview = fields.urlPreview;
	        } else {
	          result.urlPreview = options.host + fields.urlPreview;
	        }
	      }
	      if (typeof fields.urlDownload === 'string') {
	        if (!fields.urlDownload || fields.urlDownload.startsWith('http') || fields.urlDownload.startsWith('bx') || fields.urlPreview.startsWith('file')) {
	          result.urlDownload = fields.urlDownload;
	        } else {
	          result.urlDownload = options.host + fields.urlDownload;
	        }
	      }
	      if (typeof fields.urlShow === 'string') {
	        if (!fields.urlShow || fields.urlShow.startsWith('http') || fields.urlShow.startsWith('bx') || fields.urlShow.startsWith('file')) {
	          result.urlShow = fields.urlShow;
	        } else {
	          result.urlShow = options.host + fields.urlShow;
	        }
	      }
	      if (babelHelpers["typeof"](fields.viewerAttrs) === 'object') {
	        if (result.type === 'image' && !im_lib_utils.Utils.platform.isBitrixMobile()) {
	          result.viewerAttrs = fields.viewerAttrs;
	        }
	        if (result.type === 'video' && !im_lib_utils.Utils.platform.isBitrixMobile() && result.size > FilesModel.maxDiskFileSize) {
	          result.viewerAttrs = fields.viewerAttrs;
	        }
	      }
	      return result;
	    }
	  }], [{
	    key: "getType",
	    value: function getType(type) {
	      type = type.toString().toLowerCase().split('.').splice(-1)[0];
	      switch (type) {
	        case 'png':
	        case 'jpe':
	        case 'jpg':
	        case 'jpeg':
	        case 'gif':
	        case 'heic':
	        case 'bmp':
	        case 'webp':
	          return im_const.FileType.image;
	        case 'mp4':
	        case 'mkv':
	        case 'webm':
	        case 'mpeg':
	        case 'hevc':
	        case 'avi':
	        case '3gp':
	        case 'flv':
	        case 'm4v':
	        case 'ogg':
	        case 'wmv':
	        case 'mov':
	          return im_const.FileType.video;
	        case 'mp3':
	          return im_const.FileType.audio;
	      }
	      return im_const.FileType.file;
	    }
	  }, {
	    key: "getIconType",
	    value: function getIconType(extension) {
	      var icon = 'empty';
	      switch (extension.toString()) {
	        case 'png':
	        case 'jpe':
	        case 'jpg':
	        case 'jpeg':
	        case 'gif':
	        case 'heic':
	        case 'bmp':
	        case 'webp':
	          icon = 'img';
	          break;
	        case 'mp4':
	        case 'mkv':
	        case 'webm':
	        case 'mpeg':
	        case 'hevc':
	        case 'avi':
	        case '3gp':
	        case 'flv':
	        case 'm4v':
	        case 'ogg':
	        case 'wmv':
	        case 'mov':
	          icon = 'mov';
	          break;
	        case 'txt':
	          icon = 'txt';
	          break;
	        case 'doc':
	        case 'docx':
	          icon = 'doc';
	          break;
	        case 'xls':
	        case 'xlsx':
	          icon = 'xls';
	          break;
	        case 'php':
	          icon = 'php';
	          break;
	        case 'pdf':
	          icon = 'pdf';
	          break;
	        case 'ppt':
	        case 'pptx':
	          icon = 'ppt';
	          break;
	        case 'rar':
	          icon = 'rar';
	          break;
	        case 'zip':
	        case '7z':
	        case 'tar':
	        case 'gz':
	        case 'gzip':
	          icon = 'zip';
	          break;
	        case 'set':
	          icon = 'set';
	          break;
	        case 'conf':
	        case 'ini':
	        case 'plist':
	          icon = 'set';
	          break;
	      }
	      return icon;
	    }
	  }]);
	  return FilesModel;
	}(ui_vue_vuex.WidgetVuexBuilderModel);
	babelHelpers.defineProperty(FilesModel, "maxDiskFileSize", 5242880);

	/**
	 * Bitrix Messenger
	 * Recent model (Vuex Builder model)
	 *
	 * @package bitrix
	 * @subpackage im
	 * @copyright 2001-2020 Bitrix
	 */
	var RecentModel = /*#__PURE__*/function (_VuexBuilderModel) {
	  babelHelpers.inherits(RecentModel, _VuexBuilderModel);
	  function RecentModel() {
	    babelHelpers.classCallCheck(this, RecentModel);
	    return babelHelpers.possibleConstructorReturn(this, babelHelpers.getPrototypeOf(RecentModel).apply(this, arguments));
	  }
	  babelHelpers.createClass(RecentModel, [{
	    key: "getName",
	    value: function getName() {
	      return 'recent';
	    }
	  }, {
	    key: "getState",
	    value: function getState() {
	      return {
	        host: this.getVariable('host', location.protocol + '//' + location.host),
	        collection: []
	      };
	    }
	  }, {
	    key: "getElementState",
	    value: function getElementState() {
	      return {
	        id: 0,
	        templateId: '',
	        template: im_const.TemplateTypes.item,
	        chatType: im_const.ChatTypes.chat,
	        sectionCode: im_const.RecentSection.general,
	        avatar: '',
	        color: '#048bd0',
	        title: '',
	        lines: {
	          id: 0,
	          status: 0
	        },
	        message: {
	          id: 0,
	          text: '',
	          date: new Date(),
	          senderId: 0,
	          status: im_const.MessageStatus.received
	        },
	        counter: 0,
	        pinned: false,
	        chatId: 0,
	        userId: 0
	      };
	    }
	  }, {
	    key: "getGetters",
	    value: function getGetters() {
	      var _this = this;
	      return {
	        get: function get(state) {
	          return function (dialogId) {
	            if (main_core.Type.isNumber(dialogId)) {
	              dialogId = dialogId.toString();
	            }
	            var currentItem = _this.findItem(dialogId);
	            if (currentItem) {
	              return currentItem;
	            }
	            return false;
	          };
	        }
	      };
	    }
	  }, {
	    key: "getActions",
	    value: function getActions() {
	      var _this2 = this;
	      return {
	        set: function set(store, payload) {
	          var result = [];
	          if (payload instanceof Array) {
	            result = payload.map(function (recentItem) {
	              return _this2.prepareItem(recentItem, {
	                host: store.state.host
	              });
	            });
	          }
	          if (result.length === 0) {
	            return false;
	          }
	          result.forEach(function (element) {
	            var existingItem = _this2.findItem(element.id);
	            if (existingItem) {
	              store.commit('update', {
	                index: existingItem.index,
	                fields: element
	              });
	            } else {
	              store.commit('add', {
	                fields: element
	              });
	            }
	          });
	          store.state.collection.sort(_this2.sortListByMessageDate);
	        },
	        addPlaceholders: function addPlaceholders(store, payload) {
	          payload.forEach(function (element) {
	            store.commit('addPlaceholder', {
	              fields: element
	            });
	          });
	        },
	        updatePlaceholders: function updatePlaceholders(store, payload) {
	          payload.items = payload.items.map(function (element) {
	            return _this2.prepareItem(element);
	          });
	          payload.items.forEach(function (element, index) {
	            var placeholderId = 'placeholder' + (payload.firstMessage + index);
	            var existingPlaceholder = _this2.findItem(placeholderId, 'templateId');
	            var existingItem = _this2.findItem(element.id);
	            if (existingItem) {
	              store.commit('update', {
	                index: existingItem.index,
	                fields: element
	              });
	              store.commit('delete', {
	                index: existingPlaceholder.index
	              });
	            } else {
	              store.commit('update', {
	                index: existingPlaceholder.index,
	                fields: element
	              });
	            }
	          });
	        },
	        update: function update(store, payload) {
	          if (typeof payload.id === 'string' && !payload.id.startsWith('chat') && payload.id !== 'notify') {
	            payload.id = parseInt(payload.id);
	          }
	          var existingItem = _this2.findItem(payload.id);
	          if (!existingItem) {
	            return false;
	          }
	          payload.fields = _this2.validate(Object.assign({}, payload.fields));
	          store.commit('update', {
	            index: existingItem.index,
	            fields: payload.fields
	          });
	          store.state.collection.sort(_this2.sortListByMessageDate);
	        },
	        pin: function pin(store, payload) {
	          if (typeof payload.id === 'string' && !payload.id.startsWith('chat') && payload.id !== 'notify') {
	            payload.id = parseInt(payload.id);
	          }
	          var existingItem = _this2.findItem(payload.id);
	          if (!existingItem) {
	            return false;
	          }
	          store.commit('update', {
	            index: existingItem.index,
	            fields: Object.assign({}, existingItem.element, {
	              pinned: payload.action
	            })
	          });
	          store.state.collection.sort(_this2.sortListByMessageDate);
	        },
	        clearPlaceholders: function clearPlaceholders(store) {
	          store.commit('clearPlaceholders');
	        },
	        "delete": function _delete(store, payload) {
	          if (typeof payload.id === 'string' && !payload.id.startsWith('chat') && payload.id !== 'notify') {
	            payload.id = parseInt(payload.id);
	          }
	          var existingItem = _this2.findItem(payload.id);
	          if (!existingItem) {
	            return false;
	          }
	          store.commit('delete', {
	            index: existingItem.index
	          });
	          store.state.collection.sort(_this2.sortListByMessageDate);
	        }
	      };
	    }
	  }, {
	    key: "getMutations",
	    value: function getMutations() {
	      var _this3 = this;
	      return {
	        add: function add(state, payload) {
	          state.collection.push(Object.assign({}, _this3.getElementState(), payload.fields));
	        },
	        update: function update(state, payload) {
	          state.collection.splice(payload.index, 1, Object.assign({}, state.collection[payload.index], payload.fields));
	        },
	        "delete": function _delete(state, payload) {
	          state.collection.splice(payload.index, 1);
	        },
	        addPlaceholder: function addPlaceholder(state, payload) {
	          state.collection.push(Object.assign({}, _this3.getElementState(), payload.fields));
	        },
	        clearPlaceholders: function clearPlaceholders(state) {
	          state.collection = state.collection.filter(function (element) {
	            return !element.id.toString().startsWith('placeholder');
	          });
	        }
	      };
	    }
	  }, {
	    key: "validate",
	    value: function validate(fields) {
	      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	      var result = {};
	      if (main_core.Type.isNumber(fields.id)) {
	        result.id = fields.id.toString();
	      }
	      if (main_core.Type.isStringFilled(fields.id)) {
	        result.id = fields.id;
	      }
	      if (main_core.Type.isString(fields.templateId)) {
	        result.templateId = fields.templateId;
	      }
	      if (main_core.Type.isString(fields.template)) {
	        result.template = fields.template;
	      }
	      if (main_core.Type.isString(fields.type)) {
	        if (fields.type === im_const.ChatTypes.chat) {
	          if (fields.chat.type === im_const.ChatTypes.open) {
	            result.chatType = im_const.ChatTypes.open;
	          } else if (fields.chat.type === im_const.ChatTypes.chat) {
	            result.chatType = im_const.ChatTypes.chat;
	          }
	        } else if (fields.type === im_const.ChatTypes.user) {
	          result.chatType = im_const.ChatTypes.user;
	        } else if (fields.type === im_const.ChatTypes.notification) {
	          result.chatType = im_const.ChatTypes.notification;
	          fields.title = 'Notifications';
	        } else {
	          result.chatType = im_const.ChatTypes.chat;
	        }
	      }
	      if (main_core.Type.isString(fields.avatar)) {
	        var avatar;
	        if (!fields.avatar || fields.avatar.endsWith('/js/im/images/blank.gif')) {
	          avatar = '';
	        } else if (fields.avatar.startsWith('http')) {
	          avatar = fields.avatar;
	        } else {
	          avatar = options.host + fields.avatar;
	        }
	        if (avatar) {
	          result.avatar = encodeURI(avatar);
	        }
	      }
	      if (main_core.Type.isString(fields.color)) {
	        result.color = fields.color;
	      }
	      if (main_core.Type.isString(fields.title)) {
	        result.title = fields.title;
	      }
	      if (main_core.Type.isPlainObject(fields.message)) {
	        var message = {};
	        if (main_core.Type.isNumber(fields.message.id)) {
	          message.id = fields.message.id;
	        }
	        if (main_core.Type.isString(fields.message.text)) {
	          var _options = {};
	          if (fields.message.withAttach) {
	            _options.WITH_ATTACH = true;
	          } else if (fields.message.withFile) {
	            _options.WITH_FILE = true;
	          }
	          message.text = im_lib_utils.Utils.text.purify(fields.message.text, _options);
	        }
	        if (main_core.Type.isDate(fields.message.date) || main_core.Type.isString(fields.message.date)) {
	          message.date = fields.message.date;
	        }
	        if (main_core.Type.isNumber(fields.message.author_id)) {
	          message.senderId = fields.message.author_id;
	        }
	        if (main_core.Type.isNumber(fields.message.senderId)) {
	          message.senderId = fields.message.senderId;
	        }
	        if (main_core.Type.isStringFilled(fields.message.status)) {
	          message.status = fields.message.status;
	        }
	        result.message = message;
	      }
	      if (main_core.Type.isNumber(fields.counter)) {
	        result.counter = fields.counter;
	      }
	      if (main_core.Type.isBoolean(fields.pinned)) {
	        result.pinned = fields.pinned;
	      }
	      if (main_core.Type.isNumber(fields.chatId)) {
	        result.chatId = fields.chatId;
	      }
	      if (main_core.Type.isNumber(fields.userId)) {
	        result.userId = fields.userId;
	      }
	      return result;
	    }
	  }, {
	    key: "sortListByMessageDate",
	    value: function sortListByMessageDate(a, b) {
	      if (a.message && b.message) {
	        var timestampA = new Date(a.message.date).getTime();
	        var timestampB = new Date(b.message.date).getTime();
	        return timestampB - timestampA;
	      }
	    }
	  }, {
	    key: "prepareItem",
	    value: function prepareItem(item) {
	      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	      var result = this.validate(Object.assign({}, item));
	      return Object.assign({}, this.getElementState(), result, options);
	    }
	  }, {
	    key: "findItem",
	    value: function findItem(value) {
	      var key = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'id';
	      var result = {};
	      if (key === 'id' && main_core.Type.isNumber(value)) {
	        value = value.toString();
	      }
	      var elementIndex = this.store.state.recent.collection.findIndex(function (element, index) {
	        return element[key] === value;
	      });
	      if (elementIndex !== -1) {
	        result.index = elementIndex;
	        result.element = this.store.state.recent.collection[elementIndex];
	        return result;
	      }
	      return false;
	    }
	  }]);
	  return RecentModel;
	}(ui_vue_vuex.WidgetVuexBuilderModel);

	//raw input object for validation

	function _createForOfIteratorHelper$4(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$4(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }
	function _unsupportedIterableToArray$4(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$4(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$4(o, minLen); }
	function _arrayLikeToArray$4(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
	var NotificationsModel = /*#__PURE__*/function (_VuexBuilderModel) {
	  babelHelpers.inherits(NotificationsModel, _VuexBuilderModel);
	  function NotificationsModel() {
	    babelHelpers.classCallCheck(this, NotificationsModel);
	    return babelHelpers.possibleConstructorReturn(this, babelHelpers.getPrototypeOf(NotificationsModel).apply(this, arguments));
	  }
	  babelHelpers.createClass(NotificationsModel, [{
	    key: "getName",
	    value: function getName() {
	      return 'notifications';
	    }
	  }, {
	    key: "getState",
	    value: function getState() {
	      return {
	        collection: [],
	        searchCollection: [],
	        chat_id: 0,
	        total: 0,
	        host: this.getVariable('host', location.protocol + '//' + location.host),
	        unreadCounter: 0,
	        schema: {}
	      };
	    }
	  }, {
	    key: "getElementState",
	    value: function getElementState() {
	      return {
	        id: 0,
	        authorId: 0,
	        date: new Date(),
	        text: '',
	        sectionCode: im_const.NotificationTypesCodes.simple,
	        textConverted: '',
	        title: '',
	        unread: false,
	        display: true,
	        settingName: 'im|default'
	      };
	    }
	  }, {
	    key: "getGetters",
	    value: function getGetters() {
	      var _this = this;
	      return {
	        get: function get(state) {
	          return function () {
	            return state.collection;
	          };
	        },
	        getById: function getById(state) {
	          return function (notificationId) {
	            if (main_core.Type.isString(notificationId)) {
	              notificationId = parseInt(notificationId);
	            }
	            var existingItem = _this.findItemInArr(state.collection, notificationId);
	            if (!existingItem.element) {
	              return false;
	            }
	            return existingItem.element;
	          };
	        },
	        getSearchItemById: function getSearchItemById(state) {
	          return function (notificationId) {
	            if (main_core.Type.isString(notificationId)) {
	              notificationId = parseInt(notificationId);
	            }
	            var existingItem = _this.findItemInArr(state.searchCollection, notificationId);
	            if (!existingItem.element) {
	              return false;
	            }
	            return existingItem.element;
	          };
	        },
	        getBlank: function getBlank(state) {
	          return function (params) {
	            return _this.getElementState();
	          };
	        }
	      };
	    }
	  }, {
	    key: "getActions",
	    value: function getActions() {
	      var _this2 = this;
	      return {
	        set: function set(store, payload) {
	          var result = {
	            notification: []
	          };
	          if (payload.notification instanceof Array) {
	            result.notification = payload.notification.map(function (notification) {
	              return _this2.prepareNotification(notification, {
	                host: store.state.host
	              });
	            });
	          }
	          if (main_core.Type.isNumber(payload.total) || main_core.Type.isString(payload.total)) {
	            result.total = parseInt(payload.total);
	          }
	          store.commit('set', result);
	        },
	        setSearchResults: function setSearchResults(store, payload) {
	          var result = {
	            notification: []
	          };
	          if (!(payload.notification instanceof Array)) {
	            return false;
	          }

	          // we don't need validation for the local results
	          if (payload.type === 'local') {
	            result.notification = payload.notification;
	          } else {
	            result.notification = payload.notification.map(function (notification) {
	              return _this2.prepareNotification(notification, {
	                host: store.state.host
	              });
	            });
	          }
	          store.commit('setSearchResults', {
	            data: result
	          });
	        },
	        deleteSearchResults: function deleteSearchResults(store, payload) {
	          store.commit('deleteSearchResults');
	        },
	        setCounter: function setCounter(store, payload) {
	          if (main_core.Type.isNumber(payload.unreadTotal) || main_core.Type.isString(payload.unreadTotal)) {
	            var unreadCounter = parseInt(payload.unreadTotal);
	            store.commit('setCounter', unreadCounter);
	          }
	        },
	        setTotal: function setTotal(store, payload) {
	          if (main_core.Type.isNumber(payload.total) || main_core.Type.isString(payload.total)) {
	            store.commit('setTotal', payload.total);
	          }
	        },
	        add: function add(store, payload) {
	          var addItem = _this2.prepareNotification(payload.data, {
	            host: store.state.host
	          });
	          addItem.unread = true;
	          var existingItem = _this2.findItemInArr(store.state.collection, addItem.id);
	          if (!existingItem.element) {
	            store.commit('add', {
	              data: addItem
	            });
	            store.commit('setTotal', store.state.total + 1);
	          } else {
	            store.commit('update', {
	              index: existingItem.index,
	              fields: Object.assign({}, payload.fields)
	            });
	          }
	        },
	        updatePlaceholders: function updatePlaceholders(store, payload) {
	          if (payload.items instanceof Array) {
	            payload.items = payload.items.map(function (notification) {
	              return _this2.prepareNotification(notification);
	            });
	          } else {
	            return false;
	          }
	          store.commit('updatePlaceholders', payload);
	          return true;
	        },
	        clearPlaceholders: function clearPlaceholders(store, payload) {
	          store.commit('clearPlaceholders', payload);
	        },
	        update: function update(store, payload) {
	          var existingItem = _this2.findItemInArr(store.state.collection, payload.id);
	          if (existingItem.element) {
	            store.commit('update', {
	              index: existingItem.index,
	              fields: Object.assign({}, payload.fields)
	            });
	          }
	          if (payload.searchMode) {
	            var existingItemInSearchCollection = _this2.findItemInArr(store.state.searchCollection, payload.id);
	            if (existingItemInSearchCollection.element) {
	              store.commit('update', {
	                searchCollection: true,
	                index: existingItemInSearchCollection.index,
	                fields: Object.assign({}, payload.fields)
	              });
	            }
	          }
	        },
	        read: function read(store, payload) {
	          var _iterator = _createForOfIteratorHelper$4(payload.ids),
	            _step;
	          try {
	            for (_iterator.s(); !(_step = _iterator.n()).done;) {
	              var notificationId = _step.value;
	              var existingItem = _this2.findItemInArr(store.state.collection, notificationId);
	              if (!existingItem.element) {
	                return false;
	              }
	              store.commit('read', {
	                index: existingItem.index,
	                action: !payload.action
	              });
	            }
	          } catch (err) {
	            _iterator.e(err);
	          } finally {
	            _iterator.f();
	          }
	        },
	        readAll: function readAll(store, payload) {
	          store.commit('readAll');
	        },
	        "delete": function _delete(store, payload) {
	          var existingItem = _this2.findItemInArr(store.state.collection, payload.id);
	          if (existingItem.element) {
	            store.commit('delete', {
	              searchCollection: false,
	              index: existingItem.index
	            });
	            store.commit('setTotal', store.state.total - 1);
	          }
	          if (payload.searchMode) {
	            var existingItemInSearchCollection = _this2.findItemInArr(store.state.searchCollection, payload.id);
	            if (existingItemInSearchCollection.element) {
	              store.commit('delete', {
	                searchCollection: true,
	                index: existingItemInSearchCollection.index
	              });
	            }
	          }
	        },
	        deleteAll: function deleteAll(store, payload) {
	          store.commit('deleteAll');
	        },
	        setSchema: function setSchema(store, payload) {
	          store.commit('setSchema', {
	            data: payload.data
	          });
	        }
	      };
	    }
	  }, {
	    key: "getMutations",
	    value: function getMutations() {
	      var _this3 = this;
	      return {
	        set: function set(state, payload) {
	          state.total = payload.hasOwnProperty('total') ? payload.total : state.total;
	          if (!payload.hasOwnProperty('notification') || !main_core.Type.isArray(payload.notification)) {
	            return;
	          }
	          var _iterator2 = _createForOfIteratorHelper$4(payload.notification),
	            _step2;
	          try {
	            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
	              var element = _step2.value;
	              var existingItem = _this3.findItemInArr(state.collection, element.id);
	              if (!existingItem.element) {
	                state.collection.push(element);
	              } else {
	                // we trust unread status of existing item to prevent notifications blinking while init loading.
	                if (element.unread !== state.collection[existingItem.index].unread) {
	                  element.unread = state.collection[existingItem.index].unread;
	                  state.unreadCounter = element.unread === true ? state.unreadCounter + 1 : state.unreadCounter - 1;
	                }
	                state.collection[existingItem.index] = Object.assign(state.collection[existingItem.index], element);
	              }
	            }
	          } catch (err) {
	            _iterator2.e(err);
	          } finally {
	            _iterator2.f();
	          }
	          state.collection.sort(_this3.sortByType);
	        },
	        setSearchResults: function setSearchResults(state, payload) {
	          var _iterator3 = _createForOfIteratorHelper$4(payload.data.notification),
	            _step3;
	          try {
	            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
	              var element = _step3.value;
	              var existingItem = _this3.findItemInArr(state.searchCollection, element.id);
	              if (!existingItem.element) {
	                state.searchCollection.push(element);
	              } else {
	                state.searchCollection[existingItem.index] = Object.assign(state.searchCollection[existingItem.index], element);
	              }
	            }
	          } catch (err) {
	            _iterator3.e(err);
	          } finally {
	            _iterator3.f();
	          }
	        },
	        deleteAll: function deleteAll(state, payload) {
	          state.collection = [];
	        },
	        deleteSearchResults: function deleteSearchResults(state, payload) {
	          state.searchCollection = [];
	        },
	        add: function add(state, payload) {
	          var firstNotificationIndex = null;
	          if (payload.data.sectionCode === im_const.NotificationTypesCodes.confirm) {
	            //new confirms should always add to the beginning of the collection
	            state.collection.unshift(payload.data);
	          } else
	            //if (payload.data.sectionCode === NotificationTypesCodes.simple)
	            {
	              for (var index = 0; state.collection.length > index; index++) {
	                if (state.collection[index].sectionCode === im_const.NotificationTypesCodes.simple) {
	                  firstNotificationIndex = index;
	                  break;
	                }
	              }

	              //if we didn't find any simple notification and its index, then add new one to the end.
	              if (firstNotificationIndex === null) {
	                state.collection.push(payload.data);
	              } else
	                //otherwise, put it right before first simple notification.
	                {
	                  state.collection.splice(firstNotificationIndex, 0, payload.data);
	                }
	            }
	          state.collection.sort(_this3.sortByType);
	        },
	        update: function update(state, payload) {
	          var collectionName = payload.searchCollection ? 'searchCollection' : 'collection';
	          ui_vue.WidgetVue.set(state[collectionName], payload.index, Object.assign({}, state[collectionName][payload.index], payload.fields));
	        },
	        "delete": function _delete(state, payload) {
	          var collectionName = payload.searchCollection ? 'searchCollection' : 'collection';
	          state[collectionName].splice(payload.index, 1);
	        },
	        read: function read(state, payload) {
	          state.collection[payload.index].unread = payload.action;
	        },
	        readAll: function readAll(state, payload) {
	          for (var index = 0; state.collection.length > index; index++) {
	            state.collection[index].unread = false;
	          }
	        },
	        updatePlaceholders: function updatePlaceholders(state, payload) {
	          var collectionName = payload.searchCollection ? 'searchCollection' : 'collection';
	          payload.items.forEach(function (element, index) {
	            var placeholderId = "placeholder".concat(payload.firstItem + index);
	            var existingPlaceholderIndex = state[collectionName].findIndex(function (notification) {
	              return notification.id === placeholderId;
	            });
	            var existingMessageIndex = state[collectionName].findIndex(function (notification) {
	              return notification.id === element.id;
	            });
	            if (existingMessageIndex >= 0) {
	              state[collectionName][existingMessageIndex] = Object.assign(state[collectionName][existingMessageIndex], element);
	              state[collectionName].splice(existingPlaceholderIndex, 1);
	            } else {
	              state[collectionName].splice(existingPlaceholderIndex, 1, Object.assign({}, element));
	            }
	          });
	          state[collectionName].sort(_this3.sortByType);
	        },
	        clearPlaceholders: function clearPlaceholders(state, payload) {
	          state.collection = state.collection.filter(function (element) {
	            return !element.id.toString().startsWith('placeholder');
	          });
	          state.searchCollection = state.searchCollection.filter(function (element) {
	            return !element.id.toString().startsWith('placeholder');
	          });
	        },
	        setCounter: function setCounter(state, payload) {
	          state.unreadCounter = payload;
	        },
	        setTotal: function setTotal(state, payload) {
	          state.total = payload;
	        },
	        setSchema: function setSchema(state, payload) {
	          state.schema = payload.data;
	        }
	      };
	    } /* region Validation */
	  }, {
	    key: "validate",
	    value: function validate(fields, options) {
	      var result = {};
	      if (main_core.Type.isString(fields.id) || main_core.Type.isNumber(fields.id)) {
	        result.id = fields.id;
	      }
	      if (!main_core.Type.isNil(fields.date)) {
	        result.date = im_lib_utils.Utils.date.cast(fields.date);
	      }
	      if (main_core.Type.isString(fields.text) || main_core.Type.isNumber(fields.text)) {
	        result.text = fields.text.toString();
	        result.textConverted = NotificationsModel.decodeText(result.text);
	      }
	      if (main_core.Type.isNumber(fields.author_id)) {
	        if (fields.system === true || fields.system === 'Y') {
	          result.authorId = 0;
	        } else {
	          result.authorId = fields.author_id;
	        }
	      }
	      if (main_core.Type.isNumber(fields.userId)) {
	        result.authorId = fields.userId;
	      }
	      if (main_core.Type.isObjectLike(fields.params)) {
	        var params = this.validateParams(fields.params);
	        if (params) {
	          result.params = params;
	        }
	      }
	      if (!main_core.Type.isNil(fields.notify_buttons)) {
	        result.notifyButtons = JSON.parse(fields.notify_buttons);
	      }

	      //p&p format
	      if (!main_core.Type.isNil(fields.buttons)) {
	        result.notifyButtons = fields.buttons.map(function (button) {
	          return {
	            COMMAND: 'notifyConfirm',
	            COMMAND_PARAMS: "".concat(result.id, "|").concat(button.VALUE),
	            TEXT: "".concat(button.TITLE),
	            TYPE: 'BUTTON',
	            DISPLAY: 'LINE',
	            BG_COLOR: button.VALUE === 'Y' ? '#8bc84b' : '#ef4b57',
	            TEXT_COLOR: '#fff'
	          };
	        });
	      }
	      if (fields.notify_type === im_const.NotificationTypesCodes.confirm || fields.type === im_const.NotificationTypesCodes.confirm) {
	        result.sectionCode = im_const.NotificationTypesCodes.confirm;
	      } else if (fields.type === im_const.NotificationTypesCodes.placeholder) {
	        result.sectionCode = im_const.NotificationTypesCodes.placeholder;
	      }
	      if (!main_core.Type.isNil(fields.notify_read)) {
	        result.unread = fields.notify_read === 'N';
	      }

	      //p&p format
	      if (!main_core.Type.isNil(fields.read)) {
	        result.unread = fields.read === 'N'; //?
	      }

	      if (main_core.Type.isString(fields.setting_name)) {
	        result.settingName = fields.setting_name;
	      }

	      // rest format
	      if (main_core.Type.isString(fields.notify_title) && fields.notify_title.length > 0) {
	        result.title = fields.notify_title;
	      }

	      // p&p format
	      if (main_core.Type.isString(fields.title) && fields.title.length > 0) {
	        result.title = fields.title;
	      }
	      return result;
	    }
	  }, {
	    key: "validateParams",
	    value: function validateParams(params) {
	      var result = {};
	      try {
	        for (var field in params) {
	          if (!params.hasOwnProperty(field)) {
	            continue;
	          }
	          if (field === 'COMPONENT_ID') {
	            if (main_core.Type.isString(params[field]) && BX.WidgetVue.isComponent(params[field])) {
	              result[field] = params[field];
	            }
	          } else if (field === 'LIKE') {
	            if (params[field] instanceof Array) {
	              result['REACTION'] = {
	                like: params[field].map(function (element) {
	                  return parseInt(element);
	                })
	              };
	            }
	          } else if (field === 'CHAT_LAST_DATE') {
	            result[field] = im_lib_utils.Utils.date.cast(params[field]);
	          } else if (field === 'AVATAR') {
	            if (params[field]) {
	              result[field] = params[field].startsWith('http') ? params[field] : options.host + params[field];
	            }
	          } else if (field === 'NAME') {
	            if (params[field]) {
	              result[field] = params[field];
	            }
	          } else {
	            result[field] = params[field];
	          }
	        }
	      } catch (e) {}
	      var hasResultElements = false;
	      for (var _field in result) {
	        if (!result.hasOwnProperty(_field)) {
	          continue;
	        }
	        hasResultElements = true;
	        break;
	      }
	      return hasResultElements ? result : null;
	    }
	    /* endregion Validation */
	    /* region Internal helpers */
	  }, {
	    key: "prepareNotification",
	    value: function prepareNotification(notification) {
	      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	      var result = this.validate(Object.assign({}, notification));
	      return Object.assign({}, this.getElementState(), result, options);
	    }
	  }, {
	    key: "findItemInArr",
	    value: function findItemInArr(arr, value) {
	      var key = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'id';
	      var result = {};
	      var elementIndex = arr.findIndex(function (element, index) {
	        return element[key] === value;
	      });
	      if (elementIndex !== -1) {
	        result.index = elementIndex;
	        result.element = arr[elementIndex];
	      }
	      return result;
	    }
	  }, {
	    key: "sortByType",
	    value: function sortByType(a, b) {
	      if (a.sectionCode === im_const.NotificationTypesCodes.confirm && b.sectionCode !== im_const.NotificationTypesCodes.confirm) {
	        return -1;
	      } else if (a.sectionCode !== im_const.NotificationTypesCodes.confirm && b.sectionCode === im_const.NotificationTypesCodes.confirm) {
	        return 1;
	      } else {
	        return b.id - a.id;
	      }
	    } /* endregion Internal helpers */
	  }], [{
	    key: "decodeText",
	    value: function decodeText(text) {
	      text = main_core.Text.decode(text.toString());
	      text = im_lib_utils.Utils.text.decode(text);
	      var Parser = main_core.Reflection.getClass('BX.Messenger.v2.Lib.Parser');
	      if (Parser) {
	        text = Parser.decodeSmileForLegacyCore(text, {
	          enableBigSmile: false
	        });
	      }
	      if (!im_lib_utils.Utils.platform.isBitrixDesktop()) {
	        text = text.replace(/<a(.*?)>(.*?)<\/a>/gi, function (whole, anchor, innerText) {
	          return "<a ".concat(anchor.replace('target="_blank"', 'target="_self"'), " class=\"bx-im-notifications-item-link\">").concat(innerText, "</a>");
	        });
	      }
	      return text;
	    }
	  }]);
	  return NotificationsModel;
	}(ui_vue_vuex.WidgetVuexBuilderModel);

	/**
	 * Bitrix Messenger
	 * Call Application model (Vuex Builder model)
	 *
	 * @package bitrix
	 * @subpackage im
	 * @copyright 2001-2020 Bitrix
	 */
	var CallModel = /*#__PURE__*/function (_VuexBuilderModel) {
	  babelHelpers.inherits(CallModel, _VuexBuilderModel);
	  function CallModel() {
	    babelHelpers.classCallCheck(this, CallModel);
	    return babelHelpers.possibleConstructorReturn(this, babelHelpers.getPrototypeOf(CallModel).apply(this, arguments));
	  }
	  babelHelpers.createClass(CallModel, [{
	    key: "getName",
	    value: function getName() {
	      return 'call';
	    }
	  }, {
	    key: "getState",
	    value: function getState() {
	      return {
	        users: {}
	      };
	    }
	  }, {
	    key: "getElementState",
	    value: function getElementState() {
	      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	      return {
	        id: params.id ? params.id : 0,
	        state: im_const.ConferenceUserState.Idle,
	        talking: false,
	        pinned: false,
	        cameraState: false,
	        microphoneState: false,
	        screenState: false,
	        floorRequestState: false
	      };
	    }
	  }, {
	    key: "getGetters",
	    value: function getGetters() {
	      var _this = this;
	      return {
	        getUser: function getUser(state) {
	          return function (userId) {
	            userId = parseInt(userId, 10);
	            if (!state.users[userId]) {
	              return _this.getElementState({
	                id: userId
	              });
	            }
	            return state.users[userId];
	          };
	        },
	        getBlankUser: function getBlankUser(state) {
	          return function (userId) {
	            userId = parseInt(userId, 10);
	            return _this.getElementState({
	              id: userId
	            });
	          };
	        }
	      };
	    }
	  }, {
	    key: "getActions",
	    value: function getActions() {
	      var _this2 = this;
	      return {
	        updateUser: function updateUser(store, payload) {
	          payload.id = parseInt(payload.id, 10);
	          payload.fields = Object.assign({}, _this2.validate(payload.fields));
	          store.commit('updateUser', payload);
	        },
	        unpinUser: function unpinUser(store, payload) {
	          store.commit('unpinUser');
	        }
	      };
	    }
	  }, {
	    key: "getMutations",
	    value: function getMutations() {
	      var _this3 = this;
	      return {
	        updateUser: function updateUser(state, payload) {
	          if (!state.users[payload.id]) {
	            ui_vue.WidgetVue.set(state.users, payload.id, Object.assign(_this3.getElementState(), payload.fields, {
	              id: payload.id
	            }));
	          } else {
	            state.users[payload.id] = Object.assign(state.users[payload.id], payload.fields);
	          }
	        },
	        unpinUser: function unpinUser(state, payload) {
	          var pinnedUser = Object.values(state.users).find(function (user) {
	            return user.pinned === true;
	          });
	          if (pinnedUser) {
	            state.users[pinnedUser.id].pinned = false;
	          }
	        }
	      };
	    }
	  }, {
	    key: "validate",
	    value: function validate(payload) {
	      var result = {};
	      if (main_core.Type.isNumber(payload.id) || main_core.Type.isString(payload.id)) {
	        result.id = parseInt(payload.id, 10);
	      }
	      if (im_const.ConferenceUserState[payload.state]) {
	        result.state = payload.state;
	      }
	      if (main_core.Type.isBoolean(payload.talking)) {
	        result.talking = payload.talking;
	      }
	      if (main_core.Type.isBoolean(payload.pinned)) {
	        result.pinned = payload.pinned;
	      }
	      if (main_core.Type.isBoolean(payload.cameraState)) {
	        result.cameraState = payload.cameraState;
	      }
	      if (main_core.Type.isBoolean(payload.microphoneState)) {
	        result.microphoneState = payload.microphoneState;
	      }
	      if (main_core.Type.isBoolean(payload.screenState)) {
	        result.screenState = payload.screenState;
	      }
	      if (main_core.Type.isBoolean(payload.floorRequestState)) {
	        result.floorRequestState = payload.floorRequestState;
	      }
	      return result;
	    }
	  }, {
	    key: "getStateSaveException",
	    value: function getStateSaveException() {
	      return {
	        users: false
	      };
	    }
	  }]);
	  return CallModel;
	}(ui_vue_vuex.WidgetVuexBuilderModel);

	exports.ApplicationModel = ApplicationModel;
	exports.ConferenceModel = ConferenceModel;
	exports.MessagesModel = MessagesModel;
	exports.DialoguesModel = DialoguesModel;
	exports.UsersModel = UsersModel;
	exports.FilesModel = FilesModel;
	exports.RecentModel = RecentModel;
	exports.NotificationsModel = NotificationsModel;
	exports.CallModel = CallModel;

}((this.BX.Messenger.Model = this.BX.Messenger.Model || {}),BX.Messenger.Lib,BX.Event,BX.Messenger.Lib,BX,BX,BX,BX.Messenger.Const));





// file: /bitrix/js/main/polyfill/intersectionobserver/js/intersectionobserver.js
/**
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the W3C SOFTWARE AND DOCUMENT NOTICE AND LICENSE.
 *
 * https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
 *
 */

;(function(window, document) {
	'use strict';

	if ('IntersectionObserver' in window &&
		'IntersectionObserverEntry' in window &&
		'intersectionRatio' in window.IntersectionObserverEntry.prototype)
	{

		// Minimal polyfill for Edge 15's lack of `isIntersecting`
		// See: https://github.com/w3c/IntersectionObserver/issues/211
		if (!('isIntersecting' in window.IntersectionObserverEntry.prototype))
		{
			Object.defineProperty(window.IntersectionObserverEntry.prototype,
				'isIntersecting', {
					get: function ()
					{
						return this.intersectionRatio > 0;
					}
				});
		}

		return;
	}


	/**
	 * An IntersectionObserver registry. This registry exists to hold a strong
	 * reference to IntersectionObserver instances currently observering a target
	 * element. Without this registry, instances without another reference may be
	 * garbage collected.
	 */
	var registry = [];


	/**
	 * Creates the global IntersectionObserverEntry constructor.
	 * https://w3c.github.io/IntersectionObserver/#intersection-observer-entry
	 * @param {Object} entry A dictionary of instance properties.
	 * @constructor
	 */
	function IntersectionObserverEntry(entry)
	{
		this.time = entry.time;
		this.target = entry.target;
		this.rootBounds = entry.rootBounds;
		this.boundingClientRect = entry.boundingClientRect;
		this.intersectionRect = entry.intersectionRect || getEmptyRect();
		this.isIntersecting = !!entry.intersectionRect;

		// Calculates the intersection ratio.
		var targetRect = this.boundingClientRect;
		var targetArea = targetRect.width * targetRect.height;
		var intersectionRect = this.intersectionRect;
		var intersectionArea = intersectionRect.width * intersectionRect.height;

		// Sets intersection ratio.
		if (targetArea)
		{
			this.intersectionRatio = intersectionArea / targetArea;
		}
		else
		{
			// If area is zero and is intersecting, sets to 1, otherwise to 0
			this.intersectionRatio = this.isIntersecting ? 1 : 0;
		}
	}


	/**
	 * Creates the global IntersectionObserver constructor.
	 * https://w3c.github.io/IntersectionObserver/#intersection-observer-interface
	 * @param {Function} callback The function to be invoked after intersection
	 *     changes have queued. The function is not invoked if the queue has
	 *     been emptied by calling the `takeRecords` method.
	 * @param {Object=} opt_options Optional configuration options.
	 * @constructor
	 */
	function IntersectionObserver(callback, opt_options)
	{
		var options = opt_options || {};

		if (typeof callback !== 'function')
		{
			throw new Error('callback must be a function');
		}

		if (options.root && options.root.nodeType !== 1)
		{
			throw new Error('root must be an Element');
		}

		// Binds and throttles `this._checkForIntersections`.
		this._checkForIntersections = throttle(
			this._checkForIntersections.bind(this), this.THROTTLE_TIMEOUT);

		// Private properties.
		this._callback = callback;
		this._observationTargets = [];
		this._queuedEntries = [];
		this._rootMarginValues = this._parseRootMargin(options.rootMargin);

		// Public properties.
		this.thresholds = this._initThresholds(options.threshold);
		this.root = options.root || null;
		this.rootMargin = this._rootMarginValues.map(function(margin) {
			return margin.value + margin.unit;
		}).join(' ');
	}


	/**
	 * The minimum interval within which the document will be checked for
	 * intersection changes.
	 */
	IntersectionObserver.prototype.THROTTLE_TIMEOUT = 100;


	/**
	 * The frequency in which the polyfill polls for intersection changes.
	 * this can be updated on a per instance basis and must be set prior to
	 * calling `observe` on the first target.
	 */
	IntersectionObserver.prototype.POLL_INTERVAL = null;

	/**
	 * Use a mutation observer on the root element
	 * to detect intersection changes.
	 */
	IntersectionObserver.prototype.USE_MUTATION_OBSERVER = true;


	/**
	 * Starts observing a target element for intersection changes based on
	 * the thresholds values.
	 * @param {Element} target The DOM element to observe.
	 */
	IntersectionObserver.prototype.observe = function(target)
	{
		var isTargetAlreadyObserved = this._observationTargets.some(function(item) {
			return item.element === target;
		});

		if (isTargetAlreadyObserved)
		{
			return;
		}

		if (!(target && target.nodeType === 1))
		{
			throw new Error('target must be an Element');
		}

		this._registerInstance();
		this._observationTargets.push({element: target, entry: null});
		this._monitorIntersections();
		this._checkForIntersections();
	};


	// noinspection JSUnusedGlobalSymbols
	/**
	 * Stops observing a target element for intersection changes.
	 * @param {Element} target The DOM element to observe.
	 */
	IntersectionObserver.prototype.unobserve = function(target)
	{
		this._observationTargets = this._observationTargets.filter(function(item) {
			return item.element !== target;
		});

		if (!this._observationTargets.length)
		{
			this._unmonitorIntersections();
			this._unregisterInstance();
		}
	};


	/**
	 * Stops observing all target elements for intersection changes.
	 */
	IntersectionObserver.prototype.disconnect = function()
	{
		this._observationTargets = [];
		this._unmonitorIntersections();
		this._unregisterInstance();
	};


	/**
	 * Returns any queue entries that have not yet been reported to the
	 * callback and clears the queue. This can be used in conjunction with the
	 * callback to obtain the absolute most up-to-date intersection information.
	 * @return {Array} The currently queued entries.
	 */
	IntersectionObserver.prototype.takeRecords = function()
	{
		var records = this._queuedEntries.slice();
		this._queuedEntries = [];
		return records;
	};


	/**
	 * Accepts the threshold value from the user configuration object and
	 * returns a sorted array of unique threshold values. If a value is not
	 * between 0 and 1 and error is thrown.
	 * @private
	 * @param {Array|number=} opt_threshold An optional threshold value or
	 *     a list of threshold values, defaulting to [0].
	 * @return {Array} A sorted list of unique and valid threshold values.
	 */
	IntersectionObserver.prototype._initThresholds = function(opt_threshold)
	{
		var threshold = opt_threshold || [0];

		if (!Array.isArray(threshold))
		{
			threshold = [threshold];
		}

		return threshold.sort().filter(function(t, i, a) {
			if (typeof t !== 'number' || isNaN(t) || t < 0 || t > 1)
			{
				throw new Error('threshold must be a number between 0 and 1 inclusively');
			}
			return t !== a[i - 1];
		});
	};


	/**
	 * Accepts the rootMargin value from the user configuration object
	 * and returns an array of the four margin values as an object containing
	 * the value and unit properties. If any of the values are not properly
	 * formatted or use a unit other than px or %, and error is thrown.
	 * @private
	 * @param {string=} opt_rootMargin An optional rootMargin value,
	 *     defaulting to '0px'.
	 * @return {Array<Object>} An array of margin objects with the keys
	 *     value and unit.
	 */
	IntersectionObserver.prototype._parseRootMargin = function(opt_rootMargin) {
		var marginString = opt_rootMargin || '0px';
		var margins = marginString.split(/\s+/).map(function(margin) {
			var parts = /^(-?\d*\.?\d+)(px|%)$/.exec(margin);
			if (!parts)
			{
				throw new Error('rootMargin must be specified in pixels or percent');
			}

			return {value: parseFloat(parts[1]), unit: parts[2]};
		});

		// Handles shorthand.
		margins[1] = margins[1] || margins[0];
		margins[2] = margins[2] || margins[0];
		margins[3] = margins[3] || margins[1];

		return margins;
	};


	/**
	 * Starts polling for intersection changes if the polling is not already
	 * happening, and if the page's visibilty state is visible.
	 * @private
	 */
	IntersectionObserver.prototype._monitorIntersections = function()
	{
		if (!this._monitoringIntersections)
		{
			this._monitoringIntersections = true;

			// If a poll interval is set, use polling instead of listening to
			// resize and scroll events or DOM mutations.
			if (this.POLL_INTERVAL)
			{
				this._monitoringInterval = setInterval(
					this._checkForIntersections, this.POLL_INTERVAL);
			}
			else
			{
				addEvent(window, 'resize', this._checkForIntersections, true);
				addEvent(document, 'scroll', this._checkForIntersections, true);

				if (this.USE_MUTATION_OBSERVER && 'MutationObserver' in window)
				{
					this._domObserver = new MutationObserver(this._checkForIntersections);
					this._domObserver.observe(document, {
						attributes: true,
						childList: true,
						characterData: true,
						subtree: true
					});
				}
			}
		}
	};


	/**
	 * Stops polling for intersection changes.
	 * @private
	 */
	IntersectionObserver.prototype._unmonitorIntersections = function()
	{
		if (this._monitoringIntersections)
		{
			this._monitoringIntersections = false;

			clearInterval(this._monitoringInterval);
			this._monitoringInterval = null;

			removeEvent(window, 'resize', this._checkForIntersections, true);
			removeEvent(document, 'scroll', this._checkForIntersections, true);

			if (this._domObserver)
			{
				this._domObserver.disconnect();
				this._domObserver = null;
			}
		}
	};


	/**
	 * Scans each observation target for intersection changes and adds them
	 * to the internal entries queue. If new entries are found, it
	 * schedules the callback to be invoked.
	 * @private
	 */
	IntersectionObserver.prototype._checkForIntersections = function()
	{
		var rootIsInDom = this._rootIsInDom();
		var rootRect = rootIsInDom ? this._getRootRect() : getEmptyRect();

		this._observationTargets.forEach(function(item) {
			var target = item.element;
			var targetRect = getBoundingClientRect(target);
			var rootContainsTarget = this._rootContainsTarget(target);
			var oldEntry = item.entry;
			var intersectionRect = rootIsInDom && rootContainsTarget &&
				this._computeTargetAndRootIntersection(target, rootRect);

			var newEntry = item.entry = new IntersectionObserverEntry({
				time: now(),
				target: target,
				boundingClientRect: targetRect,
				rootBounds: rootRect,
				intersectionRect: intersectionRect
			});

			if (!oldEntry)
			{
				this._queuedEntries.push(newEntry);
			}
			else if (rootIsInDom && rootContainsTarget)
			{
				// If the new entry intersection ratio has crossed any of the
				// thresholds, add a new entry.
				if (this._hasCrossedThreshold(oldEntry, newEntry))
				{
					this._queuedEntries.push(newEntry);
				}
			}
			else
			{
				// If the root is not in the DOM or target is not contained within
				// root but the previous entry for this target had an intersection,
				// add a new record indicating removal.
				if (oldEntry && oldEntry.isIntersecting)
				{
					this._queuedEntries.push(newEntry);
				}
			}
		}, this);

		if (this._queuedEntries.length)
		{
			this._callback(this.takeRecords(), this);
		}
	};


	/**
	 * Accepts a target and root rect computes the intersection between then
	 * following the algorithm in the spec.
	 * TODO(philipwalton): at this time clip-path is not considered.
	 * https://w3c.github.io/IntersectionObserver/#calculate-intersection-rect-algo
	 * @param {Element} target The target DOM element
	 * @param {Object} rootRect The bounding rect of the root after being
	 *     expanded by the rootMargin value.
	 * @return {?Object} The final intersection rect object or undefined if no
	 *     intersection is found.
	 * @private
	 */
	IntersectionObserver.prototype._computeTargetAndRootIntersection = function(target, rootRect)
	{
		// If the element isn't displayed, an intersection can't happen.
		if (window.getComputedStyle(target).display === 'none')
		{
			return;
		}

		var intersectionRect = getBoundingClientRect(target);
		var parent = getParentNode(target);
		var atRoot = false;

		while (!atRoot)
		{
			var parentRect = null;
			var parentComputedStyle = parent.nodeType === 1 ?
				window.getComputedStyle(parent) : {};

			// If the parent isn't displayed, an intersection can't happen.
			// noinspection EqualityComparisonWithCoercionJS
			if (parentComputedStyle.display == 'none')
			{
				return;
			}

			if (parent === this.root || parent === document)
			{
				atRoot = true;
				parentRect = rootRect;
			}
			else
			{
				// If the element has a non-visible overflow, and it's not the <body>
				// or <html> element, update the intersection rect.
				// Note: <body> and <html> cannot be clipped to a rect that's not also
				// the document rect, so no need to compute a new intersection.
				// noinspection EqualityComparisonWithCoercionJS
				if (parent != document.body &&
					parent != document.documentElement &&
					parentComputedStyle.overflow != 'visible')
				{
					parentRect = getBoundingClientRect(parent);
				}
			}

			// If either of the above conditionals set a new parentRect,
			// calculate new intersection data.
			if (parentRect)
			{
				intersectionRect = computeRectIntersection(parentRect, intersectionRect);

				if (!intersectionRect)
				{
					break;
				}
			}

			parent = getParentNode(parent);
		}

		return intersectionRect;
	};


	/**
	 * Returns the root rect after being expanded by the rootMargin value.
	 * @return {Object} The expanded root rect.
	 * @private
	 */
	IntersectionObserver.prototype._getRootRect = function()
	{
		var rootRect;

		if (this.root)
		{
			rootRect = getBoundingClientRect(this.root);
		}
		else
		{
			// Use <html>/<body> instead of window since scroll bars affect size.
			var html = document.documentElement;
			var body = document.body;
			rootRect = {
				top: 0,
				left: 0,
				right: html.clientWidth || body.clientWidth,
				width: html.clientWidth || body.clientWidth,
				bottom: html.clientHeight || body.clientHeight,
				height: html.clientHeight || body.clientHeight
			};
		}

		return this._expandRectByRootMargin(rootRect);
	};


	/**
	 * Accepts a rect and expands it by the rootMargin value.
	 * @param {Object} rect The rect object to expand.
	 * @return {Object} The expanded rect.
	 * @private
	 */
	IntersectionObserver.prototype._expandRectByRootMargin = function(rect)
	{
		var margins = this._rootMarginValues.map(function(margin, i) {
			return margin.unit === 'px' ? margin.value :
				margin.value * (i % 2 ? rect.width : rect.height) / 100;
		});
		var newRect = {
			top: rect.top - margins[0],
			right: rect.right + margins[1],
			bottom: rect.bottom + margins[2],
			left: rect.left - margins[3]
		};
		newRect.width = newRect.right - newRect.left;
		newRect.height = newRect.bottom - newRect.top;

		return newRect;
	};


	/**
	 * Accepts an old and new entry and returns true if at least one of the
	 * threshold values has been crossed.
	 * @param {?IntersectionObserverEntry} oldEntry The previous entry for a
	 *    particular target element or null if no previous entry exists.
	 * @param {IntersectionObserverEntry} newEntry The current entry for a
	 *    particular target element.
	 * @return {boolean} Returns true if a any threshold has been crossed.
	 * @private
	 */
	IntersectionObserver.prototype._hasCrossedThreshold = function(oldEntry, newEntry)
	{
		// To make comparing easier, an entry that has a ratio of 0
		// but does not actually intersect is given a value of -1
		var oldRatio = oldEntry && oldEntry.isIntersecting ?
			oldEntry.intersectionRatio || 0 : -1;
		var newRatio = newEntry.isIntersecting ?
			newEntry.intersectionRatio || 0 : -1;

		// Ignore unchanged ratios
		if (oldRatio === newRatio)
		{
			return;
		}

		for (var i = 0; i < this.thresholds.length; i++)
		{
			var threshold = this.thresholds[i];

			// Return true if an entry matches a threshold or if the new ratio
			// and the old ratio are on the opposite sides of a threshold.
			// noinspection EqualityComparisonWithCoercionJS
			if (threshold == oldRatio || threshold == newRatio ||
				threshold < oldRatio !== threshold < newRatio)
			{
				return true;
			}
		}
	};


	/**
	 * Returns whether or not the root element is an element and is in the DOM.
	 * @return {boolean} True if the root element is an element and is in the DOM.
	 * @private
	 */
	IntersectionObserver.prototype._rootIsInDom = function()
	{
		return !this.root || containsDeep(document, this.root);
	};


	/**
	 * Returns whether or not the target element is a child of root.
	 * @param {Element} target The target element to check.
	 * @return {boolean} True if the target element is a child of root.
	 * @private
	 */
	IntersectionObserver.prototype._rootContainsTarget = function(target)
	{
		return containsDeep(this.root || document, target);
	};


	/**
	 * Adds the instance to the global IntersectionObserver registry if it isn't
	 * already present.
	 * @private
	 */
	IntersectionObserver.prototype._registerInstance = function()
	{
		if (registry.indexOf(this) < 0)
		{
			registry.push(this);
		}
	};


	/**
	 * Removes the instance from the global IntersectionObserver registry.
	 * @private
	 */
	IntersectionObserver.prototype._unregisterInstance = function()
	{
		var index = registry.indexOf(this);

		if (index !== -1)
		{
			registry.splice(index, 1);
		}
	};


	/**
	 * Returns the result of the performance.now() method or null in browsers
	 * that don't support the API.
	 * @return {number} The elapsed time since the page was requested.
	 */
	function now()
	{
		return window.performance && performance.now && performance.now();
	}


	/**
	 * Throttles a function and delays its executiong, so it's only called at most
	 * once within a given time period.
	 * @param {Function} fn The function to throttle.
	 * @param {number} timeout The amount of time that must pass before the
	 *     function can be called again.
	 * @return {Function} The throttled function.
	 */
	function throttle(fn, timeout)
	{
		var timer = null;
		return function () {
			if (!timer) {
				timer = setTimeout(function() {
					fn();
					timer = null;
				}, timeout);
			}
		};
	}


	/**
	 * Adds an event handler to a DOM node ensuring cross-browser compatibility.
	 * @param {Node|Window|HTMLDocument} node The DOM node to add the event handler to.
	 * @param {string} event The event name.
	 * @param {Function} fn The event handler to add.
	 * @param {boolean} opt_useCapture Optionally adds the even to the capture
	 *     phase. Note: this only works in modern browsers.
	 */
	function addEvent(node, event, fn, opt_useCapture)
	{
		// noinspection EqualityComparisonWithCoercionJS
		if (typeof node.addEventListener == 'function')
		{
			node.addEventListener(event, fn, opt_useCapture || false);
		}
		else if (typeof node.attachEvent === 'function')
		{
			node.attachEvent('on' + event, fn);
		}
	}


	/**
	 * Removes a previously added event handler from a DOM node.
	 * @param {Node|Window|Document} node The DOM node to remove the event handler from.
	 * @param {string} event The event name.
	 * @param {Function} fn The event handler to remove.
	 * @param {boolean} opt_useCapture If the event handler was added with this
	 *     flag set to true, it should be set to true here in order to remove it.
	 */
	function removeEvent(node, event, fn, opt_useCapture)
	{
		if (typeof node.removeEventListener === 'function')
		{
			node.removeEventListener(event, fn, opt_useCapture || false);
		}
		else if (typeof node.detatchEvent === 'function')
		{
			node.detatchEvent('on' + event, fn);
		}
	}


	/**
	 * Returns the intersection between two rect objects.
	 * @param {Object} rect1 The first rect.
	 * @param {Object} rect2 The second rect.
	 * @return {?Object} The intersection rect or undefined if no intersection
	 *     is found.
	 */
	function computeRectIntersection(rect1, rect2)
	{
		var top = Math.max(rect1.top, rect2.top);
		var bottom = Math.min(rect1.bottom, rect2.bottom);
		var left = Math.max(rect1.left, rect2.left);
		var right = Math.min(rect1.right, rect2.right);
		var width = right - left;
		var height = bottom - top;

		return (width >= 0 && height >= 0) && {
			top: top,
			bottom: bottom,
			left: left,
			right: right,
			width: width,
			height: height
		};
	}


	/**
	 * Shims the native getBoundingClientRect for compatibility with older IE.
	 * @param {Element} el The element whose bounding rect to get.
	 * @return {Object} The (possibly shimmed) rect of the element.
	 */
	function getBoundingClientRect(el)
	{
		var rect;

		try
		{
			rect = el.getBoundingClientRect();
		}
		catch (err)
		{
			// Ignore Windows 7 IE11 "Unspecified error"
			// https://github.com/w3c/IntersectionObserver/pull/205
		}

		if (!rect)
		{
			return getEmptyRect();
		}

		// Older IE
		if (!(rect.width && rect.height))
		{
			rect = {
				top: rect.top,
				right: rect.right,
				bottom: rect.bottom,
				left: rect.left,
				width: rect.right - rect.left,
				height: rect.bottom - rect.top
			};
		}

		return rect;
	}


	/**
	 * Returns an empty rect object. An empty rect is returned when an element
	 * is not in the DOM.
	 * @return {Object} The empty rect.
	 */
	function getEmptyRect()
	{
		return {
			top: 0,
			bottom: 0,
			left: 0,
			right: 0,
			width: 0,
			height: 0
		};
	}

	/**
	 * Checks to see if a parent element contains a child element (including inside
	 * shadow DOM).
	 * @param {Node} parent The parent element.
	 * @param {Node} child The child element.
	 * @return {boolean} True if the parent node contains the child node.
	 */
	function containsDeep(parent, child)
	{
		var node = child;

		while (node)
		{
			if (node === parent)
			{
				return true;
			}

			node = getParentNode(node);
		}

		return false;
	}


	/**
	 * Gets the parent node of an element or its host element if the parent node
	 * is a shadow root.
	 * @param {Node} node The node whose parent to get.
	 * @return {Node|null} The parent node or null if no parent exists.
	 */
	function getParentNode(node)
	{
		var parent = node.parentNode;

		// noinspection EqualityComparisonWithCoercionJS
		if (parent && parent.nodeType == 11 && parent.host)
		{
			// If the parent is a shadow root, return the host element.
			return parent.host;
		}

		return parent;
	}

	// Exposes the constructors globally.
	window.IntersectionObserver = IntersectionObserver;
	window.IntersectionObserverEntry = IntersectionObserverEntry;

}(window, document));



// file: /bitrix/js/ui/vue/components/audioplayer/dist/audioplayer.bundle.js
(function (exports,ui_fonts_opensans,main_polyfill_intersectionobserver,ui_vue,main_core_events) {
	'use strict';

	/**
	 * Bitrix UI
	 * Audio player Vue component
	 *
	 * @package bitrix
	 * @subpackage ui
	 * @copyright 2001-2021 Bitrix
	 */

	var _State = Object.freeze({
	  play: 'play',
	  pause: 'pause',
	  stop: 'stop',
	  none: 'none'
	});

	ui_vue.WidgetBitrixVue.component('bx-audioplayer', {
	  props: {
	    id: {
	      "default": 0
	    },
	    src: {
	      "default": ''
	    },
	    autoPlayNext: {
	      "default": true
	    },
	    background: {
	      "default": 'light'
	    }
	  },
	  data: function data() {
	    return {
	      isDark: false,
	      preload: "none",
	      loaded: false,
	      loading: false,
	      playAfterLoad: false,
	      state: _State.none,
	      progress: 0,
	      progressInPixel: 0,
	      seek: 0,
	      timeCurrent: 0,
	      timeTotal: 0
	    };
	  },
	  created: function created() {
	    this.preloadRequestSent = false;
	    this.registeredId = 0;
	    this.registerPlayer(this.id);
	    this.$Bitrix.eventEmitter.subscribe('ui:audioplayer:play', this.onPlay);
	    this.$Bitrix.eventEmitter.subscribe('ui:audioplayer:stop', this.onStop);
	    this.$Bitrix.eventEmitter.subscribe('ui:audioplayer:pause', this.onPause);
	    this.$Bitrix.eventEmitter.subscribe('ui:audioplayer:preload', this.onPreload);
	    this.isDark = this.background === 'dark';
	  },
	  mounted: function mounted() {
	    this.getObserver().observe(this.$refs.body);
	  },
	  beforeDestroy: function beforeDestroy() {
	    this.unregisterPlayer();
	    this.$Bitrix.eventEmitter.unsubscribe('ui:audioplayer:play', this.onPlay);
	    this.$Bitrix.eventEmitter.unsubscribe('ui:audioplayer:stop', this.onStop);
	    this.$Bitrix.eventEmitter.unsubscribe('ui:audioplayer:pause', this.onPause);
	    this.$Bitrix.eventEmitter.unsubscribe('ui:audioplayer:preload', this.onPreload);
	    this.getObserver().unobserve(this.$refs.body);
	  },
	  watch: {
	    id: function id(value) {
	      this.registerPlayer(value);
	    },
	    progress: function progress(value) {
	      if (value > 70) {
	        this.preloadNext();
	      }
	    }
	  },
	  methods: {
	    loadFile: function loadFile() {
	      var play = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

	      if (this.loaded) {
	        return true;
	      }

	      if (this.loading && !play) {
	        return true;
	      }

	      this.preload = 'auto';

	      if (play) {
	        this.loading = true;

	        if (this.source()) {
	          this.source().play();
	        }
	      }

	      return true;
	    },
	    clickToButton: function clickToButton() {
	      if (!this.src) {
	        return false;
	      }

	      if (this.state === _State.play) {
	        this.pause();
	      } else {
	        this.play();
	      }
	    },
	    play: function play() {
	      if (!this.loaded) {
	        this.loadFile(true);
	        return false;
	      }

	      this.source().play();
	    },
	    pause: function pause() {
	      this.source().pause();
	    },
	    stop: function stop() {
	      this.state = _State.stop;
	      this.source().pause();
	    },
	    setPosition: function setPosition(event) {
	      if (!this.loaded) {
	        this.loadFile(true);
	        return false;
	      }

	      var pixelPerPercent = this.$refs.track.offsetWidth / 100;
	      this.setProgress(this.seek / pixelPerPercent, this.seek);

	      if (this.state !== _State.play) {
	        this.state = _State.pause;
	      }

	      this.play();
	      this.source().currentTime = this.timeTotal / 100 * this.progress;
	    },
	    seeking: function seeking(event) {
	      if (!this.loaded) {
	        return false;
	      }

	      this.seek = event.offsetX > 0 ? event.offsetX : 0;
	      return true;
	    },
	    setProgress: function setProgress(percent) {
	      var pixel = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;
	      this.progress = percent;
	      this.progressInPixel = pixel > 0 ? pixel : Math.round(this.$refs.track.offsetWidth / 100 * percent);
	    },
	    formatTime: function formatTime(second) {
	      second = Math.floor(second);
	      var hour = Math.floor(second / 60 / 60);

	      if (hour > 0) {
	        second -= hour * 60 * 60;
	      }

	      var minute = Math.floor(second / 60);

	      if (minute > 0) {
	        second -= minute * 60;
	      }

	      return (hour > 0 ? hour + ':' : '') + (hour > 0 ? minute.toString().padStart(2, "0") + ':' : minute + ':') + second.toString().padStart(2, "0");
	    },
	    registerPlayer: function registerPlayer(id) {
	      var _this = this;

	      if (id <= 0) {
	        return false;
	      }

	      var registry = this.$Bitrix.Data.get('ui-audioplayer-id', []);
	      registry = babelHelpers.toConsumableArray(new Set([].concat(babelHelpers.toConsumableArray(registry), [id]))).filter(function (id) {
	        return id !== _this.registeredId;
	      }).sort(function (a, b) {
	        return a - b;
	      });
	      this.$Bitrix.Data.set('ui-audioplayer-id', registry);
	      this.registeredId = id;
	      return true;
	    },
	    unregisterPlayer: function unregisterPlayer() {
	      var _this2 = this;

	      if (!this.registeredId) {
	        return true;
	      }

	      var registry = this.$Bitrix.Data.get('ui-audioplayer-id', []).filter(function (id) {
	        return id !== _this2.registeredId;
	      });
	      this.$Bitrix.Data.set('ui-audioplayer-id', registry);
	      this.registeredId = 0;
	      return true;
	    },
	    playNext: function playNext() {
	      var _this3 = this;

	      if (!this.registeredId || !this.autoPlayNext) {
	        return false;
	      }

	      var nextId = this.$Bitrix.Data.get('ui-audioplayer-id', []).filter(function (id) {
	        return id > _this3.registeredId;
	      }).slice(0, 1)[0];

	      if (nextId) {
	        this.$Bitrix.eventEmitter.emit('ui:audioplayer:play', {
	          id: nextId,
	          start: true
	        });
	      }

	      return true;
	    },
	    preloadNext: function preloadNext() {
	      var _this4 = this;

	      if (this.preloadRequestSent) {
	        return true;
	      }

	      if (!this.registeredId || !this.autoPlayNext) {
	        return false;
	      }

	      this.preloadRequestSent = true;
	      var nextId = this.$Bitrix.Data.get('ui-audioplayer-id', []).filter(function (id) {
	        return id > _this4.registeredId;
	      }).slice(0, 1)[0];

	      if (nextId) {
	        this.$Bitrix.eventEmitter.emit('ui:audioplayer:preload', {
	          id: nextId
	        });
	      }

	      return true;
	    },
	    onPlay: function onPlay(event) {
	      var data = event.getData();

	      if (data.id !== this.id) {
	        return false;
	      }

	      if (data.start) {
	        this.stop();
	      }

	      this.play();
	    },
	    onStop: function onStop(event) {
	      var data = event.getData();

	      if (data.initiator === this.id) {
	        return false;
	      }

	      this.stop();
	    },
	    onPause: function onPause(event) {
	      var data = event.getData();

	      if (data.initiator === this.id) {
	        return false;
	      }

	      this.pause();
	    },
	    onPreload: function onPreload(event) {
	      var data = event.getData();

	      if (data.id !== this.id) {
	        return false;
	      }

	      this.loadFile();
	    },
	    source: function source() {
	      return this.$refs.source;
	    },
	    audioEventRouter: function audioEventRouter(eventName, event) {
	      if (eventName === 'durationchange' || eventName === 'loadeddata' || eventName === 'loadedmetadata') {
	        this.timeTotal = this.source().duration;
	      } else if (eventName === 'abort' || eventName === 'error') {
	        console.error('BxAudioPlayer: load failed', this.id, event);
	        this.loading = false;
	        this.state = _State.none;
	        this.timeTotal = 0;
	        this.preload = 'none';
	      } else if (eventName === 'canplaythrough') {
	        this.loading = false;
	        this.loaded = true;
	      } else if (eventName === 'timeupdate') {
	        if (!this.source()) {
	          return;
	        }

	        this.timeCurrent = this.source().currentTime;
	        this.setProgress(Math.round(100 / this.timeTotal * this.timeCurrent));

	        if (this.state === _State.play && this.timeCurrent >= this.timeTotal) {
	          this.playNext();
	        }
	      } else if (eventName === 'pause') {
	        if (this.state !== _State.stop) {
	          this.state = _State.pause;
	        }
	      } else if (eventName === 'play') {
	        this.state = _State.play;

	        if (this.state === _State.stop) {
	          this.progress = 0;
	          this.timeCurrent = 0;
	        }

	        if (this.id > 0) {
	          this.$Bitrix.eventEmitter.emit('ui:audioplayer:pause', {
	            initiator: this.id
	          });
	        }
	      }
	    },
	    getObserver: function getObserver() {
	      var _this5 = this;

	      if (this.observer) {
	        return this.observer;
	      }

	      this.observer = new IntersectionObserver(function (entries, observer) {
	        entries.forEach(function (entry) {
	          if (entry.isIntersecting) {
	            if (_this5.preload === "none") {
	              _this5.preload = "metadata";

	              _this5.observer.unobserve(entry.target);
	            }
	          }
	        });
	      }, {
	        threshold: [0, 1]
	      });
	      return this.observer;
	    }
	  },
	  computed: {
	    State: function State() {
	      return _State;
	    },
	    seekPosition: function seekPosition() {
	      if (!this.loaded && !this.seek || this.isMobile) {
	        return 'display: none';
	      }

	      return "left: ".concat(this.seek, "px;");
	    },
	    progressPosition: function progressPosition() {
	      if (!this.loaded || this.state === _State.none) {
	        return "width: 100%;";
	      }

	      return "width: ".concat(this.progressInPixel, "px;");
	    },
	    labelTime: function labelTime() {
	      if (!this.loaded && !this.timeTotal) {
	        return '--:--';
	      }

	      var time;

	      if (this.state === _State.play) {
	        time = this.timeTotal - this.timeCurrent;
	      } else {
	        time = this.timeTotal;
	      }

	      return this.formatTime(time);
	    },
	    isMobile: function isMobile() {
	      var UA = navigator.userAgent.toLowerCase();
	      return UA.includes('android') || UA.includes('iphone') || UA.includes('ipad') || UA.includes('bitrixmobile');
	    }
	  },
	  template: "\n\t\t<div :class=\"['ui-vue-audioplayer-container', {\n\t\t\t\t'ui-vue-audioplayer-container-dark': isDark,\n\t\t\t\t'ui-vue-audioplayer-container-mobile': isMobile,\n\t\t\t}]\" ref=\"body\">\n\t\t\t<div class=\"ui-vue-audioplayer-controls-container\">\n\t\t\t\t<button :class=\"['ui-vue-audioplayer-control', {\n\t\t\t\t\t'ui-vue-audioplayer-control-loader': loading,\n\t\t\t\t\t'ui-vue-audioplayer-control-play': !loading && state !== State.play,\n\t\t\t\t\t'ui-vue-audioplayer-control-pause': !loading && state === State.play,\n\t\t\t\t}]\" @click=\"clickToButton\"></button>\n\t\t\t</div>\n\t\t\t<div class=\"ui-vue-audioplayer-timeline-container\">\n\t\t\t\t<div class=\"ui-vue-audioplayer-track-container\" @click=\"setPosition\" ref=\"track\">\n\t\t\t\t\t<div class=\"ui-vue-audioplayer-track-mask\"></div>\n\t\t\t\t\t<div class=\"ui-vue-audioplayer-track\" :style=\"progressPosition\"></div>\n\t\t\t\t\t<div class=\"ui-vue-audioplayer-track-seek\" :style=\"seekPosition\"></div>\n\t\t\t\t\t<div class=\"ui-vue-audioplayer-track-event\" @mousemove=\"seeking\"></div>\n\t\t\t\t</div>\n\t\t\t\t<div class=\"ui-vue-audioplayer-timers-container\">\n\t\t\t\t\t<div class=\"ui-vue-audioplayer-time-current\">{{labelTime}}</div>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t\t<audio v-if=\"src\" :src=\"src\" class=\"ui-vue-audioplayer-source\" ref=\"source\" :preload=\"preload\"\n\t\t\t\t@abort=\"audioEventRouter('abort', $event)\"\n\t\t\t\t@error=\"audioEventRouter('error', $event)\"\n\t\t\t\t@suspend=\"audioEventRouter('suspend', $event)\"\n\t\t\t\t@canplay=\"audioEventRouter('canplay', $event)\"\n\t\t\t\t@canplaythrough=\"audioEventRouter('canplaythrough', $event)\"\n\t\t\t\t@durationchange=\"audioEventRouter('durationchange', $event)\"\n\t\t\t\t@loadeddata=\"audioEventRouter('loadeddata', $event)\"\n\t\t\t\t@loadedmetadata=\"audioEventRouter('loadedmetadata', $event)\"\n\t\t\t\t@timeupdate=\"audioEventRouter('timeupdate', $event)\"\n\t\t\t\t@play=\"audioEventRouter('play', $event)\"\n\t\t\t\t@playing=\"audioEventRouter('playing', $event)\"\n\t\t\t\t@pause=\"audioEventRouter('pause', $event)\"\n\t\t\t></audio>\n\t\t</div>\n\t"
	});

}((this.window = this.window || {}),BX,BX,BX,BX.Event));





// file: /bitrix/js/ui/vue/directives/lazyload/dist/lazyload.bundle.js
(function (exports,ui_vue) {
	'use strict';

	/**
	 * Image Lazy Load Vue directive
	 *
	 * @package bitrix
	 * @subpackage ui
	 * @copyright 2001-2019 Bitrix
	 */
	var WATCH = 'bx-lazyload-watch';
	var LOADING = 'bx-lazyload-loading';
	var SUCCESS = 'bx-lazyload-success';
	var ERROR = 'bx-lazyload-error';
	var HIDDEN = 'bx-lazyload-hidden';
	var BLANK_IMAGE = "data:image/svg+xml,%3Csvg width='1px' height='1px' xmlns='http://www.w3.org/2000/svg'%3E%3C/svg%3E";
	var lazyloadObserver = null;

	var lazyloadLoadImage = function lazyloadLoadImage(currentImage, callback) {
	  var SUCCESS_CLASS = currentImage.dataset.lazyloadSuccessClass ? currentImage.dataset.lazyloadSuccessClass.split(" ") : [];
	  delete currentImage.dataset.lazyloadSuccessClass;
	  SUCCESS_CLASS = [SUCCESS].concat(babelHelpers.toConsumableArray(SUCCESS_CLASS));
	  var ERROR_CLASS = currentImage.dataset.lazyloadErrorClass ? currentImage.dataset.lazyloadErrorClass.split(" ") : [];
	  delete currentImage.dataset.lazyloadErrorClass;
	  ERROR_CLASS = [ERROR].concat(babelHelpers.toConsumableArray(ERROR_CLASS));
	  currentImage.classList.add(LOADING);
	  var newImage = new Image();
	  newImage.src = currentImage.dataset.lazyloadSrc;

	  if (!currentImage.dataset.lazyloadHiddenSrc) {
	    currentImage.dataset.lazyloadHiddenSrc = currentImage.src;
	  }

	  newImage.onload = function () {
	    var _currentImage$classLi;

	    if (currentImage.classList.contains(HIDDEN)) {
	      return false;
	    }

	    if (currentImage.dataset.lazyloadSrc) {
	      currentImage.src = currentImage.dataset.lazyloadSrc;
	    }

	    currentImage.classList.remove(LOADING);

	    (_currentImage$classLi = currentImage.classList).add.apply(_currentImage$classLi, babelHelpers.toConsumableArray(SUCCESS_CLASS));

	    if (typeof currentImage.lazyloadCallback === 'function') {
	      currentImage.lazyloadCallback({
	        element: currentImage,
	        state: 'success'
	      });
	      delete currentImage.lazyloadCallback;
	    }
	  };

	  newImage.onerror = function () {
	    var _currentImage$classLi2;

	    if (currentImage.classList.contains(HIDDEN)) {
	      return false;
	    }

	    currentImage.classList.remove(LOADING);

	    (_currentImage$classLi2 = currentImage.classList).add.apply(_currentImage$classLi2, babelHelpers.toConsumableArray(ERROR_CLASS));

	    currentImage.title = '';
	    currentImage.alt = '';

	    if (typeof currentImage.lazyloadCallback === 'function') {
	      currentImage.lazyloadCallback({
	        element: currentImage,
	        state: 'error'
	      });
	      delete currentImage.lazyloadCallback;
	    } else {
	      currentImage.src = BLANK_IMAGE;
	    }
	  };

	  if (typeof currentImage.dataset.lazyloadDontHide !== 'undefined') {
	    currentImage.classList.remove(WATCH);
	    delete currentImage.dataset.lazyloadDontHide;

	    if (lazyloadObserver) {
	      lazyloadObserver.unobserve(currentImage);
	    }
	  }
	};

	if (typeof window.IntersectionObserver !== 'undefined') {
	  lazyloadObserver = new IntersectionObserver(function (entries, observer) {
	    entries.forEach(function (entry) {
	      var currentImage = entry.target;

	      if (currentImage.classList.contains(ERROR)) {
	        return true;
	      }

	      if (entry.isIntersecting) {
	        if (currentImage.classList.contains(HIDDEN)) {
	          if (currentImage.dataset.lazyloadSrc) {
	            currentImage.src = currentImage.dataset.lazyloadSrc;
	          }

	          currentImage.classList.remove(HIDDEN);
	        } else if (currentImage.classList.contains(WATCH)) {
	          return true;
	        } else {
	          currentImage.classList.add(WATCH);
	          lazyloadLoadImage(currentImage);
	        }
	      } else {
	        if (currentImage.classList.contains(HIDDEN) || !currentImage.classList.contains(WATCH)) {
	          return true;
	        }

	        if (currentImage.dataset.lazyloadHiddenSrc) {
	          currentImage.src = currentImage.dataset.lazyloadHiddenSrc;
	        }

	        currentImage.classList.remove(LOADING);
	        currentImage.classList.add(HIDDEN);
	      }
	    });
	  }, {
	    threshold: [0, 1]
	  });
	}

	ui_vue.WidgetBitrixVue.directive('bx-lazyload', {
	  bind: function bind(element, bindings) {
	    if (babelHelpers["typeof"](bindings.value) === 'object' && typeof bindings.value.callback === 'function') {
	      element.lazyloadCallback = bindings.value.callback;
	    }

	    if (!element.src || element.src === location.href.replace(location.hash, '')) {
	      element.src = BLANK_IMAGE;
	    }

	    if (lazyloadObserver) {
	      lazyloadObserver.observe(element);
	    } else {
	      lazyloadLoadImage(element);
	    }
	  },
	  componentUpdated: function componentUpdated(element) {
	    if (!element.classList.contains(SUCCESS) && !element.classList.contains(ERROR) && !element.classList.contains(WATCH) && !element.classList.contains(LOADING)) {
	      element.classList.add(LOADING);
	    } else if ((element.classList.contains(SUCCESS) || element.classList.contains(ERROR)) && element.dataset.lazyloadSrc && element.dataset.lazyloadSrc !== element.src) {
	      if (!element.dataset.lazyloadSrc.startsWith('http')) {
	        var url = document.createElement('a');
	        url.href = element.dataset.lazyloadSrc;

	        if (url.href === element.src) {
	          return;
	        }
	      }

	      lazyloadLoadImage(element);
	    }
	  },
	  unbind: function unbind(element) {
	    if (lazyloadObserver) {
	      lazyloadObserver.unobserve(element);
	    }
	  }
	});

}((this.window = this.window || {}),BX));





// file: /bitrix/js/ui/vue/components/socialvideo/dist/socialvideo.bundle.js
(function (exports,ui_fonts_opensans,ui_vue_directives_lazyload,main_polyfill_intersectionobserver,ui_vue,main_core_events) {
	'use strict';

	/**
	 * Bitrix UI
	 * Social Video Vue component
	 *
	 * @package bitrix
	 * @subpackage ui
	 * @copyright 2001-2021 Bitrix
	 */

	var _State = Object.freeze({
	  play: 'play',
	  pause: 'pause',
	  stop: 'stop',
	  none: 'none'
	});

	ui_vue.WidgetBitrixVue.component('bx-socialvideo', {
	  props: {
	    id: {
	      "default": 0
	    },
	    src: {
	      "default": ''
	    },
	    preview: {
	      "default": ''
	    },
	    autoplay: {
	      "default": true
	    },
	    containerClass: {
	      "default": null
	    },
	    containerStyle: {
	      "default": null
	    },
	    elementStyle: {
	      "default": null
	    },
	    showControls: {
	      "default": true
	    }
	  },
	  data: function data() {
	    return {
	      preload: "none",
	      previewLoaded: false,
	      loaded: false,
	      loading: false,
	      playAfterLoad: false,
	      enterFullscreen: false,
	      playBeforeMute: 2,
	      state: _State.none,
	      progress: 0,
	      timeCurrent: 0,
	      timeTotal: 0,
	      muteFlag: true
	    };
	  },
	  created: function created() {
	    if (!this.preview) {
	      this.previewLoaded = true;
	      this.preload = 'metadata';
	    }

	    this.$Bitrix.eventEmitter.subscribe('ui:socialvideo:unmute', this.onUnmute);
	  },
	  mounted: function mounted() {
	    this.getObserver().observe(this.$refs.body);
	  },
	  beforeDestroy: function beforeDestroy() {
	    this.$Bitrix.eventEmitter.unsubscribe('ui:socialvideo:unmute', this.onUnmute);
	    this.getObserver().unobserve(this.$refs.body);
	  },
	  watch: {
	    id: function id(value) {
	      this.registeredId = value;
	    }
	  },
	  methods: {
	    loadFile: function loadFile() {
	      var play = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

	      if (this.loaded) {
	        return true;
	      }

	      if (this.loading) {
	        return true;
	      }

	      this.preload = 'auto';
	      this.loading = true;
	      this.playAfterLoad = play;
	      return true;
	    },
	    clickToButton: function clickToButton(event) {
	      if (!this.src) {
	        return false;
	      }

	      if (this.state === _State.play) {
	        this.getObserver().unobserve(this.$refs.body);
	        this.pause();
	      } else {
	        this.play();
	      }

	      event.stopPropagation();
	    },
	    clickToMute: function clickToMute() {
	      if (!this.src) {
	        return false;
	      }

	      if (!this.muteFlag) {
	        this.mute();
	      } else {
	        this.unmute();
	      }

	      event.stopPropagation();
	    },
	    click: function click(event) {
	      if (this.autoPlayDisabled) {
	        this.play();
	        event.stopPropagation();
	        return false;
	      }

	      if (this.isMobile) {
	        if (this.source().webkitEnterFullscreen) {
	          this.unmute();
	          this.enterFullscreen = true;
	          this.source().webkitEnterFullscreen();
	        } else if (this.source().requestFullscreen) {
	          this.unmute();
	          this.enterFullscreen = true;
	          this.source().requestFullscreen();
	        } else {
	          this.$emit('click', event);
	        }
	      } else {
	        this.$emit('click', event);
	      }

	      event.stopPropagation();
	    },
	    play: function play(event) {
	      if (!this.loaded) {
	        this.loadFile(true);
	        return false;
	      }

	      if (!this.source()) {
	        return false;
	      }

	      this.source().play();
	    },
	    pause: function pause() {
	      if (!this.source()) {
	        return false;
	      }

	      this.playAfterLoad = false;
	      this.source().pause();
	    },
	    stop: function stop() {
	      if (!this.source()) {
	        return false;
	      }

	      this.state = _State.stop;
	      this.source().pause();
	    },
	    mute: function mute() {
	      if (!this.source()) {
	        return false;
	      }

	      this.muteFlag = true;
	      this.playBeforeMute = 2;
	      this.source().muted = true;
	    },
	    unmute: function unmute() {
	      if (!this.source()) {
	        return false;
	      }

	      this.muteFlag = false;
	      this.source().muted = false;

	      if (this.id > 0) {
	        this.$Bitrix.eventEmitter.emit('ui:socialvideo:unmute', {
	          initiator: this.id
	        });
	      }
	    },
	    setProgress: function setProgress(percent) {
	      this.progress = percent;
	    },
	    formatTime: function formatTime(second) {
	      second = Math.floor(second);
	      var hour = Math.floor(second / 60 / 60);

	      if (hour > 0) {
	        second -= hour * 60 * 60;
	      }

	      var minute = Math.floor(second / 60);

	      if (minute > 0) {
	        second -= minute * 60;
	      }

	      return (hour > 0 ? hour + ':' : '') + (hour > 0 ? minute.toString().padStart(2, "0") + ':' : minute + ':') + second.toString().padStart(2, "0");
	    },
	    onUnmute: function onUnmute(event) {
	      event = event.getData();

	      if (event.initiator === this.id) {
	        return false;
	      }

	      this.mute();
	    },
	    source: function source() {
	      return this.$refs.source;
	    },
	    videoEventRouter: function videoEventRouter(eventName, event) {
	      if (eventName === 'durationchange' || eventName === 'loadeddata') {
	        if (!this.source()) {
	          return false;
	        }

	        this.timeTotal = this.source().duration;
	      } else if (eventName === 'loadedmetadata') {
	        if (!this.source()) {
	          return false;
	        }

	        this.timeTotal = this.source().duration;
	        this.loaded = true;

	        if (this.playAfterLoad) {
	          this.play();
	        }
	      } else if (eventName === 'abort' || eventName === 'error') {
	        console.error('BxSocialVideo: load failed', this.id, event);
	        this.loading = false;
	        this.state = _State.none;
	        this.timeTotal = 0;
	        this.preload = 'none';
	      } else if (eventName === 'canplaythrough') {
	        this.loading = false;
	        this.loaded = true;

	        if (this.playAfterLoad) {
	          this.play();
	        }
	      } else if (eventName === 'volumechange') {
	        if (!this.source()) {
	          return false;
	        }

	        if (this.source().muted) {
	          this.mute();
	        } else {
	          this.unmute();
	        }
	      } else if (eventName === 'timeupdate') {
	        if (!this.source()) {
	          return false;
	        }

	        this.timeCurrent = this.source().currentTime;

	        if (!this.muteFlag && !this.enterFullscreen && this.timeCurrent === 0) {
	          if (this.playBeforeMute <= 0) {
	            this.mute();
	          }

	          this.playBeforeMute -= 1;
	        }

	        this.setProgress(Math.round(100 / this.timeTotal * this.timeCurrent));
	      } else if (eventName === 'pause') {
	        if (this.state !== _State.stop) {
	          this.state = _State.pause;
	        }

	        if (this.enterFullscreen) {
	          this.enterFullscreen = false;
	          this.mute();
	          this.play();
	        }
	      } else if (eventName === 'play') {
	        this.state = _State.play;

	        if (this.state === _State.stop) {
	          this.progress = 0;
	          this.timeCurrent = 0;
	        }

	        if (this.enterFullscreen) {
	          this.enterFullscreen = false;
	        }
	      }
	    },
	    getObserver: function getObserver() {
	      var _this = this;

	      if (this.observer) {
	        return this.observer;
	      }

	      this.observer = new IntersectionObserver(function (entries, observer) {
	        if (_this.autoPlayDisabled) {
	          return false;
	        }

	        entries.forEach(function (entry) {
	          if (entry.isIntersecting) {
	            _this.play();
	          } else {
	            _this.pause();
	          }
	        });
	      }, {
	        threshold: [0, 1]
	      });
	      return this.observer;
	    },
	    lazyLoadCallback: function lazyLoadCallback(element) {
	      this.previewLoaded = element.state === 'success';
	    }
	  },
	  computed: {
	    State: function State() {
	      return _State;
	    },
	    autoPlayDisabled: function autoPlayDisabled() {
	      return !this.autoplay && this.state === _State.none;
	    },
	    showStartButton: function showStartButton() {
	      return this.autoPlayDisabled && this.previewLoaded;
	    },
	    showInterface: function showInterface() {
	      return this.previewLoaded && !this.showStartButton;
	    },
	    labelTime: function labelTime() {
	      if (!this.loaded && !this.timeTotal) {
	        return '--:--';
	      }

	      var time;

	      if (this.state === _State.play) {
	        time = this.timeTotal - this.timeCurrent;
	      } else {
	        time = this.timeTotal;
	      }

	      return this.formatTime(time);
	    },
	    isMobile: function isMobile() {
	      var UA = navigator.userAgent.toLowerCase();
	      return UA.includes('android') || UA.includes('iphone') || UA.includes('ipad') || UA.includes('bitrixmobile');
	    }
	  },
	  template: "\n\t\t<div :class=\"['ui-vue-socialvideo', containerClass, {\n\t\t\t\t'ui-vue-socialvideo-mobile': isMobile,\n\t\t\t}]\" :style=\"containerStyle\" @click=\"click\">\n\t\t\t<transition name=\"ui-vue-socialvideo-animation-fade\">\n\t\t\t\t<div v-if=\"showStartButton && showControls\" class=\"ui-vue-socialvideo-button-start\">\n\t\t\t\t\t<span class=\"ui-vue-socialvideo-button-start-icon\"></span>\n\t\t\t\t</div>\n\t\t\t</transition>\n\t\t\t<transition name=\"ui-vue-socialvideo-animation-fade\">\n\t\t\t\t<div v-if=\"showInterface && showControls\" class=\"ui-vue-socialvideo-overlay-container\">\n\t\t\t\t\t<div class=\"ui-vue-socialvideo-controls-container\" @click=\"clickToButton\">\n\t\t\t\t\t\t<button :class=\"['ui-vue-socialvideo-control', {\n\t\t\t\t\t\t\t'ui-vue-socialvideo-control-loader': loading,\n\t\t\t\t\t\t\t'ui-vue-socialvideo-control-play': !loading && state !== State.play,\n\t\t\t\t\t\t\t'ui-vue-socialvideo-control-pause': !loading && state === State.play,\n\t\t\t\t\t\t}]\"></button>\n\t\t\t\t\t</div>\n\t\t\t\t\t<div class=\"ui-vue-socialvideo-info-container\" @click=\"clickToMute\">\n\t\t\t\t\t\t<span class=\"ui-vue-socialvideo-time-current\">{{labelTime}}</span>\n\t\t\t\t\t\t<span :class=\"['ui-vue-socialvideo-sound', {\n\t\t\t\t\t\t\t'ui-vue-socialvideo-sound-on': state !== State.none && !muteFlag,\n\t\t\t\t\t\t\t'ui-vue-socialvideo-sound-off': state !== State.none && muteFlag\n\t\t\t\t\t\t}]\"></span>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t</transition>\n\t\t\t<div v-if=\"!preview\" class=\"ui-vue-socialvideo-background\" :style=\"{position: (src? 'absolute': 'relative')}\"></div>\n\t\t\t<div class=\"ui-vue-socialvideo-container\" ref=\"body\">\n\t\t\t\t<img \n\t\t\t\t\tv-bx-lazyload=\"{callback: lazyLoadCallback}\"\n\t\t\t\t\tdata-lazyload-dont-hide\n\t\t\t\t\tv-if=\"preview\"\n\t\t\t\t\tclass=\"ui-vue-socialvideo-image-source\"\n\t\t\t\t\t:data-lazyload-src=\"preview\"\n\t\t\t\t\t:style=\"{position: (src? 'absolute': 'relative'), ...elementStyle}\"\n\t\t\t\t/>\n\t\t\t\t<video \n\t\t\t\t\tv-if=\"src\" :src=\"src\" \n\t\t\t\t\tclass=\"ui-vue-socialvideo-source\" \n\t\t\t\t\tref=\"source\"\n\t\t\t\t\t:preload=\"preload\" \n\t\t\t\t\tplaysinline\n\t\t\t\t\tloop \n\t\t\t\t\tmuted\n\t\t\t\t\t:style=\"{opacity: (loaded? 1: 0), ...elementStyle}\"\n\t\t\t\t\t@abort=\"videoEventRouter('abort', $event)\"\n\t\t\t\t\t@error=\"videoEventRouter('error', $event)\"\n\t\t\t\t\t@suspend=\"videoEventRouter('suspend', $event)\"\n\t\t\t\t\t@canplay=\"videoEventRouter('canplay', $event)\"\n\t\t\t\t\t@canplaythrough=\"videoEventRouter('canplaythrough', $event)\"\n\t\t\t\t\t@durationchange=\"videoEventRouter('durationchange', $event)\"\n\t\t\t\t\t@loadeddata=\"videoEventRouter('loadeddata', $event)\"\n\t\t\t\t\t@loadedmetadata=\"videoEventRouter('loadedmetadata', $event)\"\n\t\t\t\t\t@volumechange=\"videoEventRouter('volumechange', $event)\"\n\t\t\t\t\t@timeupdate=\"videoEventRouter('timeupdate', $event)\"\n\t\t\t\t\t@play=\"videoEventRouter('play', $event)\"\n\t\t\t\t\t@playing=\"videoEventRouter('playing', $event)\"\n\t\t\t\t\t@pause=\"videoEventRouter('pause', $event)\"\n\t\t\t\t></video>\n\t\t\t</div>\n\t\t</div>\t\n\t"
	});

}((this.window = this.window || {}),BX,window,BX,BX,BX.Event));





// file: /bitrix/js/im/view/element/media/dist/media.bundle.js
(function (exports,ui_progressbarjs_uploader,ui_vue_vuex,im_model,main_core_events,im_const,ui_vue_components_audioplayer,ui_designTokens,ui_vue_directives_lazyload,ui_icons,ui_vue_components_socialvideo,im_lib_utils,ui_vue) {
	'use strict';

	function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
	function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { babelHelpers.defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
	ui_vue.WidgetBitrixVue.component('bx-im-view-element-file', {
	  /*
	   * @emits EventType.dialog.clickOnUploadCancel {file: object, event: MouseEvent}
	   */
	  mounted: function mounted() {
	    this.createProgressbar();
	  },
	  beforeDestroy: function beforeDestroy() {
	    this.removeProgressbar();
	  },
	  props: {
	    userId: {
	      "default": 0
	    },
	    messageType: {
	      "default": im_const.MessageType.self
	    },
	    file: {
	      type: Object,
	      required: true
	    }
	  },
	  methods: {
	    download: function download(file) {
	      if (file.progress !== 100) {
	        return false;
	      }
	      if (BX.UI && BX.UI.Viewer && Object.keys(file.viewerAttrs).length > 0) {
	        return false;
	      }
	      if (file.type === im_const.FileType.image && file.urlShow) {
	        if (im_lib_utils.Utils.platform.isBitrixMobile()) {
	          BXMobileApp.UI.Photo.show({
	            photos: this.files.collection[this.application.dialog.chatId].filter(function (file) {
	              return file.type === 'image';
	            }).map(function (file) {
	              return {
	                url: file.urlShow.replace('bxhttp', 'http')
	              };
	            }).reverse(),
	            default_photo: file.urlShow.replace('bxhttp', 'http')
	          });
	        } else {
	          window.open(file.urlShow, '_blank');
	        }
	      } else if (file.type === im_const.FileType.video && file.urlShow) {
	        if (im_lib_utils.Utils.platform.isBitrixMobile()) {
	          app.openDocument({
	            url: file.urlShow,
	            name: file.name
	          });
	        } else {
	          window.open(file.urlShow, '_blank');
	        }
	      } else if (file.urlDownload) {
	        if (im_lib_utils.Utils.platform.isBitrixMobile()) {
	          app.openDocument({
	            url: file.urlDownload,
	            name: file.name
	          });
	        } else {
	          window.open(file.urlDownload, '_blank');
	        }
	      } else {
	        if (im_lib_utils.Utils.platform.isBitrixMobile()) {
	          app.openDocument({
	            url: file.urlShow,
	            name: file.name
	          });
	        } else {
	          window.open(file.urlShow, '_blank');
	        }
	      }
	    },
	    createProgressbar: function createProgressbar() {
	      var _this = this;
	      if (this.uploader) {
	        return true;
	      }
	      if (this.file.progress === 100) {
	        return false;
	      }
	      var blurElement = undefined;
	      if (this.file.progress < 0 || this.file.type !== im_const.FileType.image && this.file.type !== im_const.FileType.video) {
	        blurElement = false;
	      }
	      this.uploader = new ui_progressbarjs_uploader.Uploader({
	        container: this.$refs.container,
	        blurElement: blurElement,
	        direction: this.$refs.container.offsetHeight > 54 ? ui_progressbarjs_uploader.Uploader.direction.vertical : ui_progressbarjs_uploader.Uploader.direction.horizontal,
	        icon: this.file.progress < 0 ? ui_progressbarjs_uploader.Uploader.icon.cloud : ui_progressbarjs_uploader.Uploader.icon.cancel,
	        sizes: {
	          circle: this.$refs.container.offsetHeight > 54 ? 54 : 38,
	          progress: this.$refs.container.offsetHeight > 54 ? 4 : 8
	        },
	        labels: {
	          loading: this.localize['IM_MESSENGER_ELEMENT_FILE_UPLOAD_LOADING'],
	          completed: this.localize['IM_MESSENGER_ELEMENT_FILE_UPLOAD_COMPLETED'],
	          canceled: this.localize['IM_MESSENGER_ELEMENT_FILE_UPLOAD_CANCELED'],
	          cancelTitle: this.localize['IM_MESSENGER_ELEMENT_FILE_UPLOAD_CANCEL_TITLE'],
	          megabyte: this.localize['IM_MESSENGER_ELEMENT_FILE_SIZE_MB']
	        },
	        cancelCallback: this.file.progress < 0 ? null : function (event) {
	          main_core_events.EventEmitter.emit(im_const.EventType.dialog.clickOnUploadCancel, {
	            file: _this.file,
	            event: event
	          });
	        },
	        destroyCallback: function destroyCallback() {
	          if (_this.uploader) {
	            _this.uploader = null;
	          }
	        }
	      });
	      this.uploader.start();
	      if (this.file.size && this.file.size / 1024 / 1024 <= 2 || this.$refs.container.offsetHeight <= 54 && this.$refs.container.offsetWidth < 240) {
	        this.uploader.setProgressTitleVisibility(false);
	      }
	      this.updateProgressbar();
	      return true;
	    },
	    updateProgressbar: function updateProgressbar() {
	      if (!this.uploader) {
	        var result = this.createProgressbar();
	        if (!result) {
	          return false;
	        }
	      }
	      if (this.file.status === im_const.FileStatus.error) {
	        this.uploader.setProgress(0);
	        this.uploader.setCancelDisable(false);
	        this.uploader.setIcon(ui_progressbarjs_uploader.Uploader.icon.error);
	        this.uploader.setProgressTitle(this.localize['IM_MESSENGER_ELEMENT_FILE_UPLOAD_ERROR']);
	      } else if (this.file.status === im_const.FileStatus.wait) {
	        this.uploader.setProgress(this.file.progress > 5 ? this.file.progress : 5);
	        this.uploader.setCancelDisable(true);
	        this.uploader.setIcon(ui_progressbarjs_uploader.Uploader.icon.cloud);
	        this.uploader.setProgressTitle(this.localize['IM_MESSENGER_ELEMENT_FILE_UPLOAD_SAVING']);
	      } else if (this.file.progress === 100) {
	        this.uploader.setProgress(100);
	      } else if (this.file.progress === -1) {
	        this.uploader.setProgress(10);
	        this.uploader.setProgressTitle(this.localize['IM_MESSENGER_ELEMENT_FILE_UPLOAD_WAITING']);
	      } else {
	        if (this.file.progress === 0) {
	          this.uploader.setIcon(ui_progressbarjs_uploader.Uploader.icon.cancel);
	        }
	        var progress = this.file.progress > 5 ? this.file.progress : 5;
	        this.uploader.setProgress(progress);
	        if (this.file.size / 1024 / 1024 <= 2) {
	          this.uploader.setProgressTitle(this.localize['IM_MESSENGER_ELEMENT_FILE_UPLOAD_LOADING']);
	        } else {
	          this.uploader.setByteSent(this.file.size / 100 * this.file.progress, this.file.size);
	        }
	      }
	    },
	    removeProgressbar: function removeProgressbar() {
	      if (!this.uploader) {
	        return true;
	      }
	      this.uploader.destroy(false);
	      return true;
	    }
	  },
	  computed: _objectSpread({
	    FileStatus: function FileStatus() {
	      return im_const.FileStatus;
	    },
	    localize: function localize() {
	      return ui_vue.WidgetBitrixVue.getFilteredPhrases('IM_MESSENGER_ELEMENT_FILE_', this);
	    },
	    fileName: function fileName() {
	      var maxLength = 70;
	      if (this.file.name.length < maxLength) {
	        return this.file.name;
	      }
	      var endWordLength = 10;
	      var secondPart = this.file.name.substring(this.file.name.length - 1 - (this.file.extension.length + 1 + endWordLength));
	      var firstPart = this.file.name.substring(0, maxLength - secondPart.length - 3);
	      return firstPart.trim() + '...' + secondPart.trim();
	    },
	    fileSize: function fileSize() {
	      var size = this.file.size;
	      if (size <= 0) {
	        return '&nbsp;';
	      }
	      var sizes = ["BYTE", "KB", "MB", "GB", "TB"];
	      var position = 0;
	      while (size >= 1024 && position < 4) {
	        size /= 1024;
	        position++;
	      }
	      return Math.round(size) + " " + this.localize['IM_MESSENGER_ELEMENT_FILE_SIZE_' + sizes[position]];
	    },
	    uploadProgress: function uploadProgress() {
	      return this.file.status + ' ' + this.file.progress;
	    }
	  }, ui_vue_vuex.WidgetVuex.mapState({
	    application: function application(state) {
	      return state.application;
	    },
	    files: function files(state) {
	      return state.files;
	    }
	  })),
	  watch: {
	    uploadProgress: function uploadProgress() {
	      this.updateProgressbar();
	    }
	  },
	  template: "\n\t\t<div class=\"bx-im-element-file\" @click=\"download(file, $event)\" ref=\"container\">\n\t\t\t<div class=\"bx-im-element-file-icon\">\n\t\t\t\t<div :class=\"['ui-icon', 'ui-icon-file-'+file.icon]\"><i></i></div>\n\t\t\t</div>\n\t\t\t<div class=\"bx-im-element-file-block\">\n\t\t\t\t<div class=\"bx-im-element-file-name\" :title=\"file.name\">\n\t\t\t\t\t{{fileName}}\n\t\t\t\t</div>\n\t\t\t\t<div class=\"bx-im-element-file-size\" v-html=\"fileSize\"></div>\n\t\t\t</div>\n\t\t</div>\n\t"
	});

	/**
	 * Bitrix Messenger
	 * File element Vue component
	 *
	 * @package bitrix
	 * @subpackage im
	 * @copyright 2001-2019 Bitrix
	 */
	ui_vue.WidgetVue.cloneComponent('bx-im-view-element-file-audio', 'bx-im-view-element-file', {
	  computed: {
	    background: function background() {
	      return this.messageType === im_const.MessageType.self ? 'dark' : 'light';
	    }
	  },
	  template: "\n\t\t<div :class=\"['bx-im-element-file-audio', 'bx-im-element-file-audio-'+messageType]\" ref=\"container\">\n\t\t\t<bx-audioplayer :id=\"file.id\" :src=\"file.urlShow\" :background=\"background\"/>\n\t\t</div>\t\n\t"
	});

	/**
	 * Bitrix Messenger
	 * File element Vue component
	 *
	 * @package bitrix
	 * @subpackage im
	 * @copyright 2001-2019 Bitrix
	 */
	ui_vue.WidgetVue.cloneComponent('bx-im-view-element-file-image', 'bx-im-view-element-file', {
	  methods: {
	    getImageSize: function getImageSize(width, height, maxWidth) {
	      var aspectRatio;
	      if (width > maxWidth) {
	        aspectRatio = maxWidth / width;
	      } else {
	        aspectRatio = 1;
	      }
	      return {
	        width: width * aspectRatio,
	        height: height * aspectRatio
	      };
	    }
	  },
	  computed: {
	    styleFileSizes: function styleFileSizes() {
	      var sizes = this.getImageSize(this.file.image.width, this.file.image.height, 280);
	      return {
	        width: sizes.width + 'px',
	        height: sizes.height + 'px',
	        backgroundSize: sizes.width < 100 || sizes.height < 100 ? 'contain' : 'initial'
	      };
	    },
	    styleBoxSizes: function styleBoxSizes() {
	      if (parseInt(this.styleFileSizes.height) <= 280) {
	        return {};
	      }
	      return {
	        height: '280px'
	      };
	    },
	    fileSource: function fileSource() {
	      return this.file.urlPreview;
	    }
	  },
	  template: "\n\t\t<div class=\"bx-im-element-file-image\" @click=\"download(file, $event)\" :style=\"styleBoxSizes\" ref=\"container\">\n\t\t\t<img v-bx-lazyload\n\t\t\t\tclass=\"bx-im-element-file-image-source\"\n\t\t\t\t:data-lazyload-src=\"fileSource\"\n\t\t\t\t:title=\"$Bitrix.Loc.getMessage('IM_MESSENGER_ELEMENT_FILE_SHOW_TITLE').replace('#NAME#', file.name).replace('#SIZE#', fileSize)\"\n\t\t\t\t:style=\"styleFileSizes\"\n\t\t\t\t:data-viewer=\"file.viewerAttrs.viewer === null\"\n\t\t\t\t:data-viewer-type=\"file.viewerAttrs.viewerType? file.viewerAttrs.viewerType: false\"\n\t\t\t\t:data-src=\"file.viewerAttrs.src? file.viewerAttrs.src: false\"\n\t\t\t\t:data-viewer-group-by=\"file.viewerAttrs.viewerGroupBy? file.viewerAttrs.viewerGroupBy: false\"\n\t\t\t\t:data-title=\"file.viewerAttrs.title? file.viewerAttrs.title: false\"\n\t\t\t\t:data-actions=\"file.viewerAttrs.actions? file.viewerAttrs.actions: false\"\n\t\t\t/>\n\t\t</div>\n\t"
	});

	/**
	 * Bitrix Messenger
	 * File element Vue component
	 *
	 * @package bitrix
	 * @subpackage im
	 * @copyright 2001-2019 Bitrix
	 */
	ui_vue.WidgetVue.cloneComponent('bx-im-view-element-file-video', 'bx-im-view-element-file', {
	  methods: {
	    getImageSize: function getImageSize(width, height, maxWidth) {
	      var aspectRatio;
	      if (width > maxWidth) {
	        aspectRatio = maxWidth / width;
	      } else {
	        aspectRatio = 1;
	      }
	      return {
	        width: width * aspectRatio,
	        height: height * aspectRatio
	      };
	    }
	  },
	  computed: {
	    isSafari: function isSafari() {
	      return im_lib_utils.Utils.browser.isSafari() || im_lib_utils.Utils.platform.isBitrixMobile();
	    },
	    styleBoxSizes: function styleBoxSizes() {
	      if (parseInt(this.styleVideoSizes.height) <= 280) {
	        return {};
	      }
	      return {
	        height: '280px'
	      };
	    },
	    styleVideoSizes: function styleVideoSizes() {
	      if (!this.file.image) {
	        return {};
	      }
	      var sizes = this.getImageSize(this.file.image.width, this.file.image.height, 280);
	      return {
	        width: sizes.width + 'px',
	        height: sizes.height + 'px',
	        backgroundSize: sizes.width < 100 || sizes.height < 100 ? 'contain' : 'initial'
	      };
	    },
	    autoplay: function autoplay() {
	      return this.file.size < 5000000 && this.application.options.autoplayVideo;
	    }
	  },
	  template: "\n\t\t<div :class=\"['bx-im-element-file-video', {'bx-im-element-file-video-safari': isSafari}]\" :style=\"styleBoxSizes\" ref=\"container\">\n\t\t\t<bx-socialvideo \n\t\t\t\t:id=\"file.id\" \n\t\t\t\t:src=\"file.urlShow\" \n\t\t\t\t:preview=\"file.urlPreview\" \n\t\t\t\t:containerStyle=\"styleBoxSizes\"\n\t\t\t\t:elementStyle=\"styleVideoSizes\"\n\t\t\t\t:autoplay=\"autoplay\"\n\t\t\t\t:showControls=\"!file.viewerAttrs.viewerType\"\n\t\t\t\t:data-viewer=\"file.viewerAttrs.viewer === null\"\n\t\t\t\t:data-viewer-type=\"file.viewerAttrs.viewerType? file.viewerAttrs.viewerType: false\"\n\t\t\t\t:data-src=\"file.viewerAttrs.src? file.viewerAttrs.src: false\"\n\t\t\t\t:data-viewer-group-by=\"file.viewerAttrs.viewerGroupBy? file.viewerAttrs.viewerGroupBy: false\"\n\t\t\t\t:data-title=\"file.viewerAttrs.title? file.viewerAttrs.title: false\"\n\t\t\t\t:data-actions=\"file.viewerAttrs.action? file.viewerAttrs.actions: false\"\n\t\t\t\t@click=\"download(file, $event)\"\n\t\t\t/>\n\t\t</div>\n\t"
	});

}((this.window = this.window || {}),BX.ProgressBarJs,BX,BX.Messenger.Model,BX.Event,BX.Messenger.Const,window,BX,window,BX,window,BX.Messenger.Lib,BX));





// file: /bitrix/js/im/view/element/attach/dist/attach.bundle.js
(function (exports,ui_designTokens,ui_icons_disk,ui_vue_directives_lazyload,im_model,im_lib_utils,ui_vue) {
	'use strict';

	/**
	 * Bitrix Messenger
	 * Vue component
	 *
	 * Delimiter (attach type)
	 *
	 * @package bitrix
	 * @subpackage im
	 * @copyright 2001-2019 Bitrix
	 */
	var AttachTypeDelimiter = {
	  property: 'DELIMITER',
	  name: 'bx-im-view-element-attach-delimiter',
	  component: {
	    props: {
	      config: {
	        type: Object,
	        "default": {}
	      },
	      color: {
	        type: String,
	        "default": 'transparent'
	      }
	    },
	    computed: {
	      styles: function styles() {
	        return {
	          width: this.config.DELIMITER.SIZE ? this.config.DELIMITER.SIZE + 'px' : '',
	          backgroundColor: this.config.DELIMITER.COLOR ? this.config.DELIMITER.COLOR : this.color
	        };
	      }
	    },
	    template: "<div class=\"bx-im-element-attach-type-delimiter\" :style=\"styles\"></div>"
	  }
	};

	/**
	 * Bitrix Messenger
	 * Vue component
	 *
	 * File (attach type)
	 *
	 * @package bitrix
	 * @subpackage im
	 * @copyright 2001-2019 Bitrix
	 */
	var AttachTypeFile = {
	  property: 'FILE',
	  name: 'bx-im-element-attach-file',
	  component: {
	    props: {
	      config: {
	        type: Object,
	        "default": {}
	      },
	      color: {
	        type: String,
	        "default": 'transparent'
	      }
	    },
	    methods: {
	      openLink: function openLink(element) {
	        im_lib_utils.Utils.platform.openNewPage(element.LINK);
	      },
	      file: function file() {
	        return {
	          name: this.config.FILE.NAME,
	          extension: this.config.FILE.NAME.split('.').splice(-1)[0],
	          size: this.config.FILE.SIZE
	        };
	      },
	      fileName: function fileName(element) {
	        var maxLength = 70;
	        if (!element.NAME || element.NAME.length < maxLength) {
	          return element.NAME;
	        }
	        var endWordLength = 10;
	        var extension = element.NAME.split('.').splice(-1)[0];
	        var secondPart = element.NAME.substring(element.NAME.length - 1 - (extension.length + 1 + endWordLength));
	        var firstPart = element.NAME.substring(0, maxLength - secondPart.length - 3);
	        return firstPart.trim() + '...' + secondPart.trim();
	      },
	      fileNameFull: function fileNameFull(element) {
	        return element.NAME;
	      },
	      fileSize: function fileSize(element) {
	        var size = element.SIZE;
	        if (!size || size <= 0) {
	          size = 0;
	        }
	        var sizes = ["BYTE", "KB", "MB", "GB", "TB"];
	        var position = 0;
	        while (size >= 1024 && position < 4) {
	          size /= 1024;
	          position++;
	        }
	        return Math.round(size) + " " + this.$Bitrix.Loc.getMessage('IM_MESSENGER_ATTACH_FILE_SIZE_' + sizes[position]);
	      },
	      fileIcon: function fileIcon(element) {
	        return im_model.FilesModel.getIconType(element.NAME.split('.').splice(-1)[0]);
	      }
	    },
	    template: "\n\t\t\t<div class=\"bx-im-element-attach-type-file-element\">\n\t\t\t\t<template v-for=\"(element, index) in config.FILE\">\n\t\t\t\t\t<div class=\"bx-im-element-attach-type-file\" @click=\"openLink(element)\">\n\t\t\t\t\t\t<div class=\"bx-im-element-attach-type-file-icon\">\n\t\t\t\t\t\t\t<div :class=\"['ui-icon', 'ui-icon-file-'+fileIcon(element)]\"><i></i></div>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t<div class=\"bx-im-element-attach-type-file-block\">\n\t\t\t\t\t\t\t<div class=\"bx-im-element-attach-type-file-name\" :title=\"fileNameFull(element)\">\n\t\t\t\t\t\t\t\t{{fileName(element)}}\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t<div class=\"bx-im-element-attach-type-file-size\">{{fileSize(element)}}</div>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>\n\t\t\t\t</template>\n\t\t\t</div>\n\t\t"
	  }
	};

	var AttachLinks = {
	  methods: {
	    openLink: function openLink(event) {
	      var element = event.element;
	      var eventData = event.event;
	      if (!im_lib_utils.Utils.platform.isBitrixMobile() && element.LINK) {
	        return;
	      }
	      if (element.LINK && eventData.target.tagName !== 'A') {
	        im_lib_utils.Utils.platform.openNewPage(element.LINK);
	      } else if (!element.LINK) {
	        var entity = {
	          id: null,
	          type: null
	        };
	        if (element.hasOwnProperty('USER_ID') && element.USER_ID > 0) {
	          entity.id = element.USER_ID;
	          entity.type = 'user';
	        }
	        if (element.hasOwnProperty('CHAT_ID') && element.CHAT_ID > 0) {
	          entity.id = element.CHAT_ID;
	          entity.type = 'chat';
	        }
	        if (entity.id && entity.type && window.top['BXIM']) {
	          var popupAngle = !BX.MessengerTheme.isDark();
	          window.top['BXIM'].messenger.openPopupExternalData(eventData.target, entity.type, popupAngle, {
	            'ID': entity.id
	          });
	        } else if (navigator.userAgent.toLowerCase().includes('bitrixmobile')) {
	          var dialogId = '';
	          if (entity.type === 'chat') {
	            dialogId = "chat".concat(entity.id);
	          } else {
	            dialogId = entity.id;
	          }
	          if (dialogId !== '') {
	            BXMobileApp.Events.postToComponent("onOpenDialog", [{
	              dialogId: dialogId
	            }, true], 'im.recent');
	          }
	        }
	      }
	    }
	  }
	};

	/**
	 * Bitrix Messenger
	 * Vue component
	 *
	 * Grid (attach type)
	 *
	 * @package bitrix
	 * @subpackage im
	 * @copyright 2001-2019 Bitrix
	 */
	var AttachTypeGrid = {
	  property: 'GRID',
	  name: 'bx-im-view-element-attach-grid',
	  component: {
	    mixins: [AttachLinks],
	    props: {
	      config: {
	        type: Object,
	        "default": {}
	      },
	      color: {
	        type: String,
	        "default": 'transparent'
	      }
	    },
	    created: function created() {
	      if (im_lib_utils.Utils.platform.isBitrixMobile()) {
	        this.maxCellWith = Math.floor(Math.min(screen.availWidth, screen.availHeight) / 4);
	      } else {
	        this.maxCellWith = null;
	      }
	    },
	    methods: {
	      getWidth: function getWidth(element) {
	        if (element.DISPLAY !== 'row') {
	          return element.WIDTH ? element.WIDTH + 'px' : '';
	        }
	        if (!element.VALUE) {
	          return false;
	        }
	        if (this.maxCellWith && element.WIDTH > this.maxCellWith) {
	          return this.maxCellWith + 'px';
	        }
	        return element.WIDTH ? element.WIDTH + 'px' : '';
	      },
	      getValueColor: function getValueColor(element) {
	        if (!element.COLOR) {
	          return false;
	        }
	        return element.COLOR;
	      },
	      getValue: function getValue(element) {
	        if (!element.VALUE) {
	          return '';
	        }
	        return im_lib_utils.Utils.text.decode(element.VALUE);
	      }
	    },
	    //language=Vue
	    template: "\n\t\t\t<div class=\"bx-im-element-attach-type-grid\">\n\t\t\t\t<template v-for=\"(element, index) in config.GRID\">\n\t\t\t\t\t<template v-if=\"element.DISPLAY.toLowerCase() === 'block'\">\n\t\t\t\t\t\t<div class=\"bx-im-element-attach-type-grid-display bx-im-element-attach-type-display-block\" :style=\"{width: getWidth(element)}\">\n\t\t\t\t\t\t\t<div class=\"bx-im-element-attach-type-grid-element-name\">{{element.NAME}}</div>\n\t\t\t\t\t\t\t<template v-if=\"element.LINK\">\n\t\t\t\t\t\t\t\t<div class=\"bx-im-element-attach-type-grid-element-value bx-im-element-attach-type-grid-element-value-link\">\n\t\t\t\t\t\t\t\t\t<a :href=\"element.LINK\" target=\"_blank\" @click=\"openLink({element: element, event: $event})\" :style=\"{color: getValueColor(element)}\" v-html=\"getValue(element)\"></a>\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t</template>\n\t\t\t\t\t\t\t<template v-else>\n\t\t\t\t\t\t\t\t<div class=\"bx-im-element-attach-type-grid-element-value\" :style=\"{color: getValueColor(element)}\" v-html=\"getValue(element)\"></div>\n\t\t\t\t\t\t\t</template>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</template>\n\t\t\t\t\t<template v-else-if=\"element.DISPLAY.toLowerCase() === 'line'\">\n\t\t\t\t\t\t<div class=\"bx-im-element-attach-type-grid-display bx-im-element-attach-type-display-card\" :style=\"{width: getWidth(element)}\">\n\t\t\t\t\t\t\t<div class=\"bx-im-element-attach-type-grid-element-name\">{{element.NAME}}</div>\n\t\t\t\t\t\t\t<template v-if=\"element.LINK\">\n\t\t\t\t\t\t\t\t<div\n\t\t\t\t\t\t\t\t\tclass=\"bx-im-element-attach-type-grid-element-value bx-im-element-attach-type-grid-element-value-link\"\n\t\t\t\t\t\t\t\t\t:style=\"{color: element.COLOR? element.COLOR: ''}\"\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t<a :href=\"element.LINK\" target=\"_blank\" @click=\"openLink({element: element, event: $event})\" v-html=\"getValue(element)\"></a>\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t</template>\n\t\t\t\t\t\t\t<template v-else>\n\t\t\t\t\t\t\t\t<div class=\"bx-im-element-attach-type-grid-element-value\" :style=\"{color: element.COLOR? element.COLOR: ''}\" v-html=\"getValue(element)\"></div>\n\t\t\t\t\t\t\t</template>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</template>\n\t\t\t\t\t<template v-else-if=\"element.DISPLAY.toLowerCase() === 'row'\">\n\t\t\t\t\t\t<div class=\"bx-im-element-attach-type-grid-display bx-im-element-attach-type-display-column\">\n\t\t\t\t\t\t\t<table class=\"bx-im-element-attach-type-display-column-table\">\n\t\t\t\t\t\t\t\t<tbody>\n\t\t\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t\t\t<template v-if=\"element.NAME\">\n\t\t\t\t\t\t\t\t\t\t\t<td class=\"bx-im-element-attach-type-grid-element-name\" :colspan=\"element.VALUE? 1: 2\" :style=\"{width: getWidth(element)}\">{{element.NAME}}</td>\n\t\t\t\t\t\t\t\t\t\t</template>\n\t\t\t\t\t\t\t\t\t\t<template v-if=\"element.VALUE\">\n\t\t\t\t\t\t\t\t\t\t\t<template v-if=\"element.LINK\">\n\t\t\t\t\t\t\t\t\t\t\t\t<td\n\t\t\t\t\t\t\t\t\t\t\t\t\tclass=\"bx-im-element-attach-type-grid-element-value bx-im-element-attach-type-grid-element-value-link\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t:colspan=\"element.NAME? 1: 2\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t:style=\"{color: element.COLOR? element.COLOR: ''}\"\n\t\t\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t\t\t\t<a :href=\"element.LINK\" target=\"_blank\" @click=\"openLink({element: element, event: $event})\" v-html=\"getValue(element)\"></a>\n\t\t\t\t\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t\t\t\t</template>\n\t\t\t\t\t\t\t\t\t\t\t<template v-else>\n\t\t\t\t\t\t\t\t\t\t\t\t<td class=\"bx-im-element-attach-type-grid-element-value\" :colspan=\"element.NAME? 1: 2\" :style=\"{color: element.COLOR? element.COLOR: ''}\" v-html=\"getValue(element)\"></td>\n\t\t\t\t\t\t\t\t\t\t\t</template>\n\t\t\t\t\t\t\t\t\t\t</template>\n\t\t\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t\t</tbody>\n\t\t\t\t\t\t\t</table>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</template>\n\t\t\t\t</template>\n\t\t\t</div>\n\t\t"
	  }
	};

	/**
	 * Bitrix Messenger
	 * Vue component
	 *
	 * Rich Attach type
	 *
	 * @package bitrix
	 * @subpackage im
	 * @copyright 2001-2019 Bitrix
	 */
	var AttachTypeHtml = {
	  property: 'HTML',
	  name: 'bx-im-view-element-attach-html',
	  component: {
	    props: {
	      config: {
	        type: Object,
	        "default": {}
	      },
	      color: {
	        type: String,
	        "default": 'transparent'
	      }
	    },
	    computed: {
	      html: function html() {
	        var text = this.config.HTML.replace(/&nbsp;/ig, " ");
	        return im_lib_utils.Utils.text.decode(text);
	      }
	    },
	    template: "<div class=\"bx-im-element-attach-type-html\" v-html=\"html\"></div>"
	  }
	};

	/**
	 * Bitrix Messenger
	 * Vue component
	 *
	 * Image (attach type)
	 *
	 * @package bitrix
	 * @subpackage im
	 * @copyright 2001-2019 Bitrix
	 */
	var AttachTypeImage = {
	  property: 'IMAGE',
	  name: 'bx-im-view-element-attach-image',
	  component: {
	    props: {
	      config: {
	        type: Object,
	        "default": {}
	      },
	      color: {
	        type: String,
	        "default": 'transparent'
	      }
	    },
	    methods: {
	      open: function open(file) {
	        if (!file) {
	          return false;
	        }
	        if (im_lib_utils.Utils.platform.isBitrixMobile()) {
	          // TODO add multiply
	          BXMobileApp.UI.Photo.show({
	            photos: [{
	              url: file
	            }],
	            default_photo: file
	          });
	        } else {
	          window.open(file, '_blank');
	        }
	      },
	      getImageSize: function getImageSize(width, height, maxWidth) {
	        var aspectRatio;
	        if (width > maxWidth) {
	          aspectRatio = maxWidth / width;
	        } else {
	          aspectRatio = 1;
	        }
	        return {
	          width: width * aspectRatio,
	          height: height * aspectRatio
	        };
	      },
	      getElementSource: function getElementSource(element) {
	        return element.PREVIEW ? element.PREVIEW : element.LINK;
	      },
	      lazyLoadCallback: function lazyLoadCallback(event) {
	        if (!event.element.style.width) {
	          event.element.style.width = event.element.offsetWidth + 'px';
	        }
	        if (!event.element.style.height) {
	          event.element.style.height = event.element.offsetHeight + 'px';
	        }
	      },
	      styleFileSizes: function styleFileSizes(image) {
	        if (!(image.WIDTH && image.HEIGHT)) {
	          return {
	            maxHeight: '100%',
	            backgroundSize: 'contain'
	          };
	        }
	        var sizes = this.getImageSize(image.WIDTH, image.HEIGHT, 250);
	        return {
	          width: sizes.width + 'px',
	          height: sizes.height + 'px',
	          backgroundSize: sizes.width < 100 || sizes.height < 100 ? 'contain' : 'initial'
	        };
	      },
	      styleBoxSizes: function styleBoxSizes(image) {
	        if (!(image.WIDTH && image.HEIGHT)) {
	          return {
	            height: '150px'
	          };
	        }
	        if (parseInt(this.styleFileSizes(image).height) <= 250) {
	          return {};
	        }
	        return {
	          height: '280px'
	        };
	      }
	    },
	    template: "\n\t\t\t<div class=\"bx-im-element-attach-type-image\">\n\t\t\t\t<template v-for=\"(image, index) in config.IMAGE\">\n\t\t\t\t\t<div class=\"bx-im-element-attach-type-image-block\" @click=\"open(image.LINK)\" :style=\"styleBoxSizes(image)\" :key=\"index\">\n\t\t\t\t\t\t<img v-bx-lazyload=\"{callback: lazyLoadCallback}\"\n\t\t\t\t\t\t\tclass=\"bx-im-element-attach-type-image-source\"\n\t\t\t\t\t\t\t:data-lazyload-src=\"getElementSource(image)\"\n\t\t\t\t\t\t\t:style=\"styleFileSizes(image)\"\n\t\t\t\t\t\t\t:title=\"image.NAME\"\n\t\t\t\t\t\t/>\n\t\t\t\t\t</div>\n\t\t\t\t</template>\n\t\t\t</div>\n\t\t"
	  }
	};

	/**
	 * Bitrix Messenger
	 * Vue component
	 *
	 * Link (attach type)
	 *
	 * @package bitrix
	 * @subpackage im
	 * @copyright 2001-2019 Bitrix
	 */
	var AttachTypeLink = {
	  property: 'LINK',
	  name: 'bx-im-view-element-attach-link',
	  component: {
	    mixins: [AttachLinks],
	    props: {
	      config: {
	        type: Object,
	        "default": {}
	      },
	      color: {
	        type: String,
	        "default": 'transparent'
	      }
	    },
	    methods: {
	      getImageConfig: function getImageConfig(element) {
	        return {
	          IMAGE: [{
	            NAME: element.NAME,
	            PREVIEW: element.PREVIEW,
	            WIDTH: element.WIDTH,
	            HEIGHT: element.HEIGHT
	          }]
	        };
	      },
	      getLinkName: function getLinkName(element) {
	        return element.NAME ? element.NAME : element.LINK;
	      },
	      getDescription: function getDescription(element) {
	        var text = element.HTML ? element.HTML : element.DESC;
	        return im_lib_utils.Utils.text.decode(text);
	      }
	    },
	    computed: {
	      imageComponentName: function imageComponentName() {
	        return AttachTypeImage.name;
	      }
	    },
	    components: babelHelpers.defineProperty({}, AttachTypeImage.name, AttachTypeImage.component),
	    //language=Vue
	    template: "\n\t\t\t<div class=\"bx-im-element-attach-type-link\">\n\t\t\t\t<template v-for=\"(element, index) in config.LINK\">\n\t\t\t\t\t<div class=\"bx-im-element-attach-type-link-element\" :key=\"index\">\n\t\t\t\t\t\t<a \n\t\t\t\t\t\t\tv-if=\"element.LINK\"\n\t\t\t\t\t\t\t:href=\"element.LINK\"\n\t\t\t\t\t\t\ttarget=\"_blank\"\n\t\t\t\t\t\t\tclass=\"bx-im-element-attach-type-link-name\" \n\t\t\t\t\t\t\t@click=\"openLink({element: element, event: $event})\"\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\t{{getLinkName(element)}}\n\t\t\t\t\t\t</a>\n\t\t\t\t\t\t<span \n\t\t\t\t\t\t\tv-else\n\t\t\t\t\t\t\tclass=\"bx-im-element-attach-type-ajax-link\"\n\t\t\t\t\t\t\t@click=\"openLink({element: element, event: $event})\"\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\t{{getLinkName(element)}}\n\t\t\t\t\t\t</span>\n\t\t\t\t\t\t<div v-if=\"element.DESC || element.HTML\" class=\"bx-im-element-attach-type-link-desc\" v-html=\"getDescription(element)\"></div>\n\t\t\t\t\t\t<div \n\t\t\t\t\t\t\tv-if=\"element.PREVIEW\" \n\t\t\t\t\t\t\tclass=\"bx-im-element-attach-type-link-image\"\n\t\t\t\t\t\t\t@click=\"openLink({element: element, event: $event})\"\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\t<component :is=\"imageComponentName\" :config=\"getImageConfig(element)\" :color=\"color\"/>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>\n\t\t\t\t</template>\n\t\t\t</div>\n\t\t"
	  }
	};

	/**
	 * Bitrix Messenger
	 * Vue component
	 *
	 * Message (attach type)
	 *
	 * @package bitrix
	 * @subpackage im
	 * @copyright 2001-2019 Bitrix
	 */
	var AttachTypeMessage = {
	  property: 'MESSAGE',
	  name: 'bx-im-view-element-attach-message',
	  component: {
	    props: {
	      config: {
	        type: Object,
	        "default": {}
	      },
	      color: {
	        type: String,
	        "default": 'transparent'
	      }
	    },
	    computed: {
	      message: function message() {
	        return im_lib_utils.Utils.text.decode(this.config.MESSAGE);
	      }
	    },
	    template: "<div class=\"bx-im-element-attach-type-message\" v-html=\"message\"></div>"
	  }
	};

	/**
	 * Bitrix Messenger
	 * Vue component
	 *
	 * Rich (attach type)
	 *
	 * @package bitrix
	 * @subpackage im
	 * @copyright 2001-2019 Bitrix
	 */
	var AttachTypeRich = {
	  property: 'RICH_LINK',
	  name: 'bx-im-view-element-attach-rich',
	  component: {
	    mixins: [AttachLinks],
	    props: {
	      config: {
	        type: Object,
	        "default": {}
	      },
	      color: {
	        type: String,
	        "default": 'transparent'
	      }
	    },
	    methods: {
	      getImageConfig: function getImageConfig(element) {
	        return {
	          IMAGE: [{
	            NAME: element.NAME,
	            PREVIEW: element.PREVIEW,
	            WIDTH: element.WIDTH,
	            HEIGHT: element.HEIGHT
	          }]
	        };
	      }
	    },
	    computed: {
	      imageComponentName: function imageComponentName() {
	        return AttachTypeImage.name;
	      }
	    },
	    components: babelHelpers.defineProperty({}, AttachTypeImage.name, AttachTypeImage.component),
	    //language=Vue
	    template: "\n\t\t\t<div class=\"bx-im-element-attach-type-rich\">\n\t\t\t\t<template v-for=\"(element, index) in config.RICH_LINK\">\n\t\t\t\t\t<div class=\"bx-im-element-attach-type-rich-element\" :key=\"index\">\n\t\t\t\t\t\t<div v-if=\"element.PREVIEW\" class=\"bx-im-element-attach-type-rich-image\" @click=\"openLink({element: element, event: $event})\">\n\t\t\t\t\t\t\t<component :is=\"imageComponentName\" :config=\"getImageConfig(element)\" :color=\"color\"/>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t<div class=\"bx-im-element-attach-type-rich-name\" @click=\"openLink({element: element, event: $event})\">{{element.NAME}}</div>\n\t\t\t\t\t\t<div v-if=\"element.HTML || element.DESC\" class=\"bx-im-element-attach-type-rich-desc\">{{element.HTML || element.DESC}}</div>\n\t\t\t\t\t</div>\n\t\t\t\t</template>\n\t\t\t</div>\n\t\t"
	  }
	};

	/**
	 * Bitrix Messenger
	 * Vue component
	 *
	 * User (Attach type)
	 *
	 * @package bitrix
	 * @subpackage im
	 * @copyright 2001-2019 Bitrix
	 */
	var AttachTypeUser = {
	  property: 'USER',
	  name: 'bx-im-view-element-attach-user',
	  component: {
	    mixins: [AttachLinks],
	    props: {
	      config: {
	        type: Object,
	        "default": {}
	      },
	      color: {
	        type: String,
	        "default": 'transparent'
	      }
	    },
	    methods: {
	      getAvatarType: function getAvatarType(element) {
	        if (element.AVATAR) {
	          return '';
	        }
	        var avatarType = 'user';
	        if (element.AVATAR_TYPE === 'CHAT') {
	          avatarType = 'chat';
	        } else if (element.AVATAR_TYPE === 'BOT') {
	          avatarType = 'bot';
	        }
	        return 'bx-im-element-attach-type-user-avatar-type-' + avatarType;
	      }
	    },
	    //language=Vue
	    template: "\n\t\t\t<div class=\"bx-im-element-attach-type-user\">\n\t\t\t\t<template v-for=\"(element, index) in config.USER\">\n\t\t\t\t\t<div class=\"bx-im-element-attach-type-user-body\">\n\t\t\t\t\t\t<div class=\"bx-im-element-attach-type-user-avatar\">\n\t\t\t\t\t\t\t<div :class=\"['bx-im-element-attach-type-user-avatar-type', getAvatarType(element)]\" :style=\"{backgroundColor: element.AVATAR? '': color}\">\n\t\t\t\t\t\t\t\t<img v-if=\"element.AVATAR\" \n\t\t\t\t\t\t\t\t\tv-bx-lazyload\n\t\t\t\t\t\t\t\t\tclass=\"bx-im-element-attach-type-user-avatar-source\"\n\t\t\t\t\t\t\t\t\t:data-lazyload-src=\"element.AVATAR\"\n\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t<a\n\t\t\t\t\t\t\tv-if=\"element.LINK\"\n\t\t\t\t\t\t\t:href=\"element.LINK\" \n\t\t\t\t\t\t\tclass=\"bx-im-element-attach-type-user-name\"\n\t\t\t\t\t\t\ttarget=\"_blank\"\n\t\t\t\t\t\t\t@click=\"openLink({element: element, event: $event})\"\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\t{{element.NAME}}\n\t\t\t\t\t\t</a>\n\t\t\t\t\t\t<span v-else @click.prevent=\"openLink({element: element, event: $event})\">\n\t\t\t\t\t\t\t{{element.NAME}}\n\t\t\t\t\t\t</span>\n\t\t\t\t\t</div>\n\t\t\t\t</template>\n\t\t\t</div>\n\t\t"
	  }
	};

	/**
	 * Bitrix Messenger
	 * Attach element Vue component
	 *
	 * @package bitrix
	 * @subpackage im
	 * @copyright 2001-2019 Bitrix
	 */
	var AttachTypes = [AttachTypeDelimiter, AttachTypeFile, AttachTypeGrid, AttachTypeHtml, AttachTypeImage, AttachTypeLink, AttachTypeMessage, AttachTypeRich, AttachTypeUser];
	var AttachComponents = {};
	AttachTypes.forEach(function (attachType) {
	  AttachComponents[attachType.name] = attachType.component;
	});
	ui_vue.WidgetBitrixVue.component('bx-im-view-element-attach', {
	  props: {
	    config: {
	      type: Object,
	      "default": {}
	    },
	    baseColor: {
	      type: String,
	      "default": '#17a3ea'
	    }
	  },
	  methods: {
	    getComponentForBlock: function getComponentForBlock(block) {
	      for (var _i = 0, _AttachTypes = AttachTypes; _i < _AttachTypes.length; _i++) {
	        var attachType = _AttachTypes[_i];
	        if (typeof block[attachType.property] !== 'undefined') {
	          return attachType.name;
	        }
	      }
	      return '';
	    }
	  },
	  computed: {
	    color: function color() {
	      if (typeof this.config.COLOR === 'undefined' || !this.config.COLOR) {
	        return this.baseColor;
	      }
	      if (this.config.COLOR === 'transparent') {
	        return '';
	      }
	      return this.config.COLOR;
	    }
	  },
	  components: AttachComponents,
	  template: "\n\t\t<div class=\"bx-im-element-attach\">\n\t\t\t<div v-if=\"color\" class=\"bx-im-element-attach-border\" :style=\"{borderColor: color}\"></div>\n\t\t\t<div class=\"bx-im-element-attach-content\">\n\t\t\t\t<template v-for=\"(block, index) in config.BLOCKS\">\n\t\t\t\t\t<component :is=\"getComponentForBlock(block)\" :config=\"block\" :color=\"color\" :key=\"index\" />\n\t\t\t\t</template>\n\t\t\t</div>\n\t\t</div>\n\t"
	});

}((this.window = this.window || {}),BX,BX,window,BX.Messenger.Model,BX.Messenger.Lib,BX));





// file: /bitrix/js/im/view/element/keyboard/dist/keyboard.bundle.js
(function (exports,ui_designTokens,ui_vue,im_lib_utils,im_lib_logger) {
	'use strict';

	/**
	 * Bitrix Messenger
	 * Attach element Vue component
	 *
	 * @package bitrix
	 * @subpackage im
	 * @copyright 2001-2019 Bitrix
	 */
	var _ButtonType = Object.freeze({
	  newline: 'NEWLINE',
	  button: 'BUTTON'
	});
	ui_vue.WidgetBitrixVue.component('bx-im-view-element-keyboard', {
	  /*
	   * @emits 'click' {action: string, params: Object}
	   */
	  props: {
	    buttons: {
	      type: Array,
	      "default": function _default() {
	        return [];
	      }
	    },
	    messageId: {
	      "default": 0
	    },
	    userId: {
	      "default": 0
	    },
	    dialogId: {
	      "default": 0
	    }
	  },
	  data: function data() {
	    return {
	      isMobile: im_lib_utils.Utils.platform.isMobile(),
	      isBlocked: false,
	      localButtons: []
	    };
	  },
	  created: function created() {
	    this.localButtons = this.prepareButtons(this.buttons);
	  },
	  watch: {
	    buttons: function buttons() {
	      clearTimeout(this.recoverStateButton);
	      this.isBlocked = false;
	      this.localButtons = this.prepareButtons(this.buttons);
	    }
	  },
	  methods: {
	    click: function click(button) {
	      var _this = this;
	      if (this.isBlocked) {
	        return false;
	      }
	      if (button.DISABLED && button.DISABLED === 'Y') {
	        return false;
	      }
	      if (button.ACTION && button.ACTION_VALUE.toString()) {
	        this.$emit('click', {
	          action: 'ACTION',
	          params: {
	            dialogId: this.dialogId,
	            messageId: this.messageId,
	            botId: button.BOT_ID,
	            action: button.ACTION,
	            value: button.ACTION_VALUE
	          }
	        });
	      } else if (button.FUNCTION) {
	        var execFunction = button.FUNCTION.toString().replace('#MESSAGE_ID#', this.messageId).replace('#DIALOG_ID#', this.dialogId).replace('#USER_ID#', this.userId);
	        eval(execFunction);
	      } else if (button.APP_ID) {
	        im_lib_logger.Logger.warn('Messenger keyboard: open app is not implemented.');
	      } else if (button.LINK) {
	        if (im_lib_utils.Utils.platform.isBitrixMobile()) {
	          app.openNewPage(button.LINK);
	        } else {
	          window.open(button.LINK, '_blank');
	        }
	      } else if (button.WAIT !== 'Y') {
	        if (button.BLOCK === 'Y') {
	          this.isBlocked = true;
	        }
	        button.WAIT = 'Y';
	        this.$emit('click', {
	          action: 'COMMAND',
	          params: {
	            dialogId: this.dialogId,
	            messageId: this.messageId,
	            botId: button.BOT_ID,
	            command: button.COMMAND,
	            params: button.COMMAND_PARAMS
	          }
	        });
	        this.recoverStateButton = setTimeout(function () {
	          _this.isBlocked = false;
	          button.WAIT = 'N';
	        }, 10000);
	      }
	      return true;
	    },
	    getStyles: function getStyles(button) {
	      var styles = {};
	      if (button.WIDTH) {
	        styles['width'] = button.WIDTH + 'px';
	      } else if (button.DISPLAY === 'BLOCK') {
	        styles['width'] = '225px';
	      }
	      if (button.BG_COLOR) {
	        styles['backgroundColor'] = button.BG_COLOR;
	      }
	      if (button.TEXT_COLOR) {
	        styles['color'] = button.TEXT_COLOR;
	      }
	      return styles;
	    },
	    prepareButtons: function prepareButtons(buttons) {
	      return buttons.filter(function (button) {
	        if (!button.CONTEXT) {
	          return true;
	        }
	        if (im_lib_utils.Utils.platform.isBitrixMobile() && button.CONTEXT === 'DESKTOP') {
	          return false;
	        }
	        if (!im_lib_utils.Utils.platform.isBitrixMobile() && button.CONTEXT === 'MOBILE') {
	          return false;
	        }

	        // TODO activate this buttons
	        if (!im_lib_utils.Utils.platform.isBitrixMobile() && (button.ACTION === 'DIALOG' || button.ACTION === 'CALL')) {
	          return false;
	        }
	        return true;
	      });
	    }
	  },
	  computed: {
	    ButtonType: function ButtonType() {
	      return _ButtonType;
	    }
	  },
	  template: "\n\t\t<div :class=\"['bx-im-element-keyboard', {'bx-im-element-keyboard-mobile': isMobile}]\">\n\t\t\t<template v-for=\"(button, index) in localButtons\">\n\t\t\t\t<div v-if=\"button.TYPE === ButtonType.newline\" class=\"bx-im-element-keyboard-button-separator\"></div>\n\t\t\t\t<span v-else-if=\"button.TYPE === ButtonType.button\" :class=\"[\n\t\t\t\t\t'bx-im-element-keyboard-button', \n\t\t\t\t\t'bx-im-element-keyboard-button-'+button.DISPLAY.toLowerCase(), \n\t\t\t\t\t{\n\t\t\t\t\t\t'bx-im-element-keyboard-button-disabled': isBlocked || button.DISABLED === 'Y',\n\t\t\t\t\t\t'bx-im-element-keyboard-button-progress': button.WAIT === 'Y',\n\t\t\t\t\t}\n\t\t\t\t]\" @click=\"click(button)\">\n\t\t\t\t\t<span class=\"bx-im-element-keyboard-button-text\" :style=\"getStyles(button)\">{{button.TEXT}}</span>\n\t\t\t\t</span>\n\t\t\t</template>\n\t\t</div>\n\t"
	});

}((this.window = this.window || {}),BX,BX,BX.Messenger.Lib,BX.Messenger.Lib));





// file: /bitrix/js/im/view/element/chatteaser/dist/chatteaser.bundle.js
(function (exports,ui_designTokens,ui_vue,im_lib_utils) {
	'use strict';

	/**
	 * Bitrix Messenger
	 * ChatTeaser element Vue component
	 *
	 * @package bitrix
	 * @subpackage im
	 * @copyright 2001-2019 Bitrix
	 */
	ui_vue.WidgetBitrixVue.component('bx-im-view-element-chat-teaser', {
	  /*
	   * @emits 'click' {}
	   */
	  props: {
	    messageCounter: {
	      "default": 0
	    },
	    messageLastDate: {
	      "default": 0
	    },
	    languageId: {
	      "default": 'en'
	    }
	  },
	  computed: {
	    formattedDate: function formattedDate() {
	      return im_lib_utils.Utils.date.format(this.messageLastDate, null, this.$Bitrix.Loc.getMessages());
	    },
	    formattedCounter: function formattedCounter() {
	      return this.messageCounter + ' ' + im_lib_utils.Utils.text.getLocalizeForNumber('IM_MESSENGER_COMMENT', this.messageCounter, this.languageId, this.$Bitrix.Loc.getMessages());
	    }
	  },
	  template: "\n\t\t<div class=\"bx-im-element-chat-teaser\" @click=\"$emit('click', $event)\">\n\t\t\t<span class=\"bx-im-element-chat-teaser-join\">{{$Bitrix.Loc.getMessage('IM_MESSENGER_COMMENT_OPEN')}}</span>\n\t\t\t<span class=\"bx-im-element-chat-teaser-comment\">\n\t\t\t\t<span class=\"bx-im-element-chat-teaser-counter\">{{formattedCounter}}</span>, {{formattedDate}}\n\t\t\t</span>\n\t\t</div>\n\t"
	});

}((this.window = this.window || {}),BX,BX,BX.Messenger.Lib));





// file: /bitrix/js/ui/vue/components/reaction/dist/reaction.bundle.js
(function (exports,ui_fonts_opensans,ui_vue,main_core_events) {
	'use strict';

	/**
	 * Bitrix UI
	 * Reaction picker Vue component
	 *
	 * @package bitrix
	 * @subpackage ui
	 * @copyright 2001-2019 Bitrix
	 */
	var ReactionType = Object.freeze({
	  none: 'none',
	  like: 'like',
	  kiss: 'kiss',
	  laugh: 'laugh',
	  wonder: 'wonder',
	  cry: 'cry',
	  angry: 'angry'
	});
	var ReactionOrder = ['like', 'kiss', 'laugh', 'wonder', 'cry', 'angry'];
	ui_vue.WidgetBitrixVue.component('bx-reaction', {
	  /**
	   * @emits 'set' {values: object}
	   * @emits 'list' {action: string, type: string}
	   */
	  props: {
	    id: {
	      "default": ''
	    },
	    values: {
	      "default": {}
	    },
	    userId: {
	      "default": 0
	    },
	    openList: {
	      "default": true
	    }
	  },
	  data: function data() {
	    return {
	      localValues: {},
	      userReaction: ReactionType.none,
	      buttonAnimate: false
	    };
	  },
	  created: function created() {
	    this.localValues = Object.assign({}, this.values);
	    main_core_events.EventEmitter.subscribe('ui:reaction:press', this.onPress);
	  },
	  destroy: function destroy() {
	    main_core_events.EventEmitter.unsubscribe('ui:reaction:press', this.onPress);
	  },
	  watch: {
	    values: function values(_values) {
	      this.localValues = Object.assign({}, _values);
	    }
	  },
	  methods: {
	    list: function list() {
	      if (this.openList) ;

	      this.$emit('list', {
	        values: this.localValues
	      });
	    },
	    press: function press() {
	      var _this = this;

	      var emotion = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ReactionType.like;

	      if (this.userReaction === ReactionType.none) {
	        if (!this.localValues[emotion]) {
	          this.localValues = Object.assign({}, this.localValues, babelHelpers.defineProperty({}, emotion, []));
	        }

	        this.localValues[emotion].push(this.userId);
	        this.buttonAnimate = true;
	        setTimeout(function () {
	          return _this.buttonAnimate = false;
	        }, 400);
	        this.$emit('set', {
	          action: 'set',
	          type: emotion
	        });
	      } else {
	        if (this.localValues[this.userReaction]) {
	          this.localValues[this.userReaction] = this.localValues[this.userReaction].filter(function (element) {
	            return element !== _this.userId;
	          });
	        }

	        this.$emit('set', {
	          action: 'remove',
	          type: this.userReaction
	        });
	      }
	    },
	    onPress: function onPress(event) {
	      var data = event.getData();

	      if (!this.id || data.id !== this.id) {
	        return false;
	      }

	      if (!data.emotion) {
	        data.emotion = ReactionType.like;
	      }

	      this.press(data.emotion);
	    }
	  },
	  computed: {
	    types: function types() {
	      var _this2 = this;

	      this.userReaction = ReactionType.none;
	      return ReactionOrder.filter(function (type) {
	        if (typeof _this2.localValues[type] === 'undefined' || !(_this2.localValues[type] instanceof Array) || _this2.localValues[type].length <= 0) {
	          return false;
	        }

	        if (_this2.userId > 0 && _this2.userReaction === ReactionType.none && _this2.localValues[type].includes(_this2.userId)) {
	          _this2.userReaction = type;
	        }

	        return true;
	      }).map(function (type) {
	        return {
	          type: type,
	          count: _this2.localValues[type].length
	        };
	      });
	    },
	    counter: function counter() {
	      return this.types.map(function (element) {
	        return element.count;
	      }).reduce(function (result, value) {
	        return result + value;
	      }, 0);
	    },
	    isTypesShowed: function isTypesShowed() {
	      if (this.counter <= 0) {
	        return false;
	      }

	      if (this.userReaction !== ReactionType.none && this.counter === 1) {
	        return false;
	      }

	      return true;
	    },
	    isMobile: function isMobile() {
	      var UA = navigator.userAgent.toLowerCase();
	      return UA.includes('android') || UA.includes('iphone') || UA.includes('ipad') || UA.includes('bitrixmobile');
	    }
	  },
	  template: "\n\t\t<div :class=\"['ui-vue-reaction', {'ui-vue-reaction-mobile': isMobile}]\">\n\t\t\t<transition name=\"ui-vue-reaction-result-animation\">\n\t\t\t\t<div v-if=\"isTypesShowed\" class=\"ui-vue-reaction-result\" @click=\"list\">\n\t\t\t\t\t<transition-group tag=\"div\" class=\"ui-vue-reaction-result-types\" name=\"ui-vue-reaction-result-type-animation\" >\n\t\t\t\t\t\t<span v-for=\"element in types\" :class=\"['ui-vue-reaction-result-type', 'ui-vue-reaction-icon-'+element.type]\" :key=\"element.type\"></span>\n\t\t\t\t\t</transition-group>\t\n\t\t\t\t\t<div class=\"ui-vue-reaction-result-counter\">{{counter}}</div>\n\t\t\t\t</div>\n\t\t\t</transition>\n\t\t\t<div v-if=\"userId > 0\"  class=\"ui-vue-reaction-button\" @click.prevent=\"press()\">\n\t\t\t\t<div class=\"ui-vue-reaction-button-container\">\n\t\t\t\t\t<div :class=\"['ui-vue-reaction-button-icon', 'ui-vue-reaction-icon-'+userReaction, {'ui-vue-reaction-button-pressed': buttonAnimate}]\"></div>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t</div>\n\t"
	});

}((this.window = this.window || {}),BX,BX,BX.Event));





// file: /bitrix/js/im/view/message/body/dist/body.bundle.js
(function (exports,ui_designTokens,im_view_element_media,im_view_element_attach,im_view_element_keyboard,im_view_element_chatteaser,ui_vue_components_reaction,ui_vue,ui_vue_vuex,im_model,im_const,im_lib_utils,main_core,main_core_events) {
	'use strict';

	function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }
	function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
	function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
	function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
	function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { babelHelpers.defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
	var BX = window.BX;
	var _ContentType = Object.freeze({
	  "default": 'default',
	  progress: 'progress',
	  image: 'image',
	  audio: 'audio',
	  video: 'video',
	  richLink: 'richLink'
	});
	ui_vue.WidgetBitrixVue.component('bx-im-view-message-body', {
	  /**
	   * @emits EventType.dialog.clickOnChatTeaser {message: object, event: MouseEvent}
	   * @emits EventType.dialog.clickOnKeyboardButton {message: object, action: string, params: Object}
	   * @emits EventType.dialog.setMessageReaction {message: object, reaction: object}
	   * @emits EventType.dialog.openMessageReactionList {message: object, values: object}
	   * @emits EventType.dialog.clickOnUserName {user: object, event: MouseEvent}
	   */
	  props: {
	    userId: {
	      "default": 0
	    },
	    dialogId: {
	      "default": '0'
	    },
	    chatId: {
	      "default": 0
	    },
	    messageType: {
	      "default": im_const.MessageType.self
	    },
	    message: {
	      type: Object,
	      "default": im_model.MessagesModel.create().getElementState
	    },
	    enableReactions: {
	      "default": true
	    },
	    showName: {
	      "default": true
	    },
	    showAvatar: {
	      "default": true
	    },
	    referenceContentBodyClassName: {
	      "default": ''
	    },
	    referenceContentNameClassName: {
	      "default": ''
	    }
	  },
	  created: function created() {
	    this.dateFormatFunction = null;
	    this.cacheFormatDate = {};
	  },
	  methods: {
	    clickByUserName: function clickByUserName(event) {
	      if (this.showAvatar && im_lib_utils.Utils.platform.isMobile()) {
	        return false;
	      }
	      main_core_events.EventEmitter.emit(im_const.EventType.dialog.clickOnUserName, event);
	    },
	    clickByChatTeaser: function clickByChatTeaser(event) {
	      main_core_events.EventEmitter.emit(im_const.EventType.dialog.clickOnChatTeaser, {
	        message: event.message,
	        event: event.event
	      });
	    },
	    clickByKeyboardButton: function clickByKeyboardButton(event) {
	      main_core_events.EventEmitter.emit(im_const.EventType.dialog.clickOnKeyboardButton, _objectSpread({
	        message: event.message
	      }, event.event));
	    },
	    setReaction: function setReaction(event) {
	      main_core_events.EventEmitter.emit(im_const.EventType.dialog.setMessageReaction, event);
	    },
	    openReactionList: function openReactionList(event) {
	      main_core_events.EventEmitter.emit(im_const.EventType.dialog.openMessageReactionList, event);
	    },
	    formatDate: function formatDate(date) {
	      var id = date.toJSON().slice(0, 10);
	      if (this.cacheFormatDate[id]) {
	        return this.cacheFormatDate[id];
	      }
	      var dateFormat = im_lib_utils.Utils.date.getFormatType(BX.Messenger.Const.DateFormat.message, this.$Bitrix.Loc.getMessages());
	      this.cacheFormatDate[id] = this._getDateFormat().format(dateFormat, date);
	      return this.cacheFormatDate[id];
	    },
	    _getDateFormat: function _getDateFormat() {
	      var _this = this;
	      if (this.dateFormatFunction) {
	        return this.dateFormatFunction;
	      }
	      this.dateFormatFunction = Object.create(BX.Main.Date);
	      this.dateFormatFunction._getMessage = function (phrase) {
	        return _this.$Bitrix.Loc.getMessage(phrase);
	      };
	      return this.dateFormatFunction;
	    },
	    isDesktop: function isDesktop() {
	      return im_lib_utils.Utils.platform.isBitrixDesktop();
	    },
	    getDesktopVersion: function getDesktopVersion() {
	      return im_lib_utils.Utils.platform.getDesktopVersion();
	    },
	    isMobile: function isMobile() {
	      return im_lib_utils.Utils.platform.isBitrixMobile();
	    }
	  },
	  computed: _objectSpread({
	    MessageType: function MessageType() {
	      return im_const.MessageType;
	    },
	    ContentType: function ContentType() {
	      return _ContentType;
	    },
	    contentType: function contentType() {
	      if (this.filesData.length > 0) {
	        var onlyImage = false;
	        var onlyVideo = false;
	        var onlyAudio = false;
	        var inProgress = false;
	        var _iterator = _createForOfIteratorHelper(this.filesData),
	          _step;
	        try {
	          for (_iterator.s(); !(_step = _iterator.n()).done;) {
	            var file = _step.value;
	            if (file.progress < 0) {
	              inProgress = true;
	              break;
	            } else if (file.type === 'audio') {
	              if (onlyVideo || onlyImage) {
	                onlyImage = false;
	                onlyVideo = false;
	                break;
	              }
	              onlyAudio = true;
	            } else if (file.type === 'image' && file.image) {
	              if (onlyVideo || onlyAudio) {
	                onlyAudio = false;
	                onlyVideo = false;
	                break;
	              }
	              onlyImage = true;
	            } else if (file.type === 'video') {
	              if (onlyImage || onlyAudio) {
	                onlyAudio = false;
	                onlyImage = false;
	                break;
	              }
	              onlyVideo = true;
	            } else {
	              onlyAudio = false;
	              onlyImage = false;
	              onlyVideo = false;
	              break;
	            }
	          }
	        } catch (err) {
	          _iterator.e(err);
	        } finally {
	          _iterator.f();
	        }
	        if (inProgress) {
	          return _ContentType.progress;
	        } else if (onlyImage) {
	          return _ContentType.image;
	        } else if (onlyAudio) {
	          return _ContentType.audio;
	        } else if (onlyVideo) {
	          return _ContentType.video;
	        }
	      }
	      return _ContentType["default"];
	    },
	    formattedDate: function formattedDate() {
	      return this.formatDate(this.message.date);
	    },
	    messageText: function messageText() {
	      if (this.isDeleted) {
	        return this.$Bitrix.Loc.getMessage('IM_MESSENGER_MESSAGE_DELETED');
	      }
	      var message = this.message.textConverted ? this.message.textConverted : im_lib_utils.Utils.text.decode(this.message.text);
	      var messageParams = this.message.params;
	      if (typeof messageParams.LINK_ACTIVE !== 'undefined' && messageParams.LINK_ACTIVE.length > 0 && !messageParams.LINK_ACTIVE.includes(this.userId)) {
	        message = message.replace(/<a.*?href="([^"]*)".*?>(.*?)<\/a>/ig, '$2');
	      }
	      return message;
	    },
	    messageAttach: function messageAttach() {
	      return this.message.params.ATTACH;
	    },
	    messageReactions: function messageReactions() {
	      return this.message.params.REACTION || {};
	    },
	    isEdited: function isEdited() {
	      return this.message.params.IS_EDITED === 'Y';
	    },
	    isDeleted: function isDeleted() {
	      return this.message.params.IS_DELETED === 'Y';
	    },
	    chatColor: function chatColor() {
	      return this.dialog.type !== im_const.DialogType["private"] ? this.dialog.color : this.user.color;
	    },
	    dialog: function dialog() {
	      var dialog = this.$store.getters['dialogues/get'](this.dialogId);
	      return dialog ? dialog : this.$store.getters['dialogues/getBlank']();
	    },
	    user: function user() {
	      return this.$store.getters['users/get'](this.message.authorId, true);
	    },
	    filesData: function filesData() {
	      var _this2 = this;
	      var files = [];
	      if (!this.message.params.FILE_ID || this.message.params.FILE_ID.length <= 0) {
	        return files;
	      }
	      this.message.params.FILE_ID.forEach(function (fileId) {
	        if (!fileId) {
	          return false;
	        }
	        var file = _this2.$store.getters['files/get'](_this2.chatId, fileId, true);
	        if (!file) {
	          _this2.$store.commit('files/set', {
	            data: [_this2.$store.getters['files/getBlank']({
	              id: fileId,
	              chatId: _this2.chatId
	            })]
	          });
	          file = _this2.$store.getters['files/get'](_this2.chatId, fileId, true);
	        }
	        if (file) {
	          files.push(file);
	        }
	      });
	      return files;
	    },
	    keyboardButtons: function keyboardButtons() {
	      var result = false;
	      if (!this.message.params.KEYBOARD || this.message.params.KEYBOARD === 'N') {
	        return result;
	      }
	      return this.message.params.KEYBOARD;
	    },
	    chatTeaser: function chatTeaser() {
	      if (typeof this.message.params.CHAT_ID === 'undefined' || typeof this.message.params.CHAT_LAST_DATE === 'undefined' || typeof this.message.params.CHAT_MESSAGE === 'undefined') {
	        return false;
	      }
	      return {
	        messageCounter: this.message.params.CHAT_MESSAGE,
	        messageLastDate: this.message.params.CHAT_LAST_DATE,
	        languageId: this.application.common.languageId
	      };
	    },
	    userName: function userName() {
	      if (this.message.params.NAME) {
	        return main_core.Text.decode(this.message.params.NAME);
	      }
	      if (!this.showAvatar) {
	        return this.user.name;
	      } else {
	        return this.user.firstName ? this.user.firstName : this.user.name;
	      }
	    },
	    userColor: function userColor() {
	      if (this.user.extranet) {
	        return "#CA7B00";
	      }
	      return this.user.color;
	    }
	  }, ui_vue_vuex.WidgetVuex.mapState({
	    application: function application(state) {
	      return state.application;
	    }
	  })),
	  // language=Vue
	  template: "\n\t\t<div class=\"bx-im-message-content-wrap\">\n\t\t\t<template v-if=\"contentType == ContentType.default || contentType == ContentType.audio || contentType == ContentType.progress || (contentType !== ContentType.image && isDesktop() && getDesktopVersion() < 47)\">\n\t\t\t\t<div class=\"bx-im-message-content\">\n\t\t\t\t\t<span class=\"bx-im-message-content-box\">\n\t\t\t\t\t\t<div class=\"bx-im-message-content-name-wrap\">\n\t\t\t\t\t\t\t<template v-if=\"showName && user.extranet && messageType == MessageType.opponent\">\n\t\t\t\t\t\t\t\t<div class=\"bx-im-message-extranet-icon\"></div>\n\t\t\t\t\t\t\t</template>\n\t\t\t\t\t\t\t<template v-if=\"showName && messageType == MessageType.opponent\">\n\t\t\t\t\t\t\t\t<div :class=\"['bx-im-message-content-name', referenceContentNameClassName]\" :style=\"{color: userColor}\" @click=\"clickByUserName({user: user, event: $event})\">{{userName}}</div>\n\t\t\t\t\t\t\t</template>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t<div :class=\"['bx-im-message-content-body', referenceContentBodyClassName]\">\n\t\t\t\t\t\t\t<template v-if=\"(contentType == ContentType.audio) && (!isDesktop() || (isDesktop() && getDesktopVersion() > 43))\">\n\t\t\t\t\t\t\t\t<bx-im-view-element-file-audio v-for=\"file in filesData\" :messageType=\"messageType\" :file=\"file\" :key=\"file.templateId\"/>\n\t\t\t\t\t\t\t</template>\n\t\t\t\t\t\t\t<template v-else>\n\t\t\t\t\t\t\t\t<bx-im-view-element-file v-for=\"file in filesData\" :messageType=\"messageType\" :file=\"file\" :key=\"file.templateId\"/>\n\t\t\t\t\t\t\t</template>\n\t\t\t\t\t\t\t<div :class=\"['bx-im-message-content-body-wrap', {\n\t\t\t\t\t\t\t\t'bx-im-message-content-body-with-text': messageText.length > 0,\n\t\t\t\t\t\t\t\t'bx-im-message-content-body-without-text': messageText.length <= 0,\n\t\t\t\t\t\t\t}]\">\n\t\t\t\t\t\t\t\t<template v-if=\"messageText\">\n\t\t\t\t\t\t\t\t\t<span class=\"bx-im-message-content-text\" v-html=\"messageText\"></span>\n\t\t\t\t\t\t\t\t</template>\n\t\t\t\t\t\t\t\t<template v-for=\"(config, id) in messageAttach\">\n\t\t\t\t\t\t\t\t\t<bx-im-view-element-attach :baseColor=\"chatColor\" :config=\"config\" :key=\"id\"/>\n\t\t\t\t\t\t\t\t</template>\n\t\t\t\t\t\t\t\t<span class=\"bx-im-message-content-params\">\n\t\t\t\t\t\t\t\t\t<span class=\"bx-im-message-content-date\">{{formattedDate}}</span>\n\t\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</span>\n\t\t\t\t\t<div v-if=\"!message.push && enableReactions && message.authorId\" class=\"bx-im-message-content-reaction\">\n\t\t\t\t\t\t<bx-reaction :id=\"'message'+message.id\" :values=\"messageReactions\" :userId=\"userId\" :openList=\"false\" @set=\"setReaction({message: message, reaction: $event})\" @list=\"openReactionList({message: message, values: $event.values})\"/>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t</template>\n\t\t\t<template v-else-if=\"contentType == ContentType.richLink\">\n\t\t\t\t<!-- richLink type markup -->\n\t\t\t</template>\n\t\t\t<template v-else-if=\"contentType == ContentType.image || contentType == ContentType.video\">\n\t\t\t\t<div class=\"bx-im-message-content bx-im-message-content-fit\">\n\t\t\t\t\t<span class=\"bx-im-message-content-box\">\n\t\t\t\t\t\t<template v-if=\"showName && messageType == MessageType.opponent\">\n\t\t\t\t\t\t\t<div :class=\"['bx-im-message-content-name', referenceContentNameClassName]\" :style=\"{color: user.color}\" @click=\"clickByUserName({user: user, event: $event})\">{{!showAvatar? user.name: (user.firstName? user.firstName: user.name)}}</div>\n\t\t\t\t\t\t</template>\n\t\t\t\t\t\t<div :class=\"['bx-im-message-content-body', referenceContentBodyClassName]\">\n\t\t\t\t\t\t\t<template v-if=\"contentType == ContentType.image\">\n\t\t\t\t\t\t\t\t<bx-im-view-element-file-image v-for=\"file in filesData\" :messageType=\"messageType\" :file=\"file\" :key=\"file.templateId\"/>\n\t\t\t\t\t\t\t</template>\n\t\t\t\t\t\t\t<template v-else-if=\"contentType == ContentType.video\">\n\t\t\t\t\t\t\t\t<bx-im-view-element-file-video v-for=\"file in filesData\" :messageType=\"messageType\" :file=\"file\" :key=\"file.templateId\"/>\n\t\t\t\t\t\t\t</template>\n\t\t\t\t\t\t\t<div :class=\"['bx-im-message-content-body-wrap', {\n\t\t\t\t\t\t\t\t'bx-im-message-content-body-with-text': messageText.length > 0,\n\t\t\t\t\t\t\t\t'bx-im-message-content-body-without-text': messageText.length <= 0,\n\t\t\t\t\t\t\t}]\">\n\t\t\t\t\t\t\t\t<template v-if=\"messageText\">\n\t\t\t\t\t\t\t\t\t<span class=\"bx-im-message-content-text\" v-html=\"messageText\"></span>\n\t\t\t\t\t\t\t\t</template>\n\t\t\t\t\t\t\t\t<span class=\"bx-im-message-content-params\">\n\t\t\t\t\t\t\t\t\t<span class=\"bx-im-message-content-date\">{{formattedDate}}</span>\n\t\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</span>\n\t\t\t\t\t<div v-if=\"!message.push && enableReactions && message.authorId\" class=\"bx-im-message-content-reaction\">\n\t\t\t\t\t\t<bx-reaction :id=\"'message'+message.id\" :values=\"messageReactions\" :userId=\"userId\" :openList=\"false\" @set=\"setReaction({message: message, reaction: $event})\" @list=\"openReactionList({message: message, values: $event.values})\"/>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t</template>\n\t\t\t<template v-if=\"keyboardButtons\">\n\t\t\t\t<bx-im-view-element-keyboard :buttons=\"keyboardButtons\" :messageId=\"message.id\" :userId=\"userId\" :dialogId=\"dialogId\" @click=\"clickByKeyboardButton({message: message, event: $event})\"/>\n\t\t\t</template>\n\t\t\t<template v-if=\"chatTeaser\">\n\t\t\t\t<bx-im-view-element-chat-teaser :messageCounter=\"chatTeaser.messageCounter\" :messageLastDate=\"chatTeaser.messageLastDate\" :languageId=\"chatTeaser.languageId\" @click=\"clickByChatTeaser({message: message, event: $event})\"/>\n\t\t\t</template>\n\t\t</div>\n\t"
	});

}((this.window = this.window || {}),BX,window,window,window,window,window,BX,BX,BX.Messenger.Model,BX.Messenger.Const,BX.Messenger.Lib,BX,BX.Event));





// file: /bitrix/js/im/lib/animation/dist/animation.bundle.js
this.BX = this.BX || {};
this.BX.Messenger = this.BX.Messenger || {};
(function (exports) {
	'use strict';

	/**
	 * Bitrix Messenger
	 * Animation manager
	 *
	 * @package bitrix
	 * @subpackage im
	 * @copyright 2001-2019 Bitrix
	 */
	var Animation = /*#__PURE__*/function () {
	  function Animation() {
	    babelHelpers.classCallCheck(this, Animation);
	  }
	  babelHelpers.createClass(Animation, null, [{
	    key: "start",
	    value: function start(params) {
	      var _params$start = params.start,
	        start = _params$start === void 0 ? 0 : _params$start,
	        _params$end = params.end,
	        end = _params$end === void 0 ? 0 : _params$end,
	        _params$increment = params.increment,
	        increment = _params$increment === void 0 ? 20 : _params$increment,
	        _params$callback = params.callback,
	        callback = _params$callback === void 0 ? function () {} : _params$callback,
	        _params$duration = params.duration,
	        duration = _params$duration === void 0 ? 500 : _params$duration,
	        element = params.element,
	        elementProperty = params.elementProperty;
	      var diff = end - start;
	      var currentPosition = 0;
	      var easeInOutQuad = function easeInOutQuad(current, start, diff, duration) {
	        current /= duration / 2;
	        if (current < 1) {
	          return diff / 2 * current * current + start;
	        }
	        current--;
	        return -diff / 2 * (current * (current - 2) - 1) + start;
	      };
	      var requestFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || function (callback) {
	        return window.setTimeout(callback, 1000 / 60);
	      };
	      var frameId = null;
	      var animateScroll = function animateScroll() {
	        currentPosition += increment;
	        element[elementProperty] = easeInOutQuad(currentPosition, start, diff, duration);
	        if (currentPosition < duration) {
	          frameId = requestFrame(animateScroll);
	        } else {
	          if (callback && typeof callback === 'function') {
	            callback();
	          }
	        }
	        return frameId;
	      };
	      return animateScroll();
	    }
	  }, {
	    key: "cancel",
	    value: function cancel(id) {
	      var cancelFrame = window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || function (id) {
	        clearTimeout(id);
	      };
	      cancelFrame(id);
	    }
	  }]);
	  return Animation;
	}();
	Animation.frameIds = {};

	exports.Animation = Animation;

}((this.BX.Messenger.Lib = this.BX.Messenger.Lib || {})));





// file: /bitrix/js/im/view/message/dist/message.bundle.js
(function (exports,im_view_message_body,im_model,ui_vue,im_const,im_lib_utils,im_lib_animation,main_core_events) {
	'use strict';

	/**
	 * Bitrix Messenger
	 * Message Vue component
	 *
	 * @package bitrix
	 * @subpackage im
	 * @copyright 2001-2019 Bitrix
	 */
	ui_vue.WidgetBitrixVue.component('bx-im-view-message', {
	  /**
	   * @emits 'dragMessage' {result: boolean, event: MouseEvent}
	   *
	   * @emits EventType.dialog.quoteMessage {message: object}
	   * @emits EventType.dialog.clickOnUserName {user: object, event: MouseEvent}
	   * @emits EventType.dialog.clickOnMessageMenu {message: object, event: MouseEvent}
	   * @emits EventType.dialog.clickOnMessageRetry {message: object, event: MouseEvent}
	   */
	  props: {
	    userId: {
	      "default": 0
	    },
	    dialogId: {
	      "default": 0
	    },
	    chatId: {
	      "default": 0
	    },
	    enableReactions: {
	      "default": true
	    },
	    enableDateActions: {
	      "default": true
	    },
	    enableCreateContent: {
	      "default": true
	    },
	    enableGestureQuote: {
	      "default": true
	    },
	    enableGestureQuoteFromRight: {
	      "default": true
	    },
	    enableGestureMenu: {
	      "default": false
	    },
	    showAvatar: {
	      "default": true
	    },
	    showMenu: {
	      "default": true
	    },
	    showName: {
	      "default": true
	    },
	    showLargeFont: {
	      "default": true
	    },
	    capturedMoveEvent: {
	      "default": null
	    },
	    referenceContentClassName: {
	      "default": ''
	    },
	    referenceContentBodyClassName: {
	      "default": ''
	    },
	    referenceContentNameClassName: {
	      "default": ''
	    },
	    message: {
	      type: Object,
	      "default": im_model.MessagesModel.create().getElementState
	    }
	  },
	  data: function data() {
	    return {
	      componentBodyId: 'bx-im-view-message-body',
	      drag: false,
	      dragWidth: 0,
	      dragPosition: 0,
	      dragIconShowLeft: false,
	      dragIconShowRight: false
	    };
	  },
	  created: function created() {
	    this.dragStartPositionX = 0;
	    this.dragStartPositionY = 0;
	    this.dragMovePositionX = 0;
	    this.dragMovePositionY = 0;
	  },
	  beforeDestroy: function beforeDestroy() {
	    clearTimeout(this.dragStartTimeout1);
	    clearTimeout(this.dragStartTimeout2);
	    if (this.dragBackAnimation) {
	      im_lib_animation.Animation.cancel(this.dragBackAnimation);
	    }
	  },
	  methods: {
	    clickByAvatar: function clickByAvatar(event) {
	      main_core_events.EventEmitter.emit(im_const.EventType.dialog.clickOnUserName, event);
	    },
	    clickByMessageMenu: function clickByMessageMenu(event) {
	      main_core_events.EventEmitter.emit(im_const.EventType.dialog.clickOnMessageMenu, event);
	    },
	    clickByMessageRetry: function clickByMessageRetry(event) {
	      main_core_events.EventEmitter.emit(im_const.EventType.dialog.clickOnMessageRetry, event);
	    },
	    doubleClickByMessage: function doubleClickByMessage(event) {
	      main_core_events.EventEmitter.emit(im_const.EventType.dialog.doubleClickOnMessage, event);
	    },
	    gestureRouter: function gestureRouter(eventName, event) {
	      this.gestureQuote(eventName, event);
	      this.gestureMenu(eventName, event);
	    },
	    gestureMenu: function gestureMenu(eventName, event) {
	      var _this = this;
	      if (!this.enableGestureMenu) {
	        return;
	      }
	      if (eventName === 'touchstart') {
	        this.gestureMenuStarted = true;
	        this.gestureMenuPreventTouchEnd = false;
	        if (event.target.tagName === "A") {
	          return false;
	        }
	        this.gestureMenuStartPosition = {
	          x: event.changedTouches[0].clientX,
	          y: event.changedTouches[0].clientY
	        };
	        this.gestureMenuTimeout = setTimeout(function () {
	          _this.gestureMenuPreventTouchEnd = true;
	          _this.clickByMessageMenu({
	            message: _this.message,
	            event: event
	          });
	        }, 500);
	      } else if (eventName === 'touchmove') {
	        if (!this.gestureMenuStarted) {
	          return false;
	        }
	        if (Math.abs(this.gestureMenuStartPosition.x - event.changedTouches[0].clientX) >= 10 || Math.abs(this.gestureMenuStartPosition.y - event.changedTouches[0].clientY) >= 10) {
	          this.gestureMenuStarted = false;
	          clearTimeout(this.gestureMenuTimeout);
	        }
	      } else if (eventName === 'touchend') {
	        if (!this.gestureMenuStarted) {
	          return false;
	        }
	        this.gestureMenuStarted = false;
	        clearTimeout(this.gestureMenuTimeout);
	        if (this.gestureMenuPreventTouchEnd) {
	          event.preventDefault();
	        }
	      }
	    },
	    gestureQuote: function gestureQuote(eventName, event) {
	      var _this2 = this;
	      var target = im_lib_utils.Utils.browser.findParent(event.target, 'bx-im-message') || event.target;
	      if (!this.enableGestureQuote || im_lib_utils.Utils.platform.isAndroid()) {
	        return;
	      }
	      var fromRight = this.enableGestureQuoteFromRight;
	      var layerX = target.getBoundingClientRect().left + event.layerX;
	      var layerY = target.getBoundingClientRect().top + event.layerY;
	      if (eventName === 'touchstart') {
	        this.dragCheck = true;
	        this.dragStartInitialX = target.getBoundingClientRect().left;
	        this.dragStartInitialY = target.getBoundingClientRect().top;
	        this.dragStartPositionX = layerX;
	        this.dragStartPositionY = layerY;
	        this.dragMovePositionX = null;
	        this.dragMovePositionY = null;
	        clearTimeout(this.dragStartTimeout1);
	        clearTimeout(this.dragStartTimeout2);
	        this.dragStartTimeout1 = setTimeout(function () {
	          if (_this2.dragMovePositionX !== null) {
	            if (Math.abs(_this2.dragStartPositionY - _this2.dragMovePositionY) >= 10) {
	              _this2.dragCheck = false;
	            }
	          }
	        }, 29);
	        this.dragStartTimeout2 = setTimeout(function () {
	          _this2.dragCheck = false;
	          if (Math.abs(_this2.dragStartPositionY - _this2.dragMovePositionY) >= 10) {
	            return;
	          }
	          if (_this2.dragMovePositionX === null) {
	            return;
	          } else if (fromRight && _this2.dragStartPositionX - _this2.dragMovePositionX < 9) {
	            return;
	          } else if (!fromRight && _this2.dragStartPositionX - _this2.dragMovePositionX > 9) {
	            return;
	          }
	          im_lib_animation.Animation.cancel(_this2.dragBackAnimation);
	          _this2.drag = true;
	          _this2.$emit('dragMessage', {
	            result: _this2.drag,
	            event: event
	          });
	          _this2.dragWidth = _this2.$refs.body.offsetWidth;
	        }, 80);
	      } else if (eventName === 'touchmove') {
	        if (this.drag || !this.dragCheck) {
	          return false;
	        }
	        this.dragMovePositionX = layerX;
	        this.dragMovePositionY = layerY;
	      } else if (eventName === 'touchend') {
	        clearTimeout(this.dragStartTimeout1);
	        clearTimeout(this.dragStartTimeout2);
	        this.dragCheck = false;
	        if (!this.drag) {
	          this.dragIconShowLeft = false;
	          this.dragIconShowRight = false;
	          return;
	        }
	        im_lib_animation.Animation.cancel(this.dragBackAnimation);
	        this.drag = false;
	        this.$emit('dragMessage', {
	          result: this.drag,
	          event: event
	        });
	        if (this.enableGestureQuoteFromRight && this.dragIconShowRight && this.dragPosition !== 0 || !this.enableGestureQuoteFromRight && this.dragIconShowLeft && this.dragPosition !== this.dragStartInitialX) {
	          if (im_lib_utils.Utils.platform.isBitrixMobile()) {
	            setTimeout(function () {
	              return app.exec("callVibration");
	            }, 200);
	          }
	          main_core_events.EventEmitter.emit(im_const.EventType.dialog.quoteMessage, {
	            message: this.message
	          });
	        }
	        this.dragIconShowLeft = false;
	        this.dragIconShowRight = false;
	        this.dragBackAnimation = im_lib_animation.Animation.start({
	          start: this.dragPosition,
	          end: this.dragStartInitialX,
	          increment: 20,
	          duration: 300,
	          element: this,
	          elementProperty: 'dragPosition',
	          callback: function callback() {
	            _this2.dragLayerPosition = undefined;
	            _this2.dragWidth = 0;
	            _this2.dragPosition = 0;
	          }
	        });
	      }
	    }
	  },
	  watch: {
	    capturedMoveEvent: function capturedMoveEvent(event) {
	      if (!this.drag || !event) {
	        return;
	      }
	      var target = im_lib_utils.Utils.browser.findParent(event.target, 'bx-im-message') || event.target;
	      var layerX = target.getBoundingClientRect().left + event.layerX;
	      if (typeof this.dragLayerPosition === 'undefined') {
	        this.dragLayerPosition = layerX;
	      }
	      var movementX = this.dragLayerPosition - layerX;
	      this.dragLayerPosition = layerX;
	      this.dragPosition = this.dragPosition - movementX;
	      if (this.enableGestureQuoteFromRight) {
	        var dragPositionMax = (this.showAvatar ? 30 : 0) + 45;
	        var dragPositionIcon = this.showAvatar ? 30 : 30;
	        if (this.dragPosition < -dragPositionMax) {
	          this.dragPosition = -dragPositionMax;
	        } else if (this.dragPosition < -dragPositionIcon) {
	          if (!this.dragIconShowRight) {
	            this.dragIconShowRight = true;
	          }
	        } else if (this.dragPosition >= 0) {
	          this.dragPosition = 0;
	        }
	      } else {
	        var _dragPositionMax = 60;
	        var _dragPositionIcon = 40;
	        if (this.dragPosition <= this.dragStartInitialX) {
	          this.dragPosition = this.dragStartInitialX;
	        } else if (this.dragPosition >= _dragPositionMax) {
	          this.dragPosition = _dragPositionMax;
	        } else if (this.dragPosition >= _dragPositionIcon) {
	          if (!this.dragIconShowLeft) {
	            this.dragIconShowLeft = true;
	          }
	        }
	      }
	    }
	  },
	  computed: {
	    MessageType: function MessageType() {
	      return im_const.MessageType;
	    },
	    dialog: function dialog() {
	      var dialog = this.$store.getters['dialogues/get'](this.dialogId);
	      return dialog ? dialog : this.$store.getters['dialogues/getBlank']();
	    },
	    type: function type() {
	      if (this.message.system || this.message.authorId == 0) {
	        return im_const.MessageType.system;
	      } else if (this.message.authorId === -1 || this.message.authorId == this.userId) {
	        return im_const.MessageType.self;
	      } else {
	        return im_const.MessageType.opponent;
	      }
	    },
	    userData: function userData() {
	      return this.$store.getters['users/get'](this.message.authorId, true);
	    },
	    userAvatar: function userAvatar() {
	      if (this.message.params.AVATAR) {
	        return "url('".concat(this.message.params.AVATAR, "')");
	      }
	      if (this.userData.avatar) {
	        return "url('".concat(this.userData.avatar, "')");
	      }
	      return '';
	    },
	    filesData: function filesData() {
	      var files = this.$store.getters['files/getList'](this.chatId);
	      return files ? files : {};
	    },
	    isEdited: function isEdited() {
	      return this.message.params.IS_EDITED === 'Y';
	    },
	    isDeleted: function isDeleted() {
	      return this.message.params.IS_DELETED === 'Y';
	    },
	    isLargeFont: function isLargeFont() {
	      return this.showLargeFont && this.message.params.LARGE_FONT === 'Y';
	    }
	  },
	  // language=vue
	  template: "\n\t\t<div :class=\"['bx-im-message', {\n\t\t\t\t'bx-im-message-without-menu': !showMenu,\n\t\t\t\t'bx-im-message-without-avatar': !showAvatar,\n\t\t\t\t'bx-im-message-type-system': type === MessageType.system,\n\t\t\t\t'bx-im-message-type-self': type === MessageType.self,\n\t\t\t\t'bx-im-message-type-other': type !== MessageType.self,\n\t\t\t\t'bx-im-message-type-opponent': type === MessageType.opponent,\n\t\t\t\t'bx-im-message-status-error': message.error,\n\t\t\t\t'bx-im-message-status-unread': message.unread,\n\t\t\t\t'bx-im-message-status-blink': message.blink,\n\t\t\t\t'bx-im-message-status-edited': isEdited,\n\t\t\t\t'bx-im-message-status-deleted': isDeleted,\n\t\t\t\t'bx-im-message-large-font': isLargeFont,\n\t\t\t}]\" \n\t\t\t@touchstart=\"gestureRouter('touchstart', $event)\"\n\t\t\t@touchmove=\"gestureRouter('touchmove', $event)\"\n\t\t\t@touchend=\"gestureRouter('touchend', $event)\"\n\t\t\t@dblclick=\"doubleClickByMessage({message: message, event: $event})\"\n\t\t\tref=\"body\"\n\t\t\t:style=\"{\n\t\t\t\twidth: dragWidth > 0? dragWidth+'px': '', \n\t\t\t\tmarginLeft: (enableGestureQuoteFromRight && dragPosition < 0) || (!enableGestureQuoteFromRight && dragPosition > 0)? dragPosition+'px': '',\n\t\t\t}\"\n\t\t>\n\t\t\t<template v-if=\"type === MessageType.self\">\n\t\t\t\t<template v-if=\"dragIconShowRight\">\n\t\t\t\t\t<div class=\"bx-im-message-reply bx-im-message-reply-right\">\n\t\t\t\t\t\t<div class=\"bx-im-message-reply-icon\"></div>\n\t\t\t\t\t</div>\n\t\t\t\t</template> \n\t\t\t\t<div class=\"bx-im-message-box\">\n\t\t\t\t\t<component :is=\"componentBodyId\"\n\t\t\t\t\t\t:userId=\"userId\" \n\t\t\t\t\t\t:message=\"message\"\n\t\t\t\t\t\t:dialogId=\"dialogId\"\n\t\t\t\t\t\t:chatId=\"chatId\"\n\t\t\t\t\t\t:messageType=\"type\"\n\t\t\t\t\t\t:showAvatar=\"showAvatar\"\n\t\t\t\t\t\t:showName=\"showName\"\n\t\t\t\t\t\t:enableReactions=\"enableReactions\"\n\t\t\t\t\t\t:referenceContentBodyClassName=\"referenceContentBodyClassName\"\n\t\t\t\t\t\t:referenceContentNameClassName=\"referenceContentNameClassName\"\n\t\t\t\t\t/>\n\t\t\t\t</div>\n\t\t\t\t<div class=\"bx-im-message-box-status\">\n\t\t\t\t\t<template v-if=\"message.sending\">\n\t\t\t\t\t\t<div class=\"bx-im-message-sending\"></div>\n\t\t\t\t\t</template>\n\t\t\t\t\t<transition name=\"bx-im-message-status-retry\">\n\t\t\t\t\t\t<template v-if=\"!message.sending && message.error && message.retry\">\n\t\t\t\t\t\t\t<div class=\"bx-im-message-status-retry\" :title=\"$Bitrix.Loc.getMessage('IM_MESSENGER_MESSAGE_RETRY_TITLE')\" @click=\"clickByMessageRetry({message: message, event: $event})\">\n\t\t\t\t\t\t\t\t<span class=\"bx-im-message-retry-icon\"></span>\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t</template>\n\t\t\t\t\t</transition>\n\t\t\t\t\t<template v-if=\"showMenu && !message.sending && !message.error\">\n\t\t\t\t\t\t<div class=\"bx-im-message-status-menu\" :title=\"$Bitrix.Loc.getMessage('IM_MESSENGER_MESSAGE_MENU_TITLE')\" @click=\"clickByMessageMenu({message: message, event: $event})\">\n\t\t\t\t\t\t\t<span class=\"bx-im-message-menu-icon\"></span>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</template> \n\t\t\t\t</div>\n\t\t\t\t<template v-if=\"dragIconShowLeft\">\n\t\t\t\t\t<div class=\"bx-im-message-reply bx-im-message-reply-left\">\n\t\t\t\t\t\t<div class=\"bx-im-message-reply-icon\"></div>\n\t\t\t\t\t</div>\n\t\t\t\t</template> \n\t\t\t</template>\n\t\t\t<template v-else-if=\"type !== MessageType.self\">\n\t\t\t\t<template v-if=\"dragIconShowLeft\">\n\t\t\t\t\t<div class=\"bx-im-message-reply bx-im-message-reply-left\">\n\t\t\t\t\t\t<div class=\"bx-im-message-reply-icon\"></div>\n\t\t\t\t\t</div>\n\t\t\t\t</template> \n\t\t\t\t<template v-if=\"type === MessageType.opponent\">\n\t\t\t\t\t<div v-if=\"showAvatar\" class=\"bx-im-message-avatar\" @click=\"clickByAvatar({user: userData, event: $event})\">\n\t\t\t\t\t\t<div :class=\"['bx-im-message-avatar-image', {\n\t\t\t\t\t\t\t\t'bx-im-message-avatar-image-default': !userData.avatar\n\t\t\t\t\t\t\t}]\"\n\t\t\t\t\t\t\t:style=\"{\n\t\t\t\t\t\t\t\tbackgroundColor: !userData.avatar? userData.color: '', \n\t\t\t\t\t\t\t\tbackgroundImage: userAvatar\n\t\t\t\t\t\t\t}\" \n\t\t\t\t\t\t\t:title=\"userData.name\"\n\t\t\t\t\t\t></div>\t\n\t\t\t\t\t</div>\n\t\t\t\t</template>\n\t\t\t\t<div class=\"bx-im-message-box\">\n\t\t\t\t\t<component :is=\"componentBodyId\"\n\t\t\t\t\t\t:message=\"message\"\n\t\t\t\t\t\t:userId=\"userId\" \n\t\t\t\t\t\t:dialogId=\"dialogId\"\n\t\t\t\t\t\t:chatId=\"chatId\"\n\t\t\t\t\t\t:messageType=\"type\"\n\t\t\t\t\t\t:files=\"filesData\"\n\t\t\t\t\t\t:showAvatar=\"showAvatar\"\n\t\t\t\t\t\t:showName=\"showName\"\n\t\t\t\t\t\t:enableReactions=\"enableReactions\"\n\t\t\t\t\t\t:referenceContentBodyClassName=\"referenceContentBodyClassName\"\n\t\t\t\t\t\t:referenceContentNameClassName=\"referenceContentNameClassName\"\n\t\t\t\t\t/>\n\t\t\t\t</div>\n\t\t\t\t<div v-if=\"showMenu\"  class=\"bx-im-message-menu\" :title=\"$Bitrix.Loc.getMessage('IM_MESSENGER_MESSAGE_MENU_TITLE')\" @click=\"clickByMessageMenu({message: message, event: $event})\">\n\t\t\t\t\t<span class=\"bx-im-message-menu-icon\"></span>\n\t\t\t\t</div>\t\n\t\t\t\t<template v-if=\"dragIconShowRight\">\n\t\t\t\t\t<div class=\"bx-im-message-reply bx-im-message-reply-right\">\n\t\t\t\t\t\t<div class=\"bx-im-message-reply-icon\"></div>\n\t\t\t\t\t</div>\n\t\t\t\t</template> \n\t\t\t</template>\n\t\t</div>\n\t"
	});

}((this.window = this.window || {}),window,BX.Messenger.Model,BX,BX.Messenger.Const,BX.Messenger.Lib,BX.Messenger.Lib,BX.Event));





// file: /bitrix/js/im/component/dialog/dist/dialog.bundle.js
this.BX = this.BX || {};
(function (exports,ui_fonts_opensans,ui_designTokens,im_view_message,im_lib_utils,im_lib_animation,im_lib_logger,main_polyfill_intersectionobserver,ui_vue,im_const,main_core,main_core_events,ui_vue_vuex) {
	'use strict';

	var ObserverType = Object.freeze({
	  read: 'read',
	  none: 'none'
	});
	var RequestMode = Object.freeze({
	  history: 'history',
	  unread: 'unread'
	});
	var DateFormat = Object.freeze({
	  groupTitle: 'groupTitle',
	  readedTitle: 'readedTitle'
	});

	var Placeholder1 = {
	  props: ['element'],
	  created: function created() {
	    var modes = ['self', 'opponent'];
	    var randomIndex = Math.floor(Math.random() * modes.length);
	    this.mode = modes[randomIndex];
	  },
	  computed: {
	    itemClasses: function itemClasses() {
	      var itemClasses = ['im-skeleton-item', 'im-skeleton-item--sm', "".concat(im_const.DialogReferenceClassName.listItem, "-").concat(this.element.id)];
	      if (this.mode === 'self') {
	        itemClasses.push('im-skeleton-item-self');
	      } else {
	        itemClasses.push('im-skeleton-item-opponent');
	      }
	      return itemClasses;
	    }
	  },
	  template: "\n\t\t<div :class=\"itemClasses\" :key=\"element.templateId\">\n\t\t\t<div v-if=\"mode === 'opponent'\" class=\"im-skeleton-logo\"></div>\n\t\t\t<div class=\"im-skeleton-content\">\n\t\t\t\t<div class=\"im-skeleton-line-row\">\n\t\t\t\t\t<div style=\"max-width: 70%\" class=\"im-skeleton-line\"></div>\n\t\t\t\t</div>\n\t\t\t\t<div class=\"im-skeleton-line-row\">\n\t\t\t\t\t<div style=\"max-width: 100%\" class=\"im-skeleton-line\"></div>\n\t\t\t\t\t<div style=\"max-width: 26px; margin-left: auto;\" class=\"im-skeleton-line\"></div>\n\t\t\t\t</div>\n\t\t\t\t<div class=\"im-skeleton-like\"></div>\n\t\t\t</div>\n\t\t</div>\n\t"
	};

	var Placeholder2 = {
	  props: ['element'],
	  created: function created() {
	    var modes = ['self', 'opponent'];
	    var randomIndex = Math.floor(Math.random() * modes.length);
	    this.mode = modes[randomIndex];
	  },
	  computed: {
	    itemClasses: function itemClasses() {
	      var itemClasses = ['im-skeleton-item', 'im-skeleton-item--md', "".concat(im_const.DialogReferenceClassName.listItem, "-").concat(this.element.id)];
	      if (this.mode === 'self') {
	        itemClasses.push('im-skeleton-item-self');
	      } else {
	        itemClasses.push('im-skeleton-item-opponent');
	      }
	      return itemClasses;
	    }
	  },
	  template: "\n\t\t<div :class=\"itemClasses\" :key=\"element.templateId\">\n\t\t\t<div v-if=\"mode === 'opponent'\" class=\"im-skeleton-logo\"></div>\n\t\t\t<div class=\"im-skeleton-content\">\n\t\t\t\t<div class=\"im-skeleton-line-row\">\n\t\t\t\t\t<div style=\"max-width: 35%\" class=\"im-skeleton-line\"></div>\n\t\t\t\t</div>\n\t\t\t\t<div class=\"im-skeleton-line-row\">\n\t\t\t\t\t<div style=\"max-width: 100%\" class=\"im-skeleton-line\"></div>\n\t\t\t\t</div>\n\t\t\t\t<div class=\"im-skeleton-line-row\">\n\t\t\t\t\t<div style=\"max-width: 55%\" class=\"im-skeleton-line\"></div>\n\t\t\t\t\t<div style=\"max-width: 26px; margin-left: auto;\" class=\"im-skeleton-line\"></div>\n\t\t\t\t</div>\n\t\t\t\t<div class=\"im-skeleton-like\"></div>\n\t\t\t</div>\n\t\t</div>\n\t"
	};

	var Placeholder3 = {
	  props: ['element'],
	  created: function created() {
	    var modes = ['self', 'opponent'];
	    var randomIndex = Math.floor(Math.random() * modes.length);
	    this.mode = modes[randomIndex];
	  },
	  computed: {
	    itemClasses: function itemClasses() {
	      var itemClasses = ['im-skeleton-item', 'im-skeleton-item--md', "".concat(im_const.DialogReferenceClassName.listItem, "-").concat(this.element.id)];
	      if (this.mode === 'self') {
	        itemClasses.push('im-skeleton-item-self');
	      } else {
	        itemClasses.push('im-skeleton-item-opponent');
	      }
	      return itemClasses;
	    }
	  },
	  template: "\n\t\t<div :class=\"itemClasses\" :key=\"element.templateId\">\n\t\t\t<div v-if=\"mode === 'opponent'\" class=\"im-skeleton-logo\"></div>\n\t\t\t<div class=\"im-skeleton-content\">\n\t\t\t\t<div class=\"im-skeleton-line-row\">\n\t\t\t\t\t<div style=\"max-width: 35%\" class=\"im-skeleton-line\"></div>\n\t\t\t\t</div>\n\t\t\t\t<div class=\"im-skeleton-line-row\">\n\t\t\t\t\t<div style=\"max-width: 100%\" class=\"im-skeleton-line\"></div>\n\t\t\t\t</div>\n\t\t\t\t<div class=\"im-skeleton-line-row\">\n\t\t\t\t\t<div style=\"max-width: 55%\" class=\"im-skeleton-line\"></div>\n\t\t\t\t</div>\n\t\t\t\t<div class=\"im-skeleton-line-row\">\n\t\t\t\t\t<div style=\"max-width: 26px; margin-left: auto;\" class=\"im-skeleton-line\"></div>\n\t\t\t\t</div>\n\t\t\t\t<div class=\"im-skeleton-like\"></div>\n\t\t\t</div>\n\t\t</div>\n\t"
	};

	function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
	function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { babelHelpers.defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
	var MessageList = {
	  /**
	   * @emits EventType.dialog.readMessage
	   * @emits EventType.dialog.clickOnDialog
	   * @emits EventType.dialog.clickOnCommand
	   * @emits EventType.dialog.clickOnMention
	   * @emits EventType.dialog.clickOnReadList
	   */
	  props: {
	    userId: {
	      type: Number,
	      "default": 0
	    },
	    dialogId: {
	      type: String,
	      "default": "0"
	    },
	    messageLimit: {
	      type: Number,
	      "default": 50
	    },
	    enableReadMessages: {
	      type: Boolean,
	      "default": true
	    },
	    enableReactions: {
	      type: Boolean,
	      "default": true
	    },
	    enableDateActions: {
	      type: Boolean,
	      "default": true
	    },
	    enableCreateContent: {
	      type: Boolean,
	      "default": true
	    },
	    enableGestureQuote: {
	      type: Boolean,
	      "default": true
	    },
	    enableGestureQuoteFromRight: {
	      type: Boolean,
	      "default": true
	    },
	    enableGestureMenu: {
	      type: Boolean,
	      "default": false
	    },
	    showMessageUserName: {
	      type: Boolean,
	      "default": true
	    },
	    showMessageAvatar: {
	      type: Boolean,
	      "default": true
	    },
	    showMessageMenu: {
	      type: Boolean,
	      "default": true
	    }
	  },
	  components: {
	    Placeholder1: Placeholder1,
	    Placeholder2: Placeholder2,
	    Placeholder3: Placeholder3
	  },
	  data: function data() {
	    return {
	      messagesSet: false,
	      scrollAnimating: false,
	      showScrollButton: false,
	      captureMove: false,
	      capturedMoveEvent: null,
	      lastMessageId: null,
	      isRequestingHistory: false,
	      historyPagesRequested: 0,
	      stopHistoryLoading: false,
	      isRequestingUnread: false,
	      unreadPagesRequested: 0,
	      placeholderCount: 0,
	      pagesLoaded: 0
	    };
	  },
	  created: function created() {
	    im_lib_logger.Logger.warn('MessageList component is created');
	    this.initParams();
	    this.initEvents();
	  },
	  beforeDestroy: function beforeDestroy() {
	    this.observers = {};
	    clearTimeout(this.scrollButtonShowTimeout);
	    this.clearEvents();
	  },
	  mounted: function mounted() {
	    this.windowFocused = im_lib_utils.Utils.platform.isBitrixMobile() ? true : document.hasFocus();
	    this.getMessageIdsForPagination();
	    this.scrollOnStart();
	  },
	  watch: {
	    // after each dialog switch (without switching to loading state)
	    // we reset messagesSet flag and run scroll on start routine
	    dialogId: function dialogId(newValue, oldValue) {
	      var _this = this;
	      im_lib_logger.Logger.warn('new dialogId in message-list', newValue);
	      this.messagesSet = false;
	      this.$nextTick(function () {
	        _this.scrollOnStart();
	      });
	    }
	  },
	  computed: _objectSpread({
	    TemplateType: function TemplateType() {
	      return im_const.DialogTemplateType;
	    },
	    ObserverType: function ObserverType$$1() {
	      return ObserverType;
	    },
	    DialogReferenceClassName: function DialogReferenceClassName() {
	      return im_const.DialogReferenceClassName;
	    },
	    localize: function localize() {
	      return ui_vue.WidgetBitrixVue.getFilteredPhrases('IM_MESSENGER_DIALOG_', this);
	    },
	    dialog: function dialog() {
	      var dialog = this.$store.getters['dialogues/get'](this.dialogId);
	      return dialog ? dialog : this.$store.getters['dialogues/getBlank']();
	    },
	    chatId: function chatId() {
	      if (this.application) {
	        return this.application.dialog.chatId;
	      }
	    },
	    collection: function collection() {
	      return this.$store.getters['messages/get'](this.chatId);
	    },
	    formattedCollection: function formattedCollection() {
	      var _this2 = this;
	      this.lastMessageId = 0; //used in readed status
	      this.lastMessageAuthorId = 0; //used in readed status
	      this.firstUnreadMessageId = 0;
	      var lastAuthorId = 0; //used for delimeters
	      var dateGroups = {}; //date grouping nodes
	      var collection = []; //array to return

	      this.collection.forEach(function (element) {
	        if (_this2.messagesSet && (_this2.lastHistoryMessageId === null || _this2.lastHistoryMessageId > element.id)) {
	          im_lib_logger.Logger.warn('setting new lastHistoryMessageId', element.id);
	          _this2.lastHistoryMessageId = element.id;
	        }
	        _this2.lastMessageId = element.id;
	        var group = _this2.getDateGroup(element.date);
	        if (!dateGroups[group.title]) {
	          dateGroups[group.title] = group.id;
	          collection.push(_this2.getDateGroupBlock(group.id, group.title));
	        } else if (lastAuthorId !== element.authorId) {
	          collection.push(_this2.getDelimiterBlock(element.id));
	        }
	        if (element.unread && !_this2.firstUnreadMessageId) {
	          _this2.firstUnreadMessageId = element.id;
	        }
	        collection.push(element);
	        lastAuthorId = element.authorId;
	      });

	      //remembering author of last message - used in readed status
	      this.lastMessageAuthorId = lastAuthorId;
	      return collection;
	    },
	    writingStatusText: function writingStatusText() {
	      var _this3 = this;
	      clearTimeout(this.scrollToTimeout);
	      if (this.dialog.writingList.length === 0) {
	        return '';
	      }

	      //scroll to bottom
	      if (!this.scrollChangedByUser && !this.showScrollButton) {
	        this.scrollToTimeout = setTimeout(function () {
	          return _this3.animatedScrollToPosition({
	            duration: 500
	          });
	        }, 300);
	      }
	      var text = this.dialog.writingList.map(function (element) {
	        return element.userName;
	      }).join(', ');
	      return this.localize['IM_MESSENGER_DIALOG_WRITES_MESSAGE'].replace('#USER#', text);
	    },
	    statusReaded: function statusReaded() {
	      var _this4 = this;
	      clearTimeout(this.scrollToTimeout);
	      if (this.dialog.readedList.length === 0) {
	        return '';
	      }
	      var text = '';
	      if (this.dialog.type === im_const.DialogType["private"]) {
	        var record = this.dialog.readedList[0];
	        if (record.messageId === this.lastMessageId && record.userId !== this.lastMessageAuthorId) {
	          var dateFormat = this.getDateFormat(DateFormat.readedTitle);
	          var formattedDate = this.getDateObject().format(dateFormat, record.date);
	          text = this.localize['IM_MESSENGER_DIALOG_MESSAGES_READED_USER'].replace('#DATE#', formattedDate);
	        }
	      } else {
	        var readedList = this.dialog.readedList.filter(function (record) {
	          return record.messageId === _this4.lastMessageId && record.userId !== _this4.lastMessageAuthorId;
	        });
	        if (readedList.length === 1) {
	          text = this.localize['IM_MESSENGER_DIALOG_MESSAGES_READED_CHAT'].replace('#USERS#', readedList[0].userName);
	        } else if (readedList.length > 1) {
	          text = this.localize['IM_MESSENGER_DIALOG_MESSAGES_READED_CHAT'].replace('#USERS#', this.localize['IM_MESSENGER_DIALOG_MESSAGES_READED_CHAT_PLURAL'].replace('#USER#', readedList[0].userName).replace('#COUNT#', readedList.length - 1).replace('[LINK]', '').replace('[/LINK]', ''));
	        }
	      }
	      if (!text) {
	        return '';
	      }

	      //scroll to bottom
	      if (!this.scrollChangedByUser && !this.showScrollButton) {
	        this.scrollToTimeout = setTimeout(function () {
	          return _this4.animatedScrollToPosition({
	            duration: 500
	          });
	        }, 300);
	      }
	      return text;
	    },
	    unreadCounter: function unreadCounter() {
	      return this.dialog.counter > 99 ? 999 : this.dialog.counter;
	    },
	    formattedUnreadCounter: function formattedUnreadCounter() {
	      return this.unreadCounter > 99 ? '99+' : this.unreadCounter;
	    },
	    scrollBlocked: function scrollBlocked() {
	      if (this.application.device.type !== im_const.DeviceType.mobile) {
	        return false;
	      }
	      return this.scrollAnimating || this.captureMove;
	    },
	    isDarkBackground: function isDarkBackground() {
	      return this.application.options.darkBackground;
	    },
	    isMobile: function isMobile() {
	      return this.application.device.type === im_const.DeviceType.mobile;
	    },
	    //new
	    isRequestingData: function isRequestingData() {
	      return this.isRequestingHistory || this.isRequestingUnread;
	    },
	    remainingHistoryPages: function remainingHistoryPages() {
	      return Math.ceil((this.dialog.messageCount - this.collection.length) / this.historyMessageLimit);
	    },
	    remainingUnreadPages: function remainingUnreadPages() {
	      // we dont use unread counter now - we reverted unread counter to be max at 99, so we dont know actual counter

	      if (this.isLastIdInCollection) {
	        return 0;
	      }
	      return Math.ceil((this.dialog.messageCount - this.collection.length) / this.unreadMessageLimit);
	    },
	    unreadInCollection: function unreadInCollection() {
	      return this.collection.filter(function (item) {
	        return item.unread === true;
	      });
	    },
	    isLastIdInCollection: function isLastIdInCollection() {
	      return this.collection.map(function (message) {
	        return message.id;
	      }).includes(this.dialog.lastMessageId);
	    },
	    showStatusPlaceholder: function showStatusPlaceholder() {
	      return !this.writingStatusText && !this.statusReaded;
	    },
	    bodyClasses: function bodyClasses() {
	      return [im_const.DialogReferenceClassName.listBody, {
	        'bx-im-dialog-list-scroll-blocked': this.scrollBlocked,
	        'bx-im-dialog-dark-background': this.isDarkBackground,
	        'bx-im-dialog-mobile': this.isMobile
	      }];
	    }
	  }, ui_vue_vuex.WidgetVuex.mapState({
	    application: function application(state) {
	      return state.application;
	    }
	  })),
	  methods: {
	    /* region 01. Init and destroy */initParams: function initParams() {
	      this.placeholdersComposition = this.getPlaceholdersComposition();
	      this.historyMessageLimit = 50;
	      this.unreadMessageLimit = 50;
	      this.showScrollButton = this.unreadCounter > 0;
	      this.scrollingDownThreshold = 1000;
	      this.scrollingUpThreshold = 1000;
	      this.messageScrollOffset = 20;
	      this.lastScroll = 0;
	      this.scrollChangedByUser = false;
	      this.scrollButtonDiff = 100;
	      this.scrollButtonShowTimeout = null;
	      this.scrollPositionChangeTime = new Date().getTime();
	      this.lastRequestTime = new Date().getTime();
	      this.observers = {};
	      this.lastAuthorId = 0;
	      this.lastHistoryMessageId = null;
	      this.firstUnreadMessageId = null;
	      this.lastUnreadMessageId = null;
	      this.dateFormatFunction = null;
	      this.cachedDateGroups = {};
	      this.readMessageQueue = [];
	      this.readMessageTarget = {};
	      this.readVisibleMessagesDelayed = im_lib_utils.Utils.debounce(this.readVisibleMessages, 50, this);
	      this.requestHistoryDelayed = im_lib_utils.Utils.debounce(this.requestHistory, 50, this);
	    },
	    initEvents: function initEvents() {
	      main_core_events.EventEmitter.subscribe(im_const.EventType.dialog.scrollOnStart, this.onScrollOnStart);
	      main_core_events.EventEmitter.subscribe(im_const.EventType.dialog.scrollToBottom, this.onScrollToBottom);
	      main_core_events.EventEmitter.subscribe(im_const.EventType.dialog.readVisibleMessages, this.onReadVisibleMessages);
	      main_core_events.EventEmitter.subscribe(im_const.EventType.dialog.newMessage, this.onNewMessage);
	      main_core_events.EventEmitter.subscribe(im_const.EventType.dialog.requestUnread, this.onExternalUnreadRequest);
	      main_core_events.EventEmitter.subscribe(im_const.EventType.dialog.messagesSet, this.onMessagesSet);
	      main_core_events.EventEmitter.subscribe(im_const.EventType.dialog.beforeMobileKeyboard, this.onBeforeMobileKeyboard);
	      window.addEventListener("orientationchange", this.onOrientationChange);
	      window.addEventListener('focus', this.onWindowFocus);
	      window.addEventListener('blur', this.onWindowBlur);
	      ui_vue.WidgetBitrixVue.event.$on('bitrixmobile:controller:focus', this.onWindowFocus);
	      ui_vue.WidgetBitrixVue.event.$on('bitrixmobile:controller:blur', this.onWindowBlur);
	    },
	    clearEvents: function clearEvents() {
	      main_core_events.EventEmitter.unsubscribe(im_const.EventType.dialog.scrollOnStart, this.onScrollOnStart);
	      main_core_events.EventEmitter.unsubscribe(im_const.EventType.dialog.scrollToBottom, this.onScrollToBottom);
	      main_core_events.EventEmitter.unsubscribe(im_const.EventType.dialog.readVisibleMessages, this.onReadVisibleMessages);
	      main_core_events.EventEmitter.unsubscribe(im_const.EventType.dialog.newMessage, this.onNewMessage);
	      main_core_events.EventEmitter.unsubscribe(im_const.EventType.dialog.requestUnread, this.onExternalUnreadRequest);
	      main_core_events.EventEmitter.unsubscribe(im_const.EventType.dialog.messagesSet, this.onMessagesSet);
	      main_core_events.EventEmitter.unsubscribe(im_const.EventType.dialog.beforeMobileKeyboard, this.onBeforeMobileKeyboard);
	      window.removeEventListener("orientationchange", this.onOrientationChange);
	      window.removeEventListener('focus', this.onWindowFocus);
	      window.removeEventListener('blur', this.onWindowBlur);
	      ui_vue.WidgetBitrixVue.event.$off('bitrixmobile:controller:focus', this.onWindowFocus);
	      ui_vue.WidgetBitrixVue.event.$off('bitrixmobile:controller:blur', this.onWindowBlur);
	    },
	    /* endregion 01. Init and destroy */
	    /* region 02. Event handlers */
	    onDialogClick: function onDialogClick(event) {
	      if (ui_vue.WidgetBitrixVue.testNode(event.target, {
	        className: 'bx-im-message-command'
	      })) {
	        this.onCommandClick(event);
	      } else if (ui_vue.WidgetBitrixVue.testNode(event.target, {
	        className: 'bx-im-mention'
	      })) {
	        this.onMentionClick(event);
	      }
	      this.windowFocused = true;
	      main_core_events.EventEmitter.emit(im_const.EventType.dialog.clickOnDialog, {
	        event: event
	      });
	    },
	    onDialogMove: function onDialogMove(event) {
	      if (!this.captureMove) {
	        return;
	      }
	      this.capturedMoveEvent = event;
	    },
	    onCommandClick: function onCommandClick(event) {
	      var value = '';
	      if (event.target.dataset.entity === 'send' || event.target.dataset.entity === 'put') {
	        value = event.target.nextSibling.innerHTML;
	      } else if (event.target.dataset.entity === 'call') {
	        value = event.target.dataset.command;
	      }
	      main_core_events.EventEmitter.emit(im_const.EventType.dialog.clickOnCommand, {
	        type: event.target.dataset.entity,
	        value: value,
	        event: event
	      });
	    },
	    onMentionClick: function onMentionClick(event) {
	      main_core_events.EventEmitter.emit(im_const.EventType.dialog.clickOnMention, {
	        type: event.target.dataset.type,
	        value: event.target.dataset.value,
	        event: event
	      });
	    },
	    onOrientationChange: function onOrientationChange() {
	      var _this5 = this;
	      clearTimeout(this.scrollToTimeout);
	      if (this.application.device.type !== im_const.DeviceType.mobile) {
	        return false;
	      }
	      im_lib_logger.Logger.log('Orientation changed');
	      if (!this.scrollChangedByUser) {
	        this.scrollToTimeout = setTimeout(function () {
	          return _this5.scrollToBottom({
	            force: true
	          });
	        }, 300);
	      }
	    },
	    onWindowFocus: function onWindowFocus() {
	      this.windowFocused = true;
	      this.readVisibleMessages();
	      return true;
	    },
	    onWindowBlur: function onWindowBlur() {
	      this.windowFocused = false;
	    },
	    onScrollToBottom: function onScrollToBottom() {
	      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	        _ref$data = _ref.data,
	        event = _ref$data === void 0 ? {
	          chatId: 0,
	          force: false,
	          cancelIfScrollChange: false,
	          duration: null
	        } : _ref$data;
	      if (event.chatId !== this.chatId) {
	        return false;
	      }
	      im_lib_logger.Logger.warn('onScrollToBottom', event);
	      event.force = event.force === true;
	      event.cancelIfScrollChange = event.cancelIfScrollChange === true;
	      if (this.firstUnreadMessageId) {
	        im_lib_logger.Logger.warn('Dialog.onScrollToBottom: canceled - unread messages');
	        return false;
	      }
	      if (event.cancelIfScrollChange && this.scrollChangedByUser && this.scrollBeforeMobileKeyboard) {
	        var body = this.$refs.body;
	        this.scrollAfterMobileKeyboard = body.scrollHeight - body.scrollTop - body.clientHeight;
	        var scrollDiff = this.scrollAfterMobileKeyboard - this.scrollBeforeMobileKeyboard;
	        this.animatedScrollToPosition({
	          start: body.scrollTop,
	          end: body.scrollTop + scrollDiff
	        });
	        return true;
	      }
	      this.scrollToBottom(event);
	      return true;
	    },
	    onReadVisibleMessages: function onReadVisibleMessages() {
	      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	        _ref2$data = _ref2.data,
	        event = _ref2$data === void 0 ? {
	          chatId: 0
	        } : _ref2$data;
	      if (event.chatId !== this.chatId) {
	        return false;
	      }
	      im_lib_logger.Logger.warn('onReadVisibleMessages');
	      this.readVisibleMessagesDelayed();
	      return true;
	    },
	    onClickOnReadList: function onClickOnReadList(event) {
	      var _this6 = this;
	      var readedList = this.dialog.readedList.filter(function (record) {
	        return record.messageId === _this6.lastMessageId && record.userId !== _this6.lastMessageAuthorId;
	      });
	      main_core_events.EventEmitter.emit(im_const.EventType.dialog.clickOnReadList, {
	        list: readedList,
	        event: event
	      });
	    },
	    onDragMessage: function onDragMessage(event) {
	      if (!this.windowFocused) {
	        return false;
	      }
	      this.captureMove = event.result;
	      if (!event.result) {
	        this.capturedMoveEvent = null;
	      }
	    },
	    onScroll: function onScroll(event) {
	      if (this.isScrolling) {
	        return false;
	      }
	      clearTimeout(this.scrollToTimeout);
	      this.currentScroll = event.target.scrollTop;
	      var isScrollingDown = this.lastScroll < this.currentScroll;
	      var isScrollingUp = !isScrollingDown;
	      if (isScrollingUp && this.scrollButtonClicked) {
	        im_lib_logger.Logger.warn('scrollUp - reset scroll button clicks');
	        this.scrollButtonClicked = false;
	      }
	      var leftSpaceBottom = event.target.scrollHeight - event.target.scrollTop - event.target.clientHeight;
	      if (this.currentScroll > 0 && isScrollingDown && leftSpaceBottom < this.scrollingDownThreshold) {
	        this.onScrollDown();
	      } else if (isScrollingUp && this.currentScroll <= this.scrollingUpThreshold) {
	        this.onScrollUp();
	      }

	      //remember current scroll to compare with new ones
	      this.lastScroll = this.currentScroll;
	      this.scrollPositionChangeTime = new Date().getTime();
	      //show or hide scroll button
	      this.manageScrollButton(event);
	    },
	    onScrollDown: function onScrollDown() {
	      var _this7 = this;
	      if (!this.messagesSet || this.isLastIdInCollection) {
	        return false;
	      }
	      // Logger.warn('---');
	      // Logger.warn('Want to load unread');
	      // Logger.warn('this.isRequestingData', this.isRequestingData);
	      // Logger.warn('this.unreadPagesRequested', this.unreadPagesRequested);
	      // Logger.warn('this.remainingUnreadPages', this.remainingUnreadPages);
	      if (this.isRequestingData && this.remainingUnreadPages > 0) {
	        this.drawPlaceholders(RequestMode.unread).then(function () {
	          _this7.unreadPagesRequested += 1;
	          im_lib_logger.Logger.warn('Already loading! Draw placeholders and add request, total - ', _this7.unreadPagesRequested);
	        });
	      } else if (!this.isRequestingData && this.remainingUnreadPages > 0) {
	        im_lib_logger.Logger.warn('Starting new unread request');
	        this.isRequestingUnread = true;
	        this.drawPlaceholders(RequestMode.unread).then(function () {
	          _this7.requestUnread();
	        });
	      }
	    },
	    onScrollUp: function onScrollUp() {
	      var _this8 = this;
	      if (!this.messagesSet || this.stopHistoryLoading) {
	        return false;
	      }
	      this.projectedPagesToLoad = 1;

	      //draw 3 sets of placeholders if we are close to top of container
	      if (!this.isMobile && this.$refs.body.scrollTop < this.$refs.body.scrollHeight / 4) {
	        this.projectedPagesToLoad = 3;
	      }

	      // Logger.warn('---');
	      // Logger.warn('Want to load history');
	      // Logger.warn('this.isRequestingData', this.isRequestingData);
	      // Logger.warn('this.historyPagesRequested', this.historyPagesRequested);
	      // Logger.warn('this.remainingHistoryPages', this.remainingHistoryPages);
	      if (this.isRequestingData && this.remainingHistoryPages > 0) {
	        var currentBodyHeight = this.$refs.body.scrollHeight;
	        this.drawPlaceholders(RequestMode.history, this.projectedPagesToLoad).then(function () {
	          if (!_this8.isOverflowAnchorSupported()) {
	            _this8.enableUserScroll();
	          }
	          _this8.historyPagesRequested += _this8.projectedPagesToLoad;
	          im_lib_logger.Logger.warn('Already loading! Draw placeholders and add request, total - ', _this8.historyPagesRequested);
	        });
	        if (!this.isOverflowAnchorSupported()) {
	          im_lib_logger.Logger.warn('Disabling user scroll');
	          this.$nextTick(function () {
	            var heightDifference = _this8.$refs.body.scrollHeight - currentBodyHeight;
	            _this8.disableUserScroll();
	            _this8.forceScrollToPosition(_this8.$refs.body.scrollTop + heightDifference);
	          });
	        }
	      } else if (!this.isRequestingData && this.remainingHistoryPages > 0) {
	        im_lib_logger.Logger.warn('Starting new history request');
	        this.isRequestingHistory = true;
	        var _currentBodyHeight = this.$refs.body.scrollHeight;
	        this.drawPlaceholders(RequestMode.history, this.projectedPagesToLoad).then(function () {
	          _this8.historyPagesRequested = _this8.projectedPagesToLoad - 1;
	          if (!_this8.isOverflowAnchorSupported()) {
	            _this8.enableUserScroll();
	          }
	          _this8.requestHistory();
	        });
	        //will run right after drawing placeholders, before .then()
	        if (!this.isOverflowAnchorSupported()) {
	          im_lib_logger.Logger.warn('Disabling user scroll');
	          this.$nextTick(function () {
	            var heightDifference = _this8.$refs.body.scrollHeight - _currentBodyHeight;
	            _this8.disableUserScroll();
	            _this8.forceScrollToPosition(_this8.$refs.body.scrollTop + heightDifference);
	          });
	        }
	      }
	    },
	    //TODO: move
	    isOverflowAnchorSupported: function isOverflowAnchorSupported() {
	      return !im_lib_utils.Utils.platform.isBitrixMobile() && !im_lib_utils.Utils.browser.isIe() && !im_lib_utils.Utils.browser.isSafari() && !im_lib_utils.Utils.browser.isSafariBased();
	    },
	    disableUserScroll: function disableUserScroll() {
	      this.$refs.body.classList.add('bx-im-dialog-list-scroll-blocked');
	    },
	    enableUserScroll: function enableUserScroll() {
	      this.$refs.body.classList.remove('bx-im-dialog-list-scroll-blocked');
	    },
	    onScrollButtonClick: function onScrollButtonClick() {
	      im_lib_logger.Logger.warn('Scroll button click', this.scrollButtonClicked);
	      // TODO: now we just do nothing if button was clicked during data request (history or unread)
	      if (this.isRequestingData) {
	        return false;
	      }

	      //we dont have unread - just scroll to bottom
	      if (this.unreadCounter === 0) {
	        this.scrollToBottom();
	        return true;
	      }

	      //it's a second click on button - scroll to last page if we have one
	      if (this.scrollButtonClicked && this.remainingUnreadPages > 0) {
	        im_lib_logger.Logger.warn('Second click on scroll button');
	        this.scrollToLastPage();
	        return true;
	      }

	      //it's a first click - just set the flag and move on
	      this.scrollButtonClicked = true;
	      this.scrollToBottom();
	    },
	    onNewMessage: function onNewMessage(_ref3) {
	      var _this9 = this;
	      var _ref3$data = _ref3.data,
	        chatId = _ref3$data.chatId,
	        messageId = _ref3$data.messageId;
	      if (chatId !== this.chatId) {
	        return false;
	      }
	      im_lib_logger.Logger.warn('Received new message from pull', messageId);
	      if (this.showScrollButton) {
	        return false;
	      }
	      this.$nextTick(function () {
	        //non-focus handling
	        if (!_this9.windowFocused) {
	          var availableScrollHeight = _this9.$refs['body'].scrollHeight - _this9.$refs['body'].clientHeight;
	          if (_this9.currentScroll < availableScrollHeight) {
	            //show scroll button when out of focus and all visible space is filled with unread messaages already
	            _this9.showScrollButton = true;
	          }
	          _this9.scrollToFirstUnreadMessage();
	          return true;
	        }

	        //big message handling
	        var messageElement = _this9.getElementById(messageId);
	        if (!messageElement) {
	          return false;
	        }
	        //if big message - scroll to top of it
	        var body = _this9.$refs.body;
	        if (messageElement.clientHeight > body.clientHeight) {
	          _this9.scrollToMessage({
	            messageId: messageId
	          });
	          return true;
	        }
	        //else - scroll to bottom
	        _this9.animatedScrollToPosition();
	      });
	    },
	    onMessagesSet: function onMessagesSet(_ref4) {
	      var event = _ref4.data;
	      if (event.chatId !== this.chatId) {
	        return false;
	      }
	      if (this.messagesSet === true) {
	        im_lib_logger.Logger.warn('messages are already set');
	        return false;
	      }
	      im_lib_logger.Logger.warn('onMessagesSet', event.chatId);
	      this.messagesSet = true;
	      var force = false;
	      //if we are in top half of container - force scroll to first unread, else - animated scroll
	      if (this.$refs.body.scrollTop < this.$refs.body.scrollHeight / 2) {
	        force = true;
	      }
	      this.scrollToBottom({
	        force: force,
	        cancelIfScrollChange: false
	      });
	    },
	    onBeforeMobileKeyboard: function onBeforeMobileKeyboard(_ref5) {
	      var event = _ref5.data;
	      var body = this.$refs.body;
	      this.scrollBeforeMobileKeyboard = body.scrollHeight - body.scrollTop - body.clientHeight;
	    },
	    onExternalUnreadRequest: function onExternalUnreadRequest() {
	      var _this10 = this;
	      var _ref6 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	        _ref6$data = _ref6.data,
	        event = _ref6$data === void 0 ? {
	          chatId: 0
	        } : _ref6$data;
	      if (event.chatId !== this.chatId) {
	        return false;
	      }
	      im_lib_logger.Logger.warn('onExternalUnreadRequest');
	      this.isRequestingUnread = true;
	      this.drawPlaceholders(RequestMode.unread).then(function () {
	        return _this10.requestUnread();
	      });
	      this.externalUnreadRequestResolve = null;
	      return new Promise(function (resolve, reject) {
	        _this10.externalUnreadRequestResolve = resolve;
	      });
	    },
	    onScrollOnStart: function onScrollOnStart(_ref7) {
	      var event = _ref7.data;
	      if (event.chatId !== this.chatId) {
	        return false;
	      }
	      this.scrollOnStart({
	        force: false
	      });
	    },
	    /* endregion 02. Event handlers */
	    /* region 03. Scrolling */
	    scrollOnStart: function scrollOnStart() {
	      var _ref8 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	        _ref8$force = _ref8.force,
	        force = _ref8$force === void 0 ? true : _ref8$force;
	      im_lib_logger.Logger.warn('scrolling on start of dialog');
	      var unreadId = this.getFirstUnreadMessage();
	      if (unreadId) {
	        this.scrollToFirstUnreadMessage(unreadId, force);
	      } else {
	        var body = this.$refs.body;
	        this.forceScrollToPosition(body.scrollHeight - body.clientHeight);
	      }
	    },
	    //scroll to first unread if counter > 0, else scroll to bottom
	    scrollToBottom: function scrollToBottom() {
	      var _ref9 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	        _ref9$force = _ref9.force,
	        force = _ref9$force === void 0 ? false : _ref9$force,
	        _ref9$cancelIfScrollC = _ref9.cancelIfScrollChange,
	        cancelIfScrollChange = _ref9$cancelIfScrollC === void 0 ? false : _ref9$cancelIfScrollC,
	        _ref9$duration = _ref9.duration,
	        duration = _ref9$duration === void 0 ? null : _ref9$duration;
	      im_lib_logger.Logger.warn('scroll to bottom', force, cancelIfScrollChange, duration);
	      if (cancelIfScrollChange && this.scrollChangedByUser) {
	        return false;
	      }
	      var body = this.$refs.body;

	      //scroll to first unread message if there are unread messages
	      if (this.dialog.counter > 0) {
	        var scrollToMessageId = this.dialog.counter > 1 && this.firstUnreadMessageId ? this.firstUnreadMessageId : this.lastMessageId;
	        this.scrollToFirstUnreadMessage(scrollToMessageId, force);
	        return true;
	      }

	      //hide scroll button because we will scroll to bottom
	      this.showScrollButton = false;

	      //without animation
	      if (force) {
	        this.forceScrollToPosition(body.scrollHeight - body.clientHeight);
	      }
	      //with animation
	      else {
	        var scrollParams = {};
	        if (duration) {
	          scrollParams.duration = duration;
	        }
	        this.animatedScrollToPosition(_objectSpread({}, scrollParams));
	      }
	    },
	    scrollToFirstUnreadMessage: function scrollToFirstUnreadMessage() {
	      var unreadId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
	      var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
	      im_lib_logger.Logger.warn('scroll to first unread');
	      var element = false;
	      if (unreadId !== null) {
	        element = this.getElementById(unreadId);
	      }
	      if (!element) {
	        unreadId = this.getFirstUnreadMessage();
	      }
	      this.scrollToMessage({
	        messageId: unreadId,
	        force: force
	      });
	    },
	    //scroll to message - can be set at the top or at the bottom of screen
	    scrollToMessage: function scrollToMessage(_ref10) {
	      var _ref10$messageId = _ref10.messageId,
	        messageId = _ref10$messageId === void 0 ? 0 : _ref10$messageId,
	        _ref10$force = _ref10.force,
	        force = _ref10$force === void 0 ? false : _ref10$force,
	        _ref10$stickToTop = _ref10.stickToTop,
	        stickToTop = _ref10$stickToTop === void 0 ? true : _ref10$stickToTop;
	      im_lib_logger.Logger.warn('scroll to message');
	      var body = this.$refs.body;
	      var element = this.getElementById(messageId);
	      var end = 0;
	      if (!element) {
	        //if no element found in DOM - scroll to top
	        if (stickToTop) {
	          end = 10;
	        }
	        //if no element and stickToTop = false - scroll to bottom
	        else {
	          end = body.scrollHeight - body.clientHeight;
	        }
	      } else if (stickToTop) {
	        //message will be at the top of screen (+little offset)
	        end = element.offsetTop - this.messageScrollOffset / 2;
	      } else {
	        //message will be at the bottom of screen (+little offset)
	        end = element.offsetTop + element.offsetHeight - body.clientHeight + this.messageScrollOffset / 2;
	      }
	      if (force) {
	        this.forceScrollToPosition(end);
	      } else {
	        this.animatedScrollToPosition({
	          end: end
	        });
	      }
	      return true;
	    },
	    forceScrollToPosition: function forceScrollToPosition(position) {
	      im_lib_logger.Logger.warn('Force scroll to position - ', position);
	      var body = this.$refs.body;
	      if (!body) {
	        return false;
	      }
	      if (this.animateScrollId) {
	        im_lib_animation.Animation.cancel(this.animateScrollId);
	        this.scrollAnimating = false;
	        this.animateScrollId = null;
	      }
	      body.scrollTop = position;
	    },
	    //scroll to provided position with animation, by default - to the bottom
	    animatedScrollToPosition: function animatedScrollToPosition() {
	      var _this11 = this;
	      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	      im_lib_logger.Logger.warn('Animated scroll to - ', params);
	      if (this.animateScrollId) {
	        im_lib_animation.Animation.cancel(this.animateScrollId);
	        this.scrollAnimating = false;
	      }
	      if (typeof params === 'function') {
	        params = {
	          callback: params
	        };
	      }
	      var body = this.$refs.body;
	      if (!body) {
	        if (params.callback && typeof params.callback === 'function') {
	          params.callback();
	        }
	        this.animateScrollId = null;
	        this.scrollAnimating = false;
	        return true;
	      }
	      if (im_lib_utils.Utils.platform.isIos() && im_lib_utils.Utils.platform.getIosVersion() > 12 && im_lib_utils.Utils.platform.getIosVersion() < 13.2) {
	        body.scrollTop = body.scrollHeight - body.clientHeight;
	        return true;
	      }
	      var _params = params,
	        _params$start = _params.start,
	        start = _params$start === void 0 ? body.scrollTop : _params$start,
	        _params$end = _params.end,
	        end = _params$end === void 0 ? body.scrollHeight - body.clientHeight : _params$end,
	        _params$increment = _params.increment,
	        increment = _params$increment === void 0 ? 20 : _params$increment,
	        _callback = _params.callback,
	        _params$duration = _params.duration,
	        duration = _params$duration === void 0 ? 500 : _params$duration;
	      var container = this.$refs.container;
	      if (container && end - start > container.offsetHeight * 3) {
	        start = end - container.offsetHeight * 3;
	        im_lib_logger.Logger.warn('Dialog.animatedScroll: Scroll trajectory has been reduced');
	      }
	      this.scrollAnimating = true;
	      im_lib_logger.Logger.warn('Dialog.animatedScroll: User scroll blocked while scrolling');
	      this.animateScrollId = im_lib_animation.Animation.start({
	        start: start,
	        end: end,
	        increment: increment,
	        duration: duration,
	        element: body,
	        elementProperty: 'scrollTop',
	        callback: function callback() {
	          _this11.animateScrollId = null;
	          _this11.scrollAnimating = false;
	          if (_callback && typeof _callback === 'function') {
	            _callback();
	          }
	        }
	      });
	    },
	    /* endregion 03. Scrolling */
	    /* region 04. Placeholders */
	    drawPlaceholders: function drawPlaceholders(requestMode) {
	      var pagesCount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
	      var limit = requestMode === RequestMode.history ? this.historyMessageLimit : this.unreadMessageLimit;
	      var placeholders = this.generatePlaceholders(limit, pagesCount);
	      return this.$store.dispatch('messages/addPlaceholders', {
	        placeholders: placeholders,
	        requestMode: requestMode
	      });
	    },
	    generatePlaceholders: function generatePlaceholders(amount, pagesCount) {
	      var placeholders = [];
	      for (var i = 0; i < pagesCount; i++) {
	        for (var j = 0; j < this.placeholdersComposition.length; j++) {
	          placeholders.push({
	            id: "placeholder".concat(this.placeholderCount),
	            chatId: this.chatId,
	            templateType: im_const.DialogTemplateType.placeholder,
	            placeholderType: this.placeholdersComposition[j],
	            unread: false
	          });
	          this.placeholderCount++;
	        }
	      }
	      return placeholders;
	    },
	    getPlaceholdersComposition: function getPlaceholdersComposition() {
	      //randomize set of placeholder types (sums up to ~2400px height)
	      //placeholder1 x8, placeholder2 x6, placeholder3 x8
	      return [1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3].sort(function () {
	        return 0.5 - Math.random();
	      });
	    },
	    /* endregion 04. Placeholders */
	    /* region 05. History request */
	    requestHistory: function requestHistory() {
	      var _this12 = this;
	      return this.$Bitrix.RestClient.get().callMethod(im_const.RestMethod.imDialogMessagesGet, {
	        chat_id: this.chatId,
	        last_id: this.lastHistoryMessageId,
	        limit: this.historyMessageLimit,
	        convert_text: 'Y'
	      }).then(function (result) {
	        var newMessages = result.data().messages;
	        if (newMessages.length > 0) {
	          _this12.lastHistoryMessageId = newMessages[newMessages.length - 1].id;
	        }
	        if (newMessages.length < _this12.historyMessageLimit) {
	          _this12.stopHistoryLoading = true;
	        }

	        //files and users
	        _this12.$Bitrix.Data.get('controller').executeRestAnswer(im_const.RestMethodHandler.imDialogMessagesGet, result);
	        return new Promise(function (resolve, reject) {
	          var currentBodyHeight = _this12.$refs.body.scrollHeight;
	          _this12.$store.dispatch('messages/updatePlaceholders', {
	            chatId: _this12.chatId,
	            data: newMessages,
	            firstMessage: _this12.pagesLoaded * _this12.placeholdersComposition.length,
	            amount: _this12.placeholdersComposition.length
	          }).then(function () {
	            if (!_this12.isOverflowAnchorSupported()) {
	              _this12.enableUserScroll();
	            }
	            resolve();
	          });
	          if (!_this12.isOverflowAnchorSupported()) {
	            im_lib_logger.Logger.warn('Disabling user scroll in updating placeholders');
	            _this12.$nextTick(function () {
	              var heightDifference = _this12.$refs.body.scrollHeight - currentBodyHeight;
	              _this12.disableUserScroll();
	              _this12.forceScrollToPosition(_this12.$refs.body.scrollTop + heightDifference);
	            });
	          }
	        });
	      }).then(function () {
	        _this12.pagesLoaded += 1;
	        im_lib_logger.Logger.warn('History page loaded. Total loaded - ', _this12.pagesLoaded);
	        return _this12.onAfterHistoryRequest();
	      })["catch"](function (result) {
	        im_lib_logger.Logger.warn('Request history error', result);
	      });
	    },
	    onAfterHistoryRequest: function onAfterHistoryRequest() {
	      var _this13 = this;
	      im_lib_logger.Logger.warn('onAfterHistoryRequest');
	      if (this.stopHistoryLoading) {
	        im_lib_logger.Logger.warn('stopHistoryLoading, deleting all delayed requests');
	        this.historyPagesRequested = 0;
	      }
	      if (this.historyPagesRequested > 0) {
	        im_lib_logger.Logger.warn('We have delayed requests -', this.historyPagesRequested);
	        this.historyPagesRequested--;
	        return this.requestHistory();
	      } else if (this.$refs.body.scrollTop <= this.scrollingUpThreshold && this.remainingHistoryPages > 0) {
	        im_lib_logger.Logger.warn('currentScroll <= scrollingUpThreshold, requesting next page and scrolling');
	        return this.drawPlaceholders(RequestMode.history).then(function (firstPlaceholderId) {
	          _this13.scrollToMessage({
	            messageId: firstPlaceholderId,
	            force: true,
	            stickToTop: false
	          });
	          return _this13.requestHistory();
	        });
	      } else {
	        im_lib_logger.Logger.warn('No more delayed requests, clearing placeholders');
	        this.$store.dispatch('messages/clearPlaceholders', {
	          chatId: this.chatId
	        });
	        this.isRequestingHistory = false;
	        return true;
	      }
	    },
	    /* endregion 05. History request */
	    /* region 06. Unread request */
	    prepareUnreadRequestParams: function prepareUnreadRequestParams() {
	      var _ref11;
	      return _ref11 = {}, babelHelpers.defineProperty(_ref11, im_const.RestMethodHandler.imDialogRead, [im_const.RestMethod.imDialogRead, {
	        dialog_id: this.dialogId,
	        message_id: this.lastUnreadMessageId
	      }]), babelHelpers.defineProperty(_ref11, im_const.RestMethodHandler.imChatGet, [im_const.RestMethod.imChatGet, {
	        dialog_id: this.dialogId
	      }]), babelHelpers.defineProperty(_ref11, im_const.RestMethodHandler.imDialogMessagesGetUnread, [im_const.RestMethod.imDialogMessagesGet, {
	        chat_id: this.chatId,
	        first_id: this.lastUnreadMessageId,
	        limit: this.unreadMessageLimit,
	        convert_text: 'Y'
	      }]), _ref11;
	    },
	    requestUnread: function requestUnread() {
	      var _this14 = this;
	      if (!this.lastUnreadMessageId) {
	        this.lastUnreadMessageId = this.$store.getters['messages/getLastId'](this.chatId);
	      }
	      if (!this.lastUnreadMessageId) {
	        return false;
	      }
	      main_core_events.EventEmitter.emitAsync(im_const.EventType.dialog.readMessage, {
	        id: this.lastUnreadMessageId,
	        skipTimer: true,
	        skipAjax: true
	      }).then(function () {
	        _this14.$Bitrix.RestClient.get().callBatch(_this14.prepareUnreadRequestParams(), function (response) {
	          return _this14.onUnreadRequest(response);
	        });
	      });
	    },
	    onUnreadRequest: function onUnreadRequest(response) {
	      var _this15 = this;
	      if (!response) {
	        im_lib_logger.Logger.warn('Unread request: callBatch error');
	        return false;
	      }
	      var chatGetResult = response[im_const.RestMethodHandler.imChatGet];
	      if (chatGetResult.error()) {
	        im_lib_logger.Logger.warn('Unread request: imChatGet error', chatGetResult.error());
	        return false;
	      }
	      this.$Bitrix.Data.get('controller').executeRestAnswer(im_const.RestMethodHandler.imChatGet, chatGetResult);
	      var dialogMessageUnread = response[im_const.RestMethodHandler.imDialogMessagesGetUnread];
	      if (dialogMessageUnread.error()) {
	        im_lib_logger.Logger.warn('Unread request: imDialogMessagesGetUnread error', dialogMessageUnread.error());
	        return false;
	      }
	      var newMessages = dialogMessageUnread.data().messages;
	      if (newMessages.length > 0) {
	        this.lastUnreadMessageId = newMessages[newMessages.length - 1].id;
	      }
	      this.$Bitrix.Data.get('controller').executeRestAnswer(im_const.RestMethodHandler.imDialogMessagesGetUnread, dialogMessageUnread);
	      this.$store.dispatch('messages/updatePlaceholders', {
	        chatId: this.chatId,
	        data: newMessages,
	        firstMessage: this.pagesLoaded * this.placeholdersComposition.length,
	        amount: this.placeholdersComposition.length
	      }).then(function () {
	        _this15.pagesLoaded += 1;
	        im_lib_logger.Logger.warn('Unread page loaded. Total loaded - ', _this15.pagesLoaded);
	        return _this15.onAfterUnreadRequest();
	      })["catch"](function (result) {
	        im_lib_logger.Logger.warn('Unread history error', result);
	      });
	    },
	    onAfterUnreadRequest: function onAfterUnreadRequest() {
	      if (this.unreadPagesRequested > 0) {
	        im_lib_logger.Logger.warn('We have delayed requests -', this.unreadPagesRequested);
	        this.unreadPagesRequested--;
	        return this.requestUnread();
	      } else {
	        im_lib_logger.Logger.warn('No more delayed requests, clearing placeholders');
	        this.$store.dispatch('messages/clearPlaceholders', {
	          chatId: this.chatId
	        });
	        this.isRequestingUnread = false;
	        if (this.externalUnreadRequestResolve) {
	          this.externalUnreadRequestResolve();
	        }
	        return true;
	      }
	    },
	    /* endregion 06. Unread request */
	    /* region 07. Last page request */
	    scrollToLastPage: function scrollToLastPage() {
	      var _this16 = this;
	      im_lib_logger.Logger.warn('Load last page');
	      //draw placeholders at the bottom
	      this.drawPlaceholders(RequestMode.unread).then(function () {
	        //block unread and history requests
	        _this16.isScrolling = true;
	        _this16.animatedScrollToPosition({
	          callback: function callback() {
	            return _this16.onScrollToLastPage();
	          }
	        });
	      });
	    },
	    onScrollToLastPage: function onScrollToLastPage() {
	      var _this17 = this;
	      //hide scroll button
	      this.showScrollButton = false;
	      //set counter to 0
	      this.$store.dispatch('dialogues/update', {
	        dialogId: this.dialogId,
	        fields: {
	          counter: 0
	        }
	      });
	      //clear all messages except placeholders
	      this.$store.dispatch('messages/clear', {
	        chatId: this.chatId,
	        keepPlaceholders: true
	      });
	      //call batch - imDialogRead, imChatGet, imDialogMessagesGet
	      this.$Bitrix.RestClient.get().callBatch(this.prepareLastPageRequestParams(), function (response) {
	        return _this17.onLastPageRequest(response);
	      });
	    },
	    prepareLastPageRequestParams: function prepareLastPageRequestParams() {
	      var _ref12;
	      return _ref12 = {}, babelHelpers.defineProperty(_ref12, im_const.RestMethodHandler.imDialogRead, [im_const.RestMethod.imDialogRead, {
	        dialog_id: this.dialogId
	      }]), babelHelpers.defineProperty(_ref12, im_const.RestMethodHandler.imChatGet, [im_const.RestMethod.imChatGet, {
	        dialog_id: this.dialogId
	      }]), babelHelpers.defineProperty(_ref12, im_const.RestMethodHandler.imDialogMessagesGet, [im_const.RestMethod.imDialogMessagesGet, {
	        chat_id: this.chatId,
	        limit: this.unreadMessageLimit,
	        convert_text: 'Y'
	      }]), _ref12;
	    },
	    onLastPageRequest: function onLastPageRequest(response) {
	      var _this18 = this;
	      if (!response) {
	        im_lib_logger.Logger.warn('Last page request: callBatch error');
	        return false;
	      }

	      //imChatGet handle
	      var chatGetResult = response[im_const.RestMethodHandler.imChatGet];
	      if (chatGetResult.error()) {
	        im_lib_logger.Logger.warn('Last page request: imChatGet error', chatGetResult.error());
	        return false;
	      }
	      this.$Bitrix.Data.get('controller').executeRestAnswer(im_const.RestMethodHandler.imChatGet, chatGetResult);

	      //imDialogMessagesGet handle
	      var lastPageMessages = response[im_const.RestMethodHandler.imDialogMessagesGet];
	      if (lastPageMessages.error()) {
	        im_lib_logger.Logger.warn('Last page request: imDialogMessagesGet error', lastPageMessages.error());
	        return false;
	      }
	      var newMessages = lastPageMessages.data().messages.reverse();
	      //handle files and users
	      this.$Bitrix.Data.get('controller').executeRestAnswer(im_const.RestMethodHandler.imDialogMessagesGet, lastPageMessages);
	      //update placeholders to real messages
	      this.$store.dispatch('messages/updatePlaceholders', {
	        chatId: this.chatId,
	        data: newMessages,
	        firstMessage: this.pagesLoaded * this.placeholdersComposition.length,
	        amount: this.placeholdersComposition.length
	      }).then(function () {
	        //get id for history requests and increase pages counter to count placeholders on next requests
	        _this18.lastHistoryMessageId = _this18.collection[0].id;
	        _this18.pagesLoaded += 1;

	        //clear remaining placeholders
	        return _this18.$store.dispatch('messages/clearPlaceholders', {
	          chatId: _this18.chatId
	        });
	      }).then(function () {
	        _this18.scrollToBottom({
	          force: true
	        });
	        //enable history requests on scroll up
	        _this18.stopHistoryLoading = false;
	        _this18.isScrolling = false;
	      })["catch"](function (result) {
	        im_lib_logger.Logger.warn('Unread history error', result);
	      });
	    },
	    /* endregion 07. Last page request */
	    /* region 08. Read messages */
	    readVisibleMessages: function readVisibleMessages() {
	      var _this19 = this;
	      if (!this.windowFocused || !this.messagesSet) {
	        im_lib_logger.Logger.warn('reading is disabled!');
	        return false;
	      }

	      //need to filter that way to empty array after async method on every element was completed
	      this.readMessageQueue = this.readMessageQueue.filter(function (messageId) {
	        if (_this19.readMessageTarget[messageId]) {
	          if (_this19.observers[ObserverType.read]) {
	            _this19.observers[ObserverType.read].unobserve(_this19.readMessageTarget[messageId]);
	          }
	          delete _this19.readMessageTarget[messageId];
	        }
	        _this19.requestReadVisibleMessages(messageId);
	        return false;
	      });
	    },
	    requestReadVisibleMessages: function requestReadVisibleMessages(messageId) {
	      main_core_events.EventEmitter.emit(im_const.EventType.dialog.readMessage, {
	        id: messageId
	      });
	    },
	    /* endregion 08. Read messages */
	    /* region 09. Helpers */
	    getMessageIdsForPagination: function getMessageIdsForPagination() {
	      // console.warn('this.collection.length', this.collection.length);
	      // if (this.collection.length > 0)
	      // {
	      // 	console.warn('this.collection.length', this.collection[0].id);
	      // 	this.lastHistoryMessageId = this.collection[0].id;
	      // }
	      //
	      if (this.unreadInCollection.length > 0) {
	        this.lastUnreadMessageId = this.unreadInCollection[this.unreadInCollection.length - 1].id;
	      }
	    },
	    getFirstUnreadMessage: function getFirstUnreadMessage() {
	      var unreadId = null;
	      for (var index = this.collection.length - 1; index >= 0; index--) {
	        if (!this.collection[index].unread) {
	          break;
	        }
	        unreadId = this.collection[index].id;
	      }
	      return unreadId;
	    },
	    manageScrollButton: function manageScrollButton(event) {
	      var _this20 = this;
	      var availableScrollHeight = event.target.scrollHeight - event.target.clientHeight;
	      this.scrollChangedByUser = this.currentScroll + this.scrollButtonDiff < availableScrollHeight;
	      clearTimeout(this.scrollButtonShowTimeout);
	      this.scrollButtonShowTimeout = setTimeout(function () {
	        if (_this20.scrollChangedByUser) {
	          //if user scroll and there is no scroll button - show it
	          if (!_this20.showScrollButton) {
	            _this20.showScrollButton = true;
	          }
	        } else {
	          //if not user scroll, there was scroll button and no more unread to load - hide it
	          if (_this20.showScrollButton && _this20.remainingUnreadPages === 0) {
	            _this20.showScrollButton = false;
	          }
	        }
	      }, 200);

	      //if we are at the bottom
	      if (event.target.scrollTop === event.target.scrollHeight - event.target.offsetHeight) {
	        clearTimeout(this.scrollButtonShowTimeout);
	        if (this.showScrollButton && this.remainingUnreadPages === 0) {
	          this.showScrollButton = false;
	        }
	      }
	    },
	    getDateObject: function getDateObject() {
	      var _this21 = this;
	      if (this.dateFormatFunction) {
	        return this.dateFormatFunction;
	      }
	      this.dateFormatFunction = Object.create(BX.Main.Date);
	      this.dateFormatFunction._getMessage = function (phrase) {
	        return _this21.$Bitrix.Loc.getMessage(phrase);
	      };
	      return this.dateFormatFunction;
	    },
	    getDateGroup: function getDateGroup(date) {
	      var id = date.toJSON().slice(0, 10);
	      if (this.cachedDateGroups[id]) {
	        return this.cachedDateGroups[id];
	      }
	      var dateFormat = this.getDateFormat(DateFormat.groupTitle);
	      this.cachedDateGroups[id] = {
	        id: id,
	        title: this.getDateObject().format(dateFormat, date)
	      };
	      return this.cachedDateGroups[id];
	    },
	    getDateFormat: function getDateFormat(type) {
	      return im_lib_utils.Utils.date.getFormatType(BX.Messenger.Const.DateFormat[type], this.$Bitrix.Loc.getMessages());
	    },
	    getDateGroupBlock: function getDateGroupBlock() {
	      var id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
	      var text = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
	      return {
	        templateId: 'group' + id,
	        templateType: im_const.DialogTemplateType.group,
	        text: text
	      };
	    },
	    getDelimiterBlock: function getDelimiterBlock() {
	      var id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
	      return {
	        templateId: 'delimiter' + id,
	        templateType: im_const.DialogTemplateType.delimiter
	      };
	    },
	    getObserver: function getObserver(config) {
	      var _this22 = this;
	      if (typeof window.IntersectionObserver === 'undefined' || config.type === ObserverType.none) {
	        return {
	          observe: function observe() {},
	          unobserve: function unobserve() {}
	        };
	      }
	      var observerCallback, observerOptions;
	      observerCallback = function observerCallback(entries) {
	        entries.forEach(function (entry) {
	          var sendReadEvent = false;
	          if (entry.isIntersecting) {
	            //on windows with interface scaling intersectionRatio will never be 1
	            if (entry.intersectionRatio >= 0.99) {
	              sendReadEvent = true;
	            } else if (entry.intersectionRatio > 0 && entry.rootBounds.height < entry.boundingClientRect.height + 20 && entry.intersectionRect.height > entry.rootBounds.height / 2) {
	              sendReadEvent = true;
	            }
	          }
	          if (sendReadEvent) {
	            _this22.readMessageQueue.push(entry.target.dataset.messageId);
	            _this22.readMessageTarget[entry.target.dataset.messageId] = entry.target;
	          } else {
	            _this22.readMessageQueue = _this22.readMessageQueue.filter(function (messageId) {
	              return messageId !== entry.target.dataset.messageId;
	            });
	            delete _this22.readMessageTarget[entry.target.dataset.messageId];
	          }
	          if (_this22.enableReadMessages) {
	            _this22.readVisibleMessagesDelayed();
	          }
	        });
	      };
	      observerOptions = {
	        root: this.$refs.body,
	        threshold: new Array(101).fill(0).map(function (zero, index) {
	          return index * 0.01;
	        })
	      };
	      return new IntersectionObserver(observerCallback, observerOptions);
	    },
	    getElementClass: function getElementClass(elementId) {
	      var classWithId = im_const.DialogReferenceClassName.listItem + '-' + elementId;
	      return ['bx-im-dialog-list-item', im_const.DialogReferenceClassName.listItem, classWithId];
	    },
	    getElementById: function getElementById(elementId) {
	      var body = this.$refs.body;
	      var className = im_const.DialogReferenceClassName.listItem + '-' + elementId;
	      return body.getElementsByClassName(className)[0];
	    },
	    getPlaceholderClass: function getPlaceholderClass(elementId) {
	      var classWithId = im_const.DialogReferenceClassName.listItem + '-' + elementId;
	      return ['im-skeleton-item', 'im-skeleton-item-1', 'im-skeleton-item--sm', classWithId];
	    } /* endregion 09. Helpers */
	  },
	  directives: {
	    'bx-im-directive-dialog-observer': {
	      inserted: function inserted(element, bindings, vnode) {
	        if (bindings.value === ObserverType.none) {
	          return false;
	        }
	        if (!vnode.context.observers[bindings.value]) {
	          vnode.context.observers[bindings.value] = vnode.context.getObserver({
	            type: bindings.value
	          });
	        }
	        vnode.context.observers[bindings.value].observe(element);
	        return true;
	      },
	      unbind: function unbind(element, bindings, vnode) {
	        if (bindings.value === ObserverType.none) {
	          return true;
	        }
	        if (vnode.context.observers[bindings.value]) {
	          vnode.context.observers[bindings.value].unobserve(element);
	        }
	        return true;
	      }
	    }
	  },
	  // language=Vue
	  template: "\n\t<div class=\"bx-im-dialog\" @click=\"onDialogClick\" @touchmove=\"onDialogMove\" ref=\"container\">\n\t\t<div :class=\"bodyClasses\" @scroll.passive=\"onScroll\" ref=\"body\">\n\t\t\t<!-- Main elements loop -->\n\t\t\t<template v-for=\"(element, index) in formattedCollection\">\n\t\t\t\t<!-- Message -->\n\t\t\t\t<template v-if=\"element.templateType === TemplateType.message\">\n\t\t\t\t\t<div\n\t\t\t\t\t\t:class=\"getElementClass(element.id)\"\n\t\t\t\t\t\t:data-message-id=\"element.id\"\n\t\t\t\t\t\t:data-template-id=\"element.templateId\"\n\t\t\t\t\t\t:data-type=\"element.templateType\" \n\t\t\t\t\t\t:key=\"element.templateId\"\n\t\t\t\t\t\tv-bx-im-directive-dialog-observer=\"element.unread? ObserverType.read: ObserverType.none\"\n\t\t\t\t\t>\n\t\t\t\t\t\t<component :is=\"element.params.COMPONENT_ID\"\n\t\t\t\t\t\t\t:userId=\"userId\" \n\t\t\t\t\t\t\t:dialogId=\"dialogId\"\n\t\t\t\t\t\t\t:chatId=\"chatId\"\n\t\t\t\t\t\t\t:message=\"element\"\n\t\t\t\t\t\t\t:enableReactions=\"enableReactions\"\n\t\t\t\t\t\t\t:enableDateActions=\"enableDateActions\"\n\t\t\t\t\t\t\t:enableCreateContent=\"showMessageMenu\"\n\t\t\t\t\t\t\t:enableGestureQuote=\"enableGestureQuote\"\n\t\t\t\t\t\t\t:enableGestureQuoteFromRight=\"enableGestureQuoteFromRight\"\n\t\t\t\t\t\t\t:enableGestureMenu=\"enableGestureMenu\"\n\t\t\t\t\t\t\t:showName=\"showMessageUserName\"\n\t\t\t\t\t\t\t:showAvatar=\"showMessageAvatar\"\n\t\t\t\t\t\t\t:showMenu=\"showMessageMenu\"\n\t\t\t\t\t\t\t:capturedMoveEvent=\"capturedMoveEvent\"\n\t\t\t\t\t\t\t:referenceContentClassName=\"DialogReferenceClassName.listItem\"\n\t\t\t\t\t\t\t:referenceContentBodyClassName=\"DialogReferenceClassName.listItemBody\"\n\t\t\t\t\t\t\t:referenceContentNameClassName=\"DialogReferenceClassName.listItemName\"\n\t\t\t\t\t\t\t@dragMessage=\"onDragMessage\"\n\t\t\t\t\t\t/>\n\t\t\t\t\t</div>\n\t\t\t\t</template>\n\t\t\t\t<!-- Date groups -->\n\t\t\t\t<template v-else-if=\"element.templateType === TemplateType.group\">\n\t\t\t\t\t<div class=\"bx-im-dialog-group\" :data-template-id=\"element.templateId\" :data-type=\"element.templateType\" :key=\"element.templateId\">\n\t\t\t\t\t\t<div class=\"bx-im-dialog-group-date\">{{ element.text }}</div>\n\t\t\t\t\t</div>\n\t\t\t\t</template>\n\t\t\t\t<!-- Delimiters -->\n\t\t\t\t<template v-else-if=\"element.templateType === TemplateType.delimiter\">\n\t\t\t\t\t<div class=\"bx-im-dialog-delimiter\" :data-template-id=\"element.templateId\" :data-type=\"element.templateType\" :key=\"element.templateId\"></div>\n\t\t\t\t</template>\n\t\t\t\t<!-- Placeholders -->\n\t\t\t\t<template v-else-if=\"element.templateType === TemplateType.placeholder\">\n\t\t\t\t\t<component :is=\"'Placeholder'+element.placeholderType\" :element=\"element\"/>\n\t\t\t\t</template>\n\t\t\t</template>\n\t\t\t<!-- Writing and readed statuses -->\n\t\t\t<transition name=\"bx-im-dialog-status\">\n\t\t\t\t<template v-if=\"writingStatusText\">\n\t\t\t\t\t<div class=\"bx-im-dialog-status\">\n\t\t\t\t\t\t<span class=\"bx-im-dialog-status-writing\"></span>\n\t\t\t\t\t\t{{ writingStatusText }}\n\t\t\t\t\t</div>\n\t\t\t\t</template>\n\t\t\t\t<template v-else-if=\"statusReaded\">\n\t\t\t\t\t<div class=\"bx-im-dialog-status\" @click=\"onClickOnReadList\">\n\t\t\t\t\t\t{{ statusReaded }}\n\t\t\t\t\t</div>\n\t\t\t\t</template>\n\t\t\t</transition>\n\t\t\t<div v-if=\"showStatusPlaceholder\" class=\"bx-im-dialog-status-placeholder\"></div>\n\t\t</div>\n\t\t<!-- Scroll button -->\n\t\t<transition name=\"bx-im-dialog-scroll-button\">\n\t\t\t<div v-show=\"showScrollButton || (unreadCounter > 0 && !isLastIdInCollection)\" class=\"bx-im-dialog-scroll-button-box\" @click=\"onScrollButtonClick\">\n\t\t\t\t<div class=\"bx-im-dialog-scroll-button\">\n\t\t\t\t\t<div v-show=\"unreadCounter\" class=\"bx-im-dialog-scroll-button-counter\">\n\t\t\t\t\t\t<div class=\"bx-im-dialog-scroll-button-counter-digit\">{{ formattedUnreadCounter }}</div>\n\t\t\t\t\t</div>\n\t\t\t\t\t<div class=\"bx-im-dialog-scroll-button-arrow\"></div>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t</transition>\n\t</div>\n"
	};

	function ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
	function _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$1(Object(source), !0).forEach(function (key) { babelHelpers.defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
	var ErrorState = {
	  computed: _objectSpread$1({}, ui_vue_vuex.WidgetVuex.mapState({
	    application: function application(state) {
	      return state.application;
	    }
	  })),
	  // language=Vue
	  template: "\n\t\t<div class=\"bx-mobilechat-body\">\n\t\t\t<div class=\"bx-mobilechat-warning-window\">\n\t\t\t\t<div class=\"bx-mobilechat-warning-icon\"></div>\n\t\t\t\t<template v-if=\"application.error.description\">\n\t\t\t\t\t<div class=\"bx-mobilechat-help-title bx-mobilechat-help-title-sm bx-mobilechat-warning-msg\" v-html=\"application.error.description\"></div>\n\t\t\t\t</template>\n\t\t\t\t<template v-else>\n\t\t\t\t\t<div class=\"bx-mobilechat-help-title bx-mobilechat-help-title-md bx-mobilechat-warning-msg\">{{$Bitrix.Loc.getMessage('IM_DIALOG_ERROR_TITLE')}}</div>\n\t\t\t\t\t<div class=\"bx-mobilechat-help-title bx-mobilechat-help-title-sm bx-mobilechat-warning-msg\">{{$Bitrix.Loc.getMessage('IM_DIALOG_ERROR_DESC')}}</div>\n\t\t\t\t</template>\n\t\t\t</div>\n\t\t</div>\n\t"
	};

	var LoadingState = {
	  data: function data() {
	    return {
	      placeholdersComposition: [],
	      placeholderTypes: [0, 1],
	      placeholderModes: ['self', 'opponent'],
	      placeholdersCount: 20
	    };
	  },
	  created: function created() {
	    for (var i = 0; i < this.placeholdersCount; i++) {
	      var randomType = Math.floor(Math.random() * this.placeholderTypes.length);
	      var randomMode = Math.floor(Math.random() * this.placeholderModes.length);
	      this.placeholdersComposition.push({
	        index: i,
	        type: randomType,
	        mode: this.placeholderModes[randomMode],
	        classes: this.getItemClasses(randomType, randomMode)
	      });
	    }
	  },
	  methods: {
	    getItemClasses: function getItemClasses(type, modeIndex) {
	      var itemClasses = ['im-skeleton-item'];
	      if (this.placeholderModes[modeIndex] === 'self') {
	        itemClasses.push('im-skeleton-item-self');
	      } else {
	        itemClasses.push('im-skeleton-item-opponent');
	      }
	      if (type === 0) {
	        itemClasses.push('im-skeleton-item--sm');
	      } else {
	        itemClasses.push('im-skeleton-item--md');
	      }
	      return itemClasses;
	    }
	  },
	  // language=Vue
	  template: "\n\t\t<div class=\"bx-mobilechat-placeholder-wrap\">\n\t\t\t<div class=\"bx-mobilechat-placeholder-wrap-visible\">\n\t\t\t\t<template v-for=\"item in placeholdersComposition\">\n\t\t\t\t\t<div :class=\"item.classes\" :key=\"item.index\">\n\t\t\t\t\t\t<div v-if=\"item.mode === 'opponent'\" class=\"im-skeleton-logo\"></div>\n\t\t\t\t\t\t<div class=\"im-skeleton-content\">\n\t\t\t\t\t\t\t<template v-if=\"item.type === 0\">\n\t\t\t\t\t\t\t\t<div class=\"im-skeleton-line-row\">\n\t\t\t\t\t\t\t\t\t<div style=\"max-width: 70%\" class=\"im-skeleton-line\"></div>\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t<div class=\"im-skeleton-line-row\">\n\t\t\t\t\t\t\t\t\t<div style=\"max-width: 100%\" class=\"im-skeleton-line\"></div>\n\t\t\t\t\t\t\t\t\t<div style=\"max-width: 26px; margin-left: auto;\" class=\"im-skeleton-line\"></div>\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t</template>\n\t\t\t\t\t\t\t<template v-else>\n\t\t\t\t\t\t\t\t<div class=\"im-skeleton-line-row\">\n\t\t\t\t\t\t\t\t\t<div style=\"max-width: 35%\" class=\"im-skeleton-line\"></div>\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t<div class=\"im-skeleton-line-row\">\n\t\t\t\t\t\t\t\t\t<div style=\"max-width: 100%\" class=\"im-skeleton-line\"></div>\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t<div class=\"im-skeleton-line-row\">\n\t\t\t\t\t\t\t\t\t<div style=\"max-width: 55%\" class=\"im-skeleton-line\"></div>\n\t\t\t\t\t\t\t\t\t<div style=\"max-width: 26px; margin-left: auto;\" class=\"im-skeleton-line\"></div>\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t</template>\n\t\t\t\t\t\t\t<div class=\"im-skeleton-like\"></div>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>\n\t\t\t\t</template>\n\t\t\t</div>\n\t\t</div>\n\t"
	};

	var EmptyState = {
	  // language=Vue
	  template: "\n\t\t<div class=\"bx-mobilechat-loading-window\">\n\t\t\t<h3 class=\"bx-mobilechat-help-title bx-mobilechat-help-title-md bx-mobilechat-loading-msg\">\n\t\t  \t\t{{ $Bitrix.Loc.getMessage('IM_DIALOG_EMPTY') }}\n\t\t\t</h3>\n\t\t</div>\n\t"
	};

	var QuotePanel = {
	  /**
	   * @emits EventType.dialog.quotePanelClose
	   */
	  props: {
	    quotePanelData: {
	      type: Object,
	      "default": function _default() {
	        return {
	          id: 0,
	          title: '',
	          description: '',
	          color: ''
	        };
	      }
	    },
	    canClose: {
	      "default": true
	    }
	  },
	  methods: {
	    close: function close(event) {
	      main_core_events.EventEmitter.emit(im_const.EventType.dialog.quotePanelClose, event);
	    }
	  },
	  computed: {
	    formattedTittle: function formattedTittle() {
	      return this.quotePanelData.title ? this.quotePanelData.title.substr(0, 255) : this.$Bitrix.Loc.getMessage('IM_QUOTE_PANEL_DEFAULT_TITLE');
	    },
	    formattedDescription: function formattedDescription() {
	      return this.quotePanelData.description ? this.quotePanelData.description.substr(0, 255) : '';
	    }
	  },
	  template: "\n\t<transition enter-active-class=\"bx-im-quote-panel-animation-show\" leave-active-class=\"bx-im-quote-panel-animation-close\">\t\t\t\t\n\t\t<div v-if=\"quotePanelData.id > 0\" class=\"bx-im-quote-panel\">\n\t\t\t<div class=\"bx-im-quote-panel-wrap\">\n\t\t\t\t<div class=\"bx-im-quote-panel-box\" :style=\"{borderLeftColor: quotePanelData.color}\">\n\t\t\t\t\t<div class=\"bx-im-quote-panel-box-title\" :style=\"{color: quotePanelData.color}\">{{formattedTittle}}</div>\n\t\t\t\t\t<div class=\"bx-im-quote-panel-box-desc\">{{formattedDescription}}</div>\n\t\t\t\t</div>\n\t\t\t\t<div v-if=\"canClose\" class=\"bx-im-quote-panel-close\" @click=\"close\"></div>\n\t\t\t</div>\n\t\t</div>\n\t</transition>\n"
	};

	function ownKeys$2(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
	function _objectSpread$2(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$2(Object(source), !0).forEach(function (key) { babelHelpers.defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$2(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
	ui_vue.WidgetBitrixVue.component('bx-im-component-dialog', {
	  components: {
	    MessageList: MessageList,
	    ErrorState: ErrorState,
	    LoadingState: LoadingState,
	    EmptyState: EmptyState,
	    QuotePanel: QuotePanel
	  },
	  props: {
	    userId: {
	      "default": 0
	    },
	    dialogId: {
	      "default": 0
	    },
	    skipDataRequest: {
	      "default": false
	    },
	    showLoadingState: {
	      "default": true
	    },
	    showEmptyState: {
	      "default": true
	    },
	    enableGestureQuote: {
	      "default": true
	    },
	    enableGestureQuoteFromRight: {
	      "default": true
	    },
	    enableGestureMenu: {
	      "default": false
	    },
	    showMessageUserName: {
	      "default": true
	    },
	    showMessageAvatar: {
	      "default": true
	    }
	  },
	  data: function data() {
	    return {
	      messagesSet: false,
	      dialogState: im_const.DialogState.loading
	    };
	  },
	  created: function created() {
	    main_core_events.EventEmitter.subscribe(im_const.EventType.dialog.messagesSet, this.onMessagesSet);
	    this.onDialogOpen();
	  },
	  beforeDestroy: function beforeDestroy() {
	    main_core_events.EventEmitter.unsubscribe(im_const.EventType.dialog.messagesSet, this.onMessagesSet);
	  },
	  watch: {
	    dialogId: function dialogId(newValue, oldValue) {
	      im_lib_logger.Logger.warn('Switching dialogId from ', oldValue, ' to ', newValue);
	      this.messagesSet = false;
	      this.onDialogOpen();
	    }
	  },
	  computed: _objectSpread$2(_objectSpread$2({
	    EventType: function EventType() {
	      return im_const.EventType;
	    },
	    DialogState: function DialogState() {
	      return im_const.DialogState;
	    },
	    dialogWrapClasses: function dialogWrapClasses() {
	      return ['bx-mobilechat-wrapper', {
	        'bx-mobilechat-chat-start': this.isDialogShowingMessages
	      }];
	    },
	    dialogBoxClasses: function dialogBoxClasses() {
	      return ['bx-mobilechat-box', {
	        'bx-mobilechat-box-dark-background': this.isDarkBackground
	      }];
	    },
	    dialogBodyClasses: function dialogBodyClasses() {
	      return ['bx-mobilechat-body', {
	        'bx-mobilechat-body-with-message': this.dialogState === im_const.DialogState.show
	      }];
	    },
	    quotePanelData: function quotePanelData() {
	      var result = {
	        id: 0,
	        title: '',
	        description: '',
	        color: ''
	      };
	      if (!this.isDialogShowingMessages || !this.dialog.quoteId) {
	        return result;
	      }
	      var message = this.$store.getters['messages/getMessage'](this.dialog.chatId, this.dialog.quoteId);
	      if (!message) {
	        return result;
	      }
	      var user = this.$store.getters['users/get'](message.authorId);
	      var files = this.$store.getters['files/getList'](this.dialog.chatId);
	      return {
	        id: this.dialog.quoteId,
	        title: message.params.NAME ? main_core.Text.decode(message.params.NAME) : user ? user.name : '',
	        color: user ? user.color : '',
	        description: im_lib_utils.Utils.text.purify(message.text, message.params, files, this.localize)
	      };
	    },
	    isLoading: function isLoading() {
	      if (!this.showLoadingState) {
	        return false;
	      }
	      // show placeholders if we don't have chatId for current dialogId
	      // or we have chatId, but there is no messages collection for this chatId and messages are not set yet
	      // (because if chat is empty - there will be no messages collection, but we should not show loading state)
	      return !this.isChatIdInModel || this.isChatIdInModel && !this.isMessagesModelInited && !this.messagesSet;
	    },
	    isEmpty: function isEmpty() {
	      return this.showEmptyState && this.messagesSet && this.messageCollection.length === 0;
	    },
	    isChatIdInModel: function isChatIdInModel() {
	      var dialogues = this.$store.state.dialogues.collection;
	      return dialogues[this.dialogId] && dialogues[this.dialogId].chatId > 0;
	    },
	    isMessagesModelInited: function isMessagesModelInited() {
	      var messages = this.$store.state.messages.collection;
	      return messages[this.chatId];
	    },
	    isDialogShowingMessages: function isDialogShowingMessages() {
	      var messagesNotEmpty = this.messageCollection && this.messageCollection.length > 0;
	      if (messagesNotEmpty) {
	        this.dialogState = im_const.DialogState.show;
	      } else if (this.dialog && this.dialog.init) {
	        this.dialogState = im_const.DialogState.empty;
	      } else {
	        this.dialogState = im_const.DialogState.loading;
	      }
	      return messagesNotEmpty;
	    },
	    dialog: function dialog() {
	      var dialog = this.$store.getters['dialogues/get'](this.application.dialog.dialogId);
	      return dialog ? dialog : this.$store.getters['dialogues/getBlank']();
	    },
	    chatId: function chatId() {
	      if (!this.application) {
	        return 0;
	      }
	      return this.application.dialog.chatId;
	    },
	    messageCollection: function messageCollection() {
	      return this.$store.getters['messages/get'](this.application.dialog.chatId);
	    },
	    isDarkBackground: function isDarkBackground() {
	      return this.application.options.darkBackground;
	    }
	  }, ui_vue_vuex.WidgetVuex.mapState({
	    application: function application(state) {
	      return state.application;
	    }
	  })), {}, {
	    localize: function localize() {
	      return ui_vue.WidgetBitrixVue.getFilteredPhrases(['IM_DIALOG_', 'IM_UTILS_', 'IM_MESSENGER_DIALOG_', 'IM_QUOTE_'], this);
	    }
	  }),
	  methods: {
	    prepareRequestDataQuery: function prepareRequestDataQuery() {
	      var _query;
	      var query = (_query = {}, babelHelpers.defineProperty(_query, im_const.RestMethodHandler.mobileBrowserConstGet, [im_const.RestMethod.mobileBrowserConstGet, {}]), babelHelpers.defineProperty(_query, im_const.RestMethodHandler.imChatGet, [im_const.RestMethod.imChatGet, {
	        dialog_id: this.dialogId
	      }]), babelHelpers.defineProperty(_query, im_const.RestMethodHandler.imDialogMessagesGetInit, [im_const.RestMethod.imDialogMessagesGet, {
	        dialog_id: this.dialogId,
	        limit: this.getController().application.getRequestMessageLimit(),
	        convert_text: 'Y'
	      }]), _query);
	      if (im_lib_utils.Utils.dialog.isChatId(this.dialogId)) {
	        query[im_const.RestMethodHandler.imUserGet] = [im_const.RestMethod.imUserGet, {}];
	      } else {
	        query[im_const.RestMethodHandler.imUserListGet] = [im_const.RestMethod.imUserListGet, {
	          id: [this.userId, this.dialogId]
	        }];
	      }
	      return query;
	    },
	    requestData: function requestData() {
	      var _this = this;
	      im_lib_logger.Logger.log('requesting dialog data');
	      var query = this.prepareRequestDataQuery();
	      this.$Bitrix.RestClient.get().callBatch(query, function (response) {
	        if (!response) {
	          return false;
	        }

	        //const.get
	        var constGetResult = response[im_const.RestMethodHandler.mobileBrowserConstGet];
	        if (!constGetResult.error()) {
	          _this.executeRestAnswer(im_const.RestMethodHandler.mobileBrowserConstGet, constGetResult);
	        }

	        //user.get
	        var userGetResult = response[im_const.RestMethodHandler.imUserGet];
	        if (userGetResult && !userGetResult.error()) {
	          _this.executeRestAnswer(im_const.RestMethodHandler.imUserGet, userGetResult);
	        }

	        //user.list.get
	        var userListGetResult = response[im_const.RestMethodHandler.imUserListGet];
	        if (userListGetResult && !userListGetResult.error()) {
	          _this.executeRestAnswer(im_const.RestMethodHandler.imUserListGet, userListGetResult);
	        }

	        //chat.get
	        var chatGetResult = response[im_const.RestMethodHandler.imChatGet];
	        if (!chatGetResult.error()) {
	          _this.executeRestAnswer(im_const.RestMethodHandler.imChatGet, chatGetResult);
	        }

	        //dialog.messages.get
	        var dialogMessagesGetResult = response[im_const.RestMethodHandler.imDialogMessagesGetInit];
	        if (!dialogMessagesGetResult.error()) {
	          _this.$store.dispatch('application/set', {
	            dialog: {
	              enableReadMessages: true
	            }
	          }).then(function () {
	            _this.executeRestAnswer(im_const.RestMethodHandler.imDialogMessagesGetInit, dialogMessagesGetResult);
	            // this.messagesSet = true;
	          });
	        }
	      }, false, false, im_lib_utils.Utils.getLogTrackingParams({
	        name: 'im.dialog',
	        dialog: this.getController().application.getDialogData()
	      }));
	      return new Promise(function (resolve, reject) {
	        return resolve();
	      });
	    },
	    onDialogOpen: function onDialogOpen() {
	      if (this.isChatIdInModel) {
	        var dialogues = this.$store.state.dialogues.collection;
	        this.$store.commit('application/set', {
	          dialog: {
	            chatId: dialogues[this.dialogId].chatId,
	            dialogId: this.dialogId
	          }
	        });
	      }
	      if (!this.skipDataRequest) {
	        this.requestData();
	      }
	    },
	    onMessagesSet: function onMessagesSet(_ref) {
	      var event = _ref.data;
	      if (event.chatId !== this.chatId) {
	        return false;
	      }
	      if (this.messagesSet === true) {
	        return false;
	      }
	      this.messagesSet = true;
	    },
	    getController: function getController() {
	      return this.$Bitrix.Data.get('controller');
	    },
	    executeRestAnswer: function executeRestAnswer(method, queryResult, extra) {
	      this.getController().executeRestAnswer(method, queryResult, extra);
	    }
	  },
	  // language=Vue
	  template: "\n\t\t<div :class=\"dialogWrapClasses\">\n\t\t\t<div :class=\"dialogBoxClasses\" ref=\"chatBox\">\n\t\t\t\t<!-- Error state -->\n\t\t\t\t<ErrorState v-if=\"application.error.active\" />\n\t\t\t\t<template v-else>\n\t\t\t\t\t<div :class=\"dialogBodyClasses\" key=\"with-message\">\n\t\t\t\t\t\t<!-- Loading state -->\n\t\t\t\t\t  \t<LoadingState v-if=\"isLoading\" />\n\t\t\t\t\t\t<!-- Empty state -->\n\t\t\t\t\t  \t<EmptyState v-else-if=\"isEmpty\" />\n\t\t\t\t\t\t<!-- Message list state -->\n\t\t\t\t\t\t<template v-else>\n\t\t\t\t\t\t\t<div class=\"bx-mobilechat-dialog\">\n\t\t\t\t\t\t\t\t<MessageList\n\t\t\t\t\t\t\t\t\t:userId=\"userId\" \n\t\t\t\t\t\t\t\t\t:dialogId=\"dialogId\"\n\t\t\t\t\t\t\t\t\t:messageLimit=\"application.dialog.messageLimit\"\n\t\t\t\t\t\t\t\t\t:enableReadMessages=\"application.dialog.enableReadMessages\"\n\t\t\t\t\t\t\t\t\t:enableReactions=\"true\"\n\t\t\t\t\t\t\t\t\t:enableDateActions=\"false\"\n\t\t\t\t\t\t\t\t\t:enableCreateContent=\"false\"\n\t\t\t\t\t\t\t\t\t:enableGestureQuote=\"enableGestureQuote\"\n\t\t\t\t\t\t\t\t\t:enableGestureQuoteFromRight=\"enableGestureQuoteFromRight\"\n\t\t\t\t\t\t\t\t\t:enableGestureMenu=\"enableGestureMenu\"\n\t\t\t\t\t\t\t\t\t:showMessageUserName=\"showMessageUserName\"\n\t\t\t\t\t\t\t\t\t:showMessageAvatar=\"showMessageAvatar\"\n\t\t\t\t\t\t\t\t\t:showMessageMenu=\"false\"\n\t\t\t\t\t\t\t\t />\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t<!-- Quote panel -->\n\t\t\t\t\t\t\t<QuotePanel :quotePanelData=\"quotePanelData\" />\n\t\t\t\t\t\t</template>\n\t\t\t\t\t</div>\n\t\t\t\t</template>\n\t\t\t</div>\n\t\t</div>\n\t"
	});

}((this.BX.Messenger = this.BX.Messenger || {}),BX,BX,window,BX.Messenger.Lib,BX.Messenger.Lib,BX.Messenger.Lib,BX,BX,BX.Messenger.Const,BX,BX.Event,BX));





// file: /bitrix/js/im/lib/localstorage/dist/localstorage.bundle.js
this.BX = this.BX || {};
this.BX.Messenger = this.BX.Messenger || {};
(function (exports) {
	'use strict';

	/**
	 * Bitrix Messenger
	 * LocalStorage manager
	 *
	 * @package bitrix
	 * @subpackage im
	 * @copyright 2001-2019 Bitrix
	 */
	var LocalStorage = /*#__PURE__*/function () {
	  function LocalStorage() {
	    babelHelpers.classCallCheck(this, LocalStorage);
	    this.enabled = null;
	    this.expireList = null;
	    this.expireInterval = null;
	  }
	  babelHelpers.createClass(LocalStorage, [{
	    key: "isEnabled",
	    value: function isEnabled() {
	      if (this.enabled !== null) {
	        return this.enabled;
	      }
	      this.enabled = false;
	      if (typeof window.localStorage !== 'undefined') {
	        try {
	          window.localStorage.setItem('__bx_test_ls_feature__', 'ok');
	          if (window.localStorage.getItem('__bx_test_ls_feature__') === 'ok') {
	            window.localStorage.removeItem('__bx_test_ls_feature__');
	            this.enabled = true;
	          }
	        } catch (e) {}
	      }
	      if (this.enabled && !this.expireInterval) {
	        try {
	          var expireList = window.localStorage.getItem('bx-messenger-localstorage-expire');
	          if (expireList) {
	            this.expireList = JSON.parse(expireList);
	          }
	        } catch (e) {}
	        clearInterval(this.expireInterval);
	        this.expireInterval = setInterval(this._checkExpireInterval.bind(this), 60000);
	      }
	      return this.enabled;
	    }
	  }, {
	    key: "set",
	    value: function set(siteId, userId, name, value) {
	      var ttl = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
	      if (!this.isEnabled()) {
	        return false;
	      }
	      var expire = null;
	      if (ttl) {
	        expire = new Date(new Date().getTime() + ttl * 1000);
	      }
	      var storeValue = JSON.stringify({
	        value: value,
	        expire: expire
	      });
	      if (window.localStorage.getItem(this._getKey(siteId, userId, name)) !== storeValue) {
	        window.localStorage.setItem(this._getKey(siteId, userId, name), storeValue);
	      }
	      if (ttl) {
	        if (!this.expireList) {
	          this.expireList = {};
	        }
	        this.expireList[this._getKey(siteId, userId, name)] = expire;
	        window.localStorage.setItem('bx-messenger-localstorage-expire', JSON.stringify(this.expireList));
	      }
	      return true;
	    }
	  }, {
	    key: "get",
	    value: function get(siteId, userId, name, defaultValue) {
	      if (!this.isEnabled()) {
	        return typeof defaultValue !== 'undefined' ? defaultValue : null;
	      }
	      var result = window.localStorage.getItem(this._getKey(siteId, userId, name));
	      if (result === null) {
	        return typeof defaultValue !== 'undefined' ? defaultValue : null;
	      }
	      try {
	        result = JSON.parse(result);
	        if (result && typeof result.value !== 'undefined') {
	          if (!result.expire || new Date(result.expire) > new Date()) {
	            result = result.value;
	          } else {
	            window.localStorage.removeItem(this._getKey(siteId, userId, name));
	            if (this.expireList) {
	              delete this.expireList[this._getKey(siteId, userId, name)];
	            }
	            return typeof defaultValue !== 'undefined' ? defaultValue : null;
	          }
	        } else {
	          return typeof defaultValue !== 'undefined' ? defaultValue : null;
	        }
	      } catch (e) {
	        return typeof defaultValue !== 'undefined' ? defaultValue : null;
	      }
	      return result;
	    }
	  }, {
	    key: "remove",
	    value: function remove(siteId, userId, name) {
	      if (!this.isEnabled()) {
	        return false;
	      }
	      if (this.expireList) {
	        delete this.expireList[this._getKey(siteId, userId, name)];
	      }
	      return window.localStorage.removeItem(this._getKey(siteId, userId, name));
	    }
	  }, {
	    key: "_getKey",
	    value: function _getKey(siteId, userId, name) {
	      return 'bx-messenger-' + siteId + '-' + userId + '-' + name;
	    }
	  }, {
	    key: "_checkExpireInterval",
	    value: function _checkExpireInterval() {
	      if (!this.expireList) return true;
	      var currentTime = new Date();
	      var count = 0;
	      for (var name in this.expireList) {
	        if (!this.expireList.hasOwnProperty(name)) {
	          continue;
	        }
	        if (new Date(this.expireList[name]) <= currentTime) {
	          window.localStorage.removeItem(name);
	          delete this.expireList[name];
	        } else {
	          count++;
	        }
	      }
	      if (count) {
	        window.localStorage.setItem('bx-messenger-localstorage-expire', JSON.stringify(this.expireList));
	      } else {
	        this.expireList = null;
	        window.localStorage.removeItem('bx-messenger-localstorage-expire');
	      }
	      return true;
	    }
	  }]);
	  return LocalStorage;
	}();
	var localStorage = new LocalStorage();

	exports.LocalStorage = localStorage;

}((this.BX.Messenger.Lib = this.BX.Messenger.Lib || {})));





// file: /bitrix/js/im/component/textarea/dist/textarea.bundle.js
(function (exports,ui_designTokens,ui_vue,im_lib_localstorage,im_lib_utils,main_core,ui_vue_vuex,main_core_events,im_const) {
	'use strict';

	function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
	function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { babelHelpers.defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
	ui_vue.WidgetBitrixVue.component('bx-im-component-textarea', {
	  /**
	   * @emits 'send' {text: string}
	   * @emits 'edit' {}
	   * @emits 'writes' {text: string}
	   * @emits 'focus' {event: object} -- 'event' - focus event
	   * @emits 'blur' {event: object} -- 'event' - blur event
	   * @emits 'keyup' {event: object} -- 'event' - keyup event
	   * @emits 'keydown' {event: object} -- 'event' - keydown event
	   * @emits 'appButtonClick' {appId: string, event: object} -- 'appId' - application name, 'event' - event click
	   * @emits 'fileSelected' {fileInput: domNode} -- 'fileInput' - dom node element
	   */

	  props: {
	    siteId: {
	      "default": 'default'
	    },
	    userId: {
	      "default": 0
	    },
	    dialogId: {
	      "default": 0
	    },
	    enableCommand: {
	      "default": true
	    },
	    enableMention: {
	      "default": true
	    },
	    desktopMode: {
	      "default": false
	    },
	    enableEdit: {
	      "default": false
	    },
	    enableFile: {
	      "default": false
	    },
	    sendByEnter: {
	      "default": true
	    },
	    autoFocus: {
	      "default": null
	    },
	    writesEventLetter: {
	      "default": 0
	    },
	    styles: {
	      type: Object,
	      "default": function _default() {
	        return {};
	      }
	    }
	  },
	  data: function data() {
	    return {
	      placeholderMessage: '',
	      currentMessage: '',
	      previousMessage: '',
	      commandListen: false,
	      mentionListen: false,
	      stylesDefault: Object.freeze({
	        button: {
	          backgroundColor: null,
	          iconColor: null
	        }
	      })
	    };
	  },
	  created: function created() {
	    main_core_events.EventEmitter.subscribe(im_const.EventType.textarea.insertText, this.onInsertText);
	    main_core_events.EventEmitter.subscribe(im_const.EventType.textarea.setFocus, this.onFocusSet);
	    main_core_events.EventEmitter.subscribe(im_const.EventType.textarea.setBlur, this.onFocusClear);
	    this.localStorage = im_lib_localstorage.LocalStorage;
	    this.textareaHistory = this.localStorage.get(this.siteId, this.userId, 'textarea-history', {});
	    this.currentMessage = this.textareaHistory[this.dialogId] || '';
	    this.placeholderMessage = this.currentMessage;
	  },
	  beforeDestroy: function beforeDestroy() {
	    main_core_events.EventEmitter.unsubscribe(im_const.EventType.textarea.insertText, this.onInsertText);
	    main_core_events.EventEmitter.unsubscribe(im_const.EventType.textarea.setFocus, this.onFocusSet);
	    main_core_events.EventEmitter.unsubscribe(im_const.EventType.textarea.setBlur, this.onFocusClear);
	    clearTimeout(this.messageStoreTimeout);
	    this.localStorage.set(this.siteId, this.userId, 'textarea-history', this.textareaHistory);
	    this.localStorage = null;
	  },
	  computed: _objectSpread({
	    textareaClassName: function textareaClassName() {
	      return ['bx-im-textarea', {
	        'bx-im-textarea-dark-background': this.isDarkBackground,
	        'bx-im-textarea-mobile': this.isMobile
	      }];
	    },
	    buttonStyle: function buttonStyle() {
	      var styles = Object.assign({}, this.stylesDefault, this.styles);
	      var isIconDark = false;
	      if (styles.button.iconColor) {
	        isIconDark = im_lib_utils.Utils.isDarkColor(styles.button.iconColor);
	      } else {
	        isIconDark = !im_lib_utils.Utils.isDarkColor(styles.button.backgroundColor);
	      }
	      styles.button.className = isIconDark ? 'bx-im-textarea-send-button' : 'bx-im-textarea-send-button bx-im-textarea-send-button-bright-arrow';
	      styles.button.style = styles.button.backgroundColor ? 'background-color: ' + styles.button.backgroundColor + ';' : '';
	      return styles;
	    },
	    isDarkBackground: function isDarkBackground() {
	      return this.application.options.darkBackground;
	    },
	    isMobile: function isMobile() {
	      return this.application.device.type === im_const.DeviceType.mobile;
	    },
	    localize: function localize() {
	      return ui_vue.WidgetBitrixVue.getFilteredPhrases('BX_MESSENGER_TEXTAREA_', this);
	    },
	    isIE11: function isIE11() {
	      return main_core.Browser.isIE11();
	    }
	  }, ui_vue_vuex.WidgetVuex.mapState({
	    application: function application(state) {
	      return state.application;
	    }
	  })),
	  directives: {
	    'bx-im-focus': {
	      inserted: function inserted(element, params) {
	        if (params.value === true || params.value === null && !this.isMobile) {
	          element.focus();
	        }
	      }
	    }
	  },
	  methods: {
	    /**
	     *
	     * @param text
	     * @param breakline - true/false (default)
	     * @param position - start, current (default), end
	     * @param cursor - start, before, after (default), end
	     * @param focus - set focus on textarea
	     */
	    insertText: function insertText(text) {
	      var breakline = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
	      var position = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'current';
	      var cursor = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'after';
	      var focus = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;
	      var textarea = this.$refs.textarea;
	      var selectionStart = textarea.selectionStart;
	      var selectionEnd = textarea.selectionEnd;
	      if (position == 'start') {
	        if (breakline) {
	          text = text + "\n";
	        }
	        textarea.value = text + textarea.value;
	        if (focus) {
	          if (cursor == 'after') {
	            textarea.selectionStart = text.length;
	            textarea.selectionEnd = textarea.selectionStart;
	          } else if (cursor == 'before') {
	            textarea.selectionStart = 0;
	            textarea.selectionEnd = textarea.selectionStart;
	          }
	        }
	      } else if (position == 'current') {
	        if (breakline) {
	          if (textarea.value.substring(0, selectionStart).trim().length > 0) {
	            text = "\n" + text;
	          }
	          text = text + "\n";
	        } else {
	          if (textarea.value && !textarea.value.endsWith(' ')) {
	            text = ' ' + text;
	          }
	        }
	        textarea.value = textarea.value.substring(0, selectionStart) + text + textarea.value.substring(selectionEnd, textarea.value.length);
	        if (focus) {
	          if (cursor == 'after') {
	            textarea.selectionStart = selectionStart + text.length;
	            textarea.selectionEnd = textarea.selectionStart;
	          } else if (cursor == 'before') {
	            textarea.selectionStart = selectionStart;
	            textarea.selectionEnd = textarea.selectionStart;
	          }
	        }
	      } else if (position == 'end') {
	        if (breakline) {
	          if (textarea.value.substring(0, selectionStart).trim().length > 0) {
	            text = "\n" + text;
	          }
	          text = text + "\n";
	        } else {
	          if (textarea.value && !textarea.value.endsWith(' ')) {
	            text = ' ' + text;
	          }
	        }
	        textarea.value = textarea.value + text;
	        if (focus) {
	          if (cursor == 'after') {
	            textarea.selectionStart = textarea.value.length;
	            textarea.selectionEnd = textarea.selectionStart;
	          } else if (cursor == 'before') {
	            textarea.selectionStart = textarea.value.length - text.length;
	            textarea.selectionEnd = textarea.selectionStart;
	          }
	        }
	      }
	      if (focus) {
	        if (cursor == 'start') {
	          textarea.selectionStart = 0;
	          textarea.selectionEnd = 0;
	        } else if (cursor == 'end') {
	          textarea.selectionStart = textarea.value.length;
	          textarea.selectionEnd = textarea.selectionStart;
	        }
	        textarea.focus();
	      }
	      this.textChangeEvent();
	    },
	    sendMessage: function sendMessage(event) {
	      event.preventDefault();
	      main_core_events.EventEmitter.emit(im_const.EventType.textarea.sendMessage, {
	        text: this.currentMessage.trim()
	      });
	      var textarea = this.$refs.textarea;
	      if (textarea) {
	        textarea.value = '';
	      }
	      if (this.autoFocus === null || this.autoFocus) {
	        textarea.focus();
	      }
	      this.textChangeEvent();
	    },
	    textChangeEvent: function textChangeEvent() {
	      var _this = this;
	      var textarea = this.$refs.textarea;
	      if (!textarea) {
	        return;
	      }
	      var text = textarea.value.trim();
	      if (this.currentMessage === text) {
	        return;
	      }
	      if (this.writesEventLetter <= text.length) {
	        main_core_events.EventEmitter.emit(im_const.EventType.textarea.startWriting, {
	          text: text
	        });
	      }
	      this.previousMessage = this.currentMessage;
	      this.previousSelectionStart = textarea.selectionStart;
	      this.previousSelectionEnd = this.previousSelectionStart;
	      this.currentMessage = text;
	      if (text.toString().length > 0) {
	        this.textareaHistory[this.dialogId] = text;
	      } else {
	        delete this.textareaHistory[this.dialogId];
	      }
	      clearTimeout(this.messageStoreTimeout);
	      this.messageStoreTimeout = setTimeout(function () {
	        _this.localStorage.set(_this.siteId, _this.userId, 'textarea-history', _this.textareaHistory, _this.userId ? 0 : 10);
	      }, 500);
	    },
	    onKeyDown: function onKeyDown(event) {
	      this.$emit('keydown', event);
	      var textarea = event.target;
	      var text = textarea.value.trim();
	      var isMac = im_lib_utils.Utils.platform.isMac();
	      var isCtrlTEnable = im_lib_utils.Utils.platform.isBitrixDesktop() || !im_lib_utils.Utils.browser.isChrome();

	      // TODO see more im/install/js/im/im.js:12324
	      if (this.commandListen) ; else if (this.mentionListen) ; else if (!(event.altKey && event.ctrlKey)) {
	        if (this.enableMention && event.shiftKey && (event.keyCode == 61 || event.keyCode == 50 || event.keyCode == 187 || event.keyCode == 187) || event.keyCode == 107) ; else if (this.enableCommand && (event.keyCode == 191 || event.keyCode == 111 || event.keyCode == 220)) ;
	      }
	      if (event.keyCode == 27) {
	        if (textarea.value != '' && textarea === document.activeElement) {
	          event.preventDefault();
	          event.stopPropagation();
	        }
	        if (event.shiftKey) {
	          textarea.value = '';
	        }
	      } else if (event.metaKey || event.ctrlKey) {
	        // TODO translit messages
	        if (isCtrlTEnable && event.key === 't' || !isCtrlTEnable && event.key === 'e') {
	          // translit case
	          event.preventDefault();
	        } else if (['b', 's', 'i', 'u'].includes(event.key)) {
	          var selectionStart = textarea.selectionStart;
	          var selectionEnd = textarea.selectionEnd;
	          var tagStart = '[' + event.key.toLowerCase() + ']';
	          var tagEnd = '[/' + event.key.toLowerCase() + ']';
	          var selected = textarea.value.substring(selectionStart, selectionEnd);
	          if (selected.startsWith(tagStart) && selected.endsWith(tagEnd)) {
	            selected = selected.substring(tagStart.length, selected.indexOf(tagEnd));
	          } else {
	            selected = tagStart + selected + tagEnd;
	          }
	          textarea.value = textarea.value.substring(0, selectionStart) + selected + textarea.value.substring(selectionEnd, textarea.value.length);
	          textarea.selectionStart = selectionStart;
	          textarea.selectionEnd = selectionStart + selected.length;
	          event.preventDefault();
	        }
	      }
	      if (event.keyCode == 9) {
	        this.insertText("\t");
	        event.preventDefault();
	      } else if (this.enableEdit && event.keyCode == 38 && text.length <= 0) {
	        main_core_events.EventEmitter.emit(im_const.EventType.textarea.edit, {});
	      } else if (event.keyCode == 13) {
	        if (this.isMobile) ; else if (this.sendByEnter == true) {
	          if (event.ctrlKey || event.altKey || event.shiftKey) {
	            if (!event.shiftKey) {
	              this.insertText("\n");
	            }
	          } else if (text.length <= 0) {
	            event.preventDefault();
	          } else {
	            this.sendMessage(event);
	          }
	        } else {
	          if (event.ctrlKey == true) {
	            this.sendMessage(event);
	          } else if (isMac && (event.metaKey == true || event.altKey == true)) {
	            this.sendMessage(event);
	          }
	        }
	      } else if ((event.ctrlKey || event.metaKey) && event.key == 'z') {
	        if (this.previousMessage) {
	          textarea.value = this.previousMessage;
	          textarea.selectionStart = this.previousSelectionStart;
	          textarea.selectionEnd = this.previousSelectionEnd;
	          this.previousMessage = '';
	          event.preventDefault();
	        }
	      }
	    },
	    onKeyUp: function onKeyUp(event) {
	      main_core_events.EventEmitter.emit(im_const.EventType.textarea.keyUp, {
	        event: event,
	        text: this.currentMessage
	      });
	      this.textChangeEvent();
	    },
	    onPaste: function onPaste(event) {
	      this.$nextTick(this.textChangeEvent);
	    },
	    onInput: function onInput(event) {
	      this.textChangeEvent();
	    },
	    onFocus: function onFocus(event) {
	      main_core_events.EventEmitter.emit(im_const.EventType.textarea.focus, event);
	    },
	    onBlur: function onBlur(event) {
	      main_core_events.EventEmitter.emit(im_const.EventType.textarea.blur, event);
	    },
	    onAppButtonClick: function onAppButtonClick(appId, event) {
	      main_core_events.EventEmitter.emit(im_const.EventType.textarea.appButtonClick, {
	        appId: appId,
	        event: event
	      });
	    },
	    onInsertText: function onInsertText(_ref) {
	      var _ref$data = _ref.data,
	        event = _ref$data === void 0 ? {} : _ref$data;
	      if (!event.text) {
	        return false;
	      }
	      this.insertText(event.text, event.breakline, event.position, event.cursor, event.focus);
	      main_core_events.EventEmitter.emit(im_const.EventType.textarea.keyUp, {
	        event: event,
	        text: this.currentMessage
	      });
	      return true;
	    },
	    onFocusSet: function onFocusSet() {
	      this.$refs.textarea.focus();
	      return true;
	    },
	    onFocusClear: function onFocusClear() {
	      this.$refs.textarea.blur();
	      return true;
	    },
	    onFileClick: function onFileClick(event) {
	      event.target.value = "";
	    },
	    onFileSelect: function onFileSelect(event) {
	      main_core_events.EventEmitter.emit(im_const.EventType.textarea.fileSelected, {
	        fileChangeEvent: event,
	        fileInput: event.target
	      });
	    },
	    log: function log(text, skip, event) {
	      console.warn(text);
	      if (skip == 1) {
	        event.preventDefault();
	      }
	    },
	    preventDefault: function preventDefault(event) {
	      event.preventDefault();
	    }
	  },
	  // language=Vue
	  template: "\n\t\t<div :class=\"textareaClassName\">\n\t\t\t<div class=\"bx-im-textarea-box\">\n\t\t\t\t<textarea ref=\"textarea\" class=\"bx-im-textarea-input\" @keydown=\"onKeyDown\" @keyup=\"onKeyUp\" @paste=\"onPaste\" @input=\"onInput\" @focus=\"onFocus\" @blur=\"onBlur\" v-bx-im-focus=\"autoFocus\" :placeholder=\"localize.BX_MESSENGER_TEXTAREA_PLACEHOLDER\">{{placeholderMessage}}</textarea>\n\t\t\t\t<transition enter-active-class=\"bx-im-textarea-send-button-show\" leave-active-class=\"bx-im-textarea-send-button-hide\">\n\t\t\t\t\t<button \n\t\t\t\t\t\tv-if=\"currentMessage\" \n\t\t\t\t\t\t:class=\"buttonStyle.button.className\" \n\t\t\t\t\t\t:style=\"buttonStyle.button.style\" \n\t\t\t\t\t\t:title=\"localize.BX_MESSENGER_TEXTAREA_BUTTON_SEND\"\n\t\t\t\t\t\t@click=\"sendMessage\" \n\t\t\t\t\t\t@touchend=\"sendMessage\" \n\t\t\t\t\t\t@mousedown=\"preventDefault\" \n\t\t\t\t\t\t@touchstart=\"preventDefault\" \n\t\t\t\t\t/>\n\t\t\t\t</transition>\n\t\t\t</div>\n\t\t\t<div class=\"bx-im-textarea-app-box\">\n\t\t\t\t<label v-if=\"enableFile && !isIE11\" class=\"bx-im-textarea-app-button bx-im-textarea-app-file\" :title=\"localize.BX_MESSENGER_TEXTAREA_FILE\">\n\t\t\t\t\t<input type=\"file\" @click=\"onFileClick($event)\" @change=\"onFileSelect($event)\" multiple>\n\t\t\t\t</label>\n\t\t\t\t<button class=\"bx-im-textarea-app-button bx-im-textarea-app-smile\" :title=\"localize.BX_MESSENGER_TEXTAREA_SMILE\" @click=\"onAppButtonClick('smile', $event)\"></button>\n\t\t\t\t<button v-if=\"false\" class=\"bx-im-textarea-app-button bx-im-textarea-app-gif\" :title=\"localize.BX_MESSENGER_TEXTAREA_GIPHY\" @click=\"onAppButtonClick('giphy', $event)\"></button>\n\t\t\t</div>\n\t\t</div>\n\t"
	});

}((this.window = this.window || {}),BX,BX,BX.Messenger.Lib,BX.Messenger.Lib,BX,BX,BX.Event,BX.Messenger.Const));





// file: /bitrix/js/imopenlines/component/message/dist/message.bundle.js
(function (exports,ui_vue,ui_vue_vuex,im_view_message,ui_fonts_opensans,main_core_events) {
	'use strict';

	/**
	 * Bitrix OpenLines widget
	 * Widget constants
	 *
	 * @package bitrix
	 * @subpackage imopenlines
	 * @copyright 2001-2019 Bitrix
	 */

	function GetObjectValues(source) {
	  var destination = [];
	  for (var value in source) {
	    if (source.hasOwnProperty(value)) {
	      destination.push(source[value]);
	    }
	  }
	  return destination;
	}

	/* region 01. Constants */

	var VoteType = Object.freeze({
	  none: 'none',
	  like: 'like',
	  dislike: 'dislike'
	});
	var LanguageType = Object.freeze({
	  russian: 'ru',
	  ukraine: 'ua',
	  world: 'en'
	});
	var FormType = Object.freeze({
	  none: 'none',
	  like: 'like',
	  smile: 'smile',
	  consent: 'consent',
	  welcome: 'welcome',
	  offline: 'offline',
	  history: 'history'
	});
	var LocationType = Object.freeze({
	  topLeft: 1,
	  topMiddle: 2,
	  topBottom: 3,
	  bottomLeft: 6,
	  bottomMiddle: 5,
	  bottomRight: 4
	});
	var LocationStyle = Object.freeze({
	  1: 'top-left',
	  2: 'top-center',
	  3: 'top-right',
	  6: 'bottom-left',
	  5: 'bottom-center',
	  4: 'bottom-right'
	});
	var WidgetBaseSize = Object.freeze({
	  width: 435,
	  height: 557
	});
	var WidgetMinimumSize = Object.freeze({
	  width: 340,
	  height: 435
	});
	var SubscriptionType = Object.freeze({
	  configLoaded: 'configLoaded',
	  widgetOpen: 'widgetOpen',
	  widgetClose: 'widgetClose',
	  sessionStart: 'sessionStart',
	  sessionOperatorChange: 'sessionOperatorChange',
	  sessionFinish: 'sessionFinish',
	  operatorMessage: 'operatorMessage',
	  userForm: 'userForm',
	  userMessage: 'userMessage',
	  userFile: 'userFile',
	  userVote: 'userVote',
	  every: 'every'
	});
	var SubscriptionTypeCheck = GetObjectValues(SubscriptionType);
	var RestMethod = Object.freeze({
	  widgetUserRegister: 'imopenlines.widget.user.register',
	  widgetChatCreate: 'imopenlines.widget.chat.create',
	  widgetConfigGet: 'imopenlines.widget.config.get',
	  widgetDialogGet: 'imopenlines.widget.dialog.get',
	  widgetDialogList: 'imopenlines.widget.dialog.list',
	  widgetUserGet: 'imopenlines.widget.user.get',
	  widgetUserConsentApply: 'imopenlines.widget.user.consent.apply',
	  widgetVoteSend: 'imopenlines.widget.vote.send',
	  widgetActionSend: 'imopenlines.widget.action.send',
	  pullServerTime: 'server.time',
	  pullConfigGet: 'pull.config.get'
	});
	var RestMethodCheck = GetObjectValues(RestMethod);
	var RestAuth = Object.freeze({
	  guest: 'guest'
	});
	var SessionStatus = Object.freeze({
	  "new": 0,
	  skip: 5,
	  answer: 10,
	  client: 20,
	  clientAfterOperator: 25,
	  operator: 40,
	  waitClient: 50,
	  close: 60,
	  spam: 65,
	  duplicate: 69,
	  silentlyClose: 75
	});
	var WidgetEventType = Object.freeze({
	  showForm: 'IMOL.Widget:showForm',
	  hideForm: 'IMOL.Widget:hideForm',
	  processMessagesToSendQueue: 'IMOL.Widget:processMessagesToSendQueue',
	  requestData: 'IMOL.Widget:requestData',
	  showConsent: 'IMOL.Widget:showConsent',
	  acceptConsent: 'IMOL.Widget:acceptConsent',
	  consentAccepted: 'IMOL.Widget:consentAccepted',
	  declineConsent: 'IMOL.Widget:declineConsent',
	  consentDeclined: 'IMOL.Widget:consentDeclined',
	  sendDialogVote: 'IMOL.Widget:sendDialogVote',
	  createSession: 'IMOL.Widget:createSession',
	  openSession: 'IMOL.Widget:openSession'
	});

	function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
	function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { babelHelpers.defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
	var FormType$1 = Object.freeze({
	  none: 'none',
	  like: 'like',
	  welcome: 'welcome',
	  offline: 'offline',
	  history: 'history'
	});
	var VoteType$1 = Object.freeze({
	  none: 'none',
	  like: 'like',
	  dislike: 'dislike'
	});
	ui_vue.WidgetBitrixVue.cloneComponent('bx-imopenlines-message', 'bx-im-view-message', {
	  methods: {
	    checkMessageParamsForForm: function checkMessageParamsForForm() {
	      if (!this.message.params || !this.message.params.IMOL_FORM) {
	        return true;
	      }
	      if (this.message.params.IMOL_FORM === FormType$1.like) {
	        if (parseInt(this.message.params.IMOL_VOTE) === this.widget.dialog.sessionId && this.widget.dialog.userVote === VoteType$1.none) {
	          main_core_events.EventEmitter.emit(WidgetEventType.showForm, {
	            type: FormType$1.like,
	            delayed: true
	          });
	        }
	      }
	    }
	  },
	  created: function created() {
	    this.checkMessageParamsForForm();
	  },
	  computed: _objectSpread({
	    dialogNumber: function dialogNumber() {
	      if (!this.message.params) {
	        return false;
	      }
	      if (!this.message.params.IMOL_SID) {
	        return false;
	      }
	      return this.$Bitrix.Loc.getMessage('IMOL_MESSAGE_DIALOG_ID').replace('#ID#', this.message.params.IMOL_SID);
	    },
	    showMessage: function showMessage() {
	      if (!this.message.params) {
	        return true;
	      }
	      if (this.message.params.IMOL_FORM && this.message.params.IMOL_FORM === 'like') {
	        return false;
	      }
	      return true;
	    }
	  }, ui_vue_vuex.WidgetVuex.mapState({
	    widget: function widget(state) {
	      return state.widget;
	    }
	  })),
	  template: "\n\t\t<div v-if=\"showMessage\" class=\"bx-imopenlines-message\">\n\t\t\t<div v-if=\"dialogNumber\" class=\"bx-imopenlines-message-dialog-number\">{{dialogNumber}}</div>\n\t\t\t#PARENT_TEMPLATE#\n\t\t</div>\n\t"
	});

}((this.window = this.window || {}),BX,BX,window,BX,BX.Event));





// file: /bitrix/js/imopenlines/component/form/dist/form.bundle.js
(function (exports,ui_vue,ui_vue_vuex) {
    'use strict';

    function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
    function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { babelHelpers.defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
    var EVENT_POSTFIX = 'Openlines';
    var LIVECHAT_PREFIX = 'livechat';
    ui_vue.WidgetBitrixVue.component('bx-imopenlines-form', {
      props: {
        message: {
          type: Object,
          required: false
        }
      },
      data: function data() {
        return {
          formSuccess: false,
          formError: false
        };
      },
      mounted: function mounted() {
        if (this.filledFormFlag) {
          this.formSuccess = true;
        }
      },
      computed: _objectSpread({
        chatId: function chatId() {
          return this.application.dialog.chatId;
        },
        formId: function formId() {
          if (this.message) {
            return String(this.message.params.CRM_FORM_ID);
          }
          if (this.widget.common.crmFormsSettings.welcomeFormId) {
            return this.widget.common.crmFormsSettings.welcomeFormId;
          }
          return '';
        },
        formSec: function formSec() {
          if (this.message) {
            return this.message.params.CRM_FORM_SEC;
          }
          if (this.widget.common.crmFormsSettings.welcomeFormSec) {
            return this.widget.common.crmFormsSettings.welcomeFormSec;
          }
          return '';
        },
        showForm: function showForm() {
          return this.formId && this.formSec && !this.formSuccess && !this.formError;
        },
        filledFormFlag: function filledFormFlag() {
          if (this.message) {
            return this.message.params.CRM_FORM_FILLED === 'Y';
          }
          return false;
        },
        messageCount: function messageCount() {
          return this.dialog.messageCount;
        }
      }, ui_vue_vuex.WidgetVuex.mapState({
        widget: function widget(state) {
          return state.widget;
        },
        application: function application(state) {
          return state.application;
        },
        dialog: function dialog(state) {
          return state.dialogues.collection[state.application.dialog.dialogId];
        }
      })),
      watch: {
        filledFormFlag: function filledFormFlag(newValue) {
          if (newValue === true && !this.formSuccess) {
            this.formSuccess = true;
          }
        },
        chatId: function chatId(newValue) {
          // chatId > 0 means chat and user were initialized
          if (newValue !== 0 && this.widgetInitPromiseResolve) {
            this.widgetInitPromiseResolve();
          }
        }
      },
      methods: {
        getCrmBindings: function getCrmBindings() {
          var _this = this;
          return new Promise(function (resolve, reject) {
            _this.$Bitrix.RestClient.get().callMethod('imopenlines.widget.crm.bindings.get', {
              'OPENLINES_CODE': _this.buildOpenlinesCode()
            }).then(resolve)["catch"](reject);
          });
        },
        onBeforeFormSubmit: function onBeforeFormSubmit(eventData) {
          if (this.signedEntities && this.signedEntities !== '') {
            eventData.sign = this.signedEntities;
          }
        },
        onFormSubmit: function onFormSubmit(eventData) {
          var _this2 = this;
          this.eventData = eventData;
          // redefine form promise so we can send form manually later
          this.eventData.promise = this.eventData.promise.then(function () {
            return new Promise(function (resolve) {
              if (_this2.chatId === 0) {
                // promise we resolve after user and chat are inited, resolve method is saved to use in chatId watcher
                new Promise(function (widgetResolve, widgetReject) {
                  _this2.widgetInitPromiseResolve = widgetResolve;
                }).then(function () {
                  _this2.setFormProperties();
                  return resolve();
                });
                _this2.getApplication().requestData();
              }
              // we have user and chat so we can just resolve form promise instantly
              else {
                // request current crm bindings and attach them to form
                if (_this2.widget.common.crmFormsSettings.welcomeFormDelay) {
                  _this2.getCrmBindings().then(function (result) {
                    _this2.signedEntities = result.data();
                    _this2.setFormProperties();
                    return resolve();
                  })["catch"](function (error) {
                    console.error('Error getting CRM bindings', error);
                  });
                } else {
                  _this2.setFormProperties();
                  return resolve();
                }
              }
            });
          });
        },
        setFormProperties: function setFormProperties() {
          if (!this.eventData) {
            return false;
          }
          this.eventData.form.setProperty('eventNamePostfix', EVENT_POSTFIX);
          this.eventData.form.setProperty('openlinesCode', this.buildOpenlinesCode());
          if (this.message) {
            var _this$message$params$;
            this.eventData.form.setProperty('messageId', this.message.id);
            this.eventData.form.setProperty('isWelcomeForm', (_this$message$params$ = this.message.params.IS_WELCOME_FORM) !== null && _this$message$params$ !== void 0 ? _this$message$params$ : 'N');
          } else {
            this.eventData.form.setProperty('isWelcomeForm', 'Y');
          }
        },
        buildOpenlinesCode: function buildOpenlinesCode() {
          var configId = 0;
          if (this.dialog.entityId !== '') {
            configId = this.dialog.entityId.split('|')[0];
          }
          var chatId = this.dialog.chatId || 0;
          var userId = this.application.common.userId || 0;
          return "".concat(LIVECHAT_PREFIX, "|").concat(configId, "|").concat(chatId, "|").concat(userId);
        },
        onFormSendSuccess: function onFormSendSuccess() {
          if (!this.message) {
            this.$store.commit('widget/common', {
              dialogStart: true
            });
          }
          this.$emit('formSendSuccess');
          this.formSuccess = true;
        },
        onFormSendError: function onFormSendError(error) {
          this.formError = true;
          this.$emit('formSendError', {
            error: error
          });
        },
        getSuccessText: function getSuccessText() {
          return this.widget.common.crmFormsSettings.successText;
        },
        getErrorText: function getErrorText() {
          return this.widget.common.crmFormsSettings.errorText;
        },
        getApplication: function getApplication() {
          return this.$Bitrix.Application.get();
        }
      },
      template: "\n\t\t<div class=\"bx-im-message bx-im-message-without-menu bx-im-message-without-avatar bx-imopenlines-form-wrapper\">\n\t\t\t<div v-show=\"showForm\" class=\"bx-imopenlines-form-content\">\n\t\t\t\t<bx-crm-form\n\t\t\t\t\t:id=\"formId\"\n\t\t\t\t\t:sec=\"formSec\"\n\t\t\t\t\t:address=\"widget.common.host\"\n\t\t\t\t\t:lang=\"application.common.languageId\"\n\t\t\t\t\t@form:submit:post:before=\"onBeforeFormSubmit\"\n\t\t\t\t\t@form:submit=\"onFormSubmit\"\n\t\t\t\t\t@form:send:success=\"onFormSendSuccess\"\n\t\t\t\t\t@form:send:error=\"onFormSendError\"\n\t\t\t\t/>\n\t\t\t</div>\n\t\t\t<div v-show=\"formSuccess\" class=\"bx-imopenlines-form-result-container bx-imopenlines-form-success\">\n\t\t\t\t<div class=\"bx-imopenlines-form-result-icon\"></div>\n\t\t\t\t<div class=\"bx-imopenlines-form-result-title\">\n\t\t\t\t\t{{ getSuccessText() }}\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t\t<div v-show=\"formError\" class=\"bx-imopenlines-form-result-container bx-imopenlines-form-error\">\n\t\t\t\t<div class=\"bx-imopenlines-form-result-icon\"></div>\n\t\t\t\t<div class=\"bx-imopenlines-form-result-title\">\n\t\t\t\t\t{{ getErrorText() }}\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t</div>\n\t"
    });

}((this.window = this.window || {}),BX,BX));





// file: /bitrix/js/im/provider/rest/dist/registry.bundle.js
this.BX = this.BX || {};
this.BX.Messenger = this.BX.Messenger || {};
this.BX.Messenger.Provider = this.BX.Messenger.Provider || {};
(function (exports,ui_vue_vuex,im_const,im_lib_logger,main_core_events) {
	'use strict';

	/**
	 * Bitrix Messenger
	 * Base Rest Answer Handler
	 *
	 * @package bitrix
	 * @subpackage im
	 * @copyright 2001-2019 Bitrix
	 */
	var BaseRestHandler = /*#__PURE__*/function () {
	  babelHelpers.createClass(BaseRestHandler, null, [{
	    key: "create",
	    value: function create() {
	      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	      return new this(params);
	    }
	  }]);
	  function BaseRestHandler() {
	    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	    babelHelpers.classCallCheck(this, BaseRestHandler);
	    if (babelHelpers["typeof"](params.controller) === 'object' && params.controller) {
	      this.controller = params.controller;
	    }
	    if (babelHelpers["typeof"](params.store) === 'object' && params.store) {
	      this.store = params.store;
	    }
	  }
	  babelHelpers.createClass(BaseRestHandler, [{
	    key: "execute",
	    value: function execute(command, result) {
	      var extra = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
	      command = 'handle' + command.split('.').map(function (element) {
	        return element.charAt(0).toUpperCase() + element.slice(1);
	      }).join('');
	      if (result.error()) {
	        if (typeof this[command + 'Error'] === 'function') {
	          return this[command + 'Error'](result.error(), extra);
	        }
	      } else {
	        if (typeof this[command + 'Success'] === 'function') {
	          return this[command + 'Success'](result.data(), extra);
	        }
	      }
	      return typeof this[command] === 'function' ? this[command](result, extra) : null;
	    }
	  }]);
	  return BaseRestHandler;
	}();

	function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
	function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { babelHelpers.defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
	var CoreRestHandler = /*#__PURE__*/function (_BaseRestHandler) {
	  babelHelpers.inherits(CoreRestHandler, _BaseRestHandler);
	  function CoreRestHandler() {
	    babelHelpers.classCallCheck(this, CoreRestHandler);
	    return babelHelpers.possibleConstructorReturn(this, babelHelpers.getPrototypeOf(CoreRestHandler).apply(this, arguments));
	  }
	  babelHelpers.createClass(CoreRestHandler, [{
	    key: "handleImUserListGetSuccess",
	    value: function handleImUserListGetSuccess(data) {
	      this.store.dispatch('users/set', ui_vue_vuex.WidgetVuexBuilderModel.convertToArray(data));
	    }
	  }, {
	    key: "handleImUserGetSuccess",
	    value: function handleImUserGetSuccess(data) {
	      this.store.dispatch('users/set', [data]);
	    }
	  }, {
	    key: "handleImChatGetSuccess",
	    value: function handleImChatGetSuccess(data) {
	      this.store.dispatch('dialogues/set', data);
	    }
	  }, {
	    key: "handleImDialogMessagesGetSuccess",
	    value: function handleImDialogMessagesGetSuccess(data) {
	      this.store.dispatch('users/set', data.users);
	      this.store.dispatch('files/setBefore', this.controller.application.prepareFilesBeforeSave(data.files));
	      // this.store.dispatch('messages/setBefore', data.messages);
	    }
	  }, {
	    key: "handleImDialogMessagesGetInitSuccess",
	    value: function handleImDialogMessagesGetInitSuccess(data) {
	      this.store.dispatch('users/set', data.users);
	      this.store.dispatch('files/set', this.controller.application.prepareFilesBeforeSave(data.files));
	      //handling messagesSet for empty chat
	      if (data.messages.length === 0 && data.chat_id) {
	        im_lib_logger.Logger.warn('setting messagesSet for empty chat', data.chat_id);
	        setTimeout(function () {
	          main_core_events.EventEmitter.emit(im_const.EventType.dialog.messagesSet, {
	            chatId: data.chat_id
	          });
	        }, 100);
	      } else {
	        this.store.dispatch('messages/set', data.messages.reverse());
	      }
	    }
	  }, {
	    key: "handleImDialogMessagesGetUnreadSuccess",
	    value: function handleImDialogMessagesGetUnreadSuccess(data) {
	      this.store.dispatch('users/set', data.users);
	      this.store.dispatch('files/set', this.controller.application.prepareFilesBeforeSave(data.files));
	      // this.store.dispatch('messages/setAfter', data.messages);
	    }
	  }, {
	    key: "handleImDiskFolderGetSuccess",
	    value: function handleImDiskFolderGetSuccess(data) {
	      this.store.commit('application/set', {
	        dialog: {
	          diskFolderId: data.ID
	        }
	      });
	    }
	  }, {
	    key: "handleImMessageAddSuccess",
	    value: function handleImMessageAddSuccess(messageId, message) {
	      var _this = this;
	      this.store.dispatch('messages/update', {
	        id: message.id,
	        chatId: message.chatId,
	        fields: {
	          id: messageId,
	          sending: false,
	          error: false
	        }
	      }).then(function () {
	        _this.store.dispatch('messages/actionFinish', {
	          id: messageId,
	          chatId: message.chatId
	        });
	      });
	    }
	  }, {
	    key: "handleImMessageAddError",
	    value: function handleImMessageAddError(error, message) {
	      this.store.dispatch('messages/actionError', {
	        id: message.id,
	        chatId: message.chatId
	      });
	    }
	  }, {
	    key: "handleImDiskFileCommitSuccess",
	    value: function handleImDiskFileCommitSuccess(result, message) {
	      var _this2 = this;
	      this.store.dispatch('messages/update', {
	        id: message.id,
	        chatId: message.chatId,
	        fields: {
	          id: result['MESSAGE_ID'],
	          sending: false,
	          error: false
	        }
	      }).then(function () {
	        _this2.store.dispatch('messages/actionFinish', {
	          id: result['MESSAGE_ID'],
	          chatId: message.chatId
	        });
	      });
	    }
	  }, {
	    key: "handleImDiskFileCommitError",
	    value: function handleImDiskFileCommitError(error, message) {
	      this.store.dispatch('files/update', {
	        chatId: message.chatId,
	        id: message.file.id,
	        fields: {
	          status: im_const.FileStatus.error,
	          progress: 0
	        }
	      });
	      this.store.dispatch('messages/actionError', {
	        id: message.id,
	        chatId: message.chatId,
	        retry: false
	      });
	    }
	  }, {
	    key: "handleImRecentListSuccess",
	    value: function handleImRecentListSuccess(result, message) {
	      im_lib_logger.Logger.warn('Provider.Rest.handleImRecentGetSuccess', result);
	      var users = [];
	      var dialogues = [];
	      var recent = [];
	      result.items.forEach(function (item) {
	        var userId = 0;
	        var chatId = 0;
	        if (item.user && item.user.id > 0) {
	          userId = item.user.id;
	          users.push(item.user);
	        }
	        if (item.chat) {
	          chatId = item.chat.id;
	          dialogues.push(Object.assign(item.chat, {
	            dialogId: item.id
	          }));
	        } else {
	          dialogues.push(Object.assign({}, {
	            dialogId: item.id
	          }));
	        }
	        recent.push(_objectSpread(_objectSpread({}, item), {}, {
	          avatar: item.avatar.url,
	          color: item.avatar.color,
	          userId: userId,
	          chatId: chatId
	        }));
	      });
	      this.store.dispatch('users/set', users);
	      this.store.dispatch('dialogues/set', dialogues);
	      this.store.dispatch('recent/set', recent);
	    }
	  }]);
	  return CoreRestHandler;
	}(BaseRestHandler);

	/**
	 * Bitrix Im
	 * Dialog Rest answers (Rest Answer Handler)
	 *
	 * @package bitrix
	 * @subpackage im
	 * @copyright 2001-2023 Bitrix
	 */
	var DialogRestHandler = /*#__PURE__*/function (_BaseRestHandler) {
	  babelHelpers.inherits(DialogRestHandler, _BaseRestHandler);
	  function DialogRestHandler(params) {
	    var _this;
	    babelHelpers.classCallCheck(this, DialogRestHandler);
	    _this = babelHelpers.possibleConstructorReturn(this, babelHelpers.getPrototypeOf(DialogRestHandler).call(this, params));
	    _this.application = params.application;
	    return _this;
	  }
	  babelHelpers.createClass(DialogRestHandler, [{
	    key: "handleImChatGetSuccess",
	    value: function handleImChatGetSuccess(data) {
	      this.store.commit('application/set', {
	        dialog: {
	          chatId: data.id,
	          dialogId: data.dialog_id,
	          diskFolderId: data.disk_folder_id
	        }
	      });
	    }
	  }, {
	    key: "handleImCallGetCallLimitsSuccess",
	    value: function handleImCallGetCallLimitsSuccess(data) {
	      this.store.commit('application/set', {
	        call: {
	          serverEnabled: data.callServerEnabled,
	          maxParticipants: data.maxParticipants
	        }
	      });
	    }
	  }, {
	    key: "handleImChatGetError",
	    value: function handleImChatGetError(error) {
	      if (error.ex.error === 'ACCESS_ERROR') {
	        im_lib_logger.Logger.error('MobileRestAnswerHandler.handleImChatGetError: ACCESS_ERROR');
	        //	app.closeController();
	      }
	    }
	  }, {
	    key: "handleImDialogMessagesGetInitSuccess",
	    value: function handleImDialogMessagesGetInitSuccess(data) {
	      // EventEmitter.emit(EventType.dialog.readVisibleMessages, {chatId: this.controller.application.getChatId()});
	    }
	  }, {
	    key: "handleImMessageAddSuccess",
	    value: function handleImMessageAddSuccess(messageId, message) {
	      console.warn('im.message.add success in dialog handler');
	      // this.application.messagesQueue = this.context.messagesQueue.filter(el => el.id !== message.id);
	    }
	  }, {
	    key: "handleImMessageAddError",
	    value: function handleImMessageAddError(error, message) {
	      // this.application.messagesQueue = this.context.messagesQueue.filter(el => el.id !== message.id);
	    }
	  }, {
	    key: "handleImDiskFileCommitSuccess",
	    value: function handleImDiskFileCommitSuccess(result, message) {
	      // this.application.messagesQueue = this.context.messagesQueue.filter(el => el.id !== message.id);
	    }
	  }]);
	  return DialogRestHandler;
	}(BaseRestHandler);

	/**
	 * Bitrix Messenger
	 * Bundle rest answer handlers
	 *
	 * @package bitrix
	 * @subpackage im
	 * @copyright 2001-2019 Bitrix
	 */

	exports.BaseRestHandler = BaseRestHandler;
	exports.CoreRestHandler = CoreRestHandler;
	exports.DialogRestHandler = DialogRestHandler;

}((this.BX.Messenger.Provider.Rest = this.BX.Messenger.Provider.Rest || {}),BX,BX.Messenger.Const,BX.Messenger.Lib,BX.Event));





// file: /bitrix/js/main/polyfill/promise/js/promise.js
;(function(window) {
	'use strict';

	if (typeof window.Promise === 'undefined' ||
		window.Promise.toString().indexOf('[native code]') === -1)
	{
		var PROMISE_STATUS = '[[PromiseStatus]]';
		var PROMISE_VALUE = '[[PromiseValue]]';
		var STATUS_PENDING = 'pending';
		var STATUS_INTERNAL_PENDING = 'internal pending';
		var STATUS_RESOLVED = 'resolved';
		var STATUS_REJECTED = 'rejected';


		/**
		 * Handles promise done
		 * @param {Promise} promise
		 * @param {Handler} deferred
		 */
		var handle = function(promise, deferred)
		{
			if (promise[PROMISE_STATUS] === STATUS_INTERNAL_PENDING)
			{
				promise = promise[PROMISE_VALUE];
			}

			if (promise[PROMISE_STATUS] === STATUS_PENDING)
			{
				promise.deferreds.push(deferred);
			}
			else
			{
				promise.handled = true;

				setTimeout(function() {
					var callback = promise[PROMISE_STATUS] === STATUS_RESOLVED ?
						deferred.onFulfilled : deferred.onRejected;

					if (callback)
					{
						try {
							resolve(deferred.promise, callback(promise[PROMISE_VALUE]));
						} catch (err) {
							reject(deferred.promise, err);
						}
					}
					else
					{
						if (promise[PROMISE_STATUS] === STATUS_RESOLVED)
						{
							resolve(deferred.promise, promise[PROMISE_VALUE]);
						}
						else
						{
							reject(deferred.promise, promise[PROMISE_VALUE]);
						}
					}
				}, 0);
			}
		};


		/**
		 * Resolves promise with value
		 * @param {Promise} promise
		 * @param {*} value
		 */
		var resolve = function(promise, value) {
			if (value === promise)
			{
				throw new TypeError('A promise cannot be resolved with it promise.');
			}

			try {
				if (value && (typeof value === 'object' || typeof value === 'function'))
				{
					if (value instanceof Promise)
					{
						promise[PROMISE_STATUS] = STATUS_INTERNAL_PENDING;
						promise[PROMISE_VALUE] = value;
						finale(promise);
						return;
					}
					else if (typeof value.then === 'function')
					{
						executePromise(value.then.bind(value), promise);
						return;
					}
				}

				promise[PROMISE_STATUS] = STATUS_RESOLVED;
				promise[PROMISE_VALUE] = value;
				finale(promise);
			} catch (err) {
				reject(promise, err);
			}
		};


		/**
		 * Rejects promise with reason
		 * @param promise
		 * @param reason
		 */
		var reject = function(promise, reason)
		{
			promise[PROMISE_STATUS] = STATUS_REJECTED;
			promise[PROMISE_VALUE] = reason;
			finale(promise);
		};


		/**
		 * Calls async callback
		 * @param {Promise} promise
		 */
		var finale = function(promise)
		{
			if (promise[PROMISE_STATUS] === STATUS_REJECTED && promise.deferreds.length === 0)
			{
				setTimeout(function() {
					if (!promise.handled)
					{
						console.error('Unhandled Promise Rejection: ' + promise[PROMISE_VALUE]);
					}
				}, 0);
			}

			promise.deferreds.forEach(function(deferred) {
				handle(promise, deferred);
			});

			promise.deferreds = null;
		};


		/**
		 * Executes promise
		 * @param {function} resolver - Resolver
		 * @param {Promise} promise
		 */
		var executePromise = function(resolver, promise)
		{
			var done = false;

			try {
				resolver(resolveWrapper, rejectWrapper);
			} catch (err) {
				if (!done)
				{
					done = true;
					reject(promise, err);
				}
			}

			// Resolve function
			function resolveWrapper(value)
			{
				if (!done)
				{
					done = true;
					resolve(promise, value);
				}
			}

			// Reject function
			function rejectWrapper(reason)
			{
				if (!done)
				{
					done = true;
					reject(promise, reason);
				}
			}
		};


		/**
		 * Implements interface for works with promise handlers
		 * @param {?function} [onFulfilled]
		 * @param {?function} [onRejected]
		 * @param {Promise} promise
		 *
		 * @constructor
		 */
		var Handler = function(onFulfilled, onRejected, promise)
		{
			this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;
			this.onRejected = typeof onRejected === 'function' ? onRejected : null;
			this.promise = promise;
		};


		/**
		 * Implements Promise polyfill
		 * @param {function} resolver
		 *
		 * @constructor
		 */
		var Promise = function(resolver)
		{
			this[PROMISE_STATUS] = STATUS_PENDING;
			this[PROMISE_VALUE] = null;
			this.handled = false;
			this.deferreds = [];

			// Try execute promise resolver
			executePromise(resolver, this);
		};


		/**
		 * Appends a rejection handler callback to the promise,
		 * and returns a new promise resolving to the return value of the callback if it is called,
		 * or to its original fulfillment value if the promise is instead fulfilled.
		 *
		 * @param {function} onRejected
		 */
		Promise.prototype['catch'] = function(onRejected) {
			return this.then(null, onRejected);
		};


		/**
		 * Appends fulfillment and rejection handlers to the promise,
		 * and returns a new promise resolving to the return value of the called handler,
		 * or to its original settled value if the promise was not handled
		 * (i.e. if the relevant handler onFulfilled or onRejected is not a function).
		 *
		 * @param {function} onFulfilled
		 * @param {function} [onRejected]
		 * @returns {Promise}
		 */
		Promise.prototype.then = function(onFulfilled, onRejected)
		{
			var promise = new Promise(function() {});
			handle(this, new Handler(onFulfilled, onRejected, promise));
			return promise;
		};


		/**
		 * The method returns a single Promise that resolves when all of the promises
		 * in the iterable argument have resolved or when the iterable argument contains no promises.
		 * It rejects with the reason of the first promise that rejects.
		 *
		 * @static
		 * @param iterable - An iterable object such as an Array or String
		 * @return {Promise}
		 */
		Promise.all = function(iterable)
		{
			var args = [].slice.call(iterable);

			return new Promise(function(resolve, reject) {
				if (args.length === 0)
				{
					resolve(args);
				}
				else
				{
					var remaining = args.length;

					var res = function(i, val)
					{
						try {
							if (val && (typeof val === 'object' || typeof val === 'function'))
							{
								if (typeof val.then === 'function')
								{
									val.then.call(val, function(val) {
										res(i, val);
									}, reject);
									return;
								}
							}

							args[i] = val;

							if (--remaining === 0)
							{
								resolve(args);
							}
						} catch (ex) {
							reject(ex);
						}
					};

					for (var i = 0; i < args.length; i++)
					{
						res(i, args[i]);
					}
				}
			});
		};


		/**
		 * The method returns a Promise object that is resolved with the given value.
		 * If the value is a thenable (i.e. has a 'then' method),
		 * the returned promise will 'follow' that thenable, adopting its eventual state;
		 * if the value was a promise, that object becomes the result of the call to Promise.resolve;
		 * otherwise the returned promise will be fulfilled with the value.
		 *
		 * @param {*|Promise} value - Argument to be resolved by this Promise. Can also be a Promise or a thenable to resolve.
		 * @returns {Promise}
		 */
		Promise.resolve = function(value)
		{
			if (value && typeof value === 'object' && value.constructor === Promise)
			{
				return value;
			}

			return new Promise(function(resolve) {
				resolve(value);
			});
		};


		/**
		 * The method returns a Promise object that is rejected with the given reason.
		 *
		 * @param {*} reason - Reason why this Promise rejected.
		 * @returns {Promise}
		 */
		Promise.reject = function(reason)
		{
			return new Promise(function(resolve, reject) {
				reject(reason);
			});
		};


		/**
		 * The Promise.race(iterable) method returns a promise that resolves or rejects
		 * as soon as one of the promises in the iterable resolves or rejects,
		 * with the value or reason from that promise.
		 *
		 * @static
		 * @param iterable - An iterable object, such as an Array.
		 * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols
		 * @returns {Promise}
		 */
		Promise.race = function(iterable)
		{
			return new Promise(function(resolve, reject) {
				for (var i = 0, len = iterable.length; i < len; i++)
				{
					iterable[i].then(resolve, reject);
				}
			});
		};

		window.Promise = Promise;
	}
})(window);



// file: /bitrix/js/ui/vue/components/crm/form/dist/crm.form.bundle.js
this.BX = this.BX || {};
this.BX.Ui = this.BX.Ui || {};
this.BX.Ui.Vue = this.BX.Ui.Vue || {};
this.BX.Ui.Vue.Components = this.BX.Ui.Vue.Components || {};
(function (exports,ui_vue) {
    'use strict';

    function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

    function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { babelHelpers.defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
    var loadAppPromise = null;
    ui_vue.WidgetVue.component('bx-crm-form', {
      props: {
        id: {
          type: String,
          required: true
        },
        sec: {
          type: String,
          required: true
        },
        lang: {
          type: String,
          required: true,
          "default": 'en'
        },
        address: {
          type: String,
          required: true,
          "default": function _default() {
            return window.location.origin;
          }
        },
        design: {
          type: Object,
          required: false,
          "default": function _default() {
            return {
              compact: true
            };
          }
        }
      },
      data: function data() {
        return {
          message: '',
          isLoading: false,
          obj: {}
        };
      },
      beforeDestroy: function beforeDestroy() {
        if (this.obj.instance) {
          this.obj.instance.destroy();
        }
      },
      mounted: function mounted() {
        var _this = this;

        var loadForm = function loadForm() {
          _this.isLoading = false;
          _this.message = '';
          _this.obj.config.data.node = _this.$el;
          _this.obj.config.data.design = _objectSpread(_objectSpread({}, _this.obj.config.data.design), _this.design);
          _this.obj.instance = window.b24form.App.createForm24(_this.obj.config, _this.obj.config.data);

          _this.obj.instance.subscribeAll(function (data, instance, type) {
            data = data || {};
            data.form = instance;

            _this.$emit('form:' + type, data);
          });
        };

        this.isLoading = true;
        var promise = null;

        if (window.fetch) {
          var formData = new FormData();
          formData.append('id', this.id);
          formData.append('sec', this.sec);
          promise = fetch(this.address + "/bitrix/services/main/ajax.php?action=crm.site.form.get", {
            method: 'POST',
            body: formData,
            mode: "cors"
          });
        } else {
          this.message = 'error';
          return;
        }

        promise.then(function (response) {
          return response.json();
        }).then(function (data) {
          if (data.error) {
            throw new Error(data.error_description);
          }

          _this.obj.config = data.result.config;

          if (window.b24form && window.b24form.App) {
            loadForm();
            return;
          }

          if (!loadAppPromise) {
            loadAppPromise = new Promise(function (resolve, reject) {
              var checker = function checker() {
                if (!window.b24form || !window.b24form || !window.b24form.App) {
                  setTimeout(checker, 200);
                } else {
                  resolve();
                }
              };

              var node = document.createElement('script');
              node.src = data.result.loader.app.link;
              node.onload = checker;
              node.onerror = reject;
              document.head.appendChild(node);
            });
          }

          loadAppPromise.then(loadForm)["catch"](function (e) {
            _this.message = 'App load failed:' + e;
          });
        })["catch"](function (error) {
          _this.isLoading = false;
          _this.message = error;
        });
      },
      template: "\n\t\t<div>\n\t\t\t<div v-if=\"isLoading\" class=\"ui-vue-crm-form-loading-container\"></div>\n\t\t\t<div v-else-if=\"message\">{{ message }}</div>\n\t\t</div>\n\t"
    });

}((this.BX.Ui.Vue.Components.Crm = this.BX.Ui.Vue.Components.Crm || {}),BX));





// file: /bitrix/js/im/provider/pull/dist/registry.bundle.js
this.BX = this.BX || {};
this.BX.Messenger = this.BX.Messenger || {};
this.BX.Messenger.Provider = this.BX.Messenger.Provider || {};
(function (exports,ui_vue_vuex,im_const,im_lib_logger,main_core_events,pull_client) {
	'use strict';

	function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
	function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { babelHelpers.defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
	var ImBasePullHandler = /*#__PURE__*/function () {
	  babelHelpers.createClass(ImBasePullHandler, null, [{
	    key: "create",
	    value: function create() {
	      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	      return new this(params);
	    }
	  }]);
	  function ImBasePullHandler() {
	    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	    babelHelpers.classCallCheck(this, ImBasePullHandler);
	    if (babelHelpers["typeof"](params.controller) === 'object' && params.controller) {
	      this.controller = params.controller;
	    }
	    if (babelHelpers["typeof"](params.store) === 'object' && params.store) {
	      this.store = params.store;
	    }
	    this.option = babelHelpers["typeof"](params.store) === 'object' && params.store ? params.store : {};
	    if (!(babelHelpers["typeof"](this.option.handlingDialog) === 'object' && this.option.handlingDialog && this.option.handlingDialog.chatId && this.option.handlingDialog.dialogId)) {
	      this.option.handlingDialog = false;
	    }
	  }
	  babelHelpers.createClass(ImBasePullHandler, [{
	    key: "getModuleId",
	    value: function getModuleId() {
	      return 'im';
	    }
	  }, {
	    key: "getSubscriptionType",
	    value: function getSubscriptionType() {
	      return pull_client.PullClient.SubscriptionType.Server;
	    }
	  }, {
	    key: "skipExecute",
	    value: function skipExecute(params) {
	      var extra = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	      if (!extra.optionImportant) {
	        if (this.option.skip) {
	          im_lib_logger.Logger.info('Pull: command skipped while loading messages', params);
	          return true;
	        }
	        if (!this.option.handlingDialog) {
	          return false;
	        }
	      }
	      if (typeof params.chatId !== 'undefined' || typeof params.dialogId !== 'undefined') {
	        if (typeof params.chatId !== 'undefined' && parseInt(params.chatId) === parseInt(this.option.handlingDialog.chatId)) {
	          return false;
	        }
	        if (typeof params.dialogId !== 'undefined' && params.dialogId.toString() === this.option.handlingDialog.dialogId.toString()) {
	          return false;
	        }
	        return true;
	      }
	      return false;
	    }
	  }, {
	    key: "handleMessage",
	    value: function handleMessage(params, extra) {
	      this.handleMessageAdd(params, extra);
	    }
	  }, {
	    key: "handleMessageChat",
	    value: function handleMessageChat(params, extra) {
	      this.handleMessageAdd(params, extra);
	    }
	  }, {
	    key: "handleMessageAdd",
	    value: function handleMessageAdd(params, extra) {
	      var _this = this;
	      im_lib_logger.Logger.warn('handleMessageAdd', params);
	      if (this.skipExecute(params, extra)) {
	        return false;
	      }
	      var collection = this.store.state.messages.collection[params.chatId];
	      if (!collection) {
	        collection = [];
	      }

	      //search for message with message id from params
	      var message = collection.find(function (element) {
	        if (params.message.templateId && element.id === params.message.templateId) {
	          return true;
	        }
	        return element.id === params.message.id;
	      });

	      //stop if it's message with 'push' (pseudo push message in mobile)
	      if (message && params.message.push) {
	        return false;
	      }
	      if (params.chat && params.chat[params.chatId]) {
	        var existingChat = this.store.getters['dialogues/getByChatId'](params.chatId);
	        //add new chat if there is no one
	        if (!existingChat) {
	          var chatToAdd = Object.assign({}, params.chat[params.chatId], {
	            dialogId: params.dialogId
	          });
	          this.store.dispatch('dialogues/set', chatToAdd);
	        }
	        //otherwise - update it
	        else {
	          this.store.dispatch('dialogues/update', {
	            dialogId: params.dialogId,
	            fields: params.chat[params.chatId]
	          });
	        }
	      }

	      //set users
	      if (params.users) {
	        this.store.dispatch('users/set', ui_vue_vuex.WidgetVuexBuilderModel.convertToArray(params.users));
	      }

	      //set files
	      if (params.files) {
	        var files = this.controller.application.prepareFilesBeforeSave(ui_vue_vuex.WidgetVuexBuilderModel.convertToArray(params.files));
	        files.forEach(function (file) {
	          if (files.length === 1 && params.message.templateFileId && _this.store.state.files.index[params.chatId] && _this.store.state.files.index[params.chatId][params.message.templateFileId]) {
	            _this.store.dispatch('files/update', {
	              id: params.message.templateFileId,
	              chatId: params.chatId,
	              fields: file
	            }).then(function () {
	              main_core_events.EventEmitter.emit(im_const.EventType.dialog.scrollToBottom, {
	                chatId: params.chatId,
	                cancelIfScrollChange: true
	              });
	            });
	          } else {
	            _this.store.dispatch('files/set', file);
	          }
	        });
	      }

	      //if we already have message - update it and scrollToBottom
	      if (message) {
	        im_lib_logger.Logger.warn('New message pull handler: we already have this message', params.message);
	        this.store.dispatch('messages/update', {
	          id: message.id,
	          chatId: message.chatId,
	          fields: _objectSpread(_objectSpread({}, params.message), {}, {
	            sending: false,
	            error: false
	          })
	        }).then(function () {
	          if (!params.message.push) {
	            main_core_events.EventEmitter.emit(im_const.EventType.dialog.scrollToBottom, {
	              chatId: message.chatId,
	              cancelIfScrollChange: params.message.senderId !== _this.controller.application.getUserId()
	            });
	          }
	        });
	      }
	      //if we dont have message and we have all pages - add new message and send newMessage event (handles scroll stuff)
	      //we dont do anything if we dont have message and there are unloaded messages
	      else if (this.controller.application.isUnreadMessagesLoaded()) {
	        im_lib_logger.Logger.warn('New message pull handler: we dont have this message', params.message);
	        this.store.dispatch('messages/setAfter', _objectSpread(_objectSpread({}, params.message), {}, {
	          unread: true
	        })).then(function () {
	          if (!params.message.push) {
	            main_core_events.EventEmitter.emit(im_const.EventType.dialog.newMessage, {
	              chatId: params.message.chatId,
	              messageId: params.message.id
	            });
	          }
	        });
	      }

	      //stop writing event
	      this.controller.application.stopOpponentWriting({
	        dialogId: params.dialogId,
	        userId: params.message.senderId
	      });

	      // if we sent message - read all messages on server and client, set counter to 0
	      if (params.message.senderId === this.controller.application.getUserId()) {
	        if (this.store.state.dialogues.collection[params.dialogId] && this.store.state.dialogues.collection[params.dialogId].counter !== 0) {
	          this.controller.restClient.callMethod('im.dialog.read', {
	            dialog_id: params.dialogId
	          }).then(function () {
	            _this.store.dispatch('messages/readMessages', {
	              chatId: params.chatId
	            }).then(function (result) {
	              main_core_events.EventEmitter.emit(im_const.EventType.dialog.scrollToBottom, {
	                chatId: params.chatId,
	                cancelIfScrollChange: false
	              });
	              _this.store.dispatch('dialogues/update', {
	                dialogId: params.dialogId,
	                fields: {
	                  counter: 0
	                }
	              });
	            });
	          });
	        }
	      }
	      //increase the counter if message is not ours
	      else if (params.message.senderId !== this.controller.application.getUserId()) {
	        this.store.dispatch('dialogues/increaseCounter', {
	          dialogId: params.dialogId,
	          count: 1
	        });
	      }

	      //set new lastMessageId (used for pagination)
	      this.store.dispatch('dialogues/update', {
	        dialogId: params.dialogId,
	        fields: {
	          lastMessageId: params.message.id
	        }
	      });

	      //increase total message count
	      this.store.dispatch('dialogues/increaseMessageCounter', {
	        dialogId: params.dialogId,
	        count: 1
	      });
	    }
	  }, {
	    key: "handleMessageUpdate",
	    value: function handleMessageUpdate(params, extra, command) {
	      this.execMessageUpdateOrDelete(params, extra, command);
	    }
	  }, {
	    key: "handleMessageDelete",
	    value: function handleMessageDelete(params, extra, command) {
	      this.execMessageUpdateOrDelete(params, extra, command);
	    }
	  }, {
	    key: "execMessageUpdateOrDelete",
	    value: function execMessageUpdateOrDelete(params, extra, command) {
	      if (this.skipExecute(params, extra)) {
	        return false;
	      }
	      this.controller.application.stopOpponentWriting({
	        dialogId: params.dialogId,
	        userId: params.senderId
	      });
	      var fields = {
	        params: params.params,
	        blink: true
	      };
	      if (command === "messageUpdate") {
	        if (typeof params.textLegacy !== 'undefined') {
	          fields.textLegacy = params.textLegacy;
	        }
	        if (typeof params.text !== 'undefined') {
	          fields.text = params.text;
	        }
	      }
	      this.store.dispatch('messages/update', {
	        id: params.id,
	        chatId: params.chatId,
	        fields: fields
	      }).then(function () {
	        main_core_events.EventEmitter.emit(im_const.EventType.dialog.scrollToBottom, {
	          chatId: params.chatId,
	          cancelIfScrollChange: true
	        });
	      });
	    }
	  }, {
	    key: "handleMessageDeleteComplete",
	    value: function handleMessageDeleteComplete(params, extra) {
	      if (this.skipExecute(params, extra)) {
	        return false;
	      }
	      this.store.dispatch('messages/delete', {
	        id: params.id,
	        chatId: params.chatId
	      });
	      this.controller.application.stopOpponentWriting({
	        dialogId: params.dialogId,
	        userId: params.senderId,
	        action: false
	      });
	    }
	  }, {
	    key: "handleMessageLike",
	    value: function handleMessageLike(params, extra) {
	      if (this.skipExecute(params, extra)) {
	        return false;
	      }
	      this.store.dispatch('messages/update', {
	        id: params.id,
	        chatId: params.chatId,
	        fields: {
	          params: {
	            LIKE: params.users
	          }
	        }
	      });
	    }
	  }, {
	    key: "handleChatOwner",
	    value: function handleChatOwner(params, extra) {
	      if (this.skipExecute(params, extra)) {
	        return false;
	      }
	      this.store.dispatch('dialogues/update', {
	        dialogId: params.dialogId,
	        fields: {
	          ownerId: params.userId
	        }
	      });
	    }
	  }, {
	    key: "handleChatManagers",
	    value: function handleChatManagers(params, extra) {
	      if (this.skipExecute(params, extra)) {
	        return false;
	      }
	      this.store.dispatch('dialogues/update', {
	        dialogId: params.dialogId,
	        fields: {
	          managerList: params.list
	        }
	      });
	    }
	  }, {
	    key: "handleChatUpdateParams",
	    value: function handleChatUpdateParams(params, extra) {
	      if (this.skipExecute(params, extra)) {
	        return false;
	      }
	      this.store.dispatch('dialogues/update', {
	        dialogId: params.dialogId,
	        fields: params.params
	      });
	    }
	  }, {
	    key: "handleChatUserAdd",
	    value: function handleChatUserAdd(params, extra) {
	      if (this.skipExecute(params, extra)) {
	        return false;
	      }
	      this.store.dispatch('dialogues/update', {
	        dialogId: params.dialogId,
	        fields: {
	          userCounter: params.userCount
	        }
	      });
	    }
	  }, {
	    key: "handleChatUserLeave",
	    value: function handleChatUserLeave(params, extra) {
	      if (this.skipExecute(params, extra)) {
	        return false;
	      }
	      this.store.dispatch('dialogues/update', {
	        dialogId: params.dialogId,
	        fields: {
	          userCounter: params.userCount
	        }
	      });
	    }
	  }, {
	    key: "handleMessageParamsUpdate",
	    value: function handleMessageParamsUpdate(params, extra) {
	      if (this.skipExecute(params, extra)) {
	        return false;
	      }
	      this.store.dispatch('messages/update', {
	        id: params.id,
	        chatId: params.chatId,
	        fields: {
	          params: params.params
	        }
	      }).then(function () {
	        main_core_events.EventEmitter.emit(im_const.EventType.dialog.scrollToBottom, {
	          chatId: params.chatId,
	          cancelIfScrollChange: true
	        });
	      });
	    }
	  }, {
	    key: "handleStartWriting",
	    value: function handleStartWriting(params, extra) {
	      if (this.skipExecute(params, extra)) {
	        return false;
	      }
	      this.controller.application.startOpponentWriting(params);
	    }
	  }, {
	    key: "handleReadMessage",
	    value: function handleReadMessage(params, extra) {
	      var _this2 = this;
	      if (this.skipExecute(params, extra)) {
	        return false;
	      }
	      this.store.dispatch('messages/readMessages', {
	        chatId: params.chatId,
	        readId: params.lastId
	      }).then(function (result) {
	        _this2.store.dispatch('dialogues/update', {
	          dialogId: params.dialogId,
	          fields: {
	            counter: params.counter
	          }
	        });
	      });
	    }
	  }, {
	    key: "handleReadMessageChat",
	    value: function handleReadMessageChat(params, extra) {
	      this.handleReadMessage(params, extra);
	    }
	  }, {
	    key: "handleReadMessageOpponent",
	    value: function handleReadMessageOpponent(params, extra) {
	      this.execReadMessageOpponent(params, extra);
	    }
	  }, {
	    key: "handleReadMessageChatOpponent",
	    value: function handleReadMessageChatOpponent(params, extra) {
	      this.execReadMessageOpponent(params, extra);
	    }
	  }, {
	    key: "execReadMessageOpponent",
	    value: function execReadMessageOpponent(params, extra) {
	      if (this.skipExecute(params, extra)) {
	        return false;
	      }
	      this.store.dispatch('dialogues/updateReaded', {
	        dialogId: params.dialogId,
	        userId: params.userId,
	        userName: params.userName,
	        messageId: params.lastId,
	        date: params.date,
	        action: true
	      });
	    }
	  }, {
	    key: "handleUnreadMessageOpponent",
	    value: function handleUnreadMessageOpponent(params, extra) {
	      this.execUnreadMessageOpponent(params, extra);
	    }
	  }, {
	    key: "handleUnreadMessageChatOpponent",
	    value: function handleUnreadMessageChatOpponent(params, extra) {
	      this.execUnreadMessageOpponent(params, extra);
	    }
	  }, {
	    key: "execUnreadMessageOpponent",
	    value: function execUnreadMessageOpponent(params, extra) {
	      if (this.skipExecute(params, extra)) {
	        return false;
	      }
	      this.store.dispatch('dialogues/updateReaded', {
	        dialogId: params.dialogId,
	        userId: params.userId,
	        action: false
	      });
	    }
	  }, {
	    key: "handleFileUpload",
	    value: function handleFileUpload(params, extra) {
	      if (this.skipExecute(params, extra)) {
	        return false;
	      }
	      this.store.dispatch('files/set', this.controller.application.prepareFilesBeforeSave(ui_vue_vuex.WidgetVuexBuilderModel.convertToArray({
	        file: params.fileParams
	      }))).then(function () {
	        main_core_events.EventEmitter.emit(im_const.EventType.dialog.scrollToBottom, {
	          cancelIfScrollChange: true
	        });
	      });
	    }
	  }, {
	    key: "handleChatMuteNotify",
	    value: function handleChatMuteNotify(params, extra) {
	      var existingChat = this.store.getters['dialogues/get'](params.dialogId);
	      if (!existingChat) {
	        return false;
	      }
	      var existingMuteList = existingChat.muteList;
	      var newMuteList = [];
	      var currentUser = this.store.state.application.common.userId;
	      if (params.mute) {
	        newMuteList = [].concat(babelHelpers.toConsumableArray(existingMuteList), [currentUser]);
	      } else {
	        newMuteList = existingMuteList.filter(function (element) {
	          return element !== currentUser;
	        });
	      }
	      this.store.dispatch('dialogues/update', {
	        dialogId: params.dialogId,
	        fields: {
	          muteList: newMuteList
	        }
	      });
	    }
	  }, {
	    key: "handleUserInvite",
	    value: function handleUserInvite(params, extra) {
	      if (!params.invited) {
	        this.store.dispatch('users/update', {
	          id: params.userId,
	          fields: params.user
	        });
	      }
	    }
	  }]);
	  return ImBasePullHandler;
	}();

	function ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
	function _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$1(Object(source), !0).forEach(function (key) { babelHelpers.defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
	var ImCallPullHandler = /*#__PURE__*/function () {
	  babelHelpers.createClass(ImCallPullHandler, null, [{
	    key: "create",
	    value: function create() {
	      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	      return new this(params);
	    }
	  }]);
	  function ImCallPullHandler() {
	    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	    babelHelpers.classCallCheck(this, ImCallPullHandler);
	    if (babelHelpers["typeof"](params.application) === 'object' && params.application) {
	      this.application = params.application;
	    }
	    if (babelHelpers["typeof"](params.controller) === 'object' && params.controller) {
	      this.controller = params.controller;
	    }
	    if (babelHelpers["typeof"](params.store) === 'object' && params.store) {
	      this.store = params.store;
	    }
	    this.option = babelHelpers["typeof"](params.store) === 'object' && params.store ? params.store : {};
	  }
	  babelHelpers.createClass(ImCallPullHandler, [{
	    key: "getModuleId",
	    value: function getModuleId() {
	      return 'im';
	    }
	  }, {
	    key: "getSubscriptionType",
	    value: function getSubscriptionType() {
	      return pull_client.PullClient.SubscriptionType.Server;
	    }
	  }, {
	    key: "handleChatUserAdd",
	    value: function handleChatUserAdd(params) {
	      if (params.dialogId !== this.store.state.application.dialog.dialogId) {
	        return false;
	      }
	      var users = Object.values(params.users).map(function (user) {
	        return _objectSpread$1(_objectSpread$1({}, user), {}, {
	          lastActivityDate: new Date()
	        });
	      });
	      this.store.commit('conference/common', {
	        userCount: params.userCount
	      });
	      this.store.dispatch('users/set', users);
	      this.store.dispatch('conference/setUsers', {
	        users: users.map(function (user) {
	          return user.id;
	        })
	      });
	    }
	  }, {
	    key: "handleChatUserLeave",
	    value: function handleChatUserLeave(params) {
	      if (params.dialogId !== this.store.state.application.dialog.dialogId) {
	        return false;
	      }
	      if (params.userId === this.controller.getUserId()) {
	        this.application.kickFromCall();
	      }
	      this.store.commit('conference/common', {
	        userCount: params.userCount
	      });
	      this.store.dispatch('conference/removeUsers', {
	        users: [params.userId]
	      });
	    }
	  }, {
	    key: "handleCallUserNameUpdate",
	    value: function handleCallUserNameUpdate(params) {
	      var currentUser = this.store.getters['users/get'](params.userId);
	      if (!currentUser) {
	        this.store.dispatch('users/set', {
	          id: params.userId,
	          lastActivityDate: new Date()
	        });
	      }
	      this.store.dispatch('users/update', {
	        id: params.userId,
	        fields: {
	          name: params.name,
	          lastActivityDate: new Date()
	        }
	      });
	    }
	  }, {
	    key: "handleVideoconfShareUpdate",
	    value: function handleVideoconfShareUpdate(params) {
	      if (params.dialogId === this.store.state.application.dialog.dialogId) {
	        this.store.dispatch('dialogues/update', {
	          dialogId: params.dialogId,
	          fields: {
	            "public": {
	              code: params.newCode,
	              link: params.newLink
	            }
	          }
	        });
	        this.application.changeVideoconfUrl(params.newLink);
	      }
	    }
	  }, {
	    key: "handleMessageChat",
	    value: function handleMessageChat(params) {
	      this.application.sendNewMessageNotify(params);
	    }
	  }, {
	    key: "handleChatRename",
	    value: function handleChatRename(params) {
	      if (params.chatId !== this.application.getChatId()) {
	        return false;
	      }
	      this.store.dispatch('conference/setConferenceTitle', {
	        conferenceTitle: params.name
	      });
	    }
	  }, {
	    key: "handleConferenceUpdate",
	    value: function handleConferenceUpdate(params) {
	      if (params.chatId !== this.application.getChatId()) {
	        return false;
	      }
	      if (params.isBroadcast !== '') {
	        this.store.dispatch('conference/setBroadcastMode', {
	          broadcastMode: params.isBroadcast
	        });
	      }
	      if (params.presenters.length > 0) {
	        this.store.dispatch('conference/setPresenters', {
	          presenters: params.presenters,
	          replace: true
	        });
	      }
	    }
	  }]);
	  return ImCallPullHandler;
	}();

	function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }
	function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
	function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
	var ImNotificationsPullHandler = /*#__PURE__*/function () {
	  babelHelpers.createClass(ImNotificationsPullHandler, null, [{
	    key: "create",
	    value: function create() {
	      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	      return new this(params);
	    }
	  }]);
	  function ImNotificationsPullHandler() {
	    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	    babelHelpers.classCallCheck(this, ImNotificationsPullHandler);
	    if (babelHelpers["typeof"](params.application) === 'object' && params.application) {
	      this.application = params.application;
	    }
	    if (babelHelpers["typeof"](params.controller) === 'object' && params.controller) {
	      this.controller = params.controller;
	    }
	    if (babelHelpers["typeof"](params.store) === 'object' && params.store) {
	      this.store = params.store;
	    }
	    this.option = babelHelpers["typeof"](params.store) === 'object' && params.store ? params.store : {};
	  }
	  babelHelpers.createClass(ImNotificationsPullHandler, [{
	    key: "getModuleId",
	    value: function getModuleId() {
	      return 'im';
	    }
	  }, {
	    key: "getSubscriptionType",
	    value: function getSubscriptionType() {
	      return pull_client.PullClient.SubscriptionType.Server;
	    }
	  }, {
	    key: "handleNotifyAdd",
	    value: function handleNotifyAdd(params, extra) {
	      if (extra.server_time_ago > 30 || params.onlyFlash === true) {
	        return false;
	      }
	      var user = this.store.getters['users/get'](params.userId);
	      if (!user) {
	        var users = [];
	        users.push({
	          id: params.userId,
	          avatar: params.userAvatar,
	          color: params.userColor,
	          name: params.userName
	        });
	        this.store.dispatch('users/set', users);
	      }
	      this.store.dispatch('notifications/add', {
	        data: params
	      });
	      this.store.dispatch('notifications/setCounter', {
	        unreadTotal: params.counter
	      });
	      this.store.dispatch('recent/update', {
	        id: "notify",
	        fields: {
	          message: {
	            id: params.id,
	            text: params.text,
	            date: params.date
	          },
	          counter: params.counter
	        }
	      });
	    }
	  }, {
	    key: "handleNotifyReadAll",
	    value: function handleNotifyReadAll(params) {
	      this.store.dispatch('notifications/readAll');
	      this.store.dispatch('notifications/setCounter', {
	        unreadTotal: 0
	      });
	      this.store.dispatch('recent/update', {
	        id: 'notify',
	        fields: {
	          counter: 0
	        }
	      });
	    }
	  }, {
	    key: "handleNotifyConfirm",
	    value: function handleNotifyConfirm(params, extra) {
	      if (extra.server_time_ago > 30) {
	        return false;
	      }
	      this.store.dispatch('notifications/delete', {
	        id: params.id
	      });
	      this.store.dispatch('notifications/setCounter', {
	        unreadTotal: params.counter
	      });
	      this.updateRecentListOnDelete(params.counter);
	    }
	  }, {
	    key: "handleNotifyRead",
	    value: function handleNotifyRead(params, extra) {
	      var _this = this;
	      if (extra.server_time_ago > 30) {
	        return false;
	      }
	      params.list.forEach(function (id) {
	        _this.store.dispatch('notifications/read', {
	          ids: [id],
	          action: true
	        });
	      });
	      this.store.dispatch('notifications/setCounter', {
	        unreadTotal: params.counter
	      });
	      this.store.dispatch('recent/update', {
	        id: "notify",
	        fields: {
	          counter: params.counter
	        }
	      });
	    }
	  }, {
	    key: "handleNotifyUnread",
	    value: function handleNotifyUnread(params, extra) {
	      var _this2 = this;
	      if (extra.server_time_ago > 30) {
	        return false;
	      }
	      params.list.forEach(function (id) {
	        _this2.store.dispatch('notifications/read', {
	          ids: [id],
	          action: false
	        });
	      });
	      this.store.dispatch('notifications/setCounter', {
	        unreadTotal: params.counter
	      });
	      this.store.dispatch('recent/update', {
	        id: "notify",
	        fields: {
	          counter: params.counter
	        }
	      });
	    }
	  }, {
	    key: "handleNotifyDelete",
	    value: function handleNotifyDelete(params, extra) {
	      var _this3 = this;
	      if (extra.server_time_ago > 30) {
	        return false;
	      }
	      var idsToDelete = Object.keys(params.id).map(function (id) {
	        return parseInt(id, 10);
	      });
	      idsToDelete.forEach(function (id) {
	        _this3.store.dispatch('notifications/delete', {
	          id: id
	        });
	      });
	      this.updateRecentListOnDelete(params.counter);
	      this.store.dispatch('notifications/setCounter', {
	        unreadTotal: params.counter
	      });
	    }
	  }, {
	    key: "updateRecentListOnDelete",
	    value: function updateRecentListOnDelete(counterValue) {
	      var message;
	      var latestNotification = this.getLatest();
	      if (latestNotification !== null) {
	        message = {
	          id: latestNotification.id,
	          text: latestNotification.text,
	          date: latestNotification.date
	        };
	      } else {
	        var notificationChat = this.store.getters['recent/get']('notify');
	        if (notificationChat === false) {
	          return;
	        }
	        message = notificationChat.element.message;
	        message.text = this.controller.localize['IM_NOTIFICATIONS_DELETED_ITEM_STUB'];
	      }
	      this.store.dispatch('recent/update', {
	        id: "notify",
	        fields: {
	          message: message,
	          counter: counterValue
	        }
	      });
	    }
	  }, {
	    key: "getLatest",
	    value: function getLatest() {
	      var latestNotification = {
	        id: 0
	      };
	      var _iterator = _createForOfIteratorHelper(this.store.state.notifications.collection),
	        _step;
	      try {
	        for (_iterator.s(); !(_step = _iterator.n()).done;) {
	          var notification = _step.value;
	          if (notification.id > latestNotification.id) {
	            latestNotification = notification;
	          }
	        }
	      } catch (err) {
	        _iterator.e(err);
	      } finally {
	        _iterator.f();
	      }
	      if (latestNotification.id === 0) {
	        return null;
	      }
	      return latestNotification;
	    }
	  }]);
	  return ImNotificationsPullHandler;
	}();

	/**
	 * Bitrix Messenger
	 * Bundle pull command handlers
	 *
	 * @package bitrix
	 * @subpackage im
	 * @copyright 2001-2019 Bitrix
	 */

	exports.ImBasePullHandler = ImBasePullHandler;
	exports.ImCallPullHandler = ImCallPullHandler;
	exports.ImNotificationsPullHandler = ImNotificationsPullHandler;

}((this.BX.Messenger.Provider.Pull = this.BX.Messenger.Provider.Pull || {}),BX,BX.Messenger.Const,BX.Messenger.Lib,BX.Event,BX));





// file: /bitrix/js/im/lib/timer/dist/timer.bundle.js
this.BX = this.BX || {};
this.BX.Messenger = this.BX.Messenger || {};
(function (exports) {
	'use strict';

	/**
	 * Bitrix Messenger
	 * Timer manager
	 *
	 * @package bitrix
	 * @subpackage im
	 * @copyright 2001-2019 Bitrix
	 */
	var Timer = /*#__PURE__*/function () {
	  function Timer() {
	    babelHelpers.classCallCheck(this, Timer);
	    this.list = {};
	    this.updateInterval = 1000;
	    clearInterval(this.updateIntervalId);
	    this.updateIntervalId = setInterval(this.worker.bind(this), this.updateInterval);
	  }
	  babelHelpers.createClass(Timer, [{
	    key: "start",
	    value: function start(name) {
	      var id = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'default';
	      var time = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
	      var callback = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
	      var callbackParams = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};
	      id = id == null ? 'default' : id;
	      time = parseFloat(time);
	      if (isNaN(time) || time <= 0) {
	        return false;
	      }
	      time = time * 1000;
	      if (typeof this.list[name] === 'undefined') {
	        this.list[name] = {};
	      }
	      this.list[name][id] = {
	        'dateStop': new Date().getTime() + time,
	        'callback': typeof callback === 'function' ? callback : function () {},
	        'callbackParams': callbackParams
	      };
	      return true;
	    }
	  }, {
	    key: "has",
	    value: function has(name) {
	      var id = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'default';
	      id = id == null ? 'default' : id;
	      if (id.toString().length <= 0 || typeof this.list[name] === 'undefined') {
	        return false;
	      }
	      return !!this.list[name][id];
	    }
	  }, {
	    key: "stop",
	    value: function stop(name) {
	      var id = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'default';
	      var skipCallback = arguments.length > 2 ? arguments[2] : undefined;
	      id = id == null ? 'default' : id;
	      if (id.toString().length <= 0 || typeof this.list[name] === 'undefined') {
	        return false;
	      }
	      if (!this.list[name][id]) {
	        return true;
	      }
	      if (skipCallback !== true) {
	        this.list[name][id]['callback'](id, this.list[name][id]['callbackParams']);
	      }
	      delete this.list[name][id];
	      return true;
	    }
	  }, {
	    key: "stopAll",
	    value: function stopAll(skipCallback) {
	      for (var name in this.list) {
	        if (this.list.hasOwnProperty(name)) {
	          for (var id in this.list[name]) {
	            if (this.list[name].hasOwnProperty(id)) {
	              this.stop(name, id, skipCallback);
	            }
	          }
	        }
	      }
	      return true;
	    }
	  }, {
	    key: "worker",
	    value: function worker() {
	      for (var name in this.list) {
	        if (!this.list.hasOwnProperty(name)) {
	          continue;
	        }
	        for (var id in this.list[name]) {
	          if (!this.list[name].hasOwnProperty(id) || this.list[name][id]['dateStop'] > new Date()) {
	            continue;
	          }
	          this.stop(name, id);
	        }
	      }
	      return true;
	    }
	  }, {
	    key: "clean",
	    value: function clean() {
	      clearInterval(this.updateIntervalId);
	      this.stopAll(true);
	      return true;
	    }
	  }]);
	  return Timer;
	}();

	exports.Timer = Timer;

}((this.BX.Messenger.Lib = this.BX.Messenger.Lib || {})));





// file: /bitrix/js/im/controller/dist/controller.bundle.js
this.BX = this.BX || {};
(function (exports,pull_client,rest_client,ui_vue_vuex,im_model,im_provider_pull,im_provider_rest,im_lib_timer,im_const,im_lib_utils,ui_vue,im_lib_logger) {
	'use strict';

	/**
	 * Bitrix Messenger
	 * Application controller
	 *
	 * @package bitrix
	 * @subpackage im
	 * @copyright 2001-2020 Bitrix
	 */
	var ApplicationController = /*#__PURE__*/function () {
	  function ApplicationController() {
	    babelHelpers.classCallCheck(this, ApplicationController);
	    this.controller = null;
	    this.timer = new im_lib_timer.Timer();
	    this._prepareFilesBeforeSave = function (params) {
	      return params;
	    };
	    this.defaultMessageLimit = 50;
	    this.requestMessageLimit = this.getDefaultMessageLimit();
	    this.messageLastReadId = {};
	    this.messageReadQueue = {};
	  }
	  babelHelpers.createClass(ApplicationController, [{
	    key: "setCoreController",
	    value: function setCoreController(controller) {
	      this.controller = controller;
	    }
	  }, {
	    key: "getSiteId",
	    value: function getSiteId() {
	      return this.controller.getStore().state.application.common.siteId;
	    }
	  }, {
	    key: "getUserId",
	    value: function getUserId() {
	      return this.controller.getStore().state.application.common.userId;
	    }
	  }, {
	    key: "getLanguageId",
	    value: function getLanguageId() {
	      return this.controller.getStore().state.application.common.languageId;
	    }
	  }, {
	    key: "getCurrentUser",
	    value: function getCurrentUser() {
	      return this.controller.getStore().getters['users/get'](this.controller.getStore().state.application.common.userId, true);
	    }
	  }, {
	    key: "getChatId",
	    value: function getChatId() {
	      return this.controller.getStore().state.application.dialog.chatId;
	    }
	  }, {
	    key: "getDialogId",
	    value: function getDialogId() {
	      return this.controller.getStore().state.application.dialog.dialogId;
	    }
	  }, {
	    key: "getData",
	    value: function getData() {
	      return this.controller.getStore().state.application;
	    }
	  }, {
	    key: "getDialogData",
	    value: function getDialogData() {
	      var dialogId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getDialogId();
	      if (this.controller.getStore().state.dialogues.collection[dialogId]) {
	        return this.controller.getStore().state.dialogues.collection[dialogId];
	      }
	      return this.controller.getStore().getters['dialogues/getBlank']();
	    }
	  }, {
	    key: "getDialogCrmData",
	    value: function getDialogCrmData() {
	      var dialogId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getDialogId();
	      var result = {
	        enabled: false,
	        entityType: im_const.DialogCrmType.none,
	        entityId: 0
	      };
	      var dialogData = this.getDialogData(dialogId);
	      if (dialogData.type === im_const.DialogType.call) {
	        if (dialogData.entityData1 && typeof dialogData.entityData1 === 'string') {
	          var _dialogData$entityDat = dialogData.entityData1.split('|'),
	            _dialogData$entityDat2 = babelHelpers.slicedToArray(_dialogData$entityDat, 3),
	            enabled = _dialogData$entityDat2[0],
	            entityType = _dialogData$entityDat2[1],
	            entityId = _dialogData$entityDat2[2];
	          if (enabled) {
	            entityType = entityType ? entityType.toString().toLowerCase() : im_const.DialogCrmType.none;
	            result = {
	              enabled: enabled,
	              entityType: entityType,
	              entityId: entityId
	            };
	          }
	        }
	      } else if (dialogData.type === im_const.DialogType.crm) {
	        var _dialogData$entityId$ = dialogData.entityId.split('|'),
	          _dialogData$entityId$2 = babelHelpers.slicedToArray(_dialogData$entityId$, 2),
	          _entityType = _dialogData$entityId$2[0],
	          _entityId = _dialogData$entityId$2[1];
	        _entityType = _entityType ? _entityType.toString().toLowerCase() : im_const.DialogCrmType.none;
	        result = {
	          enabled: true,
	          entityType: _entityType,
	          entityId: _entityId
	        };
	      }
	      return result;
	    }
	  }, {
	    key: "getDialogIdByChatId",
	    value: function getDialogIdByChatId(chatId) {
	      if (this.getDialogId() === 'chat' + chatId) {
	        return this.getDialogId();
	      }
	      var dialog = this.controller.getStore().getters['dialogues/getByChatId'](chatId);
	      if (!dialog) {
	        return 0;
	      }
	      return dialog.dialogId;
	    }
	  }, {
	    key: "getDiskFolderId",
	    value: function getDiskFolderId() {
	      return this.controller.getStore().state.application.dialog.diskFolderId;
	    }
	  }, {
	    key: "getDefaultMessageLimit",
	    value: function getDefaultMessageLimit() {
	      return this.defaultMessageLimit;
	    }
	  }, {
	    key: "getRequestMessageLimit",
	    value: function getRequestMessageLimit() {
	      return this.requestMessageLimit;
	    }
	  }, {
	    key: "muteDialog",
	    value: function muteDialog() {
	      var _this = this;
	      var action = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
	      var dialogId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.getDialogId();
	      if (im_lib_utils.Utils.dialog.isEmptyDialogId(dialogId)) {
	        return false;
	      }
	      if (action === null) {
	        action = !this.isDialogMuted();
	      }
	      this.timer.start('muteDialog', dialogId, .3, function (id) {
	        _this.controller.restClient.callMethod(im_const.RestMethod.imChatMute, {
	          'DIALOG_ID': dialogId,
	          'ACTION': action ? 'Y' : 'N'
	        });
	      });
	      var muteList = [];
	      if (action) {
	        muteList = this.getDialogData().muteList;
	        muteList.push(this.getUserId());
	      } else {
	        muteList = this.getDialogData().muteList.filter(function (userId) {
	          return userId !== _this.getUserId();
	        });
	      }
	      this.controller.getStore().dispatch('dialogues/update', {
	        dialogId: dialogId,
	        fields: {
	          muteList: muteList
	        }
	      });
	      return true;
	    }
	  }, {
	    key: "isDialogMuted",
	    value: function isDialogMuted() {
	      var dialogId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getDialogId();
	      return this.getDialogData().muteList.includes(this.getUserId());
	    }
	  }, {
	    key: "isUnreadMessagesLoaded",
	    value: function isUnreadMessagesLoaded() {
	      var dialog = this.controller.getStore().state.dialogues.collection[this.getDialogId()];
	      if (!dialog) {
	        return true;
	      }
	      if (dialog.lastMessageId <= 0) {
	        return true;
	      }
	      var collection = this.controller.getStore().state.messages.collection[this.getChatId()];
	      if (!collection || collection.length <= 0) {
	        return true;
	      }
	      var lastElementId = 0;
	      for (var index = collection.length - 1; index >= 0; index--) {
	        var lastElement = collection[index];
	        if (typeof lastElement.id === "number") {
	          lastElementId = lastElement.id;
	          break;
	        }
	      }
	      return lastElementId >= dialog.lastMessageId;
	    }
	  }, {
	    key: "prepareFilesBeforeSave",
	    value: function prepareFilesBeforeSave(files) {
	      return this._prepareFilesBeforeSave(files);
	    }
	  }, {
	    key: "setPrepareFilesBeforeSaveFunction",
	    value: function setPrepareFilesBeforeSaveFunction(func) {
	      this._prepareFilesBeforeSave = func.bind(this);
	    }
	  }, {
	    key: "showSmiles",
	    value: function showSmiles() {
	      this.store.dispatch('application/showSmiles');
	    }
	  }, {
	    key: "hideSmiles",
	    value: function hideSmiles() {
	      this.store.dispatch('application/hideSmiles');
	    }
	  }, {
	    key: "startOpponentWriting",
	    value: function startOpponentWriting(params) {
	      var _this2 = this;
	      var dialogId = params.dialogId,
	        userId = params.userId,
	        userName = params.userName;
	      this.controller.getStore().dispatch('dialogues/updateWriting', {
	        dialogId: dialogId,
	        userId: userId,
	        userName: userName,
	        action: true
	      });
	      this.timer.start('writingEnd', dialogId + '|' + userId, 35, function (id, params) {
	        var dialogId = params.dialogId,
	          userId = params.userId;
	        _this2.controller.getStore().dispatch('dialogues/updateWriting', {
	          dialogId: dialogId,
	          userId: userId,
	          action: false
	        });
	      }, {
	        dialogId: dialogId,
	        userId: userId
	      });
	      return true;
	    }
	  }, {
	    key: "stopOpponentWriting",
	    value: function stopOpponentWriting() {
	      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	      var dialogId = params.dialogId,
	        userId = params.userId,
	        userName = params.userName;
	      this.timer.stop('writingStart', dialogId + '|' + userId, true);
	      this.timer.stop('writingEnd', dialogId + '|' + userId);
	      return true;
	    }
	  }, {
	    key: "startWriting",
	    value: function startWriting() {
	      var _this3 = this;
	      var dialogId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getDialogId();
	      if (im_lib_utils.Utils.dialog.isEmptyDialogId(dialogId) || this.timer.has('writes', dialogId)) {
	        return false;
	      }
	      this.timer.start('writes', dialogId, 28);
	      this.timer.start('writesSend', dialogId, 5, function (id) {
	        _this3.controller.restClient.callMethod(im_const.RestMethod.imDialogWriting, {
	          'DIALOG_ID': dialogId
	        })["catch"](function () {
	          _this3.timer.stop('writes', dialogId);
	        });
	      });
	    }
	  }, {
	    key: "stopWriting",
	    value: function stopWriting() {
	      var dialogId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getDialogId();
	      this.timer.stop('writes', dialogId, true);
	      this.timer.stop('writesSend', dialogId, true);
	    }
	  }, {
	    key: "joinParentChat",
	    value: function joinParentChat(messageId, dialogId) {
	      var _this4 = this;
	      return new Promise(function (resolve, reject) {
	        if (!messageId || !dialogId) {
	          return reject();
	        }
	        if (typeof _this4.tempJoinChat === 'undefined') {
	          _this4.tempJoinChat = {};
	        } else if (_this4.tempJoinChat['wait']) {
	          return reject();
	        }
	        _this4.tempJoinChat['wait'] = true;
	        _this4.controller.restClient.callMethod(im_const.RestMethod.imChatParentJoin, {
	          'DIALOG_ID': dialogId,
	          'MESSAGE_ID': messageId
	        }).then(function () {
	          _this4.tempJoinChat['wait'] = false;
	          _this4.tempJoinChat[dialogId] = true;
	          return resolve(dialogId);
	        })["catch"](function () {
	          _this4.tempJoinChat['wait'] = false;
	          return reject();
	        });
	      });
	    }
	  }, {
	    key: "setTextareaMessage",
	    value: function setTextareaMessage(params) {
	      var _params$message = params.message,
	        message = _params$message === void 0 ? '' : _params$message,
	        _params$dialogId = params.dialogId,
	        dialogId = _params$dialogId === void 0 ? this.getDialogId() : _params$dialogId;
	      this.controller.getStore().dispatch('dialogues/update', {
	        dialogId: dialogId,
	        fields: {
	          textareaMessage: message
	        }
	      });
	    }
	  }, {
	    key: "setSendingMessageFlag",
	    value: function setSendingMessageFlag(messageId) {
	      this.controller.getStore().dispatch('messages/actionStart', {
	        id: messageId,
	        chatId: this.getChatId()
	      });
	    }
	  }, {
	    key: "reactMessage",
	    value: function reactMessage(messageId) {
	      var action = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'auto';
	      this.controller.restClient.callMethod(im_const.RestMethod.imMessageLike, {
	        'MESSAGE_ID': messageId,
	        'ACTION': action === 'auto' ? 'auto' : action === 'set' ? 'plus' : 'minus'
	      });
	    }
	  }, {
	    key: "readMessage",
	    value: function readMessage() {
	      var _this5 = this;
	      var messageId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
	      var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
	      var skipAjax = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
	      var chatId = this.getChatId();
	      if (typeof this.messageLastReadId[chatId] === 'undefined') {
	        this.messageLastReadId[chatId] = null;
	      }
	      if (typeof this.messageReadQueue[chatId] === 'undefined') {
	        this.messageReadQueue[chatId] = [];
	      }
	      if (messageId) {
	        this.messageReadQueue[chatId].push(parseInt(messageId));
	      }
	      this.timer.stop('readMessage', chatId, true);
	      this.timer.stop('readMessageServer', chatId, true);
	      if (force) {
	        return this.readMessageExecute(chatId, skipAjax);
	      }
	      return new Promise(function (resolve, reject) {
	        _this5.timer.start('readMessage', chatId, .1, function (chatId, params) {
	          return _this5.readMessageExecute(chatId, skipAjax).then(function (result) {
	            return resolve(result);
	          });
	        });
	      });
	    }
	  }, {
	    key: "readMessageExecute",
	    value: function readMessageExecute(chatId) {
	      var _this6 = this;
	      var skipAjax = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
	      return new Promise(function (resolve, reject) {
	        if (_this6.messageReadQueue[chatId]) {
	          _this6.messageReadQueue[chatId] = _this6.messageReadQueue[chatId].filter(function (elementId) {
	            if (!_this6.messageLastReadId[chatId]) {
	              _this6.messageLastReadId[chatId] = elementId;
	            } else if (_this6.messageLastReadId[chatId] < elementId) {
	              _this6.messageLastReadId[chatId] = elementId;
	            }
	          });
	        }
	        var dialogId = _this6.getDialogIdByChatId(chatId);
	        var lastId = _this6.messageLastReadId[chatId] || 0;
	        if (lastId <= 0) {
	          resolve({
	            dialogId: dialogId,
	            lastId: 0
	          });
	          return true;
	        }
	        _this6.controller.getStore().dispatch('messages/readMessages', {
	          chatId: chatId,
	          readId: lastId
	        }).then(function (result) {
	          _this6.controller.getStore().dispatch('dialogues/decreaseCounter', {
	            dialogId: dialogId,
	            count: result.count
	          });
	          if (_this6.getChatId() === chatId && _this6.controller.getStore().getters['dialogues/canSaveChat']) {
	            var dialog = _this6.controller.getStore().getters['dialogues/get'](dialogId);
	            if (dialog.counter <= 0) {
	              _this6.controller.getStore().commit('application/clearDialogExtraCount');
	            }
	          }
	          if (skipAjax) {
	            resolve({
	              dialogId: dialogId,
	              lastId: lastId
	            });
	          } else {
	            _this6.timer.start('readMessageServer', chatId, .5, function () {
	              _this6.controller.restClient.callMethod(im_const.RestMethod.imDialogRead, {
	                'DIALOG_ID': dialogId,
	                'MESSAGE_ID': lastId
	              }).then(function () {
	                return resolve({
	                  dialogId: dialogId,
	                  lastId: lastId
	                });
	              })["catch"](function () {
	                return resolve({
	                  dialogId: dialogId,
	                  lastId: lastId
	                });
	              });
	            });
	          }
	        })["catch"](function () {
	          resolve();
	        });
	      });
	    }
	  }, {
	    key: "unreadMessage",
	    value: function unreadMessage() {
	      var _this7 = this;
	      var messageId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
	      var skipAjax = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
	      var chatId = this.getChatId();
	      if (typeof this.messageLastReadId[chatId] === 'undefined') {
	        this.messageLastReadId[chatId] = null;
	      }
	      if (typeof this.messageReadQueue[chatId] === 'undefined') {
	        this.messageReadQueue[chatId] = [];
	      }
	      if (messageId) {
	        this.messageReadQueue[chatId] = this.messageReadQueue[chatId].filter(function (id) {
	          return id < messageId;
	        });
	      }
	      this.timer.stop('readMessage', chatId, true);
	      this.timer.stop('readMessageServer', chatId, true);
	      this.messageLastReadId[chatId] = messageId;
	      this.controller.getStore().dispatch('messages/unreadMessages', {
	        chatId: chatId,
	        unreadId: this.messageLastReadId[chatId]
	      }).then(function (result) {
	        var dialogId = _this7.getDialogIdByChatId(chatId);
	        _this7.controller.getStore().dispatch('dialogues/update', {
	          dialogId: dialogId,
	          fields: {
	            unreadId: messageId
	          }
	        });
	        _this7.controller.getStore().dispatch('dialogues/increaseCounter', {
	          dialogId: dialogId,
	          count: result.count
	        });
	        if (!skipAjax) {
	          _this7.controller.restClient.callMethod(im_const.RestMethod.imDialogUnread, {
	            'DIALOG_ID': dialogId,
	            'MESSAGE_ID': _this7.messageLastReadId[chatId]
	          });
	        }
	      })["catch"](function () {});
	    }
	  }, {
	    key: "shareMessage",
	    value: function shareMessage(messageId, type) {
	      this.controller.restClient.callMethod(im_const.RestMethod.imMessageShare, {
	        'DIALOG_ID': this.getDialogId(),
	        'MESSAGE_ID': messageId,
	        'TYPE': type
	      });
	      return true;
	    }
	  }, {
	    key: "replyToUser",
	    value: function replyToUser(userId, user) {
	      return true;
	    }
	  }, {
	    key: "openMessageReactionList",
	    value: function openMessageReactionList(messageId, values) {
	      return true;
	    }
	  }, {
	    key: "emit",
	    value: function emit(eventName) {
	      var _Vue$event;
	      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	        args[_key - 1] = arguments[_key];
	      }
	      (_Vue$event = ui_vue.WidgetVue.event).$emit.apply(_Vue$event, [eventName].concat(args));
	    }
	  }, {
	    key: "listen",
	    value: function listen(event, callback) {
	      ui_vue.WidgetVue.event.$on(event, callback);
	    }
	  }]);
	  return ApplicationController;
	}();

	function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
	function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { babelHelpers.defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
	var Controller = /*#__PURE__*/function () {
	  /* region 01. Initialize and store data */

	  function Controller() {
	    var _this = this;
	    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	    babelHelpers.classCallCheck(this, Controller);
	    this.inited = false;
	    this.initPromise = new Promise(function (resolve, reject) {
	      _this.initPromiseResolver = resolve;
	    });
	    this.offline = false;
	    this.restAnswerHandler = [];
	    this.vuexAdditionalModel = [];
	    this.store = null;
	    this.storeBuilder = null;
	    this.init().then(function () {
	      return _this.prepareParams(params);
	    }).then(function () {
	      return _this.initController();
	    }).then(function () {
	      return _this.initLocalStorage();
	    }).then(function () {
	      return _this.initStorage();
	    }).then(function () {
	      return _this.initRestClient();
	    }).then(function () {
	      return _this.initPullClient();
	    }).then(function () {
	      return _this.initEnvironment();
	    }).then(function () {
	      return _this.initComplete();
	    })["catch"](function (error) {
	      im_lib_logger.Logger.error('error initializing core controller', error);
	    });
	  }
	  babelHelpers.createClass(Controller, [{
	    key: "init",
	    value: function init() {
	      return Promise.resolve();
	    }
	  }, {
	    key: "prepareParams",
	    value: function prepareParams(params) {
	      var _this2 = this;
	      if (typeof params.localize !== 'undefined') {
	        this.localize = params.localize;
	      } else {
	        if (typeof BX !== 'undefined') {
	          this.localize = _objectSpread({}, BX.message);
	        } else {
	          this.localize = {};
	        }
	      }
	      if (typeof params.host !== 'undefined') {
	        this.host = params.host;
	      } else {
	        this.host = location.origin;
	      }
	      if (typeof params.userId !== 'undefined') {
	        var parsedUserId = parseInt(params.userId);
	        if (!isNaN(parsedUserId)) {
	          this.userId = parsedUserId;
	        } else {
	          this.userId = 0;
	        }
	      } else {
	        var userId = this.getLocalize('USER_ID');
	        this.userId = userId ? parseInt(userId) : 0;
	      }
	      if (typeof params.siteId !== 'undefined') {
	        if (typeof params.siteId === 'string' && params.siteId !== '') {
	          this.siteId = params.siteId;
	        } else {
	          this.siteId = 's1';
	        }
	      } else {
	        this.siteId = this.getLocalize('SITE_ID') || 's1';
	      }
	      if (typeof params.siteDir !== 'undefined') {
	        if (typeof params.siteDir === 'string' && params.siteDir !== '') {
	          this.siteDir = params.siteDir;
	        } else {
	          this.siteDir = 's1';
	        }
	      } else {
	        this.siteDir = this.getLocalize('SITE_DIR') || 's1';
	      }
	      if (typeof params.languageId !== 'undefined') {
	        if (typeof params.languageId === 'string' && params.languageId !== '') {
	          this.languageId = params.languageId;
	        } else {
	          this.languageId = 'en';
	        }
	      } else {
	        this.languageId = this.getLocalize('LANGUAGE_ID') || 'en';
	      }
	      this.pullInstance = pull_client.PullClient;
	      this.pullClient = pull_client.PULL;
	      if (typeof params.pull !== 'undefined') {
	        if (typeof params.pull.instance !== 'undefined') {
	          this.pullInstance = params.pull.instance;
	        }
	        if (typeof params.pull.client !== 'undefined') {
	          this.pullClient = params.pull.client;
	        }
	      }
	      this.restInstance = rest_client.RestClient;
	      this.restClient = rest_client.rest;
	      if (typeof params.rest !== 'undefined') {
	        if (typeof params.rest.instance !== 'undefined') {
	          this.restInstance = params.rest.instance;
	        }
	        if (typeof params.rest.client !== 'undefined') {
	          this.restClient = params.rest.client;
	        }
	      }
	      this.vuexBuilder = {
	        database: false,
	        databaseName: 'desktop/im',
	        databaseType: ui_vue_vuex.WidgetVuexBuilder.DatabaseType.indexedDb
	      };
	      if (typeof params.vuexBuilder !== 'undefined') {
	        if (typeof params.vuexBuilder.database !== 'undefined') {
	          this.vuexBuilder.database = params.vuexBuilder.database;
	        }
	        if (typeof params.vuexBuilder.databaseName !== 'undefined') {
	          this.vuexBuilder.databaseName = params.vuexBuilder.databaseName;
	        }
	        if (typeof params.vuexBuilder.databaseType !== 'undefined') {
	          this.vuexBuilder.databaseType = params.vuexBuilder.databaseType;
	        }
	        if (typeof params.vuexBuilder.models !== 'undefined') {
	          params.vuexBuilder.models.forEach(function (model) {
	            _this2.addVuexModel(model);
	          });
	        }
	      }
	      return Promise.resolve();
	    }
	  }, {
	    key: "initController",
	    value: function initController() {
	      this.application = new ApplicationController();
	      this.application.setCoreController(this);
	      return new Promise(function (resolve, reject) {
	        return resolve();
	      });
	    }
	  }, {
	    key: "initLocalStorage",
	    value: function initLocalStorage() {
	      return new Promise(function (resolve, reject) {
	        return resolve();
	      });
	    }
	  }, {
	    key: "initStorage",
	    value: function initStorage() {
	      var _this3 = this;
	      var applicationVariables = {
	        common: {
	          host: this.getHost(),
	          userId: this.getUserId(),
	          siteId: this.getSiteId(),
	          languageId: this.getLanguageId()
	        },
	        dialog: {
	          messageLimit: this.application.getDefaultMessageLimit(),
	          enableReadMessages: true
	        },
	        device: {
	          type: im_lib_utils.Utils.device.isMobile() ? im_const.DeviceType.mobile : im_const.DeviceType.desktop,
	          orientation: im_lib_utils.Utils.device.getOrientation()
	        }
	      };
	      var builder = new ui_vue_vuex.WidgetVuexBuilder().addModel(im_model.ApplicationModel.create().useDatabase(false).setVariables(applicationVariables)).addModel(im_model.MessagesModel.create().useDatabase(this.vuexBuilder.database).setVariables({
	        host: this.getHost()
	      })).addModel(im_model.DialoguesModel.create().useDatabase(this.vuexBuilder.database).setVariables({
	        host: this.getHost()
	      })).addModel(im_model.FilesModel.create().useDatabase(this.vuexBuilder.database).setVariables({
	        host: this.getHost(),
	        "default": {
	          name: 'File is deleted'
	        }
	      })).addModel(im_model.UsersModel.create().useDatabase(this.vuexBuilder.database).setVariables({
	        host: this.getHost(),
	        "default": {
	          name: 'Anonymous'
	        }
	      })).addModel(im_model.RecentModel.create().useDatabase(false).setVariables({
	        host: this.getHost()
	      })).addModel(im_model.NotificationsModel.create().useDatabase(false).setVariables({
	        host: this.getHost()
	      }));
	      this.vuexAdditionalModel.forEach(function (model) {
	        builder.addModel(model);
	      });
	      builder.setDatabaseConfig({
	        name: this.vuexBuilder.databaseName,
	        type: this.vuexBuilder.databaseType,
	        siteId: this.getSiteId(),
	        userId: this.getUserId()
	      });
	      return builder.build().then(function (result) {
	        _this3.store = result.store;
	        _this3.storeBuilder = result.builder;
	        return new Promise(function (resolve, reject) {
	          return resolve();
	        });
	      });
	    }
	  }, {
	    key: "initRestClient",
	    value: function initRestClient(result) {
	      this.addRestAnswerHandler(im_provider_rest.CoreRestHandler.create({
	        store: this.store,
	        controller: this
	      }));
	      return new Promise(function (resolve, reject) {
	        return resolve();
	      });
	    }
	  }, {
	    key: "initPullClient",
	    value: function initPullClient() {
	      if (!this.pullClient) {
	        return false;
	      }
	      this.pullClient.subscribe(this.pullBaseHandler = new im_provider_pull.ImBasePullHandler({
	        store: this.store,
	        controller: this
	      }));
	      this.pullClient.subscribe({
	        type: this.pullInstance.SubscriptionType.Status,
	        callback: this.eventStatusInteraction.bind(this)
	      });
	      this.pullClient.subscribe({
	        type: this.pullInstance.SubscriptionType.Online,
	        callback: this.eventOnlineInteraction.bind(this)
	      });
	      return new Promise(function (resolve, reject) {
	        return resolve();
	      });
	    }
	  }, {
	    key: "initEnvironment",
	    value: function initEnvironment(result) {
	      var _this4 = this;
	      window.addEventListener('orientationchange', function () {
	        if (!_this4.store) {
	          return;
	        }
	        _this4.store.commit('application/set', {
	          device: {
	            orientation: im_lib_utils.Utils.device.getOrientation()
	          }
	        });
	        if (_this4.store.state.application.device.type === im_const.DeviceType.mobile && _this4.store.state.application.device.orientation === im_const.DeviceOrientation.horizontal) {
	          document.activeElement.blur();
	        }
	      });
	      return new Promise(function (resolve, reject) {
	        return resolve();
	      });
	    }
	  }, {
	    key: "initComplete",
	    value: function initComplete() {
	      this.inited = true;
	      this.initPromiseResolver(this);
	    }
	    /* endregion 01. Initialize and store data */
	    /* region 02. Push & Pull */
	  }, {
	    key: "eventStatusInteraction",
	    value: function eventStatusInteraction(data) {
	      if (data.status === this.pullInstance.PullStatus.Online) {
	        this.offline = false;

	        //this.pullBaseHandler.option.skip = true;
	        // this.getDialogUnread().then(() => {
	        // 	this.pullBaseHandler.option.skip = false;
	        // 	this.processSendMessages();
	        // 	this.emit(EventType.dialog.sendReadMessages);
	        // }).catch(() => {
	        // 	this.pullBaseHandler.option.skip = false;
	        // 	this.processSendMessages();
	        // });
	      } else if (data.status === this.pullInstance.PullStatus.Offline) {
	        this.offline = true;
	      }
	    }
	  }, {
	    key: "eventOnlineInteraction",
	    value: function eventOnlineInteraction(data) {
	      if (data.command === 'list' || data.command === 'userStatus') {
	        for (var userId in data.params.users) {
	          if (!data.params.users.hasOwnProperty(userId)) {
	            continue;
	          }
	          this.store.dispatch('users/update', {
	            id: data.params.users[userId].id,
	            fields: data.params.users[userId]
	          });
	        }
	      }
	    }
	    /* endregion 02. Push & Pull */
	    /* region 03. Rest */
	  }, {
	    key: "executeRestAnswer",
	    value: function executeRestAnswer(command, result, extra) {
	      im_lib_logger.Logger.warn('Core.controller.executeRestAnswer', command, result, extra);
	      this.restAnswerHandler.forEach(function (handler) {
	        handler.execute(command, result, extra);
	      });
	    }
	    /* endregion 03. Rest */
	    /* region 04. Template engine */
	  }, {
	    key: "createVue",
	    value: function createVue(application) {
	      var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	      var controller = this;
	      var beforeCreateFunction = function beforeCreateFunction() {};
	      if (config.beforeCreate) {
	        beforeCreateFunction = config.beforeCreate;
	      }
	      var destroyedFunction = function destroyedFunction() {};
	      if (config.destroyed) {
	        destroyedFunction = config.destroyed;
	      }
	      var createdFunction = function createdFunction() {};
	      if (config.created) {
	        createdFunction = config.created;
	      }
	      var initConfig = {
	        store: this.store,
	        beforeCreate: function beforeCreate() {
	          this.$bitrix.Data.set('controller', controller);
	          this.$bitrix.Application.set(application);
	          this.$bitrix.Loc.setMessage(controller.localize);
	          if (controller.restClient) {
	            this.$bitrix.RestClient.set(controller.restClient);
	          }
	          if (controller.pullClient) {
	            this.$bitrix.PullClient.set(controller.pullClient);
	          }
	          beforeCreateFunction.bind(this)();
	        },
	        created: function created() {
	          createdFunction.bind(this)();
	        },
	        destroyed: function destroyed() {
	          destroyedFunction.bind(this)();
	        }
	      };
	      if (config.el) {
	        initConfig.el = config.el;
	      }
	      if (config.template) {
	        initConfig.template = config.template;
	      }
	      if (config.computed) {
	        initConfig.computed = config.computed;
	      }
	      if (config.data) {
	        initConfig.data = config.data;
	      }
	      var initConfigCreatedFunction = initConfig.created;
	      return new Promise(function (resolve, reject) {
	        initConfig.created = function () {
	          initConfigCreatedFunction.bind(this)();
	          resolve(this);
	        };
	        ui_vue.WidgetBitrixVue.createApp(initConfig);
	      });
	    }
	    /* endregion 04. Template engine */
	    /* region 05. Core methods */
	  }, {
	    key: "getHost",
	    value: function getHost() {
	      return this.host;
	    }
	  }, {
	    key: "setHost",
	    value: function setHost(host) {
	      this.host = host;
	      this.store.commit('application/set', {
	        common: {
	          host: host
	        }
	      });
	    }
	  }, {
	    key: "getUserId",
	    value: function getUserId() {
	      return this.userId;
	    }
	  }, {
	    key: "setUserId",
	    value: function setUserId(userId) {
	      var parsedUserId = parseInt(userId);
	      if (!isNaN(parsedUserId)) {
	        this.userId = parsedUserId;
	      } else {
	        this.userId = 0;
	      }
	      this.store.commit('application/set', {
	        common: {
	          userId: userId
	        }
	      });
	    }
	  }, {
	    key: "getSiteId",
	    value: function getSiteId() {
	      return this.siteId;
	    }
	  }, {
	    key: "setSiteId",
	    value: function setSiteId(siteId) {
	      if (typeof siteId === 'string' && siteId !== '') {
	        this.siteId = siteId;
	      } else {
	        this.siteId = 's1';
	      }
	      this.store.commit('application/set', {
	        common: {
	          siteId: this.siteId
	        }
	      });
	    }
	  }, {
	    key: "getLanguageId",
	    value: function getLanguageId() {
	      return this.languageId;
	    }
	  }, {
	    key: "setLanguageId",
	    value: function setLanguageId(languageId) {
	      if (typeof languageId === 'string' && languageId !== '') {
	        this.languageId = languageId;
	      } else {
	        this.languageId = 'en';
	      }
	      this.store.commit('application/set', {
	        common: {
	          languageId: this.languageId
	        }
	      });
	    }
	  }, {
	    key: "getStore",
	    value: function getStore() {
	      return this.store;
	    }
	  }, {
	    key: "getStoreBuilder",
	    value: function getStoreBuilder() {
	      return this.storeBuilder;
	    }
	  }, {
	    key: "addRestAnswerHandler",
	    value: function addRestAnswerHandler(handler) {
	      this.restAnswerHandler.push(handler);
	    }
	  }, {
	    key: "addVuexModel",
	    value: function addVuexModel(model) {
	      this.vuexAdditionalModel.push(model);
	    }
	  }, {
	    key: "isOnline",
	    value: function isOnline() {
	      return !this.offline;
	    }
	  }, {
	    key: "ready",
	    value: function ready() {
	      if (this.inited) {
	        return Promise.resolve(this);
	      }
	      return this.initPromise;
	    }
	    /* endregion 05. Methods */
	    /* region 06. Interaction and utils */
	  }, {
	    key: "setError",
	    value: function setError() {
	      var code = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
	      var description = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
	      im_lib_logger.Logger.error("Messenger.Application.error: ".concat(code, " (").concat(description, ")"));
	      var localizeDescription = '';
	      if (code.endsWith('LOCALIZED')) {
	        localizeDescription = description;
	      }
	      this.store.commit('application/set', {
	        error: {
	          active: true,
	          code: code,
	          description: localizeDescription
	        }
	      });
	    }
	  }, {
	    key: "clearError",
	    value: function clearError() {
	      this.store.commit('application/set', {
	        error: {
	          active: false,
	          code: '',
	          description: ''
	        }
	      });
	    }
	  }, {
	    key: "addLocalize",
	    value: function addLocalize(phrases) {
	      if (babelHelpers["typeof"](phrases) !== "object" || !phrases) {
	        return false;
	      }
	      for (var name in phrases) {
	        if (phrases.hasOwnProperty(name)) {
	          this.localize[name] = phrases[name];
	        }
	      }
	      return true;
	    }
	  }, {
	    key: "getLocalize",
	    value: function getLocalize(name) {
	      var phrase = '';
	      if (typeof name === 'undefined') {
	        return this.localize;
	      } else if (typeof this.localize[name.toString()] === 'undefined') {
	        im_lib_logger.Logger.warn("Controller.Core.getLocalize: message with code '".concat(name.toString(), "' is undefined."));
	        //Logger.trace();
	      } else {
	        phrase = this.localize[name];
	      }
	      return phrase;
	    } /* endregion 06. Interaction and utils */
	  }]);
	  return Controller;
	}();

	exports.Controller = Controller;

}((this.BX.Messenger = this.BX.Messenger || {}),BX,BX,BX,BX.Messenger.Model,BX.Messenger.Provider.Pull,BX.Messenger.Provider.Rest,BX.Messenger.Lib,BX.Messenger.Const,BX.Messenger.Lib,BX,BX.Messenger.Lib));





// file: /bitrix/js/im/lib/cookie/dist/cookie.bundle.js
this.BX = this.BX || {};
this.BX.Messenger = this.BX.Messenger || {};
(function (exports,im_lib_localstorage) {
	'use strict';

	/**
	 * Bitrix Im
	 * Cookie manager
	 *
	 * @package bitrix
	 * @subpackage im
	 * @copyright 2001-2020 Bitrix
	 */
	var Cookie = {
	  get: function get(siteId, name) {
	    var cookieName = siteId ? siteId + '_' + name : name;
	    if (navigator.cookieEnabled) {
	      var result = document.cookie.match(new RegExp("(?:^|; )" + cookieName.replace(/([.$?*|{}()\[\]\\\/+^])/g, '\\$1') + "=([^;]*)"));
	      if (result) {
	        return decodeURIComponent(result[1]);
	      }
	    }
	    if (im_lib_localstorage.LocalStorage.isEnabled()) {
	      var _result = im_lib_localstorage.LocalStorage.get(siteId, 0, name, undefined);
	      if (typeof _result !== 'undefined') {
	        return _result;
	      }
	    }
	    if (typeof window.BX.GuestUserCookie === 'undefined') {
	      window.BX.GuestUserCookie = {};
	    }
	    return window.BX.GuestUserCookie[cookieName];
	  },
	  set: function set(siteId, name, value, options) {
	    options = options || {};
	    var expires = options.expires;
	    if (typeof expires == "number" && expires) {
	      var currentDate = new Date();
	      currentDate.setTime(currentDate.getTime() + expires * 1000);
	      expires = options.expires = currentDate;
	    }
	    if (expires && expires.toUTCString) {
	      options.expires = expires.toUTCString();
	    }
	    value = encodeURIComponent(value);
	    var cookieName = siteId ? siteId + '_' + name : name;
	    var updatedCookie = cookieName + "=" + value;
	    for (var propertyName in options) {
	      if (!options.hasOwnProperty(propertyName)) {
	        continue;
	      }
	      updatedCookie += "; " + propertyName;
	      var propertyValue = options[propertyName];
	      if (propertyValue !== true) {
	        updatedCookie += "=" + propertyValue;
	      }
	    }
	    document.cookie = updatedCookie;
	    if (typeof window.BX.GuestUserCookie === 'undefined') {
	      BX.GuestUserCookie = {};
	    }
	    window.BX.GuestUserCookie[cookieName] = value;
	    im_lib_localstorage.LocalStorage.set(siteId, 0, name, value);
	    return true;
	  }
	};

	exports.Cookie = Cookie;

}((this.BX.Messenger.Lib = this.BX.Messenger.Lib || {}),BX.Messenger.Lib));





// file: /bitrix/js/im/lib/uploader/dist/uploader.bundle.js
this.BX = this.BX || {};
this.BX.Messenger = this.BX.Messenger || {};
(function (exports,main_core_events,main_core_minimal) {
	'use strict';

	var FileSender = /*#__PURE__*/function () {
	  function FileSender(task) {
	    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	    babelHelpers.classCallCheck(this, FileSender);
	    babelHelpers.defineProperty(this, "token", null);
	    babelHelpers.defineProperty(this, "nextDataChunkToSend", null);
	    babelHelpers.defineProperty(this, "readOffset", 0);
	    this.diskFolderId = task.diskFolderId;
	    this.listener = task.listener;
	    this.status = task.status;
	    this.taskId = task.taskId;
	    this.fileData = task.fileData;
	    this.fileName = task.fileName || this.fileData.name;
	    this.generateUniqueName = task.generateUniqueName;
	    this.chunkSizeInBytes = task.chunkSize;
	    this.previewBlob = task.previewBlob || null;
	    this.requestToDelete = false;
	    this.listener('onStartUpload', {
	      id: this.taskId,
	      file: this.fileData,
	      previewData: this.previewBlob
	    });
	    this.host = options.host || null;
	    this.actionUploadChunk = options.actionUploadChunk || 'disk.api.content.upload';
	    this.actionCommitFile = options.actionCommitFile || 'disk.api.file.createByContent';
	    this.actionRollbackUpload = options.actionRollbackUpload || 'disk.api.content.rollbackUpload';
	    this.customHeaders = options.customHeaders || null;
	  }
	  babelHelpers.createClass(FileSender, [{
	    key: "uploadContent",
	    value: function uploadContent() {
	      var _this = this;
	      if (this.status === Uploader.STATUSES.CANCELLED) {
	        return;
	      }
	      this.status = Uploader.STATUSES.PROGRESS;
	      this.readNext();
	      var url = "".concat(this.host ? this.host : "", "\n\t\t\t/bitrix/services/main/ajax.php?action=").concat(this.actionUploadChunk, "\n\t\t\t&filename=").concat(this.fileName, "\n\t\t\t").concat(this.token ? "&token=" + this.token : "");
	      var contentRangeHeader = "bytes " + this.readOffset + "-" + (this.readOffset + this.chunkSizeInBytes - 1) + "/" + this.fileData.size;
	      this.calculateProgress();
	      var headers = {
	        "Content-Type": this.fileData.type,
	        "Content-Range": contentRangeHeader
	      };
	      if (!this.customHeaders) {
	        headers['X-Bitrix-Csrf-Token'] = BX.bitrix_sessid();
	      } else
	        //if (this.customHeaders)
	        {
	          for (var customHeader in this.customHeaders) {
	            if (this.customHeaders.hasOwnProperty(customHeader)) {
	              headers[customHeader] = this.customHeaders[customHeader];
	            }
	          }
	        }
	      fetch(url, {
	        method: 'POST',
	        headers: headers,
	        credentials: "include",
	        body: this.nextDataChunkToSend
	      }).then(function (response) {
	        return response.json();
	      }).then(function (result) {
	        if (result.errors.length > 0) {
	          _this.status = Uploader.STATUSES.FAILED;
	          _this.listener('onUploadFileError', {
	            id: _this.taskId,
	            result: result
	          });
	          console.error(result.errors[0].message);
	        } else if (result.data.token) {
	          _this.token = result.data.token;
	          _this.readOffset = _this.readOffset + _this.chunkSizeInBytes;
	          if (!_this.isEndOfFile()) {
	            _this.uploadContent();
	          } else {
	            _this.createFileFromUploadedChunks();
	          }
	        }
	      })["catch"](function (err) {
	        _this.status = Uploader.STATUSES.FAILED;
	        _this.listener('onUploadFileError', {
	          id: _this.taskId,
	          result: err
	        });
	      });
	    }
	  }, {
	    key: "deleteContent",
	    value: function deleteContent() {
	      this.status = Uploader.STATUSES.CANCELLED;
	      this.requestToDelete = true;
	      if (!this.token) {
	        console.error('Empty token.');
	        return;
	      }
	      var url = "".concat(this.host ? this.host : "", "/bitrix/services/main/ajax.php?\n\t\taction=").concat(this.actionRollbackUpload, "&token=").concat(this.token);
	      var headers = {};
	      if (!this.customHeaders) {
	        headers['X-Bitrix-Csrf-Token'] = BX.bitrix_sessid();
	      } else
	        //if (this.customHeaders)
	        {
	          for (var customHeader in this.customHeaders) {
	            if (this.customHeaders.hasOwnProperty(customHeader)) {
	              headers[customHeader] = this.customHeaders[customHeader];
	            }
	          }
	        }
	      fetch(url, {
	        method: 'POST',
	        credentials: "include",
	        headers: headers
	      }).then(function (response) {
	        return response.json();
	      }).then(function (result) {
	        return console.log(result);
	      })["catch"](function (err) {
	        return console.error(err);
	      });
	    }
	  }, {
	    key: "createFileFromUploadedChunks",
	    value: function createFileFromUploadedChunks() {
	      var _this2 = this;
	      if (!this.token) {
	        console.error('Empty token.');
	        return;
	      }
	      if (this.requestToDelete) {
	        return;
	      }
	      var url = "".concat(this.host ? this.host : "", "/bitrix/services/main/ajax.php?action=").concat(this.actionCommitFile, "&filename=").concat(this.fileName) + "&folderId=" + this.diskFolderId + "&contentId=" + this.token + (this.generateUniqueName ? "&generateUniqueName=true" : "");
	      var headers = {
	        "X-Upload-Content-Type": this.fileData.type
	      };
	      if (!this.customHeaders) {
	        headers['X-Bitrix-Csrf-Token'] = BX.bitrix_sessid();
	      } else
	        //if (this.customHeaders)
	        {
	          for (var customHeader in this.customHeaders) {
	            if (this.customHeaders.hasOwnProperty(customHeader)) {
	              headers[customHeader] = this.customHeaders[customHeader];
	            }
	          }
	        }
	      var formData = new FormData();
	      if (this.previewBlob) {
	        formData.append("previewFile", this.previewBlob, "preview_" + this.fileName + ".jpg");
	      }
	      fetch(url, {
	        method: 'POST',
	        headers: headers,
	        credentials: "include",
	        body: formData
	      }).then(function (response) {
	        return response.json();
	      }).then(function (result) {
	        _this2.uploadResult = result;
	        if (result.errors.length > 0) {
	          _this2.status = Uploader.STATUSES.FAILED;
	          _this2.listener('onCreateFileError', {
	            id: _this2.taskId,
	            result: result
	          });
	          console.error(result.errors[0].message);
	        } else {
	          _this2.calculateProgress();
	          _this2.status = Uploader.STATUSES.DONE;
	          _this2.listener('onComplete', {
	            id: _this2.taskId,
	            result: result
	          });
	        }
	      })["catch"](function (err) {
	        _this2.status = Uploader.STATUSES.FAILED;
	        _this2.listener('onCreateFileError', {
	          id: _this2.taskId,
	          result: err
	        });
	      });
	    }
	  }, {
	    key: "calculateProgress",
	    value: function calculateProgress() {
	      this.progress = Math.round(this.readOffset * 100 / this.fileData.size);
	      this.listener('onProgress', {
	        id: this.taskId,
	        progress: this.progress,
	        readOffset: this.readOffset,
	        fileSize: this.fileData.size
	      });
	    }
	  }, {
	    key: "readNext",
	    value: function readNext() {
	      if (this.readOffset + this.chunkSizeInBytes > this.fileData.size) {
	        this.chunkSizeInBytes = this.fileData.size - this.readOffset;
	      }
	      this.nextDataChunkToSend = this.fileData.slice(this.readOffset, this.readOffset + this.chunkSizeInBytes);
	    }
	  }, {
	    key: "isEndOfFile",
	    value: function isEndOfFile() {
	      return this.readOffset >= this.fileData.size;
	    }
	  }]);
	  return FileSender;
	}();

	var Uploader = /*#__PURE__*/function (_EventEmitter) {
	  babelHelpers.inherits(Uploader, _EventEmitter);
	  //1Mb
	  //5Mb
	  //100Mb

	  function Uploader(options) {
	    var _this;
	    babelHelpers.classCallCheck(this, Uploader);
	    _this = babelHelpers.possibleConstructorReturn(this, babelHelpers.getPrototypeOf(Uploader).call(this));
	    babelHelpers.defineProperty(babelHelpers.assertThisInitialized(_this), "queue", []);
	    babelHelpers.defineProperty(babelHelpers.assertThisInitialized(_this), "isCloud", BX.message.isCloud);
	    babelHelpers.defineProperty(babelHelpers.assertThisInitialized(_this), "phpUploadMaxFilesize", BX.message.phpUploadMaxFilesize);
	    babelHelpers.defineProperty(babelHelpers.assertThisInitialized(_this), "phpPostMaxSize", BX.message.phpPostMaxSize);
	    _this.setEventNamespace('BX.Messenger.Lib.Uploader');
	    _this.generatePreview = options.generatePreview || false;
	    if (options) {
	      _this.inputNode = options.inputNode || null;
	      _this.dropNode = options.dropNode || null;
	      _this.fileMaxSize = options.fileMaxSize || null;
	      _this.fileMaxWidth = options.fileMaxWidth || null;
	      _this.fileMaxHeight = options.fileMaxHeight || null;
	      if (options.sender) {
	        _this.senderOptions = {
	          host: options.sender.host,
	          actionUploadChunk: options.sender.actionUploadChunk,
	          actionCommitFile: options.sender.actionCommitFile,
	          actionRollbackUpload: options.sender.actionRollbackUpload,
	          customHeaders: options.sender.customHeaders || null
	        };
	      }
	      _this.assignInput();
	      _this.assignDrop();
	    }
	    return _this;
	  }
	  babelHelpers.createClass(Uploader, [{
	    key: "setInputNode",
	    value: function setInputNode(node) {
	      if (node instanceof HTMLInputElement || Array.isArray(node)) {
	        this.inputNode = node;
	        this.assignInput();
	      }
	    }
	  }, {
	    key: "addFilesFromEvent",
	    value: function addFilesFromEvent(event) {
	      var _this2 = this;
	      Array.from(event.target.files).forEach(function (file) {
	        _this2.emitSelectedFile(file);
	      });
	    }
	  }, {
	    key: "getPreview",
	    value: function getPreview(file) {
	      var _this3 = this;
	      return new Promise(function (resolve, reject) {
	        if (!_this3.generatePreview) {
	          resolve();
	        }
	        if (file instanceof File) {
	          if (file.type.startsWith('video')) {
	            Uploader.getVideoPreviewBlob(file, 10).then(function (blob) {
	              return _this3.getImageDimensions(blob);
	            }).then(function (result) {
	              return resolve(result);
	            })["catch"](function (reason) {
	              return reject(reason);
	            });
	          } else if (file.type.startsWith('image')) {
	            var blob = new Blob([file], {
	              type: file.type
	            });
	            _this3.getImageDimensions(blob).then(function (result) {
	              return resolve(result);
	            });
	          } else {
	            resolve();
	          }
	        } else {
	          reject("Parameter 'file' is not instance of 'File'");
	        }
	      });
	    }
	  }, {
	    key: "addTask",
	    value: function addTask(task) {
	      var _this4 = this;
	      if (!this.isModernBrowser()) {
	        console.warn('Unsupported browser!');
	        return;
	      }
	      if (!this.checkTaskParams(task)) {
	        return;
	      }
	      task.chunkSize = this.calculateChunkSize(task.chunkSize);
	      task.listener = function (event, data) {
	        return _this4.onUploadEvent(event, data);
	      };
	      task.status = Uploader.STATUSES.PENDING;
	      var fileSender = new FileSender(task, this.senderOptions);
	      this.queue.push(fileSender);
	      this.checkUploadQueue();
	    }
	  }, {
	    key: "deleteTask",
	    value: function deleteTask(taskId) {
	      if (!taskId) {
	        return;
	      }
	      this.queue = this.queue.filter(function (queueItem) {
	        if (queueItem.taskId === taskId) {
	          queueItem.deleteContent();
	          return false;
	        }
	        return true;
	      });
	    }
	  }, {
	    key: "getTask",
	    value: function getTask(taskId) {
	      var task = this.queue.find(function (queueItem) {
	        return queueItem.taskId === taskId;
	      });
	      if (task) {
	        return {
	          id: task.id,
	          diskFolderId: task.diskFolderId,
	          fileData: task.fileData,
	          fileName: task.fileName,
	          progress: task.progress,
	          readOffset: task.readOffset,
	          status: task.status,
	          token: task.token,
	          uploadResult: task.uploadResult
	        };
	      }
	      return null;
	    }
	  }, {
	    key: "checkUploadQueue",
	    value: function checkUploadQueue() {
	      if (this.queue.length > 0) {
	        var inProgressTasks = this.queue.filter(function (queueTask) {
	          return queueTask.status === Uploader.STATUSES.PENDING;
	        });
	        if (inProgressTasks.length > 0) {
	          inProgressTasks[0].uploadContent();
	        }
	      }
	    }
	  }, {
	    key: "onUploadEvent",
	    value: function onUploadEvent(event, data) {
	      this.emit(event, data);
	      this.checkUploadQueue();
	    }
	  }, {
	    key: "checkTaskParams",
	    value: function checkTaskParams(task) {
	      if (!task.taskId) {
	        console.error('Empty Task ID.');
	        return false;
	      }
	      if (!task.fileData) {
	        console.error('Empty file data.');
	        return false;
	      }
	      if (!task.diskFolderId) {
	        console.error('Empty disk folder ID.');
	        return false;
	      }
	      if (this.fileMaxSize && this.fileMaxSize < task.fileData.size) {
	        var data = {
	          maxFileSizeLimit: this.fileMaxSize,
	          file: task.fileData
	        };
	        this.emit('onFileMaxSizeExceeded', data);
	        return false;
	      }
	      return true;
	    }
	  }, {
	    key: "calculateChunkSize",
	    value: function calculateChunkSize(taskChunkSize) {
	      if (main_core_minimal.Type.isUndefined(this.isCloud))
	        // widget case
	        {
	          return taskChunkSize;
	        }
	      var chunk = 0;
	      if (taskChunkSize) {
	        chunk = taskChunkSize;
	      }
	      if (this.isCloud === 'Y') {
	        chunk = chunk < Uploader.CLOUD_MIN_CHUNK_SIZE ? Uploader.CLOUD_MIN_CHUNK_SIZE : chunk;
	        chunk = chunk > Uploader.CLOUD_MAX_CHUNK_SIZE ? Uploader.CLOUD_MAX_CHUNK_SIZE : chunk;
	      } else
	        //if(this.isCloud === 'N')
	        {
	          var maxBoxChunkSize = Math.min(this.phpPostMaxSize, this.phpUploadMaxFilesize);
	          chunk = chunk < Uploader.BOX_MIN_CHUNK_SIZE ? Uploader.BOX_MIN_CHUNK_SIZE : chunk;
	          chunk = chunk > maxBoxChunkSize ? maxBoxChunkSize : chunk;
	        }
	      return chunk;
	    }
	  }, {
	    key: "isModernBrowser",
	    value: function isModernBrowser() {
	      return typeof fetch !== 'undefined';
	    }
	  }, {
	    key: "assignInput",
	    value: function assignInput() {
	      var _this5 = this;
	      if (this.inputNode instanceof HTMLInputElement) {
	        this.setOnChangeEventListener(this.inputNode);
	      } else if (Array.isArray(this.inputNode)) {
	        this.inputNode.forEach(function (node) {
	          if (node instanceof HTMLInputElement) {
	            _this5.setOnChangeEventListener(node);
	          }
	        });
	      }
	    }
	  }, {
	    key: "setOnChangeEventListener",
	    value: function setOnChangeEventListener(inputNode) {
	      var _this6 = this;
	      inputNode.addEventListener('change', function (event) {
	        _this6.addFilesFromEvent(event);
	      }, false);
	    }
	  }, {
	    key: "assignDrop",
	    value: function assignDrop() {
	      var _this7 = this;
	      if (this.dropNode instanceof HTMLElement) {
	        this.setDropEventListener(this.dropNode);
	      } else if (Array.isArray(this.dropNode)) {
	        this.dropNode.forEach(function (node) {
	          if (node instanceof HTMLElement) {
	            _this7.setDropEventListener(node);
	          }
	        });
	      }
	    }
	  }, {
	    key: "setDropEventListener",
	    value: function setDropEventListener(dropNode) {
	      var _this8 = this;
	      dropNode.addEventListener('drop', function (event) {
	        event.preventDefault();
	        event.stopPropagation();
	        Array.from(event.dataTransfer.files).forEach(function (file) {
	          _this8.emitSelectedFile(file);
	        });
	      }, false);
	    }
	  }, {
	    key: "emitSelectedFile",
	    value: function emitSelectedFile(file) {
	      var _this9 = this;
	      var data = {
	        file: file
	      };
	      this.getPreview(file).then(function (previewData) {
	        if (previewData) {
	          data['previewData'] = previewData.blob;
	          data['previewDataWidth'] = previewData.width;
	          data['previewDataHeight'] = previewData.height;
	          if (_this9.fileMaxWidth || _this9.fileMaxHeight) {
	            var isMaxWidthExceeded = _this9.fileMaxWidth === null ? false : _this9.fileMaxWidth < data['previewDataWidth'];
	            var isMaxHeightExceeded = _this9.fileMaxHeight === null ? false : _this9.fileMaxHeight < data['previewDataHeight'];
	            if (isMaxWidthExceeded || isMaxHeightExceeded) {
	              var eventData = {
	                maxWidth: _this9.fileMaxWidth,
	                maxHeight: _this9.fileMaxHeight,
	                fileWidth: data['previewDataWidth'],
	                fileHeight: data['previewDataHeight']
	              };
	              _this9.emit('onFileMaxResolutionExceeded', eventData);
	              return false;
	            }
	          }
	        }
	        _this9.emit('onSelectFile', data);
	      })["catch"](function (err) {
	        console.warn("Couldn't get preview for file ".concat(file.name, ". Error: ").concat(err));
	        _this9.emit('onSelectFile', data);
	      });
	    }
	  }, {
	    key: "getImageDimensions",
	    value: function getImageDimensions(fileBlob) {
	      return new Promise(function (resolved, rejected) {
	        if (!fileBlob) {
	          rejected('getImageDimensions: fileBlob can\'t be empty');
	        }
	        var img = new Image();
	        img.onload = function () {
	          resolved({
	            blob: fileBlob,
	            width: img.width,
	            height: img.height
	          });
	        };
	        img.onerror = function () {
	          rejected();
	        };
	        img.src = URL.createObjectURL(fileBlob);
	      });
	    }
	  }], [{
	    key: "getVideoPreviewBlob",
	    value: function getVideoPreviewBlob(file) {
	      var seekTime = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
	      return new Promise(function (resolve, reject) {
	        var videoPlayer = document.createElement('video');
	        videoPlayer.setAttribute('src', URL.createObjectURL(file));
	        videoPlayer.load();
	        videoPlayer.addEventListener('error', function (error) {
	          reject("Error while loading video file", error);
	        });
	        videoPlayer.addEventListener('loadedmetadata', function () {
	          if (videoPlayer.duration < seekTime) {
	            seekTime = 0;
	            // reject("Too big seekTime for the video.");
	            // return;
	          }

	          videoPlayer.currentTime = seekTime;
	          videoPlayer.addEventListener('seeked', function () {
	            var canvas = document.createElement("canvas");
	            canvas.width = videoPlayer.videoWidth;
	            canvas.height = videoPlayer.videoHeight;
	            var context = canvas.getContext("2d");
	            context.drawImage(videoPlayer, 0, 0, canvas.width, canvas.height);
	            context.canvas.toBlob(function (blob) {
	              return resolve(blob);
	            }, "image/jpeg", 1);
	          });
	        });
	      });
	    }
	  }]);
	  return Uploader;
	}(main_core_events.EventEmitter);
	babelHelpers.defineProperty(Uploader, "STATUSES", {
	  PENDING: 0,
	  PROGRESS: 1,
	  DONE: 2,
	  CANCELLED: 3,
	  FAILED: 4
	});
	babelHelpers.defineProperty(Uploader, "BOX_MIN_CHUNK_SIZE", 1024 * 1024);
	babelHelpers.defineProperty(Uploader, "CLOUD_MIN_CHUNK_SIZE", 1024 * 1024 * 5);
	babelHelpers.defineProperty(Uploader, "CLOUD_MAX_CHUNK_SIZE", 1024 * 1024 * 100);

	exports.Uploader = Uploader;

}((this.BX.Messenger.Lib = this.BX.Messenger.Lib || {}),BX.Event,BX));





// file: /bitrix/js/im/lib/clipboard/dist/clipboard.bundle.js
this.BX = this.BX || {};
this.BX.Messenger = this.BX.Messenger || {};
(function (exports) {
	'use strict';

	/**
	 * Bitrix Messenger
	 * Clipboard manager
	 *
	 * @package bitrix
	 * @subpackage im
	 * @copyright 2001-2020 Bitrix
	 */

	var Clipboard = /*#__PURE__*/function () {
	  function Clipboard() {
	    babelHelpers.classCallCheck(this, Clipboard);
	  }
	  babelHelpers.createClass(Clipboard, null, [{
	    key: "copy",
	    value: function copy() {
	      var text = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
	      var store = Clipboard.getStore();
	      if (text) {
	        store.focus();
	        store.value = text;
	        store.selectionStart = 0;
	        document.execCommand("copy");
	      } else {
	        document.execCommand("copy");
	        store.focus();
	        document.execCommand("paste");
	        text = store.value;
	      }
	      Clipboard.removeStore();
	      return text;
	    }
	  }, {
	    key: "getStore",
	    value: function getStore() {
	      if (Clipboard.store) {
	        return Clipboard.store;
	      }
	      Clipboard.store = document.createElement('textarea');
	      Clipboard.store.style = "position: absolute; opacity: 0; top: -1000px; left: -1000px;";
	      document.body.insertBefore(Clipboard.store, document.body.firstChild);
	      return Clipboard.store;
	    }
	  }, {
	    key: "removeStore",
	    value: function removeStore() {
	      if (!Clipboard.store) {
	        return true;
	      }
	      document.body.removeChild(Clipboard.store);
	      Clipboard.store = null;
	      return true;
	    }
	  }]);
	  return Clipboard;
	}();
	Clipboard.store = null;

	exports.Clipboard = Clipboard;

}((this.BX.Messenger.Lib = this.BX.Messenger.Lib || {})));





// file: /bitrix/js/im/event-handler/dist/event-handler.bundle.js
this.BX = this.BX || {};
this.BX.Messenger = this.BX.Messenger || {};
(function (exports,im_lib_clipboard,im_lib_timer,im_lib_uploader,im_lib_utils,main_core,main_core_events,im_const,im_lib_logger) {
	'use strict';

	var SendMessageHandler = /*#__PURE__*/function () {
	  function SendMessageHandler($Bitrix) {
	    babelHelpers.classCallCheck(this, SendMessageHandler);
	    babelHelpers.defineProperty(this, "messagesToSend", []);
	    babelHelpers.defineProperty(this, "store", null);
	    babelHelpers.defineProperty(this, "restClient", null);
	    babelHelpers.defineProperty(this, "loc", null);
	    this.controller = $Bitrix.Data.get('controller');
	    this.store = this.controller.store;
	    this.restClient = $Bitrix.RestClient.get();
	    this.loc = $Bitrix.Loc.messages;
	    this.onSendMessageHandler = this.onSendMessage.bind(this);
	    this.onClickOnMessageRetryHandler = this.onClickOnMessageRetry.bind(this);
	    this.onClickOnCommandHandler = this.onClickOnCommand.bind(this);
	    this.onClickOnKeyboardHandler = this.onClickOnKeyboard.bind(this);
	    main_core_events.EventEmitter.subscribe(im_const.EventType.textarea.sendMessage, this.onSendMessageHandler);
	    main_core_events.EventEmitter.subscribe(im_const.EventType.dialog.clickOnMessageRetry, this.onClickOnMessageRetryHandler);
	    main_core_events.EventEmitter.subscribe(im_const.EventType.dialog.clickOnCommand, this.onClickOnCommandHandler);
	    main_core_events.EventEmitter.subscribe(im_const.EventType.dialog.clickOnKeyboardButton, this.onClickOnKeyboardHandler);
	  }
	  babelHelpers.createClass(SendMessageHandler, [{
	    key: "onSendMessage",
	    value: function onSendMessage(_ref) {
	      var data = _ref.data;
	      if (!data.text && !data.file) {
	        return false;
	      }
	      this.sendMessage(data.text, data.file);
	    } //endregion events
	    // entry point for sending message
	  }, {
	    key: "sendMessage",
	    value: function sendMessage() {
	      var _this = this;
	      var text = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
	      var file = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
	      if (!text && !file) {
	        return false;
	      }

	      // quote handling
	      var quoteId = this.store.getters['dialogues/getQuoteId'](this.getDialogId());
	      if (quoteId) {
	        var quoteMessage = this.store.getters['messages/getMessage'](this.getChatId(), quoteId);
	        if (quoteMessage) {
	          text = this.getMessageTextWithQuote(quoteMessage, text);
	          main_core_events.EventEmitter.emit(im_const.EventType.dialog.quotePanelClose);
	        }
	      }
	      if (!this.controller.application.isUnreadMessagesLoaded()) {
	        // not all messages are loaded, adding message only on server
	        this.sendMessageToServer({
	          id: 0,
	          chatId: this.getChatId(),
	          dialogId: this.getDialogId(),
	          text: text,
	          file: file
	        });
	        this.processQueue();
	        return true;
	      }
	      var params = {};
	      if (file) {
	        params.FILE_ID = [file.id];
	      }
	      this.addMessageToModel({
	        text: text,
	        params: params,
	        sending: !file
	      }).then(function (messageId) {
	        main_core_events.EventEmitter.emit(im_const.EventType.dialog.scrollToBottom, {
	          chatId: _this.getChatId(),
	          cancelIfScrollChange: true
	        });
	        _this.addMessageToQueue({
	          messageId: messageId,
	          text: text,
	          file: file
	        });
	        _this.processQueue();
	      });
	    }
	    /**
	     * Goes through messages queue:
	     * - For messages with file sends event to uploader
	     * - For common messages sends them to server
	     */
	  }, {
	    key: "processQueue",
	    value: function processQueue() {
	      var _this2 = this;
	      this.messagesToSend.filter(function (element) {
	        return !element.sending;
	      }).forEach(function (element) {
	        _this2.deleteFromQueue(element.id);
	        element.sending = true;
	        if (element.file) {
	          main_core_events.EventEmitter.emit(im_const.EventType.textarea.stopWriting);
	          main_core_events.EventEmitter.emit(im_const.EventType.uploader.addMessageWithFile, element);
	        } else {
	          _this2.sendMessageToServer(element);
	        }
	      });
	    }
	  }, {
	    key: "addMessageToModel",
	    value: function addMessageToModel(_ref2) {
	      var text = _ref2.text,
	        params = _ref2.params,
	        sending = _ref2.sending;
	      return this.store.dispatch('messages/add', {
	        chatId: this.getChatId(),
	        authorId: this.getUserId(),
	        text: text,
	        params: params,
	        sending: sending
	      });
	    }
	  }, {
	    key: "addMessageToQueue",
	    value: function addMessageToQueue(_ref3) {
	      var messageId = _ref3.messageId,
	        text = _ref3.text,
	        file = _ref3.file;
	      this.messagesToSend.push({
	        id: messageId,
	        chatId: this.getChatId(),
	        dialogId: this.getDialogId(),
	        text: text,
	        file: file,
	        sending: false
	      });
	    }
	  }, {
	    key: "sendMessageToServer",
	    value: function sendMessageToServer(element) {
	      var _this3 = this;
	      main_core_events.EventEmitter.emit(im_const.EventType.textarea.stopWriting);
	      this.restClient.callMethod(im_const.RestMethod.imMessageAdd, {
	        'TEMPLATE_ID': element.id,
	        'DIALOG_ID': element.dialogId,
	        'MESSAGE': element.text
	      }, null, null).then(function (response) {
	        _this3.controller.executeRestAnswer(im_const.RestMethodHandler.imMessageAdd, response, element);
	      })["catch"](function (error) {
	        _this3.controller.executeRestAnswer(im_const.RestMethodHandler.imMessageAdd, error, element);
	        im_lib_logger.Logger.warn('SendMessageHandler: error during adding message', error);
	      });
	    }
	  }, {
	    key: "onClickOnMessageRetry",
	    value: function onClickOnMessageRetry(_ref4) {
	      var event = _ref4.data;
	      this.retrySendMessage(event.message);
	    }
	  }, {
	    key: "retrySendMessage",
	    value: function retrySendMessage(message) {
	      this.addMessageToQueue({
	        messageId: message.id,
	        text: message.text,
	        file: null
	      });
	      this.setSendingMessageFlag(message.id);
	      this.processQueue();
	    }
	  }, {
	    key: "setSendingMessageFlag",
	    value: function setSendingMessageFlag(messageId) {
	      this.store.dispatch('messages/actionStart', {
	        id: messageId,
	        chatId: this.getChatId()
	      });
	    }
	  }, {
	    key: "deleteFromQueue",
	    value: function deleteFromQueue(messageId) {
	      this.messagesToSend = this.messagesToSend.filter(function (element) {
	        return element.id !== messageId;
	      });
	    }
	  }, {
	    key: "onClickOnCommand",
	    value: function onClickOnCommand(_ref5) {
	      var event = _ref5.data;
	      if (event.type === 'put') {
	        this.handlePutAction(event.value);
	      } else if (event.type === 'send') {
	        this.handleSendAction(event.value);
	      } else {
	        im_lib_logger.Logger.warn('SendMessageHandler: Unprocessed command', event);
	      }
	    }
	  }, {
	    key: "onClickOnKeyboard",
	    value: function onClickOnKeyboard(_ref6) {
	      var event = _ref6.data;
	      if (event.action === 'ACTION') {
	        var _event$params = event.params,
	          action = _event$params.action,
	          value = _event$params.value;
	        this.handleKeyboardAction(action, value);
	      }
	      if (event.action === 'COMMAND') {
	        var _event$params2 = event.params,
	          dialogId = _event$params2.dialogId,
	          messageId = _event$params2.messageId,
	          botId = _event$params2.botId,
	          command = _event$params2.command,
	          params = _event$params2.params;
	        this.restClient.callMethod(im_const.RestMethod.imMessageCommand, {
	          'MESSAGE_ID': messageId,
	          'DIALOG_ID': dialogId,
	          'BOT_ID': botId,
	          'COMMAND': command,
	          'COMMAND_PARAMS': params
	        })["catch"](function (error) {
	          return console.error('SendMessageHandler: command processing error', error);
	        });
	      }
	    }
	  }, {
	    key: "handleKeyboardAction",
	    value: function handleKeyboardAction(action, value) {
	      switch (action) {
	        case 'SEND':
	          {
	            this.handleSendAction(value);
	            break;
	          }
	        case 'PUT':
	          {
	            this.handlePutAction(value);
	            break;
	          }
	        case 'CALL':
	          {
	            //this.openPhoneMenu(value);
	            break;
	          }
	        case 'COPY':
	          {
	            im_lib_clipboard.Clipboard.copy(value);
	            BX.UI.Notification.Center.notify({
	              content: this.loc['IM_DIALOG_CLIPBOARD_COPY_SUCCESS'],
	              autoHideDelay: 4000
	            });
	            break;
	          }
	        case 'DIALOG':
	          {
	            //this.openDialog(value);
	            break;
	          }
	        default:
	          {
	            console.error('SendMessageHandler: unknown keyboard action');
	          }
	      }
	    }
	  }, {
	    key: "handlePutAction",
	    value: function handlePutAction(text) {
	      main_core_events.EventEmitter.emit(im_const.EventType.textarea.insertText, {
	        text: "".concat(text, " ")
	      });
	    }
	  }, {
	    key: "handleSendAction",
	    value: function handleSendAction(text) {
	      var _this4 = this;
	      this.sendMessage(text);
	      setTimeout(function () {
	        main_core_events.EventEmitter.emit(im_const.EventType.dialog.scrollToBottom, {
	          chatId: _this4.getChatId(),
	          duration: 300,
	          cancelIfScrollChange: false
	        });
	      }, 300);
	    } // region helpers
	  }, {
	    key: "getMessageTextWithQuote",
	    value: function getMessageTextWithQuote(quoteMessage, text) {
	      var user = null;
	      if (quoteMessage.authorId) {
	        user = this.store.getters['users/get'](quoteMessage.authorId);
	      }
	      var files = this.store.getters['files/getList'](this.getChatId());
	      var quoteDelimiter = '-'.repeat(54);
	      var quoteTitle = user && user.name ? user.name : this.loc['IM_QUOTE_PANEL_DEFAULT_TITLE'];
	      var quoteDate = im_lib_utils.Utils.date.format(quoteMessage.date, null, this.loc);
	      var quoteContent = im_lib_utils.Utils.text.quote(quoteMessage.text, quoteMessage.params, files, this.loc);
	      var message = [];
	      message.push(quoteDelimiter);
	      message.push("".concat(quoteTitle, " [").concat(quoteDate, "]"));
	      message.push(quoteContent);
	      message.push(quoteDelimiter);
	      message.push(text);
	      return message.join("\n");
	    }
	  }, {
	    key: "getChatId",
	    value: function getChatId() {
	      return this.store.state.application.dialog.chatId;
	    }
	  }, {
	    key: "getDialogId",
	    value: function getDialogId() {
	      return this.store.state.application.dialog.dialogId;
	    }
	  }, {
	    key: "getUserId",
	    value: function getUserId() {
	      return this.store.state.application.common.userId;
	    } // endregion helpers
	  }, {
	    key: "destroy",
	    value: function destroy() {
	      main_core_events.EventEmitter.unsubscribe(im_const.EventType.textarea.sendMessage, this.onSendMessageHandler);
	      main_core_events.EventEmitter.unsubscribe(im_const.EventType.dialog.clickOnMessageRetry, this.onClickOnMessageRetryHandler);
	      main_core_events.EventEmitter.unsubscribe(im_const.EventType.dialog.clickOnCommand, this.onClickOnCommandHandler);
	      main_core_events.EventEmitter.unsubscribe(im_const.EventType.dialog.clickOnKeyboardButton, this.onClickOnKeyboardHandler);
	    }
	  }]);
	  return SendMessageHandler;
	}();

	var ReadingHandler = /*#__PURE__*/function () {
	  // {<chatId>: [<messageId>]}

	  function ReadingHandler($Bitrix) {
	    babelHelpers.classCallCheck(this, ReadingHandler);
	    babelHelpers.defineProperty(this, "messagesToRead", {});
	    babelHelpers.defineProperty(this, "timer", null);
	    babelHelpers.defineProperty(this, "store", null);
	    babelHelpers.defineProperty(this, "restClient", null);
	    this.store = $Bitrix.Data.get('controller').store;
	    this.restClient = $Bitrix.RestClient.get();
	    this.timer = new im_lib_timer.Timer();
	    this.onReadMessageHandler = this.onReadMessage.bind(this);
	    main_core_events.EventEmitter.subscribe(im_const.EventType.dialog.readMessage, this.onReadMessageHandler);
	  }
	  babelHelpers.createClass(ReadingHandler, [{
	    key: "onReadMessage",
	    value: function onReadMessage(_ref) {
	      var _ref$data = _ref.data,
	        _ref$data$id = _ref$data.id,
	        id = _ref$data$id === void 0 ? null : _ref$data$id,
	        _ref$data$skipTimer = _ref$data.skipTimer,
	        skipTimer = _ref$data$skipTimer === void 0 ? false : _ref$data$skipTimer,
	        _ref$data$skipAjax = _ref$data.skipAjax,
	        skipAjax = _ref$data$skipAjax === void 0 ? false : _ref$data$skipAjax;
	      return this.readMessage(id, skipTimer, skipAjax);
	    }
	  }, {
	    key: "readMessage",
	    value: function readMessage(messageId) {
	      var _this = this;
	      var skipTimer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
	      var skipAjax = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
	      var chatId = this.getChatId();
	      if (messageId) {
	        if (!this.messagesToRead[chatId]) {
	          this.messagesToRead[chatId] = [];
	        }
	        this.messagesToRead[chatId].push(Number.parseInt(messageId, 10));
	      }
	      this.timer.stop('readMessage', chatId, true);
	      this.timer.stop('readMessageServer', chatId, true);
	      if (skipTimer) {
	        return this.processMessagesToRead(chatId, skipAjax);
	      }
	      return new Promise(function (resolve, reject) {
	        _this.timer.start('readMessage', chatId, 0.1, function () {
	          _this.processMessagesToRead(chatId, skipAjax).then(function (result) {
	            return resolve(result);
	          })["catch"](reject);
	        });
	      });
	    }
	  }, {
	    key: "processMessagesToRead",
	    value: function processMessagesToRead(chatId) {
	      var _this2 = this;
	      var skipAjax = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
	      var lastMessageToRead = this.getMaxMessageIdFromQueue(chatId);
	      delete this.messagesToRead[chatId];
	      if (lastMessageToRead <= 0) {
	        return Promise.resolve();
	      }
	      return new Promise(function (resolve, reject) {
	        _this2.readMessageOnClient(chatId, lastMessageToRead).then(function (readResult) {
	          return _this2.decreaseChatCounter(chatId, readResult.count);
	        }).then(function () {
	          if (skipAjax) {
	            return resolve({
	              chatId: chatId,
	              lastId: lastMessageToRead
	            });
	          }
	          _this2.timer.start('readMessageServer', chatId, 0.5, function () {
	            _this2.readMessageOnServer(chatId, lastMessageToRead).then(function () {
	              resolve({
	                chatId: chatId,
	                lastId: lastMessageToRead
	              });
	            })["catch"](reject);
	          });
	        })["catch"](function (error) {
	          im_lib_logger.Logger.error('Reading messages error', error);
	          reject();
	        });
	      });
	    }
	  }, {
	    key: "getMaxMessageIdFromQueue",
	    value: function getMaxMessageIdFromQueue(chatId) {
	      var maxMessageId = 0;
	      if (!this.messagesToRead[chatId]) {
	        return maxMessageId;
	      }
	      this.messagesToRead[chatId].forEach(function (messageId) {
	        if (maxMessageId < messageId) {
	          maxMessageId = messageId;
	        }
	      });
	      return maxMessageId;
	    }
	  }, {
	    key: "readMessageOnClient",
	    value: function readMessageOnClient(chatId, lastMessageToRead) {
	      return this.store.dispatch('messages/readMessages', {
	        chatId: chatId,
	        readId: lastMessageToRead
	      });
	    }
	  }, {
	    key: "readMessageOnServer",
	    value: function readMessageOnServer(chatId, lastMessageToRead) {
	      return this.restClient.callMethod(im_const.RestMethod.imDialogRead, {
	        'DIALOG_ID': this.getDialogIdByChatId(chatId),
	        'MESSAGE_ID': lastMessageToRead
	      });
	    }
	  }, {
	    key: "decreaseChatCounter",
	    value: function decreaseChatCounter(chatId, counter) {
	      return this.store.dispatch('dialogues/decreaseCounter', {
	        dialogId: this.getDialogIdByChatId(chatId),
	        count: counter
	      });
	    }
	  }, {
	    key: "getChatId",
	    value: function getChatId() {
	      return this.store.state.application.dialog.chatId;
	    }
	  }, {
	    key: "getDialogIdByChatId",
	    value: function getDialogIdByChatId(chatId) {
	      var dialog = this.store.getters['dialogues/getByChatId'](chatId);
	      if (!dialog) {
	        return 0;
	      }
	      return dialog.dialogId;
	    }
	  }, {
	    key: "getDialogId",
	    value: function getDialogId() {
	      return this.store.state.application.dialog.dialogId;
	    }
	  }, {
	    key: "destroy",
	    value: function destroy() {
	      main_core_events.EventEmitter.unsubscribe(im_const.EventType.dialog.readMessage, this.onReadMessageHandler);
	    }
	  }]);
	  return ReadingHandler;
	}();

	var ReactionHandler = /*#__PURE__*/function () {
	  function ReactionHandler($Bitrix) {
	    babelHelpers.classCallCheck(this, ReactionHandler);
	    this.store = $Bitrix.Data.get('controller').store;
	    this.restClient = $Bitrix.RestClient.get();
	    this.onSetMessageReactionHandler = this.onSetMessageReaction.bind(this);
	    this.onOpenMessageReactionListHandler = this.onOpenMessageReactionList.bind(this);
	    main_core_events.EventEmitter.subscribe(im_const.EventType.dialog.setMessageReaction, this.onSetMessageReactionHandler);
	    main_core_events.EventEmitter.subscribe(im_const.EventType.dialog.openMessageReactionList, this.onOpenMessageReactionListHandler);
	  }
	  babelHelpers.createClass(ReactionHandler, [{
	    key: "onSetMessageReaction",
	    value: function onSetMessageReaction(_ref) {
	      var data = _ref.data;
	      this.reactToMessage(data.message.id, data.reaction);
	    }
	  }, {
	    key: "onOpenMessageReactionList",
	    value: function onOpenMessageReactionList(_ref2) {
	      var data = _ref2.data;
	      this.openMessageReactionList(data.message.id, data.values);
	    }
	  }, {
	    key: "reactToMessage",
	    value: function reactToMessage(messageId, reaction) {
	      // let type = reaction.type || ReactionHandler.types.like;
	      var action = reaction.action || ReactionHandler.actions.auto;
	      if (action !== ReactionHandler.actions.auto) {
	        action = action === ReactionHandler.actions.set ? ReactionHandler.actions.plus : ReactionHandler.actions.minus;
	      }
	      this.restClient.callMethod(im_const.RestMethod.imMessageLike, {
	        'MESSAGE_ID': messageId,
	        'ACTION': action
	      });
	    }
	  }, {
	    key: "openMessageReactionList",
	    value: function openMessageReactionList(messageId, values) {
	      im_lib_logger.Logger.warn('Message reaction list not implemented yet!', messageId, values);
	    }
	  }, {
	    key: "destroy",
	    value: function destroy() {
	      main_core_events.EventEmitter.unsubscribe(im_const.EventType.dialog.setMessageReaction, this.onSetMessageReactionHandler);
	      main_core_events.EventEmitter.unsubscribe(im_const.EventType.dialog.openMessageReactionList, this.onOpenMessageReactionListHandler);
	    }
	  }]);
	  return ReactionHandler;
	}();
	babelHelpers.defineProperty(ReactionHandler, "types", {
	  none: 'none',
	  like: 'like',
	  kiss: 'kiss',
	  laugh: 'laugh',
	  wonder: 'wonder',
	  cry: 'cry',
	  angry: 'angry'
	});
	babelHelpers.defineProperty(ReactionHandler, "actions", {
	  auto: 'auto',
	  plus: 'plus',
	  minus: 'minus',
	  set: 'set'
	});

	var QuoteHandler = /*#__PURE__*/function () {
	  function QuoteHandler($Bitrix) {
	    babelHelpers.classCallCheck(this, QuoteHandler);
	    this.store = $Bitrix.Data.get('controller').store;
	    this.onQuoteMessageHandler = this.onQuoteMessage.bind(this);
	    this.onQuotePanelCloseHandler = this.onQuotePanelClose.bind(this);
	    main_core_events.EventEmitter.subscribe(im_const.EventType.dialog.quoteMessage, this.onQuoteMessageHandler);
	    main_core_events.EventEmitter.subscribe(im_const.EventType.dialog.quotePanelClose, this.onQuotePanelCloseHandler);
	  }
	  babelHelpers.createClass(QuoteHandler, [{
	    key: "onQuoteMessage",
	    value: function onQuoteMessage(_ref) {
	      var data = _ref.data;
	      this.quoteMessage(data.message.id);
	    }
	  }, {
	    key: "onQuotePanelClose",
	    value: function onQuotePanelClose() {
	      this.clearQuote();
	    }
	  }, {
	    key: "quoteMessage",
	    value: function quoteMessage(messageId) {
	      this.store.dispatch('dialogues/update', {
	        dialogId: this.getDialogId(),
	        fields: {
	          quoteId: messageId
	        }
	      });
	    }
	  }, {
	    key: "clearQuote",
	    value: function clearQuote() {
	      this.store.dispatch('dialogues/update', {
	        dialogId: this.getDialogId(),
	        fields: {
	          quoteId: 0
	        }
	      });
	    }
	  }, {
	    key: "getDialogId",
	    value: function getDialogId() {
	      return this.store.state.application.dialog.dialogId;
	    }
	  }, {
	    key: "destroy",
	    value: function destroy() {
	      main_core_events.EventEmitter.unsubscribe(im_const.EventType.dialog.quoteMessage, this.onQuoteMessageHandler);
	      main_core_events.EventEmitter.unsubscribe(im_const.EventType.dialog.quotePanelClose, this.onQuotePanelCloseHandler);
	    }
	  }]);
	  return QuoteHandler;
	}();

	var TextareaHandler = /*#__PURE__*/function () {
	  function TextareaHandler($Bitrix) {
	    babelHelpers.classCallCheck(this, TextareaHandler);
	    babelHelpers.defineProperty(this, "store", null);
	    babelHelpers.defineProperty(this, "restClient", null);
	    babelHelpers.defineProperty(this, "timer", null);
	    this.store = $Bitrix.Data.get('controller').store;
	    this.restClient = $Bitrix.RestClient.get();
	    this.timer = new im_lib_timer.Timer();
	    this.subscribeToEvents();
	  }

	  // region events
	  babelHelpers.createClass(TextareaHandler, [{
	    key: "subscribeToEvents",
	    value: function subscribeToEvents() {
	      this.onStartWritingHandler = this.onStartWriting.bind(this);
	      this.onStopWritingHandler = this.onStopWriting.bind(this);
	      this.onAppButtonClickHandler = this.onAppButtonClick.bind(this);
	      this.onFocusHandler = this.onFocus.bind(this);
	      this.onBlurHandler = this.onBlur.bind(this);
	      this.onKeyUpHandler = this.onKeyUp.bind(this);
	      this.onEditHandler = this.onEdit.bind(this);
	      main_core_events.EventEmitter.subscribe(im_const.EventType.textarea.startWriting, this.onStartWritingHandler);
	      main_core_events.EventEmitter.subscribe(im_const.EventType.textarea.stopWriting, this.onStopWritingHandler);
	      main_core_events.EventEmitter.subscribe(im_const.EventType.textarea.appButtonClick, this.onAppButtonClickHandler);
	      main_core_events.EventEmitter.subscribe(im_const.EventType.textarea.focus, this.onFocusHandler);
	      main_core_events.EventEmitter.subscribe(im_const.EventType.textarea.blur, this.onBlurHandler);
	      main_core_events.EventEmitter.subscribe(im_const.EventType.textarea.keyUp, this.onKeyUpHandler);
	      main_core_events.EventEmitter.subscribe(im_const.EventType.textarea.edit, this.onEditHandler);
	    }
	  }, {
	    key: "onStartWriting",
	    value: function onStartWriting() {
	      this.startWriting();
	    }
	  }, {
	    key: "onStopWriting",
	    value: function onStopWriting() {
	      this.stopWriting();
	    }
	  }, {
	    key: "onAppButtonClick",
	    value: function onAppButtonClick() {
	      //
	    }
	  }, {
	    key: "onFocus",
	    value: function onFocus() {
	      //
	    }
	  }, {
	    key: "onBlur",
	    value: function onBlur() {
	      //
	    }
	  }, {
	    key: "onKeyUp",
	    value: function onKeyUp() {
	      //
	    }
	  }, {
	    key: "onEdit",
	    value: function onEdit() {
	      //
	    } //endregion events
	    // region writing
	  }, {
	    key: "startWriting",
	    value: function startWriting() {
	      var _this = this;
	      var dialogId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getDialogId();
	      if (im_lib_utils.Utils.dialog.isEmptyDialogId(dialogId) || this.timer.has('writes', dialogId)) {
	        return false;
	      }
	      this.timer.start('writes', dialogId, 28);
	      this.timer.start('writesSend', dialogId, 5, function () {
	        _this.restClient.callMethod(im_const.RestMethod.imDialogWriting, {
	          'DIALOG_ID': dialogId
	        })["catch"](function () {
	          _this.timer.stop('writes', dialogId);
	        });
	      });
	    }
	  }, {
	    key: "stopWriting",
	    value: function stopWriting() {
	      var dialogId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getDialogId();
	      this.timer.stop('writes', dialogId, true);
	      this.timer.stop('writesSend', dialogId, true);
	    } // endregion writing
	    // region helpers
	  }, {
	    key: "getChatId",
	    value: function getChatId() {
	      return this.store.state.application.dialog.chatId;
	    }
	  }, {
	    key: "getDialogId",
	    value: function getDialogId() {
	      return this.store.state.application.dialog.dialogId;
	    }
	  }, {
	    key: "getUserId",
	    value: function getUserId() {
	      return this.store.state.application.common.userId;
	    }
	  }, {
	    key: "getDiskFolderId",
	    value: function getDiskFolderId() {
	      return this.store.state.application.dialog.diskFolderId;
	    } // endregion helpers
	  }, {
	    key: "destroy",
	    value: function destroy() {
	      main_core_events.EventEmitter.unsubscribe(im_const.EventType.textarea.startWriting, this.onStartWritingHandler);
	      main_core_events.EventEmitter.unsubscribe(im_const.EventType.textarea.stopWriting, this.onStopWritingHandler);
	      main_core_events.EventEmitter.unsubscribe(im_const.EventType.textarea.appButtonClick, this.onAppButtonClickHandler);
	      main_core_events.EventEmitter.unsubscribe(im_const.EventType.textarea.focus, this.onFocusHandler);
	      main_core_events.EventEmitter.unsubscribe(im_const.EventType.textarea.blur, this.onBlurHandler);
	      main_core_events.EventEmitter.unsubscribe(im_const.EventType.textarea.keyUp, this.onKeyUpHandler);
	      main_core_events.EventEmitter.unsubscribe(im_const.EventType.textarea.edit, this.onEditHandler);
	    }
	  }]);
	  return TextareaHandler;
	}();

	/**
	 * @notice define getActionUploadChunk and getActionCommitFile methods for custom upload methods (e.g. videoconference)
	 * @notice redefine addMessageWithFile for custom headers (e.g. videoconference)
	 */
	var TextareaUploadHandler = /*#__PURE__*/function () {
	  function TextareaUploadHandler($Bitrix) {
	    babelHelpers.classCallCheck(this, TextareaUploadHandler);
	    babelHelpers.defineProperty(this, "controller", null);
	    babelHelpers.defineProperty(this, "restClient", null);
	    babelHelpers.defineProperty(this, "uploader", null);
	    babelHelpers.defineProperty(this, "isRequestingDiskFolderId", false);
	    this.controller = $Bitrix.Data.get('controller');
	    this.restClient = $Bitrix.RestClient.get();
	    this.initUploader();
	    this.onTextareaFileSelectedHandler = this.onTextareaFileSelected.bind(this);
	    this.addMessageWithFileHandler = this.addMessageWithFile.bind(this);
	    this.onClickOnUploadCancelHandler = this.onClickOnUploadCancel.bind(this);
	    main_core_events.EventEmitter.subscribe(im_const.EventType.textarea.fileSelected, this.onTextareaFileSelectedHandler);
	    main_core_events.EventEmitter.subscribe(im_const.EventType.uploader.addMessageWithFile, this.addMessageWithFileHandler);
	    main_core_events.EventEmitter.subscribe(im_const.EventType.dialog.clickOnUploadCancel, this.onClickOnUploadCancelHandler);
	  }
	  babelHelpers.createClass(TextareaUploadHandler, [{
	    key: "initUploader",
	    value: function initUploader() {
	      this.uploader = new im_lib_uploader.Uploader({
	        generatePreview: true,
	        sender: this.getUploaderSenderOptions()
	      });
	      this.uploader.subscribe('onStartUpload', this.onStartUploadHandler.bind(this));
	      this.uploader.subscribe('onProgress', this.onProgressHandler.bind(this));
	      this.uploader.subscribe('onSelectFile', this.onSelectFileHandler.bind(this));
	      this.uploader.subscribe('onComplete', this.onCompleteHandler.bind(this));
	      this.uploader.subscribe('onUploadFileError', this.onUploadFileErrorHandler.bind(this));
	      this.uploader.subscribe('onCreateFileError', this.onCreateFileErrorHandler.bind(this));
	    }
	  }, {
	    key: "commitFile",
	    value: function commitFile(params, message) {
	      var _this = this;
	      this.restClient.callMethod(im_const.RestMethod.imDiskFileCommit, {
	        chat_id: params.chatId,
	        upload_id: params.uploadId,
	        message: params.messageText,
	        template_id: params.messageId,
	        file_template_id: params.fileId
	      }, null, null).then(function (response) {
	        _this.controller.executeRestAnswer(im_const.RestMethodHandler.imDiskFileCommit, response, message);
	      })["catch"](function (error) {
	        _this.controller.executeRestAnswer(im_const.RestMethodHandler.imDiskFileCommit, error, message);
	      });
	      return true;
	    }
	  }, {
	    key: "setUploadError",
	    value: function setUploadError(chatId, fileId) {
	      var messageId = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
	      this.controller.store.dispatch('files/update', {
	        chatId: chatId,
	        id: fileId,
	        fields: {
	          status: im_const.FileStatus.error,
	          progress: 0
	        }
	      });
	      if (messageId) {
	        this.controller.store.dispatch('messages/actionError', {
	          chatId: chatId,
	          id: messageId,
	          retry: false
	        });
	      }
	    }
	  }, {
	    key: "onTextareaFileSelected",
	    value: function onTextareaFileSelected(_ref) {
	      var event = _ref.data;
	      var fileInput = event && event.fileChangeEvent && event.fileChangeEvent.target.files.length > 0 ? event.fileChangeEvent : '';
	      if (!fileInput) {
	        return false;
	      }
	      this.uploadFile(fileInput);
	    }
	  }, {
	    key: "addMessageWithFile",
	    value: function addMessageWithFile(event) {
	      var _this2 = this;
	      var message = event.getData();
	      if (!this.getDiskFolderId()) {
	        this.requestDiskFolderId(message.chatId).then(function () {
	          _this2.addMessageWithFile(event);
	        })["catch"](function (error) {
	          im_lib_logger.Logger.error('addMessageWithFile error', error);
	          return false;
	        });
	        return false;
	      }
	      this.uploader.addTask({
	        taskId: message.file.id,
	        fileData: message.file.source.file,
	        fileName: message.file.source.file.name,
	        generateUniqueName: true,
	        diskFolderId: this.getDiskFolderId(),
	        previewBlob: message.file.previewBlob
	      });
	    }
	  }, {
	    key: "uploadFile",
	    value: function uploadFile(event) {
	      if (!event) {
	        return false;
	      }
	      this.uploader.addFilesFromEvent(event);
	    }
	  }, {
	    key: "destroy",
	    value: function destroy() {
	      if (this.uploader) {
	        this.uploader.unsubscribeAll();
	      }
	      main_core_events.EventEmitter.unsubscribe(im_const.EventType.textarea.fileSelected, this.onTextareaFileSelectedHandler);
	      main_core_events.EventEmitter.unsubscribe(im_const.EventType.uploader.addMessageWithFile, this.addMessageWithFileHandler);
	      main_core_events.EventEmitter.unsubscribe(im_const.EventType.dialog.clickOnUploadCancel, this.onClickOnUploadCancelHandler);
	    }
	  }, {
	    key: "getChatId",
	    value: function getChatId() {
	      return this.controller.store.state.application.dialog.chatId;
	    }
	  }, {
	    key: "getDialogId",
	    value: function getDialogId() {
	      return this.controller.store.state.application.dialog.dialogId;
	    }
	  }, {
	    key: "getDiskFolderId",
	    value: function getDiskFolderId() {
	      return this.controller.store.state.application.dialog.diskFolderId;
	    }
	  }, {
	    key: "getCurrentUser",
	    value: function getCurrentUser() {
	      return this.controller.store.getters['users/get'](this.controller.store.state.application.common.userId, true);
	    }
	  }, {
	    key: "getMessageByFileId",
	    value: function getMessageByFileId(fileId, eventData) {
	      var chatMessages = this.controller.store.getters['messages/get'](this.getChatId());
	      var messageWithFile = chatMessages.find(function (message) {
	        var _message$params;
	        if (main_core.Type.isArray((_message$params = message.params) === null || _message$params === void 0 ? void 0 : _message$params.FILE_ID)) {
	          return message.params.FILE_ID.includes(fileId);
	        }
	        return false;
	      });
	      if (!messageWithFile) {
	        return;
	      }
	      return {
	        id: messageWithFile.id,
	        chatId: messageWithFile.chatId,
	        dialogId: this.getDialogId(),
	        text: messageWithFile.text,
	        file: {
	          id: fileId,
	          source: eventData,
	          previewBlob: eventData.previewData
	        },
	        sending: true
	      };
	    }
	  }, {
	    key: "requestDiskFolderId",
	    value: function requestDiskFolderId(chatId) {
	      var _this3 = this;
	      return new Promise(function (resolve, reject) {
	        if (_this3.isRequestingDiskFolderId || _this3.getDiskFolderId()) {
	          _this3.isRequestingDiskFolderId = false;
	          resolve();
	          return;
	        }
	        _this3.isRequestingDiskFolderId = true;
	        _this3.restClient.callMethod(im_const.RestMethod.imDiskFolderGet, {
	          chat_id: chatId
	        }).then(function (response) {
	          _this3.isRequestingDiskFolderId = false;
	          _this3.controller.executeRestAnswer(im_const.RestMethodHandler.imDiskFolderGet, response);
	          resolve();
	        })["catch"](function (error) {
	          _this3.isRequestingDiskFolderId = false;
	          _this3.controller.executeRestAnswer(im_const.RestMethodHandler.imDiskFolderGet, error);
	          reject(error);
	        });
	      });
	    } // Uploader handlers
	  }, {
	    key: "onStartUploadHandler",
	    value: function onStartUploadHandler(event) {
	      var eventData = event.getData();
	      im_lib_logger.Logger.log('Uploader: onStartUpload', eventData);
	      this.controller.store.dispatch('files/update', {
	        chatId: this.getChatId(),
	        id: eventData.id,
	        fields: {
	          status: im_const.FileStatus.upload,
	          progress: 0
	        }
	      });
	    }
	  }, {
	    key: "onProgressHandler",
	    value: function onProgressHandler(event) {
	      var eventData = event.getData();
	      im_lib_logger.Logger.log('Uploader: onProgress', eventData);
	      this.controller.store.dispatch('files/update', {
	        chatId: this.getChatId(),
	        id: eventData.id,
	        fields: {
	          status: im_const.FileStatus.upload,
	          progress: eventData.progress === 100 ? 99 : eventData.progress
	        }
	      });
	    }
	  }, {
	    key: "onSelectFileHandler",
	    value: function onSelectFileHandler(event) {
	      var eventData = event.getData();
	      var file = eventData.file;
	      im_lib_logger.Logger.log('Uploader: onSelectFile', eventData);
	      var fileType = 'file';
	      if (file.type.toString().startsWith('image')) {
	        fileType = 'image';
	      } else if (file.type.toString().startsWith('video')) {
	        fileType = 'video';
	      }
	      this.controller.store.dispatch('files/add', {
	        chatId: this.getChatId(),
	        authorId: this.getCurrentUser().id,
	        name: file.name,
	        type: fileType,
	        extension: file.name.split('.').splice(-1)[0],
	        size: file.size,
	        image: !eventData.previewData ? false : {
	          width: eventData.previewDataWidth,
	          height: eventData.previewDataHeight
	        },
	        status: im_const.FileStatus.progress,
	        progress: 0,
	        authorName: this.getCurrentUser().name,
	        urlPreview: eventData.previewData ? URL.createObjectURL(eventData.previewData) : ''
	      }).then(function (fileId) {
	        main_core_events.EventEmitter.emit(im_const.EventType.textarea.sendMessage, {
	          text: '',
	          file: {
	            id: fileId,
	            source: eventData,
	            previewBlob: eventData.previewData
	          }
	        });
	      });
	    }
	  }, {
	    key: "onCompleteHandler",
	    value: function onCompleteHandler(event) {
	      var eventData = event.getData();
	      im_lib_logger.Logger.log('Uploader: onComplete', eventData);
	      this.controller.store.dispatch('files/update', {
	        chatId: this.getChatId(),
	        id: eventData.id,
	        fields: {
	          status: im_const.FileStatus.wait,
	          progress: 100
	        }
	      });
	      var messageWithFile = this.getMessageByFileId(eventData.id, eventData);
	      var fileType = this.controller.store.getters['files/get'](this.getChatId(), messageWithFile.file.id, true).type;
	      this.commitFile({
	        chatId: this.getChatId(),
	        uploadId: eventData.result.data.file.id,
	        messageText: messageWithFile.text,
	        messageId: messageWithFile.id,
	        fileId: messageWithFile.file.id,
	        fileType: fileType
	      }, messageWithFile);
	    }
	  }, {
	    key: "onUploadFileErrorHandler",
	    value: function onUploadFileErrorHandler(event) {
	      var eventData = event.getData();
	      im_lib_logger.Logger.log('Uploader: onUploadFileError', eventData);
	      var messageWithFile = this.getMessageByFileId(eventData.id, eventData);
	      if (messageWithFile) {
	        this.setUploadError(this.getChatId(), messageWithFile.file.id, messageWithFile.id);
	      }
	    }
	  }, {
	    key: "onCreateFileErrorHandler",
	    value: function onCreateFileErrorHandler(event) {
	      var eventData = event.getData();
	      im_lib_logger.Logger.log('Uploader: onCreateFileError', eventData);
	      var messageWithFile = this.getMessageByFileId(eventData.id, eventData);
	      if (messageWithFile) {
	        this.setUploadError(this.getChatId(), messageWithFile.file.id, messageWithFile.id);
	      }
	    }
	  }, {
	    key: "onClickOnUploadCancel",
	    value: function onClickOnUploadCancel(_ref2) {
	      var _this4 = this;
	      var event = _ref2.data;
	      var fileId = event.file.id;
	      var fileData = event.file;
	      var messageWithFile = this.getMessageByFileId(fileId, fileData);
	      if (!messageWithFile) {
	        return;
	      }
	      this.uploader.deleteTask(fileId);
	      this.controller.store.dispatch('messages/delete', {
	        chatId: this.getChatId(),
	        id: messageWithFile.id
	      }).then(function () {
	        _this4.controller.store.dispatch('files/delete', {
	          chatId: _this4.getChatId(),
	          id: messageWithFile.file.id
	        });
	      });
	    }
	  }, {
	    key: "getActionCommitFile",
	    value: function getActionCommitFile() {
	      return null;
	    }
	  }, {
	    key: "getActionUploadChunk",
	    value: function getActionUploadChunk() {
	      return null;
	    }
	  }, {
	    key: "getUploaderSenderOptions",
	    value: function getUploaderSenderOptions() {
	      return {
	        actionUploadChunk: this.getActionUploadChunk(),
	        actionCommitFile: this.getActionCommitFile()
	      };
	    }
	  }]);
	  return TextareaUploadHandler;
	}();

	var TextareaDragHandler = /*#__PURE__*/function (_EventEmitter) {
	  babelHelpers.inherits(TextareaDragHandler, _EventEmitter);
	  function TextareaDragHandler(events) {
	    var _this;
	    babelHelpers.classCallCheck(this, TextareaDragHandler);
	    _this = babelHelpers.possibleConstructorReturn(this, babelHelpers.getPrototypeOf(TextareaDragHandler).call(this));
	    babelHelpers.defineProperty(babelHelpers.assertThisInitialized(_this), "isDragging", false);
	    babelHelpers.defineProperty(babelHelpers.assertThisInitialized(_this), "minimumHeight", 120);
	    babelHelpers.defineProperty(babelHelpers.assertThisInitialized(_this), "maximumHeight", 400);
	    _this.setEventNamespace('BX.IM.TextareaDragHandler');
	    _this.subscribeToEvents(events);
	    if (im_lib_utils.Utils.device.isMobile()) {
	      _this.maximumHeight = 200;
	    }
	    return _this;
	  }
	  babelHelpers.createClass(TextareaDragHandler, [{
	    key: "subscribeToEvents",
	    value: function subscribeToEvents(configEvents) {
	      var _this2 = this;
	      var events = main_core.Type.isObject(configEvents) ? configEvents : {};
	      Object.entries(events).forEach(function (_ref) {
	        var _ref2 = babelHelpers.slicedToArray(_ref, 2),
	          name = _ref2[0],
	          callback = _ref2[1];
	        if (main_core.Type.isFunction(callback)) {
	          _this2.subscribe(name, callback);
	        }
	      });
	    }
	  }, {
	    key: "onStartDrag",
	    value: function onStartDrag(event, currentHeight) {
	      if (this.isDragging) {
	        return;
	      }
	      this.isDragging = true;
	      event = event.changedTouches ? event.changedTouches[0] : event;
	      this.textareaDragCursorStartPoint = event.clientY;
	      this.textareaDragHeightStartPoint = currentHeight;
	      this.addTextareaDragEvents();
	    }
	  }, {
	    key: "onTextareaContinueDrag",
	    value: function onTextareaContinueDrag(event) {
	      if (!this.isDragging) {
	        return;
	      }
	      event = event.changedTouches ? event.changedTouches[0] : event;
	      this.textareaDragCursorControlPoint = event.clientY;
	      var maxPoint = Math.min(this.textareaDragHeightStartPoint + this.textareaDragCursorStartPoint - this.textareaDragCursorControlPoint, this.maximumHeight);
	      var newTextareaHeight = Math.max(maxPoint, this.minimumHeight);
	      this.emit(TextareaDragHandler.events.onHeightChange, {
	        newHeight: newTextareaHeight
	      });
	    }
	  }, {
	    key: "onTextareaStopDrag",
	    value: function onTextareaStopDrag() {
	      if (!this.isDragging) {
	        return;
	      }
	      this.isDragging = false;
	      this.removeTextareaDragEvents();
	      this.emit(TextareaDragHandler.events.onStopDrag);
	    }
	  }, {
	    key: "addTextareaDragEvents",
	    value: function addTextareaDragEvents() {
	      this.onContinueDragHandler = this.onTextareaContinueDrag.bind(this);
	      this.onStopDragHandler = this.onTextareaStopDrag.bind(this);
	      document.addEventListener('mousemove', this.onContinueDragHandler);
	      document.addEventListener('touchmove', this.onContinueDragHandler);
	      document.addEventListener('touchend', this.onStopDragHandler);
	      document.addEventListener('mouseup', this.onStopDragHandler);
	      document.addEventListener('mouseleave', this.onStopDragHandler);
	    }
	  }, {
	    key: "removeTextareaDragEvents",
	    value: function removeTextareaDragEvents() {
	      document.removeEventListener('mousemove', this.onContinueDragHandler);
	      document.removeEventListener('touchmove', this.onContinueDragHandler);
	      document.removeEventListener('touchend', this.onStopDragHandler);
	      document.removeEventListener('mouseup', this.onStopDragHandler);
	      document.removeEventListener('mouseleave', this.onStopDragHandler);
	    }
	  }, {
	    key: "destroy",
	    value: function destroy() {
	      this.removeTextareaDragEvents();
	    }
	  }]);
	  return TextareaDragHandler;
	}(main_core_events.EventEmitter);
	babelHelpers.defineProperty(TextareaDragHandler, "events", {
	  onHeightChange: 'onHeightChange',
	  onStopDrag: 'onStopDrag'
	});

	var DialogActionHandler = /*#__PURE__*/function () {
	  function DialogActionHandler($Bitrix) {
	    babelHelpers.classCallCheck(this, DialogActionHandler);
	    babelHelpers.defineProperty(this, "restClient", null);
	    this.restClient = $Bitrix.RestClient.get();
	    this.subscribeToEvents();
	  }
	  babelHelpers.createClass(DialogActionHandler, [{
	    key: "subscribeToEvents",
	    value: function subscribeToEvents() {
	      this.clickOnMentionHandler = this.onClickOnMention.bind(this);
	      this.clickOnUserNameHandler = this.onClickOnUserName.bind(this);
	      this.clickOnMessageMenuHandler = this.onClickOnMessageMenu.bind(this);
	      this.clickOnReadListHandler = this.onClickOnReadList.bind(this);
	      this.clickOnChatTeaserHandler = this.onClickOnChatTeaser.bind(this);
	      this.clickOnDialogHandler = this.onClickOnDialog.bind(this);
	      main_core_events.EventEmitter.subscribe(im_const.EventType.dialog.clickOnMention, this.clickOnMentionHandler);
	      main_core_events.EventEmitter.subscribe(im_const.EventType.dialog.clickOnUserName, this.clickOnUserNameHandler);
	      main_core_events.EventEmitter.subscribe(im_const.EventType.dialog.clickOnMessageMenu, this.clickOnMessageMenuHandler);
	      main_core_events.EventEmitter.subscribe(im_const.EventType.dialog.clickOnReadList, this.clickOnReadListHandler);
	      main_core_events.EventEmitter.subscribe(im_const.EventType.dialog.clickOnChatTeaser, this.clickOnChatTeaserHandler);
	      main_core_events.EventEmitter.subscribe(im_const.EventType.dialog.clickOnDialog, this.clickOnDialogHandler);
	    }
	  }, {
	    key: "onClickOnMention",
	    value: function onClickOnMention(_ref) {
	      var event = _ref.data;
	      if (event.type === 'USER') {
	        im_lib_logger.Logger.warn('DialogActionHandler: open user profile', event);
	      } else if (event.type === 'CHAT') {
	        im_lib_logger.Logger.warn('DialogActionHandler: open dialog from mention click', event);
	      } else if (event.type === 'CALL') {
	        im_lib_logger.Logger.warn('DialogActionHandler: open phone menu', event);
	      }
	    }
	  }, {
	    key: "onClickOnUserName",
	    value: function onClickOnUserName(_ref2) {
	      var event = _ref2.data;
	      main_core_events.EventEmitter.emit(im_const.EventType.textarea.insertText, {
	        text: "".concat(event.user.name, ", ")
	      });
	    }
	  }, {
	    key: "onClickOnMessageMenu",
	    value: function onClickOnMessageMenu(_ref3) {
	      var event = _ref3.data;
	      im_lib_logger.Logger.warn('DialogActionHandler: open message menu', event);
	    }
	  }, {
	    key: "onClickOnReadList",
	    value: function onClickOnReadList(_ref4) {
	      var event = _ref4.data;
	      im_lib_logger.Logger.warn('DialogActionHandler: open read list', event);
	    }
	  }, {
	    key: "onClickOnChatTeaser",
	    value: function onClickOnChatTeaser(_ref5) {
	      var event = _ref5.data;
	      this.joinParentChat(event.message.id, "chat".concat(event.message.params.CHAT_ID)).then(function (dialogId) {
	        im_lib_logger.Logger.warn('DialogActionHandler: open dialog from teaser click', dialogId);
	      })["catch"](function (error) {
	        console.error('DialogActionHandler: error joining parent chat', error);
	      });
	    }
	  }, {
	    key: "onClickOnDialog",
	    value: function onClickOnDialog() {
	      im_lib_logger.Logger.warn('DialogActionHandler: click on dialog');
	    }
	  }, {
	    key: "joinParentChat",
	    value: function joinParentChat(messageId, dialogId) {
	      var _this = this;
	      return new Promise(function (resolve, reject) {
	        if (!messageId || !dialogId) {
	          return reject();
	        }

	        // TODO: what is this for
	        if (typeof _this.tempJoinChat === 'undefined') {
	          _this.tempJoinChat = {};
	        } else if (_this.tempJoinChat['wait']) {
	          return reject();
	        }
	        _this.tempJoinChat['wait'] = true;
	        _this.restClient.callMethod(im_const.RestMethod.imChatParentJoin, {
	          'DIALOG_ID': dialogId,
	          'MESSAGE_ID': messageId
	        }).then(function () {
	          _this.tempJoinChat['wait'] = false;
	          _this.tempJoinChat[dialogId] = true;
	          return resolve(dialogId);
	        })["catch"](function () {
	          _this.tempJoinChat['wait'] = false;
	          return reject();
	        });
	      });
	    }
	  }, {
	    key: "unsubscribeEvents",
	    value: function unsubscribeEvents() {
	      main_core_events.EventEmitter.unsubscribe(im_const.EventType.dialog.clickOnMention, this.clickOnMentionHandler);
	      main_core_events.EventEmitter.unsubscribe(im_const.EventType.dialog.clickOnUserName, this.clickOnUserNameHandler);
	      main_core_events.EventEmitter.unsubscribe(im_const.EventType.dialog.clickOnMessageMenu, this.clickOnMessageMenuHandler);
	      main_core_events.EventEmitter.unsubscribe(im_const.EventType.dialog.clickOnReadList, this.clickOnReadListHandler);
	      main_core_events.EventEmitter.unsubscribe(im_const.EventType.dialog.clickOnChatTeaser, this.clickOnChatTeaserHandler);
	      main_core_events.EventEmitter.unsubscribe(im_const.EventType.dialog.clickOnDialog, this.clickOnDialogHandler);
	    }
	  }, {
	    key: "destroy",
	    value: function destroy() {
	      this.unsubscribeEvents();
	    }
	  }]);
	  return DialogActionHandler;
	}();

	exports.TextareaHandler = TextareaHandler;
	exports.TextareaDragHandler = TextareaDragHandler;
	exports.TextareaUploadHandler = TextareaUploadHandler;
	exports.SendMessageHandler = SendMessageHandler;
	exports.ReadingHandler = ReadingHandler;
	exports.ReactionHandler = ReactionHandler;
	exports.QuoteHandler = QuoteHandler;
	exports.DialogActionHandler = DialogActionHandler;

}((this.BX.Messenger.EventHandler = this.BX.Messenger.EventHandler || {}),BX.Messenger.Lib,BX.Messenger.Lib,BX.Messenger.Lib,BX.Messenger.Lib,BX,BX.Event,BX.Messenger.Const,BX.Messenger.Lib));





// file: /bitrix/js/ui/vue/components/smiles/dist/smiles.bundle.js
(function (exports,ui_fonts_opensans,ui_vue_directives_lazyload,ui_vue,ui_dexie) {
	'use strict';

	function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
	function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { babelHelpers.defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
	var SmileManager = /*#__PURE__*/function () {
	  function SmileManager(restClient) {
	    babelHelpers.classCallCheck(this, SmileManager);
	    if (typeof restClient !== 'undefined') {
	      this.restClient = restClient;
	    } else {
	      this.restClient = new BX.RestClient();
	    }
	    this.db = new ui_dexie.Dexie('bx-ui-smiles');
	    this.db.version(1).stores({
	      sets: "id, parentId, name, type, image",
	      smiles: "id, setId, name, image, typing, width, height, originalWidth, originalHeight, definition"
	    });
	  }
	  babelHelpers.createClass(SmileManager, [{
	    key: "loadFromCache",
	    value: function loadFromCache() {
	      var _this = this;
	      var promise = new BX.Promise();
	      var sets = [];
	      var smiles = [];
	      this.db.transaction('r', this.db.sets, this.db.smiles, function () {
	        _this.db.sets.each(function (set) {
	          return _this.db.smiles.where('setId').equals(set.id).first().then(function (smile) {
	            sets.push(_objectSpread(_objectSpread({}, set), {}, {
	              image: smile.image
	            }));
	          })["catch"](function (error) {
	            return promise.reject(error);
	          });
	        }).then(function () {
	          return _this.db.smiles.where('setId').equals(sets[0].id).each(function (smile) {
	            smiles.push(smile);
	          });
	        }).then(function () {
	          var promiseResult = {
	            sets: sets,
	            smiles: smiles
	          };
	          promise.resolve(promiseResult);
	        })["catch"](function (error) {
	          return promise.reject(error);
	        });
	      });
	      return promise;
	    }
	  }, {
	    key: "loadFromServer",
	    value: function loadFromServer() {
	      var _this2 = this;
	      var promise = new BX.Promise();
	      this.restClient.callMethod('smile.get').then(function (result) {
	        var sets = [];
	        var smiles = [];
	        var answer = result.data();
	        var setImage = {};
	        answer.smiles = answer.smiles.map(function (smile) {
	          if (!setImage[smile.setId]) {
	            setImage[smile.setId] = smile.image;
	          }
	          var originalWidth = smile.width;
	          if (smile.definition == 'HD') {
	            originalWidth = originalWidth * 2;
	          } else if (smile.definition == 'UHD') {
	            originalWidth = originalWidth * 4;
	          }
	          var originalHeight = smile.height;
	          if (smile.definition == 'HD') {
	            originalHeight = originalHeight * 2;
	          } else if (smile.definition == 'UHD') {
	            originalHeight = originalHeight * 4;
	          }
	          return _objectSpread(_objectSpread({}, smile), {}, {
	            originalWidth: originalWidth,
	            originalHeight: originalHeight
	          });
	        });
	        answer.sets.forEach(function (set) {
	          sets.push(_objectSpread(_objectSpread({}, set), {}, {
	            image: setImage[set.id]
	          }));
	        });
	        answer.smiles.forEach(function (smile) {
	          if (smile.setId == sets[0].id) {
	            smiles.push(smile);
	          }
	        });
	        var promiseResult = {
	          sets: sets,
	          smiles: smiles
	        };
	        promise.resolve(promiseResult);
	        _this2.db.smiles.clear().then(function () {
	          return _this2.db.sets.clear().then(function () {
	            _this2.db.sets.bulkAdd(sets);
	            _this2.db.smiles.bulkAdd(answer.smiles);
	          })["catch"](function (error) {
	            return promise.reject(error);
	          });
	        })["catch"](function (error) {
	          return promise.reject(error);
	        });
	      })["catch"](function (error) {
	        return promise.reject(error);
	      });
	      return promise;
	    }
	  }, {
	    key: "changeSet",
	    value: function changeSet(setId) {
	      var promise = new BX.Promise();
	      this.db.smiles.where('setId').equals(setId).toArray(function (smiles) {
	        promise.resolve(smiles);
	      })["catch"](function (error) {
	        return promise.reject(error);
	      });
	      return promise;
	    }
	  }]);
	  return SmileManager;
	}();

	var emoji = [{
	  id: 1,
	  code: 'PEOPLE',
	  showForWindows: true,
	  emoji: [{
	    symbol: "\uD83D\uDE00"
	  }, {
	    symbol: "\uD83D\uDE03"
	  }, {
	    symbol: "\uD83D\uDE04"
	  }, {
	    symbol: "\uD83D\uDE01"
	  }, {
	    symbol: "\uD83D\uDE06"
	  }, {
	    symbol: "\uD83D\uDE05"
	  }, {
	    symbol: "\uD83D\uDE02"
	  }, {
	    symbol: "\uD83E\uDD23"
	  }, {
	    symbol: "\uD83D\uDE0A"
	  }, {
	    symbol: "\uD83D\uDE07"
	  }, {
	    symbol: "\uD83D\uDE42"
	  }, {
	    symbol: "\uD83D\uDE43"
	  }, {
	    symbol: "\uD83D\uDE09"
	  }, {
	    symbol: "\uD83D\uDE0C"
	  }, {
	    symbol: "\uD83D\uDE0D"
	  }, {
	    symbol: "\uD83E\uDD70"
	  }, {
	    symbol: "\uD83D\uDE18"
	  }, {
	    symbol: "\uD83D\uDE17"
	  }, {
	    symbol: "\uD83D\uDE19"
	  }, {
	    symbol: "\uD83D\uDE1A"
	  }, {
	    symbol: "\uD83D\uDE0B"
	  }, {
	    symbol: "\uD83D\uDE1B"
	  }, {
	    symbol: "\uD83D\uDE1D"
	  }, {
	    symbol: "\uD83D\uDE1C"
	  }, {
	    symbol: "\uD83E\uDD2A"
	  }, {
	    symbol: "\uD83E\uDD28"
	  }, {
	    symbol: "\uD83E\uDDD0"
	  }, {
	    symbol: "\uD83E\uDD13"
	  }, {
	    symbol: "\uD83D\uDE0E"
	  }, {
	    symbol: "\uD83E\uDD29"
	  }, {
	    symbol: "\uD83E\uDD73"
	  }, {
	    symbol: "\uD83D\uDE0F"
	  }, {
	    symbol: "\uD83D\uDE12"
	  }, {
	    symbol: "\uD83D\uDE1E"
	  }, {
	    symbol: "\uD83D\uDE14"
	  }, {
	    symbol: "\uD83D\uDE1F"
	  }, {
	    symbol: "\uD83D\uDE15"
	  }, {
	    symbol: "\u2639"
	  }, {
	    symbol: "\uD83D\uDE41"
	  }, {
	    symbol: "\uD83D\uDE23"
	  }, {
	    symbol: "\uD83D\uDE2B"
	  }, {
	    symbol: "\uD83D\uDE29"
	  }, {
	    symbol: "\uD83E\uDD7A"
	  }, {
	    symbol: "\uD83D\uDE22"
	  }, {
	    symbol: "\uD83D\uDE2D"
	  }, {
	    symbol: "\uD83D\uDE24"
	  }, {
	    symbol: "\uD83D\uDE20"
	  }, {
	    symbol: "\uD83D\uDE21"
	  }, {
	    symbol: "\uD83E\uDD2C"
	  }, {
	    symbol: "\uD83E\uDD2F"
	  }, {
	    symbol: "\uD83D\uDE33"
	  }, {
	    symbol: "\uD83E\uDD75"
	  }, {
	    symbol: "\uD83E\uDD76"
	  }, {
	    symbol: "\uD83D\uDE31"
	  }, {
	    symbol: "\uD83D\uDE28"
	  }, {
	    symbol: "\uD83D\uDE30"
	  }, {
	    symbol: "\uD83D\uDE25"
	  }, {
	    symbol: "\uD83D\uDE13"
	  }, {
	    symbol: "\uD83E\uDD17"
	  }, {
	    symbol: "\uD83E\uDD14"
	  }, {
	    symbol: "\uD83E\uDD2D"
	  }, {
	    symbol: "\uD83E\uDD2B"
	  }, {
	    symbol: "\uD83E\uDD25"
	  }, {
	    symbol: "\uD83D\uDE36"
	  }, {
	    symbol: "\uD83D\uDE10"
	  }, {
	    symbol: "\uD83D\uDE11"
	  }, {
	    symbol: "\uD83D\uDE2C"
	  }, {
	    symbol: "\uD83D\uDE44"
	  }, {
	    symbol: "\uD83D\uDE2F"
	  }, {
	    symbol: "\uD83D\uDE26"
	  }, {
	    symbol: "\uD83D\uDE27"
	  }, {
	    symbol: "\uD83D\uDE2E"
	  }, {
	    symbol: "\uD83D\uDE32"
	  }, {
	    symbol: "\uD83D\uDE34"
	  }, {
	    symbol: "\uD83E\uDD24"
	  }, {
	    symbol: "\uD83D\uDE2A"
	  }, {
	    symbol: "\uD83D\uDE35"
	  }, {
	    symbol: "\uD83E\uDD10"
	  }, {
	    symbol: "\uD83E\uDD74"
	  }, {
	    symbol: "\uD83E\uDD22"
	  }, {
	    symbol: "\uD83E\uDD2E"
	  }, {
	    symbol: "\uD83E\uDD27"
	  }, {
	    symbol: "\uD83D\uDE37"
	  }, {
	    symbol: "\uD83E\uDD12"
	  }, {
	    symbol: "\uD83E\uDD15"
	  }, {
	    symbol: "\uD83E\uDD11"
	  }, {
	    symbol: "\uD83E\uDD20"
	  }, {
	    symbol: "\uD83D\uDE08"
	  }, {
	    symbol: "\uD83D\uDC7F"
	  }, {
	    symbol: "\uD83D\uDC79"
	  }, {
	    symbol: "\uD83D\uDC7A"
	  }, {
	    symbol: "\uD83E\uDD21"
	  }, {
	    symbol: "\uD83D\uDCA9"
	  }, {
	    symbol: "\uD83D\uDC7B"
	  }, {
	    symbol: "\u2620"
	  }, {
	    symbol: "\uD83D\uDC80"
	  }, {
	    symbol: "\uD83D\uDC7D"
	  }, {
	    symbol: "\uD83D\uDC7E"
	  }, {
	    symbol: "\uD83E\uDD16"
	  }, {
	    symbol: "\uD83C\uDF83"
	  }, {
	    symbol: "\uD83D\uDE3A"
	  }, {
	    symbol: "\uD83D\uDE38"
	  }, {
	    symbol: "\uD83D\uDE39"
	  }, {
	    symbol: "\uD83D\uDE3B"
	  }, {
	    symbol: "\uD83D\uDE3C"
	  }, {
	    symbol: "\uD83D\uDE3D"
	  }, {
	    symbol: "\uD83D\uDE40"
	  }, {
	    symbol: "\uD83D\uDE3F"
	  }, {
	    symbol: "\uD83D\uDE3E"
	  }, {
	    symbol: "\uD83E\uDD32"
	  }, {
	    symbol: "\uD83D\uDC50"
	  }, {
	    symbol: "\uD83D\uDE4C"
	  }, {
	    symbol: "\uD83D\uDC4F"
	  }, {
	    symbol: "\uD83E\uDD1D"
	  }, {
	    symbol: "\uD83D\uDC4D"
	  }, {
	    symbol: "\uD83D\uDC4E"
	  }, {
	    symbol: "\uD83D\uDC4A"
	  }, {
	    symbol: "\u270A"
	  }, {
	    symbol: "\uD83E\uDD1B"
	  }, {
	    symbol: "\uD83E\uDD1C"
	  }, {
	    symbol: "\uD83E\uDD1E"
	  }, {
	    symbol: "\u270C"
	  }, {
	    symbol: "\uD83E\uDD1F"
	  }, {
	    symbol: "\uD83E\uDD18"
	  }, {
	    symbol: "\uD83D\uDC4C"
	  }, {
	    symbol: "\uD83D\uDC48"
	  }, {
	    symbol: "\uD83D\uDC49"
	  }, {
	    symbol: "\uD83D\uDC46"
	  }, {
	    symbol: "\uD83D\uDC47"
	  }, {
	    symbol: "\uD83E\uDD1A"
	  }, {
	    symbol: "\uD83D\uDD90"
	  }, {
	    symbol: "\uD83D\uDD96"
	  }, {
	    symbol: "\uD83D\uDC4B"
	  }, {
	    symbol: "\uD83E\uDD19"
	  }, {
	    symbol: "\uD83D\uDCAA"
	  }, {
	    symbol: "\uD83D\uDD95"
	  }, {
	    symbol: "\u270D"
	  }, {
	    symbol: "\uD83D\uDE4F"
	  }, {
	    symbol: "\uD83E\uDDB6"
	  }, {
	    symbol: "\uD83E\uDDB5"
	  }, {
	    symbol: "\uD83D\uDC84"
	  }, {
	    symbol: "\uD83D\uDC8B"
	  }, {
	    symbol: "\uD83D\uDC44"
	  }, {
	    symbol: "\uD83E\uDDB7"
	  }, {
	    symbol: "\uD83D\uDC45"
	  }, {
	    symbol: "\uD83D\uDC43"
	  }, {
	    symbol: "\uD83D\uDC63"
	  }, {
	    symbol: "\uD83D\uDC41"
	  }, {
	    symbol: "\uD83D\uDC40"
	  }, {
	    symbol: "\uD83E\uDDE0"
	  }, {
	    symbol: "\uD83D\uDDE3"
	  }, {
	    symbol: "\uD83D\uDC64"
	  }, {
	    symbol: "\uD83D\uDC65"
	  }, {
	    symbol: "\uD83D\uDC76"
	  }, {
	    symbol: "\uD83D\uDC67"
	  }, {
	    symbol: "\uD83E\uDDD2"
	  }, {
	    symbol: "\uD83D\uDC66"
	  }, {
	    symbol: "\uD83D\uDC69"
	  }, {
	    symbol: "\uD83E\uDDD1"
	  }, {
	    symbol: "\uD83D\uDC68"
	  }, {
	    symbol: "\uD83D\uDC71"
	  }, {
	    symbol: "\uD83E\uDDD4"
	  }, {
	    symbol: "\uD83D\uDC75"
	  }, {
	    symbol: "\uD83E\uDDD3"
	  }, {
	    symbol: "\uD83D\uDC74"
	  }, {
	    symbol: "\uD83D\uDC72"
	  }, {
	    symbol: "\uD83D\uDC73"
	  }, {
	    symbol: "\uD83E\uDDD5"
	  }, {
	    symbol: "\uD83D\uDC6E"
	  }, {
	    symbol: "\uD83D\uDC77"
	  }, {
	    symbol: "\uD83D\uDC82"
	  }, {
	    symbol: "\uD83D\uDD75"
	  }, {
	    symbol: "\u2695"
	  }, {
	    symbol: "\uD83C\uDF3E"
	  }, {
	    symbol: "\uD83C\uDF73"
	  }, {
	    symbol: "\uD83C\uDF93"
	  }, {
	    symbol: "\uD83C\uDFA4"
	  }, {
	    symbol: "\uD83C\uDFEB"
	  }, {
	    symbol: "\uD83C\uDFED"
	  }, {
	    symbol: "\uD83D\uDCBB"
	  }, {
	    symbol: "\uD83D\uDCBC"
	  }, {
	    symbol: "\uD83D\uDC69"
	  }, {
	    symbol: "\u2764"
	  }, {
	    symbol: "\uD83D\uDD27"
	  }, {
	    symbol: "\uD83D\uDD2C"
	  }, {
	    symbol: "\uD83C\uDFA8"
	  }, {
	    symbol: "\uD83D\uDE92"
	  }, {
	    symbol: "\uD83D\uDE80"
	  }, {
	    symbol: "\uD83D\uDC70"
	  }, {
	    symbol: "\uD83E\uDD35"
	  }, {
	    symbol: "\uD83D\uDC78"
	  }, {
	    symbol: "\uD83E\uDD34"
	  }, {
	    symbol: "\uD83E\uDDB8"
	  }, {
	    symbol: "\uD83E\uDDB9"
	  }, {
	    symbol: "\uD83E\uDD36"
	  }, {
	    symbol: "\uD83C\uDF85"
	  }, {
	    symbol: "\uD83E\uDDD9"
	  }, {
	    symbol: "\uD83E\uDDDD"
	  }, {
	    symbol: "\uD83E\uDDDB"
	  }, {
	    symbol: "\uD83E\uDDDF"
	  }, {
	    symbol: "\uD83E\uDDDE"
	  }, {
	    symbol: "\uD83E\uDDDC"
	  }, {
	    symbol: "\uD83E\uDDDA"
	  }, {
	    symbol: "\uD83D\uDC7C"
	  }, {
	    symbol: "\uD83E\uDD30"
	  }, {
	    symbol: "\uD83E\uDD31"
	  }, {
	    symbol: "\uD83D\uDE47"
	  }, {
	    symbol: "\uD83D\uDC81"
	  }, {
	    symbol: "\uD83D\uDE45"
	  }, {
	    symbol: "\uD83D\uDE46"
	  }, {
	    symbol: "\uD83D\uDE4B"
	  }, {
	    symbol: "\uD83E\uDD26"
	  }, {
	    symbol: "\uD83E\uDD37"
	  }, {
	    symbol: "\uD83D\uDE4E"
	  }, {
	    symbol: "\uD83D\uDE4D"
	  }, {
	    symbol: "\uD83D\uDC87"
	  }, {
	    symbol: "\uD83D\uDC86"
	  }, {
	    symbol: "\uD83E\uDDD6"
	  }, {
	    symbol: "\uD83D\uDC85"
	  }, {
	    symbol: "\uD83E\uDD33"
	  }, {
	    symbol: "\uD83D\uDC83"
	  }, {
	    symbol: "\uD83D\uDD7A"
	  }, {
	    symbol: "\uD83D\uDC6F"
	  }, {
	    symbol: "\uD83D\uDD74"
	  }, {
	    symbol: "\uD83D\uDEB6"
	  }, {
	    symbol: "\uD83C\uDFC3"
	  }, {
	    symbol: "\uD83D\uDC6B"
	  }, {
	    symbol: "\uD83D\uDC6D"
	  }, {
	    symbol: "\uD83D\uDC6C"
	  }, {
	    symbol: "\uD83D\uDC91"
	  }, {
	    symbol: "\uD83D\uDC8F"
	  }, {
	    symbol: "\uD83D\uDC6A"
	  }, {
	    symbol: "\uD83E\uDDF6"
	  }, {
	    symbol: "\uD83E\uDDF5"
	  }, {
	    symbol: "\uD83E\uDDE5"
	  }, {
	    symbol: "\uD83E\uDD7C"
	  }, {
	    symbol: "\uD83D\uDC5A"
	  }, {
	    symbol: "\uD83D\uDC55"
	  }, {
	    symbol: "\uD83D\uDC56"
	  }, {
	    symbol: "\uD83D\uDC54"
	  }, {
	    symbol: "\uD83D\uDC57"
	  }, {
	    symbol: "\uD83D\uDC59"
	  }, {
	    symbol: "\uD83D\uDC58"
	  }, {
	    symbol: "\uD83E\uDD7F"
	  }, {
	    symbol: "\uD83D\uDC60"
	  }, {
	    symbol: "\uD83D\uDC61"
	  }, {
	    symbol: "\uD83D\uDC62"
	  }, {
	    symbol: "\uD83D\uDC5E"
	  }, {
	    symbol: "\uD83D\uDC5F"
	  }, {
	    symbol: "\uD83E\uDD7E"
	  }, {
	    symbol: "\uD83E\uDDE6"
	  }, {
	    symbol: "\uD83E\uDDE4"
	  }, {
	    symbol: "\uD83E\uDDE3"
	  }, {
	    symbol: "\uD83C\uDFA9"
	  }, {
	    symbol: "\uD83E\uDDE2"
	  }, {
	    symbol: "\uD83D\uDC52"
	  }, {
	    symbol: "\uD83C\uDF93"
	  }, {
	    symbol: "\u26D1"
	  }, {
	    symbol: "\uD83D\uDC51"
	  }, {
	    symbol: "\uD83D\uDC8D"
	  }, {
	    symbol: "\uD83D\uDC5D"
	  }, {
	    symbol: "\uD83D\uDC5B"
	  }, {
	    symbol: "\uD83D\uDC5C"
	  }, {
	    symbol: "\uD83D\uDCBC"
	  }, {
	    symbol: "\uD83C\uDF92"
	  }, {
	    symbol: "\uD83E\uDDF3"
	  }, {
	    symbol: "\uD83D\uDC53"
	  }, {
	    symbol: "\uD83D\uDD76"
	  }, {
	    symbol: "\uD83E\uDD7D"
	  }, {
	    symbol: "\uD83C\uDF02"
	  }]
	}, {
	  id: 2,
	  code: 'ANIMALS',
	  showForWindows: true,
	  emoji: [{
	    symbol: "\uD83D\uDC36"
	  }, {
	    symbol: "\uD83D\uDC31"
	  }, {
	    symbol: "\uD83D\uDC2D"
	  }, {
	    symbol: "\uD83D\uDC39"
	  }, {
	    symbol: "\uD83D\uDC30"
	  }, {
	    symbol: "\uD83E\uDD8A"
	  }, {
	    symbol: "\uD83D\uDC3B"
	  }, {
	    symbol: "\uD83D\uDC3C"
	  }, {
	    symbol: "\uD83D\uDC28"
	  }, {
	    symbol: "\uD83D\uDC2F"
	  }, {
	    symbol: "\uD83E\uDD81"
	  }, {
	    symbol: "\uD83D\uDC2E"
	  }, {
	    symbol: "\uD83D\uDC37"
	  }, {
	    symbol: "\uD83D\uDC3D"
	  }, {
	    symbol: "\uD83D\uDC38"
	  }, {
	    symbol: "\uD83D\uDC35"
	  }, {
	    symbol: "\uD83D\uDE48"
	  }, {
	    symbol: "\uD83D\uDE49"
	  }, {
	    symbol: "\uD83D\uDE4A"
	  }, {
	    symbol: "\uD83D\uDC12"
	  }, {
	    symbol: "\uD83D\uDC14"
	  }, {
	    symbol: "\uD83D\uDC27"
	  }, {
	    symbol: "\uD83D\uDC26"
	  }, {
	    symbol: "\uD83D\uDC24"
	  }, {
	    symbol: "\uD83D\uDC23"
	  }, {
	    symbol: "\uD83D\uDC25"
	  }, {
	    symbol: "\uD83E\uDD86"
	  }, {
	    symbol: "\uD83E\uDD85"
	  }, {
	    symbol: "\uD83E\uDD89"
	  }, {
	    symbol: "\uD83E\uDD87"
	  }, {
	    symbol: "\uD83D\uDC3A"
	  }, {
	    symbol: "\uD83D\uDC17"
	  }, {
	    symbol: "\uD83D\uDC34"
	  }, {
	    symbol: "\uD83E\uDD84"
	  }, {
	    symbol: "\uD83D\uDC1D"
	  }, {
	    symbol: "\uD83D\uDC1B"
	  }, {
	    symbol: "\uD83E\uDD8B"
	  }, {
	    symbol: "\uD83D\uDC0C"
	  }, {
	    symbol: "\uD83D\uDC1E"
	  }, {
	    symbol: "\uD83D\uDC1C"
	  }, {
	    symbol: "\uD83E\uDD9F"
	  }, {
	    symbol: "\uD83E\uDD97"
	  }, {
	    symbol: "\uD83D\uDD77"
	  }, {
	    symbol: "\uD83D\uDD78"
	  }, {
	    symbol: "\uD83E\uDD82"
	  }, {
	    symbol: "\uD83D\uDC22"
	  }, {
	    symbol: "\uD83D\uDC0D"
	  }, {
	    symbol: "\uD83E\uDD8E"
	  }, {
	    symbol: "\uD83E\uDD96"
	  }, {
	    symbol: "\uD83E\uDD95"
	  }, {
	    symbol: "\uD83D\uDC19"
	  }, {
	    symbol: "\uD83E\uDD91"
	  }, {
	    symbol: "\uD83E\uDD90"
	  }, {
	    symbol: "\uD83E\uDD9E"
	  }, {
	    symbol: "\uD83E\uDD80"
	  }, {
	    symbol: "\uD83D\uDC21"
	  }, {
	    symbol: "\uD83D\uDC20"
	  }, {
	    symbol: "\uD83D\uDC1F"
	  }, {
	    symbol: "\uD83D\uDC2C"
	  }, {
	    symbol: "\uD83D\uDC33"
	  }, {
	    symbol: "\uD83D\uDC0B"
	  }, {
	    symbol: "\uD83E\uDD88"
	  }, {
	    symbol: "\uD83D\uDC0A"
	  }, {
	    symbol: "\uD83D\uDC05"
	  }, {
	    symbol: "\uD83D\uDC06"
	  }, {
	    symbol: "\uD83E\uDD93"
	  }, {
	    symbol: "\uD83E\uDD8D"
	  }, {
	    symbol: "\uD83D\uDC18"
	  }, {
	    symbol: "\uD83E\uDD9B"
	  }, {
	    symbol: "\uD83E\uDD8F"
	  }, {
	    symbol: "\uD83D\uDC2A"
	  }, {
	    symbol: "\uD83D\uDC2B"
	  }, {
	    symbol: "\uD83E\uDD92"
	  }, {
	    symbol: "\uD83E\uDD98"
	  }, {
	    symbol: "\uD83D\uDC03"
	  }, {
	    symbol: "\uD83D\uDC02"
	  }, {
	    symbol: "\uD83D\uDC04"
	  }, {
	    symbol: "\uD83D\uDC0E"
	  }, {
	    symbol: "\uD83D\uDC16"
	  }, {
	    symbol: "\uD83D\uDC0F"
	  }, {
	    symbol: "\uD83D\uDC11"
	  }, {
	    symbol: "\uD83E\uDD99"
	  }, {
	    symbol: "\uD83D\uDC10"
	  }, {
	    symbol: "\uD83E\uDD8C"
	  }, {
	    symbol: "\uD83D\uDC15"
	  }, {
	    symbol: "\uD83D\uDC29"
	  }, {
	    symbol: "\uD83D\uDC08"
	  }, {
	    symbol: "\uD83D\uDC13"
	  }, {
	    symbol: "\uD83E\uDD83"
	  }, {
	    symbol: "\uD83E\uDD9A"
	  }, {
	    symbol: "\uD83E\uDD9C"
	  }, {
	    symbol: "\uD83E\uDDA2"
	  }, {
	    symbol: "\uD83D\uDD4A"
	  }, {
	    symbol: "\uD83D\uDC07"
	  }, {
	    symbol: "\uD83E\uDD9D"
	  }, {
	    symbol: "\uD83E\uDDA1"
	  }, {
	    symbol: "\uD83D\uDC01"
	  }, {
	    symbol: "\uD83D\uDC00"
	  }, {
	    symbol: "\uD83D\uDC3F"
	  }, {
	    symbol: "\uD83E\uDD94"
	  }, {
	    symbol: "\uD83D\uDC3E"
	  }, {
	    symbol: "\uD83D\uDC09"
	  }, {
	    symbol: "\uD83D\uDC32"
	  }, {
	    symbol: "\uD83C\uDF35"
	  }, {
	    symbol: "\uD83C\uDF84"
	  }, {
	    symbol: "\uD83C\uDF32"
	  }, {
	    symbol: "\uD83C\uDF33"
	  }, {
	    symbol: "\uD83C\uDF34"
	  }, {
	    symbol: "\uD83C\uDF31"
	  }, {
	    symbol: "\uD83C\uDF3F"
	  }, {
	    symbol: "\u2618"
	  }, {
	    symbol: "\uD83C\uDF40"
	  }, {
	    symbol: "\uD83C\uDF8D"
	  }, {
	    symbol: "\uD83C\uDF8B"
	  }, {
	    symbol: "\uD83C\uDF43"
	  }, {
	    symbol: "\uD83C\uDF42"
	  }, {
	    symbol: "\uD83C\uDF41"
	  }, {
	    symbol: "\uD83C\uDF44"
	  }, {
	    symbol: "\uD83D\uDC1A"
	  }, {
	    symbol: "\uD83C\uDF3E"
	  }, {
	    symbol: "\uD83D\uDC90"
	  }, {
	    symbol: "\uD83C\uDF37"
	  }, {
	    symbol: "\uD83C\uDF39"
	  }, {
	    symbol: "\uD83E\uDD40"
	  }, {
	    symbol: "\uD83C\uDF3A"
	  }, {
	    symbol: "\uD83C\uDF38"
	  }, {
	    symbol: "\uD83C\uDF3C"
	  }, {
	    symbol: "\uD83C\uDF3B"
	  }, {
	    symbol: "\uD83C\uDF1E"
	  }, {
	    symbol: "\uD83C\uDF1D"
	  }, {
	    symbol: "\uD83C\uDF1B"
	  }, {
	    symbol: "\uD83C\uDF1C"
	  }, {
	    symbol: "\uD83C\uDF1A"
	  }, {
	    symbol: "\uD83C\uDF15"
	  }, {
	    symbol: "\uD83C\uDF16"
	  }, {
	    symbol: "\uD83C\uDF17"
	  }, {
	    symbol: "\uD83C\uDF18"
	  }, {
	    symbol: "\uD83C\uDF11"
	  }, {
	    symbol: "\uD83C\uDF12"
	  }, {
	    symbol: "\uD83C\uDF13"
	  }, {
	    symbol: "\uD83C\uDF14"
	  }, {
	    symbol: "\uD83C\uDF19"
	  }, {
	    symbol: "\uD83C\uDF0E"
	  }, {
	    symbol: "\uD83C\uDF0D"
	  }, {
	    symbol: "\uD83C\uDF0F"
	  }, {
	    symbol: "\uD83D\uDCAB"
	  }, {
	    symbol: "\u2B50"
	  }, {
	    symbol: "\uD83C\uDF1F"
	  }, {
	    symbol: "\u2728"
	  }, {
	    symbol: "\u26A1"
	  }, {
	    symbol: "\u2604"
	  }, {
	    symbol: "\uD83D\uDCA5"
	  }, {
	    symbol: "\uD83D\uDD25"
	  }, {
	    symbol: "\uD83C\uDF2A"
	  }, {
	    symbol: "\uD83C\uDF08"
	  }, {
	    symbol: "\u2600"
	  }, {
	    symbol: "\uD83C\uDF24"
	  }, {
	    symbol: "\uD83C\uDF25"
	  }, {
	    symbol: "\uD83C\uDF26"
	  }, {
	    symbol: "\uD83C\uDF27"
	  }, {
	    symbol: "\uD83C\uDF29"
	  }, {
	    symbol: "\uD83C\uDF28"
	  }, {
	    symbol: "\u2744"
	  }, {
	    symbol: "\u2603"
	  }, {
	    symbol: "\u26C4"
	  }, {
	    symbol: "\uD83C\uDF2C"
	  }, {
	    symbol: "\uD83D\uDCA8"
	  }, {
	    symbol: "\uD83D\uDCA7"
	  }, {
	    symbol: "\uD83D\uDCA6"
	  }, {
	    symbol: "\u2614"
	  }, {
	    symbol: "\u2602"
	  }, {
	    symbol: "\uD83C\uDF0A"
	  }, {
	    symbol: "\uD83C\uDF2B"
	  }]
	}, {
	  id: 3,
	  code: 'FOOD',
	  showForWindows: true,
	  emoji: [{
	    symbol: "\uD83C\uDF4F"
	  }, {
	    symbol: "\uD83C\uDF4E"
	  }, {
	    symbol: "\uD83C\uDF50"
	  }, {
	    symbol: "\uD83C\uDF4A"
	  }, {
	    symbol: "\uD83C\uDF4B"
	  }, {
	    symbol: "\uD83C\uDF4C"
	  }, {
	    symbol: "\uD83C\uDF49"
	  }, {
	    symbol: "\uD83C\uDF47"
	  }, {
	    symbol: "\uD83C\uDF53"
	  }, {
	    symbol: "\uD83C\uDF48"
	  }, {
	    symbol: "\uD83C\uDF52"
	  }, {
	    symbol: "\uD83C\uDF51"
	  }, {
	    symbol: "\uD83E\uDD6D"
	  }, {
	    symbol: "\uD83C\uDF4D"
	  }, {
	    symbol: "\uD83E\uDD65"
	  }, {
	    symbol: "\uD83E\uDD5D"
	  }, {
	    symbol: "\uD83C\uDF45"
	  }, {
	    symbol: "\uD83C\uDF46"
	  }, {
	    symbol: "\uD83E\uDD51"
	  }, {
	    symbol: "\uD83E\uDD66"
	  }, {
	    symbol: "\uD83E\uDD6C"
	  }, {
	    symbol: "\uD83E\uDD52"
	  }, {
	    symbol: "\uD83C\uDF36"
	  }, {
	    symbol: "\uD83C\uDF3D"
	  }, {
	    symbol: "\uD83E\uDD55"
	  }, {
	    symbol: "\uD83E\uDD54"
	  }, {
	    symbol: "\uD83C\uDF60"
	  }, {
	    symbol: "\uD83E\uDD50"
	  }, {
	    symbol: "\uD83E\uDD6F"
	  }, {
	    symbol: "\uD83C\uDF5E"
	  }, {
	    symbol: "\uD83E\uDD56"
	  }, {
	    symbol: "\uD83E\uDD68"
	  }, {
	    symbol: "\uD83E\uDDC0"
	  }, {
	    symbol: "\uD83E\uDD5A"
	  }, {
	    symbol: "\uD83C\uDF73"
	  }, {
	    symbol: "\uD83E\uDD5E"
	  }, {
	    symbol: "\uD83E\uDD53"
	  }, {
	    symbol: "\uD83E\uDD69"
	  }, {
	    symbol: "\uD83C\uDF57"
	  }, {
	    symbol: "\uD83C\uDF56"
	  }, {
	    symbol: "\uD83E\uDDB4"
	  }, {
	    symbol: "\uD83C\uDF2D"
	  }, {
	    symbol: "\uD83C\uDF54"
	  }, {
	    symbol: "\uD83C\uDF5F"
	  }, {
	    symbol: "\uD83C\uDF55"
	  }, {
	    symbol: "\uD83E\uDD6A"
	  }, {
	    symbol: "\uD83E\uDD59"
	  }, {
	    symbol: "\uD83C\uDF2E"
	  }, {
	    symbol: "\uD83C\uDF2F"
	  }, {
	    symbol: "\uD83E\uDD57"
	  }, {
	    symbol: "\uD83E\uDD58"
	  }, {
	    symbol: "\uD83E\uDD6B"
	  }, {
	    symbol: "\uD83C\uDF5D"
	  }, {
	    symbol: "\uD83C\uDF5C"
	  }, {
	    symbol: "\uD83C\uDF72"
	  }, {
	    symbol: "\uD83C\uDF5B"
	  }, {
	    symbol: "\uD83C\uDF63"
	  }, {
	    symbol: "\uD83C\uDF71"
	  }, {
	    symbol: "\uD83E\uDD5F"
	  }, {
	    symbol: "\uD83C\uDF64"
	  }, {
	    symbol: "\uD83C\uDF59"
	  }, {
	    symbol: "\uD83C\uDF5A"
	  }, {
	    symbol: "\uD83C\uDF58"
	  }, {
	    symbol: "\uD83C\uDF65"
	  }, {
	    symbol: "\uD83E\uDD60"
	  }, {
	    symbol: "\uD83E\uDD6E"
	  }, {
	    symbol: "\uD83C\uDF62"
	  }, {
	    symbol: "\uD83C\uDF61"
	  }, {
	    symbol: "\uD83C\uDF67"
	  }, {
	    symbol: "\uD83C\uDF68"
	  }, {
	    symbol: "\uD83C\uDF66"
	  }, {
	    symbol: "\uD83E\uDD67"
	  }, {
	    symbol: "\uD83E\uDDC1"
	  }, {
	    symbol: "\uD83C\uDF70"
	  }, {
	    symbol: "\uD83C\uDF82"
	  }, {
	    symbol: "\uD83C\uDF6E"
	  }, {
	    symbol: "\uD83C\uDF6D"
	  }, {
	    symbol: "\uD83C\uDF6C"
	  }, {
	    symbol: "\uD83C\uDF6B"
	  }, {
	    symbol: "\uD83C\uDF7F"
	  }, {
	    symbol: "\uD83C\uDF69"
	  }, {
	    symbol: "\uD83C\uDF6A"
	  }, {
	    symbol: "\uD83C\uDF30"
	  }, {
	    symbol: "\uD83E\uDD5C"
	  }, {
	    symbol: "\uD83C\uDF6F"
	  }, {
	    symbol: "\uD83E\uDD5B"
	  }, {
	    symbol: "\uD83C\uDF7C"
	  }, {
	    symbol: "\u2615"
	  }, {
	    symbol: "\uD83C\uDF75"
	  }, {
	    symbol: "\uD83E\uDD64"
	  }, {
	    symbol: "\uD83C\uDF76"
	  }, {
	    symbol: "\uD83C\uDF7A"
	  }, {
	    symbol: "\uD83C\uDF7B"
	  }, {
	    symbol: "\uD83E\uDD42"
	  }, {
	    symbol: "\uD83C\uDF77"
	  }, {
	    symbol: "\uD83E\uDD43"
	  }, {
	    symbol: "\uD83C\uDF78"
	  }, {
	    symbol: "\uD83C\uDF79"
	  }, {
	    symbol: "\uD83C\uDF7E"
	  }, {
	    symbol: "\uD83E\uDD44"
	  }, {
	    symbol: "\uD83C\uDF74"
	  }, {
	    symbol: "\uD83C\uDF7D"
	  }, {
	    symbol: "\uD83E\uDD63"
	  }, {
	    symbol: "\uD83E\uDD61"
	  }, {
	    symbol: "\uD83E\uDD62"
	  }, {
	    symbol: "\uD83E\uDDC2"
	  }]
	}, {
	  id: 4,
	  code: 'HOBBY',
	  showForWindows: true,
	  emoji: [{
	    symbol: "\u26BD"
	  }, {
	    symbol: "\uD83C\uDFC0"
	  }, {
	    symbol: "\uD83C\uDFC8"
	  }, {
	    symbol: "\u26BE"
	  }, {
	    symbol: "\uD83E\uDD4E"
	  }, {
	    symbol: "\uD83C\uDFBE"
	  }, {
	    symbol: "\uD83C\uDFD0"
	  }, {
	    symbol: "\uD83C\uDFC9"
	  }, {
	    symbol: "\uD83E\uDD4F"
	  }, {
	    symbol: "\uD83C\uDFB1"
	  }, {
	    symbol: "\uD83C\uDFD3"
	  }, {
	    symbol: "\uD83C\uDFF8"
	  }, {
	    symbol: "\uD83C\uDFD2"
	  }, {
	    symbol: "\uD83C\uDFD1"
	  }, {
	    symbol: "\uD83E\uDD4D"
	  }, {
	    symbol: "\uD83C\uDFCF"
	  }, {
	    symbol: "\uD83E\uDD45"
	  }, {
	    symbol: "\u26F3"
	  }, {
	    symbol: "\uD83C\uDFF9"
	  }, {
	    symbol: "\uD83C\uDFA3"
	  }, {
	    symbol: "\uD83E\uDD4A"
	  }, {
	    symbol: "\uD83E\uDD4B"
	  }, {
	    symbol: "\uD83C\uDFBD"
	  }, {
	    symbol: "\uD83D\uDEF9"
	  }, {
	    symbol: "\uD83D\uDEF7"
	  }, {
	    symbol: "\u26F8"
	  }, {
	    symbol: "\uD83E\uDD4C"
	  }, {
	    symbol: "\uD83C\uDFBF"
	  }, {
	    symbol: "\u26F7"
	  }, {
	    symbol: "\uD83C\uDFC2"
	  }, {
	    symbol: "\uD83C\uDFCB"
	  }, {
	    symbol: "\uD83E\uDD3C"
	  }, {
	    symbol: "\uD83E\uDD38"
	  }, {
	    symbol: "\u26F9"
	  }, {
	    symbol: "\uD83E\uDD3A"
	  }, {
	    symbol: "\uD83E\uDD3E"
	  }, {
	    symbol: "\uD83C\uDFCC"
	  }, {
	    symbol: "\uD83C\uDFC7"
	  }, {
	    symbol: "\uD83E\uDDD8"
	  }, {
	    symbol: "\uD83C\uDFC4"
	  }, {
	    symbol: "\uD83C\uDFCA"
	  }, {
	    symbol: "\uD83E\uDD3D"
	  }, {
	    symbol: "\uD83D\uDEA3"
	  }, {
	    symbol: "\uD83E\uDDD7"
	  }, {
	    symbol: "\uD83D\uDEB5"
	  }, {
	    symbol: "\uD83D\uDEB4"
	  }, {
	    symbol: "\uD83C\uDFC6"
	  }, {
	    symbol: "\uD83E\uDD47"
	  }, {
	    symbol: "\uD83E\uDD48"
	  }, {
	    symbol: "\uD83E\uDD49"
	  }, {
	    symbol: "\uD83C\uDFC5"
	  }, {
	    symbol: "\uD83C\uDF96"
	  }, {
	    symbol: "\uD83C\uDFF5"
	  }, {
	    symbol: "\uD83C\uDF97"
	  }, {
	    symbol: "\uD83C\uDFAB"
	  }, {
	    symbol: "\uD83C\uDF9F"
	  }, {
	    symbol: "\uD83C\uDFAA"
	  }, {
	    symbol: "\uD83E\uDD39"
	  }, {
	    symbol: "\uD83C\uDFAD"
	  }, {
	    symbol: "\uD83C\uDFA8"
	  }, {
	    symbol: "\uD83C\uDFAC"
	  }, {
	    symbol: "\uD83C\uDFA4"
	  }, {
	    symbol: "\uD83C\uDFA7"
	  }, {
	    symbol: "\uD83C\uDFBC"
	  }, {
	    symbol: "\uD83C\uDFB9"
	  }, {
	    symbol: "\uD83E\uDD41"
	  }, {
	    symbol: "\uD83C\uDFB7"
	  }, {
	    symbol: "\uD83C\uDFBA"
	  }, {
	    symbol: "\uD83C\uDFB8"
	  }, {
	    symbol: "\uD83C\uDFBB"
	  }, {
	    symbol: "\uD83C\uDFB2"
	  }, {
	    symbol: "\u265F"
	  }, {
	    symbol: "\uD83C\uDFAF"
	  }, {
	    symbol: "\uD83C\uDFB3"
	  }, {
	    symbol: "\uD83C\uDFAE"
	  }, {
	    symbol: "\uD83C\uDFB0"
	  }, {
	    symbol: "\uD83E\uDDE9"
	  }]
	}, {
	  id: 5,
	  code: 'TRAVEL',
	  showForWindows: true,
	  emoji: [{
	    symbol: "\uD83D\uDE97"
	  }, {
	    symbol: "\uD83D\uDE95"
	  }, {
	    symbol: "\uD83D\uDE99"
	  }, {
	    symbol: "\uD83D\uDE8C"
	  }, {
	    symbol: "\uD83D\uDE8E"
	  }, {
	    symbol: "\uD83C\uDFCE"
	  }, {
	    symbol: "\uD83D\uDE93"
	  }, {
	    symbol: "\uD83D\uDE91"
	  }, {
	    symbol: "\uD83D\uDE92"
	  }, {
	    symbol: "\uD83D\uDE90"
	  }, {
	    symbol: "\uD83D\uDE9A"
	  }, {
	    symbol: "\uD83D\uDE9B"
	  }, {
	    symbol: "\uD83D\uDE9C"
	  }, {
	    symbol: "\uD83D\uDEF4"
	  }, {
	    symbol: "\uD83D\uDEB2"
	  }, {
	    symbol: "\uD83D\uDEF5"
	  }, {
	    symbol: "\uD83C\uDFCD"
	  }, {
	    symbol: "\uD83D\uDEA8"
	  }, {
	    symbol: "\uD83D\uDE94"
	  }, {
	    symbol: "\uD83D\uDE8D"
	  }, {
	    symbol: "\uD83D\uDE98"
	  }, {
	    symbol: "\uD83D\uDE96"
	  }, {
	    symbol: "\uD83D\uDEA1"
	  }, {
	    symbol: "\uD83D\uDEA0"
	  }, {
	    symbol: "\uD83D\uDE9F"
	  }, {
	    symbol: "\uD83D\uDE83"
	  }, {
	    symbol: "\uD83D\uDE8B"
	  }, {
	    symbol: "\uD83D\uDE9E"
	  }, {
	    symbol: "\uD83D\uDE9D"
	  }, {
	    symbol: "\uD83D\uDE84"
	  }, {
	    symbol: "\uD83D\uDE85"
	  }, {
	    symbol: "\uD83D\uDE88"
	  }, {
	    symbol: "\uD83D\uDE82"
	  }, {
	    symbol: "\uD83D\uDE86"
	  }, {
	    symbol: "\uD83D\uDE87"
	  }, {
	    symbol: "\uD83D\uDE8A"
	  }, {
	    symbol: "\uD83D\uDE89"
	  }, {
	    symbol: "\u2708"
	  }, {
	    symbol: "\uD83D\uDEEB"
	  }, {
	    symbol: "\uD83D\uDEEC"
	  }, {
	    symbol: "\uD83D\uDEE9"
	  }, {
	    symbol: "\uD83D\uDCBA"
	  }, {
	    symbol: "\uD83D\uDEF0"
	  }, {
	    symbol: "\uD83D\uDE80"
	  }, {
	    symbol: "\uD83D\uDEF8"
	  }, {
	    symbol: "\uD83D\uDE81"
	  }, {
	    symbol: "\uD83D\uDEF6"
	  }, {
	    symbol: "\u26F5"
	  }, {
	    symbol: "\uD83D\uDEA4"
	  }, {
	    symbol: "\uD83D\uDEE5"
	  }, {
	    symbol: "\uD83D\uDEF3"
	  }, {
	    symbol: "\u26F4"
	  }, {
	    symbol: "\uD83D\uDEA2"
	  }, {
	    symbol: "\u2693"
	  }, {
	    symbol: "\u26FD"
	  }, {
	    symbol: "\uD83D\uDEA7"
	  }, {
	    symbol: "\uD83D\uDEA6"
	  }, {
	    symbol: "\uD83D\uDEA5"
	  }, {
	    symbol: "\uD83D\uDE8F"
	  }, {
	    symbol: "\uD83D\uDDFA"
	  }, {
	    symbol: "\uD83D\uDDFF"
	  }, {
	    symbol: "\uD83D\uDDFD"
	  }, {
	    symbol: "\uD83D\uDDFC"
	  }, {
	    symbol: "\uD83C\uDFF0"
	  }, {
	    symbol: "\uD83C\uDFEF"
	  }, {
	    symbol: "\uD83C\uDFDF"
	  }, {
	    symbol: "\uD83C\uDFA1"
	  }, {
	    symbol: "\uD83C\uDFA2"
	  }, {
	    symbol: "\uD83C\uDFA0"
	  }, {
	    symbol: "\u26F2"
	  }, {
	    symbol: "\u26F1"
	  }, {
	    symbol: "\uD83C\uDFD6"
	  }, {
	    symbol: "\uD83C\uDFDD"
	  }, {
	    symbol: "\uD83C\uDFDC"
	  }, {
	    symbol: "\uD83C\uDF0B"
	  }, {
	    symbol: "\u26F0"
	  }, {
	    symbol: "\uD83C\uDFD4"
	  }, {
	    symbol: "\uD83D\uDDFB"
	  }, {
	    symbol: "\uD83C\uDFD5"
	  }, {
	    symbol: "\u26FA"
	  }, {
	    symbol: "\uD83C\uDFE0"
	  }, {
	    symbol: "\uD83C\uDFE1"
	  }, {
	    symbol: "\uD83C\uDFD8"
	  }, {
	    symbol: "\uD83C\uDFDA"
	  }, {
	    symbol: "\uD83C\uDFD7"
	  }, {
	    symbol: "\uD83C\uDFED"
	  }, {
	    symbol: "\uD83C\uDFE2"
	  }, {
	    symbol: "\uD83C\uDFEC"
	  }, {
	    symbol: "\uD83C\uDFE3"
	  }, {
	    symbol: "\uD83C\uDFE4"
	  }, {
	    symbol: "\uD83C\uDFE5"
	  }, {
	    symbol: "\uD83C\uDFE6"
	  }, {
	    symbol: "\uD83C\uDFE8"
	  }, {
	    symbol: "\uD83C\uDFEA"
	  }, {
	    symbol: "\uD83C\uDFEB"
	  }, {
	    symbol: "\uD83C\uDFE9"
	  }, {
	    symbol: "\uD83D\uDC92"
	  }, {
	    symbol: "\uD83C\uDFDB"
	  }, {
	    symbol: "\u26EA"
	  }, {
	    symbol: "\uD83D\uDD4C"
	  }, {
	    symbol: "\uD83D\uDD4D"
	  }, {
	    symbol: "\uD83D\uDD4B"
	  }, {
	    symbol: "\u26E9"
	  }, {
	    symbol: "\uD83D\uDEE4"
	  }, {
	    symbol: "\uD83D\uDEE3"
	  }, {
	    symbol: "\uD83D\uDDFE"
	  }, {
	    symbol: "\uD83C\uDF91"
	  }, {
	    symbol: "\uD83C\uDFDE"
	  }, {
	    symbol: "\uD83C\uDF05"
	  }, {
	    symbol: "\uD83C\uDF04"
	  }, {
	    symbol: "\uD83C\uDF20"
	  }, {
	    symbol: "\uD83C\uDF87"
	  }, {
	    symbol: "\uD83C\uDF86"
	  }, {
	    symbol: "\uD83C\uDF07"
	  }, {
	    symbol: "\uD83C\uDF06"
	  }, {
	    symbol: "\uD83C\uDFD9"
	  }, {
	    symbol: "\uD83C\uDF03"
	  }, {
	    symbol: "\uD83C\uDF0C"
	  }, {
	    symbol: "\uD83C\uDF09"
	  }, {
	    symbol: "\uD83C\uDF01"
	  }]
	}, {
	  id: 6,
	  code: 'OBJECTS',
	  showForWindows: true,
	  emoji: [{
	    symbol: "\u231A"
	  }, {
	    symbol: "\uD83D\uDCF1"
	  }, {
	    symbol: "\uD83D\uDCF2"
	  }, {
	    symbol: "\uD83D\uDCBB"
	  }, {
	    symbol: "\u2328"
	  }, {
	    symbol: "\uD83D\uDDA5"
	  }, {
	    symbol: "\uD83D\uDDA8"
	  }, {
	    symbol: "\uD83D\uDDB1"
	  }, {
	    symbol: "\uD83D\uDDB2"
	  }, {
	    symbol: "\uD83D\uDD79"
	  }, {
	    symbol: "\uD83D\uDDDC"
	  }, {
	    symbol: "\uD83D\uDCBD"
	  }, {
	    symbol: "\uD83D\uDCBE"
	  }, {
	    symbol: "\uD83D\uDCBF"
	  }, {
	    symbol: "\uD83D\uDCC0"
	  }, {
	    symbol: "\uD83D\uDCFC"
	  }, {
	    symbol: "\uD83D\uDCF7"
	  }, {
	    symbol: "\uD83D\uDCF8"
	  }, {
	    symbol: "\uD83D\uDCF9"
	  }, {
	    symbol: "\uD83C\uDFA5"
	  }, {
	    symbol: "\uD83D\uDCFD"
	  }, {
	    symbol: "\uD83C\uDF9E"
	  }, {
	    symbol: "\uD83D\uDCDE"
	  }, {
	    symbol: "\u260E"
	  }, {
	    symbol: "\uD83D\uDCDF"
	  }, {
	    symbol: "\uD83D\uDCE0"
	  }, {
	    symbol: "\uD83D\uDCFA"
	  }, {
	    symbol: "\uD83D\uDCFB"
	  }, {
	    symbol: "\uD83C\uDF99"
	  }, {
	    symbol: "\uD83C\uDF9A"
	  }, {
	    symbol: "\uD83C\uDF9B"
	  }, {
	    symbol: "\uD83E\uDDED"
	  }, {
	    symbol: "\u23F1"
	  }, {
	    symbol: "\u23F2"
	  }, {
	    symbol: "\u23F0"
	  }, {
	    symbol: "\uD83D\uDD70"
	  }, {
	    symbol: "\u231B"
	  }, {
	    symbol: "\u23F3"
	  }, {
	    symbol: "\uD83D\uDCE1"
	  }, {
	    symbol: "\uD83D\uDD0B"
	  }, {
	    symbol: "\uD83D\uDD0C"
	  }, {
	    symbol: "\uD83D\uDCA1"
	  }, {
	    symbol: "\uD83D\uDD26"
	  }, {
	    symbol: "\uD83D\uDD6F"
	  }, {
	    symbol: "\uD83E\uDDEF"
	  }, {
	    symbol: "\uD83D\uDEE2"
	  }, {
	    symbol: "\uD83D\uDCB8"
	  }, {
	    symbol: "\uD83D\uDCB5"
	  }, {
	    symbol: "\uD83D\uDCB4"
	  }, {
	    symbol: "\uD83D\uDCB6"
	  }, {
	    symbol: "\uD83D\uDCB7"
	  }, {
	    symbol: "\uD83D\uDCB0"
	  }, {
	    symbol: "\uD83D\uDCB3"
	  }, {
	    symbol: "\uD83D\uDC8E"
	  }, {
	    symbol: "\u2696"
	  }, {
	    symbol: "\uD83E\uDDF0"
	  }, {
	    symbol: "\uD83D\uDD27"
	  }, {
	    symbol: "\uD83D\uDD28"
	  }, {
	    symbol: "\u2692"
	  }, {
	    symbol: "\uD83D\uDEE0"
	  }, {
	    symbol: "\u26CF"
	  }, {
	    symbol: "\uD83D\uDD29"
	  }, {
	    symbol: "\u2699"
	  }, {
	    symbol: "\uD83E\uDDF1"
	  }, {
	    symbol: "\u26D3"
	  }, {
	    symbol: "\uD83E\uDDF2"
	  }, {
	    symbol: "\uD83D\uDD2B"
	  }, {
	    symbol: "\uD83D\uDCA3"
	  }, {
	    symbol: "\uD83E\uDDE8"
	  }, {
	    symbol: "\uD83D\uDD2A"
	  }, {
	    symbol: "\uD83D\uDDE1"
	  }, {
	    symbol: "\u2694"
	  }, {
	    symbol: "\uD83D\uDEE1"
	  }, {
	    symbol: "\uD83D\uDEAC"
	  }, {
	    symbol: "\u26B0"
	  }, {
	    symbol: "\u26B1"
	  }, {
	    symbol: "\uD83C\uDFFA"
	  }, {
	    symbol: "\uD83D\uDD2E"
	  }, {
	    symbol: "\uD83D\uDCFF"
	  }, {
	    symbol: "\uD83E\uDDFF"
	  }, {
	    symbol: "\uD83D\uDC88"
	  }, {
	    symbol: "\u2697"
	  }, {
	    symbol: "\uD83D\uDD2D"
	  }, {
	    symbol: "\uD83D\uDD2C"
	  }, {
	    symbol: "\uD83D\uDD73"
	  }, {
	    symbol: "\uD83D\uDC8A"
	  }, {
	    symbol: "\uD83D\uDC89"
	  }, {
	    symbol: "\uD83E\uDDEC"
	  }, {
	    symbol: "\uD83E\uDDA0"
	  }, {
	    symbol: "\uD83E\uDDEB"
	  }, {
	    symbol: "\uD83E\uDDEA"
	  }, {
	    symbol: "\uD83C\uDF21"
	  }, {
	    symbol: "\uD83E\uDDF9"
	  }, {
	    symbol: "\uD83E\uDDFA"
	  }, {
	    symbol: "\uD83E\uDDFB"
	  }, {
	    symbol: "\uD83D\uDEBD"
	  }, {
	    symbol: "\uD83D\uDEB0"
	  }, {
	    symbol: "\uD83D\uDEBF"
	  }, {
	    symbol: "\uD83D\uDEC1"
	  }, {
	    symbol: "\uD83D\uDEC0"
	  }, {
	    symbol: "\uD83E\uDDFC"
	  }, {
	    symbol: "\uD83E\uDDFD"
	  }, {
	    symbol: "\uD83E\uDDF4"
	  }, {
	    symbol: "\uD83D\uDECE"
	  }, {
	    symbol: "\uD83D\uDD11"
	  }, {
	    symbol: "\uD83D\uDDDD"
	  }, {
	    symbol: "\uD83D\uDEAA"
	  }, {
	    symbol: "\uD83D\uDECB"
	  }, {
	    symbol: "\uD83D\uDECF"
	  }, {
	    symbol: "\uD83D\uDECC"
	  }, {
	    symbol: "\uD83E\uDDF8"
	  }, {
	    symbol: "\uD83D\uDDBC"
	  }, {
	    symbol: "\uD83D\uDECD"
	  }, {
	    symbol: "\uD83D\uDED2"
	  }, {
	    symbol: "\uD83C\uDF81"
	  }, {
	    symbol: "\uD83C\uDF88"
	  }, {
	    symbol: "\uD83C\uDF8F"
	  }, {
	    symbol: "\uD83C\uDF80"
	  }, {
	    symbol: "\uD83C\uDF8A"
	  }, {
	    symbol: "\uD83C\uDF89"
	  }, {
	    symbol: "\uD83C\uDF8E"
	  }, {
	    symbol: "\uD83C\uDFEE"
	  }, {
	    symbol: "\uD83C\uDF90"
	  }, {
	    symbol: "\uD83E\uDDE7"
	  }, {
	    symbol: "\u2709"
	  }, {
	    symbol: "\uD83D\uDCE9"
	  }, {
	    symbol: "\uD83D\uDCE8"
	  }, {
	    symbol: "\uD83D\uDCE7"
	  }, {
	    symbol: "\uD83D\uDC8C"
	  }, {
	    symbol: "\uD83D\uDCE5"
	  }, {
	    symbol: "\uD83D\uDCE4"
	  }, {
	    symbol: "\uD83D\uDCE6"
	  }, {
	    symbol: "\uD83C\uDFF7"
	  }, {
	    symbol: "\uD83D\uDCEA"
	  }, {
	    symbol: "\uD83D\uDCEB"
	  }, {
	    symbol: "\uD83D\uDCEC"
	  }, {
	    symbol: "\uD83D\uDCED"
	  }, {
	    symbol: "\uD83D\uDCEE"
	  }, {
	    symbol: "\uD83D\uDCEF"
	  }, {
	    symbol: "\uD83D\uDCDC"
	  }, {
	    symbol: "\uD83D\uDCC3"
	  }, {
	    symbol: "\uD83D\uDCC4"
	  }, {
	    symbol: "\uD83D\uDCD1"
	  }, {
	    symbol: "\uD83E\uDDFE"
	  }, {
	    symbol: "\uD83D\uDCCA"
	  }, {
	    symbol: "\uD83D\uDCC8"
	  }, {
	    symbol: "\uD83D\uDCC9"
	  }, {
	    symbol: "\uD83D\uDDD2"
	  }, {
	    symbol: "\uD83D\uDDD3"
	  }, {
	    symbol: "\uD83D\uDCC6"
	  }, {
	    symbol: "\uD83D\uDCC5"
	  }, {
	    symbol: "\uD83D\uDDD1"
	  }, {
	    symbol: "\uD83D\uDCC7"
	  }, {
	    symbol: "\uD83D\uDDC3"
	  }, {
	    symbol: "\uD83D\uDDF3"
	  }, {
	    symbol: "\uD83D\uDDC4"
	  }, {
	    symbol: "\uD83D\uDCCB"
	  }, {
	    symbol: "\uD83D\uDCC1"
	  }, {
	    symbol: "\uD83D\uDCC2"
	  }, {
	    symbol: "\uD83D\uDDC2"
	  }, {
	    symbol: "\uD83D\uDDDE"
	  }, {
	    symbol: "\uD83D\uDCF0"
	  }, {
	    symbol: "\uD83D\uDCD3"
	  }, {
	    symbol: "\uD83D\uDCD4"
	  }, {
	    symbol: "\uD83D\uDCD2"
	  }, {
	    symbol: "\uD83D\uDCD5"
	  }, {
	    symbol: "\uD83D\uDCD7"
	  }, {
	    symbol: "\uD83D\uDCD8"
	  }, {
	    symbol: "\uD83D\uDCD9"
	  }, {
	    symbol: "\uD83D\uDCDA"
	  }, {
	    symbol: "\uD83D\uDCD6"
	  }, {
	    symbol: "\uD83D\uDD16"
	  }, {
	    symbol: "\uD83E\uDDF7"
	  }, {
	    symbol: "\uD83D\uDD17"
	  }, {
	    symbol: "\uD83D\uDCCE"
	  }, {
	    symbol: "\uD83D\uDD87"
	  }, {
	    symbol: "\uD83D\uDCD0"
	  }, {
	    symbol: "\uD83D\uDCCF"
	  }, {
	    symbol: "\uD83D\uDCCC"
	  }, {
	    symbol: "\uD83D\uDCCD"
	  }, {
	    symbol: "\u2702"
	  }, {
	    symbol: "\uD83D\uDD8A"
	  }, {
	    symbol: "\uD83D\uDD8B"
	  }, {
	    symbol: "\u2712"
	  }, {
	    symbol: "\uD83D\uDD8C"
	  }, {
	    symbol: "\uD83D\uDD8D"
	  }, {
	    symbol: "\uD83D\uDCDD"
	  }, {
	    symbol: "\u270F"
	  }, {
	    symbol: "\uD83D\uDD0D"
	  }, {
	    symbol: "\uD83D\uDD0E"
	  }, {
	    symbol: "\uD83D\uDD0F"
	  }, {
	    symbol: "\uD83D\uDD10"
	  }, {
	    symbol: "\uD83D\uDD12"
	  }, {
	    symbol: "\uD83D\uDD13"
	  }]
	}, {
	  id: 7,
	  code: 'SYMBOLS',
	  showForWindows: true,
	  emoji: [{
	    symbol: "\u2764"
	  }, {
	    symbol: "\uD83E\uDDE1"
	  }, {
	    symbol: "\uD83D\uDC9B"
	  }, {
	    symbol: "\uD83D\uDC9A"
	  }, {
	    symbol: "\uD83D\uDC99"
	  }, {
	    symbol: "\uD83D\uDC9C"
	  }, {
	    symbol: "\uD83D\uDDA4"
	  }, {
	    symbol: "\uD83D\uDC94"
	  }, {
	    symbol: "\u2763"
	  }, {
	    symbol: "\uD83D\uDC95"
	  }, {
	    symbol: "\uD83D\uDC9E"
	  }, {
	    symbol: "\uD83D\uDC93"
	  }, {
	    symbol: "\uD83D\uDC97"
	  }, {
	    symbol: "\uD83D\uDC96"
	  }, {
	    symbol: "\uD83D\uDC98"
	  }, {
	    symbol: "\uD83D\uDC9D"
	  }, {
	    symbol: "\uD83D\uDC9F"
	  }, {
	    symbol: "\u262E"
	  }, {
	    symbol: "\u271D"
	  }, {
	    symbol: "\u262A"
	  }, {
	    symbol: "\uD83D\uDD49"
	  }, {
	    symbol: "\u2638"
	  }, {
	    symbol: "\u2721"
	  }, {
	    symbol: "\uD83D\uDD2F"
	  }, {
	    symbol: "\uD83D\uDD4E"
	  }, {
	    symbol: "\u262F"
	  }, {
	    symbol: "\u2626"
	  }, {
	    symbol: "\uD83D\uDED0"
	  }, {
	    symbol: "\u26CE"
	  }, {
	    symbol: "\u2648"
	  }, {
	    symbol: "\u2649"
	  }, {
	    symbol: "\u264A"
	  }, {
	    symbol: "\u264B"
	  }, {
	    symbol: "\u264C"
	  }, {
	    symbol: "\u264D"
	  }, {
	    symbol: "\u264E"
	  }, {
	    symbol: "\u264F"
	  }, {
	    symbol: "\u2650"
	  }, {
	    symbol: "\u2651"
	  }, {
	    symbol: "\u2652"
	  }, {
	    symbol: "\u2653"
	  }, {
	    symbol: "\uD83C\uDD94"
	  }, {
	    symbol: "\u269B"
	  }, {
	    symbol: "\uD83C\uDE51"
	  }, {
	    symbol: "\u2622"
	  }, {
	    symbol: "\u2623"
	  }, {
	    symbol: "\uD83D\uDCF4"
	  }, {
	    symbol: "\uD83D\uDCF3"
	  }, {
	    symbol: "\uD83C\uDE36"
	  }, {
	    symbol: "\uD83C\uDE1A"
	  }, {
	    symbol: "\uD83C\uDE38"
	  }, {
	    symbol: "\uD83C\uDE3A"
	  }, {
	    symbol: "\uD83C\uDE37"
	  }, {
	    symbol: "\u2734"
	  }, {
	    symbol: "\uD83C\uDD9A"
	  }, {
	    symbol: "\uD83D\uDCAE"
	  }, {
	    symbol: "\uD83C\uDE50"
	  }, {
	    symbol: "\u3299"
	  }, {
	    symbol: "\u3297"
	  }, {
	    symbol: "\uD83C\uDE34"
	  }, {
	    symbol: "\uD83C\uDE35"
	  }, {
	    symbol: "\uD83C\uDE39"
	  }, {
	    symbol: "\uD83C\uDE32"
	  }, {
	    symbol: "\uD83C\uDD70"
	  }, {
	    symbol: "\uD83C\uDD71"
	  }, {
	    symbol: "\uD83C\uDD8E"
	  }, {
	    symbol: "\uD83C\uDD91"
	  }, {
	    symbol: "\uD83C\uDD7E"
	  }, {
	    symbol: "\uD83C\uDD98"
	  }, {
	    symbol: "\u274C"
	  }, {
	    symbol: "\u2B55"
	  }, {
	    symbol: "\uD83D\uDED1"
	  }, {
	    symbol: "\u26D4"
	  }, {
	    symbol: "\uD83D\uDCDB"
	  }, {
	    symbol: "\uD83D\uDEAB"
	  }, {
	    symbol: "\uD83D\uDCAF"
	  }, {
	    symbol: "\uD83D\uDCA2"
	  }, {
	    symbol: "\u2668"
	  }, {
	    symbol: "\uD83D\uDEB7"
	  }, {
	    symbol: "\uD83D\uDEAF"
	  }, {
	    symbol: "\uD83D\uDEB3"
	  }, {
	    symbol: "\uD83D\uDEB1"
	  }, {
	    symbol: "\uD83D\uDD1E"
	  }, {
	    symbol: "\uD83D\uDCF5"
	  }, {
	    symbol: "\uD83D\uDEAD"
	  }, {
	    symbol: "\u2757"
	  }, {
	    symbol: "\u2755"
	  }, {
	    symbol: "\u2753"
	  }, {
	    symbol: "\u2754"
	  }, {
	    symbol: "\u203C"
	  }, {
	    symbol: "\u2049"
	  }, {
	    symbol: "\uD83D\uDD05"
	  }, {
	    symbol: "\uD83D\uDD06"
	  }, {
	    symbol: "\u303D"
	  }, {
	    symbol: "\u26A0"
	  }, {
	    symbol: "\uD83D\uDEB8"
	  }, {
	    symbol: "\uD83D\uDD31"
	  }, {
	    symbol: "\u269C"
	  }, {
	    symbol: "\uD83D\uDD30"
	  }, {
	    symbol: "\u267B"
	  }, {
	    symbol: "\u2705"
	  }, {
	    symbol: "\uD83C\uDE2F"
	  }, {
	    symbol: "\uD83D\uDCB9"
	  }, {
	    symbol: "\u2747"
	  }, {
	    symbol: "\u2733"
	  }, {
	    symbol: "\u274E"
	  }, {
	    symbol: "\uD83C\uDF10"
	  }, {
	    symbol: "\uD83D\uDCA0"
	  }, {
	    symbol: "\u24C2"
	  }, {
	    symbol: "\uD83C\uDF00"
	  }, {
	    symbol: "\uD83D\uDCA4"
	  }, {
	    symbol: "\uD83C\uDFE7"
	  }, {
	    symbol: "\uD83D\uDEBE"
	  }, {
	    symbol: "\u267F"
	  }, {
	    symbol: "\uD83C\uDD7F"
	  }, {
	    symbol: "\uD83C\uDE33"
	  }, {
	    symbol: "\uD83C\uDE02"
	  }, {
	    symbol: "\uD83D\uDEC2"
	  }, {
	    symbol: "\uD83D\uDEC3"
	  }, {
	    symbol: "\uD83D\uDEC4"
	  }, {
	    symbol: "\uD83D\uDEC5"
	  }, {
	    symbol: "\uD83D\uDEB9"
	  }, {
	    symbol: "\uD83D\uDEBA"
	  }, {
	    symbol: "\uD83D\uDEBC"
	  }, {
	    symbol: "\uD83D\uDEBB"
	  }, {
	    symbol: "\uD83D\uDEAE"
	  }, {
	    symbol: "\uD83C\uDFA6"
	  }, {
	    symbol: "\uD83D\uDCF6"
	  }, {
	    symbol: "\uD83C\uDE01"
	  }, {
	    symbol: "\uD83D\uDD23"
	  }, {
	    symbol: "\u2139"
	  }, {
	    symbol: "\uD83D\uDD24"
	  }, {
	    symbol: "\uD83D\uDD21"
	  }, {
	    symbol: "\uD83D\uDD20"
	  }, {
	    symbol: "\uD83C\uDD96"
	  }, {
	    symbol: "\uD83C\uDD97"
	  }, {
	    symbol: "\uD83C\uDD99"
	  }, {
	    symbol: "\uD83C\uDD92"
	  }, {
	    symbol: "\uD83C\uDD95"
	  }, {
	    symbol: "\uD83C\uDD93"
	  }, {
	    symbol: "0"
	  }, {
	    symbol: "1"
	  }, {
	    symbol: "2"
	  }, {
	    symbol: "3"
	  }, {
	    symbol: "4"
	  }, {
	    symbol: "5"
	  }, {
	    symbol: "6"
	  }, {
	    symbol: "7"
	  }, {
	    symbol: "8"
	  }, {
	    symbol: "9"
	  }, {
	    symbol: "\uD83D\uDD1F"
	  }, {
	    symbol: "\uD83D\uDD22"
	  }, {
	    symbol: "#"
	  }, {
	    symbol: "*"
	  }, {
	    symbol: "\u23CF"
	  }, {
	    symbol: "\u25B6"
	  }, {
	    symbol: "\u23F8"
	  }, {
	    symbol: "\u23EF"
	  }, {
	    symbol: "\u23F9"
	  }, {
	    symbol: "\u23FA"
	  }, {
	    symbol: "\u23ED"
	  }, {
	    symbol: "\u23EE"
	  }, {
	    symbol: "\u23E9"
	  }, {
	    symbol: "\u23EA"
	  }, {
	    symbol: "\u23EB"
	  }, {
	    symbol: "\u23EC"
	  }, {
	    symbol: "\u25C0"
	  }, {
	    symbol: "\uD83D\uDD3C"
	  }, {
	    symbol: "\uD83D\uDD3D"
	  }, {
	    symbol: "\u27A1"
	  }, {
	    symbol: "\u2B05"
	  }, {
	    symbol: "\u2B06"
	  }, {
	    symbol: "\u2B07"
	  }, {
	    symbol: "\u2197"
	  }, {
	    symbol: "\u2198"
	  }, {
	    symbol: "\u2199"
	  }, {
	    symbol: "\u2196"
	  }, {
	    symbol: "\u2195"
	  }, {
	    symbol: "\u2194"
	  }, {
	    symbol: "\u21AA"
	  }, {
	    symbol: "\u21A9"
	  }, {
	    symbol: "\u2934"
	  }, {
	    symbol: "\u2935"
	  }, {
	    symbol: "\uD83D\uDD00"
	  }, {
	    symbol: "\uD83D\uDD01"
	  }, {
	    symbol: "\uD83D\uDD02"
	  }, {
	    symbol: "\uD83D\uDD04"
	  }, {
	    symbol: "\uD83D\uDD03"
	  }, {
	    symbol: "\uD83C\uDFB5"
	  }, {
	    symbol: "\uD83C\uDFB6"
	  }, {
	    symbol: "\u2795"
	  }, {
	    symbol: "\u2796"
	  }, {
	    symbol: "\u2797"
	  }, {
	    symbol: "\u2716"
	  }, {
	    symbol: "\u267E"
	  }, {
	    symbol: "\uD83D\uDCB2"
	  }, {
	    symbol: "\uD83D\uDCB1"
	  }, {
	    symbol: "\u2122"
	  }, {
	    symbol: "\xA9"
	  }, {
	    symbol: "\xAE"
	  }, {
	    symbol: "\uD83D\uDC41"
	  }, {
	    symbol: "\uD83D\uDDE8"
	  }, {
	    symbol: "\uD83D\uDD1A"
	  }, {
	    symbol: "\uD83D\uDD19"
	  }, {
	    symbol: "\uD83D\uDD1B"
	  }, {
	    symbol: "\uD83D\uDD1D"
	  }, {
	    symbol: "\uD83D\uDD1C"
	  }, {
	    symbol: "\u3030"
	  }, {
	    symbol: "\u27B0"
	  }, {
	    symbol: "\u27BF"
	  }, {
	    symbol: "\u2714"
	  }, {
	    symbol: "\u2611"
	  }, {
	    symbol: "\uD83D\uDD18"
	  }, {
	    symbol: "\u26AA"
	  }, {
	    symbol: "\u26AB"
	  }, {
	    symbol: "\uD83D\uDD34"
	  }, {
	    symbol: "\uD83D\uDD35"
	  }, {
	    symbol: "\uD83D\uDD3A"
	  }, {
	    symbol: "\uD83D\uDD3B"
	  }, {
	    symbol: "\uD83D\uDD38"
	  }, {
	    symbol: "\uD83D\uDD39"
	  }, {
	    symbol: "\uD83D\uDD36"
	  }, {
	    symbol: "\uD83D\uDD37"
	  }, {
	    symbol: "\uD83D\uDD33"
	  }, {
	    symbol: "\uD83D\uDD32"
	  }, {
	    symbol: "\u25AA"
	  }, {
	    symbol: "\u25AB"
	  }, {
	    symbol: "\u25FE"
	  }, {
	    symbol: "\u25FD"
	  }, {
	    symbol: "\u25FC"
	  }, {
	    symbol: "\u25FB"
	  }, {
	    symbol: "\u2B1B"
	  }, {
	    symbol: "\u2B1C"
	  }, {
	    symbol: "\uD83D\uDD08"
	  }, {
	    symbol: "\uD83D\uDD07"
	  }, {
	    symbol: "\uD83D\uDD09"
	  }, {
	    symbol: "\uD83D\uDD0A"
	  }, {
	    symbol: "\uD83D\uDD14"
	  }, {
	    symbol: "\uD83D\uDD15"
	  }, {
	    symbol: "\uD83D\uDCE3"
	  }, {
	    symbol: "\uD83D\uDCE2"
	  }, {
	    symbol: "\uD83D\uDCAC"
	  }, {
	    symbol: "\uD83D\uDCAD"
	  }, {
	    symbol: "\uD83D\uDDEF"
	  }, {
	    symbol: "\u2660"
	  }, {
	    symbol: "\u2663"
	  }, {
	    symbol: "\u2665"
	  }, {
	    symbol: "\u2666"
	  }, {
	    symbol: "\uD83C\uDCCF"
	  }, {
	    symbol: "\uD83C\uDFB4"
	  }, {
	    symbol: "\uD83C\uDC04"
	  }, {
	    symbol: "\uD83D\uDD50"
	  }, {
	    symbol: "\uD83D\uDD51"
	  }, {
	    symbol: "\uD83D\uDD52"
	  }, {
	    symbol: "\uD83D\uDD53"
	  }, {
	    symbol: "\uD83D\uDD54"
	  }, {
	    symbol: "\uD83D\uDD55"
	  }, {
	    symbol: "\uD83D\uDD56"
	  }, {
	    symbol: "\uD83D\uDD57"
	  }, {
	    symbol: "\uD83D\uDD58"
	  }, {
	    symbol: "\uD83D\uDD59"
	  }, {
	    symbol: "\uD83D\uDD5A"
	  }, {
	    symbol: "\uD83D\uDD5B"
	  }, {
	    symbol: "\uD83D\uDD5C"
	  }, {
	    symbol: "\uD83D\uDD5D"
	  }, {
	    symbol: "\uD83D\uDD5E"
	  }, {
	    symbol: "\uD83D\uDD5F"
	  }, {
	    symbol: "\uD83D\uDD60"
	  }, {
	    symbol: "\uD83D\uDD61"
	  }, {
	    symbol: "\uD83D\uDD62"
	  }, {
	    symbol: "\uD83D\uDD63"
	  }, {
	    symbol: "\uD83D\uDD64"
	  }, {
	    symbol: "\uD83D\uDD65"
	  }, {
	    symbol: "\uD83D\uDD66"
	  }, {
	    symbol: "\uD83D\uDD67"
	  }]
	}, {
	  id: 8,
	  code: 'FLAGS',
	  showForWindows: false,
	  emoji: [{
	    symbol: "\uD83C\uDFF3"
	  }, {
	    symbol: "\uD83C\uDFF4"
	  }, {
	    symbol: "\uD83C\uDFC1"
	  }, {
	    symbol: "\uD83D\uDEA9"
	  }, {
	    symbol: "\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08"
	  }, {
	    symbol: "\uD83C\uDDFA\uD83C\uDDF3"
	  }, {
	    symbol: "\uD83C\uDDE6\uD83C\uDDEB"
	  }, {
	    symbol: "\uD83C\uDDE6\uD83C\uDDFD"
	  }, {
	    symbol: "\uD83C\uDDE6\uD83C\uDDF1"
	  }, {
	    symbol: "\uD83C\uDDE9\uD83C\uDDFF"
	  }, {
	    symbol: "\uD83C\uDDE6\uD83C\uDDF8"
	  }, {
	    symbol: "\uD83C\uDDE6\uD83C\uDDE9"
	  }, {
	    symbol: "\uD83C\uDDE6\uD83C\uDDF4"
	  }, {
	    symbol: "\uD83C\uDDE6\uD83C\uDDEE"
	  }, {
	    symbol: "\uD83C\uDDE6\uD83C\uDDF6"
	  }, {
	    symbol: "\uD83C\uDDE6\uD83C\uDDEC"
	  }, {
	    symbol: "\uD83C\uDDE6\uD83C\uDDF7"
	  }, {
	    symbol: "\uD83C\uDDE6\uD83C\uDDF2"
	  }, {
	    symbol: "\uD83C\uDDE6\uD83C\uDDFC"
	  }, {
	    symbol: "\uD83C\uDDE6\uD83C\uDDFA"
	  }, {
	    symbol: "\uD83C\uDDE6\uD83C\uDDF9"
	  }, {
	    symbol: "\uD83C\uDDE6\uD83C\uDDFF"
	  }, {
	    symbol: "\uD83C\uDDE7\uD83C\uDDF8"
	  }, {
	    symbol: "\uD83C\uDDE7\uD83C\uDDED"
	  }, {
	    symbol: "\uD83C\uDDE7\uD83C\uDDE9"
	  }, {
	    symbol: "\uD83C\uDDE7\uD83C\uDDFE"
	  }, {
	    symbol: "\uD83C\uDDE7\uD83C\uDDEA"
	  }, {
	    symbol: "\uD83C\uDDE7\uD83C\uDDFF"
	  }, {
	    symbol: "\uD83C\uDDE7\uD83C\uDDEF"
	  }, {
	    symbol: "\uD83C\uDDE7\uD83C\uDDF2"
	  }, {
	    symbol: "\uD83C\uDDE7\uD83C\uDDF9"
	  }, {
	    symbol: "\uD83C\uDDE7\uD83C\uDDF4"
	  }, {
	    symbol: "\uD83C\uDDE7\uD83C\uDDE6"
	  }, {
	    symbol: "\uD83C\uDDE7\uD83C\uDDFC"
	  }, {
	    symbol: "\uD83C\uDDE7\uD83C\uDDF7"
	  }, {
	    symbol: "\uD83C\uDDEE\uD83C\uDDF4"
	  }, {
	    symbol: "\uD83C\uDDFB\uD83C\uDDEC"
	  }, {
	    symbol: "\uD83C\uDDE7\uD83C\uDDF3"
	  }, {
	    symbol: "\uD83C\uDDE7\uD83C\uDDEC"
	  }, {
	    symbol: "\uD83C\uDDE7\uD83C\uDDEB"
	  }, {
	    symbol: "\uD83C\uDDE7\uD83C\uDDEE"
	  }, {
	    symbol: "\uD83C\uDDF0\uD83C\uDDED"
	  }, {
	    symbol: "\uD83C\uDDE8\uD83C\uDDF2"
	  }, {
	    symbol: "\uD83C\uDDE8\uD83C\uDDE6"
	  }, {
	    symbol: "\uD83C\uDDEE\uD83C\uDDE8"
	  }, {
	    symbol: "\uD83C\uDDE8\uD83C\uDDFB"
	  }, {
	    symbol: "\uD83C\uDDE7\uD83C\uDDF6"
	  }, {
	    symbol: "\uD83C\uDDF0\uD83C\uDDFE"
	  }, {
	    symbol: "\uD83C\uDDE8\uD83C\uDDEB"
	  }, {
	    symbol: "\uD83C\uDDF9\uD83C\uDDE9"
	  }, {
	    symbol: "\uD83C\uDDE8\uD83C\uDDF1"
	  }, {
	    symbol: "\uD83C\uDDE8\uD83C\uDDF3"
	  }, {
	    symbol: "\uD83C\uDDE8\uD83C\uDDFD"
	  }, {
	    symbol: "\uD83C\uDDE8\uD83C\uDDF4"
	  }, {
	    symbol: "\uD83C\uDDF0\uD83C\uDDF2"
	  }, {
	    symbol: "\uD83C\uDDE8\uD83C\uDDEC"
	  }, {
	    symbol: "\uD83C\uDDE8\uD83C\uDDE9"
	  }, {
	    symbol: "\uD83C\uDDE8\uD83C\uDDF0"
	  }, {
	    symbol: "\uD83C\uDDE8\uD83C\uDDF7"
	  }, {
	    symbol: "\uD83C\uDDE8\uD83C\uDDEE"
	  }, {
	    symbol: "\uD83C\uDDED\uD83C\uDDF7"
	  }, {
	    symbol: "\uD83C\uDDE8\uD83C\uDDFA"
	  }, {
	    symbol: "\uD83C\uDDE8\uD83C\uDDFC"
	  }, {
	    symbol: "\uD83C\uDDE8\uD83C\uDDFE"
	  }, {
	    symbol: "\uD83C\uDDE8\uD83C\uDDFF"
	  }, {
	    symbol: "\uD83C\uDDE9\uD83C\uDDF0"
	  }, {
	    symbol: "\uD83C\uDDE9\uD83C\uDDEF"
	  }, {
	    symbol: "\uD83C\uDDE9\uD83C\uDDF2"
	  }, {
	    symbol: "\uD83C\uDDE9\uD83C\uDDF4"
	  }, {
	    symbol: "\uD83C\uDDEA\uD83C\uDDE8"
	  }, {
	    symbol: "\uD83C\uDDEA\uD83C\uDDEC"
	  }, {
	    symbol: "\uD83C\uDDF8\uD83C\uDDFB"
	  }, {
	    symbol: "\uD83C\uDDEC\uD83C\uDDF6"
	  }, {
	    symbol: "\uD83C\uDDEA\uD83C\uDDF7"
	  }, {
	    symbol: "\uD83C\uDDEA\uD83C\uDDF9"
	  }, {
	    symbol: "\uD83C\uDDEA\uD83C\uDDFA"
	  }, {
	    symbol: "\uD83C\uDDEB\uD83C\uDDF0"
	  }, {
	    symbol: "\uD83C\uDDEB\uD83C\uDDF4"
	  }, {
	    symbol: "\uD83C\uDDEB\uD83C\uDDEF"
	  }, {
	    symbol: "\uD83C\uDDEB\uD83C\uDDEE"
	  }, {
	    symbol: "\uD83C\uDDEB\uD83C\uDDF7"
	  }, {
	    symbol: "\uD83C\uDDEC\uD83C\uDDEB"
	  }, {
	    symbol: "\uD83C\uDDF5\uD83C\uDDEB"
	  }, {
	    symbol: "\uD83C\uDDEC\uD83C\uDDE6"
	  }, {
	    symbol: "\uD83C\uDDEC\uD83C\uDDF2"
	  }, {
	    symbol: "\uD83C\uDDEC\uD83C\uDDEA"
	  }, {
	    symbol: "\uD83C\uDDE9\uD83C\uDDEA"
	  }, {
	    symbol: "\uD83C\uDDEC\uD83C\uDDED"
	  }, {
	    symbol: "\uD83C\uDDEC\uD83C\uDDEE"
	  }, {
	    symbol: "\uD83C\uDDEC\uD83C\uDDF7"
	  }, {
	    symbol: "\uD83C\uDDEC\uD83C\uDDF1"
	  }, {
	    symbol: "\uD83C\uDDEC\uD83C\uDDE9"
	  }, {
	    symbol: "\uD83C\uDDEC\uD83C\uDDF5"
	  }, {
	    symbol: "\uD83C\uDDEC\uD83C\uDDFA"
	  }, {
	    symbol: "\uD83C\uDDEC\uD83C\uDDF9"
	  }, {
	    symbol: "\uD83C\uDDEC\uD83C\uDDF3"
	  }, {
	    symbol: "\uD83C\uDDEC\uD83C\uDDFC"
	  }, {
	    symbol: "\uD83C\uDDEC\uD83C\uDDFE"
	  }, {
	    symbol: "\uD83C\uDDED\uD83C\uDDF9"
	  }, {
	    symbol: "\uD83C\uDDED\uD83C\uDDF3"
	  }, {
	    symbol: "\uD83C\uDDED\uD83C\uDDF0"
	  }, {
	    symbol: "\uD83C\uDDED\uD83C\uDDFA"
	  }, {
	    symbol: "\uD83C\uDDEE\uD83C\uDDF8"
	  }, {
	    symbol: "\uD83C\uDDEE\uD83C\uDDF3"
	  }, {
	    symbol: "\uD83C\uDDEE\uD83C\uDDE9"
	  }, {
	    symbol: "\uD83C\uDDEE\uD83C\uDDF7"
	  }, {
	    symbol: "\uD83C\uDDEE\uD83C\uDDF6"
	  }, {
	    symbol: "\uD83C\uDDEE\uD83C\uDDEA"
	  }, {
	    symbol: "\uD83C\uDDEE\uD83C\uDDF2"
	  }, {
	    symbol: "\uD83C\uDDEE\uD83C\uDDF1"
	  }, {
	    symbol: "\uD83C\uDDEE\uD83C\uDDF9"
	  }, {
	    symbol: "\uD83C\uDDEF\uD83C\uDDF2"
	  }, {
	    symbol: "\uD83C\uDDEF\uD83C\uDDF5"
	  }, {
	    symbol: "\uD83C\uDDEF\uD83C\uDDEA"
	  }, {
	    symbol: "\uD83C\uDDEF\uD83C\uDDF4"
	  }, {
	    symbol: "\uD83C\uDDF0\uD83C\uDDFF"
	  }, {
	    symbol: "\uD83C\uDDF0\uD83C\uDDEA"
	  }, {
	    symbol: "\uD83C\uDDF0\uD83C\uDDEE"
	  }, {
	    symbol: "\uD83C\uDDFD\uD83C\uDDF0"
	  }, {
	    symbol: "\uD83C\uDDF0\uD83C\uDDFC"
	  }, {
	    symbol: "\uD83C\uDDF0\uD83C\uDDEC"
	  }, {
	    symbol: "\uD83C\uDDF1\uD83C\uDDE6"
	  }, {
	    symbol: "\uD83C\uDDF1\uD83C\uDDFB"
	  }, {
	    symbol: "\uD83C\uDDF1\uD83C\uDDE7"
	  }, {
	    symbol: "\uD83C\uDDF1\uD83C\uDDF8"
	  }, {
	    symbol: "\uD83C\uDDF1\uD83C\uDDF7"
	  }, {
	    symbol: "\uD83C\uDDF1\uD83C\uDDFE"
	  }, {
	    symbol: "\uD83C\uDDF1\uD83C\uDDEE"
	  }, {
	    symbol: "\uD83C\uDDF1\uD83C\uDDF9"
	  }, {
	    symbol: "\uD83C\uDDF1\uD83C\uDDFA"
	  }, {
	    symbol: "\uD83C\uDDF2\uD83C\uDDF4"
	  }, {
	    symbol: "\uD83C\uDDF2\uD83C\uDDF0"
	  }, {
	    symbol: "\uD83C\uDDF2\uD83C\uDDEC"
	  }, {
	    symbol: "\uD83C\uDDF2\uD83C\uDDFC"
	  }, {
	    symbol: "\uD83C\uDDF2\uD83C\uDDFE"
	  }, {
	    symbol: "\uD83C\uDDF2\uD83C\uDDFB"
	  }, {
	    symbol: "\uD83C\uDDF2\uD83C\uDDF1"
	  }, {
	    symbol: "\uD83C\uDDF2\uD83C\uDDF9"
	  }, {
	    symbol: "\uD83C\uDDF2\uD83C\uDDED"
	  }, {
	    symbol: "\uD83C\uDDF2\uD83C\uDDF7"
	  }, {
	    symbol: "\uD83C\uDDF2\uD83C\uDDFA"
	  }, {
	    symbol: "\uD83C\uDDFE\uD83C\uDDF9"
	  }, {
	    symbol: "\uD83C\uDDF2\uD83C\uDDFD"
	  }, {
	    symbol: "\uD83C\uDDEB\uD83C\uDDF2"
	  }, {
	    symbol: "\uD83C\uDDF2\uD83C\uDDE9"
	  }, {
	    symbol: "\uD83C\uDDF2\uD83C\uDDE8"
	  }, {
	    symbol: "\uD83C\uDDF2\uD83C\uDDF3"
	  }, {
	    symbol: "\uD83C\uDDF2\uD83C\uDDEA"
	  }, {
	    symbol: "\uD83C\uDDF2\uD83C\uDDF8"
	  }, {
	    symbol: "\uD83C\uDDF2\uD83C\uDDE6"
	  }, {
	    symbol: "\uD83C\uDDF2\uD83C\uDDFF"
	  }, {
	    symbol: "\uD83C\uDDF3\uD83C\uDDE6"
	  }, {
	    symbol: "\uD83C\uDDF3\uD83C\uDDF7"
	  }, {
	    symbol: "\uD83C\uDDF3\uD83C\uDDF5"
	  }, {
	    symbol: "\uD83C\uDDF3\uD83C\uDDF1"
	  }, {
	    symbol: "\uD83C\uDDF3\uD83C\uDDE8"
	  }, {
	    symbol: "\uD83C\uDDF3\uD83C\uDDFF"
	  }, {
	    symbol: "\uD83C\uDDF3\uD83C\uDDEE"
	  }, {
	    symbol: "\uD83C\uDDF3\uD83C\uDDEA"
	  }, {
	    symbol: "\uD83C\uDDF3\uD83C\uDDEC"
	  }, {
	    symbol: "\uD83C\uDDF3\uD83C\uDDFA"
	  }, {
	    symbol: "\uD83C\uDDF3\uD83C\uDDEB"
	  }, {
	    symbol: "\uD83C\uDDF0\uD83C\uDDF5"
	  }, {
	    symbol: "\uD83C\uDDF2\uD83C\uDDF5"
	  }, {
	    symbol: "\uD83C\uDDF3\uD83C\uDDF4"
	  }, {
	    symbol: "\uD83C\uDDF4\uD83C\uDDF2"
	  }, {
	    symbol: "\uD83C\uDDF5\uD83C\uDDF0"
	  }, {
	    symbol: "\uD83C\uDDF5\uD83C\uDDFC"
	  }, {
	    symbol: "\uD83C\uDDF5\uD83C\uDDF8"
	  }, {
	    symbol: "\uD83C\uDDF5\uD83C\uDDE6"
	  }, {
	    symbol: "\uD83C\uDDF5\uD83C\uDDEC"
	  }, {
	    symbol: "\uD83C\uDDF5\uD83C\uDDFE"
	  }, {
	    symbol: "\uD83C\uDDF5\uD83C\uDDEA"
	  }, {
	    symbol: "\uD83C\uDDF5\uD83C\uDDED"
	  }, {
	    symbol: "\uD83C\uDDF5\uD83C\uDDF3"
	  }, {
	    symbol: "\uD83C\uDDF5\uD83C\uDDF1"
	  }, {
	    symbol: "\uD83C\uDDF5\uD83C\uDDF9"
	  }, {
	    symbol: "\uD83C\uDDF5\uD83C\uDDF7"
	  }, {
	    symbol: "\uD83C\uDDF6\uD83C\uDDE6"
	  }, {
	    symbol: "\uD83C\uDDF7\uD83C\uDDF4"
	  }, {
	    symbol: "\uD83C\uDDF7\uD83C\uDDFA"
	  }, {
	    symbol: "\uD83C\uDDF7\uD83C\uDDFC"
	  }, {
	    symbol: "\uD83C\uDDFC\uD83C\uDDF8"
	  }, {
	    symbol: "\uD83C\uDDF8\uD83C\uDDF2"
	  }, {
	    symbol: "\uD83C\uDDF8\uD83C\uDDF9"
	  }, {
	    symbol: "\uD83C\uDDF8\uD83C\uDDE6"
	  }, {
	    symbol: "\uD83C\uDDF8\uD83C\uDDF3"
	  }, {
	    symbol: "\uD83C\uDDF7\uD83C\uDDF8"
	  }, {
	    symbol: "\uD83C\uDDF8\uD83C\uDDE8"
	  }, {
	    symbol: "\uD83C\uDDF8\uD83C\uDDF1"
	  }, {
	    symbol: "\uD83C\uDDF8\uD83C\uDDEC"
	  }, {
	    symbol: "\uD83C\uDDF8\uD83C\uDDFD"
	  }, {
	    symbol: "\uD83C\uDDF8\uD83C\uDDF0"
	  }, {
	    symbol: "\uD83C\uDDF8\uD83C\uDDEE"
	  }, {
	    symbol: "\uD83C\uDDEC\uD83C\uDDF8"
	  }, {
	    symbol: "\uD83C\uDDF8\uD83C\uDDE7"
	  }, {
	    symbol: "\uD83C\uDDF8\uD83C\uDDF4"
	  }, {
	    symbol: "\uD83C\uDDFF\uD83C\uDDE6"
	  }, {
	    symbol: "\uD83C\uDDF0\uD83C\uDDF7"
	  }, {
	    symbol: "\uD83C\uDDEA\uD83C\uDDF8"
	  }, {
	    symbol: "\uD83C\uDDF1\uD83C\uDDF0"
	  }, {
	    symbol: "\uD83C\uDDF8\uD83C\uDDED"
	  }, {
	    symbol: "\uD83C\uDDF0\uD83C\uDDF3"
	  }, {
	    symbol: "\uD83C\uDDF1\uD83C\uDDE8"
	  }, {
	    symbol: "\uD83C\uDDF5\uD83C\uDDF2"
	  }, {
	    symbol: "\uD83C\uDDFB\uD83C\uDDE8"
	  }, {
	    symbol: "\uD83C\uDDF8\uD83C\uDDE9"
	  }, {
	    symbol: "\uD83C\uDDF8\uD83C\uDDF7"
	  }, {
	    symbol: "\uD83C\uDDF8\uD83C\uDDFF"
	  }, {
	    symbol: "\uD83C\uDDF8\uD83C\uDDEA"
	  }, {
	    symbol: "\uD83C\uDDE8\uD83C\uDDED"
	  }, {
	    symbol: "\uD83C\uDDF8\uD83C\uDDFE"
	  }, {
	    symbol: "\uD83C\uDDF9\uD83C\uDDFC"
	  }, {
	    symbol: "\uD83C\uDDF9\uD83C\uDDEF"
	  }, {
	    symbol: "\uD83C\uDDF9\uD83C\uDDFF"
	  }, {
	    symbol: "\uD83C\uDDF9\uD83C\uDDED"
	  }, {
	    symbol: "\uD83C\uDDF9\uD83C\uDDF1"
	  }, {
	    symbol: "\uD83C\uDDF9\uD83C\uDDEC"
	  }, {
	    symbol: "\uD83C\uDDF9\uD83C\uDDF0"
	  }, {
	    symbol: "\uD83C\uDDF9\uD83C\uDDF4"
	  }, {
	    symbol: "\uD83C\uDDF9\uD83C\uDDF3"
	  }, {
	    symbol: "\uD83C\uDDF9\uD83C\uDDF7"
	  }, {
	    symbol: "\uD83C\uDDF9\uD83C\uDDF2"
	  }, {
	    symbol: "\uD83C\uDDF9\uD83C\uDDE8"
	  }, {
	    symbol: "\uD83C\uDDF9\uD83C\uDDFB"
	  }, {
	    symbol: "\uD83C\uDDFB\uD83C\uDDEE"
	  }, {
	    symbol: "\uD83C\uDDFA\uD83C\uDDEC"
	  }, {
	    symbol: "\uD83C\uDDFA\uD83C\uDDE6"
	  }, {
	    symbol: "\uD83C\uDDE6\uD83C\uDDEA"
	  }, {
	    symbol: "\uD83C\uDDEC\uD83C\uDDE7"
	  }, {
	    symbol: "\uD83C\uDDFA\uD83C\uDDF8"
	  }, {
	    symbol: "\uD83C\uDDFA\uD83C\uDDFE"
	  }, {
	    symbol: "\uD83C\uDDFA\uD83C\uDDFF"
	  }, {
	    symbol: "\uD83C\uDDFB\uD83C\uDDFA"
	  }, {
	    symbol: "\uD83C\uDDFB\uD83C\uDDE6"
	  }, {
	    symbol: "\uD83C\uDDFB\uD83C\uDDEA"
	  }, {
	    symbol: "\uD83C\uDDFB\uD83C\uDDF3"
	  }, {
	    symbol: "\uD83C\uDDFC\uD83C\uDDEB"
	  }, {
	    symbol: "\uD83C\uDDEA\uD83C\uDDED"
	  }, {
	    symbol: "\uD83C\uDDFE\uD83C\uDDEA"
	  }, {
	    symbol: "\uD83C\uDDFF\uD83C\uDDF2"
	  }, {
	    symbol: "\uD83C\uDDFF\uD83C\uDDFC"
	  }]
	}];

	/**
	 * Bitrix UI
	 * Smiles Vue component
	 *
	 * @package bitrix
	 * @subpackage ui
	 * @copyright 2001-2020 Bitrix
	 */
	ui_vue.WidgetBitrixVue.component('bx-smiles', {
	  /**
	   * @emits 'selectSmile' {text: string}
	   * @emits 'selectSet' {setId: number}
	   */
	  data: function data() {
	    return {
	      smiles: [],
	      sets: [],
	      emoji: [],
	      mode: 'smile',
	      emojiIcon: "\uD83D\uDE0D"
	    };
	  },
	  created: function created() {
	    var _this = this;
	    this.setSelected = 0;
	    this.serverLoad = false;
	    var restClient = this.$root.$bitrixRestClient || this.$Bitrix.RestClient.get();
	    this.smilesController = new SmileManager(restClient);
	    this.smilesController.loadFromCache().then(function (result) {
	      if (_this.serverLoad) return true;
	      _this.smiles = result.smiles;
	      _this.sets = result.sets.map(function (element, index) {
	        element.selected = _this.setSelected === index;
	        return element;
	      });
	    });
	    this.smilesController.loadFromServer().then(function (result) {
	      _this.smiles = result.smiles;
	      _this.sets = result.sets.map(function (element, index) {
	        element.selected = _this.setSelected === index;
	        return element;
	      });
	    });
	    this.emoji = emoji;
	  },
	  methods: {
	    selectSet: function selectSet(setId) {
	      var _this2 = this;
	      this.mode = "smile";
	      this.$emit('selectSet', {
	        setId: setId
	      });
	      this.smilesController.changeSet(setId).then(function (result) {
	        _this2.smiles = result;
	        _this2.sets.map(function (set) {
	          set.selected = set.id === setId;
	          if (set.selected) {
	            _this2.setSelected = setId;
	          }
	          return set;
	        });
	        _this2.$refs.elements.scrollTop = 0;
	      });
	    },
	    selectSmile: function selectSmile(text) {
	      this.$emit('selectSmile', {
	        text: ' ' + text + ' '
	      });
	    },
	    switchToEmoji: function switchToEmoji() {
	      this.mode = 'emoji';
	      this.sets.map(function (set) {
	        set.selected = false;
	      });
	    },
	    showCategory: function showCategory(category) {
	      if (this.isWindows()) {
	        return category.showForWindows;
	      } else {
	        return true;
	      }
	    },
	    isMac: function isMac() {
	      return navigator.userAgent.toLowerCase().includes('macintosh');
	    },
	    isLinux: function isLinux() {
	      return navigator.userAgent.toLowerCase().includes('linux');
	    },
	    isWindows: function isWindows() {
	      return navigator.userAgent.toLowerCase().includes('windows') || !this.isMac() && !this.isLinux();
	    }
	  },
	  computed: {
	    showEmoji: function showEmoji() {
	      return this.$Bitrix.Loc.getMessage('UTF_MODE') === 'Y';
	    },
	    isEmojiMode: function isEmojiMode() {
	      return this.mode === 'emoji';
	    },
	    isSmileMode: function isSmileMode() {
	      return this.mode === "smile";
	    },
	    emojiIconStyle: function emojiIconStyle() {
	      var style = 'bx-ui-smiles-set-emoji';
	      if (this.isMac()) {
	        return style += '-mac';
	      } else if (this.isLinux()) {
	        return style += '-linux';
	      } else if (this.isWindows()) {
	        return style += '-win';
	      } else {
	        return style;
	      }
	    }
	  },
	  template: "\n\t\t<div class=\"bx-ui-smiles-box\">\n\t\t\t<div class=\"bx-ui-smiles-elements-wrap\" ref=\"elements\">\n\t\t\t\t<template v-if=\"!smiles.length\">\n\t\t\t\t\t<svg class=\"bx-ui-smiles-loading-circular\" viewBox=\"25 25 50 50\">\n\t\t\t\t\t\t<circle class=\"bx-ui-smiles-loading-path\" cx=\"50\" cy=\"50\" r=\"20\" fill=\"none\" stroke-miterlimit=\"10\"/>\n\t\t\t\t\t\t<circle class=\"bx-ui-smiles-loading-inner-path\" cx=\"50\" cy=\"50\" r=\"20\" fill=\"none\" stroke-miterlimit=\"10\"/>\n\t\t\t\t\t</svg>\n\t\t\t\t</template>\n\t\t\t\t<template v-else-if=\"isSmileMode\">\n\t\t\t\t\t<template v-for=\"smile in smiles\">\n\t\t\t\t\t\t<div class=\"bx-ui-smiles-smile\">\n\t\t\t\t\t\t\t<img v-bx-lazyload :key=\"smile.id\"\n\t\t\t\t\t\t\t\tclass=\"bx-ui-smiles-smile-icon\"\n\t\t\t\t\t\t\t\t:data-lazyload-src=\"smile.image\"\n\t\t\t\t\t\t\t\tdata-lazyload-error-class=\"bx-ui-smiles-smile-icon-error\"\n\t\t\t\t\t\t\t\t:title=\"smile.name\"\n\t\t\t\t\t\t\t\t:style=\"{height: (smile.originalHeight*0.5)+'px', width: (smile.originalWidth*0.5)+'px'}\"\n\t\t\t\t\t\t\t\t@click=\"selectSmile(smile.typing)\"\n\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</template>\n\t\t\t\t</template>\n\t\t\t\t<template v-else-if=\"isEmojiMode\">\n\t\t\t\t\t<div v-for=\"category in emoji\" class=\"bx-ui-smiles-emoji-wrap\">\n\t\t\t\t\t\t<template v-if=\"showCategory(category)\">\n\t\t\t\t\t\t\t<div class=\"bx-ui-smiles-category\">\n\t\t\t\t\t\t\t\t{{ $Bitrix.Loc.getMessage('UI_VUE_SMILES_EMOJI_CATEGORY_' + category.code) }}\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t<template v-for=\"element in category.emoji\">\n\t\t\t\t\t\t\t\t<div class=\"bx-ui-smiles-smile\" style=\"font-size: 28px;\">\n\t\t\t\t\t\t\t\t\t<div class=\"bx-ui-smiles-smile-icon\" @click=\"selectSmile(element.symbol)\">\n\t\t\t\t\t\t\t\t\t\t{{ element.symbol }}\n\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t</template>\n\t\t\t\t\t\t</template>\n\t\t\t\t\t</div>\n\t\t\t\t</template>\n\t\t\t</div>\n\t\t\t<template v-if=\"sets.length > 1 || emoji && showEmoji\">\n\t\t\t\t<div class=\"bx-ui-smiles-sets\">\n\t\t\t\t\t<template v-for=\"set in sets\">\n\t\t\t\t\t\t<div :class=\"['bx-ui-smiles-set', {'bx-ui-smiles-set-selected': set.selected}]\">\n\t\t\t\t\t\t\t<img v-bx-lazyload\n\t\t\t\t\t\t\t\t:key=\"set.id\"\n\t\t\t\t\t\t\t\tclass=\"bx-ui-smiles-set-icon\"\n\t\t\t\t\t\t\t\t:data-lazyload-src=\"set.image\"\n\t\t\t\t\t\t\t\tdata-lazyload-error-class=\"bx-ui-smiles-set-icon-error\"\n\t\t\t\t\t\t\t\t:title=\"set.name\"\n\t\t\t\t\t\t\t\t@click=\"selectSet(set.id)\"\n\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</template>\n\t\t\t\t\t<div v-if=\"emoji && showEmoji\" :class=\"['bx-ui-smiles-set', {'bx-ui-smiles-set-selected': isEmojiMode}]\">\n\t\t\t\t\t\t<div :class=\"['bx-ui-smiles-set-icon', emojiIconStyle]\" @click=\"switchToEmoji\">\n\t\t\t\t\t\t \t{{ emojiIcon }}\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t</template>\n\t\t</div>\n\t"
	});

}((this.window = this.window || {}),BX,window,BX,BX.Dexie3));





// file: /bitrix/js/imopenlines/component/widget/dist/widget.bundle.js
(function (exports,main_polyfill_customevent,pull_component_status,im_component_dialog,im_component_textarea,im_view_quotepanel,imopenlines_component_message,imopenlines_component_form,rest_client,im_provider_rest,main_date,pull_client,ui_vue_components_crm_form,im_controller,im_lib_cookie,im_lib_localstorage,im_lib_utils,main_md5,im_lib_uploader,main_core,im_lib_logger,im_eventHandler,im_const,main_core_minimal,ui_vue_vuex,ui_vue,main_core_events) {
	'use strict';

	/**
	 * Bitrix OpenLines widget
	 * Widget constants
	 *
	 * @package bitrix
	 * @subpackage imopenlines
	 * @copyright 2001-2019 Bitrix
	 */

	function GetObjectValues(source) {
	  var destination = [];
	  for (var value in source) {
	    if (source.hasOwnProperty(value)) {
	      destination.push(source[value]);
	    }
	  }
	  return destination;
	}

	/* region 01. Constants */

	var VoteType = Object.freeze({
	  none: 'none',
	  like: 'like',
	  dislike: 'dislike'
	});
	var LanguageType = Object.freeze({
	  russian: 'ru',
	  ukraine: 'ua',
	  world: 'en'
	});
	var FormType = Object.freeze({
	  none: 'none',
	  like: 'like',
	  smile: 'smile',
	  consent: 'consent',
	  welcome: 'welcome',
	  offline: 'offline',
	  history: 'history'
	});
	var LocationType = Object.freeze({
	  topLeft: 1,
	  topMiddle: 2,
	  topBottom: 3,
	  bottomLeft: 6,
	  bottomMiddle: 5,
	  bottomRight: 4
	});
	var LocationStyle = Object.freeze({
	  1: 'top-left',
	  2: 'top-center',
	  3: 'top-right',
	  6: 'bottom-left',
	  5: 'bottom-center',
	  4: 'bottom-right'
	});
	var WidgetBaseSize = Object.freeze({
	  width: 435,
	  height: 557
	});
	var WidgetMinimumSize = Object.freeze({
	  width: 340,
	  height: 435
	});
	var SubscriptionType = Object.freeze({
	  configLoaded: 'configLoaded',
	  widgetOpen: 'widgetOpen',
	  widgetClose: 'widgetClose',
	  sessionStart: 'sessionStart',
	  sessionOperatorChange: 'sessionOperatorChange',
	  sessionFinish: 'sessionFinish',
	  operatorMessage: 'operatorMessage',
	  userForm: 'userForm',
	  userMessage: 'userMessage',
	  userFile: 'userFile',
	  userVote: 'userVote',
	  every: 'every'
	});
	var SubscriptionTypeCheck = GetObjectValues(SubscriptionType);
	var RestMethod = Object.freeze({
	  widgetUserRegister: 'imopenlines.widget.user.register',
	  widgetChatCreate: 'imopenlines.widget.chat.create',
	  widgetConfigGet: 'imopenlines.widget.config.get',
	  widgetDialogGet: 'imopenlines.widget.dialog.get',
	  widgetDialogList: 'imopenlines.widget.dialog.list',
	  widgetUserGet: 'imopenlines.widget.user.get',
	  widgetUserConsentApply: 'imopenlines.widget.user.consent.apply',
	  widgetVoteSend: 'imopenlines.widget.vote.send',
	  widgetActionSend: 'imopenlines.widget.action.send',
	  pullServerTime: 'server.time',
	  pullConfigGet: 'pull.config.get'
	});
	var RestMethodCheck = GetObjectValues(RestMethod);
	var RestAuth = Object.freeze({
	  guest: 'guest'
	});
	var SessionStatus = Object.freeze({
	  "new": 0,
	  skip: 5,
	  answer: 10,
	  client: 20,
	  clientAfterOperator: 25,
	  operator: 40,
	  waitClient: 50,
	  close: 60,
	  spam: 65,
	  duplicate: 69,
	  silentlyClose: 75
	});
	var WidgetEventType = Object.freeze({
	  showForm: 'IMOL.Widget:showForm',
	  hideForm: 'IMOL.Widget:hideForm',
	  processMessagesToSendQueue: 'IMOL.Widget:processMessagesToSendQueue',
	  requestData: 'IMOL.Widget:requestData',
	  showConsent: 'IMOL.Widget:showConsent',
	  acceptConsent: 'IMOL.Widget:acceptConsent',
	  consentAccepted: 'IMOL.Widget:consentAccepted',
	  declineConsent: 'IMOL.Widget:declineConsent',
	  consentDeclined: 'IMOL.Widget:consentDeclined',
	  sendDialogVote: 'IMOL.Widget:sendDialogVote',
	  createSession: 'IMOL.Widget:createSession',
	  openSession: 'IMOL.Widget:openSession'
	});

	/**
	 * Bitrix OpenLines widget
	 * Widget model (Vuex Builder model)
	 *
	 * @package bitrix
	 * @subpackage imopenlines
	 * @copyright 2001-2019 Bitrix
	 */
	var WidgetModel = /*#__PURE__*/function (_VuexBuilderModel) {
	  babelHelpers.inherits(WidgetModel, _VuexBuilderModel);
	  function WidgetModel() {
	    babelHelpers.classCallCheck(this, WidgetModel);
	    return babelHelpers.possibleConstructorReturn(this, babelHelpers.getPrototypeOf(WidgetModel).apply(this, arguments));
	  }
	  babelHelpers.createClass(WidgetModel, [{
	    key: "getName",
	    /**
	     * @inheritDoc
	     */
	    value: function getName() {
	      return 'widget';
	    }
	  }, {
	    key: "getState",
	    value: function getState() {
	      return {
	        common: {
	          configId: 0,
	          configName: '',
	          host: this.getVariable('common.host', location.protocol + '//' + location.host),
	          pageMode: this.getVariable('common.pageMode', false),
	          copyright: this.getVariable('common.copyright', true),
	          copyrightUrl: this.getVariable('common.copyrightUrl', 'https://bitrix24.com'),
	          location: this.getVariable('common.location', LocationType.bottomRight),
	          styles: {
	            backgroundColor: this.getVariable('styles.backgroundColor', '#17a3ea'),
	            iconColor: this.getVariable('styles.iconColor', '#ffffff')
	          },
	          vote: {
	            enable: false,
	            beforeFinish: true,
	            messageText: this.getVariable('vote.messageText', ''),
	            messageLike: this.getVariable('vote.messageLike', ''),
	            messageDislike: this.getVariable('vote.messageDislike', '')
	          },
	          textMessages: {
	            bxLivechatOnlineLine1: this.getVariable('textMessages.bxLivechatOnlineLine1', ''),
	            bxLivechatOnlineLine2: this.getVariable('textMessages.bxLivechatOnlineLine2', ''),
	            bxLivechatOffline: this.getVariable('textMessages.bxLivechatOffline', ''),
	            bxLivechatTitle: ''
	          },
	          online: false,
	          operators: [],
	          connectors: [],
	          showForm: FormType.none,
	          showed: false,
	          reopen: false,
	          dragged: false,
	          textareaHeight: 0,
	          widgetHeight: 0,
	          widgetWidth: 0,
	          showConsent: false,
	          consentUrl: '',
	          dialogStart: false,
	          watchTyping: false,
	          showSessionId: false,
	          isCreateSessionMode: false,
	          crmFormsSettings: {
	            useWelcomeForm: false,
	            welcomeFormId: 0,
	            welcomeFormSec: '',
	            welcomeFormDelay: false,
	            welcomeFormFilled: false,
	            successText: '',
	            errorText: ''
	          }
	        },
	        dialog: {
	          sessionId: 0,
	          sessionClose: true,
	          sessionStatus: 0,
	          userVote: VoteType.none,
	          closeVote: false,
	          userConsent: false,
	          operatorChatId: 0,
	          operator: {
	            id: 0,
	            name: '',
	            firstName: '',
	            lastName: '',
	            workPosition: '',
	            avatar: '',
	            online: false
	          }
	        },
	        user: {
	          id: -1,
	          hash: '',
	          name: '',
	          firstName: '',
	          lastName: '',
	          avatar: '',
	          email: '',
	          phone: '',
	          www: '',
	          gender: 'M',
	          position: ''
	        }
	      };
	    }
	  }, {
	    key: "getStateSaveException",
	    value: function getStateSaveException() {
	      return {
	        common: {
	          host: null,
	          pageMode: null,
	          copyright: null,
	          copyrightUrl: null,
	          styles: null,
	          dragged: null,
	          showed: null,
	          showConsent: null,
	          showForm: null
	        }
	      };
	    }
	  }, {
	    key: "getMutations",
	    value: function getMutations() {
	      var _this = this;
	      return {
	        common: function common(state, payload) {
	          if (typeof payload.configId === 'number') {
	            state.common.configId = payload.configId;
	          }
	          if (typeof payload.configName === 'string') {
	            state.common.configName = payload.configName;
	          }
	          if (typeof payload.online === 'boolean') {
	            state.common.online = payload.online;
	          }
	          if (im_lib_utils.Utils.types.isPlainObject(payload.vote)) {
	            if (typeof payload.vote.enable === 'boolean') {
	              state.common.vote.enable = payload.vote.enable;
	            }
	            if (typeof payload.vote.beforeFinish === 'boolean') {
	              state.common.vote.beforeFinish = payload.vote.beforeFinish;
	            }
	            if (typeof payload.vote.messageText === 'string') {
	              state.common.vote.messageText = payload.vote.messageText;
	            }
	            if (typeof payload.vote.messageLike === 'string') {
	              state.common.vote.messageLike = payload.vote.messageLike;
	            }
	            if (typeof payload.vote.messageDislike === 'string') {
	              state.common.vote.messageDislike = payload.vote.messageDislike;
	            }
	          }
	          if (im_lib_utils.Utils.types.isPlainObject(payload.textMessages)) {
	            if (typeof payload.textMessages.bxLivechatOnlineLine1 === 'string' && payload.textMessages.bxLivechatOnlineLine1 !== '') {
	              state.common.textMessages.bxLivechatOnlineLine1 = payload.textMessages.bxLivechatOnlineLine1;
	            }
	            if (typeof payload.textMessages.bxLivechatOnlineLine2 === 'string' && payload.textMessages.bxLivechatOnlineLine2 !== '') {
	              state.common.textMessages.bxLivechatOnlineLine2 = payload.textMessages.bxLivechatOnlineLine2;
	            }
	            if (typeof payload.textMessages.bxLivechatOffline === 'string' && payload.textMessages.bxLivechatOffline !== '') {
	              state.common.textMessages.bxLivechatOffline = payload.textMessages.bxLivechatOffline;
	            }
	            if (typeof payload.textMessages.bxLivechatTitle === 'string' && payload.textMessages.bxLivechatTitle !== '') {
	              state.common.textMessages.bxLivechatTitle = payload.textMessages.bxLivechatTitle;
	            }
	          }
	          if (typeof payload.dragged === 'boolean') {
	            state.common.dragged = payload.dragged;
	          }
	          if (typeof payload.textareaHeight === 'number') {
	            state.common.textareaHeight = payload.textareaHeight;
	          }
	          if (typeof payload.widgetHeight === 'number') {
	            state.common.widgetHeight = payload.widgetHeight;
	          }
	          if (typeof payload.widgetWidth === 'number') {
	            state.common.widgetWidth = payload.widgetWidth;
	          }
	          if (typeof payload.showConsent === 'boolean') {
	            state.common.showConsent = payload.showConsent;
	          }
	          if (typeof payload.consentUrl === 'string') {
	            state.common.consentUrl = payload.consentUrl;
	          }
	          if (typeof payload.showed === 'boolean') {
	            state.common.showed = payload.showed;
	            payload.reopen = im_lib_utils.Utils.device.isMobile() ? false : payload.showed;
	          }
	          if (typeof payload.reopen === 'boolean') {
	            state.common.reopen = payload.reopen;
	          }
	          if (typeof payload.copyright === 'boolean') {
	            state.common.copyright = payload.copyright;
	          }
	          if (typeof payload.dialogStart === 'boolean') {
	            state.common.dialogStart = payload.dialogStart;
	          }
	          if (typeof payload.watchTyping === 'boolean') {
	            state.common.watchTyping = payload.watchTyping;
	          }
	          if (typeof payload.showSessionId === 'boolean') {
	            state.common.showSessionId = payload.showSessionId;
	          }
	          if (payload.operators instanceof Array) {
	            state.common.operators = payload.operators;
	          }
	          if (payload.connectors instanceof Array) {
	            state.common.connectors = payload.connectors;
	          }
	          if (typeof payload.showForm === 'string' && typeof FormType[payload.showForm] !== 'undefined') {
	            if (payload.showForm === FormType.like && !!state.dialog.closeVote) {
	              payload.showForm = FormType.none;
	            }
	            state.common.showForm = payload.showForm;
	          }
	          if (typeof payload.location === 'number' && typeof LocationStyle[payload.location] !== 'undefined') {
	            if (state.common.location !== payload.location) {
	              state.common.widgetHeight = 0;
	              state.common.widgetWidth = 0;
	              state.common.location = payload.location;
	            }
	          }
	          if (im_lib_utils.Utils.types.isPlainObject(payload.crmFormsSettings)) {
	            if (typeof payload.crmFormsSettings.useWelcomeForm === 'string') {
	              state.common.crmFormsSettings.useWelcomeForm = payload.crmFormsSettings.useWelcomeForm === 'Y';
	            }
	            if (typeof payload.crmFormsSettings.welcomeFormId === 'string') {
	              state.common.crmFormsSettings.welcomeFormId = payload.crmFormsSettings.welcomeFormId;
	            }
	            if (typeof payload.crmFormsSettings.welcomeFormSec === 'string') {
	              state.common.crmFormsSettings.welcomeFormSec = payload.crmFormsSettings.welcomeFormSec;
	            }
	            if (typeof payload.crmFormsSettings.welcomeFormDelay === 'string') {
	              state.common.crmFormsSettings.welcomeFormDelay = payload.crmFormsSettings.welcomeFormDelay === 'Y';
	            }
	            if (typeof payload.crmFormsSettings.successText === 'string' && payload.crmFormsSettings.successText !== '') {
	              state.common.crmFormsSettings.successText = payload.crmFormsSettings.successText;
	            }
	            if (typeof payload.crmFormsSettings.errorText === 'string' && payload.crmFormsSettings.errorText !== '') {
	              state.common.crmFormsSettings.errorText = payload.crmFormsSettings.errorText;
	            }
	          }
	          if (typeof payload.isCreateSessionMode === 'boolean') {
	            state.common.isCreateSessionMode = payload.isCreateSessionMode;
	          }
	          if (_this.isSaveNeeded({
	            common: payload
	          })) {
	            _this.saveState(state);
	          }
	        },
	        dialog: function dialog(state, payload) {
	          if (typeof payload.sessionId === 'number') {
	            state.dialog.sessionId = payload.sessionId;
	          }
	          if (typeof payload.sessionClose === 'boolean') {
	            state.dialog.sessionClose = payload.sessionClose;
	          }
	          if (typeof payload.sessionStatus === 'number') {
	            state.dialog.sessionStatus = payload.sessionStatus;
	          }
	          if (typeof payload.userConsent === 'boolean') {
	            state.dialog.userConsent = payload.userConsent;
	          }
	          if (typeof payload.userVote === 'string' && typeof payload.userVote !== 'undefined') {
	            state.dialog.userVote = payload.userVote;
	          }
	          if (typeof payload.closeVote === 'boolean') {
	            state.dialog.closeVote = payload.closeVote;
	            if (!!payload.closeVote && state.common.showForm === FormType.like) {
	              state.common.showForm = FormType.none;
	            }
	          }
	          if (typeof payload.operatorChatId === 'number') {
	            state.dialog.operatorChatId = payload.operatorChatId;
	          }
	          if (im_lib_utils.Utils.types.isPlainObject(payload.operator)) {
	            if (typeof payload.operator.id === 'number') {
	              state.dialog.operator.id = payload.operator.id;
	            }
	            if (typeof payload.operator.name === 'string' || typeof payload.operator.name === 'number') {
	              state.dialog.operator.name = payload.operator.name.toString();
	            }
	            if (typeof payload.operator.lastName === 'string' || typeof payload.operator.lastName === 'number') {
	              state.dialog.operator.lastName = payload.operator.lastName.toString();
	            }
	            if (typeof payload.operator.firstName === 'string' || typeof payload.operator.firstName === 'number') {
	              state.dialog.operator.firstName = payload.operator.firstName.toString();
	            }
	            if (typeof payload.operator.workPosition === 'string' || typeof payload.operator.workPosition === 'number') {
	              state.dialog.operator.workPosition = payload.operator.workPosition.toString();
	            }
	            if (typeof payload.operator.avatar === 'string') {
	              if (!payload.operator.avatar || payload.operator.avatar.startsWith('http')) {
	                state.dialog.operator.avatar = payload.operator.avatar;
	              } else {
	                state.dialog.operator.avatar = state.common.host + payload.operator.avatar;
	              }
	            }
	            if (typeof payload.operator.online === 'boolean') {
	              state.dialog.operator.online = payload.operator.online;
	            }
	          }
	          if (_this.isSaveNeeded({
	            dialog: payload
	          })) {
	            _this.saveState(state);
	          }
	        },
	        user: function user(state, payload) {
	          if (typeof payload.id === 'number') {
	            state.user.id = payload.id;
	          }
	          if (typeof payload.hash === 'string' && payload.hash !== state.user.hash) {
	            state.user.hash = payload.hash;
	            im_lib_cookie.Cookie.set(null, 'LIVECHAT_HASH', payload.hash, {
	              expires: 365 * 86400,
	              path: '/'
	            });
	          }
	          if (typeof payload.name === 'string' || typeof payload.name === 'number') {
	            state.user.name = payload.name.toString();
	          }
	          if (typeof payload.firstName === 'string' || typeof payload.firstName === 'number') {
	            state.user.firstName = payload.firstName.toString();
	          }
	          if (typeof payload.lastName === 'string' || typeof payload.lastName === 'number') {
	            state.user.lastName = payload.lastName.toString();
	          }
	          if (typeof payload.avatar === 'string') {
	            state.user.avatar = payload.avatar;
	          }
	          if (typeof payload.email === 'string') {
	            state.user.email = payload.email;
	          }
	          if (typeof payload.phone === 'string' || typeof payload.phone === 'number') {
	            state.user.phone = payload.phone.toString();
	          }
	          if (typeof payload.www === 'string') {
	            state.user.www = payload.www;
	          }
	          if (typeof payload.gender === 'string') {
	            state.user.gender = payload.gender;
	          }
	          if (typeof payload.position === 'string') {
	            state.user.position = payload.position;
	          }
	          if (_this.isSaveNeeded({
	            user: payload
	          })) {
	            _this.saveState(state);
	          }
	        }
	      };
	    }
	  }, {
	    key: "getActions",
	    value: function getActions() {
	      var _this2 = this;
	      return {
	        show: function show(_ref) {
	          var commit = _ref.commit;
	          commit('common', {
	            showed: true
	          });
	        },
	        setVoteDateFinish: function setVoteDateFinish(_ref2, payload) {
	          var commit = _ref2.commit,
	            dispatch = _ref2.dispatch,
	            state = _ref2.state;
	          if (!payload) {
	            clearTimeout(_this2.setVoteDateTimeout);
	            commit('dialog', {
	              closeVote: false
	            });
	            return true;
	          }
	          var totalDelay = new Date(payload).getTime() - new Date().getTime();
	          var dayTimestamp = 10000;
	          clearTimeout(_this2.setVoteDateTimeout);
	          if (payload) {
	            if (totalDelay && !state.dialog.closeVote) {
	              commit('dialog', {
	                closeVote: false
	              });
	            }
	            var delay = totalDelay;
	            if (totalDelay > dayTimestamp) {
	              delay = dayTimestamp;
	            }
	            _this2.setVoteDateTimeout = setTimeout(function requestCloseVote() {
	              delay = new Date(payload).getTime() - new Date().getTime();
	              if (delay > 0) {
	                if (delay > dayTimestamp) {
	                  delay = dayTimestamp;
	                }
	                setTimeout(requestCloseVote, delay);
	              } else {
	                commit('dialog', {
	                  closeVote: true
	                });
	              }
	            }, delay);
	          }
	        }
	      };
	    }
	  }]);
	  return WidgetModel;
	}(ui_vue_vuex.WidgetVuexBuilderModel);

	/**
	 * Bitrix OpenLines widget
	 * Rest client (base on BX.RestClient)
	 *
	 * @package bitrix
	 * @subpackage imopenlines
	 * @copyright 2001-2019 Bitrix
	 */
	var WidgetRestClient = /*#__PURE__*/function () {
	  function WidgetRestClient(params) {
	    babelHelpers.classCallCheck(this, WidgetRestClient);
	    this.queryAuthRestore = false;
	    this.setAuthId(RestAuth.guest);
	    this.restClient = new rest_client.RestClient({
	      endpoint: params.endpoint,
	      queryParams: this.queryParams,
	      cors: true
	    });
	  }
	  babelHelpers.createClass(WidgetRestClient, [{
	    key: "setAuthId",
	    value: function setAuthId(authId) {
	      var customAuthId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
	      if (babelHelpers["typeof"](this.queryParams) !== 'object') {
	        this.queryParams = {};
	      }
	      if (authId == RestAuth.guest || typeof authId === 'string' && authId.match(/^[a-f0-9]{32}$/)) {
	        this.queryParams.livechat_auth_id = authId;
	      } else {
	        console.error("%LiveChatRestClient.setAuthId: auth is not correct (%c".concat(authId, "%c)"), "color: black;", "font-weight: bold; color: red", "color: black");
	        return false;
	      }
	      if (authId == RestAuth.guest && typeof customAuthId === 'string' && customAuthId.match(/^[a-f0-9]{32}$/)) {
	        this.queryParams.livechat_custom_auth_id = customAuthId;
	      }
	      return true;
	    }
	  }, {
	    key: "getAuthId",
	    value: function getAuthId() {
	      if (babelHelpers["typeof"](this.queryParams) !== 'object') {
	        this.queryParams = {};
	      }
	      return this.queryParams.livechat_auth_id || null;
	    }
	  }, {
	    key: "callMethod",
	    value: function callMethod(method, params, callback, sendCallback) {
	      var _this = this;
	      var logTag = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
	      if (!logTag) {
	        logTag = im_lib_utils.Utils.getLogTrackingParams({
	          name: method
	        });
	      }
	      var promise = new BX.Promise();

	      // TODO: Callbacks methods will not work!
	      this.restClient.callMethod(method, params, null, sendCallback, logTag).then(function (result) {
	        _this.queryAuthRestore = false;
	        promise.fulfill(result);
	      })["catch"](function (result) {
	        var error = result.error();
	        if (error.ex.error == 'LIVECHAT_AUTH_WIDGET_USER') {
	          _this.setAuthId(error.ex.hash);
	          if (method === RestMethod.widgetUserRegister) {
	            console.warn("BX.LiveChatRestClient: ".concat(error.ex.error_description, " (").concat(error.ex.error, ")"));
	            _this.queryAuthRestore = false;
	            promise.reject(result);
	            return false;
	          }
	          if (!_this.queryAuthRestore) {
	            console.warn('BX.LiveChatRestClient: your auth-token has expired, send query with a new token');
	            _this.queryAuthRestore = true;
	            _this.restClient.callMethod(method, params, null, sendCallback, logTag).then(function (result) {
	              _this.queryAuthRestore = false;
	              promise.fulfill(result);
	            })["catch"](function (result) {
	              _this.queryAuthRestore = false;
	              promise.reject(result);
	            });
	            return false;
	          }
	        }
	        _this.queryAuthRestore = false;
	        promise.reject(result);
	      });
	      return promise;
	    }
	  }, {
	    key: "callBatch",
	    value: function callBatch(calls, callback, bHaltOnError, sendCallback, logTag) {
	      var _this2 = this;
	      var resultCallback = function resultCallback(result) {
	        for (var method in calls) {
	          if (!calls.hasOwnProperty(method)) {
	            continue;
	          }
	          var _error = result[method].error();
	          if (_error && _error.ex.error == 'LIVECHAT_AUTH_WIDGET_USER') {
	            _this2.setAuthId(_error.ex.hash);
	            if (method === RestMethod.widgetUserRegister) {
	              console.warn("BX.LiveChatRestClient: ".concat(_error.ex.error_description, " (").concat(_error.ex.error, ")"));
	              _this2.queryAuthRestore = false;
	              callback(result);
	              return false;
	            }
	            if (!_this2.queryAuthRestore) {
	              console.warn('BX.LiveChatRestClient: your auth-token has expired, send query with a new token');
	              _this2.queryAuthRestore = true;
	              _this2.restClient.callBatch(calls, callback, bHaltOnError, sendCallback, logTag);
	              return false;
	            }
	          }
	        }
	        _this2.queryAuthRestore = false;
	        callback(result);
	        return true;
	      };
	      return this.restClient.callBatch(calls, resultCallback, bHaltOnError, sendCallback, logTag);
	    }
	  }]);
	  return WidgetRestClient;
	}();

	/**
	 * Bitrix OpenLines widget
	 * Widget Rest answers (Rest Answer Handler)
	 *
	 * @package bitrix
	 * @subpackage imopenlines
	 * @copyright 2001-2019 Bitrix
	 */
	var WidgetRestAnswerHandler = /*#__PURE__*/function (_BaseRestHandler) {
	  babelHelpers.inherits(WidgetRestAnswerHandler, _BaseRestHandler);
	  function WidgetRestAnswerHandler() {
	    var _this;
	    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	    babelHelpers.classCallCheck(this, WidgetRestAnswerHandler);
	    _this = babelHelpers.possibleConstructorReturn(this, babelHelpers.getPrototypeOf(WidgetRestAnswerHandler).call(this, props));
	    _this.widget = props.widget;
	    return _this;
	  }
	  babelHelpers.createClass(WidgetRestAnswerHandler, [{
	    key: "handleImopenlinesWidgetConfigGetSuccess",
	    value: function handleImopenlinesWidgetConfigGetSuccess(data) {
	      this.store.commit('widget/common', {
	        configId: data.configId,
	        configName: data.configName,
	        vote: data.vote,
	        textMessages: data.textMessages,
	        operators: data.operators || [],
	        online: data.online,
	        consentUrl: data.consentUrl,
	        connectors: data.connectors || [],
	        watchTyping: data.watchTyping,
	        showSessionId: data.showSessionId,
	        crmFormsSettings: data.crmFormsSettings
	      });
	      this.store.commit('application/set', {
	        disk: data.disk
	      });
	      this.widget.addLocalize(data.serverVariables);
	      im_lib_localstorage.LocalStorage.set(this.widget.getSiteId(), 0, 'serverVariables', data.serverVariables || {});
	    }
	  }, {
	    key: "handleImopenlinesWidgetUserRegisterSuccess",
	    value: function handleImopenlinesWidgetUserRegisterSuccess(data) {
	      this.widget.restClient.setAuthId(data.hash);
	      var previousData = [];
	      if (typeof this.store.state.messages.collection[this.controller.application.getChatId()] !== 'undefined') {
	        previousData = this.store.state.messages.collection[this.controller.application.getChatId()];
	      }
	      this.store.commit('messages/initCollection', {
	        chatId: data.chatId,
	        messages: previousData
	      });
	      this.store.commit('dialogues/initCollection', {
	        dialogId: data.dialogId,
	        fields: {
	          entityType: 'LIVECHAT',
	          type: 'livechat'
	        }
	      });
	      this.store.commit('application/set', {
	        dialog: {
	          chatId: data.chatId,
	          dialogId: 'chat' + data.chatId
	        }
	      });
	    }
	  }, {
	    key: "handleImopenlinesWidgetChatCreateSuccess",
	    value: function handleImopenlinesWidgetChatCreateSuccess(data) {
	      this.widget.restClient.setAuthId(data.hash);
	      this.store.commit('messages/initCollection', {
	        chatId: data.chatId,
	        messages: []
	      });
	      this.store.commit('dialogues/initCollection', {
	        dialogId: data.dialogId,
	        fields: {
	          entityType: 'LIVECHAT',
	          type: 'livechat'
	        }
	      });
	      this.store.commit('application/set', {
	        dialog: {
	          chatId: data.chatId,
	          dialogId: 'chat' + data.chatId
	        }
	      });
	    }
	  }, {
	    key: "handleImopenlinesWidgetUserGetSuccess",
	    value: function handleImopenlinesWidgetUserGetSuccess(data) {
	      this.store.commit('widget/user', {
	        id: data.id,
	        hash: data.hash,
	        name: data.name,
	        firstName: data.firstName,
	        lastName: data.lastName,
	        phone: data.phone,
	        avatar: data.avatar,
	        email: data.email,
	        www: data.www,
	        gender: data.gender,
	        position: data.position
	      });
	      this.store.dispatch('users/set', [{
	        id: data.id,
	        name: data.name,
	        firstName: data.firstName,
	        lastName: data.lastName,
	        avatar: data.avatar,
	        gender: data.gender,
	        workPosition: data.position
	      }]);
	      this.store.commit('application/set', {
	        common: {
	          userId: data.id
	        }
	      });
	    }
	  }, {
	    key: "handleImopenlinesWidgetDialogGetSuccess",
	    value: function handleImopenlinesWidgetDialogGetSuccess(data) {
	      this.store.commit('messages/initCollection', {
	        chatId: data.chatId
	      });
	      this.store.commit('widget/dialog', data);
	      this.store.commit('application/set', {
	        dialog: {
	          chatId: data.chatId,
	          dialogId: 'chat' + data.chatId,
	          diskFolderId: data.diskFolderId
	        }
	      });
	      this.store.dispatch('widget/setVoteDateFinish', data.dateCloseVote);
	    }
	  }, {
	    key: "handleImDialogMessagesGetInitSuccess",
	    value: function handleImDialogMessagesGetInitSuccess(data) {
	      this.handleImDialogMessagesGetSuccess(data);
	    }
	  }, {
	    key: "handleImDialogMessagesGetSuccess",
	    value: function handleImDialogMessagesGetSuccess(data) {
	      if (data.messages && data.messages.length > 0 && !this.widget.isDialogStart()) {
	        this.store.commit('widget/common', {
	          dialogStart: true
	        });
	        this.store.commit('widget/dialog', {
	          userConsent: true
	        });
	      }
	    }
	  }, {
	    key: "handleImMessageAddSuccess",
	    value: function handleImMessageAddSuccess(messageId, message) {
	      this.widget.sendEvent({
	        type: SubscriptionType.userMessage,
	        data: {
	          id: messageId,
	          text: message.text
	        }
	      });
	    }
	  }, {
	    key: "handleImDiskFileCommitSuccess",
	    value: function handleImDiskFileCommitSuccess(result, message) {
	      this.widget.sendEvent({
	        type: SubscriptionType.userFile,
	        data: {}
	      });
	    }
	  }]);
	  return WidgetRestAnswerHandler;
	}(im_provider_rest.BaseRestHandler);

	/**
	 * Bitrix OpenLines widget
	 * Widget pull commands (Pull Command Handler)
	 *
	 * @package bitrix
	 * @subpackage imopenlines
	 * @copyright 2001-2019 Bitrix
	 */
	var WidgetImPullCommandHandler = /*#__PURE__*/function () {
	  babelHelpers.createClass(WidgetImPullCommandHandler, [{
	    key: "getModuleId",
	    value: function getModuleId() {
	      return 'im';
	    }
	  }], [{
	    key: "create",
	    value: function create() {
	      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	      return new this(params);
	    }
	  }]);
	  function WidgetImPullCommandHandler(params) {
	    babelHelpers.classCallCheck(this, WidgetImPullCommandHandler);
	    this.controller = params.controller;
	    this.store = params.store;
	    this.widget = params.widget;
	  }
	  babelHelpers.createClass(WidgetImPullCommandHandler, [{
	    key: "handleMessageChat",
	    value: function handleMessageChat(params, extra, command) {
	      if (params.message.senderId != this.controller.application.getUserId()) {
	        this.widget.sendEvent({
	          type: SubscriptionType.operatorMessage,
	          data: params
	        });
	        if (!this.store.state.widget.common.showed && !this.widget.onceShowed) {
	          this.widget.onceShowed = true;
	          this.widget.open();
	        }
	      }
	    }
	  }]);
	  return WidgetImPullCommandHandler;
	}();
	var WidgetImopenlinesPullCommandHandler = /*#__PURE__*/function () {
	  babelHelpers.createClass(WidgetImopenlinesPullCommandHandler, null, [{
	    key: "create",
	    value: function create() {
	      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	      return new this(params);
	    }
	  }]);
	  function WidgetImopenlinesPullCommandHandler() {
	    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	    babelHelpers.classCallCheck(this, WidgetImopenlinesPullCommandHandler);
	    this.controller = params.controller;
	    this.store = params.store;
	    this.widget = params.widget;
	  }
	  babelHelpers.createClass(WidgetImopenlinesPullCommandHandler, [{
	    key: "getModuleId",
	    value: function getModuleId() {
	      return 'imopenlines';
	    }
	  }, {
	    key: "handleSessionStart",
	    value: function handleSessionStart(params, extra, command) {
	      this.store.commit('widget/dialog', {
	        sessionId: params.sessionId,
	        sessionClose: false,
	        sessionStatus: 0,
	        userVote: VoteType.none
	      });
	      this.store.dispatch('widget/setVoteDateFinish', '');
	      this.widget.sendEvent({
	        type: SubscriptionType.sessionStart,
	        data: {
	          sessionId: params.sessionId
	        }
	      });
	    }
	  }, {
	    key: "handleSessionOperatorChange",
	    value: function handleSessionOperatorChange(params, extra, command) {
	      this.store.commit('widget/dialog', {
	        operator: params.operator,
	        operatorChatId: params.operatorChatId
	      });
	      this.widget.sendEvent({
	        type: SubscriptionType.sessionOperatorChange,
	        data: {
	          operator: params.operator
	        }
	      });
	    }
	  }, {
	    key: "handleSessionStatus",
	    value: function handleSessionStatus(params, extra, command) {
	      this.store.commit('widget/dialog', {
	        sessionId: params.sessionId,
	        sessionStatus: params.sessionStatus,
	        sessionClose: params.sessionClose
	      });
	      this.widget.sendEvent({
	        type: SubscriptionType.sessionStatus,
	        data: {
	          sessionId: params.sessionId,
	          sessionStatus: params.sessionStatus
	        }
	      });
	      if (params.sessionClose) {
	        this.widget.sendEvent({
	          type: SubscriptionType.sessionFinish,
	          data: {
	            sessionId: params.sessionId,
	            sessionStatus: params.sessionStatus
	          }
	        });
	        if (!params.spam) {
	          this.store.commit('widget/dialog', {
	            operator: {
	              name: '',
	              firstName: '',
	              lastName: '',
	              workPosition: '',
	              avatar: '',
	              online: false
	            }
	          });
	        }
	      }
	    }
	  }, {
	    key: "handleSessionDateCloseVote",
	    value: function handleSessionDateCloseVote(params, extra, command) {
	      this.store.dispatch('widget/setVoteDateFinish', params.dateCloseVote);
	    }
	  }]);
	  return WidgetImopenlinesPullCommandHandler;
	}();

	function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
	function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { babelHelpers.defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
	var Widget = /*#__PURE__*/function () {
	  /* region 01. Initialize and store data */

	  // Vue instance

	  // true if there are no initialization errors
	  // true if all preparations are done
	  // true if Pull-client is offline
	  // XHR-request from widget.config.get, can be aborted before completion

	  // this block can be set from public config
	  // user info
	  // additional info to send to server

	  // external event subscribers

	  // fields from params
	  // livechat code

	  // widget button

	  // fullscreen livechat mode options

	  function Widget() {
	    var _this = this;
	    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	    babelHelpers.classCallCheck(this, Widget);
	    babelHelpers.defineProperty(this, "params", null);
	    babelHelpers.defineProperty(this, "template", null);
	    babelHelpers.defineProperty(this, "rootNode", null);
	    babelHelpers.defineProperty(this, "restClient", null);
	    babelHelpers.defineProperty(this, "pullClient", null);
	    babelHelpers.defineProperty(this, "ready", true);
	    babelHelpers.defineProperty(this, "inited", false);
	    babelHelpers.defineProperty(this, "offline", false);
	    babelHelpers.defineProperty(this, "widgetConfigRequest", null);
	    babelHelpers.defineProperty(this, "userRegisterData", {});
	    babelHelpers.defineProperty(this, "customData", []);
	    babelHelpers.defineProperty(this, "options", {
	      checkSameDomain: true
	    });
	    babelHelpers.defineProperty(this, "subscribers", {});
	    babelHelpers.defineProperty(this, "code", '');
	    babelHelpers.defineProperty(this, "host", '');
	    babelHelpers.defineProperty(this, "language", '');
	    babelHelpers.defineProperty(this, "copyright", true);
	    babelHelpers.defineProperty(this, "copyrightUrl", '');
	    babelHelpers.defineProperty(this, "buttonInstance", null);
	    babelHelpers.defineProperty(this, "localize", null);
	    babelHelpers.defineProperty(this, "pageMode", null);
	    this.params = params;

	    //TODO: remove
	    this.messagesQueue = [];
	    main_core_events.EventEmitter.subscribe(WidgetEventType.requestData, this.requestData.bind(this));
	    main_core_events.EventEmitter.subscribe(WidgetEventType.createSession, this.createChat.bind(this));
	    main_core_events.EventEmitter.subscribe(WidgetEventType.openSession, this.openSession.bind(this));
	    this.initParams();
	    this.initRestClient();
	    this.initPullClient();
	    this.initCore().then(function () {
	      _this.initWidget();
	      _this.initComplete();
	    });
	  }
	  babelHelpers.createClass(Widget, [{
	    key: "initParams",
	    value: function initParams() {
	      this.rootNode = this.params.node || document.createElement('div');
	      this.code = this.params.code || '';
	      this.host = this.params.host || '';
	      this.language = this.params.language || 'en';
	      this.copyright = this.params.copyright !== false;
	      this.copyrightUrl = this.copyright && this.params.copyrightUrl ? this.params.copyrightUrl : '';
	      if (this.params.buttonInstance && babelHelpers["typeof"](this.params.buttonInstance) === 'object') {
	        this.buttonInstance = this.params.buttonInstance;
	      }
	      if (this.params.pageMode && babelHelpers["typeof"](this.params.pageMode) === 'object') {
	        this.pageMode = {
	          useBitrixLocalize: this.params.pageMode.useBitrixLocalize === true,
	          placeholder: document.querySelector("#".concat(this.params.pageMode.placeholder))
	        };
	      }
	      var errors = this.checkRequiredFields();
	      if (errors.length > 0) {
	        errors.forEach(function (error) {
	          return console.warn(error);
	        });
	        this.ready = false;
	      }
	      this.setRootNode();
	      this.localize = this.pageMode && this.pageMode.useBitrixLocalize ? window.BX.message : {};
	      this.setLocalize();
	    }
	  }, {
	    key: "initRestClient",
	    value: function initRestClient() {
	      this.restClient = new WidgetRestClient({
	        endpoint: "".concat(this.host, "/rest")
	      });
	    }
	  }, {
	    key: "initPullClient",
	    value: function initPullClient() {
	      this.pullClient = new pull_client.PullClient({
	        serverEnabled: true,
	        userId: 0,
	        siteId: this.getSiteId(),
	        restClient: this.restClient,
	        skipStorageInit: true,
	        configTimestamp: 0,
	        skipCheckRevision: true,
	        getPublicListMethod: 'imopenlines.widget.operator.get'
	      });
	    }
	  }, {
	    key: "initCore",
	    value: function initCore() {
	      this.controller = new im_controller.Controller({
	        host: this.getHost(),
	        siteId: this.getSiteId(),
	        userId: 0,
	        languageId: this.language,
	        pull: {
	          client: this.pullClient
	        },
	        rest: {
	          client: this.restClient
	        },
	        localize: this.localize,
	        vuexBuilder: {
	          database: !im_lib_utils.Utils.browser.isIe(),
	          databaseName: 'imol/widget',
	          databaseType: ui_vue_vuex.WidgetVuexBuilder.DatabaseType.localStorage,
	          models: [WidgetModel.create().setVariables(this.getWidgetVariables())]
	        }
	      });
	      return this.controller.ready();
	    }
	  }, {
	    key: "initWidget",
	    value: function initWidget() {
	      this.restClient.setAuthId(this.getRestAuthId());
	      this.setModelData();
	      // TODO: move from controller
	      this.controller.application.setPrepareFilesBeforeSaveFunction(this.prepareFileData.bind(this));
	      this.controller.addRestAnswerHandler(WidgetRestAnswerHandler.create({
	        widget: this,
	        store: this.controller.getStore(),
	        controller: this.controller
	      }));
	    } // if start or open methods were called before core init - we will have appropriate flags
	    // for full-page livechat we always call open
	  }, {
	    key: "initComplete",
	    value: function initComplete() {
	      window.dispatchEvent(new CustomEvent('onBitrixLiveChat', {
	        detail: {
	          widget: this,
	          widgetCode: this.code,
	          widgetHost: this.host
	        }
	      }));
	      if (this.callStartFlag) {
	        this.start();
	      }
	      if (this.pageMode || this.callOpenFlag) {
	        this.open();
	      }
	    } // public method
	    // initially called from imopenlines/lib/livechatmanager.php:16
	    // if core is not ready yet - set flag and call start once again in this.initComplete()
	  }, {
	    key: "start",
	    value: function start() {
	      if (!this.controller || !this.controller.getStore()) {
	        this.callStartFlag = true;
	        return true;
	      }
	      if (this.isSessionActive()) {
	        this.requestWidgetData();
	      }
	      return true;
	    } // public method
	    // if core is not ready yet - set flag and call start once again in this.initComplete()
	    // if not inited yet - request widget data
	  }, {
	    key: "open",
	    value: function open() {
	      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	      if (!this.controller.getStore()) {
	        this.callOpenFlag = true;
	        return true;
	      }
	      if (!params.openFromButton && this.buttonInstance) {
	        this.buttonInstance.wm.showById('openline_livechat');
	      }
	      var _this$checkForErrorsB = this.checkForErrorsBeforeOpen(),
	        error = _this$checkForErrorsB.error,
	        stop = _this$checkForErrorsB.stop;
	      if (stop) {
	        return false;
	      }
	      if (!error && !this.inited) {
	        this.requestWidgetData();
	      }
	      this.attachTemplate();
	    }
	  }, {
	    key: "requestWidgetData",
	    value: function requestWidgetData() {
	      var _this2 = this;
	      if (!this.ready) {
	        console.error('LiveChatWidget.start: widget code or host is not specified');
	        return false;
	      }

	      // if user is registered or we have its hash - proceed to getting chat and messages
	      if (this.isUserReady() || this.isHashAvailable()) {
	        this.requestData();
	        this.inited = true;
	        this.fireInitEvent();
	        return true;
	      }

	      // if there is no info about user - we need to get config and wait for first message
	      this.controller.restClient.callMethod(RestMethod.widgetConfigGet, {
	        code: this.code
	      }, function (xhr) {
	        _this2.widgetConfigRequest = xhr;
	      }).then(function (result) {
	        _this2.widgetConfigRequest = null;
	        _this2.clearError();
	        _this2.controller.executeRestAnswer(RestMethod.widgetConfigGet, result);
	        if (!_this2.inited) {
	          _this2.inited = true;
	          _this2.fireInitEvent();
	        }
	      })["catch"](function (error) {
	        _this2.widgetConfigRequest = null;
	        _this2.setError(error.error().ex.error, error.error().ex.error_description);
	      });
	      if (this.isConfigDataLoaded()) {
	        this.inited = true;
	        this.fireInitEvent();
	      }
	    } // get all other info (dialog, chat, messages etc)
	  }, {
	    key: "requestData",
	    value: function requestData() {
	      im_lib_logger.Logger.log('requesting data from widget');
	      if (this.requestDataSend) {
	        return true;
	      }
	      this.requestDataSend = true;

	      // if there is uncompleted widget.config.get request - abort it (because we will do it anyway)
	      if (this.widgetConfigRequest) {
	        this.widgetConfigRequest.abort();
	      }
	      var callback = this.handleBatchRequestResult.bind(this);
	      this.controller.restClient.callBatch(this.getDataRequestQuery(), callback, false, false, im_lib_utils.Utils.getLogTrackingParams({
	        name: 'widget.init.config',
	        dialog: this.controller.application.getDialogData()
	      }));
	    }
	  }, {
	    key: "createChat",
	    value: function createChat() {
	      var _this3 = this;
	      return new Promise(function (resolve, reject) {
	        _this3.controller.restClient.callBatch(_this3.getCreateChatRequestQuery(), function (result) {
	          _this3.handleBatchCreateChatRequestResult(result).then(function () {
	            resolve();
	          });
	        }, false, false);
	      });
	    }
	  }, {
	    key: "handleBatchRequestResult",
	    value: function handleBatchRequestResult(response) {
	      var _this4 = this;
	      if (!response) {
	        this.requestDataSend = false;
	        this.setError('EMPTY_RESPONSE', 'Server returned an empty response.');
	        return false;
	      }
	      this.handleConfigGet(response).then(function () {
	        return _this4.handleUserGet(response);
	      }).then(function () {
	        return _this4.handleChatGet(response);
	      }).then(function () {
	        return _this4.handleDialogGet(response);
	      }).then(function () {
	        return _this4.handleDialogMessagesGet(response);
	      }).then(function () {
	        return _this4.handleUserRegister(response);
	      }).then(function () {
	        return _this4.handlePullRequests(response);
	      })["catch"](function (_ref) {
	        var code = _ref.code,
	          description = _ref.description;
	        _this4.setError(code, description);
	      })["finally"](function () {
	        _this4.requestDataSend = false;
	      });
	    }
	  }, {
	    key: "handleBatchCreateChatRequestResult",
	    value: function handleBatchCreateChatRequestResult(response) {
	      var _this5 = this;
	      if (!response) {
	        this.requestDataSend = false;
	        this.setError('EMPTY_RESPONSE', 'Server returned an empty response.');
	        return false;
	      }
	      return this.handleChatCreate(response).then(function () {
	        return _this5.handleChatGet(response);
	      }).then(function () {
	        return _this5.handleDialogGet(response);
	      })["catch"](function (_ref2) {
	        var code = _ref2.code,
	          description = _ref2.description;
	        _this5.setError(code, description);
	      })["finally"](function () {
	        _this5.requestDataSend = false;
	      });
	    }
	  }, {
	    key: "handleBatchOpenSessionRequestResult",
	    value: function handleBatchOpenSessionRequestResult(response) {
	      var _this6 = this;
	      if (!response) {
	        this.requestDataSend = false;
	        this.setError('EMPTY_RESPONSE', 'Server returned an empty response.');
	        return false;
	      }
	      return this.handleChatGet(response).then(function () {
	        return _this6.handleDialogGet(response);
	      }).then(function () {
	        return _this6.handleDialogMessagesGet(response);
	      })["catch"](function (_ref3) {
	        var code = _ref3.code,
	          description = _ref3.description;
	        _this6.setError(code, description);
	      })["finally"](function () {
	        _this6.requestDataSend = false;
	      });
	    }
	  }, {
	    key: "getDataRequestQuery",
	    value: function getDataRequestQuery() {
	      // always widget.config.get
	      var query = babelHelpers.defineProperty({}, RestMethod.widgetConfigGet, [RestMethod.widgetConfigGet, {
	        code: this.code
	      }]);
	      if (this.isUserRegistered()) {
	        // widget.dialog.get
	        query[RestMethod.widgetDialogGet] = [RestMethod.widgetDialogGet, {
	          config_id: this.getConfigId(),
	          trace_data: this.getCrmTraceData(),
	          custom_data: this.getCustomData()
	        }];

	        // im.chat.get
	        query[im_const.RestMethodHandler.imChatGet] = [im_const.RestMethod.imChatGet, {
	          dialog_id: "$result[".concat(RestMethod.widgetDialogGet, "][dialogId]")
	        }];

	        // im.dialog.messages.get
	        query[im_const.RestMethodHandler.imDialogMessagesGetInit] = [im_const.RestMethod.imDialogMessagesGet, {
	          chat_id: "$result[".concat(RestMethod.widgetDialogGet, "][chatId]"),
	          limit: this.controller.application.getRequestMessageLimit(),
	          convert_text: 'Y'
	        }];
	      } else {
	        // widget.user.register
	        query[RestMethod.widgetUserRegister] = [RestMethod.widgetUserRegister, _objectSpread({
	          config_id: "$result[".concat(RestMethod.widgetConfigGet, "][configId]")
	        }, this.getUserRegisterFields())];

	        // im.chat.get
	        query[im_const.RestMethodHandler.imChatGet] = [im_const.RestMethod.imChatGet, {
	          dialog_id: "$result[".concat(RestMethod.widgetUserRegister, "][dialogId]")
	        }];
	        if (this.userRegisterData.hash || this.getUserHashCookie()) {
	          // widget.dialog.get
	          query[RestMethod.widgetDialogGet] = [RestMethod.widgetDialogGet, {
	            config_id: "$result[".concat(RestMethod.widgetConfigGet, "][configId]"),
	            trace_data: this.getCrmTraceData(),
	            custom_data: this.getCustomData()
	          }];

	          // im.dialog.messages.get
	          query[im_const.RestMethodHandler.imDialogMessagesGetInit] = [im_const.RestMethod.imDialogMessagesGet, {
	            chat_id: "$result[".concat(RestMethod.widgetDialogGet, "][chatId]"),
	            limit: this.controller.application.getRequestMessageLimit(),
	            convert_text: 'Y'
	          }];
	        }
	        if (this.isUserAgreeConsent()) {
	          // widget.user.consent.apply
	          query[RestMethod.widgetUserConsentApply] = [RestMethod.widgetUserConsentApply, {
	            config_id: "$result[".concat(RestMethod.widgetConfigGet, "][configId]"),
	            consent_url: location.href
	          }];
	        }
	      }
	      query[RestMethod.pullServerTime] = [RestMethod.pullServerTime, {}];
	      query[RestMethod.pullConfigGet] = [RestMethod.pullConfigGet, {
	        'CACHE': 'N'
	      }];
	      query[RestMethod.widgetUserGet] = [RestMethod.widgetUserGet, {}];
	      return query;
	    }
	  }, {
	    key: "getOpenSessionQuery",
	    value: function getOpenSessionQuery(chatId) {
	      // imopenlines.widget.dialog.get
	      var query = babelHelpers.defineProperty({}, RestMethod.widgetDialogGet, [RestMethod.widgetDialogGet, {
	        config_id: this.getConfigId(),
	        chat_id: chatId
	      }]);
	      query[im_const.RestMethodHandler.imChatGet] = [im_const.RestMethod.imChatGet, {
	        dialog_id: "chat".concat(chatId)
	      }];

	      // im.dialog.messages.get
	      query[im_const.RestMethodHandler.imDialogMessagesGetInit] = [im_const.RestMethod.imDialogMessagesGet, {
	        chat_id: chatId,
	        limit: 50,
	        convert_text: 'Y'
	      }];
	      return query;
	    }
	  }, {
	    key: "getCreateChatRequestQuery",
	    value: function getCreateChatRequestQuery() {
	      var query = {};

	      // widget.chat.register
	      query[RestMethod.widgetChatCreate] = [RestMethod.widgetChatCreate, _objectSpread({
	        config_id: this.getConfigId()
	      }, this.getUserRegisterFields())];

	      // im.chat.get
	      query[im_const.RestMethodHandler.imChatGet] = [im_const.RestMethod.imChatGet, {
	        dialog_id: "$result[".concat(RestMethod.widgetChatCreate, "][dialogId]")
	      }];

	      // widget.dialog.get
	      query[RestMethod.widgetDialogGet] = [RestMethod.widgetDialogGet, {
	        config_id: this.getConfigId(),
	        trace_data: this.getCrmTraceData(),
	        custom_data: this.getCustomData()
	      }];
	      if (this.isUserAgreeConsent()) {
	        // widget.user.consent.apply
	        query[RestMethod.widgetUserConsentApply] = [RestMethod.widgetUserConsentApply, {
	          config_id: this.getConfigId(),
	          consent_url: location.href
	        }];
	      }
	      query[RestMethod.pullServerTime] = [RestMethod.pullServerTime, {}];
	      query[RestMethod.pullConfigGet] = [RestMethod.pullConfigGet, {
	        'CACHE': 'N'
	      }];
	      query[RestMethod.widgetUserGet] = [RestMethod.widgetUserGet, {}];
	      return query;
	    }
	  }, {
	    key: "openSession",
	    value: function openSession(event) {
	      var _this7 = this;
	      var eventData = event.getData();
	      return new Promise(function (resolve, reject) {
	        var dialog = _this7.controller.getStore().getters['dialogues/get'](eventData.session.dialogId);
	        if (dialog) {
	          _this7.controller.getStore().commit('application/set', {
	            dialog: {
	              chatId: eventData.session.chatId,
	              dialogId: eventData.session.dialogId,
	              diskFolderId: 0
	            }
	          });
	          _this7.controller.getStore().commit('widget/common', {
	            isCreateSessionMode: false
	          });
	          resolve();
	          return;
	        }
	        _this7.controller.restClient.callBatch(_this7.getOpenSessionQuery(eventData.session.chatId), function (result) {
	          _this7.handleBatchOpenSessionRequestResult(result).then(function () {
	            _this7.controller.getStore().commit('widget/common', {
	              isCreateSessionMode: false
	            });
	            resolve();
	          });
	        }, false, false);
	      });
	    }
	  }, {
	    key: "prepareFileData",
	    value: function prepareFileData(files) {
	      var _this8 = this;
	      if (!Array.isArray(files)) {
	        return files;
	      }
	      return files.map(function (file) {
	        var hash = (window.md5 || main_md5.md5)("".concat(_this8.getUserId(), "|").concat(file.id, "|").concat(_this8.getUserHash()));
	        var urlParam = "livechat_auth_id=".concat(hash, "&livechat_user_id=").concat(_this8.getUserId());
	        if (file.urlPreview) {
	          file.urlPreview = "".concat(file.urlPreview, "&").concat(urlParam);
	        }
	        if (file.urlShow) {
	          file.urlShow = "".concat(file.urlShow, "&").concat(urlParam);
	        }
	        if (file.urlDownload) {
	          file.urlDownload = "".concat(file.urlDownload, "&").concat(urlParam);
	        }
	        return file;
	      });
	    }
	  }, {
	    key: "checkRequiredFields",
	    value: function checkRequiredFields() {
	      var errors = [];
	      if (typeof this.code === 'string' && this.code.length <= 0) {
	        errors.push("LiveChatWidget.constructor: code is not correct (".concat(this.code, ")"));
	      }
	      if (typeof this.host === 'string' && (this.host.length <= 0 || !this.host.startsWith('http'))) {
	        errors.push("LiveChatWidget.constructor: host is not correct (".concat(this.host, ")"));
	      }
	      return errors;
	    }
	  }, {
	    key: "setRootNode",
	    value: function setRootNode() {
	      if (this.pageMode && this.pageMode.placeholder) {
	        this.rootNode = this.pageMode.placeholder;
	      } else if (document.body.firstChild) {
	        document.body.insertBefore(this.rootNode, document.body.firstChild);
	      } else {
	        document.body.append(this.rootNode);
	      }
	    }
	  }, {
	    key: "setLocalize",
	    value: function setLocalize() {
	      if (babelHelpers["typeof"](this.params.localize) === 'object') {
	        this.addLocalize(this.params.localize);
	      }
	      var serverVariables = im_lib_localstorage.LocalStorage.get(this.getSiteId(), 0, 'serverVariables', false);
	      if (serverVariables) {
	        this.addLocalize(serverVariables);
	      }
	    }
	  }, {
	    key: "getWidgetVariables",
	    value: function getWidgetVariables() {
	      var variables = {
	        common: {
	          host: this.getHost(),
	          pageMode: !!this.pageMode,
	          copyright: this.copyright,
	          copyrightUrl: this.copyrightUrl
	        },
	        vote: {
	          messageText: this.getLocalize('BX_LIVECHAT_VOTE_TITLE'),
	          messageLike: this.getLocalize('BX_LIVECHAT_VOTE_PLUS_TITLE'),
	          messageDislike: this.getLocalize('BX_LIVECHAT_VOTE_MINUS_TITLE')
	        },
	        textMessages: {
	          bxLivechatOnlineLine1: this.getLocalize('BX_LIVECHAT_ONLINE_LINE_1'),
	          bxLivechatOnlineLine2: this.getLocalize('BX_LIVECHAT_ONLINE_LINE_2'),
	          bxLivechatOffline: this.getLocalize('BX_LIVECHAT_OFFLINE')
	        }
	      };
	      if (this.params.styles) {
	        variables.styles = {};
	        if (this.params.styles.backgroundColor) {
	          variables.styles.backgroundColor = this.params.styles.backgroundColor;
	        }
	        if (this.params.styles.iconColor) {
	          variables.styles.iconColor = this.params.styles.iconColor;
	        }
	      }
	      return variables;
	    }
	  }, {
	    key: "getRestAuthId",
	    value: function getRestAuthId() {
	      return this.isUserRegistered() ? this.getUserHash() : RestAuth.guest;
	    }
	  }, {
	    key: "setModelData",
	    value: function setModelData() {
	      if (this.params.location && LocationStyle[this.params.location]) {
	        this.controller.getStore().commit('widget/common', {
	          location: this.params.location
	        });
	      }
	    }
	  }, {
	    key: "checkForErrorsBeforeOpen",
	    value: function checkForErrorsBeforeOpen() {
	      var result = {
	        error: false,
	        stop: false
	      };
	      if (!this.checkBrowserVersion()) {
	        this.setError('OLD_BROWSER_LOCALIZED', this.localize.BX_LIVECHAT_OLD_BROWSER);
	        result.error = true;
	      } else if (im_lib_utils.Utils.versionCompare(ui_vue.WidgetVue.version(), '2.1') < 0) {
	        alert(this.localize.BX_LIVECHAT_OLD_VUE);
	        console.error("LiveChatWidget.error: OLD_VUE_VERSION (".concat(this.localize.BX_LIVECHAT_OLD_VUE_DEV.replace('#CURRENT_VERSION#', ui_vue.WidgetVue.version()), ")"));
	        result.error = true;
	        result.stop = true;
	      } else if (this.isSameDomain()) {
	        this.setError('LIVECHAT_SAME_DOMAIN', this.localize.BX_LIVECHAT_SAME_DOMAIN);
	        result.error = true;
	      }
	      return result;
	    }
	  }, {
	    key: "isSameDomain",
	    value: function isSameDomain() {
	      if (typeof BX === 'undefined' || !BX.isReady) {
	        return false;
	      }
	      if (!this.options.checkSameDomain) {
	        return false;
	      }
	      return this.host.lastIndexOf(".".concat(location.hostname)) > -1;
	    }
	  }, {
	    key: "checkBrowserVersion",
	    value: function checkBrowserVersion() {
	      if (im_lib_utils.Utils.platform.isIos()) {
	        var version = im_lib_utils.Utils.platform.getIosVersion();
	        if (version && version <= 10) {
	          return false;
	        }
	      }
	      return true;
	    }
	    /* endregion 01. Initialize and store data */
	    /* region 02. Push & Pull */
	  }, {
	    key: "startPullClient",
	    value: function startPullClient(config) {
	      var _this9 = this;
	      return new Promise(function (resolve, reject) {
	        if (!_this9.getUserId() || !_this9.getSiteId() || !_this9.restClient) {
	          return reject({
	            ex: {
	              error: 'WIDGET_NOT_LOADED',
	              error_description: 'Widget is not loaded.'
	            }
	          });
	        }
	        if (_this9.pullClientInited) {
	          if (!_this9.pullClient.isConnected()) {
	            _this9.pullClient.scheduleReconnect();
	          }
	          return resolve(true);
	        }
	        _this9.controller.userId = _this9.getUserId();
	        _this9.pullClient.userId = _this9.getUserId();
	        _this9.pullClient.configTimestamp = config ? config.server.config_timestamp : 0;
	        _this9.pullClient.skipStorageInit = false;
	        _this9.pullClient.storage = new pull_client.PullClient.StorageManager({
	          userId: _this9.getUserId(),
	          siteId: _this9.getSiteId()
	        });
	        _this9.pullClient.subscribe(new WidgetImPullCommandHandler({
	          store: _this9.controller.getStore(),
	          controller: _this9.controller,
	          widget: _this9
	        }));
	        _this9.pullClient.subscribe(new WidgetImopenlinesPullCommandHandler({
	          store: _this9.controller.getStore(),
	          controller: _this9.controller,
	          widget: _this9
	        }));
	        _this9.pullClient.subscribe({
	          type: pull_client.PullClient.SubscriptionType.Status,
	          callback: _this9.eventStatusInteraction.bind(_this9)
	        });
	        _this9.pullConnectedFirstTime = _this9.pullClient.subscribe({
	          type: pull_client.PullClient.SubscriptionType.Status,
	          callback: function callback(result) {
	            if (result.status === pull_client.PullClient.PullStatus.Online) {
	              resolve(true);
	              _this9.pullConnectedFirstTime();
	            }
	          }
	        });
	        if (_this9.template) {
	          _this9.template.$Bitrix.PullClient.set(_this9.pullClient);
	        }
	        _this9.pullClient.start(_objectSpread(_objectSpread({}, config), {}, {
	          skipReconnectToLastSession: true
	        }))["catch"](function () {
	          reject({
	            ex: {
	              error: 'PULL_CONNECTION_ERROR',
	              error_description: 'Pull is not connected.'
	            }
	          });
	        });
	        _this9.pullClientInited = true;
	      });
	    }
	  }, {
	    key: "stopPullClient",
	    value: function stopPullClient() {
	      if (this.pullClient) {
	        this.pullClient.stop(pull_client.PullClient.CloseReasons.MANUAL, 'Closed manually');
	      }
	    }
	  }, {
	    key: "recoverPullConnection",
	    value: function recoverPullConnection() {
	      // this.pullClient.session.mid = 0; // TODO specially for disable pull history, remove after recode im
	      this.pullClient.restart(pull_client.PullClient.CloseReasons.MANUAL, 'Restart after click by connection status button.');
	    }
	  }, {
	    key: "eventStatusInteraction",
	    value: function eventStatusInteraction(data) {
	      if (data.status === pull_client.PullClient.PullStatus.Online) {
	        this.onPullOnlineStatus();
	      } else if (data.status === pull_client.PullClient.PullStatus.Offline) {
	        this.pullRequestMessage = true;
	        this.offline = true;
	      }
	    }
	  }, {
	    key: "onPullOnlineStatus",
	    value: function onPullOnlineStatus() {
	      var _this10 = this;
	      this.offline = false;

	      // if we go online after going offline - we need to request messages
	      if (this.pullRequestMessage) {
	        this.controller.pullBaseHandler.option.skip = true;
	        im_lib_logger.Logger.warn('Requesting getDialogUnread after going online');
	        main_core_events.EventEmitter.emitAsync(im_const.EventType.dialog.requestUnread, {
	          chatId: this.controller.application.getChatId()
	        }).then(function () {
	          main_core_events.EventEmitter.emit(im_const.EventType.dialog.scrollOnStart, {
	            chatId: _this10.controller.application.getChatId()
	          });
	          _this10.controller.pullBaseHandler.option.skip = false;
	          main_core_events.EventEmitter.emit(WidgetEventType.processMessagesToSendQueue);
	        })["catch"](function () {
	          _this10.controller.pullBaseHandler.option.skip = false;
	        });
	        this.pullRequestMessage = false;
	      } else {
	        main_core_events.EventEmitter.emit(im_const.EventType.dialog.readMessage);
	        main_core_events.EventEmitter.emit(WidgetEventType.processMessagesToSendQueue);
	      }
	    }
	    /* endregion 02. Push & Pull */
	    /* region 03. Template engine */
	  }, {
	    key: "attachTemplate",
	    value: function attachTemplate() {
	      if (this.template) {
	        this.controller.getStore().commit('widget/common', {
	          showed: true
	        });
	        return true;
	      }
	      this.rootNode.innerHTML = '';
	      this.rootNode.append(document.createElement('div'));
	      var application = this;
	      return this.controller.createVue(application, {
	        el: this.rootNode.firstChild,
	        template: '<bx-livechat/>',
	        beforeCreate: function beforeCreate() {
	          application.sendEvent({
	            type: SubscriptionType.widgetOpen,
	            data: {}
	          });
	          application.template = this;
	          if (main_core_minimal.ZIndexManager !== undefined) {
	            var stack = main_core_minimal.ZIndexManager.getOrAddStack(document.body);
	            stack.setBaseIndex(1000000); // some big value
	            this.$bitrix.Data.set('zIndexStack', stack);
	          }
	        },
	        destroyed: function destroyed() {
	          application.sendEvent({
	            type: SubscriptionType.widgetClose,
	            data: {}
	          });
	          application.template = null;
	          application.templateAttached = false;
	          application.rootNode.innerHTML = '';
	        }
	      }).then(function () {
	        return new Promise(function (resolve, reject) {
	          return resolve();
	        });
	      });
	    }
	  }, {
	    key: "detachTemplate",
	    value: function detachTemplate() {
	      if (!this.template) {
	        return true;
	      }
	      this.template.$destroy();
	      return true;
	    } // public method
	  }, {
	    key: "mutateTemplateComponent",
	    value: function mutateTemplateComponent(id, params) {
	      return ui_vue.WidgetVue.mutateComponent(id, params);
	    }
	    /* endregion 03. Template engine */
	    /* region 04. Widget interaction and utils */
	    // public method
	  }, {
	    key: "close",
	    value: function close() {
	      if (this.pageMode) {
	        return false;
	      }
	      if (this.buttonInstance) {
	        this.buttonInstance.onWidgetClose();
	      }
	      this.detachTemplate();
	    }
	  }, {
	    key: "fireInitEvent",
	    value: function fireInitEvent() {
	      if (this.initEventFired) {
	        return true;
	      }
	      this.sendEvent({
	        type: SubscriptionType.configLoaded,
	        data: {}
	      });
	      if (this.controller.getStore().state.widget.common.reopen) {
	        this.open();
	      }
	      this.initEventFired = true;
	    }
	  }, {
	    key: "isUserRegistered",
	    value: function isUserRegistered() {
	      return !!this.getUserHash();
	    }
	  }, {
	    key: "isConfigDataLoaded",
	    value: function isConfigDataLoaded() {
	      return this.controller.getStore().state.widget.common.configId;
	    }
	  }, {
	    key: "isChatLoaded",
	    value: function isChatLoaded() {
	      return this.controller.getStore().state.application.dialog.chatId > 0;
	    }
	  }, {
	    key: "isSessionActive",
	    value: function isSessionActive() {
	      return !this.controller.getStore().state.widget.dialog.sessionClose;
	    }
	  }, {
	    key: "isUserAgreeConsent",
	    value: function isUserAgreeConsent() {
	      return this.controller.getStore().state.widget.dialog.userConsent;
	    }
	  }, {
	    key: "getCrmTraceData",
	    value: function getCrmTraceData() {
	      var traceData = '';
	      if (!this.buttonInstance) {
	        return traceData;
	      }
	      if (typeof this.buttonInstance.getTrace !== 'function') {
	        traceData = this.buttonInstance.getTrace();
	      } else if (typeof this.buttonInstance.b24Tracker !== 'undefined' && typeof this.buttonInstance.b24Tracker.guest !== 'undefined') {
	        traceData = this.buttonInstance.b24Tracker.guest.getTrace();
	      }
	      return traceData;
	    }
	  }, {
	    key: "getCustomData",
	    value: function getCustomData() {
	      var customData = [];
	      if (this.customData.length > 0) {
	        customData = this.customData;
	      } else {
	        customData = [{
	          MESSAGE: this.localize.BX_LIVECHAT_EXTRA_SITE + ': [URL]' + location.href + '[/URL]'
	        }];
	      }
	      return JSON.stringify(customData);
	    }
	  }, {
	    key: "isUserLoaded",
	    value: function isUserLoaded() {
	      return this.controller.getStore().state.widget.user.id > 0;
	    }
	  }, {
	    key: "isUserReady",
	    value: function isUserReady() {
	      return this.isConfigDataLoaded() && this.isUserRegistered();
	    }
	  }, {
	    key: "isHashAvailable",
	    value: function isHashAvailable() {
	      return !this.isUserRegistered() && (this.userRegisterData.hash || this.getUserHashCookie());
	    }
	  }, {
	    key: "getSiteId",
	    value: function getSiteId() {
	      return this.host.replace(/(http.?:\/\/)|([:.\\\/])/mg, "") + this.code;
	    }
	  }, {
	    key: "getHost",
	    value: function getHost() {
	      return this.host;
	    }
	  }, {
	    key: "getConfigId",
	    value: function getConfigId() {
	      return this.controller.getStore().state.widget.common.configId;
	    }
	  }, {
	    key: "isDialogStart",
	    value: function isDialogStart() {
	      return this.controller.getStore().state.widget.common.dialogStart;
	    }
	  }, {
	    key: "getChatId",
	    value: function getChatId() {
	      return this.controller.getStore().state.application.dialog.chatId;
	    }
	  }, {
	    key: "getDialogId",
	    value: function getDialogId() {
	      return this.controller.getStore().state.application.dialog.dialogId;
	    }
	  }, {
	    key: "getDiskFolderId",
	    value: function getDiskFolderId() {
	      return this.controller.getStore().state.application.dialog.diskFolderId;
	    }
	  }, {
	    key: "getDialogData",
	    value: function getDialogData() {
	      var dialogId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getDialogId();
	      return this.controller.getStore().state.dialogues.collection[dialogId];
	    }
	  }, {
	    key: "getSessionId",
	    value: function getSessionId() {
	      return this.controller.getStore().state.widget.dialog.sessionId;
	    }
	  }, {
	    key: "isSessionClose",
	    value: function isSessionClose() {
	      return this.controller.getStore().state.widget.dialog.sessionClose;
	    }
	  }, {
	    key: "getUserHash",
	    value: function getUserHash() {
	      return this.controller.getStore().state.widget.user.hash;
	    }
	  }, {
	    key: "getUserHashCookie",
	    value: function getUserHashCookie() {
	      var userHash = '';
	      var cookie = im_lib_cookie.Cookie.get(null, 'LIVECHAT_HASH');
	      if (typeof cookie === 'string' && cookie.match(/^[a-f0-9]{32}$/)) {
	        userHash = cookie;
	      } else {
	        var _cookie = im_lib_cookie.Cookie.get(this.getSiteId(), 'LIVECHAT_HASH');
	        if (typeof _cookie === 'string' && _cookie.match(/^[a-f0-9]{32}$/)) {
	          userHash = _cookie;
	        }
	      }
	      return userHash;
	    }
	  }, {
	    key: "getUserId",
	    value: function getUserId() {
	      return this.controller.getStore().state.widget.user.id;
	    }
	  }, {
	    key: "getUserData",
	    value: function getUserData() {
	      if (!this.controller || !this.controller.getStore()) {
	        console.error('LiveChatWidget.getUserData: method can be called after fired event - onBitrixLiveChat');
	        return false;
	      }
	      return this.controller.getStore().state.widget.user;
	    }
	  }, {
	    key: "getUserRegisterFields",
	    value: function getUserRegisterFields() {
	      return {
	        'name': this.userRegisterData.name || '',
	        'last_name': this.userRegisterData.lastName || '',
	        'avatar': this.userRegisterData.avatar || '',
	        'email': this.userRegisterData.email || '',
	        'www': this.userRegisterData.www || '',
	        'gender': this.userRegisterData.gender || '',
	        'position': this.userRegisterData.position || '',
	        'user_hash': this.userRegisterData.hash || this.getUserHashCookie() || '',
	        'consent_url': this.controller.getStore().state.widget.common.consentUrl ? location.href : '',
	        'trace_data': this.getCrmTraceData(),
	        'custom_data': this.getCustomData()
	      };
	    }
	  }, {
	    key: "getWidgetLocationCode",
	    value: function getWidgetLocationCode() {
	      return LocationStyle[this.controller.getStore().state.widget.common.location];
	    } // public method
	  }, {
	    key: "setUserRegisterData",
	    value: function setUserRegisterData(params) {
	      if (!this.controller || !this.controller.getStore()) {
	        console.error('LiveChatWidget.getUserData: method can be called after fired event - onBitrixLiveChat');
	        return false;
	      }
	      var validUserFields = ['hash', 'name', 'lastName', 'avatar', 'email', 'www', 'gender', 'position'];
	      if (!im_lib_utils.Utils.types.isPlainObject(params)) {
	        console.error("%cLiveChatWidget.setUserData: params is not a object", "color: black;");
	        return false;
	      }
	      for (var field in this.userRegisterData) {
	        if (!this.userRegisterData.hasOwnProperty(field)) {
	          continue;
	        }
	        if (!params[field]) {
	          delete this.userRegisterData[field];
	        }
	      }
	      for (var _field in params) {
	        if (!params.hasOwnProperty(_field)) {
	          continue;
	        }
	        if (validUserFields.indexOf(_field) === -1) {
	          console.warn("%cLiveChatWidget.setUserData: user field is not set, because you are trying to set an unknown field (%c".concat(_field, "%c)"), "color: black;", "font-weight: bold; color: red", "color: black");
	          continue;
	        }
	        this.userRegisterData[_field] = params[_field];
	      }
	      if (this.userRegisterData.hash && this.getUserHash() && this.userRegisterData.hash !== this.getUserHash()) {
	        this.setNewAuthToken(this.userRegisterData.hash);
	      }
	    }
	  }, {
	    key: "setNewAuthToken",
	    value: function setNewAuthToken() {
	      var authToken = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
	      this.controller.getStoreBuilder().clearModelState();
	      im_lib_cookie.Cookie.set(null, 'LIVECHAT_HASH', '', {
	        expires: 365 * 86400,
	        path: '/'
	      });
	      this.controller.restClient.setAuthId(RestAuth.guest, authToken);
	    } // public method
	  }, {
	    key: "setOption",
	    value: function setOption(name, value) {
	      this.options[name] = value;
	      return true;
	    } // public method
	  }, {
	    key: "setCustomData",
	    value: function setCustomData(params) {
	      if (!this.controller || !this.controller.getStore()) {
	        console.error('LiveChatWidget.getUserData: method can be called after fired event - onBitrixLiveChat');
	        return false;
	      }
	      var result = [];
	      if (params instanceof Array) {
	        params.forEach(function (element) {
	          if (element && babelHelpers["typeof"](element) === 'object') {
	            result.push(element);
	          }
	        });
	        if (result.length <= 0) {
	          console.error('LiveChatWidget.setCustomData: params is empty');
	          return false;
	        }
	      } else {
	        if (!params) {
	          return false;
	        }
	        result = [{
	          'MESSAGE': params
	        }];
	      }
	      this.customData = this.customData.concat(result);
	      return true;
	    }
	  }, {
	    key: "setError",
	    value: function setError() {
	      var code = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
	      var description = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
	      console.error("LiveChatWidget.error: ".concat(code, " (").concat(description, ")"));
	      var localizeDescription = '';
	      if (code === 'LIVECHAT_AUTH_FAILED') {
	        localizeDescription = this.getLocalize('BX_LIVECHAT_AUTH_FAILED').replace('#LINK_START#', '<a href="javascript:void();" onclick="location.reload()">').replace('#LINK_END#', '</a>');
	        this.setNewAuthToken();
	      } else if (code === 'LIVECHAT_AUTH_PORTAL_USER') {
	        localizeDescription = this.getLocalize('BX_LIVECHAT_PORTAL_USER_NEW').replace('#LINK_START#', '<a href="' + this.host + '">').replace('#LINK_END#', '</a>');
	      } else if (code === 'LIVECHAT_SAME_DOMAIN') {
	        localizeDescription = this.getLocalize('BX_LIVECHAT_SAME_DOMAIN');
	        var link = this.getLocalize('BX_LIVECHAT_SAME_DOMAIN_LINK');
	        if (link) {
	          localizeDescription += '<br><br><a href="' + link + '">' + this.getLocalize('BX_LIVECHAT_SAME_DOMAIN_MORE') + '</a>';
	        }
	      } else if (code.endsWith('LOCALIZED')) {
	        localizeDescription = description;
	      }
	      this.controller.getStore().commit('application/set', {
	        error: {
	          active: true,
	          code: code,
	          description: localizeDescription
	        }
	      });
	    }
	  }, {
	    key: "clearError",
	    value: function clearError() {
	      this.controller.getStore().commit('application/set', {
	        error: {
	          active: false,
	          code: '',
	          description: ''
	        }
	      });
	    } // public method
	  }, {
	    key: "subscribe",
	    value: function subscribe(params) {
	      if (!im_lib_utils.Utils.types.isPlainObject(params)) {
	        console.error("%cLiveChatWidget.subscribe: params is not a object", "color: black;");
	        return false;
	      }
	      if (!SubscriptionTypeCheck.includes(params.type)) {
	        console.error("%cLiveChatWidget.subscribe: subscription type is not correct (%c".concat(params.type, "%c)"), "color: black;", "font-weight: bold; color: red", "color: black");
	        return false;
	      }
	      if (typeof params.callback !== 'function') {
	        console.error("%cLiveChatWidget.subscribe: callback is not a function (%c".concat(babelHelpers["typeof"](params.callback), "%c)"), "color: black;", "font-weight: bold; color: red", "color: black");
	        return false;
	      }
	      if (typeof this.subscribers[params.type] === 'undefined') {
	        this.subscribers[params.type] = [];
	      }
	      this.subscribers[params.type].push(params.callback);
	      return function () {
	        this.subscribers[params.type] = this.subscribers[params.type].filter(function (element) {
	          return element !== params.callback;
	        });
	      }.bind(this);
	    }
	  }, {
	    key: "sendEvent",
	    value: function sendEvent(params) {
	      params = params || {};
	      if (!params.type) {
	        return false;
	      }
	      if (babelHelpers["typeof"](params.data) !== 'object' || !params.data) {
	        params.data = {};
	      }
	      if (this.subscribers[params.type] instanceof Array && this.subscribers[params.type].length > 0) {
	        this.subscribers[params.type].forEach(function (callback) {
	          return callback(params.data);
	        });
	      }
	      if (this.subscribers[SubscriptionType.every] instanceof Array && this.subscribers[SubscriptionType.every].length > 0) {
	        this.subscribers[SubscriptionType.every].forEach(function (callback) {
	          return callback({
	            type: params.type,
	            data: params.data
	          });
	        });
	      }
	      return true;
	    } // public method
	  }, {
	    key: "addLocalize",
	    value: function addLocalize(phrases) {
	      if (babelHelpers["typeof"](phrases) !== "object" || !phrases) {
	        return false;
	      }
	      for (var name in phrases) {
	        if (phrases.hasOwnProperty(name)) {
	          this.localize[name] = phrases[name];
	        }
	      }
	      return true;
	    }
	  }, {
	    key: "getLocalize",
	    value: function getLocalize(name) {
	      var phrase = '';
	      if (typeof name === 'undefined') {
	        return this.localize;
	      } else if (typeof this.localize[name.toString()] === 'undefined') {
	        console.warn("LiveChatWidget.getLocalize: message with code '".concat(name.toString(), "' is undefined."));
	      } else {
	        phrase = this.localize[name];
	      }
	      return phrase;
	    }
	    /* endregion 04. Widget interaction and utils */
	    /* region 05. Rest batch handlers */
	  }, {
	    key: "handleConfigGet",
	    value: function handleConfigGet(response) {
	      var _this11 = this;
	      return new Promise(function (resolve, reject) {
	        var configGet = response[RestMethod.widgetConfigGet];
	        if (configGet && configGet.error()) {
	          return reject({
	            code: configGet.error().ex.error,
	            description: configGet.error().ex.error_description
	          });
	        }
	        _this11.controller.executeRestAnswer(RestMethod.widgetConfigGet, configGet);
	        resolve();
	      });
	    }
	  }, {
	    key: "handleUserGet",
	    value: function handleUserGet(response) {
	      var _this12 = this;
	      return new Promise(function (resolve, reject) {
	        var userGetResult = response[RestMethod.widgetUserGet];
	        if (userGetResult.error()) {
	          return reject({
	            code: userGetResult.error().ex.error,
	            description: userGetResult.error().ex.error_description
	          });
	        }
	        _this12.controller.executeRestAnswer(RestMethod.widgetUserGet, userGetResult);
	        resolve();
	      });
	    }
	  }, {
	    key: "handleChatGet",
	    value: function handleChatGet(response) {
	      var _this13 = this;
	      return new Promise(function (resolve, reject) {
	        var chatGetResult = response[im_const.RestMethodHandler.imChatGet];
	        if (chatGetResult.error()) {
	          return reject({
	            code: chatGetResult.error().ex.error,
	            description: chatGetResult.error().ex.error_description
	          });
	        }
	        _this13.controller.executeRestAnswer(im_const.RestMethodHandler.imChatGet, chatGetResult);
	        resolve();
	      });
	    }
	  }, {
	    key: "handleDialogGet",
	    value: function handleDialogGet(response) {
	      var _this14 = this;
	      return new Promise(function (resolve, reject) {
	        var dialogGetResult = response[RestMethod.widgetDialogGet];
	        if (!dialogGetResult) {
	          return resolve();
	        }
	        if (dialogGetResult.error()) {
	          return reject({
	            code: dialogGetResult.error().ex.error,
	            description: dialogGetResult.error().ex.error_description
	          });
	        }
	        _this14.controller.executeRestAnswer(RestMethod.widgetDialogGet, dialogGetResult);
	        resolve();
	      });
	    }
	  }, {
	    key: "handleDialogMessagesGet",
	    value: function handleDialogMessagesGet(response) {
	      var _this15 = this;
	      return new Promise(function (resolve, reject) {
	        var dialogMessagesGetResult = response[im_const.RestMethodHandler.imDialogMessagesGetInit];
	        if (!dialogMessagesGetResult) {
	          return resolve();
	        }
	        if (dialogMessagesGetResult.error()) {
	          return reject({
	            code: dialogMessagesGetResult.error().ex.error,
	            description: dialogMessagesGetResult.error().ex.error_description
	          });
	        }
	        _this15.controller.getStore().dispatch('dialogues/saveDialog', {
	          dialogId: _this15.controller.application.getDialogId(),
	          chatId: _this15.controller.application.getChatId()
	        });
	        _this15.controller.executeRestAnswer(im_const.RestMethodHandler.imDialogMessagesGetInit, dialogMessagesGetResult);
	        resolve();
	      });
	    }
	  }, {
	    key: "handleUserRegister",
	    value: function handleUserRegister(response) {
	      var _this16 = this;
	      return new Promise(function (resolve, reject) {
	        var userRegisterResult = response[RestMethod.widgetUserRegister];
	        if (!userRegisterResult) {
	          return resolve();
	        }
	        if (userRegisterResult.error()) {
	          return reject({
	            code: userRegisterResult.error().ex.error,
	            description: userRegisterResult.error().ex.error_description
	          });
	        }
	        _this16.controller.executeRestAnswer(RestMethod.widgetUserRegister, userRegisterResult);
	        resolve();
	      });
	    }
	  }, {
	    key: "handleChatCreate",
	    value: function handleChatCreate(response) {
	      var _this17 = this;
	      return new Promise(function (resolve, reject) {
	        var chatCreateResult = response[RestMethod.widgetChatCreate];
	        if (!chatCreateResult) {
	          return resolve();
	        }
	        if (chatCreateResult.error()) {
	          return reject({
	            code: chatCreateResult.error().ex.error,
	            description: chatCreateResult.error().ex.error_description
	          });
	        }
	        _this17.controller.executeRestAnswer(RestMethod.widgetChatCreate, chatCreateResult);
	        resolve();
	      });
	    }
	  }, {
	    key: "handlePullRequests",
	    value: function handlePullRequests(response) {
	      var _this18 = this;
	      return new Promise(function (resolve) {
	        var timeShift = 0;
	        var serverTimeResult = response[RestMethod.pullServerTime];
	        if (serverTimeResult && !serverTimeResult.error()) {
	          timeShift = Math.floor((Date.now() - new Date(serverTimeResult.data()).getTime()) / 1000);
	        }
	        var config = null;
	        var pullConfigResult = response[RestMethod.pullConfigGet];
	        if (pullConfigResult && !pullConfigResult.error()) {
	          config = pullConfigResult.data();
	          config.server.timeShift = timeShift;
	        }
	        _this18.startPullClient(config).then(function () {
	          main_core_events.EventEmitter.emit(WidgetEventType.processMessagesToSendQueue);
	        })["catch"](function (error) {
	          _this18.setError(error.ex.error, error.ex.error_description);
	        })["finally"](resolve);
	      });
	    } /* endregion 05. Rest batch handlers */
	  }]);
	  return Widget;
	}();

	/**
	 * Bitrix OpenLines widget
	 * Widget public interface
	 *
	 * @package bitrix
	 * @subpackage imopenlines
	 * @copyright 2001-2019 Bitrix
	 */
	var WidgetPublicManager = /*#__PURE__*/function () {
	  function WidgetPublicManager(config) {
	    babelHelpers.classCallCheck(this, WidgetPublicManager);
	    this.developerInfo = 'Do not use private methods.';
	    this.__privateMethods__ = new Widget(config);
	    this.__createLegacyMethods();
	  }
	  babelHelpers.createClass(WidgetPublicManager, [{
	    key: "open",
	    value: function open(params) {
	      return this.__privateMethods__.open(params);
	    }
	  }, {
	    key: "close",
	    value: function close() {
	      return this.__privateMethods__.close();
	    }
	  }, {
	    key: "showNotification",
	    value: function showNotification(params) {
	      return this.__privateMethods__.showNotification(params);
	    }
	  }, {
	    key: "getUserData",
	    value: function getUserData() {
	      return this.__privateMethods__.getUserData();
	    }
	  }, {
	    key: "setUserRegisterData",
	    value: function setUserRegisterData(params) {
	      return this.__privateMethods__.setUserRegisterData(params);
	    }
	  }, {
	    key: "setCustomData",
	    value: function setCustomData(params) {
	      return this.__privateMethods__.setCustomData(params);
	    }
	  }, {
	    key: "mutateTemplateComponent",
	    value: function mutateTemplateComponent(id, params) {
	      return this.__privateMethods__.mutateTemplateComponent(id, params);
	    }
	  }, {
	    key: "addLocalize",
	    value: function addLocalize(phrases) {
	      return this.__privateMethods__.addLocalize(phrases);
	    }
	    /**
	     *
	     * @param params {Object}
	     * @returns {Function|Boolean} - Unsubscribe callback function or False
	     */
	  }, {
	    key: "subscribe",
	    value: function subscribe(params) {
	      return this.__privateMethods__.subscribe(params);
	    }
	  }, {
	    key: "start",
	    value: function start() {
	      return this.__privateMethods__.start();
	    }
	  }, {
	    key: "__createLegacyMethods",
	    value: function __createLegacyMethods() {
	      var _this = this;
	      if (typeof window.BX.LiveChat === 'undefined') {
	        var sourceHref = document.createElement('a');
	        sourceHref.href = this.__privateMethods__.host;
	        var sourceDomain = sourceHref.protocol + '//' + sourceHref.hostname + (sourceHref.port && sourceHref.port != '80' && sourceHref.port != '443' ? ":" + sourceHref.port : "");
	        window.BX.LiveChat = {
	          openLiveChat: function openLiveChat() {
	            _this.open({
	              openFromButton: true
	            });
	          },
	          closeLiveChat: function closeLiveChat() {
	            _this.close();
	          },
	          addEventListener: function addEventListener(el, eventName, handler) {
	            if (eventName === 'message') {
	              _this.subscribe({
	                type: SubscriptionType.userMessage,
	                callback: function callback(event) {
	                  handler({
	                    origin: sourceDomain,
	                    data: JSON.stringify({
	                      action: 'sendMessage'
	                    }),
	                    event: event
	                  });
	                }
	              });
	            } else {
	              console.warn('Method BX.LiveChat.addEventListener is not supported, user new format for subscribe.');
	            }
	          },
	          setCookie: function setCookie() {},
	          getCookie: function getCookie() {},
	          sourceDomain: sourceDomain
	        };
	      }
	      if (typeof window.BxLiveChatInit === 'function') {
	        var config = window.BxLiveChatInit();
	        if (config.user) {
	          this.__privateMethods__.setUserRegisterData(config.user);
	        }
	        if (config.firstMessage) {
	          this.__privateMethods__.setCustomData(config.firstMessage);
	        }
	      }
	      if (window.BxLiveChatLoader instanceof Array) {
	        window.BxLiveChatLoader.forEach(function (callback) {
	          return callback();
	        });
	      }
	      return true;
	    }
	  }]);
	  return WidgetPublicManager;
	}();

	var WidgetSendMessageHandler = /*#__PURE__*/function (_SendMessageHandler) {
	  babelHelpers.inherits(WidgetSendMessageHandler, _SendMessageHandler);
	  function WidgetSendMessageHandler($Bitrix) {
	    var _this;
	    babelHelpers.classCallCheck(this, WidgetSendMessageHandler);
	    _this = babelHelpers.possibleConstructorReturn(this, babelHelpers.getPrototypeOf(WidgetSendMessageHandler).call(this, $Bitrix));
	    babelHelpers.defineProperty(babelHelpers.assertThisInitialized(_this), "application", null);
	    babelHelpers.defineProperty(babelHelpers.assertThisInitialized(_this), "storedMessage", null);
	    _this.application = $Bitrix.Application.get();
	    _this.onProcessQueueHandler = _this.processQueue.bind(babelHelpers.assertThisInitialized(_this));
	    _this.onConsentAcceptedHandler = _this.onConsentAccepted.bind(babelHelpers.assertThisInitialized(_this));
	    _this.onConsentDeclinedHandler = _this.onConsentDeclined.bind(babelHelpers.assertThisInitialized(_this));
	    main_core_events.EventEmitter.subscribe(WidgetEventType.processMessagesToSendQueue, _this.onProcessQueueHandler);
	    main_core_events.EventEmitter.subscribe(WidgetEventType.consentAccepted, _this.onConsentAcceptedHandler);
	    main_core_events.EventEmitter.subscribe(WidgetEventType.consentDeclined, _this.onConsentDeclinedHandler);
	    return _this;
	  }
	  babelHelpers.createClass(WidgetSendMessageHandler, [{
	    key: "destroy",
	    value: function destroy() {
	      babelHelpers.get(babelHelpers.getPrototypeOf(WidgetSendMessageHandler.prototype), "destroy", this).call(this);
	      main_core_events.EventEmitter.unsubscribe(WidgetEventType.processMessagesToSendQueue, this.onProcessQueueHandler);
	      main_core_events.EventEmitter.unsubscribe(WidgetEventType.consentAccepted, this.onConsentAcceptedHandler);
	      main_core_events.EventEmitter.unsubscribe(WidgetEventType.consentDeclined, this.onConsentDeclinedHandler);
	    }
	  }, {
	    key: "onSendMessage",
	    value: function onSendMessage(_ref) {
	      var _this2 = this;
	      var event = _ref.data;
	      event.focus = event.focus !== false;

	      //hide smiles
	      if (this.getWidgetData().common.showForm === FormType.smile) {
	        main_core_events.EventEmitter.emit(WidgetEventType.hideForm);
	      }

	      //show consent window if needed
	      if (!this.getWidgetData().dialog.userConsent && this.getWidgetData().common.consentUrl) {
	        if (event.text) {
	          this.storedMessage = event.text;
	        }
	        main_core_events.EventEmitter.emit(WidgetEventType.showConsent);
	        return false;
	      }
	      event.text = event.text ? event.text : this.storedMessage;
	      if (!event.text && !event.file) {
	        return false;
	      }
	      main_core_events.EventEmitter.emit(WidgetEventType.hideForm);
	      if (this.isCreateSessionMode()) {
	        main_core_events.EventEmitter.emit(WidgetEventType.hideForm);
	        main_core_events.EventEmitter.emit(im_const.EventType.textarea.stopWriting);
	        main_core_events.EventEmitter.emitAsync(WidgetEventType.createSession).then(function () {
	          _this2.store.commit('widget/common', {
	            isCreateSessionMode: false
	          });
	          _this2.sendMessage(event.text, event.file);
	        });
	      } else {
	        this.sendMessage(event.text, event.file);
	      }
	      if (event.focus) {
	        main_core_events.EventEmitter.emit(im_const.EventType.textarea.setFocus);
	      }
	      return true;
	    }
	  }, {
	    key: "sendMessage",
	    value: function sendMessage() {
	      var _this3 = this;
	      var text = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
	      var file = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
	      if (!text && !file) {
	        return false;
	      }
	      var quoteId = this.store.getters['dialogues/getQuoteId'](this.getDialogId());
	      if (quoteId) {
	        var quoteMessage = this.store.getters['messages/getMessage'](this.getChatId(), quoteId);
	        if (quoteMessage) {
	          text = this.getMessageTextWithQuote(quoteMessage, text);
	          main_core_events.EventEmitter.emit(im_const.EventType.dialog.quotePanelClose);
	        }
	      }
	      if (!this.controller.application.isUnreadMessagesLoaded()) {
	        this.sendMessageToServer({
	          id: 0,
	          chatId: this.getChatId(),
	          dialogId: this.getDialogId(),
	          text: text,
	          file: file
	        });
	        this.processQueue();
	        return true;
	      }
	      var params = {};
	      if (file) {
	        params.FILE_ID = [file.id];
	      }
	      this.addMessageToModel({
	        text: text,
	        params: params,
	        sending: !file
	      }).then(function (messageId) {
	        if (!_this3.isDialogStart()) {
	          _this3.store.commit('widget/common', {
	            dialogStart: true
	          });
	        }
	        main_core_events.EventEmitter.emit(im_const.EventType.dialog.scrollToBottom, {
	          chatId: _this3.getChatId(),
	          cancelIfScrollChange: true
	        });
	        _this3.addMessageToQueue({
	          messageId: messageId,
	          text: text,
	          file: file
	        });
	        if (_this3.getChatId()) {
	          _this3.processQueue();
	        } else {
	          main_core_events.EventEmitter.emit(WidgetEventType.requestData);
	        }
	      });
	      return true;
	    }
	  }, {
	    key: "onClickOnKeyboard",
	    value: function onClickOnKeyboard(_ref2) {
	      var event = _ref2.data;
	      if (event.action === 'ACTION' && event.params.action === 'LIVECHAT') {
	        var _event$params = event.params,
	          dialogId = _event$params.dialogId,
	          messageId = _event$params.messageId,
	          value = _event$params.value;
	        var values = JSON.parse(value);
	        var sessionId = Number.parseInt(values.SESSION_ID, 10);
	        if (sessionId !== this.getSessionId() || this.isSessionClose()) {
	          console.error('WidgetSendMessageHandler', this.loc['BX_LIVECHAT_ACTION_EXPIRED']);
	          return false;
	        }
	        this.restClient.callMethod(RestMethod.widgetActionSend, {
	          'MESSAGE_ID': messageId,
	          'DIALOG_ID': dialogId,
	          'ACTION_VALUE': value
	        });
	      }
	      if (event.action === 'COMMAND') {
	        var _event$params2 = event.params,
	          _dialogId = _event$params2.dialogId,
	          _messageId = _event$params2.messageId,
	          botId = _event$params2.botId,
	          command = _event$params2.command,
	          params = _event$params2.params;
	        this.restClient.callMethod(im_const.RestMethod.imMessageCommand, {
	          'MESSAGE_ID': _messageId,
	          'DIALOG_ID': _dialogId,
	          'BOT_ID': botId,
	          'COMMAND': command,
	          'COMMAND_PARAMS': params
	        })["catch"](function (error) {
	          return console.error('WidgetSendMessageHandler: command processing error', error);
	        });
	      }
	    }
	  }, {
	    key: "getWidgetData",
	    value: function getWidgetData() {
	      return this.store.state.widget;
	    }
	  }, {
	    key: "getChatId",
	    value: function getChatId() {
	      return this.store.state.application.dialog.chatId;
	    }
	  }, {
	    key: "getDialogId",
	    value: function getDialogId() {
	      return this.store.state.application.dialog.dialogId;
	    }
	  }, {
	    key: "getUserId",
	    value: function getUserId() {
	      return this.store.state.widget.user.id;
	    }
	  }, {
	    key: "getMessageTextWithQuote",
	    value: function getMessageTextWithQuote(quoteMessage, text) {
	      var user = null;
	      if (quoteMessage.authorId) {
	        user = this.store.getters['users/get'](quoteMessage.authorId);
	      }
	      var files = this.store.getters['files/getList'](this.getChatId());
	      var quoteDelimiter = '-'.repeat(54);
	      var quoteTitle = user && user.name ? user.name : this.loc['BX_LIVECHAT_SYSTEM_MESSAGE'];
	      var quoteDate = im_lib_utils.Utils.date.format(quoteMessage.date, null, this.loc);
	      var quoteContent = im_lib_utils.Utils.text.quote(quoteMessage.text, quoteMessage.params, files, this.loc);
	      var message = [];
	      message.push(quoteDelimiter);
	      message.push("".concat(quoteTitle, " [").concat(quoteDate, "]"));
	      message.push(quoteContent);
	      message.push(quoteDelimiter);
	      message.push(text);
	      return message.join("\n");
	    }
	  }, {
	    key: "addMessageToQueue",
	    value: function addMessageToQueue(_ref3) {
	      var messageId = _ref3.messageId,
	        text = _ref3.text,
	        file = _ref3.file;
	      this.messagesToSend.push({
	        id: messageId,
	        chatId: this.getChatId(),
	        dialogId: this.getDialogId(),
	        text: text,
	        file: file,
	        sending: false
	      });
	    }
	  }, {
	    key: "sendMessageToServer",
	    value: function sendMessageToServer(message) {
	      var _this4 = this;
	      main_core_events.EventEmitter.emit(im_const.EventType.textarea.stopWriting);

	      // first message, when we didn't have chat
	      if (message.chatId === 0) {
	        message.chatId = this.getChatId();
	      }
	      this.restClient.callMethod(im_const.RestMethod.imMessageAdd, {
	        'TEMPLATE_ID': message.id,
	        'CHAT_ID': message.chatId,
	        'MESSAGE': message.text
	      }, null, null, im_lib_utils.Utils.getLogTrackingParams({
	        name: im_const.RestMethod.imMessageAdd,
	        data: {
	          timMessageType: 'text'
	        },
	        dialog: this.getDialogData()
	      })).then(function (response) {
	        _this4.controller.executeRestAnswer(im_const.RestMethodHandler.imMessageAdd, response, message);
	      })["catch"](function (error) {
	        _this4.controller.executeRestAnswer(im_const.RestMethodHandler.imMessageAdd, error, message);
	        im_lib_logger.Logger.warn('Error during sending message', error);
	      });
	      return true;
	    }
	  }, {
	    key: "isDialogStart",
	    value: function isDialogStart() {
	      return this.store.state.widget.common.dialogStart;
	    }
	  }, {
	    key: "isCreateSessionMode",
	    value: function isCreateSessionMode() {
	      return this.store.state.widget.common.isCreateSessionMode;
	    }
	  }, {
	    key: "getDialogData",
	    value: function getDialogData() {
	      var dialogId = this.getDialogId();
	      return this.store.state.dialogues.collection[dialogId];
	    }
	  }, {
	    key: "getApplicationModel",
	    value: function getApplicationModel() {
	      return this.store.state.application;
	    }
	  }, {
	    key: "getSessionId",
	    value: function getSessionId() {
	      return this.store.state.widget.dialog.sessionId;
	    }
	  }, {
	    key: "isSessionClose",
	    value: function isSessionClose() {
	      return this.store.state.widget.dialog.sessionClose;
	    }
	  }, {
	    key: "processQueue",
	    value: function processQueue() {
	      var _this5 = this;
	      if (this.application.offline) {
	        return false;
	      }
	      this.messagesToSend.filter(function (element) {
	        return !element.sending;
	      }).forEach(function (element) {
	        _this5.deleteFromQueue(element.id);
	        element.sending = true;
	        if (element.file) {
	          main_core_events.EventEmitter.emit(im_const.EventType.textarea.stopWriting);
	          main_core_events.EventEmitter.emit(im_const.EventType.uploader.addMessageWithFile, element);
	        } else {
	          _this5.sendMessageToServer(element);
	        }
	      });
	    }
	  }, {
	    key: "onConsentAccepted",
	    value: function onConsentAccepted() {
	      if (!this.storedMessage) {
	        return;
	      }
	      var isFocusNeeded = this.getApplicationModel().device.type !== im_const.DeviceType.mobile;
	      this.onSendMessage({
	        data: {
	          focus: isFocusNeeded
	        }
	      });
	      this.storedMessage = '';
	    }
	  }, {
	    key: "onConsentDeclined",
	    value: function onConsentDeclined() {
	      if (!this.storedMessage) {
	        return;
	      }
	      main_core_events.EventEmitter.emit(im_const.EventType.textarea.insertText, {
	        text: this.storedMessage,
	        focus: this.getApplicationModel().device.type !== im_const.DeviceType.mobile
	      });
	      this.storedMessage = '';
	    }
	  }]);
	  return WidgetSendMessageHandler;
	}(im_eventHandler.SendMessageHandler);

	var WidgetTextareaHandler = /*#__PURE__*/function (_TextareaHandler) {
	  babelHelpers.inherits(WidgetTextareaHandler, _TextareaHandler);
	  function WidgetTextareaHandler($Bitrix) {
	    var _this;
	    babelHelpers.classCallCheck(this, WidgetTextareaHandler);
	    _this = babelHelpers.possibleConstructorReturn(this, babelHelpers.getPrototypeOf(WidgetTextareaHandler).call(this, $Bitrix));
	    babelHelpers.defineProperty(babelHelpers.assertThisInitialized(_this), "application", null);
	    babelHelpers.defineProperty(babelHelpers.assertThisInitialized(_this), "pullClient", null);
	    _this.application = $Bitrix.Application.get();
	    _this.pullClient = $Bitrix.PullClient.get();
	    return _this;
	  }
	  babelHelpers.createClass(WidgetTextareaHandler, [{
	    key: "onAppButtonClick",
	    value: function onAppButtonClick(_ref) {
	      var event = _ref.data;
	      if (event.appId === FormType.smile) {
	        if (this.getWidgetModel().common.showForm === FormType.smile) {
	          main_core_events.EventEmitter.emit(WidgetEventType.hideForm);
	        } else {
	          main_core_events.EventEmitter.emit(WidgetEventType.showForm, {
	            type: FormType.smile
	          });
	        }
	      } else {
	        main_core_events.EventEmitter.emit(im_const.EventType.textarea.setFocus);
	      }
	    }
	  }, {
	    key: "onFocus",
	    value: function onFocus() {
	      var _this2 = this;
	      if (this.getWidgetModel().common.copyright && this.getApplicationModel().device.type === im_const.DeviceType.mobile) {
	        this.getWidgetModel().common.copyright = false;
	      }
	      if (im_lib_utils.Utils.device.isMobile()) {
	        clearTimeout(this.onFocusScrollTimeout);
	        this.onScrollHandler = this.onScroll.bind(this);
	        this.onFocusScrollTimeout = setTimeout(function () {
	          document.addEventListener('scroll', _this2.onScrollHandler);
	        }, 1000);
	      }
	    }
	  }, {
	    key: "onBlur",
	    value: function onBlur() {
	      var _this3 = this;
	      if (!this.getWidgetModel().common.copyright && this.getWidgetModel().common.copyright !== this.application.copyright) {
	        this.getWidgetModel().common.copyright = this.application.copyright;
	        setTimeout(function () {
	          main_core_events.EventEmitter.emit(im_const.EventType.dialog.scrollToBottom, {
	            chatId: _this3.getChatId(),
	            force: true
	          });
	        }, 100);
	      }
	      if (im_lib_utils.Utils.device.isMobile()) {
	        clearTimeout(this.onFocusScrollTimeout);
	        document.removeEventListener('scroll', this.onScrollHandler);
	      }
	    } // send typed client message to operator
	  }, {
	    key: "onKeyUp",
	    value: function onKeyUp(_ref2) {
	      var event = _ref2.data;
	      if (this.canSendTypedText()) {
	        var sessionId = this.getWidgetModel().dialog.sessionId;
	        var chatId = this.getChatId();
	        var userId = this.getWidgetModel().user.id;
	        var infoString = main_md5.md5("".concat(sessionId, "/").concat(chatId, "/").concat(userId));
	        var operatorId = this.getWidgetModel().dialog.operator.id;
	        var operatorChatId = this.getWidgetModel().dialog.operatorChatId;
	        this.pullClient.sendMessage([operatorId], 'imopenlines', 'linesMessageWrite', {
	          text: event.text,
	          infoString: infoString,
	          operatorChatId: operatorChatId
	        });
	      }
	    }
	  }, {
	    key: "canSendTypedText",
	    value: function canSendTypedText() {
	      return this.getWidgetModel().common.watchTyping && this.getWidgetModel().dialog.sessionId && !this.getWidgetModel().dialog.sessionClose && this.getWidgetModel().dialog.operator.id && this.getWidgetModel().dialog.operatorChatId && this.pullClient.isPublishingEnabled();
	    }
	  }, {
	    key: "onScroll",
	    value: function onScroll() {
	      clearTimeout(this.onScrollTimeout);
	      this.onScrollTimeout = setTimeout(function () {
	        main_core_events.EventEmitter.emit(im_const.EventType.textarea.setBlur, true);
	      }, 50);
	    }
	  }, {
	    key: "getWidgetModel",
	    value: function getWidgetModel() {
	      return this.store.state.widget;
	    }
	  }, {
	    key: "getApplicationModel",
	    value: function getApplicationModel() {
	      return this.store.state.application;
	    }
	  }]);
	  return WidgetTextareaHandler;
	}(im_eventHandler.TextareaHandler);

	var WidgetTextareaUploadHandler = /*#__PURE__*/function (_TextareaUploadHandle) {
	  babelHelpers.inherits(WidgetTextareaUploadHandler, _TextareaUploadHandle);
	  function WidgetTextareaUploadHandler($Bitrix) {
	    var _this;
	    babelHelpers.classCallCheck(this, WidgetTextareaUploadHandler);
	    _this = babelHelpers.possibleConstructorReturn(this, babelHelpers.getPrototypeOf(WidgetTextareaUploadHandler).call(this, $Bitrix));
	    babelHelpers.defineProperty(babelHelpers.assertThisInitialized(_this), "storedFile", null);
	    babelHelpers.defineProperty(babelHelpers.assertThisInitialized(_this), "widgetApplication", null);
	    _this.widgetApplication = $Bitrix.Application.get();
	    _this.onConsentAcceptedHandler = _this.onConsentAccepted.bind(babelHelpers.assertThisInitialized(_this));
	    _this.onConsentDeclinedHandler = _this.onConsentDeclined.bind(babelHelpers.assertThisInitialized(_this));
	    main_core_events.EventEmitter.subscribe(WidgetEventType.consentAccepted, _this.onConsentAcceptedHandler);
	    main_core_events.EventEmitter.subscribe(WidgetEventType.consentDeclined, _this.onConsentDeclinedHandler);
	    return _this;
	  }
	  babelHelpers.createClass(WidgetTextareaUploadHandler, [{
	    key: "destroy",
	    value: function destroy() {
	      babelHelpers.get(babelHelpers.getPrototypeOf(WidgetTextareaUploadHandler.prototype), "destroy", this).call(this);
	      main_core_events.EventEmitter.unsubscribe(WidgetEventType.consentAccepted, this.onConsentAcceptedHandler);
	      main_core_events.EventEmitter.unsubscribe(WidgetEventType.consentDeclined, this.onConsentDeclinedHandler);
	    }
	  }, {
	    key: "getUserId",
	    value: function getUserId() {
	      return this.controller.store.state.widget.user.id;
	    }
	  }, {
	    key: "getUserHash",
	    value: function getUserHash() {
	      return this.controller.store.state.widget.user.hash;
	    }
	  }, {
	    key: "getHost",
	    value: function getHost() {
	      return this.controller.store.state.widget.common.host;
	    }
	  }, {
	    key: "addMessageWithFile",
	    value: function addMessageWithFile(event) {
	      var _this2 = this;
	      var message = event.getData();
	      if (!this.getDiskFolderId()) {
	        this.requestDiskFolderId(message.chatId).then(function () {
	          _this2.addMessageWithFile(event);
	        })["catch"](function (error) {
	          im_lib_logger.Logger.error('addMessageWithFile error', error);
	          return false;
	        });
	        return false;
	      }
	      this.uploader.senderOptions.customHeaders['Livechat-Dialog-Id'] = this.getDialogId();
	      this.uploader.senderOptions.customHeaders['Livechat-Auth-Id'] = this.getUserHash();
	      this.uploader.addTask({
	        taskId: message.file.id,
	        fileData: message.file.source.file,
	        fileName: message.file.source.file.name,
	        generateUniqueName: true,
	        diskFolderId: this.getDiskFolderId(),
	        previewBlob: message.file.previewBlob,
	        chunkSize: this.widgetApplication.getLocalize('isCloud') ? im_lib_uploader.Uploader.CLOUD_MAX_CHUNK_SIZE : im_lib_uploader.Uploader.BOX_MIN_CHUNK_SIZE
	      });
	    }
	  }, {
	    key: "onTextareaFileSelected",
	    value: function onTextareaFileSelected() {
	      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	        event = _ref.data;
	      var fileInputEvent = null;
	      if (event && event.fileChangeEvent && event.fileChangeEvent.target.files.length > 0) {
	        fileInputEvent = event.fileChangeEvent;
	      } else {
	        fileInputEvent = this.storedFile;
	      }
	      if (!fileInputEvent) {
	        return false;
	      }
	      if (!this.controller.store.state.widget.dialog.userConsent && this.controller.store.state.widget.common.consentUrl) {
	        this.storedFile = event.fileChangeEvent;
	        main_core_events.EventEmitter.emit(WidgetEventType.showConsent);
	        return false;
	      }
	      this.uploadFile(fileInputEvent);
	    }
	  }, {
	    key: "uploadFile",
	    value: function uploadFile(event) {
	      if (!event) {
	        return false;
	      }
	      if (!this.getChatId()) {
	        main_core_events.EventEmitter.emit(WidgetEventType.requestData);
	      }
	      this.uploader.addFilesFromEvent(event);
	    }
	  }, {
	    key: "onConsentAccepted",
	    value: function onConsentAccepted() {
	      if (!this.storedFile) {
	        return;
	      }
	      this.onTextareaFileSelected();
	      this.storedFile = '';
	    }
	  }, {
	    key: "onConsentDeclined",
	    value: function onConsentDeclined() {
	      if (!this.storedFile) {
	        return;
	      }
	      this.storedFile = '';
	    }
	  }, {
	    key: "getUploaderSenderOptions",
	    value: function getUploaderSenderOptions() {
	      return {
	        host: this.getHost(),
	        customHeaders: {
	          'Livechat-Auth-Id': this.getUserHash()
	        },
	        actionUploadChunk: 'imopenlines.widget.disk.upload',
	        actionCommitFile: 'imopenlines.widget.disk.commit',
	        actionRollbackUpload: 'imopenlines.widget.disk.rollbackUpload'
	      };
	    }
	  }]);
	  return WidgetTextareaUploadHandler;
	}(im_eventHandler.TextareaUploadHandler);

	var WidgetReadingHandler = /*#__PURE__*/function (_ReadingHandler) {
	  babelHelpers.inherits(WidgetReadingHandler, _ReadingHandler);
	  function WidgetReadingHandler($Bitrix) {
	    var _this;
	    babelHelpers.classCallCheck(this, WidgetReadingHandler);
	    _this = babelHelpers.possibleConstructorReturn(this, babelHelpers.getPrototypeOf(WidgetReadingHandler).call(this, $Bitrix));
	    babelHelpers.defineProperty(babelHelpers.assertThisInitialized(_this), "application", null);
	    _this.application = $Bitrix.Application.get();
	    return _this;
	  }
	  babelHelpers.createClass(WidgetReadingHandler, [{
	    key: "readMessage",
	    value: function readMessage(messageId) {
	      var skipTimer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
	      var skipAjax = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
	      if (this.application.offline) {
	        return false;
	      }
	      return babelHelpers.get(babelHelpers.getPrototypeOf(WidgetReadingHandler.prototype), "readMessage", this).call(this, messageId, skipTimer, skipAjax);
	    }
	  }]);
	  return WidgetReadingHandler;
	}(im_eventHandler.ReadingHandler);

	var WidgetResizeHandler = /*#__PURE__*/function (_EventEmitter) {
	  babelHelpers.inherits(WidgetResizeHandler, _EventEmitter);
	  function WidgetResizeHandler(_ref) {
	    var _this;
	    var widgetLocation = _ref.widgetLocation,
	      availableWidth = _ref.availableWidth,
	      availableHeight = _ref.availableHeight,
	      events = _ref.events;
	    babelHelpers.classCallCheck(this, WidgetResizeHandler);
	    _this = babelHelpers.possibleConstructorReturn(this, babelHelpers.getPrototypeOf(WidgetResizeHandler).call(this));
	    babelHelpers.defineProperty(babelHelpers.assertThisInitialized(_this), "isResizing", false);
	    babelHelpers.defineProperty(babelHelpers.assertThisInitialized(_this), "widgetLocation", null);
	    babelHelpers.defineProperty(babelHelpers.assertThisInitialized(_this), "availableWidth", null);
	    babelHelpers.defineProperty(babelHelpers.assertThisInitialized(_this), "availableHeight", null);
	    _this.setEventNamespace('BX.IMOL.WidgetResizeHandler');
	    _this.subscribeToEvents(events);
	    _this.widgetLocation = widgetLocation;
	    _this.availableWidth = availableWidth;
	    _this.availableHeight = availableHeight;
	    return _this;
	  }
	  babelHelpers.createClass(WidgetResizeHandler, [{
	    key: "subscribeToEvents",
	    value: function subscribeToEvents(configEvents) {
	      var _this2 = this;
	      var events = main_core.Type.isObject(configEvents) ? configEvents : {};
	      Object.entries(events).forEach(function (_ref2) {
	        var _ref3 = babelHelpers.slicedToArray(_ref2, 2),
	          name = _ref3[0],
	          callback = _ref3[1];
	        if (main_core.Type.isFunction(callback)) {
	          _this2.subscribe(name, callback);
	        }
	      });
	    }
	  }, {
	    key: "startResize",
	    value: function startResize(event, currentHeight, currentWidth) {
	      if (this.isResizing) {
	        return false;
	      }
	      this.isResizing = true;
	      event = event.changedTouches ? event.changedTouches[0] : event;
	      this.cursorStartPointY = event.clientY;
	      this.cursorStartPointX = event.clientX;
	      this.heightStartPoint = currentHeight;
	      this.widthStartPoint = currentWidth;
	      this.addWidgetResizeEvents();
	    }
	  }, {
	    key: "onContinueResize",
	    value: function onContinueResize(event) {
	      if (!this.isResizing) {
	        return false;
	      }
	      event = event.changedTouches ? event.changedTouches[0] : event;
	      this.cursorControlPointY = event.clientY;
	      this.cursorControlPointX = event.clientX;
	      var maxHeight = this.isBottomLocation() ? Math.min(this.heightStartPoint + this.cursorStartPointY - this.cursorControlPointY, this.availableHeight) : Math.min(this.heightStartPoint - this.cursorStartPointY + this.cursorControlPointY, this.availableHeight);
	      var height = Math.max(maxHeight, WidgetMinimumSize.height);
	      var maxWidth = this.isLeftLocation() ? Math.min(this.widthStartPoint - this.cursorStartPointX + this.cursorControlPointX, this.availableWidth) : Math.min(this.widthStartPoint + this.cursorStartPointX - this.cursorControlPointX, this.availableWidth);
	      var width = Math.max(maxWidth, WidgetMinimumSize.width);
	      this.emit(WidgetResizeHandler.events.onSizeChange, {
	        newHeight: height,
	        newWidth: width
	      });
	    }
	  }, {
	    key: "onStopResize",
	    value: function onStopResize() {
	      if (!this.isResizing) {
	        return false;
	      }
	      this.isResizing = false;
	      this.removeWidgetResizeEvents();
	      this.emit(WidgetResizeHandler.events.onStopResize);
	    }
	  }, {
	    key: "setAvailableWidth",
	    value: function setAvailableWidth(width) {
	      this.availableWidth = width;
	    }
	  }, {
	    key: "setAvailableHeight",
	    value: function setAvailableHeight(height) {
	      this.availableHeight = height;
	    }
	  }, {
	    key: "addWidgetResizeEvents",
	    value: function addWidgetResizeEvents() {
	      this.onContinueResizeHandler = this.onContinueResize.bind(this);
	      this.onStopResizeHandler = this.onStopResize.bind(this);
	      document.addEventListener('mousemove', this.onContinueResizeHandler);
	      document.addEventListener('mouseup', this.onStopResizeHandler);
	      document.addEventListener('mouseleave', this.onStopResizeHandler);
	    }
	  }, {
	    key: "removeWidgetResizeEvents",
	    value: function removeWidgetResizeEvents() {
	      document.removeEventListener('mousemove', this.onContinueResizeHandler);
	      document.removeEventListener('mouseup', this.onStopResizeHandler);
	      document.removeEventListener('mouseleave', this.onStopResizeHandler);
	    }
	  }, {
	    key: "isBottomLocation",
	    value: function isBottomLocation() {
	      return [LocationType.bottomLeft, LocationType.bottomMiddle, LocationType.bottomRight].includes(this.widgetLocation);
	    }
	  }, {
	    key: "isLeftLocation",
	    value: function isLeftLocation() {
	      return [LocationType.bottomLeft, LocationType.topLeft, LocationType.topMiddle].includes(this.widgetLocation);
	    }
	  }, {
	    key: "destroy",
	    value: function destroy() {
	      this.removeWidgetResizeEvents();
	    }
	  }]);
	  return WidgetResizeHandler;
	}(main_core_events.EventEmitter);
	babelHelpers.defineProperty(WidgetResizeHandler, "events", {
	  onSizeChange: 'onSizeChange',
	  onStopResize: 'onStopResize'
	});

	var WidgetConsentHandler = /*#__PURE__*/function () {
	  function WidgetConsentHandler($Bitrix) {
	    babelHelpers.classCallCheck(this, WidgetConsentHandler);
	    babelHelpers.defineProperty(this, "store", null);
	    babelHelpers.defineProperty(this, "restClient", null);
	    babelHelpers.defineProperty(this, "application", null);
	    this.store = $Bitrix.Data.get('controller').store;
	    this.restClient = $Bitrix.RestClient.get();
	    this.application = $Bitrix.Application.get();
	    this.subscribeToEvents();
	  }
	  babelHelpers.createClass(WidgetConsentHandler, [{
	    key: "subscribeToEvents",
	    value: function subscribeToEvents() {
	      this.showConsentHandler = this.onShowConsent.bind(this);
	      this.acceptConsentHandler = this.onAcceptConsent.bind(this);
	      this.declineConsentHandler = this.onDeclineConsent.bind(this);
	      main_core_events.EventEmitter.subscribe(WidgetEventType.showConsent, this.showConsentHandler);
	      main_core_events.EventEmitter.subscribe(WidgetEventType.acceptConsent, this.acceptConsentHandler);
	      main_core_events.EventEmitter.subscribe(WidgetEventType.declineConsent, this.declineConsentHandler);
	    }
	  }, {
	    key: "onShowConsent",
	    value: function onShowConsent() {
	      this.showConsent();
	    }
	  }, {
	    key: "onAcceptConsent",
	    value: function onAcceptConsent() {
	      this.acceptConsent();
	    }
	  }, {
	    key: "onDeclineConsent",
	    value: function onDeclineConsent() {
	      this.declineConsent();
	    }
	  }, {
	    key: "showConsent",
	    value: function showConsent() {
	      this.store.commit('widget/common', {
	        showConsent: true
	      });
	    }
	  }, {
	    key: "hideConsent",
	    value: function hideConsent() {
	      this.store.commit('widget/common', {
	        showConsent: false
	      });
	    }
	  }, {
	    key: "acceptConsent",
	    value: function acceptConsent() {
	      this.hideConsent();
	      this.sendConsentDecision(true);
	      main_core_events.EventEmitter.emit(WidgetEventType.consentAccepted);
	      if (this.getWidgetModel().common.showForm === FormType.none) {
	        main_core_events.EventEmitter.emit(im_const.EventType.textarea.setFocus);
	      }
	    }
	  }, {
	    key: "declineConsent",
	    value: function declineConsent() {
	      main_core_events.EventEmitter.emit(WidgetEventType.hideForm);
	      this.hideConsent();
	      this.sendConsentDecision(false);
	      main_core_events.EventEmitter.emit(WidgetEventType.consentDeclined);
	      if (this.getApplicationModel().device.type !== im_const.DeviceType.mobile) {
	        main_core_events.EventEmitter.emit(im_const.EventType.textarea.setFocus);
	      }
	    }
	  }, {
	    key: "sendConsentDecision",
	    value: function sendConsentDecision(result) {
	      this.store.commit('widget/dialog', {
	        userConsent: result
	      });
	      if (result && this.application.isUserRegistered()) {
	        this.restClient.callMethod(RestMethod.widgetUserConsentApply, {
	          config_id: this.getWidgetModel().common.configId,
	          consent_url: location.href
	        });
	      }
	    }
	  }, {
	    key: "getWidgetModel",
	    value: function getWidgetModel() {
	      return this.store.state.widget;
	    }
	  }, {
	    key: "getApplicationModel",
	    value: function getApplicationModel() {
	      return this.store.state.application;
	    }
	  }, {
	    key: "destroy",
	    value: function destroy() {
	      main_core_events.EventEmitter.unsubscribe(WidgetEventType.showConsent, this.showConsentHandler);
	      main_core_events.EventEmitter.unsubscribe(WidgetEventType.acceptConsent, this.acceptConsentHandler);
	      main_core_events.EventEmitter.unsubscribe(WidgetEventType.declineConsent, this.declineConsentHandler);
	    }
	  }]);
	  return WidgetConsentHandler;
	}();

	var WidgetFormHandler = /*#__PURE__*/function () {
	  function WidgetFormHandler($Bitrix) {
	    babelHelpers.classCallCheck(this, WidgetFormHandler);
	    babelHelpers.defineProperty(this, "store", null);
	    babelHelpers.defineProperty(this, "application", null);
	    babelHelpers.defineProperty(this, "restClient", null);
	    this.store = $Bitrix.Data.get('controller').store;
	    this.restClient = $Bitrix.RestClient.get();
	    this.application = $Bitrix.Application.get();
	    this.showFormHandler = this.onShowForm.bind(this);
	    this.hideFormHandler = this.onHideForm.bind(this);
	    this.sendVoteHandler = this.onSendVote.bind(this);
	    main_core_events.EventEmitter.subscribe(WidgetEventType.showForm, this.showFormHandler);
	    main_core_events.EventEmitter.subscribe(WidgetEventType.hideForm, this.hideFormHandler);
	    main_core_events.EventEmitter.subscribe(WidgetEventType.sendDialogVote, this.sendVoteHandler);
	  }
	  babelHelpers.createClass(WidgetFormHandler, [{
	    key: "onShowForm",
	    value: function onShowForm(_ref) {
	      var _this = this;
	      var event = _ref.data;
	      clearTimeout(this.showFormTimeout);
	      if (event.type === FormType.like) {
	        if (event.delayed) {
	          this.showFormTimeout = setTimeout(function () {
	            _this.showLikeForm();
	          }, 5000);
	        } else {
	          this.showLikeForm();
	        }
	      } else if (event.type === FormType.smile) {
	        this.showSmiles();
	      }
	    }
	  }, {
	    key: "onHideForm",
	    value: function onHideForm() {
	      this.hideForm();
	    }
	  }, {
	    key: "onSendVote",
	    value: function onSendVote(_ref2) {
	      var vote = _ref2.data.vote;
	      console.warn('VOTE', vote);
	      this.sendVote(vote);
	    }
	  }, {
	    key: "showLikeForm",
	    value: function showLikeForm() {
	      if (this.application.offline) {
	        return false;
	      }
	      clearTimeout(this.showFormTimeout);
	      if (!this.getWidgetModel().common.vote.enable) {
	        return false;
	      }
	      if (this.getWidgetModel().dialog.sessionClose && this.getWidgetModel().dialog.userVote !== VoteType.none) {
	        return false;
	      }
	      this.store.commit('widget/common', {
	        showForm: FormType.like
	      });
	    }
	  }, {
	    key: "showSmiles",
	    value: function showSmiles() {
	      this.store.commit('widget/common', {
	        showForm: FormType.smile
	      });
	    }
	  }, {
	    key: "sendVote",
	    value: function sendVote(vote) {
	      var _this2 = this;
	      var sessionId = this.getWidgetModel().dialog.sessionId;
	      if (!sessionId) {
	        return false;
	      }
	      this.restClient.callMethod(RestMethod.widgetVoteSend, {
	        'SESSION_ID': sessionId,
	        'ACTION': vote
	      })["catch"](function () {
	        _this2.store.commit('widget/dialog', {
	          userVote: VoteType.none
	        });
	      });
	      this.application.sendEvent({
	        type: SubscriptionType.userVote,
	        data: {
	          vote: vote
	        }
	      });
	    }
	  }, {
	    key: "hideForm",
	    value: function hideForm() {
	      clearTimeout(this.showFormTimeout);
	      if (this.getWidgetModel().common.showForm !== FormType.none) {
	        this.store.commit('widget/common', {
	          showForm: FormType.none
	        });
	      }
	    }
	  }, {
	    key: "getWidgetModel",
	    value: function getWidgetModel() {
	      return this.store.state.widget;
	    }
	  }, {
	    key: "destroy",
	    value: function destroy() {
	      main_core_events.EventEmitter.unsubscribe(WidgetEventType.showForm, this.showFormHandler);
	      main_core_events.EventEmitter.unsubscribe(WidgetEventType.hideForm, this.hideFormHandler);
	      main_core_events.EventEmitter.unsubscribe(WidgetEventType.sendDialogVote, this.sendVoteHandler);
	    }
	  }]);
	  return WidgetFormHandler;
	}();

	var WidgetReactionHandler = /*#__PURE__*/function (_ReactionHandler) {
	  babelHelpers.inherits(WidgetReactionHandler, _ReactionHandler);
	  function WidgetReactionHandler() {
	    babelHelpers.classCallCheck(this, WidgetReactionHandler);
	    return babelHelpers.possibleConstructorReturn(this, babelHelpers.getPrototypeOf(WidgetReactionHandler).apply(this, arguments));
	  }
	  babelHelpers.createClass(WidgetReactionHandler, [{
	    key: "onOpenMessageReactionList",
	    value: function onOpenMessageReactionList(_ref) {
	      var data = _ref.data;
	      im_lib_logger.Logger.warn('Reactions list is blocked for the widget', data);
	    }
	  }]);
	  return WidgetReactionHandler;
	}(im_eventHandler.ReactionHandler);

	var WidgetHistoryHandler = /*#__PURE__*/function () {
	  function WidgetHistoryHandler($Bitrix) {
	    babelHelpers.classCallCheck(this, WidgetHistoryHandler);
	    babelHelpers.defineProperty(this, "store", null);
	    babelHelpers.defineProperty(this, "application", null);
	    this.store = $Bitrix.Data.get('controller').store;
	    this.application = $Bitrix.Application.get();
	  }
	  babelHelpers.createClass(WidgetHistoryHandler, [{
	    key: "getHtmlHistory",
	    value: function getHtmlHistory() {
	      var chatId = this.getChatId();
	      if (chatId <= 0) {
	        console.error('WidgetHistoryHandler: Incorrect chatId value');
	      }
	      var config = {
	        chatId: this.getChatId()
	      };
	      this.requestControllerAction('imopenlines.widget.history.download', config).then(this.handleRequest.bind(this)).then(this.downloadHistory.bind(this))["catch"](function (error) {
	        return console.error('WidgetHistoryHandler: fetch error.', error);
	      });
	    }
	  }, {
	    key: "requestControllerAction",
	    value: function requestControllerAction(action, config) {
	      var host = this.application.host ? this.application.host : '';
	      var ajaxEndpoint = '/bitrix/services/main/ajax.php';
	      var url = new URL(ajaxEndpoint, host);
	      url.searchParams.set('action', action);
	      var formData = new FormData();
	      for (var key in config) {
	        if (config.hasOwnProperty(key)) {
	          formData.append(key, config[key]);
	        }
	      }
	      return fetch(url, {
	        method: 'POST',
	        headers: {
	          'Livechat-Auth-Id': this.getUserHash()
	        },
	        body: formData
	      });
	    }
	  }, {
	    key: "handleRequest",
	    value: function handleRequest(response) {
	      var contentType = response.headers.get('Content-Type');
	      if (contentType.startsWith('application/json')) {
	        return response.json();
	      }
	      return response.blob();
	    }
	  }, {
	    key: "downloadHistory",
	    value: function downloadHistory(result) {
	      if (result instanceof Blob) {
	        var url = window.URL.createObjectURL(result);
	        var a = document.createElement('a');
	        a.href = url;
	        a.download = "".concat(this.getChatId(), ".html");
	        document.body.append(a);
	        a.click();
	        a.remove();
	      } else if (result.hasOwnProperty('errors')) {
	        console.error("WidgetHistoryHandler: ".concat(result.errors[0]));
	      } else {
	        console.error('WidgetHistoryHandler: unknown error.');
	      }
	    }
	  }, {
	    key: "getChatId",
	    value: function getChatId() {
	      return this.store.state.application.dialog.chatId;
	    }
	  }, {
	    key: "getUserHash",
	    value: function getUserHash() {
	      return this.store.state.widget.user.hash;
	    }
	  }, {
	    key: "destroy",
	    value: function destroy() {
	      //
	    }
	  }]);
	  return WidgetHistoryHandler;
	}();

	var WidgetDialogActionHandler = /*#__PURE__*/function (_DialogActionHandler) {
	  babelHelpers.inherits(WidgetDialogActionHandler, _DialogActionHandler);
	  function WidgetDialogActionHandler() {
	    babelHelpers.classCallCheck(this, WidgetDialogActionHandler);
	    return babelHelpers.possibleConstructorReturn(this, babelHelpers.getPrototypeOf(WidgetDialogActionHandler).apply(this, arguments));
	  }
	  babelHelpers.createClass(WidgetDialogActionHandler, [{
	    key: "onClickOnDialog",
	    value: function onClickOnDialog() {
	      main_core_events.EventEmitter.emit(WidgetEventType.hideForm);
	    }
	  }]);
	  return WidgetDialogActionHandler;
	}(im_eventHandler.DialogActionHandler);

	function ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
	function _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$1(Object(source), !0).forEach(function (key) { babelHelpers.defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
	ui_vue.WidgetBitrixVue.component('bx-livechat', {
	  data: function data() {
	    return {
	      // sizes
	      widgetAvailableHeight: 0,
	      widgetAvailableWidth: 0,
	      widgetCurrentHeight: 0,
	      widgetCurrentWidth: 0,
	      widgetIsResizing: false,
	      textareaHeight: 100,
	      // welcome form
	      welcomeFormFilled: false,
	      // multi dialog
	      startNewChatMode: false
	    };
	  },
	  computed: _objectSpread$1({
	    FormType: function FormType$$1() {
	      return FormType;
	    },
	    VoteType: function VoteType$$1() {
	      return VoteType;
	    },
	    DeviceType: function DeviceType() {
	      return im_const.DeviceType;
	    },
	    EventType: function EventType() {
	      return im_const.EventType;
	    },
	    showTextarea: function showTextarea() {
	      if (this.widget.common.isCreateSessionMode) {
	        return this.startNewChatMode;
	      }
	      var crmFormsSettings = this.widget.common.crmFormsSettings;

	      // show if we dont use welcome form
	      if (!crmFormsSettings.useWelcomeForm || !crmFormsSettings.welcomeFormId) {
	        return true;
	      } else {
	        // show if we use welcome form with delay, otherwise check if it was filled
	        return crmFormsSettings.welcomeFormDelay ? true : this.welcomeFormFilled;
	      }
	    },
	    // for welcome CRM-form before dialog start
	    showWelcomeForm: function showWelcomeForm() {
	      //we are using welcome form, it doesnt have delay and it was not already filled
	      return this.widget.common.crmFormsSettings.useWelcomeForm && !this.widget.common.crmFormsSettings.welcomeFormDelay && this.widget.common.crmFormsSettings.welcomeFormId && !this.welcomeFormFilled;
	    },
	    textareaHeightStyle: function textareaHeightStyle() {
	      return {
	        flex: "0 0 ".concat(this.textareaHeight, "px")
	      };
	    },
	    textareaBottomMargin: function textareaBottomMargin() {
	      if (!this.widget.common.copyright && !this.isBottomLocation()) {
	        return {
	          marginBottom: '5px'
	        };
	      }
	      return '';
	    },
	    widgetHeightStyle: function widgetHeightStyle() {
	      if (im_lib_utils.Utils.device.isMobile() || this.widget.common.pageMode) {
	        return;
	      }
	      if (this.widgetAvailableHeight < WidgetBaseSize.height || this.widgetAvailableHeight < this.widgetCurrentHeight) {
	        this.widgetCurrentHeight = Math.max(this.widgetAvailableHeight, WidgetMinimumSize.height);
	      }
	      return "".concat(this.widgetCurrentHeight, "px");
	    },
	    widgetWidthStyle: function widgetWidthStyle() {
	      if (im_lib_utils.Utils.device.isMobile() || this.widget.common.pageMode) {
	        return;
	      }
	      if (this.widgetAvailableWidth < WidgetBaseSize.width || this.widgetAvailableWidth < this.widgetCurrentWidth) {
	        this.widgetCurrentWidth = Math.max(this.widgetAvailableWidth, WidgetMinimumSize.width);
	      }
	      return "".concat(this.widgetCurrentWidth, "px");
	    },
	    userSelectStyle: function userSelectStyle() {
	      return this.widgetIsResizing ? 'none' : 'auto';
	    },
	    widgetMobileDisabled: function widgetMobileDisabled() {
	      if (this.application.device.type !== im_const.DeviceType.mobile) {
	        return false;
	      }
	      if (this.application.device.orientation !== im_const.DeviceOrientation.horizontal) {
	        return false;
	      }
	      if (navigator.userAgent.toString().includes('iPhone')) {
	        return true;
	      } else {
	        return babelHelpers["typeof"](window.screen) !== 'object' || window.screen.availHeight < 800;
	      }
	    },
	    widgetPositionClass: function widgetPositionClass() {
	      var className = [];
	      if (this.widget.common.pageMode) {
	        className.push('bx-livechat-page-mode');
	      } else {
	        className.push("bx-livechat-position-".concat(LocationStyle[this.widget.common.location]));
	      }
	      return className;
	    },
	    widgetLanguageClass: function widgetLanguageClass() {
	      var className = [];
	      if (this.application.common.languageId === LanguageType.russian) {
	        className.push('bx-livechat-logo-ru');
	      } else if (this.application.common.languageId === LanguageType.ukraine) {
	        className.push('bx-livechat-logo-ua');
	      } else {
	        className.push('bx-livechat-logo-en');
	      }
	      return className;
	    },
	    widgetPlatformClass: function widgetPlatformClass() {
	      var className = [];
	      if (im_lib_utils.Utils.device.isMobile()) {
	        className.push('bx-livechat-mobile');
	      } else if (im_lib_utils.Utils.browser.isSafari()) {
	        className.push('bx-livechat-browser-safari');
	      } else if (im_lib_utils.Utils.browser.isIe()) {
	        className.push('bx-livechat-browser-ie');
	      }
	      if (im_lib_utils.Utils.platform.isMac()) {
	        className.push('bx-livechat-mac');
	      } else {
	        className.push('bx-livechat-custom-scroll');
	      }
	      return className;
	    },
	    widgetClassName: function widgetClassName() {
	      var className = [];
	      className.push.apply(className, babelHelpers.toConsumableArray(this.widgetPositionClass).concat(babelHelpers.toConsumableArray(this.widgetLanguageClass), babelHelpers.toConsumableArray(this.widgetPlatformClass)));
	      if (!this.widget.common.online) {
	        className.push('bx-livechat-offline-state');
	      }
	      if (this.widget.common.dragged) {
	        className.push('bx-livechat-drag-n-drop');
	      }
	      if (this.widget.common.dialogStart) {
	        className.push('bx-livechat-chat-start');
	      }
	      if (this.widget.dialog.operator.name && !(this.application.device.type === im_const.DeviceType.mobile && this.application.device.orientation === im_const.DeviceOrientation.horizontal)) {
	        className.push('bx-livechat-has-operator');
	      }
	      if (this.widget.common.styles.backgroundColor && im_lib_utils.Utils.isDarkColor(this.widget.common.styles.iconColor)) {
	        className.push('bx-livechat-bright-header');
	      }
	      return className;
	    },
	    showMessageDialog: function showMessageDialog() {
	      return this.messageCollection.length > 0;
	    },
	    localize: function localize() {
	      return ui_vue.WidgetBitrixVue.getFilteredPhrases('BX_LIVECHAT_', this);
	    }
	  }, ui_vue_vuex.WidgetVuex.mapState({
	    widget: function widget(state) {
	      return state.widget;
	    },
	    application: function application(state) {
	      return state.application;
	    },
	    dialog: function dialog(state) {
	      return state.dialogues.collection[state.application.dialog.dialogId];
	    },
	    messageCollection: function messageCollection(state) {
	      return state.messages.collection[state.application.dialog.chatId];
	    }
	  })),
	  created: function created() {
	    var _this = this;
	    im_lib_logger.Logger.warn('Livechat component created');
	    // we need to wait for initialization and widget opening to init logic handlers
	    this.onCreated().then(function () {
	      _this.subscribeToEvents();
	      _this.initEventHandlers();
	    });
	  },
	  mounted: function mounted() {
	    if (this.widget.user.id > 0) {
	      this.welcomeFormFilled = true;
	    }
	    this.registerZIndex();
	  },
	  beforeDestroy: function beforeDestroy() {
	    this.unsubscribeEvents();
	    this.destroyHandlers();
	    this.unregisterZIndex();
	  },
	  methods: {
	    // region initialization
	    initEventHandlers: function initEventHandlers() {
	      this.sendMessageHandler = new WidgetSendMessageHandler(this.$Bitrix);
	      this.textareaHandler = new WidgetTextareaHandler(this.$Bitrix);
	      this.textareaUploadHandler = new WidgetTextareaUploadHandler(this.$Bitrix);
	      this.readingHandler = new WidgetReadingHandler(this.$Bitrix);
	      this.consentHandler = new WidgetConsentHandler(this.$Bitrix);
	      this.formHandler = new WidgetFormHandler(this.$Bitrix);
	      this.textareaDragHandler = this.getTextareaDragHandler();
	      this.resizeHandler = this.getWidgetResizeHandler();
	      this.reactionHandler = new WidgetReactionHandler(this.$Bitrix);
	      this.historyHandler = new WidgetHistoryHandler(this.$Bitrix);
	      this.dialogActionHandler = new WidgetDialogActionHandler(this.$Bitrix);
	    },
	    destroyHandlers: function destroyHandlers() {
	      this.sendMessageHandler.destroy();
	      this.textareaHandler.destroy();
	      this.textareaUploadHandler.destroy();
	      this.readingHandler.destroy();
	      this.consentHandler.destroy();
	      this.formHandler.destroy();
	      this.textareaDragHandler.destroy();
	      this.resizeHandler.destroy();
	      this.reactionHandler.destroy();
	      this.historyHandler.destroy();
	      this.dialogActionHandler.destroy();
	    },
	    subscribeToEvents: function subscribeToEvents() {
	      document.addEventListener('keydown', this.onWindowKeyDown);
	      if (!im_lib_utils.Utils.device.isMobile() && !this.widget.common.pageMode) {
	        this.getAvailableSpaceFunc = im_lib_utils.Utils.throttle(this.getAvailableSpace, 50);
	        window.addEventListener('resize', this.getAvailableSpaceFunc);
	      }
	    },
	    unsubscribeEvents: function unsubscribeEvents() {
	      document.removeEventListener('keydown', this.onWindowKeyDown);
	      if (!im_lib_utils.Utils.device.isMobile() && !this.widget.common.pageMode) {
	        window.removeEventListener('resize', this.getAvailableSpaceFunc);
	      }
	    },
	    initMobileEnv: function initMobileEnv() {
	      var _this2 = this;
	      var metaTags = document.head.querySelectorAll('meta');
	      var viewPortMetaSiteNode = babelHelpers.toConsumableArray(metaTags).find(function (element) {
	        return element.name === 'viewport';
	      });
	      if (viewPortMetaSiteNode) {
	        // save tag and remove it from DOM
	        this.viewPortMetaSiteNode = viewPortMetaSiteNode;
	        this.viewPortMetaSiteNode.remove();
	      } else {
	        this.createViewportMeta();
	      }
	      if (!this.viewPortMetaWidgetNode) {
	        this.viewPortMetaWidgetNode = document.createElement('meta');
	        this.viewPortMetaWidgetNode.setAttribute('name', 'viewport');
	        this.viewPortMetaWidgetNode.setAttribute('content', 'width=device-width, initial-scale=1.0, user-scalable=0');
	        document.head.append(this.viewPortMetaWidgetNode);
	      }
	      document.body.classList.add('bx-livechat-mobile-state');
	      if (im_lib_utils.Utils.browser.isSafariBased()) {
	        document.body.classList.add('bx-livechat-mobile-safari-based');
	      }
	      return new Promise(function (resolve) {
	        setTimeout(function () {
	          _this2.$store.dispatch('widget/show').then(resolve);
	        }, 50);
	      });
	    },
	    createViewportMeta: function createViewportMeta() {
	      var contentWidth = document.body.offsetWidth;
	      if (contentWidth < window.innerWidth) {
	        contentWidth = window.innerWidth;
	      }
	      if (contentWidth < 1024) {
	        contentWidth = 1024;
	      }
	      this.viewPortMetaSiteNode = document.createElement('meta');
	      this.viewPortMetaSiteNode.setAttribute('name', 'viewport');
	      this.viewPortMetaSiteNode.setAttribute('content', "width=".concat(contentWidth, ", initial-scale=1.0, user-scalable=1"));
	    },
	    removeMobileEnv: function removeMobileEnv() {
	      document.body.classList.remove('bx-livechat-mobile-state');
	      if (im_lib_utils.Utils.browser.isSafariBased()) {
	        document.body.classList.remove('bx-livechat-mobile-safari-based');
	      }
	      if (this.viewPortMetaWidgetNode) {
	        this.viewPortMetaWidgetNode.remove();
	        this.viewPortMetaWidgetNode = null;
	      }
	      if (this.viewPortMetaSiteNode) {
	        document.head.append(this.viewPortMetaSiteNode);
	        this.viewPortMetaSiteNode = null;
	      }
	    },
	    onCreated: function onCreated() {
	      var _this3 = this;
	      return new Promise(function (resolve) {
	        if (im_lib_utils.Utils.device.isMobile()) {
	          _this3.initMobileEnv().then(resolve);
	        } else {
	          _this3.$store.dispatch('widget/show').then(function () {
	            _this3.widgetCurrentHeight = WidgetBaseSize.height;
	            _this3.widgetCurrentWidth = WidgetBaseSize.width;
	            _this3.getAvailableSpace();

	            // restore widget size from cache
	            _this3.widgetCurrentHeight = _this3.widget.common.widgetHeight || _this3.widgetCurrentHeight;
	            _this3.widgetCurrentWidth = _this3.widget.common.widgetWidth || _this3.widgetCurrentWidth;
	            resolve();
	          });
	        }

	        // restore textarea size from cache
	        _this3.textareaHeight = _this3.widget.common.textareaHeight || _this3.textareaHeight;
	        _this3.initCollections();
	      });
	    },
	    initCollections: function initCollections() {
	      this.$store.commit('files/initCollection', {
	        chatId: this.getApplication().getChatId()
	      });
	      this.$store.commit('messages/initCollection', {
	        chatId: this.getApplication().getChatId()
	      });
	      this.$store.commit('dialogues/initCollection', {
	        dialogId: this.getApplication().getDialogId(),
	        fields: {
	          entityType: 'LIVECHAT',
	          type: 'livechat'
	        }
	      });
	    },
	    // endregion initialization
	    // region events
	    onBeforeClose: function onBeforeClose() {
	      if (im_lib_utils.Utils.device.isMobile()) {
	        this.removeMobileEnv();
	      }
	    },
	    onAfterClose: function onAfterClose() {
	      this.getApplication().close();
	    },
	    onOpenMenu: function onOpenMenu() {
	      this.historyHandler.getHtmlHistory();
	    },
	    onPullRequestConfig: function onPullRequestConfig() {
	      this.getApplication().recoverPullConnection();
	    },
	    onSmilesSelectSmile: function onSmilesSelectSmile(event) {
	      main_core_events.EventEmitter.emit(im_const.EventType.textarea.insertText, {
	        text: event.text
	      });
	    },
	    onSmilesSelectSet: function onSmilesSelectSet() {
	      main_core_events.EventEmitter.emit(im_const.EventType.textarea.setFocus);
	    },
	    onWidgetStartDrag: function onWidgetStartDrag(event) {
	      this.resizeHandler.startResize(event, this.widgetCurrentHeight, this.widgetCurrentWidth);
	      this.widgetIsResizing = true;
	      main_core_events.EventEmitter.emit(im_const.EventType.textarea.setBlur, true);
	    },
	    onWindowKeyDown: function onWindowKeyDown(event) {
	      // not escape
	      if (event.keyCode !== 27) {
	        return;
	      }

	      // hide form
	      if (this.widget.common.showForm !== FormType.none) {
	        this.$store.commit('widget/common', {
	          showForm: FormType.none
	        });
	      }
	      // decline consent
	      else if (this.widget.common.showConsent) {
	        main_core_events.EventEmitter.emit(WidgetEventType.declineConsent);
	      }
	      // close widget
	      else {
	        this.close();
	      }
	      event.preventDefault();
	      event.stopPropagation();
	      main_core_events.EventEmitter.emit(im_const.EventType.textarea.setFocus);
	    },
	    onWelcomeFormSendSuccess: function onWelcomeFormSendSuccess() {
	      this.welcomeFormFilled = true;
	    },
	    onWelcomeFormSendError: function onWelcomeFormSendError(error) {
	      console.error('onWelcomeFormSendError', error);
	      this.welcomeFormFilled = true;
	    },
	    onTextareaStartDrag: function onTextareaStartDrag(event) {
	      this.textareaDragHandler.onStartDrag(event, this.textareaHeight);
	      main_core_events.EventEmitter.emit(im_const.EventType.textarea.setBlur, true);
	    },
	    openDialogList: function openDialogList() {
	      this.$store.commit('widget/common', {
	        isCreateSessionMode: !this.widget.common.isCreateSessionMode
	      });
	      this.startNewChatMode = false;
	    },
	    onStartNewChat: function onStartNewChat() {
	      this.startNewChatMode = true;
	    },
	    // endregion events
	    // region helpers
	    getApplication: function getApplication() {
	      return this.$Bitrix.Application.get();
	    },
	    close: function close() {
	      if (this.widget.common.pageMode) {
	        return false;
	      }
	      this.onBeforeClose();
	      this.$store.commit('widget/common', {
	        showed: false
	      });
	    },
	    // how much width and height we have for resizing
	    getAvailableSpace: function getAvailableSpace() {
	      var widgetMargin = 50;
	      if (this.isBottomLocation()) {
	        var bottomPosition = this.$refs.widgetWrapper.getBoundingClientRect().bottom;
	        var widgetBottomMargin = window.innerHeight - bottomPosition;
	        this.widgetAvailableHeight = window.innerHeight - widgetMargin - widgetBottomMargin;
	      } else {
	        var topPosition = this.$refs.widgetWrapper.getBoundingClientRect().top;
	        this.widgetAvailableHeight = window.innerHeight - widgetMargin - topPosition;
	      }
	      this.widgetAvailableWidth = window.innerWidth - widgetMargin * 2;
	      if (this.resizeHandler) {
	        this.resizeHandler.setAvailableWidth(this.widgetAvailableWidth);
	        this.resizeHandler.setAvailableHeight(this.widgetAvailableHeight);
	      }
	    },
	    getTextareaDragHandler: function getTextareaDragHandler() {
	      var _this4 = this,
	        _TextareaDragHandler;
	      return new im_eventHandler.TextareaDragHandler((_TextareaDragHandler = {}, babelHelpers.defineProperty(_TextareaDragHandler, im_eventHandler.TextareaDragHandler.events.onHeightChange, function (_ref) {
	        var data = _ref.data;
	        var newHeight = data.newHeight;
	        if (_this4.textareaHeight !== newHeight) {
	          _this4.textareaHeight = newHeight;
	        }
	      }), babelHelpers.defineProperty(_TextareaDragHandler, im_eventHandler.TextareaDragHandler.events.onStopDrag, function () {
	        _this4.$store.commit('widget/common', {
	          textareaHeight: _this4.textareaHeight
	        });
	        main_core_events.EventEmitter.emit(im_const.EventType.dialog.scrollToBottom, {
	          chatId: _this4.chatId,
	          force: true
	        });
	      }), _TextareaDragHandler));
	    },
	    getWidgetResizeHandler: function getWidgetResizeHandler() {
	      var _this5 = this,
	        _events;
	      return new WidgetResizeHandler({
	        widgetLocation: this.widget.common.location,
	        availableWidth: this.widgetAvailableWidth,
	        availableHeight: this.widgetAvailableHeight,
	        events: (_events = {}, babelHelpers.defineProperty(_events, WidgetResizeHandler.events.onSizeChange, function (_ref2) {
	          var data = _ref2.data;
	          var newHeight = data.newHeight,
	            newWidth = data.newWidth;
	          if (_this5.widgetCurrentHeight !== newHeight) {
	            _this5.widgetCurrentHeight = newHeight;
	          }
	          if (_this5.widgetCurrentWidth !== newWidth) {
	            _this5.widgetCurrentWidth = newWidth;
	          }
	        }), babelHelpers.defineProperty(_events, WidgetResizeHandler.events.onStopResize, function () {
	          _this5.widgetIsResizing = false;
	          _this5.$store.commit('widget/common', {
	            widgetHeight: _this5.widgetCurrentHeight,
	            widgetWidth: _this5.widgetCurrentWidth
	          });
	        }), _events)
	      });
	    },
	    isBottomLocation: function isBottomLocation() {
	      return [LocationType.bottomLeft, LocationType.bottomMiddle, LocationType.bottomRight].includes(this.widget.common.location);
	    },
	    isPageMode: function isPageMode() {
	      return this.widget.common.pageMode;
	    },
	    registerZIndex: function registerZIndex() {
	      this.zIndexStackInstance = this.$Bitrix.Data.get('zIndexStack');
	      if (this.zIndexStackInstance && !!this.$refs.widgetWrapper) {
	        this.zIndexStackInstance.register(this.$refs.widgetWrapper);
	      }
	    },
	    unregisterZIndex: function unregisterZIndex() {
	      if (this.zIndexStackInstance) {
	        this.zIndexStackInstance.unregister(this.$refs.widgetWrapper);
	      }
	    } // endregion helpers
	  },
	  // language=Vue
	  template: "\n\t\t<transition enter-active-class=\"bx-livechat-show\" leave-active-class=\"bx-livechat-close\" @after-leave=\"onAfterClose\">\n\t\t\t<div\n\t\t\t\t:class=\"widgetClassName\"\n\t\t\t\tv-if=\"widget.common.showed\"\n\t\t\t\t:style=\"{height: widgetHeightStyle, width: widgetWidthStyle, userSelect: userSelectStyle}\"\n\t\t\t\tclass=\"bx-livechat-wrapper bx-livechat-show\"\n\t\t\t\tref=\"widgetWrapper\"\n\t\t\t>\n\t\t\t\t<div class=\"bx-livechat-box\">\n\t\t\t\t\t<div v-if=\"isBottomLocation() && !isPageMode()\" class=\"bx-livechat-widget-resize-handle\" @mousedown=\"onWidgetStartDrag\"></div>\n\t\t\t\t\t<bx-livechat-head \n\t\t\t\t\t\t:isWidgetDisabled=\"widgetMobileDisabled\" \n\t\t\t\t\t\t@openMenu=\"onOpenMenu\" \n\t\t\t\t\t\t@close=\"close\"\n\t\t\t\t\t\t@openDialogList=\"openDialogList\"\n\t\t\t\t\t/>\n\t\t\t\t\t<template v-if=\"widgetMobileDisabled\">\n\t\t\t\t\t\t<bx-livechat-body-orientation-disabled/>\n\t\t\t\t\t</template>\n\t\t\t\t\t<template v-else-if=\"application.error.active\">\n\t\t\t\t\t\t<bx-livechat-body-error/>\n\t\t\t\t\t</template>\n\t\t\t\t\t<template v-else-if=\"!widget.common.configId\">\n\t\t\t\t\t\t<div class=\"bx-livechat-body\" key=\"loading-body\">\n\t\t\t\t\t\t\t<bx-livechat-body-loading/>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</template>\n\t\t\t\t\t<template v-else>\n\t\t\t\t\t\t<div v-show=\"!widget.common.dialogStart\" class=\"bx-livechat-body\" :class=\"{'bx-livechat-body-with-scroll': showWelcomeForm}\" key=\"welcome-body\">\n\t\t\t\t\t\t\t<bx-imopenlines-form\n\t\t\t\t\t\t\t  v-show=\"showWelcomeForm\"\n\t\t\t\t\t\t\t  @formSendSuccess=\"onWelcomeFormSendSuccess\"\n\t\t\t\t\t\t\t  @formSendError=\"onWelcomeFormSendError\"\n\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t<template v-if=\"!showWelcomeForm\">\n\t\t\t\t\t\t\t\t<bx-livechat-body-operators/>\n\t\t\t\t\t\t\t\t<keep-alive include=\"bx-livechat-smiles\">\n\t\t\t\t\t\t\t\t\t<template v-if=\"widget.common.showForm === FormType.smile\">\n\t\t\t\t\t\t\t\t\t\t<bx-livechat-smiles @selectSmile=\"onSmilesSelectSmile\" @selectSet=\"onSmilesSelectSet\"/>\n\t\t\t\t\t\t\t\t\t</template>\n\t\t\t\t\t\t\t\t</keep-alive>\n\t\t\t\t\t\t\t</template>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t<template v-if=\"widget.common.dialogStart\">\n\t\t\t\t\t\t\t<bx-pull-component-status :canReconnect=\"true\" @reconnect=\"onPullRequestConfig\"/>\n\t\t\t\t\t\t\t<div :class=\"['bx-livechat-body', {'bx-livechat-body-with-message': showMessageDialog}]\" key=\"with-message\">\n\t\t\t\t\t\t\t\t<template v-if=\"widget.common.isCreateSessionMode\">\n\t\t\t\t\t\t\t\t\t<bx-livechat-dialogues-list @startNewChat=\"onStartNewChat\"/>\n\t\t\t\t\t\t\t\t</template>\n\t\t\t\t\t\t\t\t<template v-else-if=\"showMessageDialog\">\n\t\t\t\t\t\t\t\t\t<div class=\"bx-livechat-dialog\">\n\t\t\t\t\t\t\t\t\t\t<bx-im-component-dialog\n\t\t\t\t\t\t\t\t\t\t\t:userId=\"application.common.userId\"\n\t\t\t\t\t\t\t\t\t\t\t:dialogId=\"application.dialog.dialogId\"\n\t\t\t\t\t\t\t\t\t\t\t:messageLimit=\"application.dialog.messageLimit\"\n\t\t\t\t\t\t\t\t\t\t\t:enableReactions=\"true\"\n\t\t\t\t\t\t\t\t\t\t\t:enableDateActions=\"false\"\n\t\t\t\t\t\t\t\t\t\t\t:enableCreateContent=\"false\"\n\t\t\t\t\t\t\t\t\t\t\t:enableGestureQuote=\"true\"\n\t\t\t\t\t\t\t\t\t\t\t:enableGestureMenu=\"true\"\n\t\t\t\t\t\t\t\t\t\t\t:showMessageAvatar=\"false\"\n\t\t\t\t\t\t\t\t\t\t\t:showMessageMenu=\"false\"\n\t\t\t\t\t\t\t\t\t\t\t:skipDataRequest=\"true\"\n\t\t\t\t\t\t\t\t\t\t\t:showLoadingState=\"false\"\n\t\t\t\t\t\t\t\t\t\t\t:showEmptyState=\"false\"\n\t\t\t\t\t\t\t\t\t\t />\n\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t</template>\n\t\t\t\t\t\t\t\t<template v-else>\n\t\t\t\t\t\t\t\t\t<bx-livechat-body-loading/>\n\t\t\t\t\t\t\t\t</template>\n\n\t\t\t\t\t\t\t\t<keep-alive include=\"bx-livechat-smiles\">\n\t\t\t\t\t\t\t\t\t<template v-if=\"widget.common.showForm === FormType.like && widget.common.vote.enable\">\n\t\t\t\t\t\t\t\t\t\t<bx-livechat-form-vote/>\n\t\t\t\t\t\t\t\t\t</template>\n\t\t\t\t\t\t\t\t\t<template v-else-if=\"widget.common.showForm === FormType.welcome\">\n\t\t\t\t\t\t\t\t\t\t<bx-livechat-form-welcome/>\n\t\t\t\t\t\t\t\t\t</template>\n\t\t\t\t\t\t\t\t\t<template v-else-if=\"widget.common.showForm === FormType.offline\">\n\t\t\t\t\t\t\t\t\t\t<bx-livechat-form-offline/>\n\t\t\t\t\t\t\t\t\t</template>\n\t\t\t\t\t\t\t\t\t<template v-else-if=\"widget.common.showForm === FormType.history\">\n\t\t\t\t\t\t\t\t\t\t<bx-livechat-form-history/>\n\t\t\t\t\t\t\t\t\t</template>\n\t\t\t\t\t\t\t\t\t<template v-else-if=\"widget.common.showForm === FormType.smile\">\n\t\t\t\t\t\t\t\t\t\t<bx-livechat-smiles @selectSmile=\"onSmilesSelectSmile\" @selectSet=\"onSmilesSelectSet\"/>\n\t\t\t\t\t\t\t\t\t</template>\n\t\t\t\t\t\t\t\t</keep-alive>\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t</template>\n\t\t\t\t\t\t<div v-if=\"showTextarea || startNewChatMode\" class=\"bx-livechat-textarea\" :style=\"[textareaHeightStyle, textareaBottomMargin]\" ref=\"textarea\">\n\t\t\t\t\t\t\t<div class=\"bx-livechat-textarea-resize-handle\" @mousedown=\"onTextareaStartDrag\" @touchstart=\"onTextareaStartDrag\"></div>\n\t\t\t\t\t\t\t<bx-im-component-textarea\n\t\t\t\t\t\t\t\t:siteId=\"application.common.siteId\"\n\t\t\t\t\t\t\t\t:userId=\"application.common.userId\"\n\t\t\t\t\t\t\t\t:dialogId=\"application.dialog.dialogId\"\n\t\t\t\t\t\t\t\t:writesEventLetter=\"3\"\n\t\t\t\t\t\t\t\t:enableEdit=\"true\"\n\t\t\t\t\t\t\t\t:enableCommand=\"false\"\n\t\t\t\t\t\t\t\t:enableMention=\"false\"\n\t\t\t\t\t\t\t\t:enableFile=\"application.disk.enabled\"\n\t\t\t\t\t\t\t\t:autoFocus=\"application.device.type !== DeviceType.mobile\"\n\t\t\t\t\t\t\t\t:styles=\"{button: {backgroundColor: widget.common.styles.backgroundColor, iconColor: widget.common.styles.iconColor}}\"\n\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t<div v-if=\"!widget.common.copyright && !isBottomLocation\" class=\"bx-livechat-nocopyright-resize-wrap\" style=\"position: relative;\">\n\t\t\t\t\t\t\t<div class=\"bx-livechat-widget-resize-handle\" @mousedown=\"onWidgetStartDrag\"></div>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t<bx-livechat-form-consent />\n\t\t\t\t\t\t<template v-if=\"widget.common.copyright\">\n\t\t\t\t\t\t\t<div class=\"bx-livechat-copyright\">\n\t\t\t\t\t\t\t\t<template v-if=\"widget.common.copyrightUrl\">\n\t\t\t\t\t\t\t\t\t<a class=\"bx-livechat-copyright-link\" :href=\"widget.common.copyrightUrl\" target=\"_blank\">\n\t\t\t\t\t\t\t\t\t\t<span class=\"bx-livechat-logo-name\">{{localize.BX_LIVECHAT_COPYRIGHT_TEXT}}</span>\n\t\t\t\t\t\t\t\t\t\t<span class=\"bx-livechat-logo-icon\"></span>\n\t\t\t\t\t\t\t\t\t</a>\n\t\t\t\t\t\t\t\t</template>\n\t\t\t\t\t\t\t\t<template v-else>\n\t\t\t\t\t\t\t\t\t<span class=\"bx-livechat-logo-name\">{{localize.BX_LIVECHAT_COPYRIGHT_TEXT}}</span>\n\t\t\t\t\t\t\t\t\t<span class=\"bx-livechat-logo-icon\"></span>\n\t\t\t\t\t\t\t\t</template>\n\t\t\t\t\t\t\t\t<div v-if=\"!isBottomLocation() && !isPageMode()\" class=\"bx-livechat-widget-resize-handle\" @mousedown=\"onWidgetStartDrag\"></div>\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t</template>\n\t\t\t\t\t</template>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t</transition>\n\t"
	});

	function ownKeys$2(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
	function _objectSpread$2(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$2(Object(source), !0).forEach(function (key) { babelHelpers.defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$2(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
	ui_vue.WidgetBitrixVue.component('bx-livechat-body-error', {
	  computed: _objectSpread$2({}, ui_vue_vuex.WidgetVuex.mapState({
	    application: function application(state) {
	      return state.application;
	    }
	  })),
	  template: "\n\t\t<div class=\"bx-livechat-body\" key=\"error-body\">\n\t\t\t<div class=\"bx-livechat-warning-window\">\n\t\t\t\t<div class=\"bx-livechat-warning-icon\"></div>\n\t\t\t\t<template v-if=\"application.error.description\"> \n\t\t\t\t\t<div class=\"bx-livechat-help-title bx-livechat-help-title-sm bx-livechat-warning-msg\" v-html=\"application.error.description\"></div>\n\t\t\t\t</template> \n\t\t\t\t<template v-else>\n\t\t\t\t\t<div class=\"bx-livechat-help-title bx-livechat-help-title-md bx-livechat-warning-msg\">{{$Bitrix.Loc.getMessage('BX_LIVECHAT_ERROR_TITLE')}}</div>\n\t\t\t\t\t<div class=\"bx-livechat-help-title bx-livechat-help-title-sm bx-livechat-warning-msg\">{{$Bitrix.Loc.getMessage('BX_LIVECHAT_ERROR_DESC')}}</div>\n\t\t\t\t</template> \n\t\t\t</div>\n\t\t</div>\n\t"
	});

	function ownKeys$3(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
	function _objectSpread$3(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$3(Object(source), !0).forEach(function (key) { babelHelpers.defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$3(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
	ui_vue.WidgetBitrixVue.component('bx-livechat-head', {
	  /**
	   * @emits 'close'
	   * @emits 'like'
	   * @emits 'history'
	   */
	  props: {
	    isWidgetDisabled: {
	      "default": false
	    }
	  },
	  data: function data() {
	    return {
	      multiDialog: false // disabled because of beta status
	    };
	  },

	  methods: {
	    openDialogList: function openDialogList() {
	      main_core_events.EventEmitter.emit(WidgetEventType.hideForm);
	      this.$emit('openDialogList');
	    },
	    close: function close(event) {
	      this.$emit('close');
	    },
	    like: function like() {
	      main_core_events.EventEmitter.emit(WidgetEventType.showForm, {
	        type: FormType.like
	      });
	    },
	    openMenu: function openMenu(event) {
	      this.$emit('openMenu', event);
	    }
	  },
	  computed: _objectSpread$3({
	    VoteType: function VoteType$$1() {
	      return VoteType;
	    },
	    chatId: function chatId() {
	      if (this.application) {
	        return this.application.dialog.chatId;
	      }
	    },
	    customBackgroundStyle: function customBackgroundStyle(state) {
	      return state.widget.common.styles.backgroundColor ? 'background-color: ' + state.widget.common.styles.backgroundColor + '!important;' : '';
	    },
	    customBackgroundOnlineStyle: function customBackgroundOnlineStyle(state) {
	      return state.widget.common.styles.backgroundColor ? 'border-color: ' + state.widget.common.styles.backgroundColor + '!important;' : '';
	    },
	    showName: function showName(state) {
	      return state.widget.dialog.operator.firstName || state.widget.dialog.operator.lastName;
	    },
	    voteActive: function voteActive(state) {
	      if (!!state.widget.dialog.closeVote) {
	        return false;
	      }
	      if (!state.widget.common.vote.beforeFinish && state.widget.dialog.sessionStatus < SessionStatus.waitClient) {
	        return false;
	      }
	      if (!state.widget.dialog.sessionClose || state.widget.dialog.sessionClose && state.widget.dialog.userVote === VoteType.none) {
	        return true;
	      }
	      if (state.widget.dialog.sessionClose && state.widget.dialog.userVote !== VoteType.none) {
	        return true;
	      }
	      return false;
	    },
	    chatTitle: function chatTitle(state) {
	      return state.widget.common.textMessages.bxLivechatTitle || state.widget.common.configName || this.localize.BX_LIVECHAT_TITLE;
	    },
	    operatorName: function operatorName(state) {
	      if (!this.showName) return '';
	      return state.widget.dialog.operator.firstName ? state.widget.dialog.operator.firstName : state.widget.dialog.operator.name;
	    },
	    operatorDescription: function operatorDescription(state) {
	      if (!this.showName) {
	        return '';
	      }
	      var operatorPosition = state.widget.dialog.operator.workPosition ? state.widget.dialog.operator.workPosition : this.localize.BX_LIVECHAT_USER;
	      if (state.widget.common.showSessionId && state.widget.dialog.sessionId >= 0) {
	        return this.localize.BX_LIVECHAT_OPERATOR_POSITION_AND_SESSION_ID.replace("#POSITION#", operatorPosition).replace("#ID#", state.widget.dialog.sessionId);
	      }
	      return this.localize.BX_LIVECHAT_OPERATOR_POSITION_ONLY.replace("#POSITION#", operatorPosition);
	    },
	    localize: function localize() {
	      return ui_vue.WidgetBitrixVue.getFilteredPhrases('BX_LIVECHAT_', this);
	    },
	    ie11: function ie11() {
	      return main_core_minimal.Browser.isIE11();
	    }
	  }, ui_vue_vuex.WidgetVuex.mapState({
	    widget: function widget(state) {
	      return state.widget;
	    },
	    application: function application(state) {
	      return state.application;
	    }
	  })),
	  watch: {
	    showName: function showName(value) {
	      var _this = this;
	      if (value) {
	        setTimeout(function () {
	          _this.$root.$emit(im_const.EventType.dialog.scrollToBottom, {
	            chatId: _this.chatId
	          });
	        }, 300);
	      }
	    }
	  },
	  //language=Vue
	  template: "\n\t\t<div class=\"bx-livechat-head-wrap\">\n\t\t\t<template v-if=\"isWidgetDisabled\">\n\t\t\t\t<div class=\"bx-livechat-head\" :style=\"customBackgroundStyle\">\n\t\t\t\t\t<div class=\"bx-livechat-title\">{{chatTitle}}</div>\n\t\t\t\t\t<div class=\"bx-livechat-control-box\">\n\t\t\t\t\t\t<button v-if=\"!widget.common.pageMode\" class=\"bx-livechat-control-btn bx-livechat-control-btn-close\" :title=\"localize.BX_LIVECHAT_CLOSE_BUTTON\" @click=\"close\"></button>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\t\n\t\t\t</template>\n\t\t\t<template v-else-if=\"application.error.active\">\n\t\t\t\t<div class=\"bx-livechat-head\" :style=\"customBackgroundStyle\">\n\t\t\t\t\t<div class=\"bx-livechat-title\">{{chatTitle}}</div>\n\t\t\t\t\t<div class=\"bx-livechat-control-box\">\n\t\t\t\t\t\t<button v-if=\"!widget.common.pageMode\" class=\"bx-livechat-control-btn bx-livechat-control-btn-close\" :title=\"localize.BX_LIVECHAT_CLOSE_BUTTON\" @click=\"close\"></button>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t</template>\n\t\t\t<template v-else-if=\"!widget.common.configId\">\n\t\t\t\t<div class=\"bx-livechat-head\" :style=\"customBackgroundStyle\">\n\t\t\t\t\t<div class=\"bx-livechat-title\">{{chatTitle}}</div>\n\t\t\t\t\t<div class=\"bx-livechat-control-box\">\n\t\t\t\t\t\t<button v-if=\"!widget.common.pageMode\" class=\"bx-livechat-control-btn bx-livechat-control-btn-close\" :title=\"localize.BX_LIVECHAT_CLOSE_BUTTON\" @click=\"close\"></button>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t</template>\t\t\t\n\t\t\t<template v-else>\n\t\t\t\t<div class=\"bx-livechat-head\" :style=\"customBackgroundStyle\">\n\t\t\t\t\t<template v-if=\"!showName\">\n\t\t\t\t\t\t<div class=\"bx-livechat-title\">{{chatTitle}}</div>\n\t\t\t\t\t</template>\n\t\t\t\t\t<template v-else>\n\t\t\t\t\t\t<div class=\"bx-livechat-user bx-livechat-status-online\">\n\t\t\t\t\t\t\t<template v-if=\"widget.dialog.operator.avatar\">\n\t\t\t\t\t\t\t\t<div class=\"bx-livechat-user-icon\" :style=\"'background-image: url('+encodeURI(widget.dialog.operator.avatar)+')'\">\n\t\t\t\t\t\t\t\t\t<div v-if=\"widget.dialog.operator.online\" class=\"bx-livechat-user-status\" :style=\"customBackgroundOnlineStyle\"></div>\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t</template>\n\t\t\t\t\t\t\t<template v-else>\n\t\t\t\t\t\t\t\t<div class=\"bx-livechat-user-icon\">\n\t\t\t\t\t\t\t\t\t<div v-if=\"widget.dialog.operator.online\" class=\"bx-livechat-user-status\" :style=\"customBackgroundOnlineStyle\"></div>\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t</template>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t<div class=\"bx-livechat-user-info\">\n\t\t\t\t\t\t\t<div class=\"bx-livechat-user-name\">{{operatorName}}</div>\n\t\t\t\t\t\t\t<div class=\"bx-livechat-user-position\">{{operatorDescription}}</div>\t\t\t\t\t\t\t\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</template>\n\t\t\t\t\t<div class=\"bx-livechat-control-box\">\n\t\t\t\t\t\t<span class=\"bx-livechat-control-box-active\" v-if=\"widget.common.dialogStart && widget.dialog.sessionId\">\n\t\t\t\t\t\t\t<button v-if=\"widget.common.vote.enable && voteActive\" :class=\"'bx-livechat-control-btn bx-livechat-control-btn-like bx-livechat-dialog-vote-'+(widget.dialog.userVote)\" :title=\"localize.BX_LIVECHAT_VOTE_BUTTON\" @click=\"like\"></button>\n\t\t\t\t\t\t\t<button\n\t\t\t\t\t\t\t\tv-if=\"!ie11 && application.dialog.chatId > 0\"\n\t\t\t\t\t\t\t\tclass=\"bx-livechat-control-btn bx-livechat-control-btn-menu\"\n\t\t\t\t\t\t\t\t@click=\"openMenu\"\n\t\t\t\t\t\t\t\t:title=\"localize.BX_LIVECHAT_DOWNLOAD_HISTORY\"\n\t\t\t\t\t\t\t></button>\n\t\t\t\t\t\t\t<button\n\t\t\t\t\t\t\t\tv-if=\"multiDialog && application.dialog.chatId > 0\"\n\t\t\t\t\t\t\t\tclass=\"bx-livechat-control-btn bx-livechat-control-btn-list\"\n\t\t\t\t\t\t\t\t@click=\"openDialogList\"\n\t\t\t\t\t\t\t></button>\n\t\t\t\t\t\t</span>\t\n\t\t\t\t\t\t<button v-if=\"!widget.common.pageMode\" class=\"bx-livechat-control-btn bx-livechat-control-btn-close\" :title=\"localize.BX_LIVECHAT_CLOSE_BUTTON\" @click=\"close\"></button>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t</template>\n\t\t</div>\n\t"
	});

	/**
	 * Bitrix OpenLines widget
	 * Body loading component (Vue component)
	 *
	 * @package bitrix
	 * @subpackage imopenlines
	 * @copyright 2001-2019 Bitrix
	 */
	ui_vue.WidgetBitrixVue.component('bx-livechat-body-loading', {
	  template: "\n\t\t<div class=\"bx-livechat-loading-window\">\n\t\t\t<svg class=\"bx-livechat-loading-circular\" viewBox=\"25 25 50 50\">\n\t\t\t\t<circle class=\"bx-livechat-loading-path\" cx=\"50\" cy=\"50\" r=\"20\" fill=\"none\" stroke-miterlimit=\"10\"/>\n\t\t\t\t<circle class=\"bx-livechat-loading-inner-path\" cx=\"50\" cy=\"50\" r=\"20\" fill=\"none\" stroke-miterlimit=\"10\"/>\n\t\t\t</svg>\n\t\t\t<h3 class=\"bx-livechat-help-title bx-livechat-help-title-md bx-livechat-loading-msg\">{{$Bitrix.Loc.getMessage('BX_LIVECHAT_LOADING')}}</h3>\n\t\t</div>\n\t"
	});

	function ownKeys$4(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
	function _objectSpread$4(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$4(Object(source), !0).forEach(function (key) { babelHelpers.defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$4(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
	ui_vue.WidgetBitrixVue.component('bx-livechat-body-operators', {
	  computed: _objectSpread$4({}, ui_vue_vuex.WidgetVuex.mapState({
	    widget: function widget(state) {
	      return state.widget;
	    }
	  })),
	  template: "\n\t\t<div class=\"bx-livechat-help-container\">\n\t\t\t<transition name=\"bx-livechat-animation-fade\">\n\t\t\t\t<h2 v-if=\"widget.common.online\" key=\"online\" class=\"bx-livechat-help-title bx-livechat-help-title-lg\">{{widget.common.textMessages.bxLivechatOnlineLine1}}<div class=\"bx-livechat-help-subtitle\">{{widget.common.textMessages.bxLivechatOnlineLine2}}</div></h2>\n\t\t\t\t<h2 v-else key=\"offline\" class=\"bx-livechat-help-title bx-livechat-help-title-sm\">{{widget.common.textMessages.bxLivechatOffline}}</h2>\n\t\t\t</transition>\t\n\t\t\t<div class=\"bx-livechat-help-user\">\n\t\t\t\t<template v-for=\"operator in widget.common.operators\">\n\t\t\t\t\t<div class=\"bx-livechat-user\" :key=\"operator.id\">\n\t\t\t\t\t\t<template v-if=\"operator.avatar\">\n\t\t\t\t\t\t\t<div class=\"bx-livechat-user-icon\" :style=\"'background-image: url('+encodeURI(operator.avatar)+')'\"></div>\n\t\t\t\t\t\t</template>\n\t\t\t\t\t\t<template v-else>\n\t\t\t\t\t\t\t<div class=\"bx-livechat-user-icon\"></div>\n\t\t\t\t\t\t</template>\t\n\t\t\t\t\t\t<div class=\"bx-livechat-user-info\">\n\t\t\t\t\t\t\t<div class=\"bx-livechat-user-name\">{{operator.firstName? operator.firstName: operator.name}}</div>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>\n\t\t\t\t</template>\t\n\t\t\t</div>\n\t\t</div>\n\t"
	});

	function ownKeys$5(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
	function _objectSpread$5(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$5(Object(source), !0).forEach(function (key) { babelHelpers.defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$5(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
	ui_vue.WidgetBitrixVue.component('bx-livechat-dialogues-list', {
	  data: function data() {
	    return {
	      newChatMode: false,
	      sessionList: [],
	      isLoading: false,
	      pagesLoaded: 0,
	      hasMoreItemsToLoad: true,
	      itemsPerPage: 25
	    };
	  },
	  computed: _objectSpread$5({}, ui_vue_vuex.WidgetVuex.mapState({
	    dialogues: function dialogues(state) {
	      return state.dialogues;
	    }
	  })),
	  mounted: function mounted() {
	    this.requestDialogList();
	  },
	  methods: {
	    requestDialogList: function requestDialogList() {
	      var _this = this;
	      var offset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
	      this.isLoading = true;
	      var requestParams = {
	        'CONFIG_ID': this.$Bitrix.Application.get().getConfigId()
	      };
	      if (offset > 0) {
	        requestParams['OFFSET'] = offset;
	      }
	      return this.$Bitrix.Application.get().controller.restClient.callMethod(RestMethod.widgetDialogList, requestParams).then(function (result) {
	        if (result.data().length === 0 || result.data().length < _this.itemsPerPage) {
	          _this.hasMoreItemsToLoad = false;
	        }
	        _this.pagesLoaded++;
	        _this.isLoading = false;
	        _this.sessionList = [].concat(babelHelpers.toConsumableArray(_this.sessionList), babelHelpers.toConsumableArray(_this.prepareSessionList(result.data())));
	      })["catch"](function (error) {
	        console.warn('error', error);
	      });
	    },
	    prepareSessionList: function prepareSessionList(sessionList) {
	      return Object.values(sessionList).map(function (dialog) {
	        return {
	          chatId: dialog.chatId,
	          dialogId: dialog.dialogId,
	          name: "Dialog #".concat(dialog.sessionId)
	        };
	      });
	    },
	    openSession: function openSession(event) {
	      main_core_events.EventEmitter.emit(WidgetEventType.openSession, event);
	    },
	    startNewChat: function startNewChat(event) {
	      this.newChatMode = true;
	      this.$emit('startNewChat', event);
	    },
	    isOneScreenRemaining: function isOneScreenRemaining(event) {
	      return event.target.scrollTop + event.target.clientHeight >= event.target.scrollHeight - event.target.clientHeight;
	    },
	    onScroll: function onScroll(event) {
	      if (this.isOneScreenRemaining(event)) {
	        if (this.isLoading || !this.hasMoreItemsToLoad) {
	          return;
	        }
	        var offset = this.itemsPerPage * this.pagesLoaded;
	        this.requestDialogList(offset);
	      }
	    }
	  },
	  // language=Vue
	  template: "\n\t<div class=\"bx-livechat-help-container\" style=\" height: 100%; display: flex; flex-direction: column; justify-content: space-between;\">\n\t\t<div \n\t\t\tstyle=\"margin-top: 25px;overflow-y: scroll;position:relative\"\n\t\t\t:style=\"{marginBottom: newChatMode ? 0 : '10px'}\"\n\t\t\t@scroll=\"onScroll\"\n\t\t>\n\t\t\t<div\n\t\t\t\tv-for=\"session in sessionList\"\n\t\t\t\t:key=\"session.chatId\"\n\t\t\t\tclass=\"bx-livechat-help-subtitle\"\n\t\t\t\t@click=\"openSession({event: $event, session: session})\"\n\t\t\t\tstyle=\"cursor: pointer; border: solid 1px black;border-radius: 10px;margin: 10px;padding: 5px;background-color: #0ae4ff\">\n\t\t\t\t{{ session.name }}\n\t\t\t</div>\n\t\t\t<div v-if=\"isLoading\" style=\"margin: 10px\">Loading</div>\n\t\t</div>\n\t\t\n\t\t<div v-if=\"!newChatMode\" style=\"margin-bottom: 10px;\">\n\t\t\t<button \n\t\t\t\tclass=\"bx-livechat-btn\" \n\t\t\t\tstyle=\"background-color: rgb(23, 163, 234); border-radius: 5px;width: 150px;\" \n\t\t\t\t@click=\"startNewChat\">\n\t\t\t\tStart new chat!\n\t\t\t</button>\n\t\t</div>\n\t</div>\n\t"
	});

	/**
	 * Bitrix OpenLines widget
	 * Body orientation disabled component (Vue component)
	 *
	 * @package bitrix
	 * @subpackage imopenlines
	 * @copyright 2001-2019 Bitrix
	 */
	ui_vue.WidgetBitrixVue.component('bx-livechat-body-orientation-disabled', {
	  template: "\n\t\t<div class=\"bx-livechat-body\" key=\"orientation-head\">\n\t\t\t<div class=\"bx-livechat-mobile-orientation-box\">\n\t\t\t\t<div class=\"bx-livechat-mobile-orientation-icon\"></div>\n\t\t\t\t<div class=\"bx-livechat-mobile-orientation-text\">{{$Bitrix.Loc.getMessage('BX_LIVECHAT_MOBILE_ROTATE')}}</div>\n\t\t\t</div>\n\t\t</div>\n\t"
	});

	function ownKeys$6(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
	function _objectSpread$6(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$6(Object(source), !0).forEach(function (key) { babelHelpers.defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$6(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
	ui_vue.WidgetBitrixVue.component('bx-livechat-form-consent', {
	  computed: _objectSpread$6({}, ui_vue_vuex.WidgetVuex.mapState({
	    widget: function widget(state) {
	      return state.widget;
	    }
	  })),
	  methods: {
	    agree: function agree() {
	      main_core_events.EventEmitter.emit(WidgetEventType.acceptConsent);
	    },
	    disagree: function disagree() {
	      main_core_events.EventEmitter.emit(WidgetEventType.declineConsent);
	    },
	    onShow: function onShow(element, done) {
	      element.classList.add('bx-livechat-consent-window-show');
	      done();
	    },
	    onHide: function onHide(element, done) {
	      element.classList.remove('bx-livechat-consent-window-show');
	      element.classList.add('bx-livechat-consent-window-close');
	      setTimeout(function () {
	        done();
	      }, 400);
	    },
	    onKeyDown: function onKeyDown(event) {
	      if (event.keyCode == 9) {
	        if (event.target === this.$refs.iframe) {
	          if (event.shiftKey) {
	            this.$refs.cancel.focus();
	          } else {
	            this.$refs.success.focus();
	          }
	        } else if (event.target === this.$refs.success) {
	          if (event.shiftKey) {
	            this.$refs.iframe.focus();
	          } else {
	            this.$refs.cancel.focus();
	          }
	        } else if (event.target === this.$refs.cancel) {
	          if (event.shiftKey) {
	            this.$refs.success.focus();
	          } else {
	            this.$refs.iframe.focus();
	          }
	        }
	        event.preventDefault();
	      } else if (event.keyCode == 39 || event.keyCode == 37) {
	        if (event.target.nextElementSibling) {
	          event.target.nextElementSibling.focus();
	        } else if (event.target.previousElementSibling) {
	          event.target.previousElementSibling.focus();
	        }
	        event.preventDefault();
	      }
	    }
	  },
	  directives: {
	    focus: {
	      inserted: function inserted(element, params) {
	        element.focus();
	      }
	    }
	  },
	  template: "\n\t\t<transition @enter=\"onShow\" @leave=\"onHide\">\n\t\t\t<template v-if=\"widget.common.showConsent && widget.common.consentUrl\">\n\t\t\t\t<div class=\"bx-livechat-consent-window\">\n\t\t\t\t\t<div class=\"bx-livechat-consent-window-title\">{{$Bitrix.Loc.getMessage('BX_LIVECHAT_CONSENT_TITLE')}}</div>\n\t\t\t\t\t<div class=\"bx-livechat-consent-window-content\">\n\t\t\t\t\t\t<iframe class=\"bx-livechat-consent-window-content-iframe\" ref=\"iframe\" frameborder=\"0\" marginheight=\"0\"  marginwidth=\"0\" allowtransparency=\"allow-same-origin\" seamless=\"true\" :src=\"widget.common.consentUrl\" @keydown=\"onKeyDown\"></iframe>\n\t\t\t\t\t</div>\t\t\t\t\t\t\t\t\n\t\t\t\t\t<div class=\"bx-livechat-consent-window-btn-box\">\n\t\t\t\t\t\t<button class=\"bx-livechat-btn bx-livechat-btn-success\" ref=\"success\" @click=\"agree\" @keydown=\"onKeyDown\" v-focus>{{$Bitrix.Loc.getMessage('BX_LIVECHAT_CONSENT_AGREE')}}</button>\n\t\t\t\t\t\t<button class=\"bx-livechat-btn bx-livechat-btn-cancel\" ref=\"cancel\" @click=\"disagree\" @keydown=\"onKeyDown\">{{$Bitrix.Loc.getMessage('BX_LIVECHAT_CONSENT_DISAGREE')}}</button>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t</template>\n\t\t</transition>\n\t"
	});

	function ownKeys$7(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
	function _objectSpread$7(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$7(Object(source), !0).forEach(function (key) { babelHelpers.defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$7(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
	ui_vue.WidgetBitrixVue.component('bx-livechat-form-vote', {
	  computed: _objectSpread$7({
	    VoteType: function VoteType$$1() {
	      return VoteType;
	    }
	  }, ui_vue_vuex.WidgetVuex.mapState({
	    widget: function widget(state) {
	      return state.widget;
	    }
	  })),
	  methods: {
	    userVote: function userVote(vote) {
	      main_core_events.EventEmitter.emit(WidgetEventType.hideForm);
	      this.$store.commit('widget/dialog', {
	        userVote: vote
	      });
	      main_core_events.EventEmitter.emit(WidgetEventType.sendDialogVote, {
	        vote: vote
	      });
	    },
	    hideForm: function hideForm() {
	      main_core_events.EventEmitter.emit(WidgetEventType.hideForm);
	    }
	  },
	  template: "\n\t\t<transition enter-active-class=\"bx-livechat-consent-window-show\" leave-active-class=\"bx-livechat-form-close\">\n\t\t\t<div class=\"bx-livechat-alert-box bx-livechat-form-rate-show\" key=\"vote\">\n\t\t\t\t<div class=\"bx-livechat-alert-close\" :title=\"$Bitrix.Loc.getMessage('BX_LIVECHAT_VOTE_LATER')\" @click=\"hideForm\"></div>\n\t\t\t\t<div class=\"bx-livechat-alert-rate-box\">\n\t\t\t\t\t<h4 class=\"bx-livechat-alert-title bx-livechat-alert-title-mdl\">{{widget.common.vote.messageText}}</h4>\n\t\t\t\t\t<div class=\"bx-livechat-btn-box\">\n\t\t\t\t\t\t<button class=\"bx-livechat-btn bx-livechat-btn-like\" @click=\"userVote(VoteType.like)\" :title=\"widget.common.vote.messageLike\"></button>\n\t\t\t\t\t\t<button class=\"bx-livechat-btn bx-livechat-btn-dislike\" @click=\"userVote(VoteType.dislike)\" :title=\"widget.common.vote.messageDislike\"></button>\n\t\t\t\t\t</div>\n\t\t\t\t\t<div class=\"bx-livechat-alert-later\"><span class=\"bx-livechat-alert-later-btn\" @click=\"hideForm\">{{$Bitrix.Loc.getMessage('BX_LIVECHAT_VOTE_LATER')}}</span></div>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t</transition>\t\n\t"
	});

	/**
	 * Bitrix OpenLines widget
	 * Smiles component (Vue component)
	 *
	 * @package bitrix
	 * @subpackage imopenlines
	 * @copyright 2001-2019 Bitrix
	 */
	ui_vue.WidgetVue.cloneComponent('bx-livechat-smiles', 'bx-smiles', {
	  methods: {
	    hideForm: function hideForm() {
	      main_core_events.EventEmitter.emit(WidgetEventType.hideForm);
	    }
	  },
	  template: "\n\t\t<transition enter-active-class=\"bx-livechat-consent-window-show\" leave-active-class=\"bx-livechat-form-close\">\n\t\t\t<div class=\"bx-livechat-alert-box bx-livechat-alert-box-zero-padding bx-livechat-form-show\" key=\"vote\">\n\t\t\t\t<div class=\"bx-livechat-alert-close\" @click=\"hideForm\"></div>\n\t\t\t\t<div class=\"bx-livechat-alert-smiles-box\">\n\t\t\t\t\t#PARENT_TEMPLATE#\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t</transition>\n\t"
	});

	/**
	 * Bitrix OpenLines widget
	 * Widget component & controller
	 *
	 * @package bitrix
	 * @subpackage imopenlines
	 * @copyright 2001-2019 Bitrix
	 */
	BX.LiveChatWidget = WidgetPublicManager;
	BX.LiveChatWidget.VoteType = VoteType;
	BX.LiveChatWidget.SubscriptionType = SubscriptionType;
	BX.LiveChatWidget.LocationStyle = LocationStyle;
	BX.LiveChatWidget.Cookie = im_lib_cookie.Cookie;
	window.dispatchEvent(new CustomEvent('onBitrixLiveChatSourceLoaded', {
	  detail: {}
	}));

}((this.window = this.window || {}),BX,window,BX.Messenger,window,BX,window,window,BX,BX.Messenger.Provider.Rest,BX.Main,BX,BX.Ui.Vue.Components.Crm,BX.Messenger,BX.Messenger.Lib,BX.Messenger.Lib,BX.Messenger.Lib,BX,BX.Messenger.Lib,BX,BX.Messenger.Lib,BX.Messenger.EventHandler,BX.Messenger.Const,BX,BX,BX,BX.Event));



