this.BX=this.BX||{};this.BX.Crm=this.BX.Crm||{};(function(e,t,r){"use strict";const s={SERVER_TO_UTC:t.Text.toInteger(t.Loc.getMessage("SERVER_TZ_OFFSET")),USER_TO_SERVER:t.Text.toInteger(t.Loc.getMessage("USER_TZ_OFFSET")),BROWSER_TO_UTC:-t.Text.toInteger((new Date).getTimezoneOffset()*60)};Object.freeze(s);var a=babelHelpers.classPrivateFieldLooseKey("browserToUtc");var o=babelHelpers.classPrivateFieldLooseKey("normalizeTimestampFromArgs");class i{static serverToUser(e){e=babelHelpers.classPrivateFieldLooseBase(this,o)[o](e);return e+s.USER_TO_SERVER}static userToServer(e){e=babelHelpers.classPrivateFieldLooseBase(this,o)[o](e);return e-s.USER_TO_SERVER}static browserToUser(e){e=babelHelpers.classPrivateFieldLooseBase(this,o)[o](e);return e+s.USER_TO_SERVER}static browserToServer(e){e=babelHelpers.classPrivateFieldLooseBase(this,o)[o](e);return babelHelpers.classPrivateFieldLooseBase(this,a)[a](e)+s.SERVER_TO_UTC}static userToBrowser(e){e=babelHelpers.classPrivateFieldLooseBase(this,o)[o](e);return e+s.BROWSER_TO_UTC-s.SERVER_TO_UTC-s.USER_TO_SERVER}static serverToBrowser(e){e=babelHelpers.classPrivateFieldLooseBase(this,o)[o](e);return e+s.BROWSER_TO_UTC-s.SERVER_TO_UTC}}function n(e){e=babelHelpers.classPrivateFieldLooseBase(this,o)[o](e);return e-s.BROWSER_TO_UTC}function l(e){const r=t.Text.toInteger(e);if(r<0){throw new Error("BX.Crm.DateTime.TimestampConverter: input timestamp could not be negative")}return r}Object.defineProperty(i,o,{value:l});Object.defineProperty(i,a,{value:n});var T=babelHelpers.classPrivateFieldLooseKey("getBrowserNowTimestamp");class c{static getUserNow(){const e=i.browserToUser(babelHelpers.classPrivateFieldLooseBase(this,T)[T]());return new Date(e*1e3)}static getServerNow(){const e=i.browserToServer(babelHelpers.classPrivateFieldLooseBase(this,T)[T]());return new Date(e*1e3)}static createFromTimestampInUserTimezone(e){const t=i.browserToUser(e);return new Date(t*1e3)}static createFromTimestampInServerTimezone(e){const t=i.browserToServer(e);return new Date(t*1e3)}}function m(){return Math.floor(Date.now()/1e3)}Object.defineProperty(c,T,{value:m});const b={};const E=t.Extension.getSettings("crm.datetime").get("formats",{});for(const e in E){if(E.hasOwnProperty(e)&&t.Type.isStringFilled(E[e])){let t=E[e];if(e==="FORMAT_DATE"||e==="FORMAT_DATETIME"){t=r.DateTimeFormat.convertBitrixFormat(t)}b[e]=t}}Object.freeze(b);const R=t.Reflection.namespace("BX.Crm.DateTime");R.Factory=c;R.TimestampConverter=i;R.Dictionary={TimezoneOffset:s,Format:b};e.Factory=c;e.TimestampConverter=i;e.TimezoneOffset=s;e.Format=b})(this.BX.Crm.DateTime=this.BX.Crm.DateTime||{},BX,BX.Main);
//# sourceMappingURL=datetime.bundle.map.js